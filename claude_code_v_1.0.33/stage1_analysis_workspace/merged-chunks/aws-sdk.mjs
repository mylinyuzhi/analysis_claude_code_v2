
// @from(Start 2185535, End 2210278)
bbA = L(() => {
  P4A = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date, Bo0 = new Set, mz1 = typeof process === "object" && !!process ? process : {}, vbA = globalThis.AbortController, Qo0 = globalThis.AbortSignal;
  if (typeof vbA > "u") {
    Qo0 = class {
      onabort;
      _onabort = [];
      reason;
      aborted = !1;
      addEventListener(G, Z) {
        this._onabort.push(Z)
      }
    }, vbA = class {
      constructor() {
        Q()
      }
      signal = new Qo0;
      abort(G) {
        if (this.signal.aborted) return;
        this.signal.reason = G, this.signal.aborted = !0;
        for (let Z of this.signal._onabort) Z(G);
        this.signal.onabort?.(G)
      }
    };
    let A = mz1.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1",
      Q = () => {
        if (!A) return;
        A = !1, Go0("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", Q)
      }
  }
  uK7 = Symbol("type");
  TDA = class TDA extends Array {
    constructor(A) {
      super(A);
      this.fill(0)
    }
  };
  tm = class tm {
    #A;
    #Q;
    #B;
    #Z;
    #G;
    #J;
    ttl;
    ttlResolution;
    ttlAutopurge;
    updateAgeOnGet;
    updateAgeOnHas;
    allowStale;
    noDisposeOnSet;
    noUpdateTTL;
    maxEntrySize;
    sizeCalculation;
    noDeleteOnFetchRejection;
    noDeleteOnStaleGet;
    allowStaleOnFetchAbort;
    allowStaleOnFetchRejection;
    ignoreFetchAbort;
    #I;
    #V;
    #F;
    #W;
    #Y;
    #C;
    #z;
    #H;
    #K;
    #w;
    #D;
    #q;
    #N;
    #U;
    #L;
    #P;
    #E;
    static unsafeExposeInternals(A) {
      return {
        starts: A.#N,
        ttls: A.#U,
        sizes: A.#q,
        keyMap: A.#F,
        keyList: A.#W,
        valList: A.#Y,
        next: A.#C,
        prev: A.#z,
        get head() {
          return A.#H
        },
        get tail() {
          return A.#K
        },
        free: A.#w,
        isBackgroundFetch: (Q) => A.#X(Q),
        backgroundFetch: (Q, B, G, Z) => A.#x(Q, B, G, Z),
        moveToTail: (Q) => A.#_(Q),
        indexes: (Q) => A.#M(Q),
        rindexes: (Q) => A.#O(Q),
        isStale: (Q) => A.#$(Q)
      }
    }
    get max() {
      return this.#A
    }
    get maxSize() {
      return this.#Q
    }
    get calculatedSize() {
      return this.#V
    }
    get size() {
      return this.#I
    }
    get fetchMethod() {
      return this.#G
    }
    get memoMethod() {
      return this.#J
    }
    get dispose() {
      return this.#B
    }
    get disposeAfter() {
      return this.#Z
    }
    constructor(A) {
      let {
        max: Q = 0,
        ttl: B,
        ttlResolution: G = 1,
        ttlAutopurge: Z,
        updateAgeOnGet: I,
        updateAgeOnHas: Y,
        allowStale: J,
        dispose: W,
        disposeAfter: X,
        noDisposeOnSet: V,
        noUpdateTTL: F,
        maxSize: K = 0,
        maxEntrySize: D = 0,
        sizeCalculation: H,
        fetchMethod: C,
        memoMethod: E,
        noDeleteOnFetchRejection: U,
        noDeleteOnStaleGet: q,
        allowStaleOnFetchRejection: w,
        allowStaleOnFetchAbort: N,
        ignoreFetchAbort: R
      } = A;
      if (Q !== 0 && !om(Q)) throw TypeError("max option must be a nonnegative integer");
      let T = Q ? Zo0(Q) : Array;
      if (!T) throw Error("invalid max value: " + Q);
      if (this.#A = Q, this.#Q = K, this.maxEntrySize = D || this.#Q, this.sizeCalculation = H, this.sizeCalculation) {
        if (!this.#Q && !this.maxEntrySize) throw TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        if (typeof this.sizeCalculation !== "function") throw TypeError("sizeCalculation set to non-function")
      }
      if (E !== void 0 && typeof E !== "function") throw TypeError("memoMethod must be a function if defined");
      if (this.#J = E, C !== void 0 && typeof C !== "function") throw TypeError("fetchMethod must be a function if specified");
      if (this.#G = C, this.#P = !!C, this.#F = new Map, this.#W = Array(Q).fill(void 0), this.#Y = Array(Q).fill(void 0), this.#C = new T(Q), this.#z = new T(Q), this.#H = 0, this.#K = 0, this.#w = j4A.create(Q), this.#I = 0, this.#V = 0, typeof W === "function") this.#B = W;
      if (typeof X === "function") this.#Z = X, this.#D = [];
      else this.#Z = void 0, this.#D = void 0;
      if (this.#L = !!this.#B, this.#E = !!this.#Z, this.noDisposeOnSet = !!V, this.noUpdateTTL = !!F, this.noDeleteOnFetchRejection = !!U, this.allowStaleOnFetchRejection = !!w, this.allowStaleOnFetchAbort = !!N, this.ignoreFetchAbort = !!R, this.maxEntrySize !== 0) {
        if (this.#Q !== 0) {
          if (!om(this.#Q)) throw TypeError("maxSize must be a positive integer if specified")
        }
        if (!om(this.maxEntrySize)) throw TypeError("maxEntrySize must be a positive integer if specified");
        this.#m()
      }
      if (this.allowStale = !!J, this.noDeleteOnStaleGet = !!q, this.updateAgeOnGet = !!I, this.updateAgeOnHas = !!Y, this.ttlResolution = om(G) || G === 0 ? G : 1, this.ttlAutopurge = !!Z, this.ttl = B || 0, this.ttl) {
        if (!om(this.ttl)) throw TypeError("ttl must be a positive integer if specified");
        this.#v()
      }
      if (this.#A === 0 && this.ttl === 0 && this.#Q === 0) throw TypeError("At least one of max, maxSize, or ttl is required");
      if (!this.ttlAutopurge && !this.#A && !this.#Q) {
        if (OX4("LRU_CACHE_UNBOUNDED")) Bo0.add("LRU_CACHE_UNBOUNDED"), Go0("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", "LRU_CACHE_UNBOUNDED", tm)
      }
    }
    getRemainingTTL(A) {
      return this.#F.has(A) ? 1 / 0 : 0
    }
    #v() {
      let A = new TDA(this.#A),
        Q = new TDA(this.#A);
      this.#U = A, this.#N = Q, this.#b = (Z, I, Y = P4A.now()) => {
        if (Q[Z] = I !== 0 ? Y : 0, A[Z] = I, I !== 0 && this.ttlAutopurge) {
          let J = setTimeout(() => {
            if (this.#$(Z)) this.#R(this.#W[Z], "expire")
          }, I + 1);
          if (J.unref) J.unref()
        }
      }, this.#j = (Z) => {
        Q[Z] = A[Z] !== 0 ? P4A.now() : 0
      }, this.#T = (Z, I) => {
        if (A[I]) {
          let Y = A[I],
            J = Q[I];
          if (!Y || !J) return;
          Z.ttl = Y, Z.start = J, Z.now = B || G();
          let W = Z.now - J;
          Z.remainingTTL = Y - W
        }
      };
      let B = 0,
        G = () => {
          let Z = P4A.now();
          if (this.ttlResolution > 0) {
            B = Z;
            let I = setTimeout(() => B = 0, this.ttlResolution);
            if (I.unref) I.unref()
          }
          return Z
        };
      this.getRemainingTTL = (Z) => {
        let I = this.#F.get(Z);
        if (I === void 0) return 0;
        let Y = A[I],
          J = Q[I];
        if (!Y || !J) return 1 / 0;
        let W = (B || G()) - J;
        return Y - W
      }, this.#$ = (Z) => {
        let I = Q[Z],
          Y = A[Z];
        return !!Y && !!I && (B || G()) - I > Y
      }
    }
    #j = () => {};
    #T = () => {};
    #b = () => {};
    #$ = () => !1;
    #m() {
      let A = new TDA(this.#A);
      this.#V = 0, this.#q = A, this.#S = (Q) => {
        this.#V -= A[Q], A[Q] = 0
      }, this.#f = (Q, B, G, Z) => {
        if (this.#X(B)) return 0;
        if (!om(G))
          if (Z) {
            if (typeof Z !== "function") throw TypeError("sizeCalculation must be a function");
            if (G = Z(B, Q), !om(G)) throw TypeError("sizeCalculation return invalid (expect positive integer)")
          } else throw TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        return G
      }, this.#k = (Q, B, G) => {
        if (A[Q] = B, this.#Q) {
          let Z = this.#Q - A[Q];
          while (this.#V > Z) this.#y(!0)
        }
        if (this.#V += A[Q], G) G.entrySize = B, G.totalCalculatedSize = this.#V
      }
    }
    #S = (A) => {};
    #k = (A, Q, B) => {};
    #f = (A, Q, B, G) => {
      if (B || G) throw TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0
    };* #M({
      allowStale: A = this.allowStale
    } = {}) {
      if (this.#I)
        for (let Q = this.#K;;) {
          if (!this.#h(Q)) break;
          if (A || !this.#$(Q)) yield Q;
          if (Q === this.#H) break;
          else Q = this.#z[Q]
        }
    }* #O({
      allowStale: A = this.allowStale
    } = {}) {
      if (this.#I)
        for (let Q = this.#H;;) {
          if (!this.#h(Q)) break;
          if (A || !this.#$(Q)) yield Q;
          if (Q === this.#K) break;
          else Q = this.#C[Q]
        }
    }
    #h(A) {
      return A !== void 0 && this.#F.get(this.#W[A]) === A
    }* entries() {
      for (let A of this.#M())
        if (this.#Y[A] !== void 0 && this.#W[A] !== void 0 && !this.#X(this.#Y[A])) yield [this.#W[A], this.#Y[A]]
    }* rentries() {
      for (let A of this.#O())
        if (this.#Y[A] !== void 0 && this.#W[A] !== void 0 && !this.#X(this.#Y[A])) yield [this.#W[A], this.#Y[A]]
    }* keys() {
      for (let A of this.#M()) {
        let Q = this.#W[A];
        if (Q !== void 0 && !this.#X(this.#Y[A])) yield Q
      }
    }* rkeys() {
      for (let A of this.#O()) {
        let Q = this.#W[A];
        if (Q !== void 0 && !this.#X(this.#Y[A])) yield Q
      }
    }* values() {
      for (let A of this.#M())
        if (this.#Y[A] !== void 0 && !this.#X(this.#Y[A])) yield this.#Y[A]
    }* rvalues() {
      for (let A of this.#O())
        if (this.#Y[A] !== void 0 && !this.#X(this.#Y[A])) yield this.#Y[A]
    } [Symbol.iterator]() {
      return this.entries()
    } [Symbol.toStringTag] = "LRUCache";
    find(A, Q = {}) {
      for (let B of this.#M()) {
        let G = this.#Y[B],
          Z = this.#X(G) ? G.__staleWhileFetching : G;
        if (Z === void 0) continue;
        if (A(Z, this.#W[B], this)) return this.get(this.#W[B], Q)
      }
    }
    forEach(A, Q = this) {
      for (let B of this.#M()) {
        let G = this.#Y[B],
          Z = this.#X(G) ? G.__staleWhileFetching : G;
        if (Z === void 0) continue;
        A.call(Q, Z, this.#W[B], this)
      }
    }
    rforEach(A, Q = this) {
      for (let B of this.#O()) {
        let G = this.#Y[B],
          Z = this.#X(G) ? G.__staleWhileFetching : G;
        if (Z === void 0) continue;
        A.call(Q, Z, this.#W[B], this)
      }
    }
    purgeStale() {
      let A = !1;
      for (let Q of this.#O({
          allowStale: !0
        }))
        if (this.#$(Q)) this.#R(this.#W[Q], "expire"), A = !0;
      return A
    }
    info(A) {
      let Q = this.#F.get(A);
      if (Q === void 0) return;
      let B = this.#Y[Q],
        G = this.#X(B) ? B.__staleWhileFetching : B;
      if (G === void 0) return;
      let Z = {
        value: G
      };
      if (this.#U && this.#N) {
        let I = this.#U[Q],
          Y = this.#N[Q];
        if (I && Y) {
          let J = I - (P4A.now() - Y);
          Z.ttl = J, Z.start = Date.now()
        }
      }
      if (this.#q) Z.size = this.#q[Q];
      return Z
    }
    dump() {
      let A = [];
      for (let Q of this.#M({
          allowStale: !0
        })) {
        let B = this.#W[Q],
          G = this.#Y[Q],
          Z = this.#X(G) ? G.__staleWhileFetching : G;
        if (Z === void 0 || B === void 0) continue;
        let I = {
          value: Z
        };
        if (this.#U && this.#N) {
          I.ttl = this.#U[Q];
          let Y = P4A.now() - this.#N[Q];
          I.start = Math.floor(Date.now() - Y)
        }
        if (this.#q) I.size = this.#q[Q];
        A.unshift([B, I])
      }
      return A
    }
    load(A) {
      this.clear();
      for (let [Q, B] of A) {
        if (B.start) {
          let G = Date.now() - B.start;
          B.start = P4A.now() - G
        }
        this.set(Q, B.value, B)
      }
    }
    set(A, Q, B = {}) {
      if (Q === void 0) return this.delete(A), this;
      let {
        ttl: G = this.ttl,
        start: Z,
        noDisposeOnSet: I = this.noDisposeOnSet,
        sizeCalculation: Y = this.sizeCalculation,
        status: J
      } = B, {
        noUpdateTTL: W = this.noUpdateTTL
      } = B, X = this.#f(A, Q, B.size || 0, Y);
      if (this.maxEntrySize && X > this.maxEntrySize) {
        if (J) J.set = "miss", J.maxEntrySizeExceeded = !0;
        return this.#R(A, "set"), this
      }
      let V = this.#I === 0 ? void 0 : this.#F.get(A);
      if (V === void 0) {
        if (V = this.#I === 0 ? this.#K : this.#w.length !== 0 ? this.#w.pop() : this.#I === this.#A ? this.#y(!1) : this.#I, this.#W[V] = A, this.#Y[V] = Q, this.#F.set(A, V), this.#C[this.#K] = V, this.#z[V] = this.#K, this.#K = V, this.#I++, this.#k(V, X, J), J) J.set = "add";
        W = !1
      } else {
        this.#_(V);
        let F = this.#Y[V];
        if (Q !== F) {
          if (this.#P && this.#X(F)) {
            F.__abortController.abort(Error("replaced"));
            let {
              __staleWhileFetching: K
            } = F;
            if (K !== void 0 && !I) {
              if (this.#L) this.#B?.(K, A, "set");
              if (this.#E) this.#D?.push([K, A, "set"])
            }
          } else if (!I) {
            if (this.#L) this.#B?.(F, A, "set");
            if (this.#E) this.#D?.push([F, A, "set"])
          }
          if (this.#S(V), this.#k(V, X, J), this.#Y[V] = Q, J) {
            J.set = "replace";
            let K = F && this.#X(F) ? F.__staleWhileFetching : F;
            if (K !== void 0) J.oldValue = K
          }
        } else if (J) J.set = "update"
      }
      if (G !== 0 && !this.#U) this.#v();
      if (this.#U) {
        if (!W) this.#b(V, G, Z);
        if (J) this.#T(J, V)
      }
      if (!I && this.#E && this.#D) {
        let F = this.#D,
          K;
        while (K = F?.shift()) this.#Z?.(...K)
      }
      return this
    }
    pop() {
      try {
        while (this.#I) {
          let A = this.#Y[this.#H];
          if (this.#y(!0), this.#X(A)) {
            if (A.__staleWhileFetching) return A.__staleWhileFetching
          } else if (A !== void 0) return A
        }
      } finally {
        if (this.#E && this.#D) {
          let A = this.#D,
            Q;
          while (Q = A?.shift()) this.#Z?.(...Q)
        }
      }
    }
    #y(A) {
      let Q = this.#H,
        B = this.#W[Q],
        G = this.#Y[Q];
      if (this.#P && this.#X(G)) G.__abortController.abort(Error("evicted"));
      else if (this.#L || this.#E) {
        if (this.#L) this.#B?.(G, B, "evict");
        if (this.#E) this.#D?.push([G, B, "evict"])
      }
      if (this.#S(Q), A) this.#W[Q] = void 0, this.#Y[Q] = void 0, this.#w.push(Q);
      if (this.#I === 1) this.#H = this.#K = 0, this.#w.length = 0;
      else this.#H = this.#C[Q];
      return this.#F.delete(B), this.#I--, Q
    }
    has(A, Q = {}) {
      let {
        updateAgeOnHas: B = this.updateAgeOnHas,
        status: G
      } = Q, Z = this.#F.get(A);
      if (Z !== void 0) {
        let I = this.#Y[Z];
        if (this.#X(I) && I.__staleWhileFetching === void 0) return !1;
        if (!this.#$(Z)) {
          if (B) this.#j(Z);
          if (G) G.has = "hit", this.#T(G, Z);
          return !0
        } else if (G) G.has = "stale", this.#T(G, Z)
      } else if (G) G.has = "miss";
      return !1
    }
    peek(A, Q = {}) {
      let {
        allowStale: B = this.allowStale
      } = Q, G = this.#F.get(A);
      if (G === void 0 || !B && this.#$(G)) return;
      let Z = this.#Y[G];
      return this.#X(Z) ? Z.__staleWhileFetching : Z
    }
    #x(A, Q, B, G) {
      let Z = Q === void 0 ? void 0 : this.#Y[Q];
      if (this.#X(Z)) return Z;
      let I = new vbA,
        {
          signal: Y
        } = B;
      Y?.addEventListener("abort", () => I.abort(Y.reason), {
        signal: I.signal
      });
      let J = {
          signal: I.signal,
          options: B,
          context: G
        },
        W = (H, C = !1) => {
          let {
            aborted: E
          } = I.signal, U = B.ignoreFetchAbort && H !== void 0;
          if (B.status)
            if (E && !C) {
              if (B.status.fetchAborted = !0, B.status.fetchError = I.signal.reason, U) B.status.fetchAbortIgnored = !0
            } else B.status.fetchResolved = !0;
          if (E && !U && !C) return V(I.signal.reason);
          let q = K;
          if (this.#Y[Q] === K)
            if (H === void 0)
              if (q.__staleWhileFetching) this.#Y[Q] = q.__staleWhileFetching;
              else this.#R(A, "fetch");
          else {
            if (B.status) B.status.fetchUpdated = !0;
            this.set(A, H, J.options)
          }
          return H
        },
        X = (H) => {
          if (B.status) B.status.fetchRejected = !0, B.status.fetchError = H;
          return V(H)
        },
        V = (H) => {
          let {
            aborted: C
          } = I.signal, E = C && B.allowStaleOnFetchAbort, U = E || B.allowStaleOnFetchRejection, q = U || B.noDeleteOnFetchRejection, w = K;
          if (this.#Y[Q] === K) {
            if (!q || w.__staleWhileFetching === void 0) this.#R(A, "fetch");
            else if (!E) this.#Y[Q] = w.__staleWhileFetching
          }
          if (U) {
            if (B.status && w.__staleWhileFetching !== void 0) B.status.returnedStale = !0;
            return w.__staleWhileFetching
          } else if (w.__returned === w) throw H
        },
        F = (H, C) => {
          let E = this.#G?.(A, Z, J);
          if (E && E instanceof Promise) E.then((U) => H(U === void 0 ? void 0 : U), C);
          I.signal.addEventListener("abort", () => {
            if (!B.ignoreFetchAbort || B.allowStaleOnFetchAbort) {
              if (H(void 0), B.allowStaleOnFetchAbort) H = (U) => W(U, !0)
            }
          })
        };
      if (B.status) B.status.fetchDispatched = !0;
      let K = new Promise(F).then(W, X),
        D = Object.assign(K, {
          __abortController: I,
          __staleWhileFetching: Z,
          __returned: void 0
        });
      if (Q === void 0) this.set(A, D, {
        ...J.options,
        status: void 0
      }), Q = this.#F.get(A);
      else this.#Y[Q] = D;
      return D
    }
    #X(A) {
      if (!this.#P) return !1;
      let Q = A;
      return !!Q && Q instanceof Promise && Q.hasOwnProperty("__staleWhileFetching") && Q.__abortController instanceof vbA
    }
    async fetch(A, Q = {}) {
      let {
        allowStale: B = this.allowStale,
        updateAgeOnGet: G = this.updateAgeOnGet,
        noDeleteOnStaleGet: Z = this.noDeleteOnStaleGet,
        ttl: I = this.ttl,
        noDisposeOnSet: Y = this.noDisposeOnSet,
        size: J = 0,
        sizeCalculation: W = this.sizeCalculation,
        noUpdateTTL: X = this.noUpdateTTL,
        noDeleteOnFetchRejection: V = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection: F = this.allowStaleOnFetchRejection,
        ignoreFetchAbort: K = this.ignoreFetchAbort,
        allowStaleOnFetchAbort: D = this.allowStaleOnFetchAbort,
        context: H,
        forceRefresh: C = !1,
        status: E,
        signal: U
      } = Q;
      if (!this.#P) {
        if (E) E.fetch = "get";
        return this.get(A, {
          allowStale: B,
          updateAgeOnGet: G,
          noDeleteOnStaleGet: Z,
          status: E
        })
      }
      let q = {
          allowStale: B,
          updateAgeOnGet: G,
          noDeleteOnStaleGet: Z,
          ttl: I,
          noDisposeOnSet: Y,
          size: J,
          sizeCalculation: W,
          noUpdateTTL: X,
          noDeleteOnFetchRejection: V,
          allowStaleOnFetchRejection: F,
          allowStaleOnFetchAbort: D,
          ignoreFetchAbort: K,
          status: E,
          signal: U
        },
        w = this.#F.get(A);
      if (w === void 0) {
        if (E) E.fetch = "miss";
        let N = this.#x(A, w, q, H);
        return N.__returned = N
      } else {
        let N = this.#Y[w];
        if (this.#X(N)) {
          let x = B && N.__staleWhileFetching !== void 0;
          if (E) {
            if (E.fetch = "inflight", x) E.returnedStale = !0
          }
          return x ? N.__staleWhileFetching : N.__returned = N
        }
        let R = this.#$(w);
        if (!C && !R) {
          if (E) E.fetch = "hit";
          if (this.#_(w), G) this.#j(w);
          if (E) this.#T(E, w);
          return N
        }
        let T = this.#x(A, w, q, H),
          v = T.__staleWhileFetching !== void 0 && B;
        if (E) {
          if (E.fetch = R ? "stale" : "refresh", v && R) E.returnedStale = !0
        }
        return v ? T.__staleWhileFetching : T.__returned = T
      }
    }
    async forceFetch(A, Q = {}) {
      let B = await this.fetch(A, Q);
      if (B === void 0) throw Error("fetch() returned undefined");
      return B
    }
    memo(A, Q = {}) {
      let B = this.#J;
      if (!B) throw Error("no memoMethod provided to constructor");
      let {
        context: G,
        forceRefresh: Z,
        ...I
      } = Q, Y = this.get(A, I);
      if (!Z && Y !== void 0) return Y;
      let J = B(A, Y, {
        options: I,
        context: G
      });
      return this.set(A, J, I), J
    }
    get(A, Q = {}) {
      let {
        allowStale: B = this.allowStale,
        updateAgeOnGet: G = this.updateAgeOnGet,
        noDeleteOnStaleGet: Z = this.noDeleteOnStaleGet,
        status: I
      } = Q, Y = this.#F.get(A);
      if (Y !== void 0) {
        let J = this.#Y[Y],
          W = this.#X(J);
        if (I) this.#T(I, Y);
        if (this.#$(Y)) {
          if (I) I.get = "stale";
          if (!W) {
            if (!Z) this.#R(A, "expire");
            if (I && B) I.returnedStale = !0;
            return B ? J : void 0
          } else {
            if (I && B && J.__staleWhileFetching !== void 0) I.returnedStale = !0;
            return B ? J.__staleWhileFetching : void 0
          }
        } else {
          if (I) I.get = "hit";
          if (W) return J.__staleWhileFetching;
          if (this.#_(Y), G) this.#j(Y);
          return J
        }
      } else if (I) I.get = "miss"
    }
    #g(A, Q) {
      this.#z[Q] = A, this.#C[A] = Q
    }
    #_(A) {
      if (A !== this.#K) {
        if (A === this.#H) this.#H = this.#C[A];
        else this.#g(this.#z[A], this.#C[A]);
        this.#g(this.#K, A), this.#K = A
      }
    }
    delete(A) {
      return this.#R(A, "delete")
    }
    #R(A, Q) {
      let B = !1;
      if (this.#I !== 0) {
        let G = this.#F.get(A);
        if (G !== void 0)
          if (B = !0, this.#I === 1) this.#u(Q);
          else {
            this.#S(G);
            let Z = this.#Y[G];
            if (this.#X(Z)) Z.__abortController.abort(Error("deleted"));
            else if (this.#L || this.#E) {
              if (this.#L) this.#B?.(Z, A, Q);
              if (this.#E) this.#D?.push([Z, A, Q])
            }
            if (this.#F.delete(A), this.#W[G] = void 0, this.#Y[G] = void 0, G === this.#K) this.#K = this.#z[G];
            else if (G === this.#H) this.#H = this.#C[G];
            else {
              let I = this.#z[G];
              this.#C[I] = this.#C[G];
              let Y = this.#C[G];
              this.#z[Y] = this.#z[G]
            }
            this.#I--, this.#w.push(G)
          }
      }
      if (this.#E && this.#D?.length) {
        let G = this.#D,
          Z;
        while (Z = G?.shift()) this.#Z?.(...Z)
      }
      return B
    }
    clear() {
      return this.#u("delete")
    }
    #u(A) {
      for (let Q of this.#O({
          allowStale: !0
        })) {
        let B = this.#Y[Q];
        if (this.#X(B)) B.__abortController.abort(Error("deleted"));
        else {
          let G = this.#W[Q];
          if (this.#L) this.#B?.(B, G, A);
          if (this.#E) this.#D?.push([B, G, A])
        }
      }
      if (this.#F.clear(), this.#Y.fill(void 0), this.#W.fill(void 0), this.#U && this.#N) this.#U.fill(0), this.#N.fill(0);
      if (this.#q) this.#q.fill(0);
      if (this.#H = 0, this.#K = 0, this.#w.length = 0, this.#V = 0, this.#I = 0, this.#E && this.#D) {
        let Q = this.#D,
          B;
        while (B = Q?.shift()) this.#Z?.(...B)
      }
    }
  }
})
// @from(Start 2210281, End 2211031)
function dz1(A, Q = 300000) {
  let B = new Map,
    G = (...Z) => {
      let I = JSON.stringify(Z),
        Y = B.get(I),
        J = Date.now();
      if (!Y) {
        let W = A(...Z);
        return B.set(I, {
          value: W,
          timestamp: J,
          refreshing: !1
        }), W
      }
      if (Y && J - Y.timestamp > Q && !Y.refreshing) return Y.refreshing = !0, Promise.resolve().then(() => {
        let W = A(...Z);
        B.set(I, {
          value: W,
          timestamp: Date.now(),
          refreshing: !1
        })
      }).catch((W) => {
        AA(W instanceof Error ? W : Error(String(W))), B.delete(I)
      }), Y.value;
      return B.get(I).value
    };
  return G.cache = {
    clear: () => B.clear()
  }, G
}
// @from(Start 2211033, End 2211761)
function fbA(A, Q = 300000) {
  let B = new Map,
    G = async (...Z) => {
      let I = JSON.stringify(Z),
        Y = B.get(I),
        J = Date.now();
      if (!Y) {
        let W = await A(...Z);
        return B.set(I, {
          value: W,
          timestamp: J,
          refreshing: !1
        }), W
      }
      if (Y && J - Y.timestamp > Q && !Y.refreshing) return Y.refreshing = !0, A(...Z).then((W) => {
        B.set(I, {
          value: W,
          timestamp: Date.now(),
          refreshing: !1
        })
      }).catch((W) => {
        AA(W instanceof Error ? W : Error(String(W))), B.delete(I)
      }), Y.value;
      return B.get(I).value
    };
  return G.cache = {
    clear: () => B.clear()
  }, G
}
// @from(Start 2211766, End 2211791)
hbA = L(() => {
  g1()
})
// @from(Start 2211794, End 2214059)
function PX4() {
  let A = new Map;
  for (let [Q, B] of Object.entries(fI)) {
    for (let [G, Z] of Object.entries(B)) fI[G] = {
      open: `\x1B[${Z[0]}m`,
      close: `\x1B[${Z[1]}m`
    }, B[G] = fI[G], A.set(Z[0], Z[1]);
    Object.defineProperty(fI, Q, {
      value: B,
      enumerable: !1
    })
  }
  return Object.defineProperty(fI, "codes", {
    value: A,
    enumerable: !1
  }), fI.color.close = "\x1B[39m", fI.bgColor.close = "\x1B[49m", fI.color.ansi = Io0(), fI.color.ansi256 = Yo0(), fI.color.ansi16m = Jo0(), fI.bgColor.ansi = Io0(10), fI.bgColor.ansi256 = Yo0(10), fI.bgColor.ansi16m = Jo0(10), Object.defineProperties(fI, {
    rgbToAnsi256: {
      value(Q, B, G) {
        if (Q === B && B === G) {
          if (Q < 8) return 16;
          if (Q > 248) return 231;
          return Math.round((Q - 8) / 247 * 24) + 232
        }
        return 16 + 36 * Math.round(Q / 255 * 5) + 6 * Math.round(B / 255 * 5) + Math.round(G / 255 * 5)
      },
      enumerable: !1
    },
    hexToRgb: {
      value(Q) {
        let B = /[a-f\d]{6}|[a-f\d]{3}/i.exec(Q.toString(16));
        if (!B) return [0, 0, 0];
        let [G] = B;
        if (G.length === 3) G = [...G].map((I) => I + I).join("");
        let Z = Number.parseInt(G, 16);
        return [Z >> 16 & 255, Z >> 8 & 255, Z & 255]
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (Q) => fI.rgbToAnsi256(...fI.hexToRgb(Q)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(Q) {
        if (Q < 8) return 30 + Q;
        if (Q < 16) return 90 + (Q - 8);
        let B, G, Z;
        if (Q >= 232) B = ((Q - 232) * 10 + 8) / 255, G = B, Z = B;
        else {
          Q -= 16;
          let J = Q % 36;
          B = Math.floor(Q / 36) / 5, G = Math.floor(J / 6) / 5, Z = J % 6 / 5
        }
        let I = Math.max(B, G, Z) * 2;
        if (I === 0) return 30;
        let Y = 30 + (Math.round(Z) << 2 | Math.round(G) << 1 | Math.round(B));
        if (I === 2) Y += 60;
        return Y
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (Q, B, G) => fI.ansi256ToAnsi(fI.rgbToAnsi256(Q, B, G)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (Q) => fI.ansi256ToAnsi(fI.hexToAnsi256(Q)),
      enumerable: !1
    }
  }), fI
}
// @from(Start 2214064, End 2214102)
Io0 = (A = 0) => (Q) => `\x1B[${Q+A}m`
// @from(Start 2214106, End 2214152)
Yo0 = (A = 0) => (Q) => `\x1B[${38+A};5;${Q}m`
// @from(Start 2214156, End 2214218)
Jo0 = (A = 0) => (Q, B, G) => `\x1B[${38+A};2;${Q};${B};${G}m`
// @from(Start 2214222, End 2214224)
fI
// @from(Start 2214226, End 2214229)
pK7
// @from(Start 2214231, End 2214234)
RX4
// @from(Start 2214236, End 2214239)
TX4
// @from(Start 2214241, End 2214244)
lK7
// @from(Start 2214246, End 2214249)
jX4
// @from(Start 2214251, End 2214253)
gR
// @from(Start 2214259, End 2215668)
Wo0 = L(() => {
  fI = {
    modifier: {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      blackBright: [90, 39],
      gray: [90, 39],
      grey: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgBlackBright: [100, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  }, pK7 = Object.keys(fI.modifier), RX4 = Object.keys(fI.color), TX4 = Object.keys(fI.bgColor), lK7 = [...RX4, ...TX4];
  jX4 = PX4(), gR = jX4
})
// @from(Start 2215758, End 2215987)
function eN(A, Q = globalThis.Deno ? globalThis.Deno.args : cz1.argv) {
  let B = A.startsWith("-") ? "" : A.length === 1 ? "-" : "--",
    G = Q.indexOf(B + A),
    Z = Q.indexOf("--");
  return G !== -1 && (Z === -1 || G < Z)
}
// @from(Start 2215989, End 2216225)
function _X4() {
  if ("FORCE_COLOR" in qJ) {
    if (qJ.FORCE_COLOR === "true") return 1;
    if (qJ.FORCE_COLOR === "false") return 0;
    return qJ.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(qJ.FORCE_COLOR, 10), 3)
  }
}
// @from(Start 2216227, End 2216358)
function kX4(A) {
  if (A === 0) return !1;
  return {
    level: A,
    hasBasic: !0,
    has256: A >= 2,
    has16m: A >= 3
  }
}
// @from(Start 2216360, End 2217872)
function yX4(A, {
  streamIsTTY: Q,
  sniffFlags: B = !0
} = {}) {
  let G = _X4();
  if (G !== void 0) gbA = G;
  let Z = B ? gbA : G;
  if (Z === 0) return 0;
  if (B) {
    if (eN("color=16m") || eN("color=full") || eN("color=truecolor")) return 3;
    if (eN("color=256")) return 2
  }
  if ("TF_BUILD" in qJ && "AGENT_NAME" in qJ) return 1;
  if (A && !Q && Z === void 0) return 0;
  let I = Z || 0;
  if (qJ.TERM === "dumb") return I;
  if (cz1.platform === "win32") {
    let Y = SX4.release().split(".");
    if (Number(Y[0]) >= 10 && Number(Y[2]) >= 10586) return Number(Y[2]) >= 14931 ? 3 : 2;
    return 1
  }
  if ("CI" in qJ) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((Y) => (Y in qJ))) return 3;
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((Y) => (Y in qJ)) || qJ.CI_NAME === "codeship") return 1;
    return I
  }
  if ("TEAMCITY_VERSION" in qJ) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(qJ.TEAMCITY_VERSION) ? 1 : 0;
  if (qJ.COLORTERM === "truecolor") return 3;
  if (qJ.TERM === "xterm-kitty") return 3;
  if ("TERM_PROGRAM" in qJ) {
    let Y = Number.parseInt((qJ.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (qJ.TERM_PROGRAM) {
      case "iTerm.app":
        return Y >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2
    }
  }
  if (/-256(color)?$/i.test(qJ.TERM)) return 2;
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(qJ.TERM)) return 1;
  if ("COLORTERM" in qJ) return 1;
  return I
}
// @from(Start 2217874, End 2217982)
function Vo0(A, Q = {}) {
  let B = yX4(A, {
    streamIsTTY: A && A.isTTY,
    ...Q
  });
  return kX4(B)
}
// @from(Start 2217987, End 2217989)
qJ
// @from(Start 2217991, End 2217994)
gbA
// @from(Start 2217996, End 2217999)
xX4
// @from(Start 2218001, End 2218004)
Fo0
// @from(Start 2218010, End 2218370)
Ko0 = L(() => {
  ({
    env: qJ
  } = cz1);
  if (eN("no-color") || eN("no-colors") || eN("color=false") || eN("color=never")) gbA = 0;
  else if (eN("color") || eN("colors") || eN("color=true") || eN("color=always")) gbA = 1;
  xX4 = {
    stdout: Vo0({
      isTTY: Xo0.isatty(1)
    }),
    stderr: Vo0({
      isTTY: Xo0.isatty(2)
    })
  }, Fo0 = xX4
})
// @from(Start 2218373, End 2218602)
function Do0(A, Q, B) {
  let G = A.indexOf(Q);
  if (G === -1) return A;
  let Z = Q.length,
    I = 0,
    Y = "";
  do Y += A.slice(I, G) + Q + B, I = G + Z, G = A.indexOf(Q, I); while (G !== -1);
  return Y += A.slice(I), Y
}
// @from(Start 2218604, End 2218842)
function Ho0(A, Q, B, G) {
  let Z = 0,
    I = "";
  do {
    let Y = A[G - 1] === "\r";
    I += A.slice(Z, Y ? G - 1 : G) + Q + (Y ? `\r
` : `
`) + B, Z = G + 1, G = A.indexOf(`
`, Z)
  } while (G !== -1);
  return I += A.slice(Z), I
}
// @from(Start 2218844, End 2218879)
function jDA(A) {
  return bX4(A)
}
// @from(Start 2218884, End 2218887)
Co0
// @from(Start 2218889, End 2218892)
Eo0
// @from(Start 2218894, End 2218897)
pz1
// @from(Start 2218899, End 2218902)
S4A
// @from(Start 2218904, End 2218907)
PDA
// @from(Start 2218909, End 2218912)
zo0
// @from(Start 2218914, End 2218917)
_4A
// @from(Start 2218919, End 2219174)
vX4 = (A, Q = {}) => {
    if (Q.level && !(Number.isInteger(Q.level) && Q.level >= 0 && Q.level <= 3)) throw Error("The `level` option should be an integer from 0 to 3");
    let B = Co0 ? Co0.level : 0;
    A.level = Q.level === void 0 ? B : Q.level
  }
// @from(Start 2219178, End 2219296)
bX4 = (A) => {
    let Q = (...B) => B.join(" ");
    return vX4(Q, A), Object.setPrototypeOf(Q, jDA.prototype), Q
  }
// @from(Start 2219300, End 2219624)
lz1 = (A, Q, B, ...G) => {
    if (A === "rgb") {
      if (Q === "ansi16m") return gR[B].ansi16m(...G);
      if (Q === "ansi256") return gR[B].ansi256(gR.rgbToAnsi256(...G));
      return gR[B].ansi(gR.rgbToAnsi(...G))
    }
    if (A === "hex") return lz1("rgb", Q, B, ...gR.hexToRgb(...G));
    return gR[B][A](...G)
  }
// @from(Start 2219628, End 2219631)
fX4
// @from(Start 2219633, End 2219636)
hX4
// @from(Start 2219638, End 2219863)
iz1 = (A, Q, B) => {
    let G, Z;
    if (B === void 0) G = A, Z = Q;
    else G = B.openAll + A, Z = Q + B.closeAll;
    return {
      open: A,
      close: Q,
      openAll: G,
      closeAll: Z,
      parent: B
    }
  }
// @from(Start 2219867, End 2220043)
ubA = (A, Q, B) => {
    let G = (...Z) => gX4(G, Z.length === 1 ? "" + Z[0] : Z.join(" "));
    return Object.setPrototypeOf(G, hX4), G[pz1] = A, G[S4A] = Q, G[PDA] = B, G
  }
// @from(Start 2220047, End 2220415)
gX4 = (A, Q) => {
    if (A.level <= 0 || !Q) return A[PDA] ? "" : Q;
    let B = A[S4A];
    if (B === void 0) return Q;
    let {
      openAll: G,
      closeAll: Z
    } = B;
    if (Q.includes("\x1B"))
      while (B !== void 0) Q = Do0(Q, B.close, B.open), B = B.parent;
    let I = Q.indexOf(`
`);
    if (I !== -1) Q = Ho0(Q, Z, G, I);
    return G + Q + Z
  }
// @from(Start 2220419, End 2220422)
uX4
// @from(Start 2220424, End 2220427)
QD7
// @from(Start 2220429, End 2220431)
tA
// @from(Start 2220437, End 2222078)
F9 = L(() => {
  Wo0();
  Ko0();
  ({
    stdout: Co0,
    stderr: Eo0
  } = Fo0), pz1 = Symbol("GENERATOR"), S4A = Symbol("STYLER"), PDA = Symbol("IS_EMPTY"), zo0 = ["ansi", "ansi", "ansi256", "ansi16m"], _4A = Object.create(null);
  Object.setPrototypeOf(jDA.prototype, Function.prototype);
  for (let [A, Q] of Object.entries(gR)) _4A[A] = {
    get() {
      let B = ubA(this, iz1(Q.open, Q.close, this[S4A]), this[PDA]);
      return Object.defineProperty(this, A, {
        value: B
      }), B
    }
  };
  _4A.visible = {
    get() {
      let A = ubA(this, this[S4A], !0);
      return Object.defineProperty(this, "visible", {
        value: A
      }), A
    }
  };
  fX4 = ["rgb", "hex", "ansi256"];
  for (let A of fX4) {
    _4A[A] = {
      get() {
        let {
          level: B
        } = this;
        return function(...G) {
          let Z = iz1(lz1(A, zo0[B], "color", ...G), gR.color.close, this[S4A]);
          return ubA(this, Z, this[PDA])
        }
      }
    };
    let Q = "bg" + A[0].toUpperCase() + A.slice(1);
    _4A[Q] = {
      get() {
        let {
          level: B
        } = this;
        return function(...G) {
          let Z = iz1(lz1(A, zo0[B], "bgColor", ...G), gR.bgColor.close, this[S4A]);
          return ubA(this, Z, this[PDA])
        }
      }
    }
  }
  hX4 = Object.defineProperties(() => {}, {
    ..._4A,
    level: {
      enumerable: !0,
      get() {
        return this[pz1].level
      },
      set(A) {
        this[pz1].level = A
      }
    }
  });
  Object.defineProperties(jDA.prototype, _4A);
  uX4 = jDA(), QD7 = jDA({
    level: Eo0 ? Eo0.level : 0
  }), tA = uX4
})
// @from(Start 2222081, End 2222689)
function Uo0(A, Q) {
  return {
    name: `${A.name}-with-${Q.name}-fallback`,
    read() {
      let B = A.read();
      if (B !== null && B !== void 0) return B;
      return Q.read() || {}
    },
    update(B) {
      let G = A.read(),
        Z = A.update(B);
      if (Z.success) {
        if (G === null) Q.delete();
        return Z
      }
      let I = Q.update(B);
      if (I.success) return {
        success: !0,
        warning: I.warning
      };
      return {
        success: !1
      }
    },
    delete() {
      let B = A.delete(),
        G = Q.delete();
      return B || G
    }
  }
}
// @from(Start 2222777, End 2222978)
function em(A = "") {
  let Q = MQ(),
    G = !process.env.CLAUDE_CONFIG_DIR ? "" : `-${mX4("sha256").update(Q).digest("hex").substring(0,8)}`;
  return `Claude Code${e9().OAUTH_FILE_SUFFIX}${A}${G}`
}
// @from(Start 2222980, End 2223098)
function SDA() {
  try {
    return process.env.USER || dX4().username
  } catch {
    return "claude-code-user"
  }
}
// @from(Start 2223100, End 2223338)
function wo0() {
  if (process.platform !== "darwin") return !1;
  try {
    return I9A("security", ["show-keychain-info"], {
      reject: !1,
      stdio: ["ignore", "pipe", "pipe"]
    }).exitCode === 36
  } catch {
    return !1
  }
}
// @from(Start 2223343, End 2223346)
$o0
// @from(Start 2223352, End 2224497)
_DA = L(() => {
  hyA();
  hQ();
  NX();
  sFA();
  $o0 = {
    name: "keychain",
    read() {
      try {
        let A = em("-credentials"),
          Q = SDA(),
          B = tG(`security find-generic-password -a "${Q}" -w -s "${A}"`);
        if (B) return JSON.parse(B)
      } catch (A) {
        return null
      }
      return null
    },
    update(A) {
      try {
        let Q = em("-credentials"),
          B = SDA(),
          G = JSON.stringify(A),
          Z = Buffer.from(G, "utf-8").toString("hex"),
          I = `add-generic-password -U -a "${B}" -s "${Q}" -X "${Z}"
`;
        if (I9A("security", ["-i"], {
            input: I,
            stdio: ["pipe", "pipe", "pipe"],
            reject: !1
          }).exitCode !== 0) return {
          success: !1
        };
        return {
          success: !0
        }
      } catch (Q) {
        return {
          success: !1
        }
      }
    },
    delete() {
      try {
        let A = em("-credentials"),
          Q = SDA();
        return tG(`security delete-generic-password -a "${Q}" -s "${A}"`), !0
      } catch (A) {
        return !1
      }
    }
  }
})
// @from(Start 2224579, End 2224721)
function nz1() {
  let A = MQ(),
    Q = ".credentials.json";
  return {
    storageDir: A,
    storagePath: cX4(A, ".credentials.json")
  }
}
// @from(Start 2224726, End 2224729)
az1
// @from(Start 2224735, End 2225773)
qo0 = L(() => {
  AQ();
  hQ();
  az1 = {
    name: "plaintext",
    read() {
      let {
        storagePath: A
      } = nz1();
      if (RA().existsSync(A)) try {
        let Q = RA().readFileSync(A, {
          encoding: "utf8"
        });
        return JSON.parse(Q)
      } catch (Q) {
        return null
      }
      return null
    },
    update(A) {
      try {
        let {
          storageDir: Q,
          storagePath: B
        } = nz1();
        if (!RA().existsSync(Q)) RA().mkdirSync(Q);
        return RA().writeFileSync(B, JSON.stringify(A), {
          encoding: "utf8",
          flush: !1
        }), pX4(B, 384), {
          success: !0,
          warning: "Warning: Storing credentials in plaintext."
        }
      } catch (Q) {
        return {
          success: !1
        }
      }
    },
    delete() {
      let {
        storagePath: A
      } = nz1();
      if (RA().existsSync(A)) try {
        return RA().unlinkSync(A), !0
      } catch (Q) {
        return !1
      }
      return !0
    }
  }
})
// @from(Start 2225776, End 2225865)
function Fw() {
  if (process.platform === "darwin") return Uo0($o0, az1);
  return az1
}
// @from(Start 2225870, End 2225905)
mbA = L(() => {
  _DA();
  qo0()
})
// @from(Start 2225908, End 2226857)
function sz1() {
  let A = sE0();
  if (A !== void 0) return A;
  let Q = process.env.CLAUDE_CODE_OAUTH_TOKEN_FILE_DESCRIPTOR;
  if (!Q) return X2A(null), null;
  let B = parseInt(Q, 10);
  if (Number.isNaN(B)) return g(`CLAUDE_CODE_OAUTH_TOKEN_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${Q}`, {
    level: "error"
  }), X2A(null), null;
  try {
    let G = RA(),
      Z = process.platform === "darwin" || process.platform === "freebsd" ? `/dev/fd/${B}` : `/proc/self/fd/${B}`,
      I = G.readFileSync(Z, {
        encoding: "utf8"
      }).trim();
    if (!I) return g("File descriptor contained empty OAuth token", {
      level: "error"
    }), X2A(null), null;
    return g(`Successfully read OAuth token from file descriptor ${B}`), X2A(I), I
  } catch (G) {
    return g(`Failed to read OAuth token from file descriptor ${B}: ${G instanceof Error?G.message:String(G)}`, {
      level: "error"
    }), X2A(null), null
  }
}
// @from(Start 2226859, End 2227788)
function rz1() {
  let A = rE0();
  if (A !== void 0) return A;
  let Q = process.env.CLAUDE_CODE_API_KEY_FILE_DESCRIPTOR;
  if (!Q) return V2A(null), null;
  let B = parseInt(Q, 10);
  if (Number.isNaN(B)) return g(`CLAUDE_CODE_API_KEY_FILE_DESCRIPTOR must be a valid file descriptor number, got: ${Q}`, {
    level: "error"
  }), V2A(null), null;
  try {
    let G = RA(),
      Z = process.platform === "darwin" || process.platform === "freebsd" ? `/dev/fd/${B}` : `/proc/self/fd/${B}`,
      I = G.readFileSync(Z, {
        encoding: "utf8"
      }).trim();
    if (!I) return g("File descriptor contained empty API key", {
      level: "error"
    }), V2A(null), null;
    return g(`Successfully read API key from file descriptor ${B}`), V2A(I), I
  } catch (G) {
    return g(`Failed to read API key from file descriptor ${B}: ${G instanceof Error?G.message:String(G)}`, {
      level: "error"
    }), V2A(null), null
  }
}
// @from(Start 2227793, End 2227834)
No0 = L(() => {
  V0();
  AQ();
  _0()
})
// @from(Start 2227836, End 2228206)
async function dbA() {
  let Q = N1().oauthAccount?.accountUuid,
    B = Kw();
  if (!Q || !B) return;
  let G = `${e9().BASE_API_URL}/api/claude_cli_profile`;
  try {
    return (await YQ.get(G, {
      headers: {
        "x-api-key": B,
        "anthropic-beta": $4A
      },
      params: {
        account_uuid: Q
      }
    })).data
  } catch (Z) {
    AA(Z)
  }
}
// @from(Start 2228207, End 2228471)
async function k4A(A) {
  let Q = `${e9().BASE_API_URL}/api/oauth/profile`;
  try {
    return (await YQ.get(Q, {
      headers: {
        Authorization: `Bearer ${A}`,
        "Content-Type": "application/json"
      }
    })).data
  } catch (B) {
    AA(B)
  }
}
// @from(Start 2228476, End 2228533)
kDA = L(() => {
  O3();
  NX();
  gB();
  jQ();
  g1()
})
// @from(Start 2228536, End 2228589)
function wv(A) {
  return Boolean(A?.includes(wbA))
}
// @from(Start 2228591, End 2228655)
function cbA(A) {
  return A?.split(" ").filter(Boolean) ?? []
}
// @from(Start 2228657, End 2229406)
function oz1({
  codeChallenge: A,
  state: Q,
  port: B,
  isManual: G,
  loginWithClaudeAi: Z,
  inferenceOnly: I,
  orgUUID: Y
}) {
  let J = Z ? e9().CLAUDE_AI_AUTHORIZE_URL : e9().CONSOLE_AUTHORIZE_URL,
    W = new URL(J);
  W.searchParams.append("code", "true"), W.searchParams.append("client_id", e9().CLIENT_ID), W.searchParams.append("response_type", "code"), W.searchParams.append("redirect_uri", G ? e9().MANUAL_REDIRECT_URL : `http://localhost:${B}/callback`);
  let X = I ? [wbA] : Dr0;
  if (W.searchParams.append("scope", X.join(" ")), W.searchParams.append("code_challenge", A), W.searchParams.append("code_challenge_method", "S256"), W.searchParams.append("state", Q), Y) W.searchParams.append("orgUUID", Y);
  return W.toString()
}
// @from(Start 2229407, End 2230048)
async function Lo0(A, Q, B, G, Z = !1, I) {
  let Y = {
    grant_type: "authorization_code",
    code: A,
    redirect_uri: Z ? e9().MANUAL_REDIRECT_URL : `http://localhost:${G}/callback`,
    client_id: e9().CLIENT_ID,
    code_verifier: B,
    state: Q
  };
  if (I !== void 0) Y.expires_in = I;
  let J = await YQ.post(e9().TOKEN_URL, Y, {
    headers: {
      "Content-Type": "application/json"
    }
  });
  if (J.status !== 200) throw Error(J.status === 401 ? "Authentication failed: Invalid authorization code" : `Token exchange failed (${J.status}): ${J.statusText}`);
  return GA("tengu_oauth_token_exchange_success", {}), J.data
}
// @from(Start 2230049, End 2231248)
async function Mo0(A) {
  let Q = {
    grant_type: "refresh_token",
    refresh_token: A,
    client_id: e9().CLIENT_ID,
    scope: Ez1.join(" ")
  };
  try {
    let B = await YQ.post(e9().TOKEN_URL, Q, {
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (B.status !== 200) throw Error(`Token refresh failed: ${B.statusText}`);
    let G = B.data,
      {
        access_token: Z,
        refresh_token: I = A,
        expires_in: Y
      } = G,
      J = Date.now() + Y * 1000,
      W = cbA(G.scope);
    GA("tengu_oauth_token_refresh_success", {});
    let X = await tz1(Z),
      V = N1();
    if (V.oauthAccount) {
      let F = !1;
      if (X.displayName !== void 0) V.oauthAccount.displayName = X.displayName, F = !0;
      if (typeof X.hasExtraUsageEnabled === "boolean") V.oauthAccount.hasExtraUsageEnabled = X.hasExtraUsageEnabled, F = !0;
      if (F) c0(V)
    }
    return {
      accessToken: Z,
      refreshToken: I,
      expiresAt: J,
      scopes: W,
      subscriptionType: X.subscriptionType,
      rateLimitTier: X.rateLimitTier
    }
  } catch (B) {
    throw GA("tengu_oauth_token_refresh_failure", {
      error: B.message
    }), B
  }
}
// @from(Start 2231249, End 2231818)
async function Oo0(A) {
  let Q = await YQ.get(e9().ROLES_URL, {
    headers: {
      Authorization: `Bearer ${A}`
    }
  });
  if (Q.status !== 200) throw Error(`Failed to fetch user roles: ${Q.statusText}`);
  let B = Q.data,
    G = N1();
  if (!G.oauthAccount) throw Error("OAuth account information not found in config");
  G.oauthAccount.organizationRole = B.organization_role, G.oauthAccount.workspaceRole = B.workspace_role, G.oauthAccount.organizationName = B.organization_name, c0(G), GA("tengu_oauth_roles_stored", {
    org_role: B.organization_role
  })
}
// @from(Start 2231819, End 2232291)
async function Ro0(A) {
  try {
    let Q = await YQ.post(e9().API_KEY_URL, null, {
        headers: {
          Authorization: `Bearer ${A}`
        }
      }),
      B = Q.data?.raw_key;
    if (B) return Po0(B), GA("tengu_oauth_api_key", {
      status: "success",
      statusCode: Q.status
    }), B;
    return null
  } catch (Q) {
    throw GA("tengu_oauth_api_key", {
      status: "failure",
      error: Q instanceof Error ? Q.message : String(Q)
    }), Q
  }
}
// @from(Start 2232293, End 2232387)
function Ad(A) {
  if (A === null) return !1;
  let Q = 300000;
  return Date.now() + Q >= A
}
// @from(Start 2232388, End 2233089)
async function tz1(A) {
  let Q = await k4A(A),
    B = Q?.organization?.organization_type,
    G = null;
  switch (B) {
    case "claude_max":
      G = "max";
      break;
    case "claude_pro":
      G = "pro";
      break;
    case "claude_enterprise":
      G = "enterprise";
      break;
    case "claude_team":
      G = "team";
      break;
    default:
      G = null;
      break
  }
  let Z = {
    subscriptionType: G,
    rateLimitTier: Q?.organization?.rate_limit_tier ?? null,
    hasExtraUsageEnabled: Q?.organization?.has_extra_usage_enabled ?? null
  };
  if (Q?.account?.display_name) Z.displayName = Q.account.display_name;
  return GA("tengu_oauth_profile_fetch_success", {}), Z
}
// @from(Start 2233090, End 2233321)
async function HS() {
  let Q = N1().oauthAccount?.organizationUuid;
  if (Q) return Q;
  let B = M6()?.accessToken;
  if (B === void 0) return null;
  let Z = (await k4A(B))?.organization?.uuid;
  if (!Z) return null;
  return Z
}
// @from(Start 2233322, End 2233763)
async function To0() {
  if (N1().oauthAccount || !BB()) return !1;
  let Q = M6();
  if (Q?.accessToken) {
    let B = await k4A(Q.accessToken);
    if (B) return ez1({
      accountUuid: B.account.uuid,
      emailAddress: B.account.email,
      organizationUuid: B.organization.uuid,
      displayName: B.account.display_name || void 0,
      hasExtraUsageEnabled: B.organization.has_extra_usage_enabled ?? !1
    }), !0
  }
  return !1
}
// @from(Start 2233765, End 2234073)
function ez1({
  accountUuid: A,
  emailAddress: Q,
  organizationUuid: B,
  displayName: G,
  hasExtraUsageEnabled: Z
}) {
  let I = {
    accountUuid: A,
    emailAddress: Q,
    organizationUuid: B,
    hasExtraUsageEnabled: Z
  };
  if (G) I.displayName = G;
  let Y = N1();
  Y.oauthAccount = I, c0(Y)
}
// @from(Start 2234078, End 2234143)
AL = L(() => {
  O3();
  NX();
  q0();
  jQ();
  gB();
  kDA()
})
// @from(Start 2234146, End 2234178)
function So0() {
  return null
}
// @from(Start 2234180, End 2234364)
function _o0(A) {
  let Q = So0();
  if (!Q) return A;
  let B = new globalThis.Headers(A);
  return Object.entries(Q).forEach(([G, Z]) => {
    if (Z !== void 0) B.set(G, Z)
  }), B
}
// @from(Start 2234366, End 2234403)
function y4A() {
  return pbA && !1
}
// @from(Start 2234405, End 2234437)
function ko0() {
  return null
}
// @from(Start 2234439, End 2234492)
function yo0() {
  return pbA && jo0 !== null && !1
}
// @from(Start 2234497, End 2234500)
iX4
// @from(Start 2234502, End 2234510)
pbA = !1
// @from(Start 2234514, End 2234524)
jo0 = null
// @from(Start 2234528, End 2234539)
nX4 = "max"
// @from(Start 2234545, End 2234574)
lbA = L(() => {
  iX4 = {}
})
// @from(Start 2234580, End 2234608)
xo0 = "claude-code-20250219"
// @from(Start 2234612, End 2234651)
vo0 = "interleaved-thinking-2025-05-14"
// @from(Start 2234655, End 2234684)
ibA = "context-1m-2025-08-07"
// @from(Start 2234688, End 2234725)
nbA = "context-management-2025-06-27"
// @from(Start 2234729, End 2234766)
bo0 = "structured-outputs-2025-09-17"
// @from(Start 2234770, End 2234799)
AU1 = "web-search-2025-03-05"
// @from(Start 2234803, End 2234835)
abA = "tool-examples-2025-10-29"
// @from(Start 2234839, End 2234842)
QU1
// @from(Start 2234848, End 2234944)
sbA = L(() => {
  QU1 = new Set(["interleaved-thinking-2025-05-14", "context-1m-2025-08-07"])
})
// @from(Start 2234947, End 2235145)
function aX4(A) {
  let Q = V6();
  if (Q === "foundry") return !0;
  if (Q === "firstParty") return !A.includes("claude-3-");
  return A.includes("claude-opus-4") || A.includes("claude-sonnet-4")
}
// @from(Start 2235147, End 2235295)
function sX4(A) {
  let Q = A.toLowerCase();
  return Q.includes("claude-opus-4") || Q.includes("claude-sonnet-4") || Q.includes("claude-haiku-4")
}
// @from(Start 2235297, End 2235352)
function BU1(A) {
  return A.includes("-structured-")
}
// @from(Start 2235354, End 2235486)
function rX4() {
  return (V6() === "firstParty" || V6() === "foundry") && !Y0(process.env.CLAUDE_CODE_DISABLE_EXPERIMENTAL_BETAS)
}
// @from(Start 2235488, End 2235938)
function ho0(A, Q) {
  let B = Dw(A);
  if (!Q || Q.length === 0) return B;
  if (BB()) return console.warn("Warning: Custom betas are only available for API key users. Ignoring provided betas."), B;
  let G = [];
  for (let Z of Q)
    if (fo0.includes(Z)) G.push(Z);
    else console.warn(`Warning: Beta header '${Z}' is not allowed. Only the following betas are supported: ${fo0.join(", ")}`);
  return [...B, ...G.filter((Z) => !B.includes(Z))]
}
// @from(Start 2235940, End 2236024)
function x4A() {
  GU1.cache?.clear?.(), Dw.cache?.clear?.(), ZU1.cache?.clear?.()
}
// @from(Start 2236029, End 2236032)
fo0
// @from(Start 2236034, End 2236037)
GU1
// @from(Start 2236039, End 2236041)
Dw
// @from(Start 2236043, End 2236046)
ZU1
// @from(Start 2236052, End 2237229)
CS = L(() => {
  l2();
  sbA();
  NX();
  gB();
  hQ();
  lK();
  u2();
  u2();
  fo0 = [ibA];
  GU1 = s1((A) => {
    let Q = [],
      B = A.includes("haiku"),
      G = V6(),
      Z = rX4();
    if (!B) Q.push(xo0);
    if (BB()) Q.push($4A);
    if (A.includes("[1m]")) Q.push(ibA);
    else if (A.includes("claude-sonnet-4-5")) {
      if (BZ("sonnet_45_1m_header", "enabled", !1)) Q.push(ibA)
    }
    if (!Y0(process.env.DISABLE_INTERLEAVED_THINKING) && aX4(A)) Q.push(vo0);
    let I = Z && BZ("preserve_thinking", "enabled", !1);
    if (Y0(process.env.USE_API_CONTEXT_MANAGEMENT) && !1 || I) Q.push(nbA);
    let Y = o2("tengu_tool_pear");
    if (BU1(A) && Y) Q.push(bo0);
    if (Z && BZ("tool_use_examples", "enabled", !1)) Q.push(abA);
    if (G === "vertex" && sX4(A)) Q.push(AU1);
    if (G === "foundry") Q.push(AU1);
    if (process.env.ANTHROPIC_BETAS && !B) Q.push(...process.env.ANTHROPIC_BETAS.split(",").map((J) => J.trim()).filter(Boolean));
    return Q
  }), Dw = s1((A) => {
    let Q = GU1(A);
    if (V6() === "bedrock") return Q.filter((B) => !QU1.has(B));
    return Q
  }), ZU1 = s1((A) => {
    return GU1(A).filter((B) => QU1.has(B))
  })
})
// @from(Start 2237235, End 2240018)
IU1 = z((nD7, no0) => {
  var {
    defineProperty: rbA,
    getOwnPropertyDescriptor: oX4,
    getOwnPropertyNames: tX4
  } = Object, eX4 = Object.prototype.hasOwnProperty, obA = (A, Q) => rbA(A, "name", {
    value: Q,
    configurable: !0
  }), AV4 = (A, Q) => {
    for (var B in Q) rbA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, QV4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of tX4(Q))
        if (!eX4.call(A, Z) && Z !== B) rbA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = oX4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, BV4 = (A) => QV4(rbA({}, "__esModule", {
    value: !0
  }), A), go0 = {};
  AV4(go0, {
    AlgorithmId: () => co0,
    EndpointURLScheme: () => do0,
    FieldPosition: () => po0,
    HttpApiKeyAuthLocation: () => mo0,
    HttpAuthLocation: () => uo0,
    IniSectionType: () => lo0,
    RequestHandlerProtocol: () => io0,
    SMITHY_CONTEXT_KEY: () => JV4,
    getDefaultClientConfiguration: () => IV4,
    resolveDefaultRuntimeConfig: () => YV4
  });
  no0.exports = BV4(go0);
  var uo0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(uo0 || {}),
    mo0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(mo0 || {}),
    do0 = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(do0 || {}),
    co0 = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(co0 || {}),
    GV4 = obA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    ZV4 = obA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    IV4 = obA((A) => {
      return GV4(A)
    }, "getDefaultClientConfiguration"),
    YV4 = obA((A) => {
      return ZV4(A)
    }, "resolveDefaultRuntimeConfig"),
    po0 = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(po0 || {}),
    JV4 = "__smithy_context",
    lo0 = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(lo0 || {}),
    io0 = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(io0 || {})
})
// @from(Start 2240024, End 2244530)
nC = z((aD7, to0) => {
  var {
    defineProperty: tbA,
    getOwnPropertyDescriptor: WV4,
    getOwnPropertyNames: XV4
  } = Object, VV4 = Object.prototype.hasOwnProperty, Qd = (A, Q) => tbA(A, "name", {
    value: Q,
    configurable: !0
  }), FV4 = (A, Q) => {
    for (var B in Q) tbA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, KV4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of XV4(Q))
        if (!VV4.call(A, Z) && Z !== B) tbA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = WV4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, DV4 = (A) => KV4(tbA({}, "__esModule", {
    value: !0
  }), A), ao0 = {};
  FV4(ao0, {
    Field: () => EV4,
    Fields: () => zV4,
    HttpRequest: () => UV4,
    HttpResponse: () => $V4,
    IHttpRequest: () => so0.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => HV4,
    isValidHostname: () => oo0,
    resolveHttpHandlerRuntimeConfig: () => CV4
  });
  to0.exports = DV4(ao0);
  var HV4 = Qd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    CV4 = Qd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    so0 = IU1(),
    EV4 = class {
      static {
        Qd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = so0.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    zV4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Qd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    UV4 = class A {
      static {
        Qd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = ro0(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function ro0(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Qd(ro0, "cloneQuery");
  var $V4 = class {
    static {
      Qd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function oo0(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Qd(oo0, "isValidHostname")
})
// @from(Start 2244536, End 2246399)
yDA = z((tD7, Gt0) => {
  var {
    defineProperty: AfA,
    getOwnPropertyDescriptor: wV4,
    getOwnPropertyNames: qV4
  } = Object, NV4 = Object.prototype.hasOwnProperty, ebA = (A, Q) => AfA(A, "name", {
    value: Q,
    configurable: !0
  }), LV4 = (A, Q) => {
    for (var B in Q) AfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, MV4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qV4(Q))
        if (!NV4.call(A, Z) && Z !== B) AfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wV4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, OV4 = (A) => MV4(AfA({}, "__esModule", {
    value: !0
  }), A), eo0 = {};
  LV4(eo0, {
    getHostHeaderPlugin: () => TV4,
    hostHeaderMiddleware: () => Qt0,
    hostHeaderMiddlewareOptions: () => Bt0,
    resolveHostHeaderConfig: () => At0
  });
  Gt0.exports = OV4(eo0);
  var RV4 = nC();

  function At0(A) {
    return A
  }
  ebA(At0, "resolveHostHeaderConfig");
  var Qt0 = ebA((A) => (Q) => async (B) => {
      if (!RV4.HttpRequest.isInstance(B.request)) return Q(B);
      let {
        request: G
      } = B, {
        handlerProtocol: Z = ""
      } = A.requestHandler.metadata || {};
      if (Z.indexOf("h2") >= 0 && !G.headers[":authority"]) delete G.headers.host, G.headers[":authority"] = G.hostname + (G.port ? ":" + G.port : "");
      else if (!G.headers.host) {
        let I = G.hostname;
        if (G.port != null) I += `:${G.port}`;
        G.headers.host = I
      }
      return Q(B)
    }, "hostHeaderMiddleware"),
    Bt0 = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: !0
    },
    TV4 = ebA((A) => ({
      applyToStack: ebA((Q) => {
        Q.add(Qt0(A), Bt0)
      }, "applyToStack")
    }), "getHostHeaderPlugin")
})
// @from(Start 2246405, End 2248705)
xDA = z((eD7, Jt0) => {
  var {
    defineProperty: QfA,
    getOwnPropertyDescriptor: PV4,
    getOwnPropertyNames: jV4
  } = Object, SV4 = Object.prototype.hasOwnProperty, YU1 = (A, Q) => QfA(A, "name", {
    value: Q,
    configurable: !0
  }), _V4 = (A, Q) => {
    for (var B in Q) QfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, kV4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of jV4(Q))
        if (!SV4.call(A, Z) && Z !== B) QfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = PV4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, yV4 = (A) => kV4(QfA({}, "__esModule", {
    value: !0
  }), A), Zt0 = {};
  _V4(Zt0, {
    getLoggerPlugin: () => xV4,
    loggerMiddleware: () => It0,
    loggerMiddlewareOptions: () => Yt0
  });
  Jt0.exports = yV4(Zt0);
  var It0 = YU1(() => (A, Q) => async (B) => {
      try {
        let G = await A(B),
          {
            clientName: Z,
            commandName: I,
            logger: Y,
            dynamoDbDocumentClientOptions: J = {}
          } = Q,
          {
            overrideInputFilterSensitiveLog: W,
            overrideOutputFilterSensitiveLog: X
          } = J,
          V = W ?? Q.inputFilterSensitiveLog,
          F = X ?? Q.outputFilterSensitiveLog,
          {
            $metadata: K,
            ...D
          } = G.output;
        return Y?.info?.({
          clientName: Z,
          commandName: I,
          input: V(B.input),
          output: F(D),
          metadata: K
        }), G
      } catch (G) {
        let {
          clientName: Z,
          commandName: I,
          logger: Y,
          dynamoDbDocumentClientOptions: J = {}
        } = Q, {
          overrideInputFilterSensitiveLog: W
        } = J, X = W ?? Q.inputFilterSensitiveLog;
        throw Y?.error?.({
          clientName: Z,
          commandName: I,
          input: X(B.input),
          error: G,
          metadata: G.$metadata
        }), G
      }
    }, "loggerMiddleware"),
    Yt0 = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: !0
    },
    xV4 = YU1((A) => ({
      applyToStack: YU1((Q) => {
        Q.add(It0(), Yt0)
      }, "applyToStack")
    }), "getLoggerPlugin")
})
// @from(Start 2248711, End 2250643)
vDA = z((AH7, Ft0) => {
  var {
    defineProperty: GfA,
    getOwnPropertyDescriptor: vV4,
    getOwnPropertyNames: bV4
  } = Object, fV4 = Object.prototype.hasOwnProperty, BfA = (A, Q) => GfA(A, "name", {
    value: Q,
    configurable: !0
  }), hV4 = (A, Q) => {
    for (var B in Q) GfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, gV4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of bV4(Q))
        if (!fV4.call(A, Z) && Z !== B) GfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = vV4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, uV4 = (A) => gV4(GfA({}, "__esModule", {
    value: !0
  }), A), Wt0 = {};
  hV4(Wt0, {
    addRecursionDetectionMiddlewareOptions: () => Vt0,
    getRecursionDetectionPlugin: () => pV4,
    recursionDetectionMiddleware: () => Xt0
  });
  Ft0.exports = uV4(Wt0);
  var mV4 = nC(),
    JU1 = "X-Amzn-Trace-Id",
    dV4 = "AWS_LAMBDA_FUNCTION_NAME",
    cV4 = "_X_AMZN_TRACE_ID",
    Xt0 = BfA((A) => (Q) => async (B) => {
      let {
        request: G
      } = B;
      if (!mV4.HttpRequest.isInstance(G) || A.runtime !== "node") return Q(B);
      let Z = Object.keys(G.headers ?? {}).find((W) => W.toLowerCase() === JU1.toLowerCase()) ?? JU1;
      if (G.headers.hasOwnProperty(Z)) return Q(B);
      let I = process.env[dV4],
        Y = process.env[cV4],
        J = BfA((W) => typeof W === "string" && W.length > 0, "nonEmptyString");
      if (J(I) && J(Y)) G.headers[JU1] = Y;
      return Q({
        ...B,
        request: G
      })
    }, "recursionDetectionMiddleware"),
    Vt0 = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: !0,
      priority: "low"
    },
    pV4 = BfA((A) => ({
      applyToStack: BfA((Q) => {
        Q.add(Xt0(A), Vt0)
      }, "applyToStack")
    }), "getRecursionDetectionPlugin")
})
// @from(Start 2250649, End 2253432)
WU1 = z((QH7, wt0) => {
  var {
    defineProperty: ZfA,
    getOwnPropertyDescriptor: lV4,
    getOwnPropertyNames: iV4
  } = Object, nV4 = Object.prototype.hasOwnProperty, IfA = (A, Q) => ZfA(A, "name", {
    value: Q,
    configurable: !0
  }), aV4 = (A, Q) => {
    for (var B in Q) ZfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, sV4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of iV4(Q))
        if (!nV4.call(A, Z) && Z !== B) ZfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = lV4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, rV4 = (A) => sV4(ZfA({}, "__esModule", {
    value: !0
  }), A), Kt0 = {};
  aV4(Kt0, {
    AlgorithmId: () => Et0,
    EndpointURLScheme: () => Ct0,
    FieldPosition: () => zt0,
    HttpApiKeyAuthLocation: () => Ht0,
    HttpAuthLocation: () => Dt0,
    IniSectionType: () => Ut0,
    RequestHandlerProtocol: () => $t0,
    SMITHY_CONTEXT_KEY: () => QF4,
    getDefaultClientConfiguration: () => eV4,
    resolveDefaultRuntimeConfig: () => AF4
  });
  wt0.exports = rV4(Kt0);
  var Dt0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(Dt0 || {}),
    Ht0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(Ht0 || {}),
    Ct0 = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(Ct0 || {}),
    Et0 = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(Et0 || {}),
    oV4 = IfA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    tV4 = IfA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    eV4 = IfA((A) => {
      return oV4(A)
    }, "getDefaultClientConfiguration"),
    AF4 = IfA((A) => {
      return tV4(A)
    }, "resolveDefaultRuntimeConfig"),
    zt0 = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(zt0 || {}),
    QF4 = "__smithy_context",
    Ut0 = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(Ut0 || {}),
    $t0 = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })($t0 || {})
})
// @from(Start 2253438, End 2256221)
St0 = z((BH7, jt0) => {
  var {
    defineProperty: YfA,
    getOwnPropertyDescriptor: BF4,
    getOwnPropertyNames: GF4
  } = Object, ZF4 = Object.prototype.hasOwnProperty, JfA = (A, Q) => YfA(A, "name", {
    value: Q,
    configurable: !0
  }), IF4 = (A, Q) => {
    for (var B in Q) YfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, YF4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of GF4(Q))
        if (!ZF4.call(A, Z) && Z !== B) YfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = BF4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, JF4 = (A) => YF4(YfA({}, "__esModule", {
    value: !0
  }), A), qt0 = {};
  IF4(qt0, {
    AlgorithmId: () => Ot0,
    EndpointURLScheme: () => Mt0,
    FieldPosition: () => Rt0,
    HttpApiKeyAuthLocation: () => Lt0,
    HttpAuthLocation: () => Nt0,
    IniSectionType: () => Tt0,
    RequestHandlerProtocol: () => Pt0,
    SMITHY_CONTEXT_KEY: () => KF4,
    getDefaultClientConfiguration: () => VF4,
    resolveDefaultRuntimeConfig: () => FF4
  });
  jt0.exports = JF4(qt0);
  var Nt0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(Nt0 || {}),
    Lt0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(Lt0 || {}),
    Mt0 = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(Mt0 || {}),
    Ot0 = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(Ot0 || {}),
    WF4 = JfA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    XF4 = JfA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    VF4 = JfA((A) => {
      return WF4(A)
    }, "getDefaultClientConfiguration"),
    FF4 = JfA((A) => {
      return XF4(A)
    }, "resolveDefaultRuntimeConfig"),
    Rt0 = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(Rt0 || {}),
    KF4 = "__smithy_context",
    Tt0 = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(Tt0 || {}),
    Pt0 = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(Pt0 || {})
})
// @from(Start 2256227, End 2257324)
w7 = z((GH7, xt0) => {
  var {
    defineProperty: WfA,
    getOwnPropertyDescriptor: DF4,
    getOwnPropertyNames: HF4
  } = Object, CF4 = Object.prototype.hasOwnProperty, kt0 = (A, Q) => WfA(A, "name", {
    value: Q,
    configurable: !0
  }), EF4 = (A, Q) => {
    for (var B in Q) WfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, zF4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of HF4(Q))
        if (!CF4.call(A, Z) && Z !== B) WfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = DF4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, UF4 = (A) => zF4(WfA({}, "__esModule", {
    value: !0
  }), A), yt0 = {};
  EF4(yt0, {
    getSmithyContext: () => $F4,
    normalizeProvider: () => wF4
  });
  xt0.exports = UF4(yt0);
  var _t0 = St0(),
    $F4 = kt0((A) => A[_t0.SMITHY_CONTEXT_KEY] || (A[_t0.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext"),
    wF4 = kt0((A) => {
      if (typeof A === "function") return A;
      let Q = Promise.resolve(A);
      return () => Q
    }, "normalizeProvider")
})
// @from(Start 2257330, End 2260113)
pt0 = z((ZH7, ct0) => {
  var {
    defineProperty: XfA,
    getOwnPropertyDescriptor: qF4,
    getOwnPropertyNames: NF4
  } = Object, LF4 = Object.prototype.hasOwnProperty, VfA = (A, Q) => XfA(A, "name", {
    value: Q,
    configurable: !0
  }), MF4 = (A, Q) => {
    for (var B in Q) XfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, OF4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of NF4(Q))
        if (!LF4.call(A, Z) && Z !== B) XfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qF4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, RF4 = (A) => OF4(XfA({}, "__esModule", {
    value: !0
  }), A), vt0 = {};
  MF4(vt0, {
    AlgorithmId: () => gt0,
    EndpointURLScheme: () => ht0,
    FieldPosition: () => ut0,
    HttpApiKeyAuthLocation: () => ft0,
    HttpAuthLocation: () => bt0,
    IniSectionType: () => mt0,
    RequestHandlerProtocol: () => dt0,
    SMITHY_CONTEXT_KEY: () => _F4,
    getDefaultClientConfiguration: () => jF4,
    resolveDefaultRuntimeConfig: () => SF4
  });
  ct0.exports = RF4(vt0);
  var bt0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(bt0 || {}),
    ft0 = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(ft0 || {}),
    ht0 = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(ht0 || {}),
    gt0 = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(gt0 || {}),
    TF4 = VfA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    PF4 = VfA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    jF4 = VfA((A) => {
      return TF4(A)
    }, "getDefaultClientConfiguration"),
    SF4 = VfA((A) => {
      return PF4(A)
    }, "resolveDefaultRuntimeConfig"),
    ut0 = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(ut0 || {}),
    _F4 = "__smithy_context",
    mt0 = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(mt0 || {}),
    dt0 = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(dt0 || {})
})
// @from(Start 2260119, End 2264626)
rt0 = z((IH7, st0) => {
  var {
    defineProperty: FfA,
    getOwnPropertyDescriptor: kF4,
    getOwnPropertyNames: yF4
  } = Object, xF4 = Object.prototype.hasOwnProperty, Bd = (A, Q) => FfA(A, "name", {
    value: Q,
    configurable: !0
  }), vF4 = (A, Q) => {
    for (var B in Q) FfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, bF4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of yF4(Q))
        if (!xF4.call(A, Z) && Z !== B) FfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = kF4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, fF4 = (A) => bF4(FfA({}, "__esModule", {
    value: !0
  }), A), lt0 = {};
  vF4(lt0, {
    Field: () => uF4,
    Fields: () => mF4,
    HttpRequest: () => dF4,
    HttpResponse: () => cF4,
    IHttpRequest: () => it0.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => hF4,
    isValidHostname: () => at0,
    resolveHttpHandlerRuntimeConfig: () => gF4
  });
  st0.exports = fF4(lt0);
  var hF4 = Bd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    gF4 = Bd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    it0 = pt0(),
    uF4 = class {
      static {
        Bd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = it0.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    mF4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Bd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    dF4 = class A {
      static {
        Bd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = nt0(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function nt0(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Bd(nt0, "cloneQuery");
  var cF4 = class {
    static {
      Bd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function at0(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Bd(at0, "isValidHostname")
})
// @from(Start 2264632, End 2268114)
GZ = z((XH7, Ge0) => {
  var {
    defineProperty: KfA,
    getOwnPropertyDescriptor: pF4,
    getOwnPropertyNames: lF4
  } = Object, iF4 = Object.prototype.hasOwnProperty, DfA = (A, Q) => KfA(A, "name", {
    value: Q,
    configurable: !0
  }), nF4 = (A, Q) => {
    for (var B in Q) KfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, aF4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of lF4(Q))
        if (!iF4.call(A, Z) && Z !== B) KfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = pF4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, sF4 = (A) => aF4(KfA({}, "__esModule", {
    value: !0
  }), A), ot0 = {};
  nF4(ot0, {
    deserializerMiddleware: () => tt0,
    deserializerMiddlewareOption: () => Ae0,
    getSerdePlugin: () => Be0,
    serializerMiddleware: () => et0,
    serializerMiddlewareOption: () => Qe0
  });
  Ge0.exports = sF4(ot0);
  var rF4 = rt0(),
    tt0 = DfA((A, Q) => (B, G) => async (Z) => {
      let {
        response: I
      } = await B(Z);
      try {
        let Y = await Q(I, A);
        return {
          response: I,
          output: Y
        }
      } catch (Y) {
        if (Object.defineProperty(Y, "$response", {
            value: I
          }), !("$metadata" in Y)) {
          try {
            Y.message += `
  Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`
          } catch (W) {
            if (!G.logger || G.logger?.constructor?.name === "NoOpLogger") console.warn("Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.");
            else G.logger?.warn?.("Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.")
          }
          if (typeof Y.$responseBodyText < "u") {
            if (Y.$response) Y.$response.body = Y.$responseBodyText
          }
          try {
            if (rF4.HttpResponse.isInstance(I)) {
              let {
                headers: W = {}
              } = I, X = Object.entries(W);
              Y.$metadata = {
                httpStatusCode: I.statusCode,
                requestId: XU1(/^x-[\w-]+-request-?id$/, X),
                extendedRequestId: XU1(/^x-[\w-]+-id-2$/, X),
                cfId: XU1(/^x-[\w-]+-cf-id$/, X)
              }
            }
          } catch (W) {}
        }
        throw Y
      }
    }, "deserializerMiddleware"),
    XU1 = DfA((A, Q) => {
      return (Q.find(([B]) => {
        return B.match(A)
      }) || [void 0, void 0])[1]
    }, "findHeader"),
    et0 = DfA((A, Q) => (B, G) => async (Z) => {
      let I = A,
        Y = G.endpointV2?.url && I.urlParser ? async () => I.urlParser(G.endpointV2.url): I.endpoint;
      if (!Y) throw Error("No valid endpoint provider available.");
      let J = await Q(Z.input, {
        ...A,
        endpoint: Y
      });
      return B({
        ...Z,
        request: J
      })
    }, "serializerMiddleware"),
    Ae0 = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0
    },
    Qe0 = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: !0
    };

  function Be0(A, Q, B) {
    return {
      applyToStack: (G) => {
        G.add(tt0(A, B), Ae0), G.add(et0(A, Q), Qe0)
      }
    }
  }
  DfA(Be0, "getSerdePlugin")
})
// @from(Start 2268120, End 2272626)
Sr = z((VH7, We0) => {
  var {
    defineProperty: HfA,
    getOwnPropertyDescriptor: oF4,
    getOwnPropertyNames: tF4
  } = Object, eF4 = Object.prototype.hasOwnProperty, Gd = (A, Q) => HfA(A, "name", {
    value: Q,
    configurable: !0
  }), AK4 = (A, Q) => {
    for (var B in Q) HfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, QK4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of tF4(Q))
        if (!eF4.call(A, Z) && Z !== B) HfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = oF4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, BK4 = (A) => QK4(HfA({}, "__esModule", {
    value: !0
  }), A), Ze0 = {};
  AK4(Ze0, {
    Field: () => IK4,
    Fields: () => YK4,
    HttpRequest: () => JK4,
    HttpResponse: () => WK4,
    IHttpRequest: () => Ie0.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => GK4,
    isValidHostname: () => Je0,
    resolveHttpHandlerRuntimeConfig: () => ZK4
  });
  We0.exports = BK4(Ze0);
  var GK4 = Gd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    ZK4 = Gd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    Ie0 = WU1(),
    IK4 = class {
      static {
        Gd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = Ie0.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    YK4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Gd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    JK4 = class A {
      static {
        Gd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = Ye0(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function Ye0(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Gd(Ye0, "cloneQuery");
  var WK4 = class {
    static {
      Gd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function Je0(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Gd(Je0, "isValidHostname")
})
// @from(Start 2272632, End 2273585)
Fe0 = z((HH7, Ve0) => {
  var {
    defineProperty: CfA,
    getOwnPropertyDescriptor: XK4,
    getOwnPropertyNames: VK4
  } = Object, FK4 = Object.prototype.hasOwnProperty, KK4 = (A, Q) => CfA(A, "name", {
    value: Q,
    configurable: !0
  }), DK4 = (A, Q) => {
    for (var B in Q) CfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, HK4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of VK4(Q))
        if (!FK4.call(A, Z) && Z !== B) CfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = XK4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, CK4 = (A) => HK4(CfA({}, "__esModule", {
    value: !0
  }), A), Xe0 = {};
  DK4(Xe0, {
    isArrayBuffer: () => EK4
  });
  Ve0.exports = CK4(Xe0);
  var EK4 = KK4((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 2273591, End 2274936)
hI = z((CH7, He0) => {
  var {
    defineProperty: EfA,
    getOwnPropertyDescriptor: zK4,
    getOwnPropertyNames: UK4
  } = Object, $K4 = Object.prototype.hasOwnProperty, Ke0 = (A, Q) => EfA(A, "name", {
    value: Q,
    configurable: !0
  }), wK4 = (A, Q) => {
    for (var B in Q) EfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, qK4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of UK4(Q))
        if (!$K4.call(A, Z) && Z !== B) EfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = zK4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, NK4 = (A) => qK4(EfA({}, "__esModule", {
    value: !0
  }), A), De0 = {};
  wK4(De0, {
    fromArrayBuffer: () => MK4,
    fromString: () => OK4
  });
  He0.exports = NK4(De0);
  var LK4 = Fe0(),
    VU1 = UA("buffer"),
    MK4 = Ke0((A, Q = 0, B = A.byteLength - Q) => {
      if (!(0, LK4.isArrayBuffer)(A)) throw TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof A} (${A})`);
      return VU1.Buffer.from(A, Q, B)
    }, "fromArrayBuffer"),
    OK4 = Ke0((A, Q) => {
      if (typeof A !== "string") throw TypeError(`The "input" argument must be of type string. Received type ${typeof A} (${A})`);
      return Q ? VU1.Buffer.from(A, Q) : VU1.Buffer.from(A)
    }, "fromString")
})
// @from(Start 2274942, End 2275429)
ze0 = z((Ce0) => {
  Object.defineProperty(Ce0, "__esModule", {
    value: !0
  });
  Ce0.fromBase64 = void 0;
  var RK4 = hI(),
    TK4 = /^[A-Za-z0-9+/]*={0,2}$/,
    PK4 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!TK4.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, RK4.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  Ce0.fromBase64 = PK4
})
// @from(Start 2275435, End 2277096)
O2 = z((zH7, qe0) => {
  var {
    defineProperty: zfA,
    getOwnPropertyDescriptor: jK4,
    getOwnPropertyNames: SK4
  } = Object, _K4 = Object.prototype.hasOwnProperty, FU1 = (A, Q) => zfA(A, "name", {
    value: Q,
    configurable: !0
  }), kK4 = (A, Q) => {
    for (var B in Q) zfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, yK4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of SK4(Q))
        if (!_K4.call(A, Z) && Z !== B) zfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = jK4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, xK4 = (A) => yK4(zfA({}, "__esModule", {
    value: !0
  }), A), Ue0 = {};
  kK4(Ue0, {
    fromUtf8: () => we0,
    toUint8Array: () => vK4,
    toUtf8: () => bK4
  });
  qe0.exports = xK4(Ue0);
  var $e0 = hI(),
    we0 = FU1((A) => {
      let Q = (0, $e0.fromString)(A, "utf8");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength / Uint8Array.BYTES_PER_ELEMENT)
    }, "fromUtf8"),
    vK4 = FU1((A) => {
      if (typeof A === "string") return we0(A);
      if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      return new Uint8Array(A)
    }, "toUint8Array"),
    bK4 = FU1((A) => {
      if (typeof A === "string") return A;
      if (typeof A !== "object" || typeof A.byteOffset !== "number" || typeof A.byteLength !== "number") throw Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      return (0, $e0.fromArrayBuffer)(A.buffer, A.byteOffset, A.byteLength).toString("utf8")
    }, "toUtf8")
})
// @from(Start 2277102, End 2277681)
Me0 = z((Ne0) => {
  Object.defineProperty(Ne0, "__esModule", {
    value: !0
  });
  Ne0.toBase64 = void 0;
  var fK4 = hI(),
    hK4 = O2(),
    gK4 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, hK4.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, fK4.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  Ne0.toBase64 = gK4
})
// @from(Start 2277687, End 2278383)
v4A = z(($H7, UfA) => {
  var {
    defineProperty: Oe0,
    getOwnPropertyDescriptor: uK4,
    getOwnPropertyNames: mK4
  } = Object, dK4 = Object.prototype.hasOwnProperty, KU1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of mK4(Q))
        if (!dK4.call(A, Z) && Z !== B) Oe0(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = uK4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Re0 = (A, Q, B) => (KU1(A, Q, "default"), B && KU1(B, Q, "default")), cK4 = (A) => KU1(Oe0({}, "__esModule", {
    value: !0
  }), A), DU1 = {};
  UfA.exports = cK4(DU1);
  Re0(DU1, ze0(), UfA.exports);
  Re0(DU1, Me0(), UfA.exports)
})
// @from(Start 2278389, End 2279789)
HU1 = z((Pe0) => {
  Object.defineProperty(Pe0, "__esModule", {
    value: !0
  });
  Pe0.ChecksumStream = void 0;
  var pK4 = v4A(),
    lK4 = UA("stream");
  class Te0 extends lK4.Duplex {
    constructor({
      expectedChecksum: A,
      checksum: Q,
      source: B,
      checksumSourceLocation: G,
      base64Encoder: Z
    }) {
      var I, Y;
      super();
      if (typeof B.pipe === "function") this.source = B;
      else throw Error(`@smithy/util-stream: unsupported source type ${(Y=(I=B===null||B===void 0?void 0:B.constructor)===null||I===void 0?void 0:I.name)!==null&&Y!==void 0?Y:B} in ChecksumStream.`);
      this.base64Encoder = Z !== null && Z !== void 0 ? Z : pK4.toBase64, this.expectedChecksum = A, this.checksum = Q, this.checksumSourceLocation = G, this.source.pipe(this)
    }
    _read(A) {}
    _write(A, Q, B) {
      try {
        this.checksum.update(A), this.push(A)
      } catch (G) {
        return B(G)
      }
      return B()
    }
    async _final(A) {
      try {
        let Q = await this.checksum.digest(),
          B = this.base64Encoder(Q);
        if (this.expectedChecksum !== B) return A(Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${B}" in response header "${this.checksumSourceLocation}".`))
      } catch (Q) {
        return A(Q)
      }
      return this.push(null), A()
    }
  }
  Pe0.ChecksumStream = Te0
})
// @from(Start 2279795, End 2280441)
Zd = z((Se0) => {
  Object.defineProperty(Se0, "__esModule", {
    value: !0
  });
  Se0.isBlob = Se0.isReadableStream = void 0;
  var iK4 = (A) => {
    var Q;
    return typeof ReadableStream === "function" && (((Q = A === null || A === void 0 ? void 0 : A.constructor) === null || Q === void 0 ? void 0 : Q.name) === ReadableStream.name || A instanceof ReadableStream)
  };
  Se0.isReadableStream = iK4;
  var nK4 = (A) => {
    var Q;
    return typeof Blob === "function" && (((Q = A === null || A === void 0 ? void 0 : A.constructor) === null || Q === void 0 ? void 0 : Q.name) === Blob.name || A instanceof Blob)
  };
  Se0.isBlob = nK4
})
// @from(Start 2280447, End 2280701)
ve0 = z((ye0) => {
  Object.defineProperty(ye0, "__esModule", {
    value: !0
  });
  ye0.ChecksumStream = void 0;
  var sK4 = typeof ReadableStream === "function" ? ReadableStream : function() {};
  class ke0 extends sK4 {}
  ye0.ChecksumStream = ke0
})
// @from(Start 2280707, End 2282103)
he0 = z((be0) => {
  Object.defineProperty(be0, "__esModule", {
    value: !0
  });
  be0.createChecksumStream = void 0;
  var rK4 = v4A(),
    oK4 = Zd(),
    tK4 = ve0(),
    eK4 = ({
      expectedChecksum: A,
      checksum: Q,
      source: B,
      checksumSourceLocation: G,
      base64Encoder: Z
    }) => {
      var I, Y;
      if (!(0, oK4.isReadableStream)(B)) throw Error(`@smithy/util-stream: unsupported source type ${(Y=(I=B===null||B===void 0?void 0:B.constructor)===null||I===void 0?void 0:I.name)!==null&&Y!==void 0?Y:B} in ChecksumStream.`);
      let J = Z !== null && Z !== void 0 ? Z : rK4.toBase64;
      if (typeof TransformStream !== "function") throw Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
      let W = new TransformStream({
        start() {},
        async transform(V, F) {
          Q.update(V), F.enqueue(V)
        },
        async flush(V) {
          let F = await Q.digest(),
            K = J(F);
          if (A !== K) {
            let D = Error(`Checksum mismatch: expected "${A}" but received "${K}" in response header "${G}".`);
            V.error(D)
          } else V.terminate()
        }
      });
      B.pipeThrough(W);
      let X = W.readable;
      return Object.setPrototypeOf(X, tK4.ChecksumStream.prototype), X
    };
  be0.createChecksumStream = eK4
})
// @from(Start 2282109, End 2282469)
ue0 = z((ge0) => {
  Object.defineProperty(ge0, "__esModule", {
    value: !0
  });
  ge0.createChecksumStream = GD4;
  var AD4 = Zd(),
    QD4 = HU1(),
    BD4 = he0();

  function GD4(A) {
    if (typeof ReadableStream === "function" && (0, AD4.isReadableStream)(A.source)) return (0, BD4.createChecksumStream)(A);
    return new QD4.ChecksumStream(A)
  }
})
// @from(Start 2282475, End 2283269)
CU1 = z((de0) => {
  Object.defineProperty(de0, "__esModule", {
    value: !0
  });
  de0.ByteArrayCollector = void 0;
  class me0 {
    constructor(A) {
      this.allocByteArray = A, this.byteLength = 0, this.byteArrays = []
    }
    push(A) {
      this.byteArrays.push(A), this.byteLength += A.byteLength
    }
    flush() {
      if (this.byteArrays.length === 1) {
        let B = this.byteArrays[0];
        return this.reset(), B
      }
      let A = this.allocByteArray(this.byteLength),
        Q = 0;
      for (let B = 0; B < this.byteArrays.length; ++B) {
        let G = this.byteArrays[B];
        A.set(G, Q), Q += G.byteLength
      }
      return this.reset(), A
    }
    reset() {
      this.byteArrays = [], this.byteLength = 0
    }
  }
  de0.ByteArrayCollector = me0
})
// @from(Start 2283275, End 2285586)
se0 = z((ne0) => {
  Object.defineProperty(ne0, "__esModule", {
    value: !0
  });
  ne0.createBufferedReadable = void 0;
  ne0.createBufferedReadableStream = pe0;
  ne0.merge = le0;
  ne0.flush = $fA;
  ne0.sizeOf = b4A;
  ne0.modeOf = ie0;
  var ID4 = CU1();

  function pe0(A, Q, B) {
    let G = A.getReader(),
      Z = !1,
      I = 0,
      Y = ["", new ID4.ByteArrayCollector((X) => new Uint8Array(X))],
      J = -1,
      W = async (X) => {
        let {
          value: V,
          done: F
        } = await G.read(), K = V;
        if (F) {
          if (J !== -1) {
            let D = $fA(Y, J);
            if (b4A(D) > 0) X.enqueue(D)
          }
          X.close()
        } else {
          let D = ie0(K, !1);
          if (J !== D) {
            if (J >= 0) X.enqueue($fA(Y, J));
            J = D
          }
          if (J === -1) {
            X.enqueue(K);
            return
          }
          let H = b4A(K);
          I += H;
          let C = b4A(Y[J]);
          if (H >= Q && C === 0) X.enqueue(K);
          else {
            let E = le0(Y, J, K);
            if (!Z && I > Q * 2) Z = !0, B === null || B === void 0 || B.warn(`@smithy/util-stream - stream chunk size ${H} is below threshold of ${Q}, automatically buffering.`);
            if (E >= Q) X.enqueue($fA(Y, J));
            else await W(X)
          }
        }
      };
    return new ReadableStream({
      pull: W
    })
  }
  ne0.createBufferedReadable = pe0;

  function le0(A, Q, B) {
    switch (Q) {
      case 0:
        return A[0] += B, b4A(A[0]);
      case 1:
      case 2:
        return A[Q].push(B), b4A(A[Q])
    }
  }

  function $fA(A, Q) {
    switch (Q) {
      case 0:
        let B = A[0];
        return A[0] = "", B;
      case 1:
      case 2:
        return A[Q].flush()
    }
    throw Error(`@smithy/util-stream - invalid index ${Q} given to flush()`)
  }

  function b4A(A) {
    var Q, B;
    return (B = (Q = A === null || A === void 0 ? void 0 : A.byteLength) !== null && Q !== void 0 ? Q : A === null || A === void 0 ? void 0 : A.length) !== null && B !== void 0 ? B : 0
  }

  function ie0(A, Q = !0) {
    if (Q && typeof Buffer < "u" && A instanceof Buffer) return 2;
    if (A instanceof Uint8Array) return 1;
    if (typeof A === "string") return 0;
    return -1
  }
})
// @from(Start 2285592, End 2286957)
te0 = z((oe0) => {
  Object.defineProperty(oe0, "__esModule", {
    value: !0
  });
  oe0.createBufferedReadable = DD4;
  var FD4 = UA("node:stream"),
    re0 = CU1(),
    qv = se0(),
    KD4 = Zd();

  function DD4(A, Q, B) {
    if ((0, KD4.isReadableStream)(A)) return (0, qv.createBufferedReadableStream)(A, Q, B);
    let G = new FD4.Readable({
        read() {}
      }),
      Z = !1,
      I = 0,
      Y = ["", new re0.ByteArrayCollector((W) => new Uint8Array(W)), new re0.ByteArrayCollector((W) => Buffer.from(new Uint8Array(W)))],
      J = -1;
    return A.on("data", (W) => {
      let X = (0, qv.modeOf)(W, !0);
      if (J !== X) {
        if (J >= 0) G.push((0, qv.flush)(Y, J));
        J = X
      }
      if (J === -1) {
        G.push(W);
        return
      }
      let V = (0, qv.sizeOf)(W);
      I += V;
      let F = (0, qv.sizeOf)(Y[J]);
      if (V >= Q && F === 0) G.push(W);
      else {
        let K = (0, qv.merge)(Y, J, W);
        if (!Z && I > Q * 2) Z = !0, B === null || B === void 0 || B.warn(`@smithy/util-stream - stream chunk size ${V} is below threshold of ${Q}, automatically buffering.`);
        if (K >= Q) G.push((0, qv.flush)(Y, J))
      }
    }), A.on("end", () => {
      if (J !== -1) {
        let W = (0, qv.flush)(Y, J);
        if ((0, qv.sizeOf)(W) > 0) G.push(W)
      }
      G.push(null)
    }), G
  }
})
// @from(Start 2286963, End 2287823)
QAQ = z((ee0) => {
  Object.defineProperty(ee0, "__esModule", {
    value: !0
  });
  ee0.getAwsChunkedEncodingStream = void 0;
  var CD4 = UA("stream"),
    ED4 = (A, Q) => {
      let {
        base64Encoder: B,
        bodyLengthChecker: G,
        checksumAlgorithmFn: Z,
        checksumLocationName: I,
        streamHasher: Y
      } = Q, J = B !== void 0 && Z !== void 0 && I !== void 0 && Y !== void 0, W = J ? Y(Z, A) : void 0, X = new CD4.Readable({
        read: () => {}
      });
      return A.on("data", (V) => {
        let F = G(V) || 0;
        X.push(`${F.toString(16)}\r
`), X.push(V), X.push(`\r
`)
      }), A.on("end", async () => {
        if (X.push(`0\r
`), J) {
          let V = B(await W);
          X.push(`${I}:${V}\r
`), X.push(`\r
`)
        }
        X.push(null)
      }), X
    };
  ee0.getAwsChunkedEncodingStream = ED4
})
// @from(Start 2287829, End 2288579)
GAQ = z((BAQ) => {
  Object.defineProperty(BAQ, "__esModule", {
    value: !0
  });
  BAQ.headStream = zD4;
  async function zD4(A, Q) {
    var B;
    let G = 0,
      Z = [],
      I = A.getReader(),
      Y = !1;
    while (!Y) {
      let {
        done: X,
        value: V
      } = await I.read();
      if (V) Z.push(V), G += (B = V === null || V === void 0 ? void 0 : V.byteLength) !== null && B !== void 0 ? B : 0;
      if (G >= Q) break;
      Y = X
    }
    I.releaseLock();
    let J = new Uint8Array(Math.min(Q, G)),
      W = 0;
    for (let X of Z) {
      if (X.byteLength > J.byteLength - W) {
        J.set(X.subarray(0, J.byteLength - W), W);
        break
      } else J.set(X, W);
      W += X.length
    }
    return J
  }
})
// @from(Start 2288585, End 2289746)
JAQ = z((IAQ) => {
  Object.defineProperty(IAQ, "__esModule", {
    value: !0
  });
  IAQ.headStream = void 0;
  var $D4 = UA("stream"),
    wD4 = GAQ(),
    qD4 = Zd(),
    ND4 = (A, Q) => {
      if ((0, qD4.isReadableStream)(A)) return (0, wD4.headStream)(A, Q);
      return new Promise((B, G) => {
        let Z = new ZAQ;
        Z.limit = Q, A.pipe(Z), A.on("error", (I) => {
          Z.end(), G(I)
        }), Z.on("error", G), Z.on("finish", function() {
          let I = new Uint8Array(Buffer.concat(this.buffers));
          B(I)
        })
      })
    };
  IAQ.headStream = ND4;
  class ZAQ extends $D4.Writable {
    constructor() {
      super(...arguments);
      this.buffers = [], this.limit = 1 / 0, this.bytesBuffered = 0
    }
    _write(A, Q, B) {
      var G;
      if (this.buffers.push(A), this.bytesBuffered += (G = A.byteLength) !== null && G !== void 0 ? G : 0, this.bytesBuffered >= this.limit) {
        let Z = this.bytesBuffered - this.limit,
          I = this.buffers[this.buffers.length - 1];
        this.buffers[this.buffers.length - 1] = I.subarray(0, I.byteLength - Z), this.emit("finish")
      }
      B()
    }
  }
})
// @from(Start 2289752, End 2292535)
zAQ = z((_H7, EAQ) => {
  var {
    defineProperty: wfA,
    getOwnPropertyDescriptor: LD4,
    getOwnPropertyNames: MD4
  } = Object, OD4 = Object.prototype.hasOwnProperty, qfA = (A, Q) => wfA(A, "name", {
    value: Q,
    configurable: !0
  }), RD4 = (A, Q) => {
    for (var B in Q) wfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, TD4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of MD4(Q))
        if (!OD4.call(A, Z) && Z !== B) wfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = LD4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, PD4 = (A) => TD4(wfA({}, "__esModule", {
    value: !0
  }), A), WAQ = {};
  RD4(WAQ, {
    AlgorithmId: () => KAQ,
    EndpointURLScheme: () => FAQ,
    FieldPosition: () => DAQ,
    HttpApiKeyAuthLocation: () => VAQ,
    HttpAuthLocation: () => XAQ,
    IniSectionType: () => HAQ,
    RequestHandlerProtocol: () => CAQ,
    SMITHY_CONTEXT_KEY: () => yD4,
    getDefaultClientConfiguration: () => _D4,
    resolveDefaultRuntimeConfig: () => kD4
  });
  EAQ.exports = PD4(WAQ);
  var XAQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(XAQ || {}),
    VAQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(VAQ || {}),
    FAQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(FAQ || {}),
    KAQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(KAQ || {}),
    jD4 = qfA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    SD4 = qfA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    _D4 = qfA((A) => {
      return jD4(A)
    }, "getDefaultClientConfiguration"),
    kD4 = qfA((A) => {
      return SD4(A)
    }, "resolveDefaultRuntimeConfig"),
    DAQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(DAQ || {}),
    yD4 = "__smithy_context",
    HAQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(HAQ || {}),
    CAQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(CAQ || {})
})
// @from(Start 2292541, End 2297048)
LAQ = z((kH7, NAQ) => {
  var {
    defineProperty: NfA,
    getOwnPropertyDescriptor: xD4,
    getOwnPropertyNames: vD4
  } = Object, bD4 = Object.prototype.hasOwnProperty, Id = (A, Q) => NfA(A, "name", {
    value: Q,
    configurable: !0
  }), fD4 = (A, Q) => {
    for (var B in Q) NfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, hD4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of vD4(Q))
        if (!bD4.call(A, Z) && Z !== B) NfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = xD4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, gD4 = (A) => hD4(NfA({}, "__esModule", {
    value: !0
  }), A), UAQ = {};
  fD4(UAQ, {
    Field: () => dD4,
    Fields: () => cD4,
    HttpRequest: () => pD4,
    HttpResponse: () => lD4,
    IHttpRequest: () => $AQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => uD4,
    isValidHostname: () => qAQ,
    resolveHttpHandlerRuntimeConfig: () => mD4
  });
  NAQ.exports = gD4(UAQ);
  var uD4 = Id((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    mD4 = Id((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    $AQ = zAQ(),
    dD4 = class {
      static {
        Id(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = $AQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    cD4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Id(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    pD4 = class A {
      static {
        Id(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = wAQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function wAQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Id(wAQ, "cloneQuery");
  var lD4 = class {
    static {
      Id(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function qAQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Id(qAQ, "isValidHostname")
})
// @from(Start 2297054, End 2298107)
TAQ = z((bH7, RAQ) => {
  var {
    defineProperty: LfA,
    getOwnPropertyDescriptor: iD4,
    getOwnPropertyNames: nD4
  } = Object, aD4 = Object.prototype.hasOwnProperty, EU1 = (A, Q) => LfA(A, "name", {
    value: Q,
    configurable: !0
  }), sD4 = (A, Q) => {
    for (var B in Q) LfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, rD4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of nD4(Q))
        if (!aD4.call(A, Z) && Z !== B) LfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = iD4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, oD4 = (A) => rD4(LfA({}, "__esModule", {
    value: !0
  }), A), MAQ = {};
  sD4(MAQ, {
    escapeUri: () => OAQ,
    escapeUriPath: () => eD4
  });
  RAQ.exports = oD4(MAQ);
  var OAQ = EU1((A) => encodeURIComponent(A).replace(/[!'()*]/g, tD4), "escapeUri"),
    tD4 = EU1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    eD4 = EU1((A) => A.split("/").map(OAQ).join("/"), "escapeUriPath")
})
// @from(Start 2298113, End 2299364)
_AQ = z((fH7, SAQ) => {
  var {
    defineProperty: MfA,
    getOwnPropertyDescriptor: AH4,
    getOwnPropertyNames: QH4
  } = Object, BH4 = Object.prototype.hasOwnProperty, GH4 = (A, Q) => MfA(A, "name", {
    value: Q,
    configurable: !0
  }), ZH4 = (A, Q) => {
    for (var B in Q) MfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, IH4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of QH4(Q))
        if (!BH4.call(A, Z) && Z !== B) MfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = AH4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, YH4 = (A) => IH4(MfA({}, "__esModule", {
    value: !0
  }), A), PAQ = {};
  ZH4(PAQ, {
    buildQueryString: () => jAQ
  });
  SAQ.exports = YH4(PAQ);
  var zU1 = TAQ();

  function jAQ(A) {
    let Q = [];
    for (let B of Object.keys(A).sort()) {
      let G = A[B];
      if (B = (0, zU1.escapeUri)(B), Array.isArray(G))
        for (let Z = 0, I = G.length; Z < I; Z++) Q.push(`${B}=${(0,zU1.escapeUri)(G[Z])}`);
      else {
        let Z = B;
        if (G || typeof G === "string") Z += `=${(0,zU1.escapeUri)(G)}`;
        Q.push(Z)
      }
    }
    return Q.join("&")
  }
  GH4(jAQ, "buildQueryString")
})
// @from(Start 2299370, End 2318316)
IZ = z((hH7, lAQ) => {
  var {
    create: JH4,
    defineProperty: bDA,
    getOwnPropertyDescriptor: WH4,
    getOwnPropertyNames: XH4,
    getPrototypeOf: VH4
  } = Object, FH4 = Object.prototype.hasOwnProperty, ZZ = (A, Q) => bDA(A, "name", {
    value: Q,
    configurable: !0
  }), KH4 = (A, Q) => {
    for (var B in Q) bDA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, bAQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of XH4(Q))
        if (!FH4.call(A, Z) && Z !== B) bDA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = WH4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, DH4 = (A, Q, B) => (B = A != null ? JH4(VH4(A)) : {}, bAQ(Q || !A || !A.__esModule ? bDA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), HH4 = (A) => bAQ(bDA({}, "__esModule", {
    value: !0
  }), A), fAQ = {};
  KH4(fAQ, {
    DEFAULT_REQUEST_TIMEOUT: () => cAQ,
    NodeHttp2Handler: () => MH4,
    NodeHttpHandler: () => wH4,
    streamCollector: () => RH4
  });
  lAQ.exports = HH4(fAQ);
  var hAQ = LAQ(),
    gAQ = _AQ(),
    UU1 = UA("http"),
    $U1 = UA("https"),
    CH4 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"],
    uAQ = ZZ((A) => {
      let Q = {};
      for (let B of Object.keys(A)) {
        let G = A[B];
        Q[B] = Array.isArray(G) ? G.join(",") : G
      }
      return Q
    }, "getTransformedHeaders"),
    pz = {
      setTimeout: (A, Q) => setTimeout(A, Q),
      clearTimeout: (A) => clearTimeout(A)
    },
    kAQ = 1000,
    EH4 = ZZ((A, Q, B = 0) => {
      if (!B) return -1;
      let G = ZZ((Z) => {
        let I = pz.setTimeout(() => {
            A.destroy(), Q(Object.assign(Error(`Socket timed out without establishing a connection within ${B} ms`), {
              name: "TimeoutError"
            }))
          }, B - Z),
          Y = ZZ((J) => {
            if (J?.connecting) J.on("connect", () => {
              pz.clearTimeout(I)
            });
            else pz.clearTimeout(I)
          }, "doWithSocket");
        if (A.socket) Y(A.socket);
        else A.on("socket", Y)
      }, "registerTimeout");
      if (B < 2000) return G(0), 0;
      return pz.setTimeout(G.bind(null, kAQ), kAQ)
    }, "setConnectionTimeout"),
    zH4 = 3000,
    UH4 = ZZ((A, {
      keepAlive: Q,
      keepAliveMsecs: B
    }, G = zH4) => {
      if (Q !== !0) return -1;
      let Z = ZZ(() => {
        if (A.socket) A.socket.setKeepAlive(Q, B || 0);
        else A.on("socket", (I) => {
          I.setKeepAlive(Q, B || 0)
        })
      }, "registerListener");
      if (G === 0) return Z(), 0;
      return pz.setTimeout(Z, G)
    }, "setSocketKeepAlive"),
    yAQ = 3000,
    $H4 = ZZ((A, Q, B = cAQ) => {
      let G = ZZ((Z) => {
        let I = B - Z,
          Y = ZZ(() => {
            A.destroy(), Q(Object.assign(Error(`Connection timed out after ${B} ms`), {
              name: "TimeoutError"
            }))
          }, "onTimeout");
        if (A.socket) A.socket.setTimeout(I, Y), A.on("close", () => A.socket?.removeListener("timeout", Y));
        else A.setTimeout(I, Y)
      }, "registerTimeout");
      if (0 < B && B < 6000) return G(0), 0;
      return pz.setTimeout(G.bind(null, B === 0 ? 0 : yAQ), yAQ)
    }, "setSocketTimeout"),
    mAQ = UA("stream"),
    xAQ = 6000;
  async function wU1(A, Q, B = xAQ) {
    let G = Q.headers ?? {},
      Z = G.Expect || G.expect,
      I = -1,
      Y = !0;
    if (Z === "100-continue") Y = await Promise.race([new Promise((J) => {
      I = Number(pz.setTimeout(() => J(!0), Math.max(xAQ, B)))
    }), new Promise((J) => {
      A.on("continue", () => {
        pz.clearTimeout(I), J(!0)
      }), A.on("response", () => {
        pz.clearTimeout(I), J(!1)
      }), A.on("error", () => {
        pz.clearTimeout(I), J(!1)
      })
    })]);
    if (Y) dAQ(A, Q.body)
  }
  ZZ(wU1, "writeRequestBody");

  function dAQ(A, Q) {
    if (Q instanceof mAQ.Readable) {
      Q.pipe(A);
      return
    }
    if (Q) {
      if (Buffer.isBuffer(Q) || typeof Q === "string") {
        A.end(Q);
        return
      }
      let B = Q;
      if (typeof B === "object" && B.buffer && typeof B.byteOffset === "number" && typeof B.byteLength === "number") {
        A.end(Buffer.from(B.buffer, B.byteOffset, B.byteLength));
        return
      }
      A.end(Buffer.from(Q));
      return
    }
    A.end()
  }
  ZZ(dAQ, "writeBody");
  var cAQ = 0,
    wH4 = class A {
      constructor(Q) {
        this.socketWarningTimestamp = 0, this.metadata = {
          handlerProtocol: "http/1.1"
        }, this.configProvider = new Promise((B, G) => {
          if (typeof Q === "function") Q().then((Z) => {
            B(this.resolveDefaultConfig(Z))
          }).catch(G);
          else B(this.resolveDefaultConfig(Q))
        })
      }
      static {
        ZZ(this, "NodeHttpHandler")
      }
      static create(Q) {
        if (typeof Q?.handle === "function") return Q;
        return new A(Q)
      }
      static checkSocketUsage(Q, B, G = console) {
        let {
          sockets: Z,
          requests: I,
          maxSockets: Y
        } = Q;
        if (typeof Y !== "number" || Y === 1 / 0) return B;
        let J = 15000;
        if (Date.now() - J < B) return B;
        if (Z && I)
          for (let W in Z) {
            let X = Z[W]?.length ?? 0,
              V = I[W]?.length ?? 0;
            if (X >= Y && V >= 2 * Y) return G?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${X} and ${V} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`), Date.now()
          }
        return B
      }
      resolveDefaultConfig(Q) {
        let {
          requestTimeout: B,
          connectionTimeout: G,
          socketTimeout: Z,
          socketAcquisitionWarningTimeout: I,
          httpAgent: Y,
          httpsAgent: J
        } = Q || {}, W = !0, X = 50;
        return {
          connectionTimeout: G,
          requestTimeout: B ?? Z,
          socketAcquisitionWarningTimeout: I,
          httpAgent: (() => {
            if (Y instanceof UU1.Agent || typeof Y?.destroy === "function") return Y;
            return new UU1.Agent({
              keepAlive: !0,
              maxSockets: 50,
              ...Y
            })
          })(),
          httpsAgent: (() => {
            if (J instanceof $U1.Agent || typeof J?.destroy === "function") return J;
            return new $U1.Agent({
              keepAlive: !0,
              maxSockets: 50,
              ...J
            })
          })(),
          logger: console
        }
      }
      destroy() {
        this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy()
      }
      async handle(Q, {
        abortSignal: B
      } = {}) {
        if (!this.config) this.config = await this.configProvider;
        return new Promise((G, Z) => {
          let I = void 0,
            Y = [],
            J = ZZ(async (w) => {
              await I, Y.forEach(pz.clearTimeout), G(w)
            }, "resolve"),
            W = ZZ(async (w) => {
              await I, Y.forEach(pz.clearTimeout), Z(w)
            }, "reject");
          if (!this.config) throw Error("Node HTTP request handler config is not resolved");
          if (B?.aborted) {
            let w = Error("Request aborted");
            w.name = "AbortError", W(w);
            return
          }
          let X = Q.protocol === "https:",
            V = X ? this.config.httpsAgent : this.config.httpAgent;
          Y.push(pz.setTimeout(() => {
            this.socketWarningTimestamp = A.checkSocketUsage(V, this.socketWarningTimestamp, this.config.logger)
          }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000)));
          let F = (0, gAQ.buildQueryString)(Q.query || {}),
            K = void 0;
          if (Q.username != null || Q.password != null) {
            let w = Q.username ?? "",
              N = Q.password ?? "";
            K = `${w}:${N}`
          }
          let D = Q.path;
          if (F) D += `?${F}`;
          if (Q.fragment) D += `#${Q.fragment}`;
          let H = Q.hostname ?? "";
          if (H[0] === "[" && H.endsWith("]")) H = Q.hostname.slice(1, -1);
          else H = Q.hostname;
          let C = {
              headers: Q.headers,
              host: H,
              method: Q.method,
              path: D,
              port: Q.port,
              agent: V,
              auth: K
            },
            U = (X ? $U1.request : UU1.request)(C, (w) => {
              let N = new hAQ.HttpResponse({
                statusCode: w.statusCode || -1,
                reason: w.statusMessage,
                headers: uAQ(w.headers),
                body: w
              });
              J({
                response: N
              })
            });
          if (U.on("error", (w) => {
              if (CH4.includes(w.code)) W(Object.assign(w, {
                name: "TimeoutError"
              }));
              else W(w)
            }), B) {
            let w = ZZ(() => {
              U.destroy();
              let N = Error("Request aborted");
              N.name = "AbortError", W(N)
            }, "onAbort");
            if (typeof B.addEventListener === "function") {
              let N = B;
              N.addEventListener("abort", w, {
                once: !0
              }), U.once("close", () => N.removeEventListener("abort", w))
            } else B.onabort = w
          }
          Y.push(EH4(U, W, this.config.connectionTimeout)), Y.push($H4(U, W, this.config.requestTimeout));
          let q = C.agent;
          if (typeof q === "object" && "keepAlive" in q) Y.push(UH4(U, {
            keepAlive: q.keepAlive,
            keepAliveMsecs: q.keepAliveMsecs
          }));
          I = wU1(U, Q, this.config.requestTimeout).catch((w) => {
            return Y.forEach(pz.clearTimeout), Z(w)
          })
        })
      }
      updateHttpClientConfig(Q, B) {
        this.config = void 0, this.configProvider = this.configProvider.then((G) => {
          return {
            ...G,
            [Q]: B
          }
        })
      }
      httpHandlerConfigs() {
        return this.config ?? {}
      }
    },
    vAQ = UA("http2"),
    qH4 = DH4(UA("http2")),
    NH4 = class {
      constructor(A) {
        this.sessions = [], this.sessions = A ?? []
      }
      static {
        ZZ(this, "NodeHttp2ConnectionPool")
      }
      poll() {
        if (this.sessions.length > 0) return this.sessions.shift()
      }
      offerLast(A) {
        this.sessions.push(A)
      }
      contains(A) {
        return this.sessions.includes(A)
      }
      remove(A) {
        this.sessions = this.sessions.filter((Q) => Q !== A)
      } [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]()
      }
      destroy(A) {
        for (let Q of this.sessions)
          if (Q === A) {
            if (!Q.destroyed) Q.destroy()
          }
      }
    },
    LH4 = class {
      constructor(A) {
        if (this.sessionCache = new Map, this.config = A, this.config.maxConcurrency && this.config.maxConcurrency <= 0) throw RangeError("maxConcurrency must be greater than zero.")
      }
      static {
        ZZ(this, "NodeHttp2ConnectionManager")
      }
      lease(A, Q) {
        let B = this.getUrlString(A),
          G = this.sessionCache.get(B);
        if (G) {
          let J = G.poll();
          if (J && !this.config.disableConcurrency) return J
        }
        let Z = qH4.default.connect(B);
        if (this.config.maxConcurrency) Z.settings({
          maxConcurrentStreams: this.config.maxConcurrency
        }, (J) => {
          if (J) throw Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + A.destination.toString())
        });
        Z.unref();
        let I = ZZ(() => {
          Z.destroy(), this.deleteSession(B, Z)
        }, "destroySessionCb");
        if (Z.on("goaway", I), Z.on("error", I), Z.on("frameError", I), Z.on("close", () => this.deleteSession(B, Z)), Q.requestTimeout) Z.setTimeout(Q.requestTimeout, I);
        let Y = this.sessionCache.get(B) || new NH4;
        return Y.offerLast(Z), this.sessionCache.set(B, Y), Z
      }
      deleteSession(A, Q) {
        let B = this.sessionCache.get(A);
        if (!B) return;
        if (!B.contains(Q)) return;
        B.remove(Q), this.sessionCache.set(A, B)
      }
      release(A, Q) {
        let B = this.getUrlString(A);
        this.sessionCache.get(B)?.offerLast(Q)
      }
      destroy() {
        for (let [A, Q] of this.sessionCache) {
          for (let B of Q) {
            if (!B.destroyed) B.destroy();
            Q.remove(B)
          }
          this.sessionCache.delete(A)
        }
      }
      setMaxConcurrentStreams(A) {
        if (A && A <= 0) throw RangeError("maxConcurrentStreams must be greater than zero.");
        this.config.maxConcurrency = A
      }
      setDisableConcurrentStreams(A) {
        this.config.disableConcurrency = A
      }
      getUrlString(A) {
        return A.destination.toString()
      }
    },
    MH4 = class A {
      constructor(Q) {
        this.metadata = {
          handlerProtocol: "h2"
        }, this.connectionManager = new LH4({}), this.configProvider = new Promise((B, G) => {
          if (typeof Q === "function") Q().then((Z) => {
            B(Z || {})
          }).catch(G);
          else B(Q || {})
        })
      }
      static {
        ZZ(this, "NodeHttp2Handler")
      }
      static create(Q) {
        if (typeof Q?.handle === "function") return Q;
        return new A(Q)
      }
      destroy() {
        this.connectionManager.destroy()
      }
      async handle(Q, {
        abortSignal: B
      } = {}) {
        if (!this.config) {
          if (this.config = await this.configProvider, this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || !1), this.config.maxConcurrentStreams) this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams)
        }
        let {
          requestTimeout: G,
          disableConcurrentStreams: Z
        } = this.config;
        return new Promise((I, Y) => {
          let J = !1,
            W = void 0,
            X = ZZ(async (v) => {
              await W, I(v)
            }, "resolve"),
            V = ZZ(async (v) => {
              await W, Y(v)
            }, "reject");
          if (B?.aborted) {
            J = !0;
            let v = Error("Request aborted");
            v.name = "AbortError", V(v);
            return
          }
          let {
            hostname: F,
            method: K,
            port: D,
            protocol: H,
            query: C
          } = Q, E = "";
          if (Q.username != null || Q.password != null) {
            let v = Q.username ?? "",
              x = Q.password ?? "";
            E = `${v}:${x}@`
          }
          let U = `${H}//${E}${F}${D?`:${D}`:""}`,
            q = {
              destination: new URL(U)
            },
            w = this.connectionManager.lease(q, {
              requestTimeout: this.config?.sessionTimeout,
              disableConcurrentStreams: Z || !1
            }),
            N = ZZ((v) => {
              if (Z) this.destroySession(w);
              J = !0, V(v)
            }, "rejectWithDestroy"),
            R = (0, gAQ.buildQueryString)(C || {}),
            T = Q.path;
          if (R) T += `?${R}`;
          if (Q.fragment) T += `#${Q.fragment}`;
          let y = w.request({
            ...Q.headers,
            [vAQ.constants.HTTP2_HEADER_PATH]: T,
            [vAQ.constants.HTTP2_HEADER_METHOD]: K
          });
          if (w.ref(), y.on("response", (v) => {
              let x = new hAQ.HttpResponse({
                statusCode: v[":status"] || -1,
                headers: uAQ(v),
                body: y
              });
              if (J = !0, X({
                  response: x
                }), Z) w.close(), this.connectionManager.deleteSession(U, w)
            }), G) y.setTimeout(G, () => {
            y.close();
            let v = Error(`Stream timed out because of no activity for ${G} ms`);
            v.name = "TimeoutError", N(v)
          });
          if (B) {
            let v = ZZ(() => {
              y.close();
              let x = Error("Request aborted");
              x.name = "AbortError", N(x)
            }, "onAbort");
            if (typeof B.addEventListener === "function") {
              let x = B;
              x.addEventListener("abort", v, {
                once: !0
              }), y.once("close", () => x.removeEventListener("abort", v))
            } else B.onabort = v
          }
          y.on("frameError", (v, x, p) => {
            N(Error(`Frame type id ${v} in stream id ${p} has failed with code ${x}.`))
          }), y.on("error", N), y.on("aborted", () => {
            N(Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${y.rstCode}.`))
          }), y.on("close", () => {
            if (w.unref(), Z) w.destroy();
            if (!J) N(Error("Unexpected error: http2 request did not get a response"))
          }), W = wU1(y, Q, G)
        })
      }
      updateHttpClientConfig(Q, B) {
        this.config = void 0, this.configProvider = this.configProvider.then((G) => {
          return {
            ...G,
            [Q]: B
          }
        })
      }
      httpHandlerConfigs() {
        return this.config ?? {}
      }
      destroySession(Q) {
        if (!Q.destroyed) Q.destroy()
      }
    },
    OH4 = class extends mAQ.Writable {
      constructor() {
        super(...arguments);
        this.bufferedBytes = []
      }
      static {
        ZZ(this, "Collector")
      }
      _write(A, Q, B) {
        this.bufferedBytes.push(A), B()
      }
    },
    RH4 = ZZ((A) => {
      if (TH4(A)) return pAQ(A);
      return new Promise((Q, B) => {
        let G = new OH4;
        A.pipe(G), A.on("error", (Z) => {
          G.end(), B(Z)
        }), G.on("error", B), G.on("finish", function() {
          let Z = new Uint8Array(Buffer.concat(this.bufferedBytes));
          Q(Z)
        })
      })
    }, "streamCollector"),
    TH4 = ZZ((A) => typeof ReadableStream === "function" && A instanceof ReadableStream, "isReadableStreamInstance");
  async function pAQ(A) {
    let Q = [],
      B = A.getReader(),
      G = !1,
      Z = 0;
    while (!G) {
      let {
        done: J,
        value: W
      } = await B.read();
      if (W) Q.push(W), Z += W.length;
      G = J
    }
    let I = new Uint8Array(Z),
      Y = 0;
    for (let J of Q) I.set(J, Y), Y += J.length;
    return I
  }
  ZZ(pAQ, "collectReadableStream")
})
// @from(Start 2318322, End 2321105)
Q1Q = z((dH7, A1Q) => {
  var {
    defineProperty: OfA,
    getOwnPropertyDescriptor: PH4,
    getOwnPropertyNames: jH4
  } = Object, SH4 = Object.prototype.hasOwnProperty, RfA = (A, Q) => OfA(A, "name", {
    value: Q,
    configurable: !0
  }), _H4 = (A, Q) => {
    for (var B in Q) OfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, kH4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of jH4(Q))
        if (!SH4.call(A, Z) && Z !== B) OfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = PH4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, yH4 = (A) => kH4(OfA({}, "__esModule", {
    value: !0
  }), A), iAQ = {};
  _H4(iAQ, {
    AlgorithmId: () => rAQ,
    EndpointURLScheme: () => sAQ,
    FieldPosition: () => oAQ,
    HttpApiKeyAuthLocation: () => aAQ,
    HttpAuthLocation: () => nAQ,
    IniSectionType: () => tAQ,
    RequestHandlerProtocol: () => eAQ,
    SMITHY_CONTEXT_KEY: () => hH4,
    getDefaultClientConfiguration: () => bH4,
    resolveDefaultRuntimeConfig: () => fH4
  });
  A1Q.exports = yH4(iAQ);
  var nAQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(nAQ || {}),
    aAQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(aAQ || {}),
    sAQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(sAQ || {}),
    rAQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(rAQ || {}),
    xH4 = RfA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    vH4 = RfA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    bH4 = RfA((A) => {
      return xH4(A)
    }, "getDefaultClientConfiguration"),
    fH4 = RfA((A) => {
      return vH4(A)
    }, "resolveDefaultRuntimeConfig"),
    oAQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(oAQ || {}),
    hH4 = "__smithy_context",
    tAQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(tAQ || {}),
    eAQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(eAQ || {})
})
// @from(Start 2321111, End 2325618)
J1Q = z((cH7, Y1Q) => {
  var {
    defineProperty: TfA,
    getOwnPropertyDescriptor: gH4,
    getOwnPropertyNames: uH4
  } = Object, mH4 = Object.prototype.hasOwnProperty, Yd = (A, Q) => TfA(A, "name", {
    value: Q,
    configurable: !0
  }), dH4 = (A, Q) => {
    for (var B in Q) TfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, cH4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of uH4(Q))
        if (!mH4.call(A, Z) && Z !== B) TfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = gH4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, pH4 = (A) => cH4(TfA({}, "__esModule", {
    value: !0
  }), A), B1Q = {};
  dH4(B1Q, {
    Field: () => nH4,
    Fields: () => aH4,
    HttpRequest: () => sH4,
    HttpResponse: () => rH4,
    IHttpRequest: () => G1Q.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => lH4,
    isValidHostname: () => I1Q,
    resolveHttpHandlerRuntimeConfig: () => iH4
  });
  Y1Q.exports = pH4(B1Q);
  var lH4 = Yd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    iH4 = Yd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    G1Q = Q1Q(),
    nH4 = class {
      static {
        Yd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = G1Q.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    aH4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Yd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    sH4 = class A {
      static {
        Yd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = Z1Q(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function Z1Q(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Yd(Z1Q, "cloneQuery");
  var rH4 = class {
    static {
      Yd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function I1Q(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Yd(I1Q, "isValidHostname")
})
// @from(Start 2325624, End 2326677)
F1Q = z((nH7, V1Q) => {
  var {
    defineProperty: PfA,
    getOwnPropertyDescriptor: oH4,
    getOwnPropertyNames: tH4
  } = Object, eH4 = Object.prototype.hasOwnProperty, qU1 = (A, Q) => PfA(A, "name", {
    value: Q,
    configurable: !0
  }), AC4 = (A, Q) => {
    for (var B in Q) PfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, QC4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of tH4(Q))
        if (!eH4.call(A, Z) && Z !== B) PfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = oH4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, BC4 = (A) => QC4(PfA({}, "__esModule", {
    value: !0
  }), A), W1Q = {};
  AC4(W1Q, {
    escapeUri: () => X1Q,
    escapeUriPath: () => ZC4
  });
  V1Q.exports = BC4(W1Q);
  var X1Q = qU1((A) => encodeURIComponent(A).replace(/[!'()*]/g, GC4), "escapeUri"),
    GC4 = qU1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    ZC4 = qU1((A) => A.split("/").map(X1Q).join("/"), "escapeUriPath")
})
// @from(Start 2326683, End 2327934)
C1Q = z((aH7, H1Q) => {
  var {
    defineProperty: jfA,
    getOwnPropertyDescriptor: IC4,
    getOwnPropertyNames: YC4
  } = Object, JC4 = Object.prototype.hasOwnProperty, WC4 = (A, Q) => jfA(A, "name", {
    value: Q,
    configurable: !0
  }), XC4 = (A, Q) => {
    for (var B in Q) jfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, VC4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of YC4(Q))
        if (!JC4.call(A, Z) && Z !== B) jfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = IC4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, FC4 = (A) => VC4(jfA({}, "__esModule", {
    value: !0
  }), A), K1Q = {};
  XC4(K1Q, {
    buildQueryString: () => D1Q
  });
  H1Q.exports = FC4(K1Q);
  var NU1 = F1Q();

  function D1Q(A) {
    let Q = [];
    for (let B of Object.keys(A).sort()) {
      let G = A[B];
      if (B = (0, NU1.escapeUri)(B), Array.isArray(G))
        for (let Z = 0, I = G.length; Z < I; Z++) Q.push(`${B}=${(0,NU1.escapeUri)(G[Z])}`);
      else {
        let Z = B;
        if (G || typeof G === "string") Z += `=${(0,NU1.escapeUri)(G)}`;
        Q.push(Z)
      }
    }
    return Q.join("&")
  }
  WC4(D1Q, "buildQueryString")
})
// @from(Start 2327940, End 2333905)
L1Q = z((sH7, N1Q) => {
  var {
    defineProperty: _fA,
    getOwnPropertyDescriptor: KC4,
    getOwnPropertyNames: DC4
  } = Object, HC4 = Object.prototype.hasOwnProperty, ES = (A, Q) => _fA(A, "name", {
    value: Q,
    configurable: !0
  }), CC4 = (A, Q) => {
    for (var B in Q) _fA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, EC4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of DC4(Q))
        if (!HC4.call(A, Z) && Z !== B) _fA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = KC4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, zC4 = (A) => EC4(_fA({}, "__esModule", {
    value: !0
  }), A), z1Q = {};
  CC4(z1Q, {
    FetchHttpHandler: () => $C4,
    keepAliveSupport: () => SfA,
    streamCollector: () => qC4
  });
  N1Q.exports = zC4(z1Q);
  var E1Q = J1Q(),
    UC4 = C1Q();

  function LU1(A, Q) {
    return new Request(A, Q)
  }
  ES(LU1, "createRequest");

  function U1Q(A = 0) {
    return new Promise((Q, B) => {
      if (A) setTimeout(() => {
        let G = Error(`Request did not complete within ${A} ms`);
        G.name = "TimeoutError", B(G)
      }, A)
    })
  }
  ES(U1Q, "requestTimeout");
  var SfA = {
      supported: void 0
    },
    $C4 = class A {
      static {
        ES(this, "FetchHttpHandler")
      }
      static create(Q) {
        if (typeof Q?.handle === "function") return Q;
        return new A(Q)
      }
      constructor(Q) {
        if (typeof Q === "function") this.configProvider = Q().then((B) => B || {});
        else this.config = Q ?? {}, this.configProvider = Promise.resolve(this.config);
        if (SfA.supported === void 0) SfA.supported = Boolean(typeof Request < "u" && "keepalive" in LU1("https://[::1]"))
      }
      destroy() {}
      async handle(Q, {
        abortSignal: B
      } = {}) {
        if (!this.config) this.config = await this.configProvider;
        let G = this.config.requestTimeout,
          Z = this.config.keepAlive === !0,
          I = this.config.credentials;
        if (B?.aborted) {
          let U = Error("Request aborted");
          return U.name = "AbortError", Promise.reject(U)
        }
        let Y = Q.path,
          J = (0, UC4.buildQueryString)(Q.query || {});
        if (J) Y += `?${J}`;
        if (Q.fragment) Y += `#${Q.fragment}`;
        let W = "";
        if (Q.username != null || Q.password != null) {
          let U = Q.username ?? "",
            q = Q.password ?? "";
          W = `${U}:${q}@`
        }
        let {
          port: X,
          method: V
        } = Q, F = `${Q.protocol}//${W}${Q.hostname}${X?`:${X}`:""}${Y}`, K = V === "GET" || V === "HEAD" ? void 0 : Q.body, D = {
          body: K,
          headers: new Headers(Q.headers),
          method: V,
          credentials: I
        };
        if (this.config?.cache) D.cache = this.config.cache;
        if (K) D.duplex = "half";
        if (typeof AbortController < "u") D.signal = B;
        if (SfA.supported) D.keepalive = Z;
        if (typeof this.config.requestInit === "function") Object.assign(D, this.config.requestInit(Q));
        let H = ES(() => {}, "removeSignalEventListener"),
          C = LU1(F, D),
          E = [fetch(C).then((U) => {
            let q = U.headers,
              w = {};
            for (let R of q.entries()) w[R[0]] = R[1];
            if (U.body == null) return U.blob().then((R) => ({
              response: new E1Q.HttpResponse({
                headers: w,
                reason: U.statusText,
                statusCode: U.status,
                body: R
              })
            }));
            return {
              response: new E1Q.HttpResponse({
                headers: w,
                reason: U.statusText,
                statusCode: U.status,
                body: U.body
              })
            }
          }), U1Q(G)];
        if (B) E.push(new Promise((U, q) => {
          let w = ES(() => {
            let N = Error("Request aborted");
            N.name = "AbortError", q(N)
          }, "onAbort");
          if (typeof B.addEventListener === "function") {
            let N = B;
            N.addEventListener("abort", w, {
              once: !0
            }), H = ES(() => N.removeEventListener("abort", w), "removeSignalEventListener")
          } else B.onabort = w
        }));
        return Promise.race(E).finally(H)
      }
      updateHttpClientConfig(Q, B) {
        this.config = void 0, this.configProvider = this.configProvider.then((G) => {
          return G[Q] = B, G
        })
      }
      httpHandlerConfigs() {
        return this.config ?? {}
      }
    },
    wC4 = v4A(),
    qC4 = ES(async (A) => {
      if (typeof Blob === "function" && A instanceof Blob || A.constructor?.name === "Blob") {
        if (Blob.prototype.arrayBuffer !== void 0) return new Uint8Array(await A.arrayBuffer());
        return $1Q(A)
      }
      return w1Q(A)
    }, "streamCollector");
  async function $1Q(A) {
    let Q = await q1Q(A),
      B = (0, wC4.fromBase64)(Q);
    return new Uint8Array(B)
  }
  ES($1Q, "collectBlob");
  async function w1Q(A) {
    let Q = [],
      B = A.getReader(),
      G = !1,
      Z = 0;
    while (!G) {
      let {
        done: J,
        value: W
      } = await B.read();
      if (W) Q.push(W), Z += W.length;
      G = J
    }
    let I = new Uint8Array(Z),
      Y = 0;
    for (let J of Q) I.set(J, Y), Y += J.length;
    return I
  }
  ES(w1Q, "collectStream");

  function q1Q(A) {
    return new Promise((Q, B) => {
      let G = new FileReader;
      G.onloadend = () => {
        if (G.readyState !== 2) return B(Error("Reader aborted too early"));
        let Z = G.result ?? "",
          I = Z.indexOf(","),
          Y = I > -1 ? I + 1 : Z.length;
        Q(Z.substring(Y))
      }, G.onabort = () => B(Error("Read aborted")), G.onerror = () => B(G.error), G.readAsDataURL(A)
    })
  }
  ES(q1Q, "readToBase64")
})
// @from(Start 2333911, End 2335436)
Jd = z((rH7, j1Q) => {
  var {
    defineProperty: kfA,
    getOwnPropertyDescriptor: NC4,
    getOwnPropertyNames: LC4
  } = Object, MC4 = Object.prototype.hasOwnProperty, M1Q = (A, Q) => kfA(A, "name", {
    value: Q,
    configurable: !0
  }), OC4 = (A, Q) => {
    for (var B in Q) kfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, RC4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of LC4(Q))
        if (!MC4.call(A, Z) && Z !== B) kfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = NC4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, TC4 = (A) => RC4(kfA({}, "__esModule", {
    value: !0
  }), A), O1Q = {};
  OC4(O1Q, {
    fromHex: () => T1Q,
    toHex: () => P1Q
  });
  j1Q.exports = TC4(O1Q);
  var R1Q = {},
    MU1 = {};
  for (let A = 0; A < 256; A++) {
    let Q = A.toString(16).toLowerCase();
    if (Q.length === 1) Q = `0${Q}`;
    R1Q[A] = Q, MU1[Q] = A
  }

  function T1Q(A) {
    if (A.length % 2 !== 0) throw Error("Hex encoded strings must have an even number length");
    let Q = new Uint8Array(A.length / 2);
    for (let B = 0; B < A.length; B += 2) {
      let G = A.slice(B, B + 2).toLowerCase();
      if (G in MU1) Q[B / 2] = MU1[G];
      else throw Error(`Cannot decode unrecognized sequence ${G} as hexadecimal`)
    }
    return Q
  }
  M1Q(T1Q, "fromHex");

  function P1Q(A) {
    let Q = "";
    for (let B = 0; B < A.byteLength; B++) Q += R1Q[A[B]];
    return Q
  }
  M1Q(P1Q, "toHex")
})
// @from(Start 2335442, End 2337487)
v1Q = z((y1Q) => {
  Object.defineProperty(y1Q, "__esModule", {
    value: !0
  });
  y1Q.sdkStreamMixin = void 0;
  var PC4 = L1Q(),
    jC4 = v4A(),
    SC4 = Jd(),
    _C4 = O2(),
    S1Q = Zd(),
    _1Q = "The stream has already been transformed.",
    kC4 = (A) => {
      var Q, B;
      if (!k1Q(A) && !(0, S1Q.isReadableStream)(A)) {
        let Y = ((B = (Q = A === null || A === void 0 ? void 0 : A.__proto__) === null || Q === void 0 ? void 0 : Q.constructor) === null || B === void 0 ? void 0 : B.name) || A;
        throw Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${Y}`)
      }
      let G = !1,
        Z = async () => {
          if (G) throw Error(_1Q);
          return G = !0, await (0, PC4.streamCollector)(A)
        }, I = (Y) => {
          if (typeof Y.stream !== "function") throw Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
          return Y.stream()
        };
      return Object.assign(A, {
        transformToByteArray: Z,
        transformToString: async (Y) => {
          let J = await Z();
          if (Y === "base64") return (0, jC4.toBase64)(J);
          else if (Y === "hex") return (0, SC4.toHex)(J);
          else if (Y === void 0 || Y === "utf8" || Y === "utf-8") return (0, _C4.toUtf8)(J);
          else if (typeof TextDecoder === "function") return new TextDecoder(Y).decode(J);
          else throw Error("TextDecoder is not available, please make sure polyfill is provided.")
        },
        transformToWebStream: () => {
          if (G) throw Error(_1Q);
          if (G = !0, k1Q(A)) return I(A);
          else if ((0, S1Q.isReadableStream)(A)) return A;
          else throw Error(`Cannot transform payload to web stream, got ${A}`)
        }
      })
    };
  y1Q.sdkStreamMixin = kC4;
  var k1Q = (A) => typeof Blob === "function" && A instanceof Blob
})
// @from(Start 2337493, End 2339076)
g1Q = z((f1Q) => {
  Object.defineProperty(f1Q, "__esModule", {
    value: !0
  });
  f1Q.sdkStreamMixin = void 0;
  var yC4 = IZ(),
    xC4 = hI(),
    OU1 = UA("stream"),
    vC4 = v1Q(),
    b1Q = "The stream has already been transformed.",
    bC4 = (A) => {
      var Q, B;
      if (!(A instanceof OU1.Readable)) try {
        return (0, vC4.sdkStreamMixin)(A)
      } catch (I) {
        let Y = ((B = (Q = A === null || A === void 0 ? void 0 : A.__proto__) === null || Q === void 0 ? void 0 : Q.constructor) === null || B === void 0 ? void 0 : B.name) || A;
        throw Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${Y}`)
      }
      let G = !1,
        Z = async () => {
          if (G) throw Error(b1Q);
          return G = !0, await (0, yC4.streamCollector)(A)
        };
      return Object.assign(A, {
        transformToByteArray: Z,
        transformToString: async (I) => {
          let Y = await Z();
          if (I === void 0 || Buffer.isEncoding(I)) return (0, xC4.fromArrayBuffer)(Y.buffer, Y.byteOffset, Y.byteLength).toString(I);
          else return new TextDecoder(I).decode(Y)
        },
        transformToWebStream: () => {
          if (G) throw Error(b1Q);
          if (A.readableFlowing !== null) throw Error("The stream has been consumed by other callbacks.");
          if (typeof OU1.Readable.toWeb !== "function") throw Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
          return G = !0, OU1.Readable.toWeb(A)
        }
      })
    };
  f1Q.sdkStreamMixin = bC4
})
// @from(Start 2339082, End 2339298)
m1Q = z((u1Q) => {
  Object.defineProperty(u1Q, "__esModule", {
    value: !0
  });
  u1Q.splitStream = fC4;
  async function fC4(A) {
    if (typeof A.stream === "function") A = A.stream();
    return A.tee()
  }
})
// @from(Start 2339304, End 2339700)
l1Q = z((p1Q) => {
  Object.defineProperty(p1Q, "__esModule", {
    value: !0
  });
  p1Q.splitStream = uC4;
  var d1Q = UA("stream"),
    gC4 = m1Q(),
    c1Q = Zd();
  async function uC4(A) {
    if ((0, c1Q.isReadableStream)(A) || (0, c1Q.isBlob)(A)) return (0, gC4.splitStream)(A);
    let Q = new d1Q.PassThrough,
      B = new d1Q.PassThrough;
    return A.pipe(Q), A.pipe(B), [Q, B]
  }
})
// @from(Start 2339706, End 2341653)
Xd = z((QC7, US) => {
  var {
    defineProperty: yfA,
    getOwnPropertyDescriptor: dC4,
    getOwnPropertyNames: cC4
  } = Object, pC4 = Object.prototype.hasOwnProperty, PU1 = (A, Q) => yfA(A, "name", {
    value: Q,
    configurable: !0
  }), lC4 = (A, Q) => {
    for (var B in Q) yfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, RU1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of cC4(Q))
        if (!pC4.call(A, Z) && Z !== B) yfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = dC4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Wd = (A, Q, B) => (RU1(A, Q, "default"), B && RU1(B, Q, "default")), iC4 = (A) => RU1(yfA({}, "__esModule", {
    value: !0
  }), A), zS = {};
  lC4(zS, {
    Uint8ArrayBlobAdapter: () => TU1
  });
  US.exports = iC4(zS);
  var i1Q = v4A(),
    n1Q = O2();

  function a1Q(A, Q = "utf-8") {
    if (Q === "base64") return (0, i1Q.toBase64)(A);
    return (0, n1Q.toUtf8)(A)
  }
  PU1(a1Q, "transformToString");

  function s1Q(A, Q) {
    if (Q === "base64") return TU1.mutate((0, i1Q.fromBase64)(A));
    return TU1.mutate((0, n1Q.fromUtf8)(A))
  }
  PU1(s1Q, "transformFromString");
  var TU1 = class A extends Uint8Array {
    static {
      PU1(this, "Uint8ArrayBlobAdapter")
    }
    static fromString(Q, B = "utf-8") {
      switch (typeof Q) {
        case "string":
          return s1Q(Q, B);
        default:
          throw Error(`Unsupported conversion from ${typeof Q} to Uint8ArrayBlobAdapter.`)
      }
    }
    static mutate(Q) {
      return Object.setPrototypeOf(Q, A.prototype), Q
    }
    transformToString(Q = "utf-8") {
      return a1Q(this, Q)
    }
  };
  Wd(zS, HU1(), US.exports);
  Wd(zS, ue0(), US.exports);
  Wd(zS, te0(), US.exports);
  Wd(zS, QAQ(), US.exports);
  Wd(zS, JAQ(), US.exports);
  Wd(zS, g1Q(), US.exports);
  Wd(zS, l1Q(), US.exports);
  Wd(zS, Zd(), US.exports)
})
// @from(Start 2341659, End 2356448)
b4 = z((BC7, Q0Q) => {
  var {
    defineProperty: SU1,
    getOwnPropertyDescriptor: nC4,
    getOwnPropertyNames: aC4
  } = Object, sC4 = Object.prototype.hasOwnProperty, rC4 = (A, Q) => {
    for (var B in Q) SU1(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, oC4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of aC4(Q))
        if (!sC4.call(A, Z) && Z !== B) SU1(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = nC4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, tC4 = (A) => oC4(SU1({}, "__esModule", {
    value: !0
  }), A), r1Q = {};
  rC4(r1Q, {
    ErrorSchema: () => A0Q,
    ListSchema: () => _U1,
    MapSchema: () => kU1,
    NormalizedSchema: () => FE4,
    OperationSchema: () => e1Q,
    SCHEMA: () => XW,
    Schema: () => f4A,
    SimpleSchema: () => yU1,
    StructureSchema: () => xfA,
    TypeRegistry: () => _r,
    deref: () => fDA,
    deserializerMiddlewareOption: () => o1Q,
    error: () => XE4,
    getSchemaSerdePlugin: () => ZE4,
    list: () => IE4,
    map: () => YE4,
    op: () => JE4,
    serializerMiddlewareOption: () => t1Q,
    sim: () => VE4,
    struct: () => WE4
  });
  Q0Q.exports = tC4(r1Q);
  var fDA = (A) => {
      if (typeof A === "function") return A();
      return A
    },
    eC4 = Sr(),
    AE4 = w7(),
    QE4 = (A) => (Q, B) => async (G) => {
      let {
        response: Z
      } = await Q(G), {
        operationSchema: I
      } = (0, AE4.getSmithyContext)(B);
      try {
        let Y = await A.protocol.deserializeResponse(I, {
          ...A,
          ...B
        }, Z);
        return {
          response: Z,
          output: Y
        }
      } catch (Y) {
        if (Object.defineProperty(Y, "$response", {
            value: Z
          }), !("$metadata" in Y)) {
          try {
            Y.message += `
  Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`
          } catch (W) {
            if (!B.logger || B.logger?.constructor?.name === "NoOpLogger") console.warn("Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.");
            else B.logger?.warn?.("Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.")
          }
          if (typeof Y.$responseBodyText < "u") {
            if (Y.$response) Y.$response.body = Y.$responseBodyText
          }
          try {
            if (eC4.HttpResponse.isInstance(Z)) {
              let {
                headers: W = {}
              } = Z, X = Object.entries(W);
              Y.$metadata = {
                httpStatusCode: Z.statusCode,
                requestId: jU1(/^x-[\w-]+-request-?id$/, X),
                extendedRequestId: jU1(/^x-[\w-]+-id-2$/, X),
                cfId: jU1(/^x-[\w-]+-cf-id$/, X)
              }
            }
          } catch (W) {}
        }
        throw Y
      }
    }, jU1 = (A, Q) => {
      return (Q.find(([B]) => {
        return B.match(A)
      }) || [void 0, void 0])[1]
    }, BE4 = w7(), GE4 = (A) => (Q, B) => async (G) => {
      let {
        operationSchema: Z
      } = (0, BE4.getSmithyContext)(B), I = B.endpointV2?.url && A.urlParser ? async () => A.urlParser(B.endpointV2.url): A.endpoint, Y = await A.protocol.serializeRequest(Z, G.input, {
        ...A,
        ...B,
        endpoint: I
      });
      return Q({
        ...G,
        request: Y
      })
    }, o1Q = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0
    }, t1Q = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: !0
    };

  function ZE4(A) {
    return {
      applyToStack: (Q) => {
        Q.add(GE4(A), t1Q), Q.add(QE4(A), o1Q), A.protocol.setSerdeContext(A)
      }
    }
  }
  var _r = class A {
      constructor(Q, B = new Map) {
        this.namespace = Q, this.schemas = B
      }
      static {
        this.registries = new Map
      }
      static
      for (Q) {
        if (!A.registries.has(Q)) A.registries.set(Q, new A(Q));
        return A.registries.get(Q)
      }
      register(Q, B) {
        let G = this.normalizeShapeId(Q);
        A.for(this.getNamespace(Q)).schemas.set(G, B)
      }
      getSchema(Q) {
        let B = this.normalizeShapeId(Q);
        if (!this.schemas.has(B)) throw Error(`@smithy/core/schema - schema not found for ${B}`);
        return this.schemas.get(B)
      }
      getBaseException() {
        for (let [Q, B] of this.schemas.entries())
          if (Q.startsWith("smithy.ts.sdk.synthetic.") && Q.endsWith("ServiceException")) return B;
        return
      }
      find(Q) {
        return [...this.schemas.values()].find(Q)
      }
      destroy() {
        A.registries.delete(this.namespace), this.schemas.clear()
      }
      normalizeShapeId(Q) {
        if (Q.includes("#")) return Q;
        return this.namespace + "#" + Q
      }
      getNamespace(Q) {
        return this.normalizeShapeId(Q).split("#")[0]
      }
    },
    f4A = class {
      constructor(A, Q) {
        this.name = A, this.traits = Q
      }
    },
    _U1 = class extends f4A {
      constructor(A, Q, B) {
        super(A, Q);
        this.name = A, this.traits = Q, this.valueSchema = B
      }
    };

  function IE4(A, Q, B = {}, G) {
    let Z = new _U1(A + "#" + Q, B, typeof G === "function" ? G() : G);
    return _r.for(A).register(Q, Z), Z
  }
  var kU1 = class extends f4A {
    constructor(A, Q, B, G) {
      super(A, Q);
      this.name = A, this.traits = Q, this.keySchema = B, this.valueSchema = G
    }
  };

  function YE4(A, Q, B = {}, G, Z) {
    let I = new kU1(A + "#" + Q, B, G, typeof Z === "function" ? Z() : Z);
    return _r.for(A).register(Q, I), I
  }
  var e1Q = class extends f4A {
    constructor(A, Q, B, G) {
      super(A, Q);
      this.name = A, this.traits = Q, this.input = B, this.output = G
    }
  };

  function JE4(A, Q, B = {}, G, Z) {
    let I = new e1Q(A + "#" + Q, B, G, Z);
    return _r.for(A).register(Q, I), I
  }
  var xfA = class extends f4A {
    constructor(A, Q, B, G) {
      super(A, Q);
      this.name = A, this.traits = Q, this.memberNames = B, this.memberList = G, this.members = {};
      for (let Z = 0; Z < B.length; ++Z) this.members[B[Z]] = Array.isArray(G[Z]) ? G[Z] : [G[Z], 0]
    }
  };

  function WE4(A, Q, B, G, Z) {
    let I = new xfA(A + "#" + Q, B, G, Z);
    return _r.for(A).register(Q, I), I
  }
  var A0Q = class extends xfA {
    constructor(A, Q, B, G, Z) {
      super(A, Q, B, G);
      this.name = A, this.traits = Q, this.memberNames = B, this.memberList = G, this.ctor = Z
    }
  };

  function XE4(A, Q, B = {}, G, Z, I) {
    let Y = new A0Q(A + "#" + Q, B, G, Z, I);
    return _r.for(A).register(Q, Y), Y
  }
  var XW = {
      BLOB: 21,
      STREAMING_BLOB: 42,
      BOOLEAN: 2,
      STRING: 0,
      NUMERIC: 1,
      BIG_INTEGER: 17,
      BIG_DECIMAL: 19,
      DOCUMENT: 15,
      TIMESTAMP_DEFAULT: 4,
      TIMESTAMP_DATE_TIME: 5,
      TIMESTAMP_HTTP_DATE: 6,
      TIMESTAMP_EPOCH_SECONDS: 7,
      LIST_MODIFIER: 64,
      MAP_MODIFIER: 128
    },
    yU1 = class extends f4A {
      constructor(A, Q, B) {
        super(A, B);
        this.name = A, this.schemaRef = Q, this.traits = B
      }
    };

  function VE4(A, Q, B, G) {
    let Z = new yU1(A + "#" + Q, B, G);
    return _r.for(A).register(Q, Z), Z
  }
  var FE4 = class A {
    constructor(Q, B) {
      this.ref = Q, this.memberName = B;
      let G = [],
        Z = Q,
        I = Q;
      this._isMemberSchema = !1;
      while (Array.isArray(Z)) G.push(Z[1]), Z = Z[0], I = fDA(Z), this._isMemberSchema = !0;
      if (G.length > 0) {
        this.memberTraits = {};
        for (let Y = G.length - 1; Y >= 0; --Y) {
          let J = G[Y];
          Object.assign(this.memberTraits, A.translateTraits(J))
        }
      } else this.memberTraits = 0;
      if (I instanceof A) {
        this.name = I.name, this.traits = I.traits, this._isMemberSchema = I._isMemberSchema, this.schema = I.schema, this.memberTraits = Object.assign({}, I.getMemberTraits(), this.getMemberTraits()), this.normalizedTraits = void 0, this.ref = I.ref, this.memberName = B ?? I.memberName;
        return
      }
      if (this.schema = fDA(I), this.schema && typeof this.schema === "object") this.traits = this.schema?.traits ?? {};
      else this.traits = 0;
      if (this.name = (typeof this.schema === "object" ? this.schema?.name : void 0) ?? this.memberName ?? this.getSchemaName(), this._isMemberSchema && !B) throw Error(`@smithy/core/schema - NormalizedSchema member schema ${this.getName(!0)} must initialize with memberName argument.`)
    }
    static of (Q, B) {
      if (Q instanceof A) return Q;
      return new A(Q, B)
    }
    static translateTraits(Q) {
      if (typeof Q === "object") return Q;
      Q = Q | 0;
      let B = {};
      if ((Q & 1) === 1) B.httpLabel = 1;
      if ((Q >> 1 & 1) === 1) B.idempotent = 1;
      if ((Q >> 2 & 1) === 1) B.idempotencyToken = 1;
      if ((Q >> 3 & 1) === 1) B.sensitive = 1;
      if ((Q >> 4 & 1) === 1) B.httpPayload = 1;
      if ((Q >> 5 & 1) === 1) B.httpResponseCode = 1;
      if ((Q >> 6 & 1) === 1) B.httpQueryParams = 1;
      return B
    }
    static memberFrom(Q, B) {
      if (Q instanceof A) return Q.memberName = B, Q._isMemberSchema = !0, Q;
      return new A(Q, B)
    }
    getSchema() {
      if (this.schema instanceof A) return this.schema = this.schema.getSchema();
      if (this.schema instanceof yU1) return fDA(this.schema.schemaRef);
      return fDA(this.schema)
    }
    getName(Q = !1) {
      if (!Q) {
        if (this.name && this.name.includes("#")) return this.name.split("#")[1]
      }
      return this.name || void 0
    }
    getMemberName() {
      if (!this.isMemberSchema()) throw Error(`@smithy/core/schema - cannot get member name on non-member schema: ${this.getName(!0)}`);
      return this.memberName
    }
    isMemberSchema() {
      return this._isMemberSchema
    }
    isUnitSchema() {
      return this.getSchema() === "unit"
    }
    isListSchema() {
      let Q = this.getSchema();
      if (typeof Q === "number") return Q >= XW.LIST_MODIFIER && Q < XW.MAP_MODIFIER;
      return Q instanceof _U1
    }
    isMapSchema() {
      let Q = this.getSchema();
      if (typeof Q === "number") return Q >= XW.MAP_MODIFIER && Q <= 255;
      return Q instanceof kU1
    }
    isDocumentSchema() {
      return this.getSchema() === XW.DOCUMENT
    }
    isStructSchema() {
      let Q = this.getSchema();
      return Q !== null && typeof Q === "object" && "members" in Q || Q instanceof xfA
    }
    isBlobSchema() {
      return this.getSchema() === XW.BLOB || this.getSchema() === XW.STREAMING_BLOB
    }
    isTimestampSchema() {
      let Q = this.getSchema();
      return typeof Q === "number" && Q >= XW.TIMESTAMP_DEFAULT && Q <= XW.TIMESTAMP_EPOCH_SECONDS
    }
    isStringSchema() {
      return this.getSchema() === XW.STRING
    }
    isBooleanSchema() {
      return this.getSchema() === XW.BOOLEAN
    }
    isNumericSchema() {
      return this.getSchema() === XW.NUMERIC
    }
    isBigIntegerSchema() {
      return this.getSchema() === XW.BIG_INTEGER
    }
    isBigDecimalSchema() {
      return this.getSchema() === XW.BIG_DECIMAL
    }
    isStreaming() {
      if (!!this.getMergedTraits().streaming) return !0;
      return this.getSchema() === XW.STREAMING_BLOB
    }
    getMergedTraits() {
      if (this.normalizedTraits) return this.normalizedTraits;
      return this.normalizedTraits = {
        ...this.getOwnTraits(),
        ...this.getMemberTraits()
      }, this.normalizedTraits
    }
    getMemberTraits() {
      return A.translateTraits(this.memberTraits)
    }
    getOwnTraits() {
      return A.translateTraits(this.traits)
    }
    getKeySchema() {
      if (this.isDocumentSchema()) return A.memberFrom([XW.DOCUMENT, 0], "key");
      if (!this.isMapSchema()) throw Error(`@smithy/core/schema - cannot get key schema for non-map schema: ${this.getName(!0)}`);
      let Q = this.getSchema();
      if (typeof Q === "number") return A.memberFrom([63 & Q, 0], "key");
      return A.memberFrom([Q.keySchema, 0], "key")
    }
    getValueSchema() {
      let Q = this.getSchema();
      if (typeof Q === "number") {
        if (this.isMapSchema()) return A.memberFrom([63 & Q, 0], "value");
        else if (this.isListSchema()) return A.memberFrom([63 & Q, 0], "member")
      }
      if (Q && typeof Q === "object") {
        if (this.isStructSchema()) throw Error(`cannot call getValueSchema() with StructureSchema ${this.getName(!0)}`);
        let B = Q;
        if ("valueSchema" in B) {
          if (this.isMapSchema()) return A.memberFrom([B.valueSchema, 0], "value");
          else if (this.isListSchema()) return A.memberFrom([B.valueSchema, 0], "member")
        }
      }
      if (this.isDocumentSchema()) return A.memberFrom([XW.DOCUMENT, 0], "value");
      throw Error(`@smithy/core/schema - the schema ${this.getName(!0)} does not have a value member.`)
    }
    getMemberSchema(Q) {
      if (this.isStructSchema()) {
        let B = this.getSchema();
        if (!(Q in B.members)) throw Error(`@smithy/core/schema - the schema ${this.getName(!0)} does not have a member with name=${Q}.`);
        return A.memberFrom(B.members[Q], Q)
      }
      if (this.isDocumentSchema()) return A.memberFrom([XW.DOCUMENT, 0], Q);
      throw Error(`@smithy/core/schema - the schema ${this.getName(!0)} does not have members.`)
    }
    getMemberSchemas() {
      let {
        schema: Q
      } = this, B = Q;
      if (!B || typeof B !== "object") return {};
      if ("members" in B) {
        let G = {};
        for (let Z of B.memberNames) G[Z] = this.getMemberSchema(Z);
        return G
      }
      return {}
    }* structIterator() {
      if (this.isUnitSchema()) return;
      if (!this.isStructSchema()) throw Error("@smithy/core/schema - cannot acquire structIterator on non-struct schema.");
      let Q = this.getSchema();
      for (let B = 0; B < Q.memberNames.length; ++B) yield [Q.memberNames[B], A.memberFrom([Q.memberList[B], 0], Q.memberNames[B])]
    }
    getSchemaName() {
      let Q = this.getSchema();
      if (typeof Q === "number") {
        let B = 63 & Q,
          G = 192 & Q,
          Z = Object.entries(XW).find(([, I]) => {
            return I === B
          })?.[0] ?? "Unknown";
        switch (G) {
          case XW.MAP_MODIFIER:
            return `${Z}Map`;
          case XW.LIST_MODIFIER:
            return `${Z}List`;
          case 0:
            return Z
        }
      }
      return "Unknown"
    }
  }
})
// @from(Start 2356454, End 2373150)
s6 = z((VC7, X0Q) => {
  var {
    defineProperty: hU1,
    getOwnPropertyDescriptor: KE4,
    getOwnPropertyNames: DE4
  } = Object, HE4 = Object.prototype.hasOwnProperty, CE4 = (A, Q) => {
    for (var B in Q) hU1(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, EE4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of DE4(Q))
        if (!HE4.call(A, Z) && Z !== B) hU1(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = KE4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, zE4 = (A) => EE4(hU1({}, "__esModule", {
    value: !0
  }), A), B0Q = {};
  CE4(B0Q, {
    LazyJsonString: () => kr,
    NumericValue: () => W0Q,
    copyDocumentWithTransform: () => hDA,
    dateToUtcString: () => vE4,
    expectBoolean: () => wE4,
    expectByte: () => fU1,
    expectFloat32: () => vfA,
    expectInt: () => NE4,
    expectInt32: () => vU1,
    expectLong: () => mDA,
    expectNonNull: () => ME4,
    expectNumber: () => uDA,
    expectObject: () => G0Q,
    expectShort: () => bU1,
    expectString: () => OE4,
    expectUnion: () => RE4,
    handleFloat: () => jE4,
    limitedParseDouble: () => mU1,
    limitedParseFloat: () => SE4,
    limitedParseFloat32: () => _E4,
    logger: () => dDA,
    nv: () => Bz4,
    parseBoolean: () => $E4,
    parseEpochTimestamp: () => pE4,
    parseRfc3339DateTime: () => fE4,
    parseRfc3339DateTimeWithOffset: () => gE4,
    parseRfc7231DateTime: () => cE4,
    quoteHeader: () => eE4,
    splitEvery: () => Az4,
    splitHeader: () => Qz4,
    strictParseByte: () => J0Q,
    strictParseDouble: () => uU1,
    strictParseFloat: () => TE4,
    strictParseFloat32: () => Z0Q,
    strictParseInt: () => kE4,
    strictParseInt32: () => yE4,
    strictParseLong: () => Y0Q,
    strictParseShort: () => h4A
  });
  X0Q.exports = zE4(B0Q);
  var UE4 = b4(),
    hDA = (A, Q, B = (G) => G) => {
      let G = UE4.NormalizedSchema.of(Q);
      switch (typeof A) {
        case "undefined":
        case "boolean":
        case "number":
        case "string":
        case "bigint":
        case "symbol":
          return B(A, G);
        case "function":
        case "object":
          if (A === null) return B(null, G);
          if (Array.isArray(A)) {
            let I = Array(A.length),
              Y = 0;
            for (let J of A) I[Y++] = hDA(J, G.getValueSchema(), B);
            return B(I, G)
          }
          if ("byteLength" in A) {
            let I = new Uint8Array(A.byteLength);
            return I.set(A, 0), B(I, G)
          }
          if (A instanceof Date) return B(A, G);
          let Z = {};
          if (G.isMapSchema())
            for (let I of Object.keys(A)) Z[I] = hDA(A[I], G.getValueSchema(), B);
          else if (G.isStructSchema())
            for (let [I, Y] of G.structIterator()) Z[I] = hDA(A[I], Y, B);
          else if (G.isDocumentSchema())
            for (let I of Object.keys(A)) Z[I] = hDA(A[I], G.getValueSchema(), B);
          return B(Z, G);
        default:
          return B(A, G)
      }
    },
    $E4 = (A) => {
      switch (A) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw Error(`Unable to parse boolean value "${A}"`)
      }
    },
    wE4 = (A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "number") {
        if (A === 0 || A === 1) dDA.warn(bfA(`Expected boolean, got ${typeof A}: ${A}`));
        if (A === 0) return !1;
        if (A === 1) return !0
      }
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (Q === "false" || Q === "true") dDA.warn(bfA(`Expected boolean, got ${typeof A}: ${A}`));
        if (Q === "false") return !1;
        if (Q === "true") return !0
      }
      if (typeof A === "boolean") return A;
      throw TypeError(`Expected boolean, got ${typeof A}: ${A}`)
    },
    uDA = (A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") {
        let Q = parseFloat(A);
        if (!Number.isNaN(Q)) {
          if (String(Q) !== String(A)) dDA.warn(bfA(`Expected number but observed string: ${A}`));
          return Q
        }
      }
      if (typeof A === "number") return A;
      throw TypeError(`Expected number, got ${typeof A}: ${A}`)
    },
    qE4 = Math.ceil(340282346638528860000000000000000000000),
    vfA = (A) => {
      let Q = uDA(A);
      if (Q !== void 0 && !Number.isNaN(Q) && Q !== 1 / 0 && Q !== -1 / 0) {
        if (Math.abs(Q) > qE4) throw TypeError(`Expected 32-bit float, got ${A}`)
      }
      return Q
    },
    mDA = (A) => {
      if (A === null || A === void 0) return;
      if (Number.isInteger(A) && !Number.isNaN(A)) return A;
      throw TypeError(`Expected integer, got ${typeof A}: ${A}`)
    },
    NE4 = mDA,
    vU1 = (A) => gU1(A, 32),
    bU1 = (A) => gU1(A, 16),
    fU1 = (A) => gU1(A, 8),
    gU1 = (A, Q) => {
      let B = mDA(A);
      if (B !== void 0 && LE4(B, Q) !== B) throw TypeError(`Expected ${Q}-bit integer, got ${A}`);
      return B
    },
    LE4 = (A, Q) => {
      switch (Q) {
        case 32:
          return Int32Array.of(A)[0];
        case 16:
          return Int16Array.of(A)[0];
        case 8:
          return Int8Array.of(A)[0]
      }
    },
    ME4 = (A, Q) => {
      if (A === null || A === void 0) {
        if (Q) throw TypeError(`Expected a non-null value for ${Q}`);
        throw TypeError("Expected a non-null value")
      }
      return A
    },
    G0Q = (A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "object" && !Array.isArray(A)) return A;
      let Q = Array.isArray(A) ? "array" : typeof A;
      throw TypeError(`Expected object, got ${Q}: ${A}`)
    },
    OE4 = (A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") return A;
      if (["boolean", "number", "bigint"].includes(typeof A)) return dDA.warn(bfA(`Expected string, got ${typeof A}: ${A}`)), String(A);
      throw TypeError(`Expected string, got ${typeof A}: ${A}`)
    },
    RE4 = (A) => {
      if (A === null || A === void 0) return;
      let Q = G0Q(A),
        B = Object.entries(Q).filter(([, G]) => G != null).map(([G]) => G);
      if (B.length === 0) throw TypeError("Unions must have exactly one non-null member. None were found.");
      if (B.length > 1) throw TypeError(`Unions must have exactly one non-null member. Keys ${B} were not null.`);
      return Q
    },
    uU1 = (A) => {
      if (typeof A == "string") return uDA(u4A(A));
      return uDA(A)
    },
    TE4 = uU1,
    Z0Q = (A) => {
      if (typeof A == "string") return vfA(u4A(A));
      return vfA(A)
    },
    PE4 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    u4A = (A) => {
      let Q = A.match(PE4);
      if (Q === null || Q[0].length !== A.length) throw TypeError("Expected real number, got implicit NaN");
      return parseFloat(A)
    },
    mU1 = (A) => {
      if (typeof A == "string") return I0Q(A);
      return uDA(A)
    },
    jE4 = mU1,
    SE4 = mU1,
    _E4 = (A) => {
      if (typeof A == "string") return I0Q(A);
      return vfA(A)
    },
    I0Q = (A) => {
      switch (A) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw Error(`Unable to parse float value: ${A}`)
      }
    },
    Y0Q = (A) => {
      if (typeof A === "string") return mDA(u4A(A));
      return mDA(A)
    },
    kE4 = Y0Q,
    yE4 = (A) => {
      if (typeof A === "string") return vU1(u4A(A));
      return vU1(A)
    },
    h4A = (A) => {
      if (typeof A === "string") return bU1(u4A(A));
      return bU1(A)
    },
    J0Q = (A) => {
      if (typeof A === "string") return fU1(u4A(A));
      return fU1(A)
    },
    bfA = (A) => {
      return String(TypeError(A).stack || A).split(`
`).slice(0, 5).filter((Q) => !Q.includes("stackTraceWarning")).join(`
`)
    },
    dDA = {
      warn: console.warn
    },
    xE4 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dU1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  function vE4(A) {
    let Q = A.getUTCFullYear(),
      B = A.getUTCMonth(),
      G = A.getUTCDay(),
      Z = A.getUTCDate(),
      I = A.getUTCHours(),
      Y = A.getUTCMinutes(),
      J = A.getUTCSeconds(),
      W = Z < 10 ? `0${Z}` : `${Z}`,
      X = I < 10 ? `0${I}` : `${I}`,
      V = Y < 10 ? `0${Y}` : `${Y}`,
      F = J < 10 ? `0${J}` : `${J}`;
    return `${xE4[G]}, ${W} ${dU1[B]} ${Q} ${X}:${V}:${F} GMT`
  }
  var bE4 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/),
    fE4 = (A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = bE4.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X] = Q, V = h4A(g4A(G)), F = $S(Z, "month", 1, 12), K = $S(I, "day", 1, 31);
      return gDA(V, F, K, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      })
    },
    hE4 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/),
    gE4 = (A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = hE4.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X, V] = Q, F = h4A(g4A(G)), K = $S(Z, "month", 1, 12), D = $S(I, "day", 1, 31), H = gDA(F, K, D, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      });
      if (V.toUpperCase() != "Z") H.setTime(H.getTime() - tE4(V));
      return H
    },
    uE4 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    mE4 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    dE4 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/),
    cE4 = (A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-7231 date-times must be expressed as strings");
      let Q = uE4.exec(A);
      if (Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return gDA(h4A(g4A(I)), xU1(Z), $S(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        })
      }
      if (Q = mE4.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return nE4(gDA(lE4(I), xU1(Z), $S(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        }))
      }
      if (Q = dE4.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return gDA(h4A(g4A(X)), xU1(G), $S(Z.trimLeft(), "day", 1, 31), {
          hours: I,
          minutes: Y,
          seconds: J,
          fractionalMilliseconds: W
        })
      }
      throw TypeError("Invalid RFC-7231 date-time value")
    },
    pE4 = (A) => {
      if (A === null || A === void 0) return;
      let Q;
      if (typeof A === "number") Q = A;
      else if (typeof A === "string") Q = uU1(A);
      else if (typeof A === "object" && A.tag === 1) Q = A.value;
      else throw TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      if (Number.isNaN(Q) || Q === 1 / 0 || Q === -1 / 0) throw TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      return new Date(Math.round(Q * 1000))
    },
    gDA = (A, Q, B, G) => {
      let Z = Q - 1;
      return sE4(A, Z, B), new Date(Date.UTC(A, Z, B, $S(G.hours, "hour", 0, 23), $S(G.minutes, "minute", 0, 59), $S(G.seconds, "seconds", 0, 60), oE4(G.fractionalMilliseconds)))
    },
    lE4 = (A) => {
      let Q = new Date().getUTCFullYear(),
        B = Math.floor(Q / 100) * 100 + h4A(g4A(A));
      if (B < Q) return B + 100;
      return B
    },
    iE4 = 1576800000000,
    nE4 = (A) => {
      if (A.getTime() - new Date().getTime() > iE4) return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));
      return A
    },
    xU1 = (A) => {
      let Q = dU1.indexOf(A);
      if (Q < 0) throw TypeError(`Invalid month: ${A}`);
      return Q + 1
    },
    aE4 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    sE4 = (A, Q, B) => {
      let G = aE4[Q];
      if (Q === 1 && rE4(A)) G = 29;
      if (B > G) throw TypeError(`Invalid day for ${dU1[Q]} in ${A}: ${B}`)
    },
    rE4 = (A) => {
      return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0)
    },
    $S = (A, Q, B, G) => {
      let Z = J0Q(g4A(A));
      if (Z < B || Z > G) throw TypeError(`${Q} must be between ${B} and ${G}, inclusive`);
      return Z
    },
    oE4 = (A) => {
      if (A === null || A === void 0) return 0;
      return Z0Q("0." + A) * 1000
    },
    tE4 = (A) => {
      let Q = A[0],
        B = 1;
      if (Q == "+") B = 1;
      else if (Q == "-") B = -1;
      else throw TypeError(`Offset direction, ${Q}, must be "+" or "-"`);
      let G = Number(A.substring(1, 3)),
        Z = Number(A.substring(4, 6));
      return B * (G * 60 + Z) * 60 * 1000
    },
    g4A = (A) => {
      let Q = 0;
      while (Q < A.length - 1 && A.charAt(Q) === "0") Q++;
      if (Q === 0) return A;
      return A.slice(Q)
    },
    kr = function(Q) {
      return Object.assign(new String(Q), {
        deserializeJSON() {
          return JSON.parse(String(Q))
        },
        toString() {
          return String(Q)
        },
        toJSON() {
          return String(Q)
        }
      })
    };
  kr.from = (A) => {
    if (A && typeof A === "object" && (A instanceof kr || ("deserializeJSON" in A))) return A;
    else if (typeof A === "string" || Object.getPrototypeOf(A) === String.prototype) return kr(String(A));
    return kr(JSON.stringify(A))
  };
  kr.fromObject = kr.from;

  function eE4(A) {
    if (A.includes(",") || A.includes('"')) A = `"${A.replace(/"/g,"\\\"")}"`;
    return A
  }

  function Az4(A, Q, B) {
    if (B <= 0 || !Number.isInteger(B)) throw Error("Invalid number of delimiters (" + B + ") for splitEvery.");
    let G = A.split(Q);
    if (B === 1) return G;
    let Z = [],
      I = "";
    for (let Y = 0; Y < G.length; Y++) {
      if (I === "") I = G[Y];
      else I += Q + G[Y];
      if ((Y + 1) % B === 0) Z.push(I), I = ""
    }
    if (I !== "") Z.push(I);
    return Z
  }
  var Qz4 = (A) => {
      let Q = A.length,
        B = [],
        G = !1,
        Z = void 0,
        I = 0;
      for (let Y = 0; Y < Q; ++Y) {
        let J = A[Y];
        switch (J) {
          case '"':
            if (Z !== "\\") G = !G;
            break;
          case ",":
            if (!G) B.push(A.slice(I, Y)), I = Y + 1;
            break;
          default:
        }
        Z = J
      }
      return B.push(A.slice(I)), B.map((Y) => {
        Y = Y.trim();
        let J = Y.length;
        if (J < 2) return Y;
        if (Y[0] === '"' && Y[J - 1] === '"') Y = Y.slice(1, J - 1);
        return Y.replace(/\\"/g, '"')
      })
    },
    W0Q = class {
      constructor(A, Q) {
        this.string = A, this.type = Q;
        let B = 0;
        for (let G = 0; G < A.length; ++G) {
          let Z = A.charCodeAt(G);
          if (G === 0 && Z === 45) continue;
          if (Z === 46) {
            if (B) throw Error("@smithy/core/serde - NumericValue must contain at most one decimal point.");
            B = 1;
            continue
          }
          if (Z < 48 || Z > 57) throw Error('@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point ".", and an optional negation prefix "-".')
        }
      }
      toString() {
        return this.string
      } [Symbol.hasInstance](A) {
        if (!A || typeof A !== "object") return !1;
        let Q = A;
        if (typeof Q.string === "string" && typeof Q.type === "string" && Q.constructor?.name === "NumericValue") return !0;
        return !1
      }
    };

  function Bz4(A) {
    return new W0Q(String(A), "bigDecimal")
  }
})
// @from(Start 2373156, End 2373643)
K0Q = z((V0Q) => {
  Object.defineProperty(V0Q, "__esModule", {
    value: !0
  });
  V0Q.fromBase64 = void 0;
  var Gz4 = hI(),
    Zz4 = /^[A-Za-z0-9+/]*={0,2}$/,
    Iz4 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!Zz4.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, Gz4.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  V0Q.fromBase64 = Iz4
})
// @from(Start 2373649, End 2374228)
C0Q = z((D0Q) => {
  Object.defineProperty(D0Q, "__esModule", {
    value: !0
  });
  D0Q.toBase64 = void 0;
  var Yz4 = hI(),
    Jz4 = O2(),
    Wz4 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, Jz4.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, Yz4.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  D0Q.toBase64 = Wz4
})
// @from(Start 2374234, End 2374930)
lU1 = z((HC7, ffA) => {
  var {
    defineProperty: E0Q,
    getOwnPropertyDescriptor: Xz4,
    getOwnPropertyNames: Vz4
  } = Object, Fz4 = Object.prototype.hasOwnProperty, cU1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Vz4(Q))
        if (!Fz4.call(A, Z) && Z !== B) E0Q(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Xz4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, z0Q = (A, Q, B) => (cU1(A, Q, "default"), B && cU1(B, Q, "default")), Kz4 = (A) => cU1(E0Q({}, "__esModule", {
    value: !0
  }), A), pU1 = {};
  ffA.exports = Kz4(pU1);
  z0Q(pU1, K0Q(), ffA.exports);
  z0Q(pU1, C0Q(), ffA.exports)
})
// @from(Start 2374936, End 2395794)
w5 = z((CC7, j0Q) => {
  var {
    defineProperty: sU1,
    getOwnPropertyDescriptor: Dz4,
    getOwnPropertyNames: Hz4
  } = Object, Cz4 = Object.prototype.hasOwnProperty, Ez4 = (A, Q) => {
    for (var B in Q) sU1(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, zz4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Hz4(Q))
        if (!Cz4.call(A, Z) && Z !== B) sU1(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Dz4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Uz4 = (A) => zz4(sU1({}, "__esModule", {
    value: !0
  }), A), L0Q = {};
  Ez4(L0Q, {
    FromStringShapeDeserializer: () => T0Q,
    HttpBindingProtocol: () => qz4,
    HttpInterceptingShapeDeserializer: () => Pz4,
    HttpInterceptingShapeSerializer: () => Sz4,
    RequestBuilder: () => R0Q,
    RpcProtocol: () => Lz4,
    ToStringShapeSerializer: () => P0Q,
    collectBody: () => d4A,
    determineTimestampFormat: () => rU1,
    extendedEncodeURIComponent: () => lDA,
    requestBuilder: () => Oz4,
    resolvedPath: () => O0Q
  });
  j0Q.exports = Uz4(L0Q);
  var iU1 = Xd(),
    d4A = async (A = new Uint8Array, Q) => {
      if (A instanceof Uint8Array) return iU1.Uint8ArrayBlobAdapter.mutate(A);
      if (!A) return iU1.Uint8ArrayBlobAdapter.mutate(new Uint8Array);
      let B = Q.streamCollector(A);
      return iU1.Uint8ArrayBlobAdapter.mutate(await B)
    };

  function lDA(A) {
    return encodeURIComponent(A).replace(/[!'()*]/g, function(Q) {
      return "%" + Q.charCodeAt(0).toString(16).toUpperCase()
    })
  }
  var cDA = b4(),
    $z4 = Sr(),
    hfA = b4(),
    U0Q = s6(),
    $0Q = Sr(),
    wz4 = Xd(),
    M0Q = class {
      constructor(A) {
        this.options = A
      }
      getRequestType() {
        return $0Q.HttpRequest
      }
      getResponseType() {
        return $0Q.HttpResponse
      }
      setSerdeContext(A) {
        if (this.serdeContext = A, this.serializer.setSerdeContext(A), this.deserializer.setSerdeContext(A), this.getPayloadCodec()) this.getPayloadCodec().setSerdeContext(A)
      }
      updateServiceEndpoint(A, Q) {
        if ("url" in Q) {
          A.protocol = Q.url.protocol, A.hostname = Q.url.hostname, A.port = Q.url.port ? Number(Q.url.port) : void 0, A.path = Q.url.pathname, A.fragment = Q.url.hash || void 0, A.username = Q.url.username || void 0, A.password = Q.url.password || void 0;
          for (let [B, G] of Q.url.searchParams.entries()) {
            if (!A.query) A.query = {};
            A.query[B] = G
          }
          return A
        } else return A.protocol = Q.protocol, A.hostname = Q.hostname, A.port = Q.port ? Number(Q.port) : void 0, A.path = Q.path, A.query = {
          ...Q.query
        }, A
      }
      setHostPrefix(A, Q, B) {
        let G = hfA.NormalizedSchema.of(Q),
          Z = hfA.NormalizedSchema.of(Q.input);
        if (G.getMergedTraits().endpoint) {
          let I = G.getMergedTraits().endpoint?.[0];
          if (typeof I === "string") {
            let Y = [...Z.structIterator()].filter(([, J]) => J.getMergedTraits().hostLabel);
            for (let [J] of Y) {
              let W = B[J];
              if (typeof W !== "string") throw Error(`@smithy/core/schema - ${J} in input must be a string as hostLabel.`);
              I = I.replace(`{${J}}`, W)
            }
            A.hostname = I + A.hostname
          }
        }
      }
      deserializeMetadata(A) {
        return {
          httpStatusCode: A.statusCode,
          requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
          extendedRequestId: A.headers["x-amz-id-2"],
          cfId: A.headers["x-amz-cf-id"]
        }
      }
      async deserializeHttpMessage(A, Q, B, G, Z) {
        let I;
        if (G instanceof Set) I = Z;
        else I = G;
        let Y = this.deserializer,
          J = hfA.NormalizedSchema.of(A),
          W = [];
        for (let [X, V] of J.structIterator()) {
          let F = V.getMemberTraits();
          if (F.httpPayload) {
            if (V.isStreaming())
              if (V.isStructSchema()) {
                let H = this.serdeContext;
                if (!H.eventStreamMarshaller) throw Error("@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.");
                let C = V.getMemberSchemas();
                I[X] = H.eventStreamMarshaller.deserialize(B.body, async (E) => {
                  let U = Object.keys(E).find((q) => {
                    return q !== "__type"
                  }) ?? "";
                  if (U in C) {
                    let q = C[U];
                    return {
                      [U]: await Y.read(q, E[U].body)
                    }
                  } else return {
                    $unknown: E
                  }
                })
              } else I[X] = (0, wz4.sdkStreamMixin)(B.body);
            else if (B.body) {
              let D = await d4A(B.body, Q);
              if (D.byteLength > 0) I[X] = await Y.read(V, D)
            }
          } else if (F.httpHeader) {
            let K = String(F.httpHeader).toLowerCase(),
              D = B.headers[K];
            if (D != null)
              if (V.isListSchema()) {
                let H = V.getValueSchema(),
                  C;
                if (H.isTimestampSchema() && H.getSchema() === hfA.SCHEMA.TIMESTAMP_DEFAULT) C = (0, U0Q.splitEvery)(D, ",", 2);
                else C = (0, U0Q.splitHeader)(D);
                let E = [];
                for (let U of C) E.push(await Y.read([H, {
                  httpHeader: K
                }], U.trim()));
                I[X] = E
              } else I[X] = await Y.read(V, D)
          } else if (F.httpPrefixHeaders !== void 0) {
            I[X] = {};
            for (let [K, D] of Object.entries(B.headers))
              if (K.startsWith(F.httpPrefixHeaders)) I[X][K.slice(F.httpPrefixHeaders.length)] = await Y.read([V.getValueSchema(), {
                httpHeader: K
              }], D)
          } else if (F.httpResponseCode) I[X] = B.statusCode;
          else W.push(X)
        }
        return W
      }
    },
    qz4 = class extends M0Q {
      async serializeRequest(A, Q, B) {
        let G = this.serializer,
          Z = {},
          I = {},
          Y = await B.endpoint(),
          J = cDA.NormalizedSchema.of(A?.input),
          W = J.getSchema(),
          X = !1,
          V, F = new $z4.HttpRequest({
            protocol: "",
            hostname: "",
            port: void 0,
            path: "",
            fragment: void 0,
            query: Z,
            headers: I,
            body: void 0
          });
        if (Y) {
          this.updateServiceEndpoint(F, Y), this.setHostPrefix(F, A, Q);
          let D = cDA.NormalizedSchema.translateTraits(A.traits);
          if (D.http) {
            F.method = D.http[0];
            let [H, C] = D.http[1].split("?");
            if (F.path == "/") F.path = H;
            else F.path += H;
            let E = new URLSearchParams(C ?? "");
            Object.assign(Z, Object.fromEntries(E))
          }
        }
        let K = {
          ...Q
        };
        for (let D of Object.keys(K)) {
          let H = J.getMemberSchema(D);
          if (H === void 0) continue;
          let C = H.getMergedTraits(),
            E = K[D];
          if (C.httpPayload)
            if (H.isStreaming())
              if (H.isStructSchema()) throw Error("serialization of event streams is not yet implemented");
              else V = E;
          else G.write(H, E), V = G.flush();
          else if (C.httpLabel) {
            G.write(H, E);
            let U = G.flush();
            if (F.path.includes(`{${D}+}`)) F.path = F.path.replace(`{${D}+}`, U.split("/").map(lDA).join("/"));
            else if (F.path.includes(`{${D}}`)) F.path = F.path.replace(`{${D}}`, lDA(U));
            delete K[D]
          } else if (C.httpHeader) G.write(H, E), I[C.httpHeader.toLowerCase()] = String(G.flush()), delete K[D];
          else if (typeof C.httpPrefixHeaders === "string") {
            for (let [U, q] of Object.entries(E)) {
              let w = C.httpPrefixHeaders + U;
              G.write([H.getValueSchema(), {
                httpHeader: w
              }], q), I[w.toLowerCase()] = G.flush()
            }
            delete K[D]
          } else if (C.httpQuery || C.httpQueryParams) this.serializeQuery(H, E, Z), delete K[D];
          else X = !0
        }
        if (X && Q) G.write(W, K), V = G.flush();
        return F.headers = I, F.query = Z, F.body = V, F
      }
      serializeQuery(A, Q, B) {
        let G = this.serializer,
          Z = A.getMergedTraits();
        if (Z.httpQueryParams) {
          for (let [I, Y] of Object.entries(Q))
            if (!(I in B)) this.serializeQuery(cDA.NormalizedSchema.of([A.getValueSchema(), {
              ...Z,
              httpQuery: I,
              httpQueryParams: void 0
            }]), Y, B);
          return
        }
        if (A.isListSchema()) {
          let I = !!A.getMergedTraits().sparse,
            Y = [];
          for (let J of Q) {
            G.write([A.getValueSchema(), Z], J);
            let W = G.flush();
            if (I || W !== void 0) Y.push(W)
          }
          B[Z.httpQuery] = Y
        } else G.write([A, Z], Q), B[Z.httpQuery] = G.flush()
      }
      async deserializeResponse(A, Q, B) {
        let G = this.deserializer,
          Z = cDA.NormalizedSchema.of(A.output),
          I = {};
        if (B.statusCode >= 300) {
          let W = await d4A(B.body, Q);
          if (W.byteLength > 0) Object.assign(I, await G.read(cDA.SCHEMA.DOCUMENT, W));
          throw await this.handleError(A, Q, B, I, this.deserializeMetadata(B)), Error("@smithy/core/protocols - HTTP Protocol error handler failed to throw.")
        }
        for (let W in B.headers) {
          let X = B.headers[W];
          delete B.headers[W], B.headers[W.toLowerCase()] = X
        }
        let Y = await this.deserializeHttpMessage(Z, Q, B, I);
        if (Y.length) {
          let W = await d4A(B.body, Q);
          if (W.byteLength > 0) {
            let X = await G.read(Z, W);
            for (let V of Y) I[V] = X[V]
          }
        }
        return {
          $metadata: this.deserializeMetadata(B),
          ...I
        }
      }
    },
    nU1 = b4(),
    Nz4 = Sr(),
    Lz4 = class extends M0Q {
      async serializeRequest(A, Q, B) {
        let G = this.serializer,
          Z = {},
          I = {},
          Y = await B.endpoint(),
          W = nU1.NormalizedSchema.of(A?.input).getSchema(),
          X, V = new Nz4.HttpRequest({
            protocol: "",
            hostname: "",
            port: void 0,
            path: "/",
            fragment: void 0,
            query: Z,
            headers: I,
            body: void 0
          });
        if (Y) this.updateServiceEndpoint(V, Y), this.setHostPrefix(V, A, Q);
        let F = {
          ...Q
        };
        if (Q) G.write(W, F), X = G.flush();
        return V.headers = I, V.query = Z, V.body = X, V.method = "POST", V
      }
      async deserializeResponse(A, Q, B) {
        let G = this.deserializer,
          Z = nU1.NormalizedSchema.of(A.output),
          I = {};
        if (B.statusCode >= 300) {
          let W = await d4A(B.body, Q);
          if (W.byteLength > 0) Object.assign(I, await G.read(nU1.SCHEMA.DOCUMENT, W));
          throw await this.handleError(A, Q, B, I, this.deserializeMetadata(B)), Error("@smithy/core/protocols - RPC Protocol error handler failed to throw.")
        }
        for (let W in B.headers) {
          let X = B.headers[W];
          delete B.headers[W], B.headers[W.toLowerCase()] = X
        }
        let Y = await d4A(B.body, Q);
        if (Y.byteLength > 0) Object.assign(I, await G.read(Z, Y));
        return {
          $metadata: this.deserializeMetadata(B),
          ...I
        }
      }
    },
    Mz4 = Sr(),
    O0Q = (A, Q, B, G, Z, I) => {
      if (Q != null && Q[B] !== void 0) {
        let Y = G();
        if (Y.length <= 0) throw Error("Empty value provided for input HTTP label: " + B + ".");
        A = A.replace(Z, I ? Y.split("/").map((J) => lDA(J)).join("/") : lDA(Y))
      } else throw Error("No value provided for input HTTP label: " + B + ".");
      return A
    };

  function Oz4(A, Q) {
    return new R0Q(A, Q)
  }
  var R0Q = class {
      constructor(A, Q) {
        this.input = A, this.context = Q, this.query = {}, this.method = "", this.headers = {}, this.path = "", this.body = null, this.hostname = "", this.resolvePathStack = []
      }
      async build() {
        let {
          hostname: A,
          protocol: Q = "https",
          port: B,
          path: G
        } = await this.context.endpoint();
        this.path = G;
        for (let Z of this.resolvePathStack) Z(this.path);
        return new Mz4.HttpRequest({
          protocol: Q,
          hostname: this.hostname || A,
          port: B,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers
        })
      }
      hn(A) {
        return this.hostname = A, this
      }
      bp(A) {
        return this.resolvePathStack.push((Q) => {
          this.path = `${Q?.endsWith("/")?Q.slice(0,-1):Q||""}` + A
        }), this
      }
      p(A, Q, B, G) {
        return this.resolvePathStack.push((Z) => {
          this.path = O0Q(Z, this.input, A, Q, B, G)
        }), this
      }
      h(A) {
        return this.headers = A, this
      }
      q(A) {
        return this.query = A, this
      }
      b(A) {
        return this.body = A, this
      }
      m(A) {
        return this.method = A, this
      }
    },
    gfA = b4(),
    m4A = s6(),
    w0Q = lU1(),
    Rz4 = O2(),
    pDA = b4();

  function rU1(A, Q) {
    if (Q.timestampFormat.useTrait) {
      if (A.isTimestampSchema() && (A.getSchema() === pDA.SCHEMA.TIMESTAMP_DATE_TIME || A.getSchema() === pDA.SCHEMA.TIMESTAMP_HTTP_DATE || A.getSchema() === pDA.SCHEMA.TIMESTAMP_EPOCH_SECONDS)) return A.getSchema()
    }
    let {
      httpLabel: B,
      httpPrefixHeaders: G,
      httpHeader: Z,
      httpQuery: I
    } = A.getMergedTraits();
    return (Q.httpBindings ? typeof G === "string" || Boolean(Z) ? pDA.SCHEMA.TIMESTAMP_HTTP_DATE : Boolean(I) || Boolean(B) ? pDA.SCHEMA.TIMESTAMP_DATE_TIME : void 0 : void 0) ?? Q.timestampFormat.default
  }
  var T0Q = class {
      constructor(A) {
        this.settings = A
      }
      setSerdeContext(A) {
        this.serdeContext = A
      }
      read(A, Q) {
        let B = gfA.NormalizedSchema.of(A);
        if (B.isListSchema()) return (0, m4A.splitHeader)(Q).map((G) => this.read(B.getValueSchema(), G));
        if (B.isBlobSchema()) return (this.serdeContext?.base64Decoder ?? w0Q.fromBase64)(Q);
        if (B.isTimestampSchema()) switch (rU1(B, this.settings)) {
          case gfA.SCHEMA.TIMESTAMP_DATE_TIME:
            return (0, m4A.parseRfc3339DateTimeWithOffset)(Q);
          case gfA.SCHEMA.TIMESTAMP_HTTP_DATE:
            return (0, m4A.parseRfc7231DateTime)(Q);
          case gfA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
            return (0, m4A.parseEpochTimestamp)(Q);
          default:
            return console.warn("Missing timestamp format, parsing value with Date constructor:", Q), new Date(Q)
        }
        if (B.isStringSchema()) {
          let G = B.getMergedTraits().mediaType,
            Z = Q;
          if (G) {
            if (B.getMergedTraits().httpHeader) Z = this.base64ToUtf8(Z);
            if (G === "application/json" || G.endsWith("+json")) Z = m4A.LazyJsonString.from(Z);
            return Z
          }
        }
        switch (!0) {
          case B.isNumericSchema():
            return Number(Q);
          case B.isBigIntegerSchema():
            return BigInt(Q);
          case B.isBigDecimalSchema():
            return new m4A.NumericValue(Q, "bigDecimal");
          case B.isBooleanSchema():
            return String(Q).toLowerCase() === "true"
        }
        return Q
      }
      base64ToUtf8(A) {
        return (this.serdeContext?.utf8Encoder ?? Rz4.toUtf8)((this.serdeContext?.base64Decoder ?? w0Q.fromBase64)(A))
      }
    },
    Tz4 = b4(),
    q0Q = O2(),
    Pz4 = class {
      constructor(A, Q) {
        this.codecDeserializer = A, this.stringDeserializer = new T0Q(Q)
      }
      setSerdeContext(A) {
        this.stringDeserializer.setSerdeContext(A), this.codecDeserializer.setSerdeContext(A), this.serdeContext = A
      }
      read(A, Q) {
        let B = Tz4.NormalizedSchema.of(A),
          G = B.getMergedTraits(),
          Z = this.serdeContext?.utf8Encoder ?? q0Q.toUtf8;
        if (G.httpHeader || G.httpResponseCode) return this.stringDeserializer.read(B, Z(Q));
        if (G.httpPayload) {
          if (B.isBlobSchema()) {
            let I = this.serdeContext?.utf8Decoder ?? q0Q.fromUtf8;
            if (typeof Q === "string") return I(Q);
            return Q
          } else if (B.isStringSchema()) {
            if ("byteLength" in Q) return Z(Q);
            return Q
          }
        }
        return this.codecDeserializer.read(B, Q)
      }
    },
    jz4 = b4(),
    ufA = b4(),
    aU1 = s6(),
    N0Q = lU1(),
    P0Q = class {
      constructor(A) {
        this.settings = A, this.stringBuffer = "", this.serdeContext = void 0
      }
      setSerdeContext(A) {
        this.serdeContext = A
      }
      write(A, Q) {
        let B = ufA.NormalizedSchema.of(A);
        switch (typeof Q) {
          case "object":
            if (Q === null) {
              this.stringBuffer = "null";
              return
            }
            if (B.isTimestampSchema()) {
              if (!(Q instanceof Date)) throw Error(`@smithy/core/protocols - received non-Date value ${Q} when schema expected Date in ${B.getName(!0)}`);
              switch (rU1(B, this.settings)) {
                case ufA.SCHEMA.TIMESTAMP_DATE_TIME:
                  this.stringBuffer = Q.toISOString().replace(".000Z", "Z");
                  break;
                case ufA.SCHEMA.TIMESTAMP_HTTP_DATE:
                  this.stringBuffer = (0, aU1.dateToUtcString)(Q);
                  break;
                case ufA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
                  this.stringBuffer = String(Q.getTime() / 1000);
                  break;
                default:
                  console.warn("Missing timestamp format, using epoch seconds", Q), this.stringBuffer = String(Q.getTime() / 1000)
              }
              return
            }
            if (B.isBlobSchema() && "byteLength" in Q) {
              this.stringBuffer = (this.serdeContext?.base64Encoder ?? N0Q.toBase64)(Q);
              return
            }
            if (B.isListSchema() && Array.isArray(Q)) {
              let I = "";
              for (let Y of Q) {
                this.write([B.getValueSchema(), B.getMergedTraits()], Y);
                let J = this.flush(),
                  W = B.getValueSchema().isTimestampSchema() ? J : (0, aU1.quoteHeader)(J);
                if (I !== "") I += ", ";
                I += W
              }
              this.stringBuffer = I;
              return
            }
            this.stringBuffer = JSON.stringify(Q, null, 2);
            break;
          case "string":
            let G = B.getMergedTraits().mediaType,
              Z = Q;
            if (G) {
              if (G === "application/json" || G.endsWith("+json")) Z = aU1.LazyJsonString.from(Z);
              if (B.getMergedTraits().httpHeader) {
                this.stringBuffer = (this.serdeContext?.base64Encoder ?? N0Q.toBase64)(Z.toString());
                return
              }
            }
            this.stringBuffer = Q;
            break;
          default:
            this.stringBuffer = String(Q)
        }
      }
      flush() {
        let A = this.stringBuffer;
        return this.stringBuffer = "", A
      }
    },
    Sz4 = class {
      constructor(A, Q, B = new P0Q(Q)) {
        this.codecSerializer = A, this.stringSerializer = B
      }
      setSerdeContext(A) {
        this.codecSerializer.setSerdeContext(A), this.stringSerializer.setSerdeContext(A)
      }
      write(A, Q) {
        let B = jz4.NormalizedSchema.of(A),
          G = B.getMergedTraits();
        if (G.httpHeader || G.httpLabel || G.httpQuery) {
          this.stringSerializer.write(B, Q), this.buffer = this.stringSerializer.flush();
          return
        }
        return this.codecSerializer.write(B, Q)
      }
      flush() {
        if (this.buffer !== void 0) {
          let A = this.buffer;
          return this.buffer = void 0, A
        }
        return this.codecSerializer.flush()
      }
    }
})
// @from(Start 2395800, End 2405799)
iB = z((MC7, d0Q) => {
  var {
    defineProperty: dfA,
    getOwnPropertyDescriptor: _z4,
    getOwnPropertyNames: kz4
  } = Object, yz4 = Object.prototype.hasOwnProperty, gI = (A, Q) => dfA(A, "name", {
    value: Q,
    configurable: !0
  }), xz4 = (A, Q) => {
    for (var B in Q) dfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vz4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of kz4(Q))
        if (!yz4.call(A, Z) && Z !== B) dfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _z4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bz4 = (A) => vz4(dfA({}, "__esModule", {
    value: !0
  }), A), S0Q = {};
  xz4(S0Q, {
    DefaultIdentityProviderConfig: () => sz4,
    EXPIRATION_MS: () => u0Q,
    HttpApiKeyAuthSigner: () => rz4,
    HttpBearerAuthSigner: () => oz4,
    NoAuthSigner: () => tz4,
    createIsIdentityExpiredFunction: () => g0Q,
    createPaginator: () => f0Q,
    doesIdentityRequireRefresh: () => m0Q,
    getHttpAuthSchemeEndpointRuleSetPlugin: () => gz4,
    getHttpAuthSchemePlugin: () => mz4,
    getHttpSigningPlugin: () => pz4,
    getSmithyContext: () => fz4,
    httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => y0Q,
    httpAuthSchemeMiddleware: () => oU1,
    httpAuthSchemeMiddlewareOptions: () => x0Q,
    httpSigningMiddleware: () => v0Q,
    httpSigningMiddlewareOptions: () => b0Q,
    isIdentityExpired: () => ez4,
    memoizeIdentityProvider: () => AU4,
    normalizeProvider: () => lz4,
    requestBuilder: () => az4.requestBuilder,
    setFeature: () => h0Q
  });
  d0Q.exports = bz4(S0Q);
  var mfA = WU1(),
    fz4 = gI((A) => A[mfA.SMITHY_CONTEXT_KEY] || (A[mfA.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext"),
    _0Q = w7(),
    hz4 = gI((A, Q) => {
      if (!Q || Q.length === 0) return A;
      let B = [];
      for (let G of Q)
        for (let Z of A)
          if (Z.schemeId.split("#")[1] === G) B.push(Z);
      for (let G of A)
        if (!B.find(({
            schemeId: Z
          }) => Z === G.schemeId)) B.push(G);
      return B
    }, "resolveAuthOptions");

  function k0Q(A) {
    let Q = new Map;
    for (let B of A) Q.set(B.schemeId, B);
    return Q
  }
  gI(k0Q, "convertHttpAuthSchemesToMap");
  var oU1 = gI((A, Q) => (B, G) => async (Z) => {
      let I = A.httpAuthSchemeProvider(await Q.httpAuthSchemeParametersProvider(A, G, Z.input)),
        Y = A.authSchemePreference ? await A.authSchemePreference() : [],
        J = hz4(I, Y),
        W = k0Q(A.httpAuthSchemes),
        X = (0, _0Q.getSmithyContext)(G),
        V = [];
      for (let F of J) {
        let K = W.get(F.schemeId);
        if (!K) {
          V.push(`HttpAuthScheme \`${F.schemeId}\` was not enabled for this service.`);
          continue
        }
        let D = K.identityProvider(await Q.identityProviderConfigProvider(A));
        if (!D) {
          V.push(`HttpAuthScheme \`${F.schemeId}\` did not have an IdentityProvider configured.`);
          continue
        }
        let {
          identityProperties: H = {},
          signingProperties: C = {}
        } = F.propertiesExtractor?.(A, G) || {};
        F.identityProperties = Object.assign(F.identityProperties || {}, H), F.signingProperties = Object.assign(F.signingProperties || {}, C), X.selectedHttpAuthScheme = {
          httpAuthOption: F,
          identity: await D(F.identityProperties),
          signer: K.signer
        };
        break
      }
      if (!X.selectedHttpAuthScheme) throw Error(V.join(`
`));
      return B(Z)
    }, "httpAuthSchemeMiddleware"),
    y0Q = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: "endpointV2Middleware"
    },
    gz4 = gI((A, {
      httpAuthSchemeParametersProvider: Q,
      identityProviderConfigProvider: B
    }) => ({
      applyToStack: (G) => {
        G.addRelativeTo(oU1(A, {
          httpAuthSchemeParametersProvider: Q,
          identityProviderConfigProvider: B
        }), y0Q)
      }
    }), "getHttpAuthSchemeEndpointRuleSetPlugin"),
    uz4 = GZ(),
    x0Q = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: uz4.serializerMiddlewareOption.name
    },
    mz4 = gI((A, {
      httpAuthSchemeParametersProvider: Q,
      identityProviderConfigProvider: B
    }) => ({
      applyToStack: (G) => {
        G.addRelativeTo(oU1(A, {
          httpAuthSchemeParametersProvider: Q,
          identityProviderConfigProvider: B
        }), x0Q)
      }
    }), "getHttpAuthSchemePlugin"),
    tU1 = Sr(),
    dz4 = gI((A) => (Q) => {
      throw Q
    }, "defaultErrorHandler"),
    cz4 = gI((A, Q) => {}, "defaultSuccessHandler"),
    v0Q = gI((A) => (Q, B) => async (G) => {
      if (!tU1.HttpRequest.isInstance(G.request)) return Q(G);
      let I = (0, _0Q.getSmithyContext)(B).selectedHttpAuthScheme;
      if (!I) throw Error("No HttpAuthScheme was selected: unable to sign request");
      let {
        httpAuthOption: {
          signingProperties: Y = {}
        },
        identity: J,
        signer: W
      } = I, X = await Q({
        ...G,
        request: await W.sign(G.request, J, Y)
      }).catch((W.errorHandler || dz4)(Y));
      return (W.successHandler || cz4)(X.response, Y), X
    }, "httpSigningMiddleware"),
    b0Q = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: !0,
      relation: "after",
      toMiddleware: "retryMiddleware"
    },
    pz4 = gI((A) => ({
      applyToStack: (Q) => {
        Q.addRelativeTo(v0Q(A), b0Q)
      }
    }), "getHttpSigningPlugin"),
    lz4 = gI((A) => {
      if (typeof A === "function") return A;
      let Q = Promise.resolve(A);
      return () => Q
    }, "normalizeProvider"),
    iz4 = gI(async (A, Q, B, G = (I) => I, ...Z) => {
      let I = new A(B);
      return I = G(I) ?? I, await Q.send(I, ...Z)
    }, "makePagedClientRequest");

  function f0Q(A, Q, B, G, Z) {
    return gI(async function*(Y, J, ...W) {
      let X = J,
        V = Y.startingToken ?? X[B],
        F = !0,
        K;
      while (F) {
        if (X[B] = V, Z) X[Z] = X[Z] ?? Y.pageSize;
        if (Y.client instanceof A) K = await iz4(Q, Y.client, J, Y.withCommand, ...W);
        else throw Error(`Invalid client, expected instance of ${A.name}`);
        yield K;
        let D = V;
        V = nz4(K, G), F = !!(V && (!Y.stopOnSameToken || V !== D))
      }
      return
    }, "paginateOperation")
  }
  gI(f0Q, "createPaginator");
  var nz4 = gI((A, Q) => {
      let B = A,
        G = Q.split(".");
      for (let Z of G) {
        if (!B || typeof B !== "object") return;
        B = B[Z]
      }
      return B
    }, "get"),
    az4 = w5();

  function h0Q(A, Q, B) {
    if (!A.__smithy_context) A.__smithy_context = {
      features: {}
    };
    else if (!A.__smithy_context.features) A.__smithy_context.features = {};
    A.__smithy_context.features[Q] = B
  }
  gI(h0Q, "setFeature");
  var sz4 = class {
      constructor(A) {
        this.authSchemes = new Map;
        for (let [Q, B] of Object.entries(A))
          if (B !== void 0) this.authSchemes.set(Q, B)
      }
      static {
        gI(this, "DefaultIdentityProviderConfig")
      }
      getIdentityProvider(A) {
        return this.authSchemes.get(A)
      }
    },
    rz4 = class {
      static {
        gI(this, "HttpApiKeyAuthSigner")
      }
      async sign(A, Q, B) {
        if (!B) throw Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
        if (!B.name) throw Error("request could not be signed with `apiKey` since the `name` signer property is missing");
        if (!B.in) throw Error("request could not be signed with `apiKey` since the `in` signer property is missing");
        if (!Q.apiKey) throw Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
        let G = tU1.HttpRequest.clone(A);
        if (B.in === mfA.HttpApiKeyAuthLocation.QUERY) G.query[B.name] = Q.apiKey;
        else if (B.in === mfA.HttpApiKeyAuthLocation.HEADER) G.headers[B.name] = B.scheme ? `${B.scheme} ${Q.apiKey}` : Q.apiKey;
        else throw Error("request can only be signed with `apiKey` locations `query` or `header`, but found: `" + B.in + "`");
        return G
      }
    },
    oz4 = class {
      static {
        gI(this, "HttpBearerAuthSigner")
      }
      async sign(A, Q, B) {
        let G = tU1.HttpRequest.clone(A);
        if (!Q.token) throw Error("request could not be signed with `token` since the `token` is not defined");
        return G.headers.Authorization = `Bearer ${Q.token}`, G
      }
    },
    tz4 = class {
      static {
        gI(this, "NoAuthSigner")
      }
      async sign(A, Q, B) {
        return A
      }
    },
    g0Q = gI((A) => (Q) => m0Q(Q) && Q.expiration.getTime() - Date.now() < A, "createIsIdentityExpiredFunction"),
    u0Q = 300000,
    ez4 = g0Q(u0Q),
    m0Q = gI((A) => A.expiration !== void 0, "doesIdentityRequireRefresh"),
    AU4 = gI((A, Q, B) => {
      if (A === void 0) return;
      let G = typeof A !== "function" ? async () => Promise.resolve(A): A, Z, I, Y, J = !1, W = gI(async (X) => {
        if (!I) I = G(X);
        try {
          Z = await I, Y = !0, J = !1
        } finally {
          I = void 0
        }
        return Z
      }, "coalesceProvider");
      if (Q === void 0) return async (X) => {
        if (!Y || X?.forceRefresh) Z = await W(X);
        return Z
      };
      return async (X) => {
        if (!Y || X?.forceRefresh) Z = await W(X);
        if (J) return Z;
        if (!B(Z)) return J = !0, Z;
        if (Q(Z)) return await W(X), Z;
        return Z
      }
    }, "memoizeIdentityProvider")
})
// @from(Start 2405805, End 2408588)
t0Q = z((jC7, o0Q) => {
  var {
    defineProperty: cfA,
    getOwnPropertyDescriptor: QU4,
    getOwnPropertyNames: BU4
  } = Object, GU4 = Object.prototype.hasOwnProperty, pfA = (A, Q) => cfA(A, "name", {
    value: Q,
    configurable: !0
  }), ZU4 = (A, Q) => {
    for (var B in Q) cfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, IU4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of BU4(Q))
        if (!GU4.call(A, Z) && Z !== B) cfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = QU4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, YU4 = (A) => IU4(cfA({}, "__esModule", {
    value: !0
  }), A), c0Q = {};
  ZU4(c0Q, {
    AlgorithmId: () => n0Q,
    EndpointURLScheme: () => i0Q,
    FieldPosition: () => a0Q,
    HttpApiKeyAuthLocation: () => l0Q,
    HttpAuthLocation: () => p0Q,
    IniSectionType: () => s0Q,
    RequestHandlerProtocol: () => r0Q,
    SMITHY_CONTEXT_KEY: () => FU4,
    getDefaultClientConfiguration: () => XU4,
    resolveDefaultRuntimeConfig: () => VU4
  });
  o0Q.exports = YU4(c0Q);
  var p0Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(p0Q || {}),
    l0Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(l0Q || {}),
    i0Q = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(i0Q || {}),
    n0Q = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(n0Q || {}),
    JU4 = pfA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    WU4 = pfA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    XU4 = pfA((A) => {
      return JU4(A)
    }, "getDefaultClientConfiguration"),
    VU4 = pfA((A) => {
      return WU4(A)
    }, "resolveDefaultRuntimeConfig"),
    a0Q = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(a0Q || {}),
    FU4 = "__smithy_context",
    s0Q = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(s0Q || {}),
    r0Q = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(r0Q || {})
})
// @from(Start 2408594, End 2420809)
FI = z((SC7, JQQ) => {
  var {
    defineProperty: lfA,
    getOwnPropertyDescriptor: KU4,
    getOwnPropertyNames: DU4
  } = Object, HU4 = Object.prototype.hasOwnProperty, YG = (A, Q) => lfA(A, "name", {
    value: Q,
    configurable: !0
  }), CU4 = (A, Q) => {
    for (var B in Q) lfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, EU4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of DU4(Q))
        if (!HU4.call(A, Z) && Z !== B) lfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = KU4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, zU4 = (A) => EU4(lfA({}, "__esModule", {
    value: !0
  }), A), e0Q = {};
  CU4(e0Q, {
    EndpointCache: () => UU4,
    EndpointError: () => lz,
    customEndpointFunctions: () => A$1,
    isIpAddress: () => AQQ,
    isValidHostLabel: () => B$1,
    resolveEndpoint: () => fU4
  });
  JQQ.exports = zU4(e0Q);
  var UU4 = class {
      constructor({
        size: A,
        params: Q
      }) {
        if (this.data = new Map, this.parameters = [], this.capacity = A ?? 50, Q) this.parameters = Q
      }
      static {
        YG(this, "EndpointCache")
      }
      get(A, Q) {
        let B = this.hash(A);
        if (B === !1) return Q();
        if (!this.data.has(B)) {
          if (this.data.size > this.capacity + 10) {
            let G = this.data.keys(),
              Z = 0;
            while (!0) {
              let {
                value: I,
                done: Y
              } = G.next();
              if (this.data.delete(I), Y || ++Z > 10) break
            }
          }
          this.data.set(B, Q())
        }
        return this.data.get(B)
      }
      size() {
        return this.data.size
      }
      hash(A) {
        let Q = "",
          {
            parameters: B
          } = this;
        if (B.length === 0) return !1;
        for (let G of B) {
          let Z = String(A[G] ?? "");
          if (Z.includes("|;")) return !1;
          Q += Z + "|;"
        }
        return Q
      }
    },
    $U4 = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"),
    AQQ = YG((A) => $U4.test(A) || A.startsWith("[") && A.endsWith("]"), "isIpAddress"),
    wU4 = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"),
    B$1 = YG((A, Q = !1) => {
      if (!Q) return wU4.test(A);
      let B = A.split(".");
      for (let G of B)
        if (!B$1(G)) return !1;
      return !0
    }, "isValidHostLabel"),
    A$1 = {},
    iDA = "endpoints";

  function Nv(A) {
    if (typeof A !== "object" || A == null) return A;
    if ("ref" in A) return `$${Nv(A.ref)}`;
    if ("fn" in A) return `${A.fn}(${(A.argv||[]).map(Nv).join(", ")})`;
    return JSON.stringify(A, null, 2)
  }
  YG(Nv, "toDebugString");
  var lz = class extends Error {
      static {
        YG(this, "EndpointError")
      }
      constructor(A) {
        super(A);
        this.name = "EndpointError"
      }
    },
    qU4 = YG((A, Q) => A === Q, "booleanEquals"),
    NU4 = YG((A) => {
      let Q = A.split("."),
        B = [];
      for (let G of Q) {
        let Z = G.indexOf("[");
        if (Z !== -1) {
          if (G.indexOf("]") !== G.length - 1) throw new lz(`Path: '${A}' does not end with ']'`);
          let I = G.slice(Z + 1, -1);
          if (Number.isNaN(parseInt(I))) throw new lz(`Invalid array index: '${I}' in path: '${A}'`);
          if (Z !== 0) B.push(G.slice(0, Z));
          B.push(I)
        } else B.push(G)
      }
      return B
    }, "getAttrPathList"),
    QQQ = YG((A, Q) => NU4(Q).reduce((B, G) => {
      if (typeof B !== "object") throw new lz(`Index '${G}' in '${Q}' not found in '${JSON.stringify(A)}'`);
      else if (Array.isArray(B)) return B[parseInt(G)];
      return B[G]
    }, A), "getAttr"),
    LU4 = YG((A) => A != null, "isSet"),
    MU4 = YG((A) => !A, "not"),
    Q$1 = t0Q(),
    eU1 = {
      [Q$1.EndpointURLScheme.HTTP]: 80,
      [Q$1.EndpointURLScheme.HTTPS]: 443
    },
    OU4 = YG((A) => {
      let Q = (() => {
        try {
          if (A instanceof URL) return A;
          if (typeof A === "object" && "hostname" in A) {
            let {
              hostname: K,
              port: D,
              protocol: H = "",
              path: C = "",
              query: E = {}
            } = A, U = new URL(`${H}//${K}${D?`:${D}`:""}${C}`);
            return U.search = Object.entries(E).map(([q, w]) => `${q}=${w}`).join("&"), U
          }
          return new URL(A)
        } catch (K) {
          return null
        }
      })();
      if (!Q) return console.error(`Unable to parse ${JSON.stringify(A)} as a whatwg URL.`), null;
      let B = Q.href,
        {
          host: G,
          hostname: Z,
          pathname: I,
          protocol: Y,
          search: J
        } = Q;
      if (J) return null;
      let W = Y.slice(0, -1);
      if (!Object.values(Q$1.EndpointURLScheme).includes(W)) return null;
      let X = AQQ(Z),
        V = B.includes(`${G}:${eU1[W]}`) || typeof A === "string" && A.includes(`${G}:${eU1[W]}`),
        F = `${G}${V?`:${eU1[W]}`:""}`;
      return {
        scheme: W,
        authority: F,
        path: I,
        normalizedPath: I.endsWith("/") ? I : `${I}/`,
        isIp: X
      }
    }, "parseURL"),
    RU4 = YG((A, Q) => A === Q, "stringEquals"),
    TU4 = YG((A, Q, B, G) => {
      if (Q >= B || A.length < B) return null;
      if (!G) return A.substring(Q, B);
      return A.substring(A.length - B, A.length - Q)
    }, "substring"),
    PU4 = YG((A) => encodeURIComponent(A).replace(/[!*'()]/g, (Q) => `%${Q.charCodeAt(0).toString(16).toUpperCase()}`), "uriEncode"),
    jU4 = {
      booleanEquals: qU4,
      getAttr: QQQ,
      isSet: LU4,
      isValidHostLabel: B$1,
      not: MU4,
      parseURL: OU4,
      stringEquals: RU4,
      substring: TU4,
      uriEncode: PU4
    },
    BQQ = YG((A, Q) => {
      let B = [],
        G = {
          ...Q.endpointParams,
          ...Q.referenceRecord
        },
        Z = 0;
      while (Z < A.length) {
        let I = A.indexOf("{", Z);
        if (I === -1) {
          B.push(A.slice(Z));
          break
        }
        B.push(A.slice(Z, I));
        let Y = A.indexOf("}", I);
        if (Y === -1) {
          B.push(A.slice(I));
          break
        }
        if (A[I + 1] === "{" && A[Y + 1] === "}") B.push(A.slice(I + 1, Y)), Z = Y + 2;
        let J = A.substring(I + 1, Y);
        if (J.includes("#")) {
          let [W, X] = J.split("#");
          B.push(QQQ(G[W], X))
        } else B.push(G[J]);
        Z = Y + 1
      }
      return B.join("")
    }, "evaluateTemplate"),
    SU4 = YG(({
      ref: A
    }, Q) => {
      return {
        ...Q.endpointParams,
        ...Q.referenceRecord
      } [A]
    }, "getReferenceValue"),
    ifA = YG((A, Q, B) => {
      if (typeof A === "string") return BQQ(A, B);
      else if (A.fn) return GQQ(A, B);
      else if (A.ref) return SU4(A, B);
      throw new lz(`'${Q}': ${String(A)} is not a string, function or reference.`)
    }, "evaluateExpression"),
    GQQ = YG(({
      fn: A,
      argv: Q
    }, B) => {
      let G = Q.map((I) => ["boolean", "number"].includes(typeof I) ? I : ifA(I, "arg", B)),
        Z = A.split(".");
      if (Z[0] in A$1 && Z[1] != null) return A$1[Z[0]][Z[1]](...G);
      return jU4[A](...G)
    }, "callFunction"),
    _U4 = YG(({
      assign: A,
      ...Q
    }, B) => {
      if (A && A in B.referenceRecord) throw new lz(`'${A}' is already defined in Reference Record.`);
      let G = GQQ(Q, B);
      return B.logger?.debug?.(`${iDA} evaluateCondition: ${Nv(Q)} = ${Nv(G)}`), {
        result: G === "" ? !0 : !!G,
        ...A != null && {
          toAssign: {
            name: A,
            value: G
          }
        }
      }
    }, "evaluateCondition"),
    G$1 = YG((A = [], Q) => {
      let B = {};
      for (let G of A) {
        let {
          result: Z,
          toAssign: I
        } = _U4(G, {
          ...Q,
          referenceRecord: {
            ...Q.referenceRecord,
            ...B
          }
        });
        if (!Z) return {
          result: Z
        };
        if (I) B[I.name] = I.value, Q.logger?.debug?.(`${iDA} assign: ${I.name} := ${Nv(I.value)}`)
      }
      return {
        result: !0,
        referenceRecord: B
      }
    }, "evaluateConditions"),
    kU4 = YG((A, Q) => Object.entries(A).reduce((B, [G, Z]) => ({
      ...B,
      [G]: Z.map((I) => {
        let Y = ifA(I, "Header value entry", Q);
        if (typeof Y !== "string") throw new lz(`Header '${G}' value '${Y}' is not a string`);
        return Y
      })
    }), {}), "getEndpointHeaders"),
    ZQQ = YG((A, Q) => {
      if (Array.isArray(A)) return A.map((B) => ZQQ(B, Q));
      switch (typeof A) {
        case "string":
          return BQQ(A, Q);
        case "object":
          if (A === null) throw new lz(`Unexpected endpoint property: ${A}`);
          return IQQ(A, Q);
        case "boolean":
          return A;
        default:
          throw new lz(`Unexpected endpoint property type: ${typeof A}`)
      }
    }, "getEndpointProperty"),
    IQQ = YG((A, Q) => Object.entries(A).reduce((B, [G, Z]) => ({
      ...B,
      [G]: ZQQ(Z, Q)
    }), {}), "getEndpointProperties"),
    yU4 = YG((A, Q) => {
      let B = ifA(A, "Endpoint URL", Q);
      if (typeof B === "string") try {
        return new URL(B)
      } catch (G) {
        throw console.error(`Failed to construct URL with ${B}`, G), G
      }
      throw new lz(`Endpoint URL must be a string, got ${typeof B}`)
    }, "getEndpointUrl"),
    xU4 = YG((A, Q) => {
      let {
        conditions: B,
        endpoint: G
      } = A, {
        result: Z,
        referenceRecord: I
      } = G$1(B, Q);
      if (!Z) return;
      let Y = {
          ...Q,
          referenceRecord: {
            ...Q.referenceRecord,
            ...I
          }
        },
        {
          url: J,
          properties: W,
          headers: X
        } = G;
      return Q.logger?.debug?.(`${iDA} Resolving endpoint from template: ${Nv(G)}`), {
        ...X != null && {
          headers: kU4(X, Y)
        },
        ...W != null && {
          properties: IQQ(W, Y)
        },
        url: yU4(J, Y)
      }
    }, "evaluateEndpointRule"),
    vU4 = YG((A, Q) => {
      let {
        conditions: B,
        error: G
      } = A, {
        result: Z,
        referenceRecord: I
      } = G$1(B, Q);
      if (!Z) return;
      throw new lz(ifA(G, "Error", {
        ...Q,
        referenceRecord: {
          ...Q.referenceRecord,
          ...I
        }
      }))
    }, "evaluateErrorRule"),
    bU4 = YG((A, Q) => {
      let {
        conditions: B,
        rules: G
      } = A, {
        result: Z,
        referenceRecord: I
      } = G$1(B, Q);
      if (!Z) return;
      return YQQ(G, {
        ...Q,
        referenceRecord: {
          ...Q.referenceRecord,
          ...I
        }
      })
    }, "evaluateTreeRule"),
    YQQ = YG((A, Q) => {
      for (let B of A)
        if (B.type === "endpoint") {
          let G = xU4(B, Q);
          if (G) return G
        } else if (B.type === "error") vU4(B, Q);
      else if (B.type === "tree") {
        let G = bU4(B, Q);
        if (G) return G
      } else throw new lz(`Unknown endpoint rule: ${B}`);
      throw new lz("Rules evaluation failed")
    }, "evaluateRules"),
    fU4 = YG((A, Q) => {
      let {
        endpointParams: B,
        logger: G
      } = Q, {
        parameters: Z,
        rules: I
      } = A;
      Q.logger?.debug?.(`${iDA} Initial EndpointParams: ${Nv(B)}`);
      let Y = Object.entries(Z).filter(([, X]) => X.default != null).map(([X, V]) => [X, V.default]);
      if (Y.length > 0)
        for (let [X, V] of Y) B[X] = B[X] ?? V;
      let J = Object.entries(Z).filter(([, X]) => X.required).map(([X]) => X);
      for (let X of J)
        if (B[X] == null) throw new lz(`Missing required parameter: '${X}'`);
      let W = YQQ(I, {
        endpointParams: B,
        logger: G,
        referenceRecord: {}
      });
      return Q.logger?.debug?.(`${iDA} Resolved endpoint: ${Nv(W)}`), W
    }, "resolveEndpoint")
})
// @from(Start 2420815, End 2432273)
p4A = z((yC7, zQQ) => {
  var {
    defineProperty: nfA,
    getOwnPropertyDescriptor: hU4,
    getOwnPropertyNames: gU4
  } = Object, uU4 = Object.prototype.hasOwnProperty, c4A = (A, Q) => nfA(A, "name", {
    value: Q,
    configurable: !0
  }), mU4 = (A, Q) => {
    for (var B in Q) nfA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, dU4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gU4(Q))
        if (!uU4.call(A, Z) && Z !== B) nfA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = hU4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, cU4 = (A) => dU4(nfA({}, "__esModule", {
    value: !0
  }), A), XQQ = {};
  mU4(XQQ, {
    ConditionObject: () => PZ.ConditionObject,
    DeprecatedObject: () => PZ.DeprecatedObject,
    EndpointError: () => PZ.EndpointError,
    EndpointObject: () => PZ.EndpointObject,
    EndpointObjectHeaders: () => PZ.EndpointObjectHeaders,
    EndpointObjectProperties: () => PZ.EndpointObjectProperties,
    EndpointParams: () => PZ.EndpointParams,
    EndpointResolverOptions: () => PZ.EndpointResolverOptions,
    EndpointRuleObject: () => PZ.EndpointRuleObject,
    ErrorRuleObject: () => PZ.ErrorRuleObject,
    EvaluateOptions: () => PZ.EvaluateOptions,
    Expression: () => PZ.Expression,
    FunctionArgv: () => PZ.FunctionArgv,
    FunctionObject: () => PZ.FunctionObject,
    FunctionReturn: () => PZ.FunctionReturn,
    ParameterObject: () => PZ.ParameterObject,
    ReferenceObject: () => PZ.ReferenceObject,
    ReferenceRecord: () => PZ.ReferenceRecord,
    RuleSetObject: () => PZ.RuleSetObject,
    RuleSetRules: () => PZ.RuleSetRules,
    TreeRuleObject: () => PZ.TreeRuleObject,
    awsEndpointFunctions: () => EQQ,
    getUserAgentPrefix: () => nU4,
    isIpAddress: () => PZ.isIpAddress,
    partition: () => HQQ,
    resolveEndpoint: () => PZ.resolveEndpoint,
    setPartitionInfo: () => CQQ,
    useDefaultPartitionInfo: () => iU4
  });
  zQQ.exports = cU4(XQQ);
  var PZ = FI(),
    VQQ = c4A((A, Q = !1) => {
      if (Q) {
        for (let B of A.split("."))
          if (!VQQ(B)) return !1;
        return !0
      }
      if (!(0, PZ.isValidHostLabel)(A)) return !1;
      if (A.length < 3 || A.length > 63) return !1;
      if (A !== A.toLowerCase()) return !1;
      if ((0, PZ.isIpAddress)(A)) return !1;
      return !0
    }, "isVirtualHostableS3Bucket"),
    WQQ = ":",
    pU4 = "/",
    lU4 = c4A((A) => {
      let Q = A.split(WQQ);
      if (Q.length < 6) return null;
      let [B, G, Z, I, Y, ...J] = Q;
      if (B !== "arn" || G === "" || Z === "" || J.join(WQQ) === "") return null;
      let W = J.map((X) => X.split(pU4)).flat();
      return {
        partition: G,
        service: Z,
        region: I,
        accountId: Y,
        resourceId: W
      }
    }, "parseArn"),
    FQQ = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-east-2": {
            description: "Asia Pacific (Taipei)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "cloud.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-e-global": {
            description: "AWS ISOE (Europe) global region"
          },
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "csp.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "AWS ISOF global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      }, {
        id: "aws-eusc",
        outputs: {
          dnsSuffix: "amazonaws.eu",
          dualStackDnsSuffix: "amazonaws.eu",
          implicitGlobalRegion: "eusc-de-east-1",
          name: "aws-eusc",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
        regions: {
          "eusc-de-east-1": {
            description: "EU (Germany)"
          }
        }
      }],
      version: "1.1"
    },
    KQQ = FQQ,
    DQQ = "",
    HQQ = c4A((A) => {
      let {
        partitions: Q
      } = KQQ;
      for (let G of Q) {
        let {
          regions: Z,
          outputs: I
        } = G;
        for (let [Y, J] of Object.entries(Z))
          if (Y === A) return {
            ...I,
            ...J
          }
      }
      for (let G of Q) {
        let {
          regionRegex: Z,
          outputs: I
        } = G;
        if (new RegExp(Z).test(A)) return {
          ...I
        }
      }
      let B = Q.find((G) => G.id === "aws");
      if (!B) throw Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      return {
        ...B.outputs
      }
    }, "partition"),
    CQQ = c4A((A, Q = "") => {
      KQQ = A, DQQ = Q
    }, "setPartitionInfo"),
    iU4 = c4A(() => {
      CQQ(FQQ, "")
    }, "useDefaultPartitionInfo"),
    nU4 = c4A(() => DQQ, "getUserAgentPrefix"),
    EQQ = {
      isVirtualHostableS3Bucket: VQQ,
      parseArn: lU4,
      partition: HQQ
    };
  PZ.customEndpointFunctions.aws = EQQ
})
// @from(Start 2432279, End 2449534)
yr = z((xC7, rfA) => {
  var UQQ, $QQ, wQQ, qQQ, NQQ, LQQ, MQQ, OQQ, RQQ, TQQ, PQQ, jQQ, SQQ, afA, Z$1, _QQ, kQQ, yQQ, l4A, xQQ, vQQ, bQQ, fQQ, hQQ, gQQ, uQQ, mQQ, dQQ, sfA, cQQ, pQQ, lQQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof rfA === "object" && typeof xC7 === "object") A(B(Q, B(xC7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    UQQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, $QQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, wQQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, qQQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, NQQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, LQQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, MQQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, OQQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, RQQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, TQQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, PQQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, jQQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, SQQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) sfA(Y, I, J)
    }, sfA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, afA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, Z$1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, _QQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(Z$1(arguments[Y]));
      return I
    }, kQQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, yQQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, l4A = function(I) {
      return this instanceof l4A ? (this.v = I, this) : new l4A(I)
    }, xQQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof l4A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, vQQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: l4A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, bQQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof afA === "function" ? afA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, fQQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    hQQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") sfA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, gQQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, uQQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, mQQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, dQQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, cQQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    pQQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, lQQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", UQQ), A("__assign", $QQ), A("__rest", wQQ), A("__decorate", qQQ), A("__param", NQQ), A("__esDecorate", LQQ), A("__runInitializers", MQQ), A("__propKey", OQQ), A("__setFunctionName", RQQ), A("__metadata", TQQ), A("__awaiter", PQQ), A("__generator", jQQ), A("__exportStar", SQQ), A("__createBinding", sfA), A("__values", afA), A("__read", Z$1), A("__spread", _QQ), A("__spreadArrays", kQQ), A("__spreadArray", yQQ), A("__await", l4A), A("__asyncGenerator", xQQ), A("__asyncDelegator", vQQ), A("__asyncValues", bQQ), A("__makeTemplateObject", fQQ), A("__importStar", hQQ), A("__importDefault", gQQ), A("__classPrivateFieldGet", uQQ), A("__classPrivateFieldSet", mQQ), A("__classPrivateFieldIn", dQQ), A("__addDisposableResource", cQQ), A("__disposeResources", pQQ), A("__rewriteRelativeImportExtension", lQQ)
  })
})
// @from(Start 2449540, End 2451523)
QL = z((vC7, rQQ) => {
  var {
    defineProperty: ofA,
    getOwnPropertyDescriptor: aU4,
    getOwnPropertyNames: sU4
  } = Object, rU4 = Object.prototype.hasOwnProperty, tfA = (A, Q) => ofA(A, "name", {
    value: Q,
    configurable: !0
  }), oU4 = (A, Q) => {
    for (var B in Q) ofA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, tU4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of sU4(Q))
        if (!rU4.call(A, Z) && Z !== B) ofA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = aU4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, eU4 = (A) => tU4(ofA({}, "__esModule", {
    value: !0
  }), A), iQQ = {};
  oU4(iQQ, {
    emitWarningIfUnsupportedVersion: () => A$4,
    setCredentialFeature: () => nQQ,
    setFeature: () => aQQ,
    setTokenFeature: () => sQQ,
    state: () => I$1
  });
  rQQ.exports = eU4(iQQ);
  var I$1 = {
      warningEmitted: !1
    },
    A$4 = tfA((A) => {
      if (A && !I$1.warningEmitted && parseInt(A.substring(1, A.indexOf("."))) < 18) I$1.warningEmitted = !0, process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`)
    }, "emitWarningIfUnsupportedVersion");

  function nQQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  tfA(nQQ, "setCredentialFeature");

  function aQQ(A, Q, B) {
    if (!A.__aws_sdk_context) A.__aws_sdk_context = {
      features: {}
    };
    else if (!A.__aws_sdk_context.features) A.__aws_sdk_context.features = {};
    A.__aws_sdk_context.features[Q] = B
  }
  tfA(aQQ, "setFeature");

  function sQQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  tfA(sQQ, "setTokenFeature")
})
// @from(Start 2451529, End 2454521)
j2 = z((bC7, tQQ) => {
  var {
    defineProperty: efA,
    getOwnPropertyDescriptor: Q$4,
    getOwnPropertyNames: B$4
  } = Object, G$4 = Object.prototype.hasOwnProperty, xr = (A, Q) => efA(A, "name", {
    value: Q,
    configurable: !0
  }), Z$4 = (A, Q) => {
    for (var B in Q) efA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, I$4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of B$4(Q))
        if (!G$4.call(A, Z) && Z !== B) efA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Q$4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Y$4 = (A) => I$4(efA({}, "__esModule", {
    value: !0
  }), A), oQQ = {};
  Z$4(oQQ, {
    CredentialsProviderError: () => J$4,
    ProviderError: () => AhA,
    TokenProviderError: () => W$4,
    chain: () => X$4,
    fromStatic: () => V$4,
    memoize: () => F$4
  });
  tQQ.exports = Y$4(oQQ);
  var AhA = class A extends Error {
      constructor(Q, B = !0) {
        let G, Z = !0;
        if (typeof B === "boolean") G = void 0, Z = B;
        else if (B != null && typeof B === "object") G = B.logger, Z = B.tryNextLink ?? !0;
        super(Q);
        this.name = "ProviderError", this.tryNextLink = Z, Object.setPrototypeOf(this, A.prototype), G?.debug?.(`@smithy/property-provider ${Z?"->":"(!)"} ${Q}`)
      }
      static {
        xr(this, "ProviderError")
      }
      static from(Q, B = !0) {
        return Object.assign(new this(Q.message, B), Q)
      }
    },
    J$4 = class A extends AhA {
      constructor(Q, B = !0) {
        super(Q, B);
        this.name = "CredentialsProviderError", Object.setPrototypeOf(this, A.prototype)
      }
      static {
        xr(this, "CredentialsProviderError")
      }
    },
    W$4 = class A extends AhA {
      constructor(Q, B = !0) {
        super(Q, B);
        this.name = "TokenProviderError", Object.setPrototypeOf(this, A.prototype)
      }
      static {
        xr(this, "TokenProviderError")
      }
    },
    X$4 = xr((...A) => async () => {
      if (A.length === 0) throw new AhA("No providers in chain");
      let Q;
      for (let B of A) try {
        return await B()
      } catch (G) {
        if (Q = G, G?.tryNextLink) continue;
        throw G
      }
      throw Q
    }, "chain"),
    V$4 = xr((A) => () => Promise.resolve(A), "fromStatic"),
    F$4 = xr((A, Q, B) => {
      let G, Z, I, Y = !1,
        J = xr(async () => {
          if (!Z) Z = A();
          try {
            G = await Z, I = !0, Y = !1
          } finally {
            Z = void 0
          }
          return G
        }, "coalesceProvider");
      if (Q === void 0) return async (W) => {
        if (!I || W?.forceRefresh) G = await J();
        return G
      };
      return async (W) => {
        if (!I || W?.forceRefresh) G = await J();
        if (Y) return G;
        if (B && !B(G)) return Y = !0, G;
        if (Q(G)) return await J(), G;
        return G
      }
    }, "memoize")
})
// @from(Start 2454527, End 2455480)
QBQ = z((fC7, ABQ) => {
  var {
    defineProperty: QhA,
    getOwnPropertyDescriptor: K$4,
    getOwnPropertyNames: D$4
  } = Object, H$4 = Object.prototype.hasOwnProperty, C$4 = (A, Q) => QhA(A, "name", {
    value: Q,
    configurable: !0
  }), E$4 = (A, Q) => {
    for (var B in Q) QhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, z$4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of D$4(Q))
        if (!H$4.call(A, Z) && Z !== B) QhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = K$4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, U$4 = (A) => z$4(QhA({}, "__esModule", {
    value: !0
  }), A), eQQ = {};
  E$4(eQQ, {
    isArrayBuffer: () => $$4
  });
  ABQ.exports = U$4(eQQ);
  var $$4 = C$4((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 2455486, End 2456539)
IBQ = z((hC7, ZBQ) => {
  var {
    defineProperty: BhA,
    getOwnPropertyDescriptor: w$4,
    getOwnPropertyNames: q$4
  } = Object, N$4 = Object.prototype.hasOwnProperty, Y$1 = (A, Q) => BhA(A, "name", {
    value: Q,
    configurable: !0
  }), L$4 = (A, Q) => {
    for (var B in Q) BhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, M$4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of q$4(Q))
        if (!N$4.call(A, Z) && Z !== B) BhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = w$4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, O$4 = (A) => M$4(BhA({}, "__esModule", {
    value: !0
  }), A), BBQ = {};
  L$4(BBQ, {
    escapeUri: () => GBQ,
    escapeUriPath: () => T$4
  });
  ZBQ.exports = O$4(BBQ);
  var GBQ = Y$1((A) => encodeURIComponent(A).replace(/[!'()*]/g, R$4), "escapeUri"),
    R$4 = Y$1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    T$4 = Y$1((A) => A.split("/").map(GBQ).join("/"), "escapeUriPath")
})
// @from(Start 2456545, End 2473458)
yBQ = z((gC7, kBQ) => {
  var {
    defineProperty: XhA,
    getOwnPropertyDescriptor: P$4,
    getOwnPropertyNames: j$4
  } = Object, S$4 = Object.prototype.hasOwnProperty, rK = (A, Q) => XhA(A, "name", {
    value: Q,
    configurable: !0
  }), _$4 = (A, Q) => {
    for (var B in Q) XhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, k$4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of j$4(Q))
        if (!S$4.call(A, Z) && Z !== B) XhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = P$4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, y$4 = (A) => k$4(XhA({}, "__esModule", {
    value: !0
  }), A), VBQ = {};
  _$4(VBQ, {
    ALGORITHM_IDENTIFIER: () => GhA,
    ALGORITHM_IDENTIFIER_V4A: () => f$4,
    ALGORITHM_QUERY_PARAM: () => FBQ,
    ALWAYS_UNSIGNABLE_HEADERS: () => $BQ,
    AMZ_DATE_HEADER: () => H$1,
    AMZ_DATE_QUERY_PARAM: () => V$1,
    AUTH_HEADER: () => D$1,
    CREDENTIAL_QUERY_PARAM: () => KBQ,
    DATE_HEADER: () => CBQ,
    EVENT_ALGORITHM_IDENTIFIER: () => NBQ,
    EXPIRES_QUERY_PARAM: () => HBQ,
    GENERATED_HEADERS: () => EBQ,
    HOST_HEADER: () => v$4,
    KEY_TYPE_IDENTIFIER: () => C$1,
    MAX_CACHE_SIZE: () => MBQ,
    MAX_PRESIGNED_TTL: () => OBQ,
    PROXY_HEADER_PATTERN: () => wBQ,
    REGION_SET_PARAM: () => x$4,
    SEC_HEADER_PATTERN: () => qBQ,
    SHA256_HEADER: () => WhA,
    SIGNATURE_HEADER: () => zBQ,
    SIGNATURE_QUERY_PARAM: () => F$1,
    SIGNED_HEADERS_QUERY_PARAM: () => DBQ,
    SignatureV4: () => a$4,
    SignatureV4Base: () => _BQ,
    TOKEN_HEADER: () => UBQ,
    TOKEN_QUERY_PARAM: () => K$1,
    UNSIGNABLE_PATTERNS: () => b$4,
    UNSIGNED_PAYLOAD: () => LBQ,
    clearCredentialCache: () => g$4,
    createScope: () => IhA,
    getCanonicalHeaders: () => J$1,
    getCanonicalQuery: () => SBQ,
    getPayloadHash: () => YhA,
    getSigningKey: () => RBQ,
    hasHeader: () => TBQ,
    moveHeadersToQuery: () => jBQ,
    prepareRequest: () => X$1,
    signatureV4aContainer: () => s$4
  });
  kBQ.exports = y$4(VBQ);
  var YBQ = O2(),
    FBQ = "X-Amz-Algorithm",
    KBQ = "X-Amz-Credential",
    V$1 = "X-Amz-Date",
    DBQ = "X-Amz-SignedHeaders",
    HBQ = "X-Amz-Expires",
    F$1 = "X-Amz-Signature",
    K$1 = "X-Amz-Security-Token",
    x$4 = "X-Amz-Region-Set",
    D$1 = "authorization",
    H$1 = V$1.toLowerCase(),
    CBQ = "date",
    EBQ = [D$1, H$1, CBQ],
    zBQ = F$1.toLowerCase(),
    WhA = "x-amz-content-sha256",
    UBQ = K$1.toLowerCase(),
    v$4 = "host",
    $BQ = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0
    },
    wBQ = /^proxy-/,
    qBQ = /^sec-/,
    b$4 = [/^proxy-/i, /^sec-/i],
    GhA = "AWS4-HMAC-SHA256",
    f$4 = "AWS4-ECDSA-P256-SHA256",
    NBQ = "AWS4-HMAC-SHA256-PAYLOAD",
    LBQ = "UNSIGNED-PAYLOAD",
    MBQ = 50,
    C$1 = "aws4_request",
    OBQ = 604800,
    Vd = Jd(),
    h$4 = O2(),
    i4A = {},
    ZhA = [],
    IhA = rK((A, Q, B) => `${A}/${Q}/${B}/${C$1}`, "createScope"),
    RBQ = rK(async (A, Q, B, G, Z) => {
      let I = await JBQ(A, Q.secretAccessKey, Q.accessKeyId),
        Y = `${B}:${G}:${Z}:${(0,Vd.toHex)(I)}:${Q.sessionToken}`;
      if (Y in i4A) return i4A[Y];
      ZhA.push(Y);
      while (ZhA.length > MBQ) delete i4A[ZhA.shift()];
      let J = `AWS4${Q.secretAccessKey}`;
      for (let W of [B, G, Z, C$1]) J = await JBQ(A, J, W);
      return i4A[Y] = J
    }, "getSigningKey"),
    g$4 = rK(() => {
      ZhA.length = 0, Object.keys(i4A).forEach((A) => {
        delete i4A[A]
      })
    }, "clearCredentialCache"),
    JBQ = rK((A, Q, B) => {
      let G = new A(Q);
      return G.update((0, h$4.toUint8Array)(B)), G.digest()
    }, "hmac"),
    J$1 = rK(({
      headers: A
    }, Q, B) => {
      let G = {};
      for (let Z of Object.keys(A).sort()) {
        if (A[Z] == null) continue;
        let I = Z.toLowerCase();
        if (I in $BQ || Q?.has(I) || wBQ.test(I) || qBQ.test(I)) {
          if (!B || B && !B.has(I)) continue
        }
        G[I] = A[Z].trim().replace(/\s+/g, " ")
      }
      return G
    }, "getCanonicalHeaders"),
    u$4 = QBQ(),
    m$4 = O2(),
    YhA = rK(async ({
      headers: A,
      body: Q
    }, B) => {
      for (let G of Object.keys(A))
        if (G.toLowerCase() === WhA) return A[G];
      if (Q == null) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      else if (typeof Q === "string" || ArrayBuffer.isView(Q) || (0, u$4.isArrayBuffer)(Q)) {
        let G = new B;
        return G.update((0, m$4.toUint8Array)(Q)), (0, Vd.toHex)(await G.digest())
      }
      return LBQ
    }, "getPayloadHash"),
    WBQ = O2(),
    d$4 = class {
      static {
        rK(this, "HeaderFormatter")
      }
      format(A) {
        let Q = [];
        for (let Z of Object.keys(A)) {
          let I = (0, WBQ.fromUtf8)(Z);
          Q.push(Uint8Array.from([I.byteLength]), I, this.formatHeaderValue(A[Z]))
        }
        let B = new Uint8Array(Q.reduce((Z, I) => Z + I.byteLength, 0)),
          G = 0;
        for (let Z of Q) B.set(Z, G), G += Z.byteLength;
        return B
      }
      formatHeaderValue(A) {
        switch (A.type) {
          case "boolean":
            return Uint8Array.from([A.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, A.value]);
          case "short":
            let Q = new DataView(new ArrayBuffer(3));
            return Q.setUint8(0, 3), Q.setInt16(1, A.value, !1), new Uint8Array(Q.buffer);
          case "integer":
            let B = new DataView(new ArrayBuffer(5));
            return B.setUint8(0, 4), B.setInt32(1, A.value, !1), new Uint8Array(B.buffer);
          case "long":
            let G = new Uint8Array(9);
            return G[0] = 5, G.set(A.value.bytes, 1), G;
          case "binary":
            let Z = new DataView(new ArrayBuffer(3 + A.value.byteLength));
            Z.setUint8(0, 6), Z.setUint16(1, A.value.byteLength, !1);
            let I = new Uint8Array(Z.buffer);
            return I.set(A.value, 3), I;
          case "string":
            let Y = (0, WBQ.fromUtf8)(A.value),
              J = new DataView(new ArrayBuffer(3 + Y.byteLength));
            J.setUint8(0, 7), J.setUint16(1, Y.byteLength, !1);
            let W = new Uint8Array(J.buffer);
            return W.set(Y, 3), W;
          case "timestamp":
            let X = new Uint8Array(9);
            return X[0] = 8, X.set(p$4.fromNumber(A.value.valueOf()).bytes, 1), X;
          case "uuid":
            if (!c$4.test(A.value)) throw Error(`Invalid UUID received: ${A.value}`);
            let V = new Uint8Array(17);
            return V[0] = 9, V.set((0, Vd.fromHex)(A.value.replace(/\-/g, "")), 1), V
        }
      }
    },
    c$4 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    p$4 = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static {
        rK(this, "Int64")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) W$1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) W$1(Q);
        return parseInt((0, Vd.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };

  function W$1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  rK(W$1, "negate");
  var TBQ = rK((A, Q) => {
      A = A.toLowerCase();
      for (let B of Object.keys(Q))
        if (A === B.toLowerCase()) return !0;
      return !1
    }, "hasHeader"),
    PBQ = nC(),
    jBQ = rK((A, Q = {}) => {
      let {
        headers: B,
        query: G = {}
      } = PBQ.HttpRequest.clone(A);
      for (let Z of Object.keys(B)) {
        let I = Z.toLowerCase();
        if (I.slice(0, 6) === "x-amz-" && !Q.unhoistableHeaders?.has(I) || Q.hoistableHeaders?.has(I)) G[Z] = B[Z], delete B[Z]
      }
      return {
        ...A,
        headers: B,
        query: G
      }
    }, "moveHeadersToQuery"),
    X$1 = rK((A) => {
      A = PBQ.HttpRequest.clone(A);
      for (let Q of Object.keys(A.headers))
        if (EBQ.indexOf(Q.toLowerCase()) > -1) delete A.headers[Q];
      return A
    }, "prepareRequest"),
    XBQ = w7(),
    l$4 = O2(),
    JhA = IBQ(),
    SBQ = rK(({
      query: A = {}
    }) => {
      let Q = [],
        B = {};
      for (let G of Object.keys(A)) {
        if (G.toLowerCase() === zBQ) continue;
        let Z = (0, JhA.escapeUri)(G);
        Q.push(Z);
        let I = A[G];
        if (typeof I === "string") B[Z] = `${Z}=${(0,JhA.escapeUri)(I)}`;
        else if (Array.isArray(I)) B[Z] = I.slice(0).reduce((Y, J) => Y.concat([`${Z}=${(0,JhA.escapeUri)(J)}`]), []).sort().join("&")
      }
      return Q.sort().map((G) => B[G]).filter((G) => G).join("&")
    }, "getCanonicalQuery"),
    i$4 = rK((A) => n$4(A).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601"),
    n$4 = rK((A) => {
      if (typeof A === "number") return new Date(A * 1000);
      if (typeof A === "string") {
        if (Number(A)) return new Date(Number(A) * 1000);
        return new Date(A)
      }
      return A
    }, "toDate"),
    _BQ = class {
      static {
        rK(this, "SignatureV4Base")
      }
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        this.service = G, this.sha256 = Z, this.uriEscapePath = I, this.applyChecksum = typeof A === "boolean" ? A : !0, this.regionProvider = (0, XBQ.normalizeProvider)(B), this.credentialProvider = (0, XBQ.normalizeProvider)(Q)
      }
      createCanonicalRequest(A, Q, B) {
        let G = Object.keys(Q).sort();
        return `${A.method}
${this.getCanonicalPath(A)}
${SBQ(A)}
${G.map((Z)=>`${Z}:${Q[Z]}`).join(`
`)}

${G.join(";")}
${B}`
      }
      async createStringToSign(A, Q, B, G) {
        let Z = new this.sha256;
        Z.update((0, l$4.toUint8Array)(B));
        let I = await Z.digest();
        return `${G}
${A}
${Q}
${(0,Vd.toHex)(I)}`
      }
      getCanonicalPath({
        path: A
      }) {
        if (this.uriEscapePath) {
          let Q = [];
          for (let Z of A.split("/")) {
            if (Z?.length === 0) continue;
            if (Z === ".") continue;
            if (Z === "..") Q.pop();
            else Q.push(Z)
          }
          let B = `${A?.startsWith("/")?"/":""}${Q.join("/")}${Q.length>0&&A?.endsWith("/")?"/":""}`;
          return (0, JhA.escapeUri)(B).replace(/%2F/g, "/")
        }
        return A
      }
      validateResolvedCredentials(A) {
        if (typeof A !== "object" || typeof A.accessKeyId !== "string" || typeof A.secretAccessKey !== "string") throw Error("Resolved credential object is not valid")
      }
      formatDate(A) {
        let Q = i$4(A).replace(/[\-:]/g, "");
        return {
          longDate: Q,
          shortDate: Q.slice(0, 8)
        }
      }
      getCanonicalHeaderList(A) {
        return Object.keys(A).sort().join(";")
      }
    },
    a$4 = class extends _BQ {
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        super({
          applyChecksum: A,
          credentials: Q,
          region: B,
          service: G,
          sha256: Z,
          uriEscapePath: I
        });
        this.headerFormatter = new d$4
      }
      static {
        rK(this, "SignatureV4")
      }
      async presign(A, Q = {}) {
        let {
          signingDate: B = new Date,
          expiresIn: G = 3600,
          unsignableHeaders: Z,
          unhoistableHeaders: I,
          signableHeaders: Y,
          hoistableHeaders: J,
          signingRegion: W,
          signingService: X
        } = Q, V = await this.credentialProvider();
        this.validateResolvedCredentials(V);
        let F = W ?? await this.regionProvider(),
          {
            longDate: K,
            shortDate: D
          } = this.formatDate(B);
        if (G > OBQ) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        let H = IhA(D, F, X ?? this.service),
          C = jBQ(X$1(A), {
            unhoistableHeaders: I,
            hoistableHeaders: J
          });
        if (V.sessionToken) C.query[K$1] = V.sessionToken;
        C.query[FBQ] = GhA, C.query[KBQ] = `${V.accessKeyId}/${H}`, C.query[V$1] = K, C.query[HBQ] = G.toString(10);
        let E = J$1(C, Z, Y);
        return C.query[DBQ] = this.getCanonicalHeaderList(E), C.query[F$1] = await this.getSignature(K, H, this.getSigningKey(V, F, D, X), this.createCanonicalRequest(C, E, await YhA(A, this.sha256))), C
      }
      async sign(A, Q) {
        if (typeof A === "string") return this.signString(A, Q);
        else if (A.headers && A.payload) return this.signEvent(A, Q);
        else if (A.message) return this.signMessage(A, Q);
        else return this.signRequest(A, Q)
      }
      async signEvent({
        headers: A,
        payload: Q
      }, {
        signingDate: B = new Date,
        priorSignature: G,
        signingRegion: Z,
        signingService: I
      }) {
        let Y = Z ?? await this.regionProvider(),
          {
            shortDate: J,
            longDate: W
          } = this.formatDate(B),
          X = IhA(J, Y, I ?? this.service),
          V = await YhA({
            headers: {},
            body: Q
          }, this.sha256),
          F = new this.sha256;
        F.update(A);
        let K = (0, Vd.toHex)(await F.digest()),
          D = [NBQ, W, X, G, K, V].join(`
`);
        return this.signString(D, {
          signingDate: B,
          signingRegion: Y,
          signingService: I
        })
      }
      async signMessage(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      }) {
        return this.signEvent({
          headers: this.headerFormatter.format(A.message.headers),
          payload: A.message.body
        }, {
          signingDate: Q,
          signingRegion: B,
          signingService: G,
          priorSignature: A.priorSignature
        }).then((I) => {
          return {
            message: A.message,
            signature: I
          }
        })
      }
      async signString(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      } = {}) {
        let Z = await this.credentialProvider();
        this.validateResolvedCredentials(Z);
        let I = B ?? await this.regionProvider(),
          {
            shortDate: Y
          } = this.formatDate(Q),
          J = new this.sha256(await this.getSigningKey(Z, I, Y, G));
        return J.update((0, YBQ.toUint8Array)(A)), (0, Vd.toHex)(await J.digest())
      }
      async signRequest(A, {
        signingDate: Q = new Date,
        signableHeaders: B,
        unsignableHeaders: G,
        signingRegion: Z,
        signingService: I
      } = {}) {
        let Y = await this.credentialProvider();
        this.validateResolvedCredentials(Y);
        let J = Z ?? await this.regionProvider(),
          W = X$1(A),
          {
            longDate: X,
            shortDate: V
          } = this.formatDate(Q),
          F = IhA(V, J, I ?? this.service);
        if (W.headers[H$1] = X, Y.sessionToken) W.headers[UBQ] = Y.sessionToken;
        let K = await YhA(W, this.sha256);
        if (!TBQ(WhA, W.headers) && this.applyChecksum) W.headers[WhA] = K;
        let D = J$1(W, G, B),
          H = await this.getSignature(X, F, this.getSigningKey(Y, J, V, I), this.createCanonicalRequest(W, D, K));
        return W.headers[D$1] = `${GhA} Credential=${Y.accessKeyId}/${F}, SignedHeaders=${this.getCanonicalHeaderList(D)}, Signature=${H}`, W
      }
      async getSignature(A, Q, B, G) {
        let Z = await this.createStringToSign(A, Q, G, GhA),
          I = new this.sha256(await B);
        return I.update((0, YBQ.toUint8Array)(Z)), (0, Vd.toHex)(await I.digest())
      }
      getSigningKey(A, Q, B, G) {
        return RBQ(this.sha256, A, B, Q, G || this.service)
      }
    },
    s$4 = {
      SignatureV4a: null
    }
})
// @from(Start 2473464, End 2482878)
$$1 = z((cC7, iBQ) => {
  var {
    defineProperty: VhA,
    getOwnPropertyDescriptor: r$4,
    getOwnPropertyNames: o$4
  } = Object, t$4 = Object.prototype.hasOwnProperty, VW = (A, Q) => VhA(A, "name", {
    value: Q,
    configurable: !0
  }), e$4 = (A, Q) => {
    for (var B in Q) VhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Aw4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of o$4(Q))
        if (!t$4.call(A, Z) && Z !== B) VhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = r$4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Qw4 = (A) => Aw4(VhA({}, "__esModule", {
    value: !0
  }), A), mBQ = {};
  e$4(mBQ, {
    AWSSDKSigV4Signer: () => Iw4,
    AwsSdkSigV4ASigner: () => Jw4,
    AwsSdkSigV4Signer: () => U$1,
    NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => Ww4,
    NODE_SIGV4A_CONFIG_OPTIONS: () => Fw4,
    getBearerTokenEnvKey: () => dBQ,
    resolveAWSSDKSigV4Config: () => Dw4,
    resolveAwsSdkSigV4AConfig: () => Vw4,
    resolveAwsSdkSigV4Config: () => cBQ,
    validateSigningProperties: () => z$1
  });
  iBQ.exports = Qw4(mBQ);
  var Bw4 = nC(),
    Gw4 = nC(),
    xBQ = VW((A) => Gw4.HttpResponse.isInstance(A) ? A.headers?.date ?? A.headers?.Date : void 0, "getDateHeader"),
    E$1 = VW((A) => new Date(Date.now() + A), "getSkewCorrectedDate"),
    Zw4 = VW((A, Q) => Math.abs(E$1(Q).getTime() - A) >= 300000, "isClockSkewed"),
    vBQ = VW((A, Q) => {
      let B = Date.parse(A);
      if (Zw4(B, Q)) return B - Date.now();
      return Q
    }, "getUpdatedSystemClockOffset"),
    nDA = VW((A, Q) => {
      if (!Q) throw Error(`Property \`${A}\` is not resolved for AWS SDK SigV4Auth`);
      return Q
    }, "throwSigningPropertyError"),
    z$1 = VW(async (A) => {
      let Q = nDA("context", A.context),
        B = nDA("config", A.config),
        G = Q.endpointV2?.properties?.authSchemes?.[0],
        I = await nDA("signer", B.signer)(G),
        Y = A?.signingRegion,
        J = A?.signingRegionSet,
        W = A?.signingName;
      return {
        config: B,
        signer: I,
        signingRegion: Y,
        signingRegionSet: J,
        signingName: W
      }
    }, "validateSigningProperties"),
    U$1 = class {
      static {
        VW(this, "AwsSdkSigV4Signer")
      }
      async sign(A, Q, B) {
        if (!Bw4.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let G = await z$1(B),
          {
            config: Z,
            signer: I
          } = G,
          {
            signingRegion: Y,
            signingName: J
          } = G,
          W = B.context;
        if (W?.authSchemes?.length ?? !1) {
          let [V, F] = W.authSchemes;
          if (V?.name === "sigv4a" && F?.name === "sigv4") Y = F?.signingRegion ?? Y, J = F?.signingName ?? J
        }
        return await I.sign(A, {
          signingDate: E$1(Z.systemClockOffset),
          signingRegion: Y,
          signingService: J
        })
      }
      errorHandler(A) {
        return (Q) => {
          let B = Q.ServerTime ?? xBQ(Q.$response);
          if (B) {
            let G = nDA("config", A.config),
              Z = G.systemClockOffset;
            if (G.systemClockOffset = vBQ(B, G.systemClockOffset), G.systemClockOffset !== Z && Q.$metadata) Q.$metadata.clockSkewCorrected = !0
          }
          throw Q
        }
      }
      successHandler(A, Q) {
        let B = xBQ(A);
        if (B) {
          let G = nDA("config", Q.config);
          G.systemClockOffset = vBQ(B, G.systemClockOffset)
        }
      }
    },
    Iw4 = U$1,
    Yw4 = nC(),
    Jw4 = class extends U$1 {
      static {
        VW(this, "AwsSdkSigV4ASigner")
      }
      async sign(A, Q, B) {
        if (!Yw4.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let {
          config: G,
          signer: Z,
          signingRegion: I,
          signingRegionSet: Y,
          signingName: J
        } = await z$1(B), X = (await G.sigv4aSigningRegionSet?.() ?? Y ?? [I]).join(",");
        return await Z.sign(A, {
          signingDate: E$1(G.systemClockOffset),
          signingRegion: X,
          signingService: J
        })
      }
    },
    bBQ = VW((A) => typeof A === "string" && A.length > 0 ? A.split(",").map((Q) => Q.trim()) : [], "getArrayForCommaSeparatedString"),
    dBQ = VW((A) => `AWS_BEARER_TOKEN_${A.replace(/[\s-]/g,"_").toUpperCase()}`, "getBearerTokenEnvKey"),
    fBQ = "AWS_AUTH_SCHEME_PREFERENCE",
    hBQ = "auth_scheme_preference",
    Ww4 = {
      environmentVariableSelector: VW((A, Q) => {
        if (Q?.signingName) {
          if (dBQ(Q.signingName) in A) return ["httpBearerAuth"]
        }
        if (!(fBQ in A)) return;
        return bBQ(A[fBQ])
      }, "environmentVariableSelector"),
      configFileSelector: VW((A) => {
        if (!(hBQ in A)) return;
        return bBQ(A[hBQ])
      }, "configFileSelector"),
      default: []
    },
    Xw4 = iB(),
    gBQ = j2(),
    Vw4 = VW((A) => {
      return A.sigv4aSigningRegionSet = (0, Xw4.normalizeProvider)(A.sigv4aSigningRegionSet), A
    }, "resolveAwsSdkSigV4AConfig"),
    Fw4 = {
      environmentVariableSelector(A) {
        if (A.AWS_SIGV4A_SIGNING_REGION_SET) return A.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((Q) => Q.trim());
        throw new gBQ.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
          tryNextLink: !0
        })
      },
      configFileSelector(A) {
        if (A.sigv4a_signing_region_set) return (A.sigv4a_signing_region_set ?? "").split(",").map((Q) => Q.trim());
        throw new gBQ.ProviderError("sigv4a_signing_region_set not set in profile.", {
          tryNextLink: !0
        })
      },
      default: void 0
    },
    Kw4 = QL(),
    vr = iB(),
    uBQ = yBQ(),
    cBQ = VW((A) => {
      let Q = A.credentials,
        B = !!A.credentials,
        G = void 0;
      Object.defineProperty(A, "credentials", {
        set(X) {
          if (X && X !== Q && X !== G) B = !0;
          Q = X;
          let V = pBQ(A, {
              credentials: Q,
              credentialDefaultProvider: A.credentialDefaultProvider
            }),
            F = lBQ(A, V);
          if (B && !F.attributed) G = VW(async (K) => F(K).then((D) => (0, Kw4.setCredentialFeature)(D, "CREDENTIALS_CODE", "e")), "resolvedCredentials"), G.memoized = F.memoized, G.configBound = F.configBound, G.attributed = !0;
          else G = F
        },
        get() {
          return G
        },
        enumerable: !0,
        configurable: !0
      }), A.credentials = Q;
      let {
        signingEscapePath: Z = !0,
        systemClockOffset: I = A.systemClockOffset || 0,
        sha256: Y
      } = A, J;
      if (A.signer) J = (0, vr.normalizeProvider)(A.signer);
      else if (A.regionInfoProvider) J = VW(() => (0, vr.normalizeProvider)(A.region)().then(async (X) => [await A.regionInfoProvider(X, {
        useFipsEndpoint: await A.useFipsEndpoint(),
        useDualstackEndpoint: await A.useDualstackEndpoint()
      }) || {}, X]).then(([X, V]) => {
        let {
          signingRegion: F,
          signingService: K
        } = X;
        A.signingRegion = A.signingRegion || F || V, A.signingName = A.signingName || K || A.serviceId;
        let D = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || uBQ.SignatureV4)(D)
      }), "signer");
      else J = VW(async (X) => {
        X = Object.assign({}, {
          name: "sigv4",
          signingName: A.signingName || A.defaultSigningName,
          signingRegion: await (0, vr.normalizeProvider)(A.region)(),
          properties: {}
        }, X);
        let {
          signingRegion: V,
          signingName: F
        } = X;
        A.signingRegion = A.signingRegion || V, A.signingName = A.signingName || F || A.serviceId;
        let K = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || uBQ.SignatureV4)(K)
      }, "signer");
      return Object.assign(A, {
        systemClockOffset: I,
        signingEscapePath: Z,
        signer: J
      })
    }, "resolveAwsSdkSigV4Config"),
    Dw4 = cBQ;

  function pBQ(A, {
    credentials: Q,
    credentialDefaultProvider: B
  }) {
    let G;
    if (Q)
      if (!Q?.memoized) G = (0, vr.memoizeIdentityProvider)(Q, vr.isIdentityExpired, vr.doesIdentityRequireRefresh);
      else G = Q;
    else if (B) G = (0, vr.normalizeProvider)(B(Object.assign({}, A, {
      parentClientConfig: A
    })));
    else G = VW(async () => {
      throw Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.")
    }, "credentialsProvider");
    return G.memoized = !0, G
  }
  VW(pBQ, "normalizeCredentialProvider");

  function lBQ(A, Q) {
    if (Q.configBound) return Q;
    let B = VW(async (G) => Q({
      ...G,
      callerClientConfig: A
    }), "fn");
    return B.memoized = Q.memoized, B.configBound = !0, B
  }
  VW(lBQ, "bindCallerConfig")
})
// @from(Start 2482884, End 2484342)
oK = z((iC7, sBQ) => {
  var {
    defineProperty: FhA,
    getOwnPropertyDescriptor: Hw4,
    getOwnPropertyNames: Cw4
  } = Object, Ew4 = Object.prototype.hasOwnProperty, zw4 = (A, Q) => FhA(A, "name", {
    value: Q,
    configurable: !0
  }), Uw4 = (A, Q) => {
    for (var B in Q) FhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, $w4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Cw4(Q))
        if (!Ew4.call(A, Z) && Z !== B) FhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Hw4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ww4 = (A) => $w4(FhA({}, "__esModule", {
    value: !0
  }), A), aBQ = {};
  Uw4(aBQ, {
    calculateBodyLength: () => qw4
  });
  sBQ.exports = ww4(aBQ);
  var nBQ = typeof TextEncoder == "function" ? new TextEncoder : null,
    qw4 = zw4((A) => {
      if (typeof A === "string") {
        if (nBQ) return nBQ.encode(A).byteLength;
        let Q = A.length;
        for (let B = Q - 1; B >= 0; B--) {
          let G = A.charCodeAt(B);
          if (G > 127 && G <= 2047) Q++;
          else if (G > 2047 && G <= 65535) Q += 2;
          if (G >= 56320 && G <= 57343) B--
        }
        return Q
      } else if (typeof A.byteLength === "number") return A.byteLength;
      else if (typeof A.size === "number") return A.size;
      throw Error(`Body Length computation failed for ${A}`)
    }, "calculateBodyLength")
})
// @from(Start 2484348, End 2484835)
tBQ = z((rBQ) => {
  Object.defineProperty(rBQ, "__esModule", {
    value: !0
  });
  rBQ.fromBase64 = void 0;
  var Nw4 = hI(),
    Lw4 = /^[A-Za-z0-9+/]*={0,2}$/,
    Mw4 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!Lw4.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, Nw4.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  rBQ.fromBase64 = Mw4
})
// @from(Start 2484841, End 2485420)
Q2Q = z((eBQ) => {
  Object.defineProperty(eBQ, "__esModule", {
    value: !0
  });
  eBQ.toBase64 = void 0;
  var Ow4 = hI(),
    Rw4 = O2(),
    Tw4 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, Rw4.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, Ow4.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  eBQ.toBase64 = Tw4
})
// @from(Start 2485426, End 2486121)
Fd = z((sC7, KhA) => {
  var {
    defineProperty: B2Q,
    getOwnPropertyDescriptor: Pw4,
    getOwnPropertyNames: jw4
  } = Object, Sw4 = Object.prototype.hasOwnProperty, w$1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of jw4(Q))
        if (!Sw4.call(A, Z) && Z !== B) B2Q(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Pw4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, G2Q = (A, Q, B) => (w$1(A, Q, "default"), B && w$1(B, Q, "default")), _w4 = (A) => w$1(B2Q({}, "__esModule", {
    value: !0
  }), A), q$1 = {};
  KhA.exports = _w4(q$1);
  G2Q(q$1, tBQ(), KhA.exports);
  G2Q(q$1, Q2Q(), KhA.exports)
})
// @from(Start 2486127, End 2493923)
uR = z((rC7, J2Q) => {
  var {
    defineProperty: DhA,
    getOwnPropertyDescriptor: kw4,
    getOwnPropertyNames: yw4
  } = Object, xw4 = Object.prototype.hasOwnProperty, BL = (A, Q) => DhA(A, "name", {
    value: Q,
    configurable: !0
  }), vw4 = (A, Q) => {
    for (var B in Q) DhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, bw4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of yw4(Q))
        if (!xw4.call(A, Z) && Z !== B) DhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = kw4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, fw4 = (A) => bw4(DhA({}, "__esModule", {
    value: !0
  }), A), Y2Q = {};
  vw4(Y2Q, {
    constructStack: () => N$1
  });
  J2Q.exports = fw4(Y2Q);
  var br = BL((A, Q) => {
      let B = [];
      if (A) B.push(A);
      if (Q)
        for (let G of Q) B.push(G);
      return B
    }, "getAllAliases"),
    Kd = BL((A, Q) => {
      return `${A||"anonymous"}${Q&&Q.length>0?` (a.k.a. ${Q.join(",")})`:""}`
    }, "getMiddlewareNameWithAliases"),
    N$1 = BL(() => {
      let A = [],
        Q = [],
        B = !1,
        G = new Set,
        Z = BL((F) => F.sort((K, D) => Z2Q[D.step] - Z2Q[K.step] || I2Q[D.priority || "normal"] - I2Q[K.priority || "normal"]), "sort"),
        I = BL((F) => {
          let K = !1,
            D = BL((H) => {
              let C = br(H.name, H.aliases);
              if (C.includes(F)) {
                K = !0;
                for (let E of C) G.delete(E);
                return !1
              }
              return !0
            }, "filterCb");
          return A = A.filter(D), Q = Q.filter(D), K
        }, "removeByName"),
        Y = BL((F) => {
          let K = !1,
            D = BL((H) => {
              if (H.middleware === F) {
                K = !0;
                for (let C of br(H.name, H.aliases)) G.delete(C);
                return !1
              }
              return !0
            }, "filterCb");
          return A = A.filter(D), Q = Q.filter(D), K
        }, "removeByReference"),
        J = BL((F) => {
          return A.forEach((K) => {
            F.add(K.middleware, {
              ...K
            })
          }), Q.forEach((K) => {
            F.addRelativeTo(K.middleware, {
              ...K
            })
          }), F.identifyOnResolve?.(V.identifyOnResolve()), F
        }, "cloneTo"),
        W = BL((F) => {
          let K = [];
          return F.before.forEach((D) => {
            if (D.before.length === 0 && D.after.length === 0) K.push(D);
            else K.push(...W(D))
          }), K.push(F), F.after.reverse().forEach((D) => {
            if (D.before.length === 0 && D.after.length === 0) K.push(D);
            else K.push(...W(D))
          }), K
        }, "expandRelativeMiddlewareList"),
        X = BL((F = !1) => {
          let K = [],
            D = [],
            H = {};
          return A.forEach((E) => {
            let U = {
              ...E,
              before: [],
              after: []
            };
            for (let q of br(U.name, U.aliases)) H[q] = U;
            K.push(U)
          }), Q.forEach((E) => {
            let U = {
              ...E,
              before: [],
              after: []
            };
            for (let q of br(U.name, U.aliases)) H[q] = U;
            D.push(U)
          }), D.forEach((E) => {
            if (E.toMiddleware) {
              let U = H[E.toMiddleware];
              if (U === void 0) {
                if (F) return;
                throw Error(`${E.toMiddleware} is not found when adding ${Kd(E.name,E.aliases)} middleware ${E.relation} ${E.toMiddleware}`)
              }
              if (E.relation === "after") U.after.push(E);
              if (E.relation === "before") U.before.push(E)
            }
          }), Z(K).map(W).reduce((E, U) => {
            return E.push(...U), E
          }, [])
        }, "getMiddlewareList"),
        V = {
          add: (F, K = {}) => {
            let {
              name: D,
              override: H,
              aliases: C
            } = K, E = {
              step: "initialize",
              priority: "normal",
              middleware: F,
              ...K
            }, U = br(D, C);
            if (U.length > 0) {
              if (U.some((q) => G.has(q))) {
                if (!H) throw Error(`Duplicate middleware name '${Kd(D,C)}'`);
                for (let q of U) {
                  let w = A.findIndex((R) => R.name === q || R.aliases?.some((T) => T === q));
                  if (w === -1) continue;
                  let N = A[w];
                  if (N.step !== E.step || E.priority !== N.priority) throw Error(`"${Kd(N.name,N.aliases)}" middleware with ${N.priority} priority in ${N.step} step cannot be overridden by "${Kd(D,C)}" middleware with ${E.priority} priority in ${E.step} step.`);
                  A.splice(w, 1)
                }
              }
              for (let q of U) G.add(q)
            }
            A.push(E)
          },
          addRelativeTo: (F, K) => {
            let {
              name: D,
              override: H,
              aliases: C
            } = K, E = {
              middleware: F,
              ...K
            }, U = br(D, C);
            if (U.length > 0) {
              if (U.some((q) => G.has(q))) {
                if (!H) throw Error(`Duplicate middleware name '${Kd(D,C)}'`);
                for (let q of U) {
                  let w = Q.findIndex((R) => R.name === q || R.aliases?.some((T) => T === q));
                  if (w === -1) continue;
                  let N = Q[w];
                  if (N.toMiddleware !== E.toMiddleware || N.relation !== E.relation) throw Error(`"${Kd(N.name,N.aliases)}" middleware ${N.relation} "${N.toMiddleware}" middleware cannot be overridden by "${Kd(D,C)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`);
                  Q.splice(w, 1)
                }
              }
              for (let q of U) G.add(q)
            }
            Q.push(E)
          },
          clone: () => J(N$1()),
          use: (F) => {
            F.applyToStack(V)
          },
          remove: (F) => {
            if (typeof F === "string") return I(F);
            else return Y(F)
          },
          removeByTag: (F) => {
            let K = !1,
              D = BL((H) => {
                let {
                  tags: C,
                  name: E,
                  aliases: U
                } = H;
                if (C && C.includes(F)) {
                  let q = br(E, U);
                  for (let w of q) G.delete(w);
                  return K = !0, !1
                }
                return !0
              }, "filterCb");
            return A = A.filter(D), Q = Q.filter(D), K
          },
          concat: (F) => {
            let K = J(N$1());
            return K.use(F), K.identifyOnResolve(B || K.identifyOnResolve() || (F.identifyOnResolve?.() ?? !1)), K
          },
          applyToStack: J,
          identify: () => {
            return X(!0).map((F) => {
              let K = F.step ?? F.relation + " " + F.toMiddleware;
              return Kd(F.name, F.aliases) + " - " + K
            })
          },
          identifyOnResolve(F) {
            if (typeof F === "boolean") B = F;
            return B
          },
          resolve: (F, K) => {
            for (let D of X().map((H) => H.middleware).reverse()) F = D(F, K);
            if (B) console.log(V.identify());
            return F
          }
        };
      return V
    }, "constructStack"),
    Z2Q = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1
    },
    I2Q = {
      high: 3,
      normal: 2,
      low: 1
    }
})
// @from(Start 2493929, End 2507953)
K6 = z((oC7, j$1) => {
  var {
    defineProperty: HhA,
    getOwnPropertyDescriptor: hw4,
    getOwnPropertyNames: gw4
  } = Object, uw4 = Object.prototype.hasOwnProperty, R3 = (A, Q) => HhA(A, "name", {
    value: Q,
    configurable: !0
  }), mw4 = (A, Q) => {
    for (var B in Q) HhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, M$1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gw4(Q))
        if (!uw4.call(A, Z) && Z !== B) HhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = hw4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, dw4 = (A, Q, B) => (M$1(A, Q, "default"), B && M$1(B, Q, "default")), cw4 = (A) => M$1(HhA({}, "__esModule", {
    value: !0
  }), A), T$1 = {};
  mw4(T$1, {
    Client: () => pw4,
    Command: () => V2Q,
    NoOpLogger: () => Jq4,
    SENSITIVE_STRING: () => iw4,
    ServiceException: () => aw4,
    _json: () => R$1,
    collectBody: () => L$1.collectBody,
    convertMap: () => Wq4,
    createAggregatedClient: () => nw4,
    decorateServiceException: () => F2Q,
    emitWarningIfUnsupportedVersion: () => tw4,
    extendedEncodeURIComponent: () => L$1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => Iq4,
    getDefaultClientConfiguration: () => Gq4,
    getDefaultExtensionConfiguration: () => D2Q,
    getValueFromTextNode: () => H2Q,
    isSerializableHeaderValue: () => Yq4,
    loadConfigsForDefaultMode: () => ow4,
    map: () => P$1,
    resolveDefaultRuntimeConfig: () => Zq4,
    resolvedPath: () => L$1.resolvedPath,
    serializeDateTime: () => Hq4,
    serializeFloat: () => Dq4,
    take: () => Xq4,
    throwDefaultError: () => K2Q,
    withBaseException: () => sw4
  });
  j$1.exports = cw4(T$1);
  var X2Q = uR(),
    pw4 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, X2Q.constructStack)()
      }
      static {
        R3(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    L$1 = w5(),
    O$1 = IU1(),
    V2Q = class {
      constructor() {
        this.middlewareStack = (0, X2Q.constructStack)()
      }
      static {
        R3(this, "Command")
      }
      static classBuilder() {
        return new lw4
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [O$1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    lw4 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        R3(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      sc(A) {
        return this._operationSchema = A, this._smithyContext.operationSchema = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends V2Q {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this), this.schema = A._operationSchema
          }
          static {
            R3(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    iw4 = "***SensitiveInformation***",
    nw4 = R3((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = R3(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    aw4 = class A extends Error {
      static {
        R3(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    F2Q = R3((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    K2Q = R3(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = rw4(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw F2Q(Y, Q)
    }, "throwDefaultError"),
    sw4 = R3((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        K2Q({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    rw4 = R3((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    ow4 = R3((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    W2Q = !1,
    tw4 = R3((A) => {
      if (A && !W2Q && parseInt(A.substring(1, A.indexOf("."))) < 16) W2Q = !0
    }, "emitWarningIfUnsupportedVersion"),
    ew4 = R3((A) => {
      let Q = [];
      for (let B in O$1.AlgorithmId) {
        let G = O$1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    Aq4 = R3((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    Qq4 = R3((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    Bq4 = R3((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    D2Q = R3((A) => {
      return Object.assign(ew4(A), Qq4(A))
    }, "getDefaultExtensionConfiguration"),
    Gq4 = D2Q,
    Zq4 = R3((A) => {
      return Object.assign(Aq4(A), Bq4(A))
    }, "resolveDefaultRuntimeConfig"),
    Iq4 = R3((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    H2Q = R3((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = H2Q(A[B]);
      return A
    }, "getValueFromTextNode"),
    Yq4 = R3((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    Jq4 = class {
      static {
        R3(this, "NoOpLogger")
      }
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };

  function P$1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, Vq4(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      C2Q(G, null, I, Y)
    }
    return G
  }
  R3(P$1, "map");
  var Wq4 = R3((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    Xq4 = R3((A, Q) => {
      let B = {};
      for (let G in Q) C2Q(B, A, Q, G);
      return B
    }, "take"),
    Vq4 = R3((A, Q, B) => {
      return P$1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    C2Q = R3((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = Fq4, W = Kq4, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    Fq4 = R3((A) => A != null, "nonNullish"),
    Kq4 = R3((A) => A, "pass"),
    Dq4 = R3((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    Hq4 = R3((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    R$1 = R3((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(R$1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = R$1(A[B])
        }
        return Q
      }
      return A
    }, "_json");
  dw4(T$1, s6(), j$1.exports)
})
// @from(Start 2507959, End 2509377)
ChA = z(($q4) => {
  var Cq4 = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040",
    E2Q = "[:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][" + Cq4 + "]*",
    Eq4 = new RegExp("^" + E2Q + "$"),
    zq4 = function(A, Q) {
      let B = [],
        G = Q.exec(A);
      while (G) {
        let Z = [];
        Z.startIndex = Q.lastIndex - G[0].length;
        let I = G.length;
        for (let Y = 0; Y < I; Y++) Z.push(G[Y]);
        B.push(Z), G = Q.exec(A)
      }
      return B
    },
    Uq4 = function(A) {
      let Q = Eq4.exec(A);
      return !(Q === null || typeof Q > "u")
    };
  $q4.isExist = function(A) {
    return typeof A < "u"
  };
  $q4.isEmptyObject = function(A) {
    return Object.keys(A).length === 0
  };
  $q4.merge = function(A, Q, B) {
    if (Q) {
      let G = Object.keys(Q),
        Z = G.length;
      for (let I = 0; I < Z; I++)
        if (B === "strict") A[G[I]] = [Q[G[I]]];
        else A[G[I]] = Q[G[I]]
    }
  };
  $q4.getValue = function(A) {
    if ($q4.isExist(A)) return A;
    else return ""
  };
  $q4.isName = Uq4;
  $q4.getAllMatches = zq4;
  $q4.nameRegexp = E2Q
})
// @from(Start 2509383, End 2516865)
_$1 = z((vq4) => {
  var S$1 = ChA(),
    Rq4 = {
      allowBooleanAttributes: !1,
      unpairedTags: []
    };
  vq4.validate = function(A, Q) {
    Q = Object.assign({}, Rq4, Q);
    let B = [],
      G = !1,
      Z = !1;
    if (A[0] === "\uFEFF") A = A.substr(1);
    for (let I = 0; I < A.length; I++)
      if (A[I] === "<" && A[I + 1] === "?") {
        if (I += 2, I = $2Q(A, I), I.err) return I
      } else if (A[I] === "<") {
      let Y = I;
      if (I++, A[I] === "!") {
        I = w2Q(A, I);
        continue
      } else {
        let J = !1;
        if (A[I] === "/") J = !0, I++;
        let W = "";
        for (; I < A.length && A[I] !== ">" && A[I] !== " " && A[I] !== "\t" && A[I] !== `
` && A[I] !== "\r"; I++) W += A[I];
        if (W = W.trim(), W[W.length - 1] === "/") W = W.substring(0, W.length - 1), I--;
        if (!xq4(W)) {
          let F;
          if (W.trim().length === 0) F = "Invalid space after '<'.";
          else F = "Tag '" + W + "' is an invalid name.";
          return FW("InvalidTag", F, aC(A, I))
        }
        let X = jq4(A, I);
        if (X === !1) return FW("InvalidAttr", "Attributes for '" + W + "' have open quote.", aC(A, I));
        let V = X.value;
        if (I = X.index, V[V.length - 1] === "/") {
          let F = I - V.length;
          V = V.substring(0, V.length - 1);
          let K = q2Q(V, Q);
          if (K === !0) G = !0;
          else return FW(K.err.code, K.err.msg, aC(A, F + K.err.line))
        } else if (J)
          if (!X.tagClosed) return FW("InvalidTag", "Closing tag '" + W + "' doesn't have proper closing.", aC(A, I));
          else if (V.trim().length > 0) return FW("InvalidTag", "Closing tag '" + W + "' can't have attributes or invalid starting.", aC(A, Y));
        else if (B.length === 0) return FW("InvalidTag", "Closing tag '" + W + "' has not been opened.", aC(A, Y));
        else {
          let F = B.pop();
          if (W !== F.tagName) {
            let K = aC(A, F.tagStartPos);
            return FW("InvalidTag", "Expected closing tag '" + F.tagName + "' (opened in line " + K.line + ", col " + K.col + ") instead of closing tag '" + W + "'.", aC(A, Y))
          }
          if (B.length == 0) Z = !0
        } else {
          let F = q2Q(V, Q);
          if (F !== !0) return FW(F.err.code, F.err.msg, aC(A, I - V.length + F.err.line));
          if (Z === !0) return FW("InvalidXml", "Multiple possible root nodes found.", aC(A, I));
          else if (Q.unpairedTags.indexOf(W) !== -1);
          else B.push({
            tagName: W,
            tagStartPos: Y
          });
          G = !0
        }
        for (I++; I < A.length; I++)
          if (A[I] === "<")
            if (A[I + 1] === "!") {
              I++, I = w2Q(A, I);
              continue
            } else if (A[I + 1] === "?") {
          if (I = $2Q(A, ++I), I.err) return I
        } else break;
        else if (A[I] === "&") {
          let F = kq4(A, I);
          if (F == -1) return FW("InvalidChar", "char '&' is not expected.", aC(A, I));
          I = F
        } else if (Z === !0 && !U2Q(A[I])) return FW("InvalidXml", "Extra text at the end", aC(A, I));
        if (A[I] === "<") I--
      }
    } else {
      if (U2Q(A[I])) continue;
      return FW("InvalidChar", "char '" + A[I] + "' is not expected.", aC(A, I))
    }
    if (!G) return FW("InvalidXml", "Start tag expected.", 1);
    else if (B.length == 1) return FW("InvalidTag", "Unclosed tag '" + B[0].tagName + "'.", aC(A, B[0].tagStartPos));
    else if (B.length > 0) return FW("InvalidXml", "Invalid '" + JSON.stringify(B.map((I) => I.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", {
      line: 1,
      col: 1
    });
    return !0
  };

  function U2Q(A) {
    return A === " " || A === "\t" || A === `
` || A === "\r"
  }

  function $2Q(A, Q) {
    let B = Q;
    for (; Q < A.length; Q++)
      if (A[Q] == "?" || A[Q] == " ") {
        let G = A.substr(B, Q - B);
        if (Q > 5 && G === "xml") return FW("InvalidXml", "XML declaration allowed only at the start of the document.", aC(A, Q));
        else if (A[Q] == "?" && A[Q + 1] == ">") {
          Q++;
          break
        } else continue
      } return Q
  }

  function w2Q(A, Q) {
    if (A.length > Q + 5 && A[Q + 1] === "-" && A[Q + 2] === "-") {
      for (Q += 3; Q < A.length; Q++)
        if (A[Q] === "-" && A[Q + 1] === "-" && A[Q + 2] === ">") {
          Q += 2;
          break
        }
    } else if (A.length > Q + 8 && A[Q + 1] === "D" && A[Q + 2] === "O" && A[Q + 3] === "C" && A[Q + 4] === "T" && A[Q + 5] === "Y" && A[Q + 6] === "P" && A[Q + 7] === "E") {
      let B = 1;
      for (Q += 8; Q < A.length; Q++)
        if (A[Q] === "<") B++;
        else if (A[Q] === ">") {
        if (B--, B === 0) break
      }
    } else if (A.length > Q + 9 && A[Q + 1] === "[" && A[Q + 2] === "C" && A[Q + 3] === "D" && A[Q + 4] === "A" && A[Q + 5] === "T" && A[Q + 6] === "A" && A[Q + 7] === "[") {
      for (Q += 8; Q < A.length; Q++)
        if (A[Q] === "]" && A[Q + 1] === "]" && A[Q + 2] === ">") {
          Q += 2;
          break
        }
    }
    return Q
  }
  var Tq4 = '"',
    Pq4 = "'";

  function jq4(A, Q) {
    let B = "",
      G = "",
      Z = !1;
    for (; Q < A.length; Q++) {
      if (A[Q] === Tq4 || A[Q] === Pq4)
        if (G === "") G = A[Q];
        else if (G !== A[Q]);
      else G = "";
      else if (A[Q] === ">") {
        if (G === "") {
          Z = !0;
          break
        }
      }
      B += A[Q]
    }
    if (G !== "") return !1;
    return {
      value: B,
      index: Q,
      tagClosed: Z
    }
  }
  var Sq4 = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");

  function q2Q(A, Q) {
    let B = S$1.getAllMatches(A, Sq4),
      G = {};
    for (let Z = 0; Z < B.length; Z++) {
      if (B[Z][1].length === 0) return FW("InvalidAttr", "Attribute '" + B[Z][2] + "' has no space in starting.", aDA(B[Z]));
      else if (B[Z][3] !== void 0 && B[Z][4] === void 0) return FW("InvalidAttr", "Attribute '" + B[Z][2] + "' is without value.", aDA(B[Z]));
      else if (B[Z][3] === void 0 && !Q.allowBooleanAttributes) return FW("InvalidAttr", "boolean attribute '" + B[Z][2] + "' is not allowed.", aDA(B[Z]));
      let I = B[Z][2];
      if (!yq4(I)) return FW("InvalidAttr", "Attribute '" + I + "' is an invalid name.", aDA(B[Z]));
      if (!G.hasOwnProperty(I)) G[I] = 1;
      else return FW("InvalidAttr", "Attribute '" + I + "' is repeated.", aDA(B[Z]))
    }
    return !0
  }

  function _q4(A, Q) {
    let B = /\d/;
    if (A[Q] === "x") Q++, B = /[\da-fA-F]/;
    for (; Q < A.length; Q++) {
      if (A[Q] === ";") return Q;
      if (!A[Q].match(B)) break
    }
    return -1
  }

  function kq4(A, Q) {
    if (Q++, A[Q] === ";") return -1;
    if (A[Q] === "#") return Q++, _q4(A, Q);
    let B = 0;
    for (; Q < A.length; Q++, B++) {
      if (A[Q].match(/\w/) && B < 20) continue;
      if (A[Q] === ";") break;
      return -1
    }
    return Q
  }

  function FW(A, Q, B) {
    return {
      err: {
        code: A,
        msg: Q,
        line: B.line || B,
        col: B.col
      }
    }
  }

  function yq4(A) {
    return S$1.isName(A)
  }

  function xq4(A) {
    return S$1.isName(A)
  }

  function aC(A, Q) {
    let B = A.substring(0, Q).split(/\r?\n/);
    return {
      line: B.length,
      col: B[B.length - 1].length + 1
    }
  }

  function aDA(A) {
    return A.startIndex + A[1].length
  }
})
// @from(Start 2516871, End 2517946)
L2Q = z((hq4) => {
  var N2Q = {
      preserveOrder: !1,
      attributeNamePrefix: "@_",
      attributesGroupName: !1,
      textNodeName: "#text",
      ignoreAttributes: !0,
      removeNSPrefix: !1,
      allowBooleanAttributes: !1,
      parseTagValue: !0,
      parseAttributeValue: !1,
      trimValues: !0,
      cdataPropName: !1,
      numberParseOptions: {
        hex: !0,
        leadingZeros: !0,
        eNotation: !0
      },
      tagValueProcessor: function(A, Q) {
        return Q
      },
      attributeValueProcessor: function(A, Q) {
        return Q
      },
      stopNodes: [],
      alwaysCreateTextNode: !1,
      isArray: () => !1,
      commentPropName: !1,
      unpairedTags: [],
      processEntities: !0,
      htmlEntities: !1,
      ignoreDeclaration: !1,
      ignorePiTags: !1,
      transformTagName: !1,
      transformAttributeName: !1,
      updateTag: function(A, Q, B) {
        return A
      }
    },
    fq4 = function(A) {
      return Object.assign({}, N2Q, A)
    };
  hq4.buildOptions = fq4;
  hq4.defaultOptions = N2Q
})
// @from(Start 2517952, End 2518507)
R2Q = z((YE7, O2Q) => {
  class M2Q {
    constructor(A) {
      this.tagname = A, this.child = [], this[":@"] = {}
    }
    add(A, Q) {
      if (A === "__proto__") A = "#__proto__";
      this.child.push({
        [A]: Q
      })
    }
    addChild(A) {
      if (A.tagname === "__proto__") A.tagname = "#__proto__";
      if (A[":@"] && Object.keys(A[":@"]).length > 0) this.child.push({
        [A.tagname]: A.child,
        [":@"]: A[":@"]
      });
      else this.child.push({
        [A.tagname]: A.child
      })
    }
  }
  O2Q.exports = M2Q
})
// @from(Start 2518513, End 2521165)
P2Q = z((JE7, T2Q) => {
  var mq4 = ChA();

  function dq4(A, Q) {
    let B = {};
    if (A[Q + 3] === "O" && A[Q + 4] === "C" && A[Q + 5] === "T" && A[Q + 6] === "Y" && A[Q + 7] === "P" && A[Q + 8] === "E") {
      Q = Q + 9;
      let G = 1,
        Z = !1,
        I = !1,
        Y = "";
      for (; Q < A.length; Q++)
        if (A[Q] === "<" && !I) {
          if (Z && lq4(A, Q)) {
            if (Q += 7, [entityName, val, Q] = cq4(A, Q + 1), val.indexOf("&") === -1) B[sq4(entityName)] = {
              regx: RegExp(`&${entityName};`, "g"),
              val
            }
          } else if (Z && iq4(A, Q)) Q += 8;
          else if (Z && nq4(A, Q)) Q += 8;
          else if (Z && aq4(A, Q)) Q += 9;
          else if (pq4) I = !0;
          else throw Error("Invalid DOCTYPE");
          G++, Y = ""
        } else if (A[Q] === ">") {
        if (I) {
          if (A[Q - 1] === "-" && A[Q - 2] === "-") I = !1, G--
        } else G--;
        if (G === 0) break
      } else if (A[Q] === "[") Z = !0;
      else Y += A[Q];
      if (G !== 0) throw Error("Unclosed DOCTYPE")
    } else throw Error("Invalid Tag instead of DOCTYPE");
    return {
      entities: B,
      i: Q
    }
  }

  function cq4(A, Q) {
    let B = "";
    for (; Q < A.length && (A[Q] !== "'" && A[Q] !== '"'); Q++) B += A[Q];
    if (B = B.trim(), B.indexOf(" ") !== -1) throw Error("External entites are not supported");
    let G = A[Q++],
      Z = "";
    for (; Q < A.length && A[Q] !== G; Q++) Z += A[Q];
    return [B, Z, Q]
  }

  function pq4(A, Q) {
    if (A[Q + 1] === "!" && A[Q + 2] === "-" && A[Q + 3] === "-") return !0;
    return !1
  }

  function lq4(A, Q) {
    if (A[Q + 1] === "!" && A[Q + 2] === "E" && A[Q + 3] === "N" && A[Q + 4] === "T" && A[Q + 5] === "I" && A[Q + 6] === "T" && A[Q + 7] === "Y") return !0;
    return !1
  }

  function iq4(A, Q) {
    if (A[Q + 1] === "!" && A[Q + 2] === "E" && A[Q + 3] === "L" && A[Q + 4] === "E" && A[Q + 5] === "M" && A[Q + 6] === "E" && A[Q + 7] === "N" && A[Q + 8] === "T") return !0;
    return !1
  }

  function nq4(A, Q) {
    if (A[Q + 1] === "!" && A[Q + 2] === "A" && A[Q + 3] === "T" && A[Q + 4] === "T" && A[Q + 5] === "L" && A[Q + 6] === "I" && A[Q + 7] === "S" && A[Q + 8] === "T") return !0;
    return !1
  }

  function aq4(A, Q) {
    if (A[Q + 1] === "!" && A[Q + 2] === "N" && A[Q + 3] === "O" && A[Q + 4] === "T" && A[Q + 5] === "A" && A[Q + 6] === "T" && A[Q + 7] === "I" && A[Q + 8] === "O" && A[Q + 9] === "N") return !0;
    return !1
  }

  function sq4(A) {
    if (mq4.isName(A)) return A;
    else throw Error(`Invalid entity name ${A}`)
  }
  T2Q.exports = dq4
})
// @from(Start 2521171, End 2523155)
S2Q = z((WE7, j2Q) => {
  var rq4 = /^[-+]?0x[a-fA-F0-9]+$/,
    oq4 = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
  if (!Number.parseInt && window.parseInt) Number.parseInt = window.parseInt;
  if (!Number.parseFloat && window.parseFloat) Number.parseFloat = window.parseFloat;
  var tq4 = {
    hex: !0,
    leadingZeros: !0,
    decimalPoint: ".",
    eNotation: !0
  };

  function eq4(A, Q = {}) {
    if (Q = Object.assign({}, tq4, Q), !A || typeof A !== "string") return A;
    let B = A.trim();
    if (Q.skipLike !== void 0 && Q.skipLike.test(B)) return A;
    else if (Q.hex && rq4.test(B)) return Number.parseInt(B, 16);
    else {
      let G = oq4.exec(B);
      if (G) {
        let Z = G[1],
          I = G[2],
          Y = AN4(G[3]),
          J = G[4] || G[6];
        if (!Q.leadingZeros && I.length > 0 && Z && B[2] !== ".") return A;
        else if (!Q.leadingZeros && I.length > 0 && !Z && B[1] !== ".") return A;
        else {
          let W = Number(B),
            X = "" + W;
          if (X.search(/[eE]/) !== -1)
            if (Q.eNotation) return W;
            else return A;
          else if (J)
            if (Q.eNotation) return W;
            else return A;
          else if (B.indexOf(".") !== -1)
            if (X === "0" && Y === "") return W;
            else if (X === Y) return W;
          else if (Z && X === "-" + Y) return W;
          else return A;
          if (I)
            if (Y === X) return W;
            else if (Z + Y === X) return W;
          else return A;
          if (B === X) return W;
          else if (B === Z + X) return W;
          return A
        }
      } else return A
    }
  }

  function AN4(A) {
    if (A && A.indexOf(".") !== -1) {
      if (A = A.replace(/0+$/, ""), A === ".") A = "0";
      else if (A[0] === ".") A = "0" + A;
      else if (A[A.length - 1] === ".") A = A.substr(0, A.length - 1);
      return A
    }
    return A
  }
  j2Q.exports = eq4
})
// @from(Start 2523161, End 2535685)
x2Q = z((XE7, y2Q) => {
  var _2Q = ChA(),
    sDA = R2Q(),
    QN4 = P2Q(),
    BN4 = S2Q();
  class k2Q {
    constructor(A) {
      this.options = A, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
        apos: {
          regex: /&(apos|#39|#x27);/g,
          val: "'"
        },
        gt: {
          regex: /&(gt|#62|#x3E);/g,
          val: ">"
        },
        lt: {
          regex: /&(lt|#60|#x3C);/g,
          val: "<"
        },
        quot: {
          regex: /&(quot|#34|#x22);/g,
          val: '"'
        }
      }, this.ampEntity = {
        regex: /&(amp|#38|#x26);/g,
        val: "&"
      }, this.htmlEntities = {
        space: {
          regex: /&(nbsp|#160);/g,
          val: " "
        },
        cent: {
          regex: /&(cent|#162);/g,
          val: ""
        },
        pound: {
          regex: /&(pound|#163);/g,
          val: ""
        },
        yen: {
          regex: /&(yen|#165);/g,
          val: ""
        },
        euro: {
          regex: /&(euro|#8364);/g,
          val: ""
        },
        copyright: {
          regex: /&(copy|#169);/g,
          val: ""
        },
        reg: {
          regex: /&(reg|#174);/g,
          val: ""
        },
        inr: {
          regex: /&(inr|#8377);/g,
          val: ""
        },
        num_dec: {
          regex: /&#([0-9]{1,7});/g,
          val: (Q, B) => String.fromCharCode(Number.parseInt(B, 10))
        },
        num_hex: {
          regex: /&#x([0-9a-fA-F]{1,6});/g,
          val: (Q, B) => String.fromCharCode(Number.parseInt(B, 16))
        }
      }, this.addExternalEntities = GN4, this.parseXml = WN4, this.parseTextData = ZN4, this.resolveNameSpace = IN4, this.buildAttributesMap = JN4, this.isItStopNode = KN4, this.replaceEntitiesValue = VN4, this.readStopNodeData = HN4, this.saveTextToParentTag = FN4, this.addChild = XN4
    }
  }

  function GN4(A) {
    let Q = Object.keys(A);
    for (let B = 0; B < Q.length; B++) {
      let G = Q[B];
      this.lastEntities[G] = {
        regex: new RegExp("&" + G + ";", "g"),
        val: A[G]
      }
    }
  }

  function ZN4(A, Q, B, G, Z, I, Y) {
    if (A !== void 0) {
      if (this.options.trimValues && !G) A = A.trim();
      if (A.length > 0) {
        if (!Y) A = this.replaceEntitiesValue(A);
        let J = this.options.tagValueProcessor(Q, A, B, Z, I);
        if (J === null || J === void 0) return A;
        else if (typeof J !== typeof A || J !== A) return J;
        else if (this.options.trimValues) return y$1(A, this.options.parseTagValue, this.options.numberParseOptions);
        else if (A.trim() === A) return y$1(A, this.options.parseTagValue, this.options.numberParseOptions);
        else return A
      }
    }
  }

  function IN4(A) {
    if (this.options.removeNSPrefix) {
      let Q = A.split(":"),
        B = A.charAt(0) === "/" ? "/" : "";
      if (Q[0] === "xmlns") return "";
      if (Q.length === 2) A = B + Q[1]
    }
    return A
  }
  var YN4 = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");

  function JN4(A, Q, B) {
    if (!this.options.ignoreAttributes && typeof A === "string") {
      let G = _2Q.getAllMatches(A, YN4),
        Z = G.length,
        I = {};
      for (let Y = 0; Y < Z; Y++) {
        let J = this.resolveNameSpace(G[Y][1]),
          W = G[Y][4],
          X = this.options.attributeNamePrefix + J;
        if (J.length) {
          if (this.options.transformAttributeName) X = this.options.transformAttributeName(X);
          if (X === "__proto__") X = "#__proto__";
          if (W !== void 0) {
            if (this.options.trimValues) W = W.trim();
            W = this.replaceEntitiesValue(W);
            let V = this.options.attributeValueProcessor(J, W, Q);
            if (V === null || V === void 0) I[X] = W;
            else if (typeof V !== typeof W || V !== W) I[X] = V;
            else I[X] = y$1(W, this.options.parseAttributeValue, this.options.numberParseOptions)
          } else if (this.options.allowBooleanAttributes) I[X] = !0
        }
      }
      if (!Object.keys(I).length) return;
      if (this.options.attributesGroupName) {
        let Y = {};
        return Y[this.options.attributesGroupName] = I, Y
      }
      return I
    }
  }
  var WN4 = function(A) {
    A = A.replace(/\r\n?/g, `
`);
    let Q = new sDA("!xml"),
      B = Q,
      G = "",
      Z = "";
    for (let I = 0; I < A.length; I++)
      if (A[I] === "<")
        if (A[I + 1] === "/") {
          let J = fr(A, ">", I, "Closing Tag is not closed."),
            W = A.substring(I + 2, J).trim();
          if (this.options.removeNSPrefix) {
            let F = W.indexOf(":");
            if (F !== -1) W = W.substr(F + 1)
          }
          if (this.options.transformTagName) W = this.options.transformTagName(W);
          if (B) G = this.saveTextToParentTag(G, B, Z);
          let X = Z.substring(Z.lastIndexOf(".") + 1);
          if (W && this.options.unpairedTags.indexOf(W) !== -1) throw Error(`Unpaired tag can not be used as closing tag: </${W}>`);
          let V = 0;
          if (X && this.options.unpairedTags.indexOf(X) !== -1) V = Z.lastIndexOf(".", Z.lastIndexOf(".") - 1), this.tagsNodeStack.pop();
          else V = Z.lastIndexOf(".");
          Z = Z.substring(0, V), B = this.tagsNodeStack.pop(), G = "", I = J
        } else if (A[I + 1] === "?") {
      let J = k$1(A, I, !1, "?>");
      if (!J) throw Error("Pi Tag is not closed.");
      if (G = this.saveTextToParentTag(G, B, Z), this.options.ignoreDeclaration && J.tagName === "?xml" || this.options.ignorePiTags);
      else {
        let W = new sDA(J.tagName);
        if (W.add(this.options.textNodeName, ""), J.tagName !== J.tagExp && J.attrExpPresent) W[":@"] = this.buildAttributesMap(J.tagExp, Z, J.tagName);
        this.addChild(B, W, Z)
      }
      I = J.closeIndex + 1
    } else if (A.substr(I + 1, 3) === "!--") {
      let J = fr(A, "-->", I + 4, "Comment is not closed.");
      if (this.options.commentPropName) {
        let W = A.substring(I + 4, J - 2);
        G = this.saveTextToParentTag(G, B, Z), B.add(this.options.commentPropName, [{
          [this.options.textNodeName]: W
        }])
      }
      I = J
    } else if (A.substr(I + 1, 2) === "!D") {
      let J = QN4(A, I);
      this.docTypeEntities = J.entities, I = J.i
    } else if (A.substr(I + 1, 2) === "![") {
      let J = fr(A, "]]>", I, "CDATA is not closed.") - 2,
        W = A.substring(I + 9, J);
      G = this.saveTextToParentTag(G, B, Z);
      let X = this.parseTextData(W, B.tagname, Z, !0, !1, !0, !0);
      if (X == null) X = "";
      if (this.options.cdataPropName) B.add(this.options.cdataPropName, [{
        [this.options.textNodeName]: W
      }]);
      else B.add(this.options.textNodeName, X);
      I = J + 2
    } else {
      let J = k$1(A, I, this.options.removeNSPrefix),
        W = J.tagName,
        X = J.rawTagName,
        V = J.tagExp,
        F = J.attrExpPresent,
        K = J.closeIndex;
      if (this.options.transformTagName) W = this.options.transformTagName(W);
      if (B && G) {
        if (B.tagname !== "!xml") G = this.saveTextToParentTag(G, B, Z, !1)
      }
      let D = B;
      if (D && this.options.unpairedTags.indexOf(D.tagname) !== -1) B = this.tagsNodeStack.pop(), Z = Z.substring(0, Z.lastIndexOf("."));
      if (W !== Q.tagname) Z += Z ? "." + W : W;
      if (this.isItStopNode(this.options.stopNodes, Z, W)) {
        let H = "";
        if (V.length > 0 && V.lastIndexOf("/") === V.length - 1) {
          if (W[W.length - 1] === "/") W = W.substr(0, W.length - 1), Z = Z.substr(0, Z.length - 1), V = W;
          else V = V.substr(0, V.length - 1);
          I = J.closeIndex
        } else if (this.options.unpairedTags.indexOf(W) !== -1) I = J.closeIndex;
        else {
          let E = this.readStopNodeData(A, X, K + 1);
          if (!E) throw Error(`Unexpected end of ${X}`);
          I = E.i, H = E.tagContent
        }
        let C = new sDA(W);
        if (W !== V && F) C[":@"] = this.buildAttributesMap(V, Z, W);
        if (H) H = this.parseTextData(H, W, Z, !0, F, !0, !0);
        Z = Z.substr(0, Z.lastIndexOf(".")), C.add(this.options.textNodeName, H), this.addChild(B, C, Z)
      } else {
        if (V.length > 0 && V.lastIndexOf("/") === V.length - 1) {
          if (W[W.length - 1] === "/") W = W.substr(0, W.length - 1), Z = Z.substr(0, Z.length - 1), V = W;
          else V = V.substr(0, V.length - 1);
          if (this.options.transformTagName) W = this.options.transformTagName(W);
          let H = new sDA(W);
          if (W !== V && F) H[":@"] = this.buildAttributesMap(V, Z, W);
          this.addChild(B, H, Z), Z = Z.substr(0, Z.lastIndexOf("."))
        } else {
          let H = new sDA(W);
          if (this.tagsNodeStack.push(B), W !== V && F) H[":@"] = this.buildAttributesMap(V, Z, W);
          this.addChild(B, H, Z), B = H
        }
        G = "", I = K
      }
    } else G += A[I];
    return Q.child
  };

  function XN4(A, Q, B) {
    let G = this.options.updateTag(Q.tagname, B, Q[":@"]);
    if (G === !1);
    else if (typeof G === "string") Q.tagname = G, A.addChild(Q);
    else A.addChild(Q)
  }
  var VN4 = function(A) {
    if (this.options.processEntities) {
      for (let Q in this.docTypeEntities) {
        let B = this.docTypeEntities[Q];
        A = A.replace(B.regx, B.val)
      }
      for (let Q in this.lastEntities) {
        let B = this.lastEntities[Q];
        A = A.replace(B.regex, B.val)
      }
      if (this.options.htmlEntities)
        for (let Q in this.htmlEntities) {
          let B = this.htmlEntities[Q];
          A = A.replace(B.regex, B.val)
        }
      A = A.replace(this.ampEntity.regex, this.ampEntity.val)
    }
    return A
  };

  function FN4(A, Q, B, G) {
    if (A) {
      if (G === void 0) G = Object.keys(Q.child).length === 0;
      if (A = this.parseTextData(A, Q.tagname, B, !1, Q[":@"] ? Object.keys(Q[":@"]).length !== 0 : !1, G), A !== void 0 && A !== "") Q.add(this.options.textNodeName, A);
      A = ""
    }
    return A
  }

  function KN4(A, Q, B) {
    let G = "*." + B;
    for (let Z in A) {
      let I = A[Z];
      if (G === I || Q === I) return !0
    }
    return !1
  }

  function DN4(A, Q, B = ">") {
    let G, Z = "";
    for (let I = Q; I < A.length; I++) {
      let Y = A[I];
      if (G) {
        if (Y === G) G = ""
      } else if (Y === '"' || Y === "'") G = Y;
      else if (Y === B[0])
        if (B[1]) {
          if (A[I + 1] === B[1]) return {
            data: Z,
            index: I
          }
        } else return {
          data: Z,
          index: I
        };
      else if (Y === "\t") Y = " ";
      Z += Y
    }
  }

  function fr(A, Q, B, G) {
    let Z = A.indexOf(Q, B);
    if (Z === -1) throw Error(G);
    else return Z + Q.length - 1
  }

  function k$1(A, Q, B, G = ">") {
    let Z = DN4(A, Q + 1, G);
    if (!Z) return;
    let {
      data: I,
      index: Y
    } = Z, J = I.search(/\s/), W = I, X = !0;
    if (J !== -1) W = I.substring(0, J), I = I.substring(J + 1).trimStart();
    let V = W;
    if (B) {
      let F = W.indexOf(":");
      if (F !== -1) W = W.substr(F + 1), X = W !== Z.data.substr(F + 1)
    }
    return {
      tagName: W,
      tagExp: I,
      closeIndex: Y,
      attrExpPresent: X,
      rawTagName: V
    }
  }

  function HN4(A, Q, B) {
    let G = B,
      Z = 1;
    for (; B < A.length; B++)
      if (A[B] === "<")
        if (A[B + 1] === "/") {
          let I = fr(A, ">", B, `${Q} is not closed`);
          if (A.substring(B + 2, I).trim() === Q) {
            if (Z--, Z === 0) return {
              tagContent: A.substring(G, B),
              i: I
            }
          }
          B = I
        } else if (A[B + 1] === "?") B = fr(A, "?>", B + 1, "StopNode is not closed.");
    else if (A.substr(B + 1, 3) === "!--") B = fr(A, "-->", B + 3, "StopNode is not closed.");
    else if (A.substr(B + 1, 2) === "![") B = fr(A, "]]>", B, "StopNode is not closed.") - 2;
    else {
      let I = k$1(A, B, ">");
      if (I) {
        if ((I && I.tagName) === Q && I.tagExp[I.tagExp.length - 1] !== "/") Z++;
        B = I.closeIndex
      }
    }
  }

  function y$1(A, Q, B) {
    if (Q && typeof A === "string") {
      let G = A.trim();
      if (G === "true") return !0;
      else if (G === "false") return !1;
      else return BN4(A, B)
    } else if (_2Q.isExist(A)) return A;
    else return ""
  }
  y2Q.exports = k2Q
})
// @from(Start 2535691, End 2537496)
b2Q = z(($N4) => {
  function CN4(A, Q) {
    return v2Q(A, Q)
  }

  function v2Q(A, Q, B) {
    let G, Z = {};
    for (let I = 0; I < A.length; I++) {
      let Y = A[I],
        J = EN4(Y),
        W = "";
      if (B === void 0) W = J;
      else W = B + "." + J;
      if (J === Q.textNodeName)
        if (G === void 0) G = Y[J];
        else G += "" + Y[J];
      else if (J === void 0) continue;
      else if (Y[J]) {
        let X = v2Q(Y[J], Q, W),
          V = UN4(X, Q);
        if (Y[":@"]) zN4(X, Y[":@"], W, Q);
        else if (Object.keys(X).length === 1 && X[Q.textNodeName] !== void 0 && !Q.alwaysCreateTextNode) X = X[Q.textNodeName];
        else if (Object.keys(X).length === 0)
          if (Q.alwaysCreateTextNode) X[Q.textNodeName] = "";
          else X = "";
        if (Z[J] !== void 0 && Z.hasOwnProperty(J)) {
          if (!Array.isArray(Z[J])) Z[J] = [Z[J]];
          Z[J].push(X)
        } else if (Q.isArray(J, W, V)) Z[J] = [X];
        else Z[J] = X
      }
    }
    if (typeof G === "string") {
      if (G.length > 0) Z[Q.textNodeName] = G
    } else if (G !== void 0) Z[Q.textNodeName] = G;
    return Z
  }

  function EN4(A) {
    let Q = Object.keys(A);
    for (let B = 0; B < Q.length; B++) {
      let G = Q[B];
      if (G !== ":@") return G
    }
  }

  function zN4(A, Q, B, G) {
    if (Q) {
      let Z = Object.keys(Q),
        I = Z.length;
      for (let Y = 0; Y < I; Y++) {
        let J = Z[Y];
        if (G.isArray(J, B + "." + J, !0, !0)) A[J] = [Q[J]];
        else A[J] = Q[J]
      }
    }
  }

  function UN4(A, Q) {
    let {
      textNodeName: B
    } = Q, G = Object.keys(A).length;
    if (G === 0) return !0;
    if (G === 1 && (A[B] || typeof A[B] === "boolean" || A[B] === 0)) return !0;
    return !1
  }
  $N4.prettify = CN4
})
// @from(Start 2537502, End 2538693)
g2Q = z((FE7, h2Q) => {
  var {
    buildOptions: qN4
  } = L2Q(), NN4 = x2Q(), {
    prettify: LN4
  } = b2Q(), MN4 = _$1();
  class f2Q {
    constructor(A) {
      this.externalEntities = {}, this.options = qN4(A)
    }
    parse(A, Q) {
      if (typeof A === "string");
      else if (A.toString) A = A.toString();
      else throw Error("XML data is accepted in String or Bytes[] form.");
      if (Q) {
        if (Q === !0) Q = {};
        let Z = MN4.validate(A, Q);
        if (Z !== !0) throw Error(`${Z.err.msg}:${Z.err.line}:${Z.err.col}`)
      }
      let B = new NN4(this.options);
      B.addExternalEntities(this.externalEntities);
      let G = B.parseXml(A);
      if (this.options.preserveOrder || G === void 0) return G;
      else return LN4(G, this.options)
    }
    addEntity(A, Q) {
      if (Q.indexOf("&") !== -1) throw Error("Entity value can't have '&'");
      else if (A.indexOf("&") !== -1 || A.indexOf(";") !== -1) throw Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      else if (Q === "&") throw Error("An entity with value '&' is not permitted");
      else this.externalEntities[A] = Q
    }
  }
  h2Q.exports = f2Q
})
// @from(Start 2538699, End 2541522)
p2Q = z((KE7, c2Q) => {
  function ON4(A, Q) {
    let B = "";
    if (Q.format && Q.indentBy.length > 0) B = `
`;
    return m2Q(A, Q, "", B)
  }

  function m2Q(A, Q, B, G) {
    let Z = "",
      I = !1;
    for (let Y = 0; Y < A.length; Y++) {
      let J = A[Y],
        W = RN4(J);
      if (W === void 0) continue;
      let X = "";
      if (B.length === 0) X = W;
      else X = `${B}.${W}`;
      if (W === Q.textNodeName) {
        let H = J[W];
        if (!TN4(X, Q)) H = Q.tagValueProcessor(W, H), H = d2Q(H, Q);
        if (I) Z += G;
        Z += H, I = !1;
        continue
      } else if (W === Q.cdataPropName) {
        if (I) Z += G;
        Z += `<![CDATA[${J[W][0][Q.textNodeName]}]]>`, I = !1;
        continue
      } else if (W === Q.commentPropName) {
        Z += G + `<!--${J[W][0][Q.textNodeName]}-->`, I = !0;
        continue
      } else if (W[0] === "?") {
        let H = u2Q(J[":@"], Q),
          C = W === "?xml" ? "" : G,
          E = J[W][0][Q.textNodeName];
        E = E.length !== 0 ? " " + E : "", Z += C + `<${W}${E}${H}?>`, I = !0;
        continue
      }
      let V = G;
      if (V !== "") V += Q.indentBy;
      let F = u2Q(J[":@"], Q),
        K = G + `<${W}${F}`,
        D = m2Q(J[W], Q, X, V);
      if (Q.unpairedTags.indexOf(W) !== -1)
        if (Q.suppressUnpairedNode) Z += K + ">";
        else Z += K + "/>";
      else if ((!D || D.length === 0) && Q.suppressEmptyNode) Z += K + "/>";
      else if (D && D.endsWith(">")) Z += K + `>${D}${G}</${W}>`;
      else {
        if (Z += K + ">", D && G !== "" && (D.includes("/>") || D.includes("</"))) Z += G + Q.indentBy + D + G;
        else Z += D;
        Z += `</${W}>`
      }
      I = !0
    }
    return Z
  }

  function RN4(A) {
    let Q = Object.keys(A);
    for (let B = 0; B < Q.length; B++) {
      let G = Q[B];
      if (!A.hasOwnProperty(G)) continue;
      if (G !== ":@") return G
    }
  }

  function u2Q(A, Q) {
    let B = "";
    if (A && !Q.ignoreAttributes)
      for (let G in A) {
        if (!A.hasOwnProperty(G)) continue;
        let Z = Q.attributeValueProcessor(G, A[G]);
        if (Z = d2Q(Z, Q), Z === !0 && Q.suppressBooleanAttributes) B += ` ${G.substr(Q.attributeNamePrefix.length)}`;
        else B += ` ${G.substr(Q.attributeNamePrefix.length)}="${Z}"`
      }
    return B
  }

  function TN4(A, Q) {
    A = A.substr(0, A.length - Q.textNodeName.length - 1);
    let B = A.substr(A.lastIndexOf(".") + 1);
    for (let G in Q.stopNodes)
      if (Q.stopNodes[G] === A || Q.stopNodes[G] === "*." + B) return !0;
    return !1
  }

  function d2Q(A, Q) {
    if (A && A.length > 0 && Q.processEntities)
      for (let B = 0; B < Q.entities.length; B++) {
        let G = Q.entities[B];
        A = A.replace(G.regex, G.val)
      }
    return A
  }
  c2Q.exports = ON4
})
// @from(Start 2541528, End 2548469)
i2Q = z((DE7, l2Q) => {
  var PN4 = p2Q(),
    jN4 = {
      attributeNamePrefix: "@_",
      attributesGroupName: !1,
      textNodeName: "#text",
      ignoreAttributes: !0,
      cdataPropName: !1,
      format: !1,
      indentBy: "  ",
      suppressEmptyNode: !1,
      suppressUnpairedNode: !0,
      suppressBooleanAttributes: !0,
      tagValueProcessor: function(A, Q) {
        return Q
      },
      attributeValueProcessor: function(A, Q) {
        return Q
      },
      preserveOrder: !1,
      commentPropName: !1,
      unpairedTags: [],
      entities: [{
        regex: new RegExp("&", "g"),
        val: "&amp;"
      }, {
        regex: new RegExp(">", "g"),
        val: "&gt;"
      }, {
        regex: new RegExp("<", "g"),
        val: "&lt;"
      }, {
        regex: new RegExp("'", "g"),
        val: "&apos;"
      }, {
        regex: new RegExp('"', "g"),
        val: "&quot;"
      }],
      processEntities: !0,
      stopNodes: [],
      oneListGroup: !1
    };

  function Dd(A) {
    if (this.options = Object.assign({}, jN4, A), this.options.ignoreAttributes || this.options.attributesGroupName) this.isAttribute = function() {
      return !1
    };
    else this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = kN4;
    if (this.processTextOrObjNode = SN4, this.options.format) this.indentate = _N4, this.tagEndChar = `>
`, this.newLine = `
`;
    else this.indentate = function() {
      return ""
    }, this.tagEndChar = ">", this.newLine = ""
  }
  Dd.prototype.build = function(A) {
    if (this.options.preserveOrder) return PN4(A, this.options);
    else {
      if (Array.isArray(A) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) A = {
        [this.options.arrayNodeName]: A
      };
      return this.j2x(A, 0).val
    }
  };
  Dd.prototype.j2x = function(A, Q) {
    let B = "",
      G = "";
    for (let Z in A) {
      if (!Object.prototype.hasOwnProperty.call(A, Z)) continue;
      if (typeof A[Z] > "u") {
        if (this.isAttribute(Z)) G += ""
      } else if (A[Z] === null)
        if (this.isAttribute(Z)) G += "";
        else if (Z[0] === "?") G += this.indentate(Q) + "<" + Z + "?" + this.tagEndChar;
      else G += this.indentate(Q) + "<" + Z + "/" + this.tagEndChar;
      else if (A[Z] instanceof Date) G += this.buildTextValNode(A[Z], Z, "", Q);
      else if (typeof A[Z] !== "object") {
        let I = this.isAttribute(Z);
        if (I) B += this.buildAttrPairStr(I, "" + A[Z]);
        else if (Z === this.options.textNodeName) {
          let Y = this.options.tagValueProcessor(Z, "" + A[Z]);
          G += this.replaceEntitiesValue(Y)
        } else G += this.buildTextValNode(A[Z], Z, "", Q)
      } else if (Array.isArray(A[Z])) {
        let I = A[Z].length,
          Y = "",
          J = "";
        for (let W = 0; W < I; W++) {
          let X = A[Z][W];
          if (typeof X > "u");
          else if (X === null)
            if (Z[0] === "?") G += this.indentate(Q) + "<" + Z + "?" + this.tagEndChar;
            else G += this.indentate(Q) + "<" + Z + "/" + this.tagEndChar;
          else if (typeof X === "object")
            if (this.options.oneListGroup) {
              let V = this.j2x(X, Q + 1);
              if (Y += V.val, this.options.attributesGroupName && X.hasOwnProperty(this.options.attributesGroupName)) J += V.attrStr
            } else Y += this.processTextOrObjNode(X, Z, Q);
          else if (this.options.oneListGroup) {
            let V = this.options.tagValueProcessor(Z, X);
            V = this.replaceEntitiesValue(V), Y += V
          } else Y += this.buildTextValNode(X, Z, "", Q)
        }
        if (this.options.oneListGroup) Y = this.buildObjectNode(Y, Z, J, Q);
        G += Y
      } else if (this.options.attributesGroupName && Z === this.options.attributesGroupName) {
        let I = Object.keys(A[Z]),
          Y = I.length;
        for (let J = 0; J < Y; J++) B += this.buildAttrPairStr(I[J], "" + A[Z][I[J]])
      } else G += this.processTextOrObjNode(A[Z], Z, Q)
    }
    return {
      attrStr: B,
      val: G
    }
  };
  Dd.prototype.buildAttrPairStr = function(A, Q) {
    if (Q = this.options.attributeValueProcessor(A, "" + Q), Q = this.replaceEntitiesValue(Q), this.options.suppressBooleanAttributes && Q === "true") return " " + A;
    else return " " + A + '="' + Q + '"'
  };

  function SN4(A, Q, B) {
    let G = this.j2x(A, B + 1);
    if (A[this.options.textNodeName] !== void 0 && Object.keys(A).length === 1) return this.buildTextValNode(A[this.options.textNodeName], Q, G.attrStr, B);
    else return this.buildObjectNode(G.val, Q, G.attrStr, B)
  }
  Dd.prototype.buildObjectNode = function(A, Q, B, G) {
    if (A === "")
      if (Q[0] === "?") return this.indentate(G) + "<" + Q + B + "?" + this.tagEndChar;
      else return this.indentate(G) + "<" + Q + B + this.closeTag(Q) + this.tagEndChar;
    else {
      let Z = "</" + Q + this.tagEndChar,
        I = "";
      if (Q[0] === "?") I = "?", Z = "";
      if ((B || B === "") && A.indexOf("<") === -1) return this.indentate(G) + "<" + Q + B + I + ">" + A + Z;
      else if (this.options.commentPropName !== !1 && Q === this.options.commentPropName && I.length === 0) return this.indentate(G) + `<!--${A}-->` + this.newLine;
      else return this.indentate(G) + "<" + Q + B + I + this.tagEndChar + A + this.indentate(G) + Z
    }
  };
  Dd.prototype.closeTag = function(A) {
    let Q = "";
    if (this.options.unpairedTags.indexOf(A) !== -1) {
      if (!this.options.suppressUnpairedNode) Q = "/"
    } else if (this.options.suppressEmptyNode) Q = "/";
    else Q = `></${A}`;
    return Q
  };
  Dd.prototype.buildTextValNode = function(A, Q, B, G) {
    if (this.options.cdataPropName !== !1 && Q === this.options.cdataPropName) return this.indentate(G) + `<![CDATA[${A}]]>` + this.newLine;
    else if (this.options.commentPropName !== !1 && Q === this.options.commentPropName) return this.indentate(G) + `<!--${A}-->` + this.newLine;
    else if (Q[0] === "?") return this.indentate(G) + "<" + Q + B + "?" + this.tagEndChar;
    else {
      let Z = this.options.tagValueProcessor(Q, A);
      if (Z = this.replaceEntitiesValue(Z), Z === "") return this.indentate(G) + "<" + Q + B + this.closeTag(Q) + this.tagEndChar;
      else return this.indentate(G) + "<" + Q + B + ">" + Z + "</" + Q + this.tagEndChar
    }
  };
  Dd.prototype.replaceEntitiesValue = function(A) {
    if (A && A.length > 0 && this.options.processEntities)
      for (let Q = 0; Q < this.options.entities.length; Q++) {
        let B = this.options.entities[Q];
        A = A.replace(B.regex, B.val)
      }
    return A
  };

  function _N4(A) {
    return this.options.indentBy.repeat(A)
  }

  function kN4(A) {
    if (A.startsWith(this.options.attributeNamePrefix) && A !== this.options.textNodeName) return A.substr(this.attrPrefixLen);
    else return !1
  }
  l2Q.exports = Dd
})
// @from(Start 2548475, End 2548638)
wS = z((HE7, n2Q) => {
  var yN4 = _$1(),
    xN4 = g2Q(),
    vN4 = i2Q();
  n2Q.exports = {
    XMLParser: xN4,
    XMLValidator: yN4,
    XMLBuilder: vN4
  }
})
// @from(Start 2548644, End 2551762)
rDA = z((CE7, t2Q) => {
  var {
    defineProperty: EhA,
    getOwnPropertyDescriptor: bN4,
    getOwnPropertyNames: fN4
  } = Object, hN4 = Object.prototype.hasOwnProperty, zhA = (A, Q) => EhA(A, "name", {
    value: Q,
    configurable: !0
  }), gN4 = (A, Q) => {
    for (var B in Q) EhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, uN4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of fN4(Q))
        if (!hN4.call(A, Z) && Z !== B) EhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = bN4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, mN4 = (A) => uN4(EhA({}, "__esModule", {
    value: !0
  }), A), a2Q = {};
  gN4(a2Q, {
    XmlNode: () => dN4,
    XmlText: () => o2Q
  });
  t2Q.exports = mN4(a2Q);

  function s2Q(A) {
    return A.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")
  }
  zhA(s2Q, "escapeAttribute");

  function r2Q(A) {
    return A.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;")
  }
  zhA(r2Q, "escapeElement");
  var o2Q = class {
      constructor(A) {
        this.value = A
      }
      static {
        zhA(this, "XmlText")
      }
      toString() {
        return r2Q("" + this.value)
      }
    },
    dN4 = class A {
      constructor(Q, B = []) {
        this.name = Q, this.children = B
      }
      static {
        zhA(this, "XmlNode")
      }
      attributes = {};
      static of (Q, B, G) {
        let Z = new A(Q);
        if (B !== void 0) Z.addChildNode(new o2Q(B));
        if (G !== void 0) Z.withName(G);
        return Z
      }
      withName(Q) {
        return this.name = Q, this
      }
      addAttribute(Q, B) {
        return this.attributes[Q] = B, this
      }
      addChildNode(Q) {
        return this.children.push(Q), this
      }
      removeAttribute(Q) {
        return delete this.attributes[Q], this
      }
      n(Q) {
        return this.name = Q, this
      }
      c(Q) {
        return this.children.push(Q), this
      }
      a(Q, B) {
        if (B != null) this.attributes[Q] = B;
        return this
      }
      cc(Q, B, G = B) {
        if (Q[B] != null) {
          let Z = A.of(B, Q[B]).withName(G);
          this.c(Z)
        }
      }
      l(Q, B, G, Z) {
        if (Q[B] != null) Z().map((Y) => {
          Y.withName(G), this.c(Y)
        })
      }
      lc(Q, B, G, Z) {
        if (Q[B] != null) {
          let I = Z(),
            Y = new A(G);
          I.map((J) => {
            Y.c(J)
          }), this.c(Y)
        }
      }
      toString() {
        let Q = Boolean(this.children.length),
          B = `<${this.name}`,
          G = this.attributes;
        for (let Z of Object.keys(G)) {
          let I = G[Z];
          if (I != null) B += ` ${Z}="${s2Q(""+I)}"`
        }
        return B += !Q ? "/>" : `>${this.children.map((Z)=>Z.toString()).join("")}</${this.name}>`
      }
    }
})
// @from(Start 2551768, End 2596959)
H9Q = z((zE7, D9Q) => {
  var {
    defineProperty: $hA,
    getOwnPropertyDescriptor: cN4,
    getOwnPropertyNames: pN4
  } = Object, lN4 = Object.prototype.hasOwnProperty, Z3 = (A, Q) => $hA(A, "name", {
    value: Q,
    configurable: !0
  }), iN4 = (A, Q) => {
    for (var B in Q) $hA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, nN4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of pN4(Q))
        if (!lN4.call(A, Z) && Z !== B) $hA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = cN4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, aN4 = (A) => nN4($hA({}, "__esModule", {
    value: !0
  }), A), G9Q = {};
  iN4(G9Q, {
    AwsEc2QueryProtocol: () => LL4,
    AwsJson1_0Protocol: () => WL4,
    AwsJson1_1Protocol: () => XL4,
    AwsJsonRpcProtocol: () => m$1,
    AwsQueryProtocol: () => W9Q,
    AwsRestJsonProtocol: () => FL4,
    AwsRestXmlProtocol: () => jL4,
    JsonCodec: () => u$1,
    JsonShapeDeserializer: () => Y9Q,
    JsonShapeSerializer: () => J9Q,
    XmlCodec: () => K9Q,
    XmlShapeDeserializer: () => d$1,
    XmlShapeSerializer: () => F9Q,
    _toBool: () => rN4,
    _toNum: () => oN4,
    _toStr: () => sN4,
    awsExpectUnion: () => DL4,
    loadRestJsonErrorCode: () => g$1,
    loadRestXmlErrorCode: () => V9Q,
    parseJsonBody: () => h$1,
    parseJsonErrorBody: () => GL4,
    parseXmlBody: () => X9Q,
    parseXmlErrorBody: () => TL4
  });
  D9Q.exports = aN4(G9Q);
  var sN4 = Z3((A) => {
      if (A == null) return A;
      if (typeof A === "number" || typeof A === "bigint") {
        let Q = Error(`Received number ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      if (typeof A === "boolean") {
        let Q = Error(`Received boolean ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      return A
    }, "_toStr"),
    rN4 = Z3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (A !== "" && Q !== "false" && Q !== "true") {
          let B = Error(`Received string "${A}" where a boolean was expected.`);
          B.name = "Warning", console.warn(B)
        }
        return A !== "" && Q !== "false"
      }
      return A
    }, "_toBool"),
    oN4 = Z3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = Number(A);
        if (Q.toString() !== A) {
          let B = Error(`Received string "${A}" where a number was expected.`);
          return B.name = "Warning", console.warn(B), A
        }
        return Q
      }
      return A
    }, "_toNum"),
    tN4 = w5(),
    n4A = b4(),
    eN4 = oK(),
    gr = class {
      static {
        Z3(this, "SerdeContextConfig")
      }
      serdeContext;
      setSerdeContext(A) {
        this.serdeContext = A
      }
    },
    oDA = b4(),
    a4A = s6(),
    AL4 = Fd(),
    QL4 = s6();

  function Z9Q(A, Q, B) {
    if (B?.source) {
      let G = B.source;
      if (typeof Q === "number") {
        if (Q > Number.MAX_SAFE_INTEGER || Q < Number.MIN_SAFE_INTEGER || G !== String(Q))
          if (G.includes(".")) return new QL4.NumericValue(G, "bigDecimal");
          else return BigInt(G)
      }
    }
    return Q
  }
  Z3(Z9Q, "jsonReviver");
  var BL4 = K6(),
    I9Q = Z3((A, Q) => (0, BL4.collectBody)(A, Q).then((B) => Q.utf8Encoder(B)), "collectBodyString"),
    h$1 = Z3((A, Q) => I9Q(A, Q).then((B) => {
      if (B.length) try {
        return JSON.parse(B)
      } catch (G) {
        if (G?.name === "SyntaxError") Object.defineProperty(G, "$responseBodyText", {
          value: B
        });
        throw G
      }
      return {}
    }), "parseJsonBody"),
    GL4 = Z3(async (A, Q) => {
      let B = await h$1(A, Q);
      return B.message = B.message ?? B.Message, B
    }, "parseJsonErrorBody"),
    g$1 = Z3((A, Q) => {
      let B = Z3((I, Y) => Object.keys(I).find((J) => J.toLowerCase() === Y.toLowerCase()), "findKey"),
        G = Z3((I) => {
          let Y = I;
          if (typeof Y === "number") Y = Y.toString();
          if (Y.indexOf(",") >= 0) Y = Y.split(",")[0];
          if (Y.indexOf(":") >= 0) Y = Y.split(":")[0];
          if (Y.indexOf("#") >= 0) Y = Y.split("#")[1];
          return Y
        }, "sanitizeErrorCode"),
        Z = B(A.headers, "x-amzn-errortype");
      if (Z !== void 0) return G(A.headers[Z]);
      if (Q && typeof Q === "object") {
        let I = B(Q, "code");
        if (I && Q[I] !== void 0) return G(Q[I]);
        if (Q.__type !== void 0) return G(Q.__type)
      }
    }, "loadRestJsonErrorCode"),
    Y9Q = class extends gr {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        Z3(this, "JsonShapeDeserializer")
      }
      async read(A, Q) {
        return this._read(A, typeof Q === "string" ? JSON.parse(Q, Z9Q) : await h$1(Q, this.serdeContext))
      }
      readObject(A, Q) {
        return this._read(A, Q)
      }
      _read(A, Q) {
        let B = Q !== null && typeof Q === "object",
          G = oDA.NormalizedSchema.of(A);
        if (G.isListSchema() && Array.isArray(Q)) {
          let I = G.getValueSchema(),
            Y = [],
            J = !!G.getMergedTraits().sparse;
          for (let W of Q)
            if (J || W != null) Y.push(this._read(I, W));
          return Y
        } else if (G.isMapSchema() && B) {
          let I = G.getValueSchema(),
            Y = {},
            J = !!G.getMergedTraits().sparse;
          for (let [W, X] of Object.entries(Q))
            if (J || X != null) Y[W] = this._read(I, X);
          return Y
        } else if (G.isStructSchema() && B) {
          let I = {};
          for (let [Y, J] of G.structIterator()) {
            let W = this.settings.jsonName ? J.getMergedTraits().jsonName ?? Y : Y,
              X = this._read(J, Q[W]);
            if (X != null) I[Y] = X
          }
          return I
        }
        if (G.isBlobSchema() && typeof Q === "string") return (0, AL4.fromBase64)(Q);
        let Z = G.getMergedTraits().mediaType;
        if (G.isStringSchema() && typeof Q === "string" && Z) {
          if (Z === "application/json" || Z.endsWith("+json")) return a4A.LazyJsonString.from(Q)
        }
        if (G.isTimestampSchema()) {
          let I = this.settings.timestampFormat;
          switch (I.useTrait ? G.getSchema() === oDA.SCHEMA.TIMESTAMP_DEFAULT ? I.default : G.getSchema() ?? I.default : I.default) {
            case oDA.SCHEMA.TIMESTAMP_DATE_TIME:
              return (0, a4A.parseRfc3339DateTimeWithOffset)(Q);
            case oDA.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, a4A.parseRfc7231DateTime)(Q);
            case oDA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return (0, a4A.parseEpochTimestamp)(Q);
            default:
              return console.warn("Missing timestamp format, parsing value with Date constructor:", Q), new Date(Q)
          }
        }
        if (G.isBigIntegerSchema() && (typeof Q === "number" || typeof Q === "string")) return BigInt(Q);
        if (G.isBigDecimalSchema() && Q != null) {
          if (Q instanceof a4A.NumericValue) return Q;
          return new a4A.NumericValue(String(Q), "bigDecimal")
        }
        if (G.isNumericSchema() && typeof Q === "string") switch (Q) {
          case "Infinity":
            return 1 / 0;
          case "-Infinity":
            return -1 / 0;
          case "NaN":
            return NaN
        }
        return Q
      }
    },
    s4A = b4(),
    ZL4 = s6(),
    IL4 = s6(),
    YL4 = s6(),
    e2Q = String.fromCharCode(925),
    JL4 = class {
      static {
        Z3(this, "JsonReplacer")
      }
      values = new Map;
      counter = 0;
      stage = 0;
      createReplacer() {
        if (this.stage === 1) throw Error("@aws-sdk/core/protocols - JsonReplacer already created.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        return this.stage = 1, (A, Q) => {
          if (Q instanceof YL4.NumericValue) {
            let B = `${e2Q+NaN+this.counter++}_` + Q.string;
            return this.values.set(`"${B}"`, Q.string), B
          }
          if (typeof Q === "bigint") {
            let B = Q.toString(),
              G = `${e2Q+"b"+this.counter++}_` + B;
            return this.values.set(`"${G}"`, B), G
          }
          return Q
        }
      }
      replaceInJson(A) {
        if (this.stage === 0) throw Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        if (this.stage = 2, this.counter === 0) return A;
        for (let [Q, B] of this.values) A = A.replace(Q, B);
        return A
      }
    },
    J9Q = class extends gr {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        Z3(this, "JsonShapeSerializer")
      }
      buffer;
      rootSchema;
      write(A, Q) {
        this.rootSchema = s4A.NormalizedSchema.of(A), this.buffer = this._write(this.rootSchema, Q)
      }
      flush() {
        if (this.rootSchema?.isStructSchema() || this.rootSchema?.isDocumentSchema()) {
          let A = new JL4;
          return A.replaceInJson(JSON.stringify(this.buffer, A.createReplacer(), 0))
        }
        return this.buffer
      }
      _write(A, Q, B) {
        let G = Q !== null && typeof Q === "object",
          Z = s4A.NormalizedSchema.of(A);
        if (Z.isListSchema() && Array.isArray(Q)) {
          let Y = Z.getValueSchema(),
            J = [],
            W = !!Z.getMergedTraits().sparse;
          for (let X of Q)
            if (W || X != null) J.push(this._write(Y, X));
          return J
        } else if (Z.isMapSchema() && G) {
          let Y = Z.getValueSchema(),
            J = {},
            W = !!Z.getMergedTraits().sparse;
          for (let [X, V] of Object.entries(Q))
            if (W || V != null) J[X] = this._write(Y, V);
          return J
        } else if (Z.isStructSchema() && G) {
          let Y = {};
          for (let [J, W] of Z.structIterator()) {
            let X = this.settings.jsonName ? W.getMergedTraits().jsonName ?? J : J,
              V = this._write(W, Q[J], Z);
            if (V !== void 0) Y[X] = V
          }
          return Y
        }
        if (Q === null && B?.isStructSchema()) return;
        if (Z.isBlobSchema() && (Q instanceof Uint8Array || typeof Q === "string")) {
          if (Z === this.rootSchema) return Q;
          if (!this.serdeContext?.base64Encoder) throw Error("Missing base64Encoder in serdeContext");
          return this.serdeContext?.base64Encoder(Q)
        }
        if (Z.isTimestampSchema() && Q instanceof Date) {
          let Y = this.settings.timestampFormat;
          switch (Y.useTrait ? Z.getSchema() === s4A.SCHEMA.TIMESTAMP_DEFAULT ? Y.default : Z.getSchema() ?? Y.default : Y.default) {
            case s4A.SCHEMA.TIMESTAMP_DATE_TIME:
              return Q.toISOString().replace(".000Z", "Z");
            case s4A.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, ZL4.dateToUtcString)(Q);
            case s4A.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return Q.getTime() / 1000;
            default:
              return console.warn("Missing timestamp format, using epoch seconds", Q), Q.getTime() / 1000
          }
        }
        if (Z.isNumericSchema() && typeof Q === "number") {
          if (Math.abs(Q) === 1 / 0 || isNaN(Q)) return String(Q)
        }
        let I = Z.getMergedTraits().mediaType;
        if (Z.isStringSchema() && typeof Q === "string" && I) {
          if (I === "application/json" || I.endsWith("+json")) return IL4.LazyJsonString.from(Q)
        }
        return Q
      }
    },
    u$1 = class extends gr {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        Z3(this, "JsonCodec")
      }
      createSerializer() {
        let A = new J9Q(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new Y9Q(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    m$1 = class extends tN4.RpcProtocol {
      static {
        Z3(this, "AwsJsonRpcProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        this.codec = new u$1({
          timestampFormat: {
            useTrait: !0,
            default: n4A.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          jsonName: !1
        }), this.serializer = this.codec.createSerializer(), this.deserializer = this.codec.createDeserializer()
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
            "x-amz-target": (this.getJsonRpcVersion() === "1.0" ? "JsonRpc10." : "JsonProtocol.") + n4A.NormalizedSchema.of(A).getName()
          }), (0, n4A.deref)(A.input) === "unit" || !G.body) G.body = "{}";
        try {
          G.headers["content-length"] = String((0, eN4.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      getPayloadCodec() {
        return this.codec
      }
      async handleError(A, Q, B, G, Z) {
        let I = g$1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = n4A.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = n4A.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = n4A.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    WL4 = class extends m$1 {
      static {
        Z3(this, "AwsJson1_0Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_0"
      }
      getJsonRpcVersion() {
        return "1.0"
      }
    },
    XL4 = class extends m$1 {
      static {
        Z3(this, "AwsJson1_1Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_1"
      }
      getJsonRpcVersion() {
        return "1.1"
      }
    },
    x$1 = w5(),
    tDA = b4(),
    VL4 = oK(),
    FL4 = class extends x$1.HttpBindingProtocol {
      static {
        Z3(this, "AwsRestJsonProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: tDA.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          httpBindings: !0,
          jsonName: !0
        };
        this.codec = new u$1(Q), this.serializer = new x$1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new x$1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getShapeId() {
        return "aws.protocols#restJson1"
      }
      getPayloadCodec() {
        return this.codec
      }
      setSerdeContext(A) {
        this.codec.setSerdeContext(A), super.setSerdeContext(A)
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = tDA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (!G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/json"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/json"
          }
        }
        if (G.headers["content-type"] && !G.body) G.body = "{}";
        if (G.body) try {
          G.headers["content-length"] = String((0, VL4.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async handleError(A, Q, B, G, Z) {
        let I = g$1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = tDA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = tDA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = tDA.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    KL4 = K6(),
    DL4 = Z3((A) => {
      if (A == null) return;
      if (typeof A === "object" && "__type" in A) delete A.__type;
      return (0, KL4.expectUnion)(A)
    }, "awsExpectUnion"),
    v$1 = w5(),
    Hd = b4(),
    HL4 = oK(),
    CL4 = w5(),
    A9Q = b4(),
    EL4 = K6(),
    zL4 = O2(),
    UL4 = wS(),
    d$1 = class extends gr {
      constructor(A) {
        super();
        this.settings = A, this.stringDeserializer = new CL4.FromStringShapeDeserializer(A)
      }
      static {
        Z3(this, "XmlShapeDeserializer")
      }
      stringDeserializer;
      setSerdeContext(A) {
        this.serdeContext = A, this.stringDeserializer.setSerdeContext(A)
      }
      read(A, Q, B) {
        let G = A9Q.NormalizedSchema.of(A),
          Z = G.getMemberSchemas();
        if (G.isStructSchema() && G.isMemberSchema() && !!Object.values(Z).find((W) => {
            return !!W.getMemberTraits().eventPayload
          })) {
          let W = {},
            X = Object.keys(Z)[0];
          if (Z[X].isBlobSchema()) W[X] = Q;
          else W[X] = this.read(Z[X], Q);
          return W
        }
        let Y = (this.serdeContext?.utf8Encoder ?? zL4.toUtf8)(Q),
          J = this.parseXml(Y);
        return this.readSchema(A, B ? J[B] : J)
      }
      readSchema(A, Q) {
        let B = A9Q.NormalizedSchema.of(A),
          G = B.getMergedTraits(),
          Z = B.getSchema();
        if (B.isListSchema() && !Array.isArray(Q)) return this.readSchema(Z, [Q]);
        if (Q == null) return Q;
        if (typeof Q === "object") {
          let I = !!G.sparse,
            Y = !!G.xmlFlattened;
          if (B.isListSchema()) {
            let W = B.getValueSchema(),
              X = [],
              V = W.getMergedTraits().xmlName ?? "member",
              F = Y ? Q : (Q[0] ?? Q)[V],
              K = Array.isArray(F) ? F : [F];
            for (let D of K)
              if (D != null || I) X.push(this.readSchema(W, D));
            return X
          }
          let J = {};
          if (B.isMapSchema()) {
            let W = B.getKeySchema(),
              X = B.getValueSchema(),
              V;
            if (Y) V = Array.isArray(Q) ? Q : [Q];
            else V = Array.isArray(Q.entry) ? Q.entry : [Q.entry];
            let F = W.getMergedTraits().xmlName ?? "key",
              K = X.getMergedTraits().xmlName ?? "value";
            for (let D of V) {
              let H = D[F],
                C = D[K];
              if (C != null || I) J[H] = this.readSchema(X, C)
            }
            return J
          }
          if (B.isStructSchema()) {
            for (let [W, X] of B.structIterator()) {
              let V = X.getMergedTraits(),
                F = !V.httpPayload ? X.getMemberTraits().xmlName ?? W : V.xmlName ?? X.getName();
              if (Q[F] != null) J[W] = this.readSchema(X, Q[F])
            }
            return J
          }
          if (B.isDocumentSchema()) return Q;
          throw Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${B.getName(!0)}`)
        } else {
          if (B.isListSchema()) return [];
          else if (B.isMapSchema() || B.isStructSchema()) return {};
          return this.stringDeserializer.read(B, Q)
        }
      }
      parseXml(A) {
        if (A.length) {
          let Q = new UL4.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: Z3((Y, J) => J.trim() === "" && J.includes(`
`) ? "" : void 0, "tagValueProcessor")
          });
          Q.addEntity("#xD", "\r"), Q.addEntity("#10", `
`);
          let B;
          try {
            B = Q.parse(A, !0)
          } catch (Y) {
            if (Y && typeof Y === "object") Object.defineProperty(Y, "$responseBodyText", {
              value: A
            });
            throw Y
          }
          let G = "#text",
            Z = Object.keys(B)[0],
            I = B[Z];
          if (I[G]) I[Z] = I[G], delete I[G];
          return (0, EL4.getValueFromTextNode)(I)
        }
        return {}
      }
    },
    b$1 = w5(),
    UhA = b4(),
    $L4 = s6(),
    wL4 = K6(),
    qL4 = Fd(),
    NL4 = class extends gr {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        Z3(this, "QueryShapeSerializer")
      }
      buffer;
      write(A, Q, B = "") {
        if (this.buffer === void 0) this.buffer = "";
        let G = UhA.NormalizedSchema.of(A);
        if (B && !B.endsWith(".")) B += ".";
        if (G.isBlobSchema()) {
          if (typeof Q === "string" || Q instanceof Uint8Array) this.writeKey(B), this.writeValue((this.serdeContext?.base64Encoder ?? qL4.toBase64)(Q))
        } else if (G.isBooleanSchema() || G.isNumericSchema() || G.isStringSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigIntegerSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigDecimalSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(Q instanceof $L4.NumericValue ? Q.string : String(Q))
        } else if (G.isTimestampSchema()) {
          if (Q instanceof Date) switch (this.writeKey(B), (0, b$1.determineTimestampFormat)(G, this.settings)) {
            case UhA.SCHEMA.TIMESTAMP_DATE_TIME:
              this.writeValue(Q.toISOString().replace(".000Z", "Z"));
              break;
            case UhA.SCHEMA.TIMESTAMP_HTTP_DATE:
              this.writeValue((0, wL4.dateToUtcString)(Q));
              break;
            case UhA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              this.writeValue(String(Q.getTime() / 1000));
              break
          }
        } else if (G.isDocumentSchema()) throw Error(`@aws-sdk/core/protocols - QuerySerializer unsupported document type ${G.getName(!0)}`);
        else if (G.isListSchema()) {
          if (Array.isArray(Q))
            if (Q.length === 0) {
              if (this.settings.serializeEmptyLists) this.writeKey(B), this.writeValue("")
            } else {
              let Z = G.getValueSchema(),
                I = this.settings.flattenLists || G.getMergedTraits().xmlFlattened,
                Y = 1;
              for (let J of Q) {
                if (J == null) continue;
                let W = this.getKey("member", Z.getMergedTraits().xmlName),
                  X = I ? `${B}${Y}` : `${B}${W}.${Y}`;
                this.write(Z, J, X), ++Y
              }
            }
        } else if (G.isMapSchema()) {
          if (Q && typeof Q === "object") {
            let Z = G.getKeySchema(),
              I = G.getValueSchema(),
              Y = G.getMergedTraits().xmlFlattened,
              J = 1;
            for (let [W, X] of Object.entries(Q)) {
              if (X == null) continue;
              let V = this.getKey("key", Z.getMergedTraits().xmlName),
                F = Y ? `${B}${J}.${V}` : `${B}entry.${J}.${V}`,
                K = this.getKey("value", I.getMergedTraits().xmlName),
                D = Y ? `${B}${J}.${K}` : `${B}entry.${J}.${K}`;
              this.write(Z, W, F), this.write(I, X, D), ++J
            }
          }
        } else if (G.isStructSchema()) {
          if (Q && typeof Q === "object")
            for (let [Z, I] of G.structIterator()) {
              if (Q[Z] == null) continue;
              let Y = this.getKey(Z, I.getMergedTraits().xmlName),
                J = `${B}${Y}`;
              this.write(I, Q[Z], J)
            }
        } else if (G.isUnitSchema());
        else throw Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${G.getName(!0)}`)
      }
      flush() {
        if (this.buffer === void 0) throw Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
        let A = this.buffer;
        return delete this.buffer, A
      }
      getKey(A, Q) {
        let B = Q ?? A;
        if (this.settings.capitalizeKeys) return B[0].toUpperCase() + B.slice(1);
        return B
      }
      writeKey(A) {
        if (A.endsWith(".")) A = A.slice(0, A.length - 1);
        this.buffer += `&${(0,b$1.extendedEncodeURIComponent)(A)}=`
      }
      writeValue(A) {
        this.buffer += (0, b$1.extendedEncodeURIComponent)(A)
      }
    },
    W9Q = class extends v$1.RpcProtocol {
      constructor(A) {
        super({
          defaultNamespace: A.defaultNamespace
        });
        this.options = A;
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: Hd.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !1,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace,
          serializeEmptyLists: !0
        };
        this.serializer = new NL4(Q), this.deserializer = new d$1(Q)
      }
      static {
        Z3(this, "AwsQueryProtocol")
      }
      serializer;
      deserializer;
      getShapeId() {
        return "aws.protocols#awsQuery"
      }
      setSerdeContext(A) {
        this.serializer.setSerdeContext(A), this.deserializer.setSerdeContext(A)
      }
      getPayloadCodec() {
        throw Error("AWSQuery protocol has no payload codec.")
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": "application/x-www-form-urlencoded"
          }), (0, Hd.deref)(A.input) === "unit" || !G.body) G.body = "";
        if (G.body = `Action=${A.name.split("#")[1]}&Version=${this.options.version}` + G.body, G.body.endsWith("&")) G.body = G.body.slice(-1);
        try {
          G.headers["content-length"] = String((0, HL4.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        let G = this.deserializer,
          Z = Hd.NormalizedSchema.of(A.output),
          I = {};
        if (B.statusCode >= 300) {
          let X = await (0, v$1.collectBody)(B.body, Q);
          if (X.byteLength > 0) Object.assign(I, await G.read(Hd.SCHEMA.DOCUMENT, X));
          await this.handleError(A, Q, B, I, this.deserializeMetadata(B))
        }
        for (let X in B.headers) {
          let V = B.headers[X];
          delete B.headers[X], B.headers[X.toLowerCase()] = V
        }
        let Y = Z.isStructSchema() && this.useNestedResult() ? A.name.split("#")[1] + "Result" : void 0,
          J = await (0, v$1.collectBody)(B.body, Q);
        if (J.byteLength > 0) Object.assign(I, await G.read(Z, J, Y));
        return {
          $metadata: this.deserializeMetadata(B),
          ...I
        }
      }
      useNestedResult() {
        return !0
      }
      async handleError(A, Q, B, G, Z) {
        let I = this.loadQueryErrorCode(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = this.loadQueryError(G),
          X = Hd.TypeRegistry.for(Y),
          V;
        try {
          if (V = X.find((C) => Hd.NormalizedSchema.of(C).getMergedTraits().awsQueryError?.[0] === J), !V) V = X.getSchema(I)
        } catch (C) {
          let E = Hd.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (E) {
            let U = E.ctor;
            throw Object.assign(new U(J), W)
          }
          throw Error(J)
        }
        let F = Hd.NormalizedSchema.of(V),
          K = this.loadQueryErrorMessage(G),
          D = new V.ctor(K),
          H = {};
        for (let [C, E] of F.structIterator()) {
          let U = E.getMergedTraits().xmlName ?? C,
            q = W[U] ?? G[U];
          H[C] = this.deserializer.readSchema(E, q)
        }
        throw Object.assign(D, {
          $metadata: Z,
          $response: B,
          $fault: F.getMergedTraits().error,
          message: K,
          ...H
        }), D
      }
      loadQueryErrorCode(A, Q) {
        let B = (Q.Errors?.[0]?.Error ?? Q.Errors?.Error ?? Q.Error)?.Code;
        if (B !== void 0) return B;
        if (A.statusCode == 404) return "NotFound"
      }
      loadQueryError(A) {
        return A.Errors?.[0]?.Error ?? A.Errors?.Error ?? A.Error
      }
      loadQueryErrorMessage(A) {
        let Q = this.loadQueryError(A);
        return Q?.message ?? Q?.Message ?? A.message ?? A.Message ?? "Unknown"
      }
    },
    LL4 = class extends W9Q {
      constructor(A) {
        super(A);
        this.options = A;
        let Q = {
          capitalizeKeys: !0,
          flattenLists: !0,
          serializeEmptyLists: !1
        };
        Object.assign(this.serializer.settings, Q)
      }
      static {
        Z3(this, "AwsEc2QueryProtocol")
      }
      useNestedResult() {
        return !1
      }
    },
    f$1 = w5(),
    eDA = b4(),
    ML4 = oK(),
    OL4 = K6(),
    RL4 = wS(),
    X9Q = Z3((A, Q) => I9Q(A, Q).then((B) => {
      if (B.length) {
        let G = new RL4.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: !0,
          ignoreAttributes: !1,
          ignoreDeclaration: !0,
          parseTagValue: !1,
          trimValues: !1,
          tagValueProcessor: Z3((W, X) => X.trim() === "" && X.includes(`
`) ? "" : void 0, "tagValueProcessor")
        });
        G.addEntity("#xD", "\r"), G.addEntity("#10", `
`);
        let Z;
        try {
          Z = G.parse(B, !0)
        } catch (W) {
          if (W && typeof W === "object") Object.defineProperty(W, "$responseBodyText", {
            value: B
          });
          throw W
        }
        let I = "#text",
          Y = Object.keys(Z)[0],
          J = Z[Y];
        if (J[I]) J[Y] = J[I], delete J[I];
        return (0, OL4.getValueFromTextNode)(J)
      }
      return {}
    }), "parseXmlBody"),
    TL4 = Z3(async (A, Q) => {
      let B = await X9Q(A, Q);
      if (B.Error) B.Error.message = B.Error.message ?? B.Error.Message;
      return B
    }, "parseXmlErrorBody"),
    V9Q = Z3((A, Q) => {
      if (Q?.Error?.Code !== void 0) return Q.Error.Code;
      if (Q?.Code !== void 0) return Q.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadRestXmlErrorCode"),
    qS = rDA(),
    hr = b4(),
    PL4 = s6(),
    Q9Q = K6(),
    B9Q = Fd(),
    F9Q = class extends gr {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        Z3(this, "XmlShapeSerializer")
      }
      stringBuffer;
      byteBuffer;
      buffer;
      write(A, Q) {
        let B = hr.NormalizedSchema.of(A);
        if (B.isStringSchema() && typeof Q === "string") this.stringBuffer = Q;
        else if (B.isBlobSchema()) this.byteBuffer = "byteLength" in Q ? Q : (this.serdeContext?.base64Decoder ?? B9Q.fromBase64)(Q);
        else {
          this.buffer = this.writeStruct(B, Q, void 0);
          let G = B.getMergedTraits();
          if (G.httpPayload && !G.xmlName) this.buffer.withName(B.getName())
        }
      }
      flush() {
        if (this.byteBuffer !== void 0) {
          let Q = this.byteBuffer;
          return delete this.byteBuffer, Q
        }
        if (this.stringBuffer !== void 0) {
          let Q = this.stringBuffer;
          return delete this.stringBuffer, Q
        }
        let A = this.buffer;
        if (this.settings.xmlNamespace) {
          if (!A?.attributes?.xmlns) A.addAttribute("xmlns", this.settings.xmlNamespace)
        }
        return delete this.buffer, A.toString()
      }
      writeStruct(A, Q, B) {
        let G = A.getMergedTraits(),
          Z = A.isMemberSchema() && !G.httpPayload ? A.getMemberTraits().xmlName ?? A.getMemberName() : G.xmlName ?? A.getName();
        if (!Z || !A.isStructSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${A.getName(!0)}.`);
        let I = qS.XmlNode.of(Z),
          [Y, J] = this.getXmlnsAttribute(A, B);
        if (J) I.addAttribute(Y, J);
        for (let [W, X] of A.structIterator()) {
          let V = Q[W];
          if (V != null) {
            if (X.getMergedTraits().xmlAttribute) {
              I.addAttribute(X.getMergedTraits().xmlName ?? W, this.writeSimple(X, V));
              continue
            }
            if (X.isListSchema()) this.writeList(X, V, I, J);
            else if (X.isMapSchema()) this.writeMap(X, V, I, J);
            else if (X.isStructSchema()) I.addChildNode(this.writeStruct(X, V, J));
            else {
              let F = qS.XmlNode.of(X.getMergedTraits().xmlName ?? X.getMemberName());
              this.writeSimpleInto(X, V, F, J), I.addChildNode(F)
            }
          }
        }
        return I
      }
      writeList(A, Q, B, G) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${A.getName(!0)}`);
        let Z = A.getMergedTraits(),
          I = A.getValueSchema(),
          Y = I.getMergedTraits(),
          J = !!Y.sparse,
          W = !!Z.xmlFlattened,
          [X, V] = this.getXmlnsAttribute(A, G),
          F = Z3((K, D) => {
            if (I.isListSchema()) this.writeList(I, Array.isArray(D) ? D : [D], K, V);
            else if (I.isMapSchema()) this.writeMap(I, D, K, V);
            else if (I.isStructSchema()) {
              let H = this.writeStruct(I, D, V);
              K.addChildNode(H.withName(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member"))
            } else {
              let H = qS.XmlNode.of(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member");
              this.writeSimpleInto(I, D, H, V), K.addChildNode(H)
            }
          }, "writeItem");
        if (W) {
          for (let K of Q)
            if (J || K != null) F(B, K)
        } else {
          let K = qS.XmlNode.of(Z.xmlName ?? A.getMemberName());
          if (V) K.addAttribute(X, V);
          for (let D of Q)
            if (J || D != null) F(K, D);
          B.addChildNode(K)
        }
      }
      writeMap(A, Q, B, G, Z = !1) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${A.getName(!0)}`);
        let I = A.getMergedTraits(),
          Y = A.getKeySchema(),
          W = Y.getMergedTraits().xmlName ?? "key",
          X = A.getValueSchema(),
          V = X.getMergedTraits(),
          F = V.xmlName ?? "value",
          K = !!V.sparse,
          D = !!I.xmlFlattened,
          [H, C] = this.getXmlnsAttribute(A, G),
          E = Z3((U, q, w) => {
            let N = qS.XmlNode.of(W, q),
              [R, T] = this.getXmlnsAttribute(Y, C);
            if (T) N.addAttribute(R, T);
            U.addChildNode(N);
            let y = qS.XmlNode.of(F);
            if (X.isListSchema()) this.writeList(X, w, y, C);
            else if (X.isMapSchema()) this.writeMap(X, w, y, C, !0);
            else if (X.isStructSchema()) y = this.writeStruct(X, w, C);
            else this.writeSimpleInto(X, w, y, C);
            U.addChildNode(y)
          }, "addKeyValue");
        if (D) {
          for (let [U, q] of Object.entries(Q))
            if (K || q != null) {
              let w = qS.XmlNode.of(I.xmlName ?? A.getMemberName());
              E(w, U, q), B.addChildNode(w)
            }
        } else {
          let U;
          if (!Z) {
            if (U = qS.XmlNode.of(I.xmlName ?? A.getMemberName()), C) U.addAttribute(H, C);
            B.addChildNode(U)
          }
          for (let [q, w] of Object.entries(Q))
            if (K || w != null) {
              let N = qS.XmlNode.of("entry");
              E(N, q, w), (Z ? B : U).addChildNode(N)
            }
        }
      }
      writeSimple(A, Q) {
        if (Q === null) throw Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
        let B = hr.NormalizedSchema.of(A),
          G = null;
        if (Q && typeof Q === "object")
          if (B.isBlobSchema()) G = (this.serdeContext?.base64Encoder ?? B9Q.toBase64)(Q);
          else if (B.isTimestampSchema() && Q instanceof Date) {
          let Z = this.settings.timestampFormat;
          switch (Z.useTrait ? B.getSchema() === hr.SCHEMA.TIMESTAMP_DEFAULT ? Z.default : B.getSchema() ?? Z.default : Z.default) {
            case hr.SCHEMA.TIMESTAMP_DATE_TIME:
              G = Q.toISOString().replace(".000Z", "Z");
              break;
            case hr.SCHEMA.TIMESTAMP_HTTP_DATE:
              G = (0, Q9Q.dateToUtcString)(Q);
              break;
            case hr.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              G = String(Q.getTime() / 1000);
              break;
            default:
              console.warn("Missing timestamp format, using http date", Q), G = (0, Q9Q.dateToUtcString)(Q);
              break
          }
        } else if (B.isBigDecimalSchema() && Q) {
          if (Q instanceof PL4.NumericValue) return Q.string;
          return String(Q)
        } else if (B.isMapSchema() || B.isListSchema()) throw Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
        else throw Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${B.getName(!0)}`);
        if (B.isStringSchema() || B.isBooleanSchema() || B.isNumericSchema() || B.isBigIntegerSchema() || B.isBigDecimalSchema()) G = String(Q);
        if (G === null) throw Error(`Unhandled schema-value pair ${B.getName(!0)}=${Q}`);
        return G
      }
      writeSimpleInto(A, Q, B, G) {
        let Z = this.writeSimple(A, Q),
          I = hr.NormalizedSchema.of(A),
          Y = new qS.XmlText(Z),
          [J, W] = this.getXmlnsAttribute(I, G);
        if (W) B.addAttribute(J, W);
        B.addChildNode(Y)
      }
      getXmlnsAttribute(A, Q) {
        let B = A.getMergedTraits(),
          [G, Z] = B.xmlNamespace ?? [];
        if (Z && Z !== Q) return [G ? `xmlns:${G}` : "xmlns", Z];
        return [void 0, void 0]
      }
    },
    K9Q = class extends gr {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        Z3(this, "XmlCodec")
      }
      createSerializer() {
        let A = new F9Q(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new d$1(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    jL4 = class extends f$1.HttpBindingProtocol {
      static {
        Z3(this, "AwsRestXmlProtocol")
      }
      codec;
      serializer;
      deserializer;
      constructor(A) {
        super(A);
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: eDA.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !0,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace
        };
        this.codec = new K9Q(Q), this.serializer = new f$1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new f$1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getPayloadCodec() {
        return this.codec
      }
      getShapeId() {
        return "aws.protocols#restXml"
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = eDA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (G.path = String(G.path).split("/").filter((Y) => {
            return Y !== "{Bucket}"
          }).join("/") || "/", !G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/xml"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/xml"
          }
        }
        if (G.headers["content-type"] === "application/xml") {
          if (typeof G.body === "string") G.body = '<?xml version="1.0" encoding="UTF-8"?>' + G.body
        }
        if (G.body) try {
          G.headers["content-length"] = String((0, ML4.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        return super.deserializeResponse(A, Q, B)
      }
      async handleError(A, Q, B, G, Z) {
        let I = V9Q(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = eDA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = eDA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = eDA.NormalizedSchema.of(X),
          F = G.Error?.message ?? G.Error?.Message ?? G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().xmlName ?? H,
            U = G.Error?.[E] ?? G[E];
          D[H] = this.codec.createDeserializer().readSchema(C, U)
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    }
})
// @from(Start 2596965, End 2597162)
MF = z((AHA) => {
  Object.defineProperty(AHA, "__esModule", {
    value: !0
  });
  var c$1 = yr();
  c$1.__exportStar(QL(), AHA);
  c$1.__exportStar($$1(), AHA);
  c$1.__exportStar(H9Q(), AHA)
})
// @from(Start 2597168, End 2602822)
r4A = z((vE7, R9Q) => {
  var {
    defineProperty: qhA,
    getOwnPropertyDescriptor: SL4,
    getOwnPropertyNames: _L4
  } = Object, kL4 = Object.prototype.hasOwnProperty, Lv = (A, Q) => qhA(A, "name", {
    value: Q,
    configurable: !0
  }), yL4 = (A, Q) => {
    for (var B in Q) qhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, xL4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of _L4(Q))
        if (!kL4.call(A, Z) && Z !== B) qhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = SL4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, vL4 = (A) => xL4(qhA({}, "__esModule", {
    value: !0
  }), A), U9Q = {};
  yL4(U9Q, {
    DEFAULT_UA_APP_ID: () => $9Q,
    getUserAgentMiddlewareOptions: () => O9Q,
    getUserAgentPlugin: () => cL4,
    resolveUserAgentConfig: () => q9Q,
    userAgentMiddleware: () => M9Q
  });
  R9Q.exports = vL4(U9Q);
  var bL4 = iB(),
    $9Q = void 0;

  function w9Q(A) {
    if (A === void 0) return !0;
    return typeof A === "string" && A.length <= 50
  }
  Lv(w9Q, "isValidUserAgentAppId");

  function q9Q(A) {
    let Q = (0, bL4.normalizeProvider)(A.userAgentAppId ?? $9Q),
      {
        customUserAgent: B
      } = A;
    return Object.assign(A, {
      customUserAgent: typeof B === "string" ? [
        [B]
      ] : B,
      userAgentAppId: Lv(async () => {
        let G = await Q();
        if (!w9Q(G)) {
          let Z = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console : A.logger;
          if (typeof G !== "string") Z?.warn("userAgentAppId must be a string or undefined.");
          else if (G.length > 50) Z?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.")
        }
        return G
      }, "userAgentAppId")
    })
  }
  Lv(q9Q, "resolveUserAgentConfig");
  var fL4 = p4A(),
    hL4 = nC(),
    NS = MF(),
    gL4 = /\d{12}\.ddb/;
  async function N9Q(A, Q, B) {
    if (B.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor")(0, NS.setFeature)(A, "PROTOCOL_RPC_V2_CBOR", "M");
    if (typeof Q.retryStrategy === "function") {
      let I = await Q.retryStrategy();
      if (typeof I.acquireInitialRetryToken === "function")
        if (I.constructor?.name?.includes("Adaptive"))(0, NS.setFeature)(A, "RETRY_MODE_ADAPTIVE", "F");
        else(0, NS.setFeature)(A, "RETRY_MODE_STANDARD", "E");
      else(0, NS.setFeature)(A, "RETRY_MODE_LEGACY", "D")
    }
    if (typeof Q.accountIdEndpointMode === "function") {
      let I = A.endpointV2;
      if (String(I?.url?.hostname).match(gL4))(0, NS.setFeature)(A, "ACCOUNT_ID_ENDPOINT", "O");
      switch (await Q.accountIdEndpointMode?.()) {
        case "disabled":
          (0, NS.setFeature)(A, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, NS.setFeature)(A, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, NS.setFeature)(A, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break
      }
    }
    let Z = A.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (Z?.$source) {
      let I = Z;
      if (I.accountId)(0, NS.setFeature)(A, "RESOLVED_ACCOUNT_ID", "T");
      for (let [Y, J] of Object.entries(I.$source ?? {}))(0, NS.setFeature)(A, Y, J)
    }
  }
  Lv(N9Q, "checkFeatures");
  var C9Q = "user-agent",
    p$1 = "x-amz-user-agent",
    E9Q = " ",
    l$1 = "/",
    uL4 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
    mL4 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
    z9Q = "-",
    dL4 = 1024;

  function L9Q(A) {
    let Q = "";
    for (let B in A) {
      let G = A[B];
      if (Q.length + G.length + 1 <= dL4) {
        if (Q.length) Q += "," + G;
        else Q += G;
        continue
      }
      break
    }
    return Q
  }
  Lv(L9Q, "encodeFeatures");
  var M9Q = Lv((A) => (Q, B) => async (G) => {
      let {
        request: Z
      } = G;
      if (!hL4.HttpRequest.isInstance(Z)) return Q(G);
      let {
        headers: I
      } = Z, Y = B?.userAgent?.map(whA) || [], J = (await A.defaultUserAgentProvider()).map(whA);
      await N9Q(B, A, G);
      let W = B;
      J.push(`m/${L9Q(Object.assign({},B.__smithy_context?.features,W.__aws_sdk_context?.features))}`);
      let X = A?.customUserAgent?.map(whA) || [],
        V = await A.userAgentAppId();
      if (V) J.push(whA([`app/${V}`]));
      let F = (0, fL4.getUserAgentPrefix)(),
        K = (F ? [F] : []).concat([...J, ...Y, ...X]).join(E9Q),
        D = [...J.filter((H) => H.startsWith("aws-sdk-")), ...X].join(E9Q);
      if (A.runtime !== "browser") {
        if (D) I[p$1] = I[p$1] ? `${I[C9Q]} ${D}` : D;
        I[C9Q] = K
      } else I[p$1] = K;
      return Q({
        ...G,
        request: Z
      })
    }, "userAgentMiddleware"),
    whA = Lv((A) => {
      let Q = A[0].split(l$1).map((Y) => Y.replace(uL4, z9Q)).join(l$1),
        B = A[1]?.replace(mL4, z9Q),
        G = Q.indexOf(l$1),
        Z = Q.substring(0, G),
        I = Q.substring(G + 1);
      if (Z === "api") I = I.toLowerCase();
      return [Z, I, B].filter((Y) => Y && Y.length > 0).reduce((Y, J, W) => {
        switch (W) {
          case 0:
            return J;
          case 1:
            return `${Y}/${J}`;
          default:
            return `${Y}#${J}`
        }
      }, "")
    }, "escapeUserAgent"),
    O9Q = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: !0
    },
    cL4 = Lv((A) => ({
      applyToStack: Lv((Q) => {
        Q.add(M9Q(A), O9Q)
      }, "applyToStack")
    }), "getUserAgentPlugin")
})
// @from(Start 2602828, End 2604266)
_9Q = z((bE7, S9Q) => {
  var {
    defineProperty: NhA,
    getOwnPropertyDescriptor: pL4,
    getOwnPropertyNames: lL4
  } = Object, iL4 = Object.prototype.hasOwnProperty, T9Q = (A, Q) => NhA(A, "name", {
    value: Q,
    configurable: !0
  }), nL4 = (A, Q) => {
    for (var B in Q) NhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, aL4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of lL4(Q))
        if (!iL4.call(A, Z) && Z !== B) NhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = pL4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, sL4 = (A) => aL4(NhA({}, "__esModule", {
    value: !0
  }), A), P9Q = {};
  nL4(P9Q, {
    SelectorType: () => j9Q,
    booleanSelector: () => rL4,
    numberSelector: () => oL4
  });
  S9Q.exports = sL4(P9Q);
  var rL4 = T9Q((A, Q, B) => {
      if (!(Q in A)) return;
      if (A[Q] === "true") return !0;
      if (A[Q] === "false") return !1;
      throw Error(`Cannot load ${B} "${Q}". Expected "true" or "false", got ${A[Q]}.`)
    }, "booleanSelector"),
    oL4 = T9Q((A, Q, B) => {
      if (!(Q in A)) return;
      let G = parseInt(A[Q], 10);
      if (Number.isNaN(G)) throw TypeError(`Cannot load ${B} '${Q}'. Expected number, got '${A[Q]}'.`);
      return G
    }, "numberSelector"),
    j9Q = ((A) => {
      return A.ENV = "env", A.CONFIG = "shared config entry", A
    })(j9Q || {})
})
// @from(Start 2604272, End 2611016)
f8 = z((fE7, d9Q) => {
  var {
    defineProperty: MhA,
    getOwnPropertyDescriptor: tL4,
    getOwnPropertyNames: eL4
  } = Object, AM4 = Object.prototype.hasOwnProperty, mR = (A, Q) => MhA(A, "name", {
    value: Q,
    configurable: !0
  }), QM4 = (A, Q) => {
    for (var B in Q) MhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, BM4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of eL4(Q))
        if (!AM4.call(A, Z) && Z !== B) MhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = tL4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, GM4 = (A) => BM4(MhA({}, "__esModule", {
    value: !0
  }), A), x9Q = {};
  QM4(x9Q, {
    CONFIG_USE_DUALSTACK_ENDPOINT: () => b9Q,
    CONFIG_USE_FIPS_ENDPOINT: () => h9Q,
    DEFAULT_USE_DUALSTACK_ENDPOINT: () => ZM4,
    DEFAULT_USE_FIPS_ENDPOINT: () => YM4,
    ENV_USE_DUALSTACK_ENDPOINT: () => v9Q,
    ENV_USE_FIPS_ENDPOINT: () => f9Q,
    NODE_REGION_CONFIG_FILE_OPTIONS: () => KM4,
    NODE_REGION_CONFIG_OPTIONS: () => FM4,
    NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: () => IM4,
    NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: () => JM4,
    REGION_ENV_NAME: () => g9Q,
    REGION_INI_NAME: () => u9Q,
    getRegionInfo: () => zM4,
    resolveCustomEndpointsConfig: () => WM4,
    resolveEndpointsConfig: () => VM4,
    resolveRegionConfig: () => DM4
  });
  d9Q.exports = GM4(x9Q);
  var Cd = _9Q(),
    v9Q = "AWS_USE_DUALSTACK_ENDPOINT",
    b9Q = "use_dualstack_endpoint",
    ZM4 = !1,
    IM4 = {
      environmentVariableSelector: (A) => (0, Cd.booleanSelector)(A, v9Q, Cd.SelectorType.ENV),
      configFileSelector: (A) => (0, Cd.booleanSelector)(A, b9Q, Cd.SelectorType.CONFIG),
      default: !1
    },
    f9Q = "AWS_USE_FIPS_ENDPOINT",
    h9Q = "use_fips_endpoint",
    YM4 = !1,
    JM4 = {
      environmentVariableSelector: (A) => (0, Cd.booleanSelector)(A, f9Q, Cd.SelectorType.ENV),
      configFileSelector: (A) => (0, Cd.booleanSelector)(A, h9Q, Cd.SelectorType.CONFIG),
      default: !1
    },
    LhA = w7(),
    WM4 = mR((A) => {
      let {
        tls: Q,
        endpoint: B,
        urlParser: G,
        useDualstackEndpoint: Z
      } = A;
      return Object.assign(A, {
        tls: Q ?? !0,
        endpoint: (0, LhA.normalizeProvider)(typeof B === "string" ? G(B) : B),
        isCustomEndpoint: !0,
        useDualstackEndpoint: (0, LhA.normalizeProvider)(Z ?? !1)
      })
    }, "resolveCustomEndpointsConfig"),
    XM4 = mR(async (A) => {
      let {
        tls: Q = !0
      } = A, B = await A.region();
      if (!new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/).test(B)) throw Error("Invalid region in client config");
      let Z = await A.useDualstackEndpoint(),
        I = await A.useFipsEndpoint(),
        {
          hostname: Y
        } = await A.regionInfoProvider(B, {
          useDualstackEndpoint: Z,
          useFipsEndpoint: I
        }) ?? {};
      if (!Y) throw Error("Cannot resolve hostname from client config");
      return A.urlParser(`${Q?"https:":"http:"}//${Y}`)
    }, "getEndpointFromRegion"),
    VM4 = mR((A) => {
      let Q = (0, LhA.normalizeProvider)(A.useDualstackEndpoint ?? !1),
        {
          endpoint: B,
          useFipsEndpoint: G,
          urlParser: Z,
          tls: I
        } = A;
      return Object.assign(A, {
        tls: I ?? !0,
        endpoint: B ? (0, LhA.normalizeProvider)(typeof B === "string" ? Z(B) : B) : () => XM4({
          ...A,
          useDualstackEndpoint: Q,
          useFipsEndpoint: G
        }),
        isCustomEndpoint: !!B,
        useDualstackEndpoint: Q
      })
    }, "resolveEndpointsConfig"),
    g9Q = "AWS_REGION",
    u9Q = "region",
    FM4 = {
      environmentVariableSelector: (A) => A[g9Q],
      configFileSelector: (A) => A[u9Q],
      default: () => {
        throw Error("Region is missing")
      }
    },
    KM4 = {
      preferredFile: "credentials"
    },
    m9Q = mR((A) => typeof A === "string" && (A.startsWith("fips-") || A.endsWith("-fips")), "isFipsRegion"),
    k9Q = mR((A) => m9Q(A) ? ["fips-aws-global", "aws-fips"].includes(A) ? "us-east-1" : A.replace(/fips-(dkr-|prod-)?|-fips/, "") : A, "getRealRegion"),
    DM4 = mR((A) => {
      let {
        region: Q,
        useFipsEndpoint: B
      } = A;
      if (!Q) throw Error("Region is missing");
      return Object.assign(A, {
        region: async () => {
          if (typeof Q === "string") return k9Q(Q);
          let G = await Q();
          return k9Q(G)
        },
        useFipsEndpoint: async () => {
          let G = typeof Q === "string" ? Q : await Q();
          if (m9Q(G)) return !0;
          return typeof B !== "function" ? Promise.resolve(!!B) : B()
        }
      })
    }, "resolveRegionConfig"),
    y9Q = mR((A = [], {
      useFipsEndpoint: Q,
      useDualstackEndpoint: B
    }) => A.find(({
      tags: G
    }) => Q === G.includes("fips") && B === G.includes("dualstack"))?.hostname, "getHostnameFromVariants"),
    HM4 = mR((A, {
      regionHostname: Q,
      partitionHostname: B
    }) => Q ? Q : B ? B.replace("{region}", A) : void 0, "getResolvedHostname"),
    CM4 = mR((A, {
      partitionHash: Q
    }) => Object.keys(Q || {}).find((B) => Q[B].regions.includes(A)) ?? "aws", "getResolvedPartition"),
    EM4 = mR((A, {
      signingRegion: Q,
      regionRegex: B,
      useFipsEndpoint: G
    }) => {
      if (Q) return Q;
      else if (G) {
        let Z = B.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\."),
          I = A.match(Z);
        if (I) return I[0].slice(1, -1)
      }
    }, "getResolvedSigningRegion"),
    zM4 = mR((A, {
      useFipsEndpoint: Q = !1,
      useDualstackEndpoint: B = !1,
      signingService: G,
      regionHash: Z,
      partitionHash: I
    }) => {
      let Y = CM4(A, {
          partitionHash: I
        }),
        J = A in Z ? A : I[Y]?.endpoint ?? A,
        W = {
          useFipsEndpoint: Q,
          useDualstackEndpoint: B
        },
        X = y9Q(Z[J]?.variants, W),
        V = y9Q(I[Y]?.variants, W),
        F = HM4(J, {
          regionHostname: X,
          partitionHostname: V
        });
      if (F === void 0) throw Error(`Endpoint resolution failed for: ${{resolvedRegion:J,useFipsEndpoint:Q,useDualstackEndpoint:B}}`);
      let K = EM4(F, {
        signingRegion: Z[J]?.signingRegion,
        regionRegex: I[Y].regionRegex,
        useFipsEndpoint: Q
      });
      return {
        partition: Y,
        signingService: G,
        hostname: F,
        ...K && {
          signingRegion: K
        },
        ...Z[J]?.signingService && {
          signingService: Z[J].signingService
        }
      }
    }, "getRegionInfo")
})
// @from(Start 2611022, End 2613805)
t9Q = z((hE7, o9Q) => {
  var {
    defineProperty: OhA,
    getOwnPropertyDescriptor: UM4,
    getOwnPropertyNames: $M4
  } = Object, wM4 = Object.prototype.hasOwnProperty, RhA = (A, Q) => OhA(A, "name", {
    value: Q,
    configurable: !0
  }), qM4 = (A, Q) => {
    for (var B in Q) OhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, NM4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of $M4(Q))
        if (!wM4.call(A, Z) && Z !== B) OhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = UM4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, LM4 = (A) => NM4(OhA({}, "__esModule", {
    value: !0
  }), A), c9Q = {};
  qM4(c9Q, {
    AlgorithmId: () => n9Q,
    EndpointURLScheme: () => i9Q,
    FieldPosition: () => a9Q,
    HttpApiKeyAuthLocation: () => l9Q,
    HttpAuthLocation: () => p9Q,
    IniSectionType: () => s9Q,
    RequestHandlerProtocol: () => r9Q,
    SMITHY_CONTEXT_KEY: () => PM4,
    getDefaultClientConfiguration: () => RM4,
    resolveDefaultRuntimeConfig: () => TM4
  });
  o9Q.exports = LM4(c9Q);
  var p9Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(p9Q || {}),
    l9Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(l9Q || {}),
    i9Q = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(i9Q || {}),
    n9Q = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(n9Q || {}),
    MM4 = RhA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    OM4 = RhA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    RM4 = RhA((A) => {
      return MM4(A)
    }, "getDefaultClientConfiguration"),
    TM4 = RhA((A) => {
      return OM4(A)
    }, "resolveDefaultRuntimeConfig"),
    a9Q = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(a9Q || {}),
    PM4 = "__smithy_context",
    s9Q = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(s9Q || {}),
    r9Q = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(r9Q || {})
})
// @from(Start 2613811, End 2618318)
Z4Q = z((gE7, G4Q) => {
  var {
    defineProperty: ThA,
    getOwnPropertyDescriptor: jM4,
    getOwnPropertyNames: SM4
  } = Object, _M4 = Object.prototype.hasOwnProperty, Ed = (A, Q) => ThA(A, "name", {
    value: Q,
    configurable: !0
  }), kM4 = (A, Q) => {
    for (var B in Q) ThA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, yM4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of SM4(Q))
        if (!_M4.call(A, Z) && Z !== B) ThA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = jM4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, xM4 = (A) => yM4(ThA({}, "__esModule", {
    value: !0
  }), A), e9Q = {};
  kM4(e9Q, {
    Field: () => fM4,
    Fields: () => hM4,
    HttpRequest: () => gM4,
    HttpResponse: () => uM4,
    IHttpRequest: () => A4Q.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => vM4,
    isValidHostname: () => B4Q,
    resolveHttpHandlerRuntimeConfig: () => bM4
  });
  G4Q.exports = xM4(e9Q);
  var vM4 = Ed((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    bM4 = Ed((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    A4Q = t9Q(),
    fM4 = class {
      static {
        Ed(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = A4Q.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    hM4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Ed(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    gM4 = class A {
      static {
        Ed(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = Q4Q(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function Q4Q(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Ed(Q4Q, "cloneQuery");
  var uM4 = class {
    static {
      Ed(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function B4Q(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Ed(B4Q, "isValidHostname")
})
// @from(Start 2618324, End 2620078)
LX = z((cE7, X4Q) => {
  var {
    defineProperty: PhA,
    getOwnPropertyDescriptor: mM4,
    getOwnPropertyNames: dM4
  } = Object, cM4 = Object.prototype.hasOwnProperty, Y4Q = (A, Q) => PhA(A, "name", {
    value: Q,
    configurable: !0
  }), pM4 = (A, Q) => {
    for (var B in Q) PhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, lM4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of dM4(Q))
        if (!cM4.call(A, Z) && Z !== B) PhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = mM4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, iM4 = (A) => lM4(PhA({}, "__esModule", {
    value: !0
  }), A), J4Q = {};
  pM4(J4Q, {
    contentLengthMiddleware: () => i$1,
    contentLengthMiddlewareOptions: () => W4Q,
    getContentLengthPlugin: () => aM4
  });
  X4Q.exports = iM4(J4Q);
  var nM4 = Z4Q(),
    I4Q = "content-length";

  function i$1(A) {
    return (Q) => async (B) => {
      let G = B.request;
      if (nM4.HttpRequest.isInstance(G)) {
        let {
          body: Z,
          headers: I
        } = G;
        if (Z && Object.keys(I).map((Y) => Y.toLowerCase()).indexOf(I4Q) === -1) try {
          let Y = A(Z);
          G.headers = {
            ...G.headers,
            [I4Q]: String(Y)
          }
        } catch (Y) {}
      }
      return Q({
        ...B,
        request: G
      })
    }
  }
  Y4Q(i$1, "contentLengthMiddleware");
  var W4Q = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: !0
    },
    aM4 = Y4Q((A) => ({
      applyToStack: (Q) => {
        Q.add(i$1(A.bodyLengthChecker), W4Q)
      }
    }), "getContentLengthPlugin")
})
// @from(Start 2620084, End 2620722)
o4A = z((V4Q) => {
  Object.defineProperty(V4Q, "__esModule", {
    value: !0
  });
  V4Q.getHomeDir = void 0;
  var sM4 = UA("os"),
    rM4 = UA("path"),
    n$1 = {},
    oM4 = () => {
      if (process && process.geteuid) return `${process.geteuid()}`;
      return "DEFAULT"
    },
    tM4 = () => {
      let {
        HOME: A,
        USERPROFILE: Q,
        HOMEPATH: B,
        HOMEDRIVE: G = `C:${rM4.sep}`
      } = process.env;
      if (A) return A;
      if (Q) return Q;
      if (B) return `${G}${B}`;
      let Z = oM4();
      if (!n$1[Z]) n$1[Z] = (0, sM4.homedir)();
      return n$1[Z]
    };
  V4Q.getHomeDir = tM4
})
// @from(Start 2620728, End 2621127)
a$1 = z((K4Q) => {
  Object.defineProperty(K4Q, "__esModule", {
    value: !0
  });
  K4Q.getSSOTokenFilepath = void 0;
  var eM4 = UA("crypto"),
    AO4 = UA("path"),
    QO4 = o4A(),
    BO4 = (A) => {
      let B = (0, eM4.createHash)("sha1").update(A).digest("hex");
      return (0, AO4.join)((0, QO4.getHomeDir)(), ".aws", "sso", "cache", `${B}.json`)
    };
  K4Q.getSSOTokenFilepath = BO4
})
// @from(Start 2621133, End 2621514)
E4Q = z((H4Q) => {
  Object.defineProperty(H4Q, "__esModule", {
    value: !0
  });
  H4Q.getSSOTokenFromFile = void 0;
  var GO4 = UA("fs"),
    ZO4 = a$1(),
    {
      readFile: IO4
    } = GO4.promises,
    YO4 = async (A) => {
      let Q = (0, ZO4.getSSOTokenFilepath)(A),
        B = await IO4(Q, "utf8");
      return JSON.parse(B)
    };
  H4Q.getSSOTokenFromFile = YO4
})
// @from(Start 2621520, End 2624303)
R4Q = z((nE7, O4Q) => {
  var {
    defineProperty: jhA,
    getOwnPropertyDescriptor: JO4,
    getOwnPropertyNames: WO4
  } = Object, XO4 = Object.prototype.hasOwnProperty, ShA = (A, Q) => jhA(A, "name", {
    value: Q,
    configurable: !0
  }), VO4 = (A, Q) => {
    for (var B in Q) jhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, FO4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of WO4(Q))
        if (!XO4.call(A, Z) && Z !== B) jhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = JO4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, KO4 = (A) => FO4(jhA({}, "__esModule", {
    value: !0
  }), A), z4Q = {};
  VO4(z4Q, {
    AlgorithmId: () => q4Q,
    EndpointURLScheme: () => w4Q,
    FieldPosition: () => N4Q,
    HttpApiKeyAuthLocation: () => $4Q,
    HttpAuthLocation: () => U4Q,
    IniSectionType: () => L4Q,
    RequestHandlerProtocol: () => M4Q,
    SMITHY_CONTEXT_KEY: () => zO4,
    getDefaultClientConfiguration: () => CO4,
    resolveDefaultRuntimeConfig: () => EO4
  });
  O4Q.exports = KO4(z4Q);
  var U4Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(U4Q || {}),
    $4Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })($4Q || {}),
    w4Q = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(w4Q || {}),
    q4Q = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(q4Q || {}),
    DO4 = ShA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    HO4 = ShA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    CO4 = ShA((A) => {
      return DO4(A)
    }, "getDefaultClientConfiguration"),
    EO4 = ShA((A) => {
      return HO4(A)
    }, "resolveDefaultRuntimeConfig"),
    N4Q = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(N4Q || {}),
    zO4 = "__smithy_context",
    L4Q = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(L4Q || {}),
    M4Q = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(M4Q || {})
})
// @from(Start 2624309, End 2624677)
r$1 = z((T4Q) => {
  Object.defineProperty(T4Q, "__esModule", {
    value: !0
  });
  T4Q.slurpFile = void 0;
  var UO4 = UA("fs"),
    {
      readFile: $O4
    } = UO4.promises,
    s$1 = {},
    wO4 = (A, Q) => {
      if (!s$1[A] || (Q === null || Q === void 0 ? void 0 : Q.ignoreCache)) s$1[A] = $O4(A, "utf8");
      return s$1[A]
    };
  T4Q.slurpFile = wO4
})
// @from(Start 2624683, End 2629436)
SG = z((sE7, BHA) => {
  var {
    defineProperty: yhA,
    getOwnPropertyDescriptor: qO4,
    getOwnPropertyNames: NO4
  } = Object, LO4 = Object.prototype.hasOwnProperty, GL = (A, Q) => yhA(A, "name", {
    value: Q,
    configurable: !0
  }), MO4 = (A, Q) => {
    for (var B in Q) yhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, o$1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of NO4(Q))
        if (!LO4.call(A, Z) && Z !== B) yhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qO4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, e$1 = (A, Q, B) => (o$1(A, Q, "default"), B && o$1(B, Q, "default")), OO4 = (A) => o$1(yhA({}, "__esModule", {
    value: !0
  }), A), QHA = {};
  MO4(QHA, {
    CONFIG_PREFIX_SEPARATOR: () => ur,
    DEFAULT_PROFILE: () => k4Q,
    ENV_PROFILE: () => _4Q,
    getProfileName: () => RO4,
    loadSharedConfigFiles: () => x4Q,
    loadSsoSessionData: () => gO4,
    parseKnownFiles: () => mO4
  });
  BHA.exports = OO4(QHA);
  e$1(QHA, o4A(), BHA.exports);
  var _4Q = "AWS_PROFILE",
    k4Q = "default",
    RO4 = GL((A) => A.profile || process.env[_4Q] || k4Q, "getProfileName");
  e$1(QHA, a$1(), BHA.exports);
  e$1(QHA, E4Q(), BHA.exports);
  var _hA = R4Q(),
    TO4 = GL((A) => Object.entries(A).filter(([Q]) => {
      let B = Q.indexOf(ur);
      if (B === -1) return !1;
      return Object.values(_hA.IniSectionType).includes(Q.substring(0, B))
    }).reduce((Q, [B, G]) => {
      let Z = B.indexOf(ur),
        I = B.substring(0, Z) === _hA.IniSectionType.PROFILE ? B.substring(Z + 1) : B;
      return Q[I] = G, Q
    }, {
      ...A.default && {
        default: A.default
      }
    }), "getConfigData"),
    khA = UA("path"),
    PO4 = o4A(),
    jO4 = "AWS_CONFIG_FILE",
    y4Q = GL(() => process.env[jO4] || (0, khA.join)((0, PO4.getHomeDir)(), ".aws", "config"), "getConfigFilepath"),
    SO4 = o4A(),
    _O4 = "AWS_SHARED_CREDENTIALS_FILE",
    kO4 = GL(() => process.env[_O4] || (0, khA.join)((0, SO4.getHomeDir)(), ".aws", "credentials"), "getCredentialsFilepath"),
    yO4 = o4A(),
    xO4 = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/,
    vO4 = ["__proto__", "profile __proto__"],
    t$1 = GL((A) => {
      let Q = {},
        B, G;
      for (let Z of A.split(/\r?\n/)) {
        let I = Z.split(/(^|\s)[;#]/)[0].trim();
        if (I[0] === "[" && I[I.length - 1] === "]") {
          B = void 0, G = void 0;
          let J = I.substring(1, I.length - 1),
            W = xO4.exec(J);
          if (W) {
            let [, X, , V] = W;
            if (Object.values(_hA.IniSectionType).includes(X)) B = [X, V].join(ur)
          } else B = J;
          if (vO4.includes(J)) throw Error(`Found invalid profile name "${J}"`)
        } else if (B) {
          let J = I.indexOf("=");
          if (![0, -1].includes(J)) {
            let [W, X] = [I.substring(0, J).trim(), I.substring(J + 1).trim()];
            if (X === "") G = W;
            else {
              if (G && Z.trimStart() === Z) G = void 0;
              Q[B] = Q[B] || {};
              let V = G ? [G, W].join(ur) : W;
              Q[B][V] = X
            }
          }
        }
      }
      return Q
    }, "parseIni"),
    j4Q = r$1(),
    S4Q = GL(() => ({}), "swallowError"),
    ur = ".",
    x4Q = GL(async (A = {}) => {
      let {
        filepath: Q = kO4(),
        configFilepath: B = y4Q()
      } = A, G = (0, yO4.getHomeDir)(), Z = "~/", I = Q;
      if (Q.startsWith("~/")) I = (0, khA.join)(G, Q.slice(2));
      let Y = B;
      if (B.startsWith("~/")) Y = (0, khA.join)(G, B.slice(2));
      let J = await Promise.all([(0, j4Q.slurpFile)(Y, {
        ignoreCache: A.ignoreCache
      }).then(t$1).then(TO4).catch(S4Q), (0, j4Q.slurpFile)(I, {
        ignoreCache: A.ignoreCache
      }).then(t$1).catch(S4Q)]);
      return {
        configFile: J[0],
        credentialsFile: J[1]
      }
    }, "loadSharedConfigFiles"),
    bO4 = GL((A) => Object.entries(A).filter(([Q]) => Q.startsWith(_hA.IniSectionType.SSO_SESSION + ur)).reduce((Q, [B, G]) => ({
      ...Q,
      [B.substring(B.indexOf(ur) + 1)]: G
    }), {}), "getSsoSessionData"),
    fO4 = r$1(),
    hO4 = GL(() => ({}), "swallowError"),
    gO4 = GL(async (A = {}) => (0, fO4.slurpFile)(A.configFilepath ?? y4Q()).then(t$1).then(bO4).catch(hO4), "loadSsoSessionData"),
    uO4 = GL((...A) => {
      let Q = {};
      for (let B of A)
        for (let [G, Z] of Object.entries(B))
          if (Q[G] !== void 0) Object.assign(Q[G], Z);
          else Q[G] = Z;
      return Q
    }, "mergeConfigFiles"),
    mO4 = GL(async (A) => {
      let Q = await x4Q(A);
      return uO4(Q.configFile, Q.credentialsFile)
    }, "parseKnownFiles")
})
// @from(Start 2629442, End 2632131)
uI = z((rE7, f4Q) => {
  var {
    defineProperty: xhA,
    getOwnPropertyDescriptor: dO4,
    getOwnPropertyNames: cO4
  } = Object, pO4 = Object.prototype.hasOwnProperty, t4A = (A, Q) => xhA(A, "name", {
    value: Q,
    configurable: !0
  }), lO4 = (A, Q) => {
    for (var B in Q) xhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, iO4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of cO4(Q))
        if (!pO4.call(A, Z) && Z !== B) xhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = dO4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, nO4 = (A) => iO4(xhA({}, "__esModule", {
    value: !0
  }), A), b4Q = {};
  lO4(b4Q, {
    loadConfig: () => tO4
  });
  f4Q.exports = nO4(b4Q);
  var GHA = j2();

  function Aw1(A) {
    try {
      let Q = new Set(Array.from(A.match(/([A-Z_]){3,}/g) ?? []));
      return Q.delete("CONFIG"), Q.delete("CONFIG_PREFIX_SEPARATOR"), Q.delete("ENV"), [...Q].join(", ")
    } catch (Q) {
      return A
    }
  }
  t4A(Aw1, "getSelectorName");
  var aO4 = t4A((A, Q) => async () => {
      try {
        let B = A(process.env, Q);
        if (B === void 0) throw Error();
        return B
      } catch (B) {
        throw new GHA.CredentialsProviderError(B.message || `Not found in ENV: ${Aw1(A.toString())}`, {
          logger: Q?.logger
        })
      }
    }, "fromEnv"),
    v4Q = SG(),
    sO4 = t4A((A, {
      preferredFile: Q = "config",
      ...B
    } = {}) => async () => {
      let G = (0, v4Q.getProfileName)(B),
        {
          configFile: Z,
          credentialsFile: I
        } = await (0, v4Q.loadSharedConfigFiles)(B),
        Y = I[G] || {},
        J = Z[G] || {},
        W = Q === "config" ? {
          ...Y,
          ...J
        } : {
          ...J,
          ...Y
        };
      try {
        let V = A(W, Q === "config" ? Z : I);
        if (V === void 0) throw Error();
        return V
      } catch (X) {
        throw new GHA.CredentialsProviderError(X.message || `Not found in config files w/ profile [${G}]: ${Aw1(A.toString())}`, {
          logger: B.logger
        })
      }
    }, "fromSharedConfigFiles"),
    rO4 = t4A((A) => typeof A === "function", "isFunction"),
    oO4 = t4A((A) => rO4(A) ? async () => await A(): (0, GHA.fromStatic)(A), "fromStatic"),
    tO4 = t4A(({
      environmentVariableSelector: A,
      configFileSelector: Q,
      default: B
    }, G = {}) => {
      let {
        signingName: Z,
        logger: I
      } = G, Y = {
        signingName: Z,
        logger: I
      };
      return (0, GHA.memoize)((0, GHA.chain)(aO4(A, Y), sO4(Q, G), oO4(B)))
    }, "loadConfig")
})
// @from(Start 2632137, End 2633086)
c4Q = z((m4Q) => {
  Object.defineProperty(m4Q, "__esModule", {
    value: !0
  });
  m4Q.getEndpointUrlConfig = void 0;
  var h4Q = SG(),
    g4Q = "AWS_ENDPOINT_URL",
    u4Q = "endpoint_url",
    eO4 = (A) => ({
      environmentVariableSelector: (Q) => {
        let B = A.split(" ").map((I) => I.toUpperCase()),
          G = Q[[g4Q, ...B].join("_")];
        if (G) return G;
        let Z = Q[g4Q];
        if (Z) return Z;
        return
      },
      configFileSelector: (Q, B) => {
        if (B && Q.services) {
          let Z = B[["services", Q.services].join(h4Q.CONFIG_PREFIX_SEPARATOR)];
          if (Z) {
            let I = A.split(" ").map((J) => J.toLowerCase()),
              Y = Z[[I.join("_"), u4Q].join(h4Q.CONFIG_PREFIX_SEPARATOR)];
            if (Y) return Y
          }
        }
        let G = Q[u4Q];
        if (G) return G;
        return
      },
      default: void 0
    });
  m4Q.getEndpointUrlConfig = eO4
})
// @from(Start 2633092, End 2633399)
Qw1 = z((p4Q) => {
  Object.defineProperty(p4Q, "__esModule", {
    value: !0
  });
  p4Q.getEndpointFromConfig = void 0;
  var AR4 = uI(),
    QR4 = c4Q(),
    BR4 = async (A) => (0, AR4.loadConfig)((0, QR4.getEndpointUrlConfig)(A !== null && A !== void 0 ? A : ""))();
  p4Q.getEndpointFromConfig = BR4
})
// @from(Start 2633405, End 2634586)
s4Q = z((eE7, a4Q) => {
  var {
    defineProperty: vhA,
    getOwnPropertyDescriptor: GR4,
    getOwnPropertyNames: ZR4
  } = Object, IR4 = Object.prototype.hasOwnProperty, YR4 = (A, Q) => vhA(A, "name", {
    value: Q,
    configurable: !0
  }), JR4 = (A, Q) => {
    for (var B in Q) vhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, WR4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ZR4(Q))
        if (!IR4.call(A, Z) && Z !== B) vhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = GR4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, XR4 = (A) => WR4(vhA({}, "__esModule", {
    value: !0
  }), A), i4Q = {};
  JR4(i4Q, {
    parseQueryString: () => n4Q
  });
  a4Q.exports = XR4(i4Q);

  function n4Q(A) {
    let Q = {};
    if (A = A.replace(/^\?/, ""), A)
      for (let B of A.split("&")) {
        let [G, Z = null] = B.split("=");
        if (G = decodeURIComponent(G), Z) Z = decodeURIComponent(Z);
        if (!(G in Q)) Q[G] = Z;
        else if (Array.isArray(Q[G])) Q[G].push(Z);
        else Q[G] = [Q[G], Z]
      }
    return Q
  }
  YR4(n4Q, "parseQueryString")
})
// @from(Start 2634592, End 2635802)
NJ = z((Az7, t4Q) => {
  var {
    defineProperty: bhA,
    getOwnPropertyDescriptor: VR4,
    getOwnPropertyNames: FR4
  } = Object, KR4 = Object.prototype.hasOwnProperty, DR4 = (A, Q) => bhA(A, "name", {
    value: Q,
    configurable: !0
  }), HR4 = (A, Q) => {
    for (var B in Q) bhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, CR4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of FR4(Q))
        if (!KR4.call(A, Z) && Z !== B) bhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = VR4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ER4 = (A) => CR4(bhA({}, "__esModule", {
    value: !0
  }), A), r4Q = {};
  HR4(r4Q, {
    parseUrl: () => o4Q
  });
  t4Q.exports = ER4(r4Q);
  var zR4 = s4Q(),
    o4Q = DR4((A) => {
      if (typeof A === "string") return o4Q(new URL(A));
      let {
        hostname: Q,
        pathname: B,
        port: G,
        protocol: Z,
        search: I
      } = A, Y;
      if (I) Y = (0, zR4.parseQueryString)(I);
      return {
        hostname: Q,
        port: G ? parseInt(G) : void 0,
        protocol: Z,
        path: B,
        query: Y
      }
    }, "parseUrl")
})
// @from(Start 2635808, End 2643198)
q5 = z((Qz7, I8Q) => {
  var {
    defineProperty: hhA,
    getOwnPropertyDescriptor: UR4,
    getOwnPropertyNames: $R4
  } = Object, wR4 = Object.prototype.hasOwnProperty, ZL = (A, Q) => hhA(A, "name", {
    value: Q,
    configurable: !0
  }), qR4 = (A, Q) => {
    for (var B in Q) hhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, NR4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of $R4(Q))
        if (!wR4.call(A, Z) && Z !== B) hhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = UR4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, LR4 = (A) => NR4(hhA({}, "__esModule", {
    value: !0
  }), A), A8Q = {};
  qR4(A8Q, {
    endpointMiddleware: () => G8Q,
    endpointMiddlewareOptions: () => Z8Q,
    getEndpointFromInstructions: () => Q8Q,
    getEndpointPlugin: () => xR4,
    resolveEndpointConfig: () => bR4,
    resolveEndpointRequiredConfig: () => fR4,
    resolveParams: () => B8Q,
    toEndpointV1: () => Bw1
  });
  I8Q.exports = LR4(A8Q);
  var MR4 = ZL(async (A) => {
      let Q = A?.Bucket || "";
      if (typeof A.Bucket === "string") A.Bucket = Q.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
      if (jR4(Q)) {
        if (A.ForcePathStyle === !0) throw Error("Path-style addressing cannot be used with ARN buckets")
      } else if (!PR4(Q) || Q.indexOf(".") !== -1 && !String(A.Endpoint).startsWith("http:") || Q.toLowerCase() !== Q || Q.length < 3) A.ForcePathStyle = !0;
      if (A.DisableMultiRegionAccessPoints) A.disableMultiRegionAccessPoints = !0, A.DisableMRAP = !0;
      return A
    }, "resolveParamsForS3"),
    OR4 = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
    RR4 = /(\d+\.){3}\d+/,
    TR4 = /\.\./,
    PR4 = ZL((A) => OR4.test(A) && !RR4.test(A) && !TR4.test(A), "isDnsCompatibleBucketName"),
    jR4 = ZL((A) => {
      let [Q, B, G, , , Z] = A.split(":"), I = Q === "arn" && A.split(":").length >= 6, Y = Boolean(I && B && G && Z);
      if (I && !Y) throw Error(`Invalid ARN: ${A} was an invalid ARN.`);
      return Y
    }, "isArnBucketName"),
    SR4 = ZL((A, Q, B) => {
      let G = ZL(async () => {
        let Z = B[A] ?? B[Q];
        if (typeof Z === "function") return Z();
        return Z
      }, "configProvider");
      if (A === "credentialScope" || Q === "CredentialScope") return async () => {
        let Z = typeof B.credentials === "function" ? await B.credentials() : B.credentials;
        return Z?.credentialScope ?? Z?.CredentialScope
      };
      if (A === "accountId" || Q === "AccountId") return async () => {
        let Z = typeof B.credentials === "function" ? await B.credentials() : B.credentials;
        return Z?.accountId ?? Z?.AccountId
      };
      if (A === "endpoint" || Q === "endpoint") return async () => {
        let Z = await G();
        if (Z && typeof Z === "object") {
          if ("url" in Z) return Z.url.href;
          if ("hostname" in Z) {
            let {
              protocol: I,
              hostname: Y,
              port: J,
              path: W
            } = Z;
            return `${I}//${Y}${J?":"+J:""}${W}`
          }
        }
        return Z
      };
      return G
    }, "createConfigValueProvider"),
    _R4 = Qw1(),
    e4Q = NJ(),
    Bw1 = ZL((A) => {
      if (typeof A === "object") {
        if ("url" in A) return (0, e4Q.parseUrl)(A.url);
        return A
      }
      return (0, e4Q.parseUrl)(A)
    }, "toEndpointV1"),
    Q8Q = ZL(async (A, Q, B, G) => {
      if (!B.endpoint) {
        let Y;
        if (B.serviceConfiguredEndpoint) Y = await B.serviceConfiguredEndpoint();
        else Y = await (0, _R4.getEndpointFromConfig)(B.serviceId);
        if (Y) B.endpoint = () => Promise.resolve(Bw1(Y))
      }
      let Z = await B8Q(A, Q, B);
      if (typeof B.endpointProvider !== "function") throw Error("config.endpointProvider is not set.");
      return B.endpointProvider(Z, G)
    }, "getEndpointFromInstructions"),
    B8Q = ZL(async (A, Q, B) => {
      let G = {},
        Z = Q?.getEndpointParameterInstructions?.() || {};
      for (let [I, Y] of Object.entries(Z)) switch (Y.type) {
        case "staticContextParams":
          G[I] = Y.value;
          break;
        case "contextParams":
          G[I] = A[Y.name];
          break;
        case "clientContextParams":
        case "builtInParams":
          G[I] = await SR4(Y.name, I, B)();
          break;
        case "operationContextParams":
          G[I] = Y.get(A);
          break;
        default:
          throw Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(Y))
      }
      if (Object.keys(Z).length === 0) Object.assign(G, B);
      if (String(B.serviceId).toLowerCase() === "s3") await MR4(G);
      return G
    }, "resolveParams"),
    kR4 = iB(),
    fhA = w7(),
    G8Q = ZL(({
      config: A,
      instructions: Q
    }) => {
      return (B, G) => async (Z) => {
        if (A.endpoint)(0, kR4.setFeature)(G, "ENDPOINT_OVERRIDE", "N");
        let I = await Q8Q(Z.input, {
          getEndpointParameterInstructions() {
            return Q
          }
        }, {
          ...A
        }, G);
        G.endpointV2 = I, G.authSchemes = I.properties?.authSchemes;
        let Y = G.authSchemes?.[0];
        if (Y) {
          G.signing_region = Y.signingRegion, G.signing_service = Y.signingName;
          let W = (0, fhA.getSmithyContext)(G)?.selectedHttpAuthScheme?.httpAuthOption;
          if (W) W.signingProperties = Object.assign(W.signingProperties || {}, {
            signing_region: Y.signingRegion,
            signingRegion: Y.signingRegion,
            signing_service: Y.signingName,
            signingName: Y.signingName,
            signingRegionSet: Y.signingRegionSet
          }, Y.properties)
        }
        return B({
          ...Z
        })
      }
    }, "endpointMiddleware"),
    yR4 = GZ(),
    Z8Q = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: !0,
      relation: "before",
      toMiddleware: yR4.serializerMiddlewareOption.name
    },
    xR4 = ZL((A, Q) => ({
      applyToStack: (B) => {
        B.addRelativeTo(G8Q({
          config: A,
          instructions: Q
        }), Z8Q)
      }
    }), "getEndpointPlugin"),
    vR4 = Qw1(),
    bR4 = ZL((A) => {
      let Q = A.tls ?? !0,
        {
          endpoint: B,
          useDualstackEndpoint: G,
          useFipsEndpoint: Z
        } = A,
        I = B != null ? async () => Bw1(await (0, fhA.normalizeProvider)(B)()): void 0, J = Object.assign(A, {
          endpoint: I,
          tls: Q,
          isCustomEndpoint: !!B,
          useDualstackEndpoint: (0, fhA.normalizeProvider)(G ?? !1),
          useFipsEndpoint: (0, fhA.normalizeProvider)(Z ?? !1)
        }), W = void 0;
      return J.serviceConfiguredEndpoint = async () => {
        if (A.serviceId && !W) W = (0, vR4.getEndpointFromConfig)(A.serviceId);
        return W
      }, J
    }, "resolveEndpointConfig"),
    fR4 = ZL((A) => {
      let {
        endpoint: Q
      } = A;
      if (Q === void 0) A.endpoint = async () => {
        throw Error("@smithy/middleware-endpoint: (default endpointRuleSet) endpoint is not set - you must configure an endpoint.")
      };
      return A
    }, "resolveEndpointRequiredConfig")
})
// @from(Start 2643204, End 2645987)
Gw1 = z((Bz7, H8Q) => {
  var {
    defineProperty: ghA,
    getOwnPropertyDescriptor: hR4,
    getOwnPropertyNames: gR4
  } = Object, uR4 = Object.prototype.hasOwnProperty, uhA = (A, Q) => ghA(A, "name", {
    value: Q,
    configurable: !0
  }), mR4 = (A, Q) => {
    for (var B in Q) ghA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, dR4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gR4(Q))
        if (!uR4.call(A, Z) && Z !== B) ghA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = hR4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, cR4 = (A) => dR4(ghA({}, "__esModule", {
    value: !0
  }), A), Y8Q = {};
  mR4(Y8Q, {
    AlgorithmId: () => V8Q,
    EndpointURLScheme: () => X8Q,
    FieldPosition: () => F8Q,
    HttpApiKeyAuthLocation: () => W8Q,
    HttpAuthLocation: () => J8Q,
    IniSectionType: () => K8Q,
    RequestHandlerProtocol: () => D8Q,
    SMITHY_CONTEXT_KEY: () => aR4,
    getDefaultClientConfiguration: () => iR4,
    resolveDefaultRuntimeConfig: () => nR4
  });
  H8Q.exports = cR4(Y8Q);
  var J8Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(J8Q || {}),
    W8Q = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(W8Q || {}),
    X8Q = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(X8Q || {}),
    V8Q = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(V8Q || {}),
    pR4 = uhA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    lR4 = uhA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    iR4 = uhA((A) => {
      return pR4(A)
    }, "getDefaultClientConfiguration"),
    nR4 = uhA((A) => {
      return lR4(A)
    }, "resolveDefaultRuntimeConfig"),
    F8Q = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(F8Q || {}),
    aR4 = "__smithy_context",
    K8Q = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(K8Q || {}),
    D8Q = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(D8Q || {})
})
// @from(Start 2645993, End 2650500)
w8Q = z((Gz7, $8Q) => {
  var {
    defineProperty: mhA,
    getOwnPropertyDescriptor: sR4,
    getOwnPropertyNames: rR4
  } = Object, oR4 = Object.prototype.hasOwnProperty, zd = (A, Q) => mhA(A, "name", {
    value: Q,
    configurable: !0
  }), tR4 = (A, Q) => {
    for (var B in Q) mhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, eR4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of rR4(Q))
        if (!oR4.call(A, Z) && Z !== B) mhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = sR4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, AT4 = (A) => eR4(mhA({}, "__esModule", {
    value: !0
  }), A), C8Q = {};
  tR4(C8Q, {
    Field: () => GT4,
    Fields: () => ZT4,
    HttpRequest: () => IT4,
    HttpResponse: () => YT4,
    IHttpRequest: () => E8Q.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => QT4,
    isValidHostname: () => U8Q,
    resolveHttpHandlerRuntimeConfig: () => BT4
  });
  $8Q.exports = AT4(C8Q);
  var QT4 = zd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    BT4 = zd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    E8Q = Gw1(),
    GT4 = class {
      static {
        zd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = E8Q.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    ZT4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        zd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    IT4 = class A {
      static {
        zd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = z8Q(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function z8Q(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  zd(z8Q, "cloneQuery");
  var YT4 = class {
    static {
      zd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function U8Q(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  zd(U8Q, "isValidHostname")
})
// @from(Start 2650506, End 2650918)
Zw1 = z((q8Q) => {
  Object.defineProperty(q8Q, "__esModule", {
    value: !0
  });
  q8Q.default = XT4;
  var JT4 = WT4(UA("crypto"));

  function WT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }
  var chA = new Uint8Array(256),
    dhA = chA.length;

  function XT4() {
    if (dhA > chA.length - 16) JT4.default.randomFillSync(chA), dhA = 0;
    return chA.slice(dhA, dhA += 16)
  }
})
// @from(Start 2650924, End 2651185)
M8Q = z((N8Q) => {
  Object.defineProperty(N8Q, "__esModule", {
    value: !0
  });
  N8Q.default = void 0;
  var FT4 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  N8Q.default = FT4
})
// @from(Start 2651191, End 2651528)
ZHA = z((O8Q) => {
  Object.defineProperty(O8Q, "__esModule", {
    value: !0
  });
  O8Q.default = void 0;
  var KT4 = DT4(M8Q());

  function DT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }

  function HT4(A) {
    return typeof A === "string" && KT4.default.test(A)
  }
  var CT4 = HT4;
  O8Q.default = CT4
})
// @from(Start 2651534, End 2652365)
IHA = z((P8Q) => {
  Object.defineProperty(P8Q, "__esModule", {
    value: !0
  });
  P8Q.default = void 0;
  P8Q.unsafeStringify = T8Q;
  var ET4 = zT4(ZHA());

  function zT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }
  var tK = [];
  for (let A = 0; A < 256; ++A) tK.push((A + 256).toString(16).slice(1));

  function T8Q(A, Q = 0) {
    return tK[A[Q + 0]] + tK[A[Q + 1]] + tK[A[Q + 2]] + tK[A[Q + 3]] + "-" + tK[A[Q + 4]] + tK[A[Q + 5]] + "-" + tK[A[Q + 6]] + tK[A[Q + 7]] + "-" + tK[A[Q + 8]] + tK[A[Q + 9]] + "-" + tK[A[Q + 10]] + tK[A[Q + 11]] + tK[A[Q + 12]] + tK[A[Q + 13]] + tK[A[Q + 14]] + tK[A[Q + 15]]
  }

  function UT4(A, Q = 0) {
    let B = T8Q(A, Q);
    if (!(0, ET4.default)(B)) throw TypeError("Stringified UUID is invalid");
    return B
  }
  var $T4 = UT4;
  P8Q.default = $T4
})
// @from(Start 2652371, End 2653906)
y8Q = z((_8Q) => {
  Object.defineProperty(_8Q, "__esModule", {
    value: !0
  });
  _8Q.default = void 0;
  var qT4 = LT4(Zw1()),
    NT4 = IHA();

  function LT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }
  var S8Q, Iw1, Yw1 = 0,
    Jw1 = 0;

  function MT4(A, Q, B) {
    let G = Q && B || 0,
      Z = Q || Array(16);
    A = A || {};
    let I = A.node || S8Q,
      Y = A.clockseq !== void 0 ? A.clockseq : Iw1;
    if (I == null || Y == null) {
      let K = A.random || (A.rng || qT4.default)();
      if (I == null) I = S8Q = [K[0] | 1, K[1], K[2], K[3], K[4], K[5]];
      if (Y == null) Y = Iw1 = (K[6] << 8 | K[7]) & 16383
    }
    let J = A.msecs !== void 0 ? A.msecs : Date.now(),
      W = A.nsecs !== void 0 ? A.nsecs : Jw1 + 1,
      X = J - Yw1 + (W - Jw1) / 1e4;
    if (X < 0 && A.clockseq === void 0) Y = Y + 1 & 16383;
    if ((X < 0 || J > Yw1) && A.nsecs === void 0) W = 0;
    if (W >= 1e4) throw Error("uuid.v1(): Can't create more than 10M uuids/sec");
    Yw1 = J, Jw1 = W, Iw1 = Y, J += 12219292800000;
    let V = ((J & 268435455) * 1e4 + W) % 4294967296;
    Z[G++] = V >>> 24 & 255, Z[G++] = V >>> 16 & 255, Z[G++] = V >>> 8 & 255, Z[G++] = V & 255;
    let F = J / 4294967296 * 1e4 & 268435455;
    Z[G++] = F >>> 8 & 255, Z[G++] = F & 255, Z[G++] = F >>> 24 & 15 | 16, Z[G++] = F >>> 16 & 255, Z[G++] = Y >>> 8 | 128, Z[G++] = Y & 255;
    for (let K = 0; K < 6; ++K) Z[G + K] = I[K];
    return Q || (0, NT4.unsafeStringify)(Z)
  }
  var OT4 = MT4;
  _8Q.default = OT4
})
// @from(Start 2653912, End 2654796)
Ww1 = z((x8Q) => {
  Object.defineProperty(x8Q, "__esModule", {
    value: !0
  });
  x8Q.default = void 0;
  var RT4 = TT4(ZHA());

  function TT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }

  function PT4(A) {
    if (!(0, RT4.default)(A)) throw TypeError("Invalid UUID");
    let Q, B = new Uint8Array(16);
    return B[0] = (Q = parseInt(A.slice(0, 8), 16)) >>> 24, B[1] = Q >>> 16 & 255, B[2] = Q >>> 8 & 255, B[3] = Q & 255, B[4] = (Q = parseInt(A.slice(9, 13), 16)) >>> 8, B[5] = Q & 255, B[6] = (Q = parseInt(A.slice(14, 18), 16)) >>> 8, B[7] = Q & 255, B[8] = (Q = parseInt(A.slice(19, 23), 16)) >>> 8, B[9] = Q & 255, B[10] = (Q = parseInt(A.slice(24, 36), 16)) / 1099511627776 & 255, B[11] = Q / 4294967296 & 255, B[12] = Q >>> 24 & 255, B[13] = Q >>> 16 & 255, B[14] = Q >>> 8 & 255, B[15] = Q & 255, B
  }
  var jT4 = PT4;
  x8Q.default = jT4
})
// @from(Start 2654802, End 2656073)
Xw1 = z((h8Q) => {
  Object.defineProperty(h8Q, "__esModule", {
    value: !0
  });
  h8Q.URL = h8Q.DNS = void 0;
  h8Q.default = xT4;
  var ST4 = IHA(),
    _T4 = kT4(Ww1());

  function kT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }

  function yT4(A) {
    A = unescape(encodeURIComponent(A));
    let Q = [];
    for (let B = 0; B < A.length; ++B) Q.push(A.charCodeAt(B));
    return Q
  }
  var b8Q = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  h8Q.DNS = b8Q;
  var f8Q = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  h8Q.URL = f8Q;

  function xT4(A, Q, B) {
    function G(Z, I, Y, J) {
      var W;
      if (typeof Z === "string") Z = yT4(Z);
      if (typeof I === "string") I = (0, _T4.default)(I);
      if (((W = I) === null || W === void 0 ? void 0 : W.length) !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let X = new Uint8Array(16 + Z.length);
      if (X.set(I), X.set(Z, I.length), X = B(X), X[6] = X[6] & 15 | Q, X[8] = X[8] & 63 | 128, Y) {
        J = J || 0;
        for (let V = 0; V < 16; ++V) Y[J + V] = X[V];
        return Y
      }
      return (0, ST4.unsafeStringify)(X)
    }
    try {
      G.name = A
    } catch (Z) {}
    return G.DNS = b8Q, G.URL = f8Q, G
  }
})
// @from(Start 2656079, End 2656537)
d8Q = z((u8Q) => {
  Object.defineProperty(u8Q, "__esModule", {
    value: !0
  });
  u8Q.default = void 0;
  var fT4 = hT4(UA("crypto"));

  function hT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }

  function gT4(A) {
    if (Array.isArray(A)) A = Buffer.from(A);
    else if (typeof A === "string") A = Buffer.from(A, "utf8");
    return fT4.default.createHash("md5").update(A).digest()
  }
  var uT4 = gT4;
  u8Q.default = uT4
})
// @from(Start 2656543, End 2656872)
i8Q = z((p8Q) => {
  Object.defineProperty(p8Q, "__esModule", {
    value: !0
  });
  p8Q.default = void 0;
  var mT4 = c8Q(Xw1()),
    dT4 = c8Q(d8Q());

  function c8Q(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }
  var cT4 = (0, mT4.default)("v3", 48, dT4.default),
    pT4 = cT4;
  p8Q.default = pT4
})
// @from(Start 2656878, End 2657182)
s8Q = z((n8Q) => {
  Object.defineProperty(n8Q, "__esModule", {
    value: !0
  });
  n8Q.default = void 0;
  var lT4 = iT4(UA("crypto"));

  function iT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }
  var nT4 = {
    randomUUID: lT4.default.randomUUID
  };
  n8Q.default = nT4
})
// @from(Start 2657188, End 2657848)
A6Q = z((t8Q) => {
  Object.defineProperty(t8Q, "__esModule", {
    value: !0
  });
  t8Q.default = void 0;
  var r8Q = o8Q(s8Q()),
    aT4 = o8Q(Zw1()),
    sT4 = IHA();

  function o8Q(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }

  function rT4(A, Q, B) {
    if (r8Q.default.randomUUID && !Q && !A) return r8Q.default.randomUUID();
    A = A || {};
    let G = A.random || (A.rng || aT4.default)();
    if (G[6] = G[6] & 15 | 64, G[8] = G[8] & 63 | 128, Q) {
      B = B || 0;
      for (let Z = 0; Z < 16; ++Z) Q[B + Z] = G[Z];
      return Q
    }
    return (0, sT4.unsafeStringify)(G)
  }
  var oT4 = rT4;
  t8Q.default = oT4
})
// @from(Start 2657854, End 2658313)
G6Q = z((Q6Q) => {
  Object.defineProperty(Q6Q, "__esModule", {
    value: !0
  });
  Q6Q.default = void 0;
  var tT4 = eT4(UA("crypto"));

  function eT4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }

  function AP4(A) {
    if (Array.isArray(A)) A = Buffer.from(A);
    else if (typeof A === "string") A = Buffer.from(A, "utf8");
    return tT4.default.createHash("sha1").update(A).digest()
  }
  var QP4 = AP4;
  Q6Q.default = QP4
})
// @from(Start 2658319, End 2658648)
J6Q = z((I6Q) => {
  Object.defineProperty(I6Q, "__esModule", {
    value: !0
  });
  I6Q.default = void 0;
  var BP4 = Z6Q(Xw1()),
    GP4 = Z6Q(G6Q());

  function Z6Q(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }
  var ZP4 = (0, BP4.default)("v5", 80, GP4.default),
    IP4 = ZP4;
  I6Q.default = IP4
})
// @from(Start 2658654, End 2658836)
V6Q = z((W6Q) => {
  Object.defineProperty(W6Q, "__esModule", {
    value: !0
  });
  W6Q.default = void 0;
  var YP4 = "00000000-0000-0000-0000-000000000000";
  W6Q.default = YP4
})
// @from(Start 2658842, End 2659227)
D6Q = z((F6Q) => {
  Object.defineProperty(F6Q, "__esModule", {
    value: !0
  });
  F6Q.default = void 0;
  var JP4 = WP4(ZHA());

  function WP4(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }

  function XP4(A) {
    if (!(0, JP4.default)(A)) throw TypeError("Invalid UUID");
    return parseInt(A.slice(14, 15), 16)
  }
  var VP4 = XP4;
  F6Q.default = VP4
})
// @from(Start 2659233, End 2660649)
YHA = z((dR) => {
  Object.defineProperty(dR, "__esModule", {
    value: !0
  });
  Object.defineProperty(dR, "NIL", {
    enumerable: !0,
    get: function() {
      return CP4.default
    }
  });
  Object.defineProperty(dR, "parse", {
    enumerable: !0,
    get: function() {
      return $P4.default
    }
  });
  Object.defineProperty(dR, "stringify", {
    enumerable: !0,
    get: function() {
      return UP4.default
    }
  });
  Object.defineProperty(dR, "v1", {
    enumerable: !0,
    get: function() {
      return FP4.default
    }
  });
  Object.defineProperty(dR, "v3", {
    enumerable: !0,
    get: function() {
      return KP4.default
    }
  });
  Object.defineProperty(dR, "v4", {
    enumerable: !0,
    get: function() {
      return DP4.default
    }
  });
  Object.defineProperty(dR, "v5", {
    enumerable: !0,
    get: function() {
      return HP4.default
    }
  });
  Object.defineProperty(dR, "validate", {
    enumerable: !0,
    get: function() {
      return zP4.default
    }
  });
  Object.defineProperty(dR, "version", {
    enumerable: !0,
    get: function() {
      return EP4.default
    }
  });
  var FP4 = Mv(y8Q()),
    KP4 = Mv(i8Q()),
    DP4 = Mv(A6Q()),
    HP4 = Mv(J6Q()),
    CP4 = Mv(V6Q()),
    EP4 = Mv(D6Q()),
    zP4 = Mv(ZHA()),
    UP4 = Mv(IHA()),
    $P4 = Mv(Ww1());

  function Mv(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  }
})
// @from(Start 2660655, End 2663562)
Fw1 = z((Lz7, z6Q) => {
  var {
    defineProperty: phA,
    getOwnPropertyDescriptor: wP4,
    getOwnPropertyNames: qP4
  } = Object, NP4 = Object.prototype.hasOwnProperty, mr = (A, Q) => phA(A, "name", {
    value: Q,
    configurable: !0
  }), LP4 = (A, Q) => {
    for (var B in Q) phA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, MP4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qP4(Q))
        if (!NP4.call(A, Z) && Z !== B) phA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wP4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, OP4 = (A) => MP4(phA({}, "__esModule", {
    value: !0
  }), A), H6Q = {};
  LP4(H6Q, {
    isBrowserNetworkError: () => E6Q,
    isClockSkewCorrectedError: () => C6Q,
    isClockSkewError: () => yP4,
    isRetryableByTrait: () => kP4,
    isServerError: () => vP4,
    isThrottlingError: () => xP4,
    isTransientError: () => Vw1
  });
  z6Q.exports = OP4(H6Q);
  var RP4 = ["AuthFailure", "InvalidSignatureException", "RequestExpired", "RequestInTheFuture", "RequestTimeTooSkewed", "SignatureDoesNotMatch"],
    TP4 = ["BandwidthLimitExceeded", "EC2ThrottledException", "LimitExceededException", "PriorRequestNotComplete", "ProvisionedThroughputExceededException", "RequestLimitExceeded", "RequestThrottled", "RequestThrottledException", "SlowDown", "ThrottledException", "Throttling", "ThrottlingException", "TooManyRequestsException", "TransactionInProgressException"],
    PP4 = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"],
    jP4 = [500, 502, 503, 504],
    SP4 = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"],
    _P4 = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"],
    kP4 = mr((A) => A.$retryable !== void 0, "isRetryableByTrait"),
    yP4 = mr((A) => RP4.includes(A.name), "isClockSkewError"),
    C6Q = mr((A) => A.$metadata?.clockSkewCorrected, "isClockSkewCorrectedError"),
    E6Q = mr((A) => {
      let Q = new Set(["Failed to fetch", "NetworkError when attempting to fetch resource", "The Internet connection appears to be offline", "Load failed", "Network request failed"]);
      if (!(A && A instanceof TypeError)) return !1;
      return Q.has(A.message)
    }, "isBrowserNetworkError"),
    xP4 = mr((A) => A.$metadata?.httpStatusCode === 429 || TP4.includes(A.name) || A.$retryable?.throttling == !0, "isThrottlingError"),
    Vw1 = mr((A, Q = 0) => C6Q(A) || PP4.includes(A.name) || SP4.includes(A?.code || "") || _P4.includes(A?.code || "") || jP4.includes(A.$metadata?.httpStatusCode || 0) || E6Q(A) || A.cause !== void 0 && Q <= 10 && Vw1(A.cause, Q + 1), "isTransientError"),
    vP4 = mr((A) => {
      if (A.$metadata?.httpStatusCode !== void 0) {
        let Q = A.$metadata.httpStatusCode;
        if (500 <= Q && Q <= 599 && !Vw1(A)) return !0;
        return !1
      }
      return !1
    }, "isServerError")
})
// @from(Start 2663568, End 2672461)
KW = z((Mz7, R6Q) => {
  var {
    defineProperty: lhA,
    getOwnPropertyDescriptor: bP4,
    getOwnPropertyNames: fP4
  } = Object, hP4 = Object.prototype.hasOwnProperty, cR = (A, Q) => lhA(A, "name", {
    value: Q,
    configurable: !0
  }), gP4 = (A, Q) => {
    for (var B in Q) lhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, uP4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of fP4(Q))
        if (!hP4.call(A, Z) && Z !== B) lhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = bP4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, mP4 = (A) => uP4(lhA({}, "__esModule", {
    value: !0
  }), A), $6Q = {};
  gP4($6Q, {
    AdaptiveRetryStrategy: () => nP4,
    ConfiguredRetryStrategy: () => aP4,
    DEFAULT_MAX_ATTEMPTS: () => Kw1,
    DEFAULT_RETRY_DELAY_BASE: () => JHA,
    DEFAULT_RETRY_MODE: () => dP4,
    DefaultRateLimiter: () => q6Q,
    INITIAL_RETRY_TOKENS: () => Dw1,
    INVOCATION_ID_HEADER: () => pP4,
    MAXIMUM_RETRY_DELAY: () => Hw1,
    NO_RETRY_INCREMENT: () => O6Q,
    REQUEST_HEADER: () => lP4,
    RETRY_COST: () => L6Q,
    RETRY_MODES: () => w6Q,
    StandardRetryStrategy: () => Cw1,
    THROTTLING_RETRY_DELAY_BASE: () => N6Q,
    TIMEOUT_RETRY_COST: () => M6Q
  });
  R6Q.exports = mP4($6Q);
  var w6Q = ((A) => {
      return A.STANDARD = "standard", A.ADAPTIVE = "adaptive", A
    })(w6Q || {}),
    Kw1 = 3,
    dP4 = "standard",
    cP4 = Fw1(),
    q6Q = class A {
      constructor(Q) {
        this.currentCapacity = 0, this.enabled = !1, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = Q?.beta ?? 0.7, this.minCapacity = Q?.minCapacity ?? 1, this.minFillRate = Q?.minFillRate ?? 0.5, this.scaleConstant = Q?.scaleConstant ?? 0.4, this.smooth = Q?.smooth ?? 0.8;
        let B = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = B, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity
      }
      static {
        cR(this, "DefaultRateLimiter")
      }
      static {
        this.setTimeoutFn = setTimeout
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1000
      }
      async getSendToken() {
        return this.acquireTokenBucket(1)
      }
      async acquireTokenBucket(Q) {
        if (!this.enabled) return;
        if (this.refillTokenBucket(), Q > this.currentCapacity) {
          let B = (Q - this.currentCapacity) / this.fillRate * 1000;
          await new Promise((G) => A.setTimeoutFn(G, B))
        }
        this.currentCapacity = this.currentCapacity - Q
      }
      refillTokenBucket() {
        let Q = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = Q;
          return
        }
        let B = (Q - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + B), this.lastTimestamp = Q
      }
      updateClientSendingRate(Q) {
        let B;
        if (this.updateMeasuredRate(), (0, cP4.isThrottlingError)(Q)) {
          let Z = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
          this.lastMaxRate = Z, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), B = this.cubicThrottle(Z), this.enableTokenBucket()
        } else this.calculateTimeWindow(), B = this.cubicSuccess(this.getCurrentTimeInSeconds());
        let G = Math.min(B, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(G)
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 0.3333333333333333))
      }
      cubicThrottle(Q) {
        return this.getPrecise(Q * this.beta)
      }
      cubicSuccess(Q) {
        return this.getPrecise(this.scaleConstant * Math.pow(Q - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate)
      }
      enableTokenBucket() {
        this.enabled = !0
      }
      updateTokenBucketRate(Q) {
        this.refillTokenBucket(), this.fillRate = Math.max(Q, this.minFillRate), this.maxCapacity = Math.max(Q, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity)
      }
      updateMeasuredRate() {
        let Q = this.getCurrentTimeInSeconds(),
          B = Math.floor(Q * 2) / 2;
        if (this.requestCount++, B > this.lastTxRateBucket) {
          let G = this.requestCount / (B - this.lastTxRateBucket);
          this.measuredTxRate = this.getPrecise(G * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = B
        }
      }
      getPrecise(Q) {
        return parseFloat(Q.toFixed(8))
      }
    },
    JHA = 100,
    Hw1 = 20000,
    N6Q = 500,
    Dw1 = 500,
    L6Q = 5,
    M6Q = 10,
    O6Q = 1,
    pP4 = "amz-sdk-invocation-id",
    lP4 = "amz-sdk-request",
    iP4 = cR(() => {
      let A = JHA;
      return {
        computeNextBackoffDelay: cR((G) => {
          return Math.floor(Math.min(Hw1, Math.random() * 2 ** G * A))
        }, "computeNextBackoffDelay"),
        setDelayBase: cR((G) => {
          A = G
        }, "setDelayBase")
      }
    }, "getDefaultRetryBackoffStrategy"),
    U6Q = cR(({
      retryDelay: A,
      retryCount: Q,
      retryCost: B
    }) => {
      return {
        getRetryCount: cR(() => Q, "getRetryCount"),
        getRetryDelay: cR(() => Math.min(Hw1, A), "getRetryDelay"),
        getRetryCost: cR(() => B, "getRetryCost")
      }
    }, "createDefaultRetryToken"),
    Cw1 = class {
      constructor(A) {
        this.maxAttempts = A, this.mode = "standard", this.capacity = Dw1, this.retryBackoffStrategy = iP4(), this.maxAttemptsProvider = typeof A === "function" ? A : async () => A
      }
      static {
        cR(this, "StandardRetryStrategy")
      }
      async acquireInitialRetryToken(A) {
        return U6Q({
          retryDelay: JHA,
          retryCount: 0
        })
      }
      async refreshRetryTokenForRetry(A, Q) {
        let B = await this.getMaxAttempts();
        if (this.shouldRetry(A, Q, B)) {
          let G = Q.errorType;
          this.retryBackoffStrategy.setDelayBase(G === "THROTTLING" ? N6Q : JHA);
          let Z = this.retryBackoffStrategy.computeNextBackoffDelay(A.getRetryCount()),
            I = Q.retryAfterHint ? Math.max(Q.retryAfterHint.getTime() - Date.now() || 0, Z) : Z,
            Y = this.getCapacityCost(G);
          return this.capacity -= Y, U6Q({
            retryDelay: I,
            retryCount: A.getRetryCount() + 1,
            retryCost: Y
          })
        }
        throw Error("No retry token available")
      }
      recordSuccess(A) {
        this.capacity = Math.max(Dw1, this.capacity + (A.getRetryCost() ?? O6Q))
      }
      getCapacity() {
        return this.capacity
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider()
        } catch (A) {
          return console.warn(`Max attempts provider could not resolve. Using default of ${Kw1}`), Kw1
        }
      }
      shouldRetry(A, Q, B) {
        return A.getRetryCount() + 1 < B && this.capacity >= this.getCapacityCost(Q.errorType) && this.isRetryableError(Q.errorType)
      }
      getCapacityCost(A) {
        return A === "TRANSIENT" ? M6Q : L6Q
      }
      isRetryableError(A) {
        return A === "THROTTLING" || A === "TRANSIENT"
      }
    },
    nP4 = class {
      constructor(A, Q) {
        this.maxAttemptsProvider = A, this.mode = "adaptive";
        let {
          rateLimiter: B
        } = Q ?? {};
        this.rateLimiter = B ?? new q6Q, this.standardRetryStrategy = new Cw1(A)
      }
      static {
        cR(this, "AdaptiveRetryStrategy")
      }
      async acquireInitialRetryToken(A) {
        return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(A)
      }
      async refreshRetryTokenForRetry(A, Q) {
        return this.rateLimiter.updateClientSendingRate(Q), this.standardRetryStrategy.refreshRetryTokenForRetry(A, Q)
      }
      recordSuccess(A) {
        this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(A)
      }
    },
    aP4 = class extends Cw1 {
      static {
        cR(this, "ConfiguredRetryStrategy")
      }
      constructor(A, Q = JHA) {
        super(typeof A === "function" ? A : async () => A);
        if (typeof Q === "number") this.computeNextBackoffDelay = () => Q;
        else this.computeNextBackoffDelay = Q
      }
      async refreshRetryTokenForRetry(A, Q) {
        let B = await super.refreshRetryTokenForRetry(A, Q);
        return B.getRetryDelay = () => this.computeNextBackoffDelay(B.getRetryCount()), B
      }
    }
})
// @from(Start 2672467, End 2686492)
v6Q = z((Pz7, Nw1) => {
  var {
    defineProperty: ihA,
    getOwnPropertyDescriptor: sP4,
    getOwnPropertyNames: rP4
  } = Object, oP4 = Object.prototype.hasOwnProperty, T3 = (A, Q) => ihA(A, "name", {
    value: Q,
    configurable: !0
  }), tP4 = (A, Q) => {
    for (var B in Q) ihA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, zw1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of rP4(Q))
        if (!oP4.call(A, Z) && Z !== B) ihA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = sP4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, eP4 = (A, Q, B) => (zw1(A, Q, "default"), B && zw1(B, Q, "default")), Aj4 = (A) => zw1(ihA({}, "__esModule", {
    value: !0
  }), A), ww1 = {};
  tP4(ww1, {
    Client: () => Qj4,
    Command: () => j6Q,
    NoOpLogger: () => Uj4,
    SENSITIVE_STRING: () => Gj4,
    ServiceException: () => Ij4,
    _json: () => $w1,
    collectBody: () => Ew1.collectBody,
    convertMap: () => $j4,
    createAggregatedClient: () => Zj4,
    decorateServiceException: () => S6Q,
    emitWarningIfUnsupportedVersion: () => Xj4,
    extendedEncodeURIComponent: () => Ew1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => Ej4,
    getDefaultClientConfiguration: () => Hj4,
    getDefaultExtensionConfiguration: () => k6Q,
    getValueFromTextNode: () => y6Q,
    isSerializableHeaderValue: () => zj4,
    loadConfigsForDefaultMode: () => Wj4,
    map: () => qw1,
    resolveDefaultRuntimeConfig: () => Cj4,
    resolvedPath: () => Ew1.resolvedPath,
    serializeDateTime: () => Oj4,
    serializeFloat: () => Mj4,
    take: () => wj4,
    throwDefaultError: () => _6Q,
    withBaseException: () => Yj4
  });
  Nw1.exports = Aj4(ww1);
  var P6Q = uR(),
    Qj4 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, P6Q.constructStack)()
      }
      static {
        T3(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    Ew1 = w5(),
    Uw1 = Gw1(),
    j6Q = class {
      constructor() {
        this.middlewareStack = (0, P6Q.constructStack)()
      }
      static {
        T3(this, "Command")
      }
      static classBuilder() {
        return new Bj4
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [Uw1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    Bj4 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        T3(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      sc(A) {
        return this._operationSchema = A, this._smithyContext.operationSchema = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends j6Q {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this), this.schema = A._operationSchema
          }
          static {
            T3(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    Gj4 = "***SensitiveInformation***",
    Zj4 = T3((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = T3(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    Ij4 = class A extends Error {
      static {
        T3(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    S6Q = T3((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    _6Q = T3(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = Jj4(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw S6Q(Y, Q)
    }, "throwDefaultError"),
    Yj4 = T3((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        _6Q({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    Jj4 = T3((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    Wj4 = T3((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    T6Q = !1,
    Xj4 = T3((A) => {
      if (A && !T6Q && parseInt(A.substring(1, A.indexOf("."))) < 16) T6Q = !0
    }, "emitWarningIfUnsupportedVersion"),
    Vj4 = T3((A) => {
      let Q = [];
      for (let B in Uw1.AlgorithmId) {
        let G = Uw1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    Fj4 = T3((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    Kj4 = T3((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    Dj4 = T3((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    k6Q = T3((A) => {
      return Object.assign(Vj4(A), Kj4(A))
    }, "getDefaultExtensionConfiguration"),
    Hj4 = k6Q,
    Cj4 = T3((A) => {
      return Object.assign(Fj4(A), Dj4(A))
    }, "resolveDefaultRuntimeConfig"),
    Ej4 = T3((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    y6Q = T3((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = y6Q(A[B]);
      return A
    }, "getValueFromTextNode"),
    zj4 = T3((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    Uj4 = class {
      static {
        T3(this, "NoOpLogger")
      }
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };

  function qw1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, qj4(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      x6Q(G, null, I, Y)
    }
    return G
  }
  T3(qw1, "map");
  var $j4 = T3((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    wj4 = T3((A, Q) => {
      let B = {};
      for (let G in Q) x6Q(B, A, Q, G);
      return B
    }, "take"),
    qj4 = T3((A, Q, B) => {
      return qw1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    x6Q = T3((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = Nj4, W = Lj4, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    Nj4 = T3((A) => A != null, "nonNullish"),
    Lj4 = T3((A) => A, "pass"),
    Mj4 = T3((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    Oj4 = T3((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    $w1 = T3((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map($w1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = $w1(A[B])
        }
        return Q
      }
      return A
    }, "_json");
  eP4(ww1, s6(), Nw1.exports)
})
// @from(Start 2686498, End 2686872)
h6Q = z((b6Q) => {
  Object.defineProperty(b6Q, "__esModule", {
    value: !0
  });
  b6Q.isStreamingPayload = void 0;
  var Rj4 = UA("stream"),
    Tj4 = (A) => (A === null || A === void 0 ? void 0 : A.body) instanceof Rj4.Readable || typeof ReadableStream < "u" && (A === null || A === void 0 ? void 0 : A.body) instanceof ReadableStream;
  b6Q.isStreamingPayload = Tj4
})
// @from(Start 2686878, End 2697541)
D6 = z((vz7, e6Q) => {
  var {
    defineProperty: nhA,
    getOwnPropertyDescriptor: Pj4,
    getOwnPropertyNames: jj4
  } = Object, Sj4 = Object.prototype.hasOwnProperty, MX = (A, Q) => nhA(A, "name", {
    value: Q,
    configurable: !0
  }), _j4 = (A, Q) => {
    for (var B in Q) nhA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, kj4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of jj4(Q))
        if (!Sj4.call(A, Z) && Z !== B) nhA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Pj4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, yj4 = (A) => kj4(nhA({}, "__esModule", {
    value: !0
  }), A), u6Q = {};
  _j4(u6Q, {
    AdaptiveRetryStrategy: () => bj4,
    CONFIG_MAX_ATTEMPTS: () => Mw1,
    CONFIG_RETRY_MODE: () => n6Q,
    ENV_MAX_ATTEMPTS: () => Lw1,
    ENV_RETRY_MODE: () => i6Q,
    NODE_MAX_ATTEMPT_CONFIG_OPTIONS: () => fj4,
    NODE_RETRY_MODE_CONFIG_OPTIONS: () => gj4,
    StandardRetryStrategy: () => l6Q,
    defaultDelayDecider: () => d6Q,
    defaultRetryDecider: () => c6Q,
    getOmitRetryHeadersPlugin: () => uj4,
    getRetryAfterHint: () => t6Q,
    getRetryPlugin: () => ij4,
    omitRetryHeadersMiddleware: () => a6Q,
    omitRetryHeadersMiddlewareOptions: () => s6Q,
    resolveRetryConfig: () => hj4,
    retryMiddleware: () => r6Q,
    retryMiddlewareOptions: () => o6Q
  });
  e6Q.exports = yj4(u6Q);
  var e4A = w8Q(),
    m6Q = YHA(),
    fY = KW(),
    xj4 = MX((A, Q) => {
      let B = A,
        G = Q?.noRetryIncrement ?? fY.NO_RETRY_INCREMENT,
        Z = Q?.retryCost ?? fY.RETRY_COST,
        I = Q?.timeoutRetryCost ?? fY.TIMEOUT_RETRY_COST,
        Y = A,
        J = MX((F) => F.name === "TimeoutError" ? I : Z, "getCapacityAmount"),
        W = MX((F) => J(F) <= Y, "hasRetryTokens");
      return Object.freeze({
        hasRetryTokens: W,
        retrieveRetryTokens: MX((F) => {
          if (!W(F)) throw Error("No retry token available");
          let K = J(F);
          return Y -= K, K
        }, "retrieveRetryTokens"),
        releaseRetryTokens: MX((F) => {
          Y += F ?? G, Y = Math.min(Y, B)
        }, "releaseRetryTokens")
      })
    }, "getDefaultRetryQuota"),
    d6Q = MX((A, Q) => Math.floor(Math.min(fY.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** Q * A)), "defaultDelayDecider"),
    Ud = Fw1(),
    c6Q = MX((A) => {
      if (!A) return !1;
      return (0, Ud.isRetryableByTrait)(A) || (0, Ud.isClockSkewError)(A) || (0, Ud.isThrottlingError)(A) || (0, Ud.isTransientError)(A)
    }, "defaultRetryDecider"),
    p6Q = MX((A) => {
      if (A instanceof Error) return A;
      if (A instanceof Object) return Object.assign(Error(), A);
      if (typeof A === "string") return Error(A);
      return Error(`AWS SDK error wrapper for ${A}`)
    }, "asSdkError"),
    l6Q = class {
      constructor(A, Q) {
        this.maxAttemptsProvider = A, this.mode = fY.RETRY_MODES.STANDARD, this.retryDecider = Q?.retryDecider ?? c6Q, this.delayDecider = Q?.delayDecider ?? d6Q, this.retryQuota = Q?.retryQuota ?? xj4(fY.INITIAL_RETRY_TOKENS)
      }
      static {
        MX(this, "StandardRetryStrategy")
      }
      shouldRetry(A, Q, B) {
        return Q < B && this.retryDecider(A) && this.retryQuota.hasRetryTokens(A)
      }
      async getMaxAttempts() {
        let A;
        try {
          A = await this.maxAttemptsProvider()
        } catch (Q) {
          A = fY.DEFAULT_MAX_ATTEMPTS
        }
        return A
      }
      async retry(A, Q, B) {
        let G, Z = 0,
          I = 0,
          Y = await this.getMaxAttempts(),
          {
            request: J
          } = Q;
        if (e4A.HttpRequest.isInstance(J)) J.headers[fY.INVOCATION_ID_HEADER] = (0, m6Q.v4)();
        while (!0) try {
          if (e4A.HttpRequest.isInstance(J)) J.headers[fY.REQUEST_HEADER] = `attempt=${Z+1}; max=${Y}`;
          if (B?.beforeRequest) await B.beforeRequest();
          let {
            response: W,
            output: X
          } = await A(Q);
          if (B?.afterRequest) B.afterRequest(W);
          return this.retryQuota.releaseRetryTokens(G), X.$metadata.attempts = Z + 1, X.$metadata.totalRetryDelay = I, {
            response: W,
            output: X
          }
        } catch (W) {
          let X = p6Q(W);
          if (Z++, this.shouldRetry(X, Z, Y)) {
            G = this.retryQuota.retrieveRetryTokens(X);
            let V = this.delayDecider((0, Ud.isThrottlingError)(X) ? fY.THROTTLING_RETRY_DELAY_BASE : fY.DEFAULT_RETRY_DELAY_BASE, Z),
              F = vj4(X.$response),
              K = Math.max(F || 0, V);
            I += K, await new Promise((D) => setTimeout(D, K));
            continue
          }
          if (!X.$metadata) X.$metadata = {};
          throw X.$metadata.attempts = Z, X.$metadata.totalRetryDelay = I, X
        }
      }
    },
    vj4 = MX((A) => {
      if (!e4A.HttpResponse.isInstance(A)) return;
      let Q = Object.keys(A.headers).find((I) => I.toLowerCase() === "retry-after");
      if (!Q) return;
      let B = A.headers[Q],
        G = Number(B);
      if (!Number.isNaN(G)) return G * 1000;
      return new Date(B).getTime() - Date.now()
    }, "getDelayFromRetryAfterHeader"),
    bj4 = class extends l6Q {
      static {
        MX(this, "AdaptiveRetryStrategy")
      }
      constructor(A, Q) {
        let {
          rateLimiter: B,
          ...G
        } = Q ?? {};
        super(A, G);
        this.rateLimiter = B ?? new fY.DefaultRateLimiter, this.mode = fY.RETRY_MODES.ADAPTIVE
      }
      async retry(A, Q) {
        return super.retry(A, Q, {
          beforeRequest: async () => {
            return this.rateLimiter.getSendToken()
          },
          afterRequest: (B) => {
            this.rateLimiter.updateClientSendingRate(B)
          }
        })
      }
    },
    g6Q = w7(),
    Lw1 = "AWS_MAX_ATTEMPTS",
    Mw1 = "max_attempts",
    fj4 = {
      environmentVariableSelector: (A) => {
        let Q = A[Lw1];
        if (!Q) return;
        let B = parseInt(Q);
        if (Number.isNaN(B)) throw Error(`Environment variable ${Lw1} mast be a number, got "${Q}"`);
        return B
      },
      configFileSelector: (A) => {
        let Q = A[Mw1];
        if (!Q) return;
        let B = parseInt(Q);
        if (Number.isNaN(B)) throw Error(`Shared config file entry ${Mw1} mast be a number, got "${Q}"`);
        return B
      },
      default: fY.DEFAULT_MAX_ATTEMPTS
    },
    hj4 = MX((A) => {
      let {
        retryStrategy: Q,
        retryMode: B,
        maxAttempts: G
      } = A, Z = (0, g6Q.normalizeProvider)(G ?? fY.DEFAULT_MAX_ATTEMPTS);
      return Object.assign(A, {
        maxAttempts: Z,
        retryStrategy: async () => {
          if (Q) return Q;
          if (await (0, g6Q.normalizeProvider)(B)() === fY.RETRY_MODES.ADAPTIVE) return new fY.AdaptiveRetryStrategy(Z);
          return new fY.StandardRetryStrategy(Z)
        }
      })
    }, "resolveRetryConfig"),
    i6Q = "AWS_RETRY_MODE",
    n6Q = "retry_mode",
    gj4 = {
      environmentVariableSelector: (A) => A[i6Q],
      configFileSelector: (A) => A[n6Q],
      default: fY.DEFAULT_RETRY_MODE
    },
    a6Q = MX(() => (A) => async (Q) => {
      let {
        request: B
      } = Q;
      if (e4A.HttpRequest.isInstance(B)) delete B.headers[fY.INVOCATION_ID_HEADER], delete B.headers[fY.REQUEST_HEADER];
      return A(Q)
    }, "omitRetryHeadersMiddleware"),
    s6Q = {
      name: "omitRetryHeadersMiddleware",
      tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
      relation: "before",
      toMiddleware: "awsAuthMiddleware",
      override: !0
    },
    uj4 = MX((A) => ({
      applyToStack: (Q) => {
        Q.addRelativeTo(a6Q(), s6Q)
      }
    }), "getOmitRetryHeadersPlugin"),
    mj4 = v6Q(),
    dj4 = h6Q(),
    r6Q = MX((A) => (Q, B) => async (G) => {
      let Z = await A.retryStrategy(),
        I = await A.maxAttempts();
      if (cj4(Z)) {
        Z = Z;
        let Y = await Z.acquireInitialRetryToken(B.partition_id),
          J = Error(),
          W = 0,
          X = 0,
          {
            request: V
          } = G,
          F = e4A.HttpRequest.isInstance(V);
        if (F) V.headers[fY.INVOCATION_ID_HEADER] = (0, m6Q.v4)();
        while (!0) try {
          if (F) V.headers[fY.REQUEST_HEADER] = `attempt=${W+1}; max=${I}`;
          let {
            response: K,
            output: D
          } = await Q(G);
          return Z.recordSuccess(Y), D.$metadata.attempts = W + 1, D.$metadata.totalRetryDelay = X, {
            response: K,
            output: D
          }
        } catch (K) {
          let D = pj4(K);
          if (J = p6Q(K), F && (0, dj4.isStreamingPayload)(V)) throw (B.logger instanceof mj4.NoOpLogger ? console : B.logger)?.warn("An error was encountered in a non-retryable streaming request."), J;
          try {
            Y = await Z.refreshRetryTokenForRetry(Y, D)
          } catch (C) {
            if (!J.$metadata) J.$metadata = {};
            throw J.$metadata.attempts = W + 1, J.$metadata.totalRetryDelay = X, J
          }
          W = Y.getRetryCount();
          let H = Y.getRetryDelay();
          X += H, await new Promise((C) => setTimeout(C, H))
        }
      } else {
        if (Z = Z, Z?.mode) B.userAgent = [...B.userAgent || [],
          ["cfg/retry-mode", Z.mode]
        ];
        return Z.retry(Q, G)
      }
    }, "retryMiddleware"),
    cj4 = MX((A) => typeof A.acquireInitialRetryToken < "u" && typeof A.refreshRetryTokenForRetry < "u" && typeof A.recordSuccess < "u", "isRetryStrategyV2"),
    pj4 = MX((A) => {
      let Q = {
          error: A,
          errorType: lj4(A)
        },
        B = t6Q(A.$response);
      if (B) Q.retryAfterHint = B;
      return Q
    }, "getRetryErrorInfo"),
    lj4 = MX((A) => {
      if ((0, Ud.isThrottlingError)(A)) return "THROTTLING";
      if ((0, Ud.isTransientError)(A)) return "TRANSIENT";
      if ((0, Ud.isServerError)(A)) return "SERVER_ERROR";
      return "CLIENT_ERROR"
    }, "getRetryErrorType"),
    o6Q = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: !0
    },
    ij4 = MX((A) => ({
      applyToStack: (Q) => {
        Q.add(r6Q(A), o6Q)
      }
    }), "getRetryPlugin"),
    t6Q = MX((A) => {
      if (!e4A.HttpResponse.isInstance(A)) return;
      let Q = Object.keys(A.headers).find((I) => I.toLowerCase() === "retry-after");
      if (!Q) return;
      let B = A.headers[Q],
        G = Number(B);
      if (!Number.isNaN(G)) return new Date(G * 1000);
      return new Date(B)
    }, "getRetryAfterHint")
})
// @from(Start 2697547, End 2699285)
Rw1 = z((Q5Q) => {
  Object.defineProperty(Q5Q, "__esModule", {
    value: !0
  });
  Q5Q.resolveHttpAuthSchemeConfig = Q5Q.resolveStsAuthConfig = Q5Q.defaultSTSHttpAuthSchemeProvider = Q5Q.defaultSTSHttpAuthSchemeParametersProvider = void 0;
  var nj4 = MF(),
    Ow1 = w7(),
    aj4 = WHA(),
    sj4 = async (A, Q, B) => {
      return {
        operation: (0, Ow1.getSmithyContext)(Q).operation,
        region: await (0, Ow1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  Q5Q.defaultSTSHttpAuthSchemeParametersProvider = sj4;

  function rj4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function A5Q(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var oj4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "AssumeRoleWithSAML": {
        Q.push(A5Q(A));
        break
      }
      case "AssumeRoleWithWebIdentity": {
        Q.push(A5Q(A));
        break
      }
      default:
        Q.push(rj4(A))
    }
    return Q
  };
  Q5Q.defaultSTSHttpAuthSchemeProvider = oj4;
  var tj4 = (A) => Object.assign(A, {
    stsClientCtor: aj4.STSClient
  });
  Q5Q.resolveStsAuthConfig = tj4;
  var ej4 = (A) => {
    let Q = Q5Q.resolveStsAuthConfig(A),
      B = (0, nj4.resolveAwsSdkSigV4Config)(Q);
    return Object.assign(B, {
      authSchemePreference: (0, Ow1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  Q5Q.resolveHttpAuthSchemeConfig = ej4
})
// @from(Start 2699291, End 2700178)
IL = z((Z5Q) => {
  Object.defineProperty(Z5Q, "__esModule", {
    value: !0
  });
  Z5Q.commonParams = Z5Q.resolveClientEndpointParameters = void 0;
  var BS4 = (A) => {
    return Object.assign(A, {
      useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
      useFipsEndpoint: A.useFipsEndpoint ?? !1,
      useGlobalEndpoint: A.useGlobalEndpoint ?? !1,
      defaultSigningName: "sts"
    })
  };
  Z5Q.resolveClientEndpointParameters = BS4;
  Z5Q.commonParams = {
    UseGlobalEndpoint: {
      type: "builtInParams",
      name: "useGlobalEndpoint"
    },
    UseFIPS: {
      type: "builtInParams",
      name: "useFipsEndpoint"
    },
    Endpoint: {
      type: "builtInParams",
      name: "endpoint"
    },
    Region: {
      type: "builtInParams",
      name: "region"
    },
    UseDualStack: {
      type: "builtInParams",
      name: "useDualstackEndpoint"
    }
  }
})
// @from(Start 2700184, End 2703952)
Y5Q = z((uz7, ZS4) => {
  ZS4.exports = {
    name: "@aws-sdk/client-sts",
    description: "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native",
    version: "3.840.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sts",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "rimraf ./dist-types tsconfig.types.tsbuildinfo && tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/credential-provider-node": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sts"
    }
  }
})
// @from(Start 2703958, End 2706031)
Tw1 = z((mz7, H5Q) => {
  var {
    defineProperty: ahA,
    getOwnPropertyDescriptor: IS4,
    getOwnPropertyNames: YS4
  } = Object, JS4 = Object.prototype.hasOwnProperty, WS4 = (A, Q) => ahA(A, "name", {
    value: Q,
    configurable: !0
  }), XS4 = (A, Q) => {
    for (var B in Q) ahA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, VS4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of YS4(Q))
        if (!JS4.call(A, Z) && Z !== B) ahA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = IS4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, FS4 = (A) => VS4(ahA({}, "__esModule", {
    value: !0
  }), A), J5Q = {};
  XS4(J5Q, {
    ENV_ACCOUNT_ID: () => D5Q,
    ENV_CREDENTIAL_SCOPE: () => K5Q,
    ENV_EXPIRATION: () => F5Q,
    ENV_KEY: () => W5Q,
    ENV_SECRET: () => X5Q,
    ENV_SESSION: () => V5Q,
    fromEnv: () => HS4
  });
  H5Q.exports = FS4(J5Q);
  var KS4 = QL(),
    DS4 = j2(),
    W5Q = "AWS_ACCESS_KEY_ID",
    X5Q = "AWS_SECRET_ACCESS_KEY",
    V5Q = "AWS_SESSION_TOKEN",
    F5Q = "AWS_CREDENTIAL_EXPIRATION",
    K5Q = "AWS_CREDENTIAL_SCOPE",
    D5Q = "AWS_ACCOUNT_ID",
    HS4 = WS4((A) => async () => {
      A?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
      let Q = process.env[W5Q],
        B = process.env[X5Q],
        G = process.env[V5Q],
        Z = process.env[F5Q],
        I = process.env[K5Q],
        Y = process.env[D5Q];
      if (Q && B) {
        let J = {
          accessKeyId: Q,
          secretAccessKey: B,
          ...G && {
            sessionToken: G
          },
          ...Z && {
            expiration: new Date(Z)
          },
          ...I && {
            credentialScope: I
          },
          ...Y && {
            accountId: Y
          }
        };
        return (0, KS4.setCredentialFeature)(J, "CREDENTIALS_ENV_VARS", "g"), J
      }
      throw new DS4.CredentialsProviderError("Unable to find environment variable credentials.", {
        logger: A?.logger
      })
    }, "fromEnv")
})
// @from(Start 2706037, End 2717672)
OV = z((dz7, T5Q) => {
  var {
    defineProperty: ohA,
    getOwnPropertyDescriptor: CS4,
    getOwnPropertyNames: ES4
  } = Object, zS4 = Object.prototype.hasOwnProperty, OX = (A, Q) => ohA(A, "name", {
    value: Q,
    configurable: !0
  }), US4 = (A, Q) => {
    for (var B in Q) ohA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, $S4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ES4(Q))
        if (!zS4.call(A, Z) && Z !== B) ohA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = CS4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, wS4 = (A) => $S4(ohA({}, "__esModule", {
    value: !0
  }), A), U5Q = {};
  US4(U5Q, {
    DEFAULT_MAX_RETRIES: () => N5Q,
    DEFAULT_TIMEOUT: () => q5Q,
    ENV_CMDS_AUTH_TOKEN: () => Sw1,
    ENV_CMDS_FULL_URI: () => shA,
    ENV_CMDS_RELATIVE_URI: () => rhA,
    Endpoint: () => L5Q,
    fromContainerMetadata: () => MS4,
    fromInstanceMetadata: () => lS4,
    getInstanceMetadataEndpoint: () => O5Q,
    httpRequest: () => A8A,
    providerConfigFromInit: () => _w1
  });
  T5Q.exports = wS4(U5Q);
  var qS4 = UA("url"),
    LS = j2(),
    NS4 = UA("buffer"),
    LS4 = UA("http");

  function A8A(A) {
    return new Promise((Q, B) => {
      let G = (0, LS4.request)({
        method: "GET",
        ...A,
        hostname: A.hostname?.replace(/^\[(.+)\]$/, "$1")
      });
      G.on("error", (Z) => {
        B(Object.assign(new LS.ProviderError("Unable to connect to instance metadata service"), Z)), G.destroy()
      }), G.on("timeout", () => {
        B(new LS.ProviderError("TimeoutError from instance metadata service")), G.destroy()
      }), G.on("response", (Z) => {
        let {
          statusCode: I = 400
        } = Z;
        if (I < 200 || 300 <= I) B(Object.assign(new LS.ProviderError("Error response received from instance metadata service"), {
          statusCode: I
        })), G.destroy();
        let Y = [];
        Z.on("data", (J) => {
          Y.push(J)
        }), Z.on("end", () => {
          Q(NS4.Buffer.concat(Y)), G.destroy()
        })
      }), G.end()
    })
  }
  OX(A8A, "httpRequest");
  var $5Q = OX((A) => Boolean(A) && typeof A === "object" && typeof A.AccessKeyId === "string" && typeof A.SecretAccessKey === "string" && typeof A.Token === "string" && typeof A.Expiration === "string", "isImdsCredentials"),
    w5Q = OX((A) => ({
      accessKeyId: A.AccessKeyId,
      secretAccessKey: A.SecretAccessKey,
      sessionToken: A.Token,
      expiration: new Date(A.Expiration),
      ...A.AccountId && {
        accountId: A.AccountId
      }
    }), "fromImdsCredentials"),
    q5Q = 1000,
    N5Q = 0,
    _w1 = OX(({
      maxRetries: A = N5Q,
      timeout: Q = q5Q
    }) => ({
      maxRetries: A,
      timeout: Q
    }), "providerConfigFromInit"),
    jw1 = OX((A, Q) => {
      let B = A();
      for (let G = 0; G < Q; G++) B = B.catch(A);
      return B
    }, "retry"),
    shA = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    rhA = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    Sw1 = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    MS4 = OX((A = {}) => {
      let {
        timeout: Q,
        maxRetries: B
      } = _w1(A);
      return () => jw1(async () => {
        let G = await jS4({
            logger: A.logger
          }),
          Z = JSON.parse(await OS4(Q, G));
        if (!$5Q(Z)) throw new LS.CredentialsProviderError("Invalid response received from instance metadata service.", {
          logger: A.logger
        });
        return w5Q(Z)
      }, B)
    }, "fromContainerMetadata"),
    OS4 = OX(async (A, Q) => {
      if (process.env[Sw1]) Q.headers = {
        ...Q.headers,
        Authorization: process.env[Sw1]
      };
      return (await A8A({
        ...Q,
        timeout: A
      })).toString()
    }, "requestFromEcsImds"),
    RS4 = "169.254.170.2",
    TS4 = {
      localhost: !0,
      "127.0.0.1": !0
    },
    PS4 = {
      "http:": !0,
      "https:": !0
    },
    jS4 = OX(async ({
      logger: A
    }) => {
      if (process.env[rhA]) return {
        hostname: RS4,
        path: process.env[rhA]
      };
      if (process.env[shA]) {
        let Q = (0, qS4.parse)(process.env[shA]);
        if (!Q.hostname || !(Q.hostname in TS4)) throw new LS.CredentialsProviderError(`${Q.hostname} is not a valid container metadata service hostname`, {
          tryNextLink: !1,
          logger: A
        });
        if (!Q.protocol || !(Q.protocol in PS4)) throw new LS.CredentialsProviderError(`${Q.protocol} is not a valid container metadata service protocol`, {
          tryNextLink: !1,
          logger: A
        });
        return {
          ...Q,
          port: Q.port ? parseInt(Q.port, 10) : void 0
        }
      }
      throw new LS.CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${rhA} or ${shA} environment variable is set`, {
        tryNextLink: !1,
        logger: A
      })
    }, "getCmdsUri"),
    SS4 = class A extends LS.CredentialsProviderError {
      constructor(Q, B = !0) {
        super(Q, B);
        this.tryNextLink = B, this.name = "InstanceMetadataV1FallbackError", Object.setPrototypeOf(this, A.prototype)
      }
      static {
        OX(this, "InstanceMetadataV1FallbackError")
      }
    },
    kw1 = uI(),
    _S4 = NJ(),
    L5Q = ((A) => {
      return A.IPv4 = "http://169.254.169.254", A.IPv6 = "http://[fd00:ec2::254]", A
    })(L5Q || {}),
    kS4 = "AWS_EC2_METADATA_SERVICE_ENDPOINT",
    yS4 = "ec2_metadata_service_endpoint",
    xS4 = {
      environmentVariableSelector: (A) => A[kS4],
      configFileSelector: (A) => A[yS4],
      default: void 0
    },
    M5Q = ((A) => {
      return A.IPv4 = "IPv4", A.IPv6 = "IPv6", A
    })(M5Q || {}),
    vS4 = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",
    bS4 = "ec2_metadata_service_endpoint_mode",
    fS4 = {
      environmentVariableSelector: (A) => A[vS4],
      configFileSelector: (A) => A[bS4],
      default: "IPv4"
    },
    O5Q = OX(async () => (0, _S4.parseUrl)(await hS4() || await gS4()), "getInstanceMetadataEndpoint"),
    hS4 = OX(async () => (0, kw1.loadConfig)(xS4)(), "getFromEndpointConfig"),
    gS4 = OX(async () => {
      let A = await (0, kw1.loadConfig)(fS4)();
      switch (A) {
        case "IPv4":
          return "http://169.254.169.254";
        case "IPv6":
          return "http://[fd00:ec2::254]";
        default:
          throw Error(`Unsupported endpoint mode: ${A}. Select from ${Object.values(M5Q)}`)
      }
    }, "getFromEndpointModeConfig"),
    uS4 = 300,
    mS4 = 300,
    dS4 = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html",
    C5Q = OX((A, Q) => {
      let B = uS4 + Math.floor(Math.random() * mS4),
        G = new Date(Date.now() + B * 1000);
      Q.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(G)}.
For more information, please visit: ` + dS4);
      let Z = A.originalExpiration ?? A.expiration;
      return {
        ...A,
        ...Z ? {
          originalExpiration: Z
        } : {},
        expiration: G
      }
    }, "getExtendedInstanceMetadataCredentials"),
    cS4 = OX((A, Q = {}) => {
      let B = Q?.logger || console,
        G;
      return async () => {
        let Z;
        try {
          if (Z = await A(), Z.expiration && Z.expiration.getTime() < Date.now()) Z = C5Q(Z, B)
        } catch (I) {
          if (G) B.warn("Credential renew failed: ", I), Z = C5Q(G, B);
          else throw I
        }
        return G = Z, Z
      }
    }, "staticStabilityProvider"),
    R5Q = "/latest/meta-data/iam/security-credentials/",
    pS4 = "/latest/api/token",
    Pw1 = "AWS_EC2_METADATA_V1_DISABLED",
    E5Q = "ec2_metadata_v1_disabled",
    z5Q = "x-aws-ec2-metadata-token",
    lS4 = OX((A = {}) => cS4(iS4(A), {
      logger: A.logger
    }), "fromInstanceMetadata"),
    iS4 = OX((A = {}) => {
      let Q = !1,
        {
          logger: B,
          profile: G
        } = A,
        {
          timeout: Z,
          maxRetries: I
        } = _w1(A),
        Y = OX(async (J, W) => {
          if (Q || W.headers?.[z5Q] == null) {
            let F = !1,
              K = !1,
              D = await (0, kw1.loadConfig)({
                environmentVariableSelector: (H) => {
                  let C = H[Pw1];
                  if (K = !!C && C !== "false", C === void 0) throw new LS.CredentialsProviderError(`${Pw1} not set in env, checking config file next.`, {
                    logger: A.logger
                  });
                  return K
                },
                configFileSelector: (H) => {
                  let C = H[E5Q];
                  return F = !!C && C !== "false", F
                },
                default: !1
              }, {
                profile: G
              })();
            if (A.ec2MetadataV1Disabled || D) {
              let H = [];
              if (A.ec2MetadataV1Disabled) H.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
              if (F) H.push(`config file profile (${E5Q})`);
              if (K) H.push(`process environment variable (${Pw1})`);
              throw new SS4(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${H.join(", ")}].`)
            }
          }
          let V = (await jw1(async () => {
            let F;
            try {
              F = await aS4(W)
            } catch (K) {
              if (K.statusCode === 401) Q = !1;
              throw K
            }
            return F
          }, J)).trim();
          return jw1(async () => {
            let F;
            try {
              F = await sS4(V, W, A)
            } catch (K) {
              if (K.statusCode === 401) Q = !1;
              throw K
            }
            return F
          }, J)
        }, "getCredentials");
      return async () => {
        let J = await O5Q();
        if (Q) return B?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)"), Y(I, {
          ...J,
          timeout: Z
        });
        else {
          let W;
          try {
            W = (await nS4({
              ...J,
              timeout: Z
            })).toString()
          } catch (X) {
            if (X?.statusCode === 400) throw Object.assign(X, {
              message: "EC2 Metadata token request returned error"
            });
            else if (X.message === "TimeoutError" || [403, 404, 405].includes(X.statusCode)) Q = !0;
            return B?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)"), Y(I, {
              ...J,
              timeout: Z
            })
          }
          return Y(I, {
            ...J,
            headers: {
              [z5Q]: W
            },
            timeout: Z
          })
        }
      }
    }, "getInstanceMetadataProvider"),
    nS4 = OX(async (A) => A8A({
      ...A,
      path: pS4,
      method: "PUT",
      headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600"
      }
    }), "getMetadataToken"),
    aS4 = OX(async (A) => (await A8A({
      ...A,
      path: R5Q
    })).toString(), "getProfile"),
    sS4 = OX(async (A, Q, B) => {
      let G = JSON.parse((await A8A({
        ...Q,
        path: R5Q + A
      })).toString());
      if (!$5Q(G)) throw new LS.CredentialsProviderError("Invalid response received from instance metadata service.", {
        logger: B.logger
      });
      return w5Q(G)
    }, "getCredentialsFromProfile")
})
// @from(Start 2717678, End 2718801)
S5Q = z((P5Q) => {
  Object.defineProperty(P5Q, "__esModule", {
    value: !0
  });
  P5Q.checkUrl = void 0;
  var rS4 = j2(),
    oS4 = "169.254.170.2",
    tS4 = "169.254.170.23",
    eS4 = "[fd00:ec2::23]",
    A_4 = (A, Q) => {
      if (A.protocol === "https:") return;
      if (A.hostname === oS4 || A.hostname === tS4 || A.hostname === eS4) return;
      if (A.hostname.includes("[")) {
        if (A.hostname === "[::1]" || A.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") return
      } else {
        if (A.hostname === "localhost") return;
        let B = A.hostname.split("."),
          G = (Z) => {
            let I = parseInt(Z, 10);
            return 0 <= I && I <= 255
          };
        if (B[0] === "127" && G(B[1]) && G(B[2]) && G(B[3]) && B.length === 4) return
      }
      throw new rS4.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, {
        logger: Q
      })
    };
  P5Q.checkUrl = A_4
})
// @from(Start 2718807, End 2720548)
k5Q = z((_5Q) => {
  Object.defineProperty(_5Q, "__esModule", {
    value: !0
  });
  _5Q.createGetRequest = Z_4;
  _5Q.getCredentials = I_4;
  var yw1 = j2(),
    Q_4 = nC(),
    B_4 = K6(),
    G_4 = Xd();

  function Z_4(A) {
    return new Q_4.HttpRequest({
      protocol: A.protocol,
      hostname: A.hostname,
      port: Number(A.port),
      path: A.pathname,
      query: Array.from(A.searchParams.entries()).reduce((Q, [B, G]) => {
        return Q[B] = G, Q
      }, {}),
      fragment: A.hash
    })
  }
  async function I_4(A, Q) {
    let G = await (0, G_4.sdkStreamMixin)(A.body).transformToString();
    if (A.statusCode === 200) {
      let Z = JSON.parse(G);
      if (typeof Z.AccessKeyId !== "string" || typeof Z.SecretAccessKey !== "string" || typeof Z.Token !== "string" || typeof Z.Expiration !== "string") throw new yw1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", {
        logger: Q
      });
      return {
        accessKeyId: Z.AccessKeyId,
        secretAccessKey: Z.SecretAccessKey,
        sessionToken: Z.Token,
        expiration: (0, B_4.parseRfc3339DateTime)(Z.Expiration)
      }
    }
    if (A.statusCode >= 400 && A.statusCode < 500) {
      let Z = {};
      try {
        Z = JSON.parse(G)
      } catch (I) {}
      throw Object.assign(new yw1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
        logger: Q
      }), {
        Code: Z.Code,
        Message: Z.Message
      })
    }
    throw new yw1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
      logger: Q
    })
  }
})
// @from(Start 2720554, End 2720924)
v5Q = z((y5Q) => {
  Object.defineProperty(y5Q, "__esModule", {
    value: !0
  });
  y5Q.retryWrapper = void 0;
  var W_4 = (A, Q, B) => {
    return async () => {
      for (let G = 0; G < Q; ++G) try {
        return await A()
      } catch (Z) {
        await new Promise((I) => setTimeout(I, B))
      }
      return await A()
    }
  };
  y5Q.retryWrapper = W_4
})
// @from(Start 2720930, End 2723417)
u5Q = z((h5Q) => {
  Object.defineProperty(h5Q, "__esModule", {
    value: !0
  });
  h5Q.fromHttp = void 0;
  var X_4 = yr(),
    V_4 = QL(),
    F_4 = IZ(),
    b5Q = j2(),
    K_4 = X_4.__importDefault(UA("fs/promises")),
    D_4 = S5Q(),
    f5Q = k5Q(),
    H_4 = v5Q(),
    C_4 = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    E_4 = "http://169.254.170.2",
    z_4 = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    U_4 = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",
    $_4 = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    w_4 = (A = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let Q, B = A.awsContainerCredentialsRelativeUri ?? process.env[C_4],
        G = A.awsContainerCredentialsFullUri ?? process.env[z_4],
        Z = A.awsContainerAuthorizationToken ?? process.env[$_4],
        I = A.awsContainerAuthorizationTokenFile ?? process.env[U_4],
        Y = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console.warn : A.logger.warn;
      if (B && G) Y("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."), Y("awsContainerCredentialsFullUri will take precedence.");
      if (Z && I) Y("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."), Y("awsContainerAuthorizationToken will take precedence.");
      if (G) Q = G;
      else if (B) Q = `${E_4}${B}`;
      else throw new b5Q.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, {
        logger: A.logger
      });
      let J = new URL(Q);
      (0, D_4.checkUrl)(J, A.logger);
      let W = new F_4.NodeHttpHandler({
        requestTimeout: A.timeout ?? 1000,
        connectionTimeout: A.timeout ?? 1000
      });
      return (0, H_4.retryWrapper)(async () => {
        let X = (0, f5Q.createGetRequest)(J);
        if (Z) X.headers.Authorization = Z;
        else if (I) X.headers.Authorization = (await K_4.default.readFile(I)).toString();
        try {
          let V = await W.handle(X);
          return (0, f5Q.getCredentials)(V.response).then((F) => (0, V_4.setCredentialFeature)(F, "CREDENTIALS_HTTP", "z"))
        } catch (V) {
          throw new b5Q.CredentialsProviderError(String(V), {
            logger: A.logger
          })
        }
      }, A.maxRetries ?? 3, A.timeout ?? 1000)
    };
  h5Q.fromHttp = w_4
})
// @from(Start 2723423, End 2723675)
vw1 = z((xw1) => {
  Object.defineProperty(xw1, "__esModule", {
    value: !0
  });
  xw1.fromHttp = void 0;
  var q_4 = u5Q();
  Object.defineProperty(xw1, "fromHttp", {
    enumerable: !0,
    get: function() {
      return q_4.fromHttp
    }
  })
})
// @from(Start 2723681, End 2725369)
fw1 = z((m5Q) => {
  Object.defineProperty(m5Q, "__esModule", {
    value: !0
  });
  m5Q.resolveHttpAuthSchemeConfig = m5Q.defaultSSOHttpAuthSchemeProvider = m5Q.defaultSSOHttpAuthSchemeParametersProvider = void 0;
  var L_4 = MF(),
    bw1 = w7(),
    M_4 = async (A, Q, B) => {
      return {
        operation: (0, bw1.getSmithyContext)(Q).operation,
        region: await (0, bw1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  m5Q.defaultSSOHttpAuthSchemeParametersProvider = M_4;

  function O_4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "awsssoportal",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function thA(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var R_4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "GetRoleCredentials": {
        Q.push(thA(A));
        break
      }
      case "ListAccountRoles": {
        Q.push(thA(A));
        break
      }
      case "ListAccounts": {
        Q.push(thA(A));
        break
      }
      case "Logout": {
        Q.push(thA(A));
        break
      }
      default:
        Q.push(O_4(A))
    }
    return Q
  };
  m5Q.defaultSSOHttpAuthSchemeProvider = R_4;
  var T_4 = (A) => {
    let Q = (0, L_4.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, bw1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  m5Q.resolveHttpAuthSchemeConfig = T_4
})
// @from(Start 2725375, End 2728963)
c5Q = z((sz7, S_4) => {
  S_4.exports = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.840.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  }
})
// @from(Start 2728969, End 2731145)
XHA = z((rz7, r5Q) => {
  var {
    defineProperty: AgA,
    getOwnPropertyDescriptor: __4,
    getOwnPropertyNames: k_4
  } = Object, y_4 = Object.prototype.hasOwnProperty, ehA = (A, Q) => AgA(A, "name", {
    value: Q,
    configurable: !0
  }), x_4 = (A, Q) => {
    for (var B in Q) AgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, v_4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of k_4(Q))
        if (!y_4.call(A, Z) && Z !== B) AgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = __4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, b_4 = (A) => v_4(AgA({}, "__esModule", {
    value: !0
  }), A), l5Q = {};
  x_4(l5Q, {
    NODE_APP_ID_CONFIG_OPTIONS: () => m_4,
    UA_APP_ID_ENV_NAME: () => a5Q,
    UA_APP_ID_INI_NAME: () => s5Q,
    createDefaultUserAgentProvider: () => n5Q,
    crtAvailability: () => i5Q,
    defaultUserAgent: () => h_4
  });
  r5Q.exports = b_4(l5Q);
  var p5Q = UA("os"),
    hw1 = UA("process"),
    i5Q = {
      isCrtAvailable: !1
    },
    f_4 = ehA(() => {
      if (i5Q.isCrtAvailable) return ["md/crt-avail"];
      return null
    }, "isCrtAvailable"),
    n5Q = ehA(({
      serviceId: A,
      clientVersion: Q
    }) => {
      return async (B) => {
        let G = [
            ["aws-sdk-js", Q],
            ["ua", "2.1"],
            [`os/${(0,p5Q.platform)()}`, (0, p5Q.release)()],
            ["lang/js"],
            ["md/nodejs", `${hw1.versions.node}`]
          ],
          Z = f_4();
        if (Z) G.push(Z);
        if (A) G.push([`api/${A}`, Q]);
        if (hw1.env.AWS_EXECUTION_ENV) G.push([`exec-env/${hw1.env.AWS_EXECUTION_ENV}`]);
        let I = await B?.userAgentAppId?.();
        return I ? [...G, [`app/${I}`]] : [...G]
      }
    }, "createDefaultUserAgentProvider"),
    h_4 = n5Q,
    g_4 = r4A(),
    a5Q = "AWS_SDK_UA_APP_ID",
    s5Q = "sdk_ua_app_id",
    u_4 = "sdk-ua-app-id",
    m_4 = {
      environmentVariableSelector: ehA((A) => A[a5Q], "environmentVariableSelector"),
      configFileSelector: ehA((A) => A[s5Q] ?? A[u_4], "configFileSelector"),
      default: g_4.DEFAULT_UA_APP_ID
    }
})
// @from(Start 2731151, End 2732824)
RX = z((oz7, A3Q) => {
  var {
    defineProperty: QgA,
    getOwnPropertyDescriptor: d_4,
    getOwnPropertyNames: c_4
  } = Object, p_4 = Object.prototype.hasOwnProperty, t5Q = (A, Q) => QgA(A, "name", {
    value: Q,
    configurable: !0
  }), l_4 = (A, Q) => {
    for (var B in Q) QgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, i_4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of c_4(Q))
        if (!p_4.call(A, Z) && Z !== B) QgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = d_4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, n_4 = (A) => i_4(QgA({}, "__esModule", {
    value: !0
  }), A), e5Q = {};
  l_4(e5Q, {
    Hash: () => r_4
  });
  A3Q.exports = n_4(e5Q);
  var gw1 = hI(),
    a_4 = O2(),
    s_4 = UA("buffer"),
    o5Q = UA("crypto"),
    r_4 = class {
      static {
        t5Q(this, "Hash")
      }
      constructor(A, Q) {
        this.algorithmIdentifier = A, this.secret = Q, this.reset()
      }
      update(A, Q) {
        this.hash.update((0, a_4.toUint8Array)(uw1(A, Q)))
      }
      digest() {
        return Promise.resolve(this.hash.digest())
      }
      reset() {
        this.hash = this.secret ? (0, o5Q.createHmac)(this.algorithmIdentifier, uw1(this.secret)) : (0, o5Q.createHash)(this.algorithmIdentifier)
      }
    };

  function uw1(A, Q) {
    if (s_4.Buffer.isBuffer(A)) return A;
    if (typeof A === "string") return (0, gw1.fromString)(A, Q);
    if (ArrayBuffer.isView(A)) return (0, gw1.fromArrayBuffer)(A.buffer, A.byteOffset, A.byteLength);
    return (0, gw1.fromArrayBuffer)(A)
  }
  t5Q(uw1, "castSourceData")
})
// @from(Start 2732830, End 2734261)
TX = z((ez7, G3Q) => {
  var {
    defineProperty: BgA,
    getOwnPropertyDescriptor: o_4,
    getOwnPropertyNames: t_4
  } = Object, e_4 = Object.prototype.hasOwnProperty, Ak4 = (A, Q) => BgA(A, "name", {
    value: Q,
    configurable: !0
  }), Qk4 = (A, Q) => {
    for (var B in Q) BgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Bk4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of t_4(Q))
        if (!e_4.call(A, Z) && Z !== B) BgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = o_4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Gk4 = (A) => Bk4(BgA({}, "__esModule", {
    value: !0
  }), A), B3Q = {};
  Qk4(B3Q, {
    calculateBodyLength: () => Zk4
  });
  G3Q.exports = Gk4(B3Q);
  var Q3Q = UA("fs"),
    Zk4 = Ak4((A) => {
      if (!A) return 0;
      if (typeof A === "string") return Buffer.byteLength(A);
      else if (typeof A.byteLength === "number") return A.byteLength;
      else if (typeof A.size === "number") return A.size;
      else if (typeof A.start === "number" && typeof A.end === "number") return A.end + 1 - A.start;
      else if (typeof A.path === "string" || Buffer.isBuffer(A.path)) return (0, Q3Q.lstatSync)(A.path).size;
      else if (typeof A.fd === "number") return (0, Q3Q.fstatSync)(A.fd).size;
      throw Error(`Body Length computation failed for ${A}`)
    }, "calculateBodyLength")
})
// @from(Start 2734267, End 2738964)
w3Q = z((U3Q) => {
  Object.defineProperty(U3Q, "__esModule", {
    value: !0
  });
  U3Q.ruleSet = void 0;
  var H3Q = "required",
    JL = "fn",
    WL = "argv",
    G8A = "ref",
    Z3Q = !0,
    I3Q = "isSet",
    VHA = "booleanEquals",
    Q8A = "error",
    B8A = "endpoint",
    Ov = "tree",
    mw1 = "PartitionResult",
    dw1 = "getAttr",
    Y3Q = {
      [H3Q]: !1,
      type: "String"
    },
    J3Q = {
      [H3Q]: !0,
      default: !1,
      type: "Boolean"
    },
    W3Q = {
      [G8A]: "Endpoint"
    },
    C3Q = {
      [JL]: VHA,
      [WL]: [{
        [G8A]: "UseFIPS"
      }, !0]
    },
    E3Q = {
      [JL]: VHA,
      [WL]: [{
        [G8A]: "UseDualStack"
      }, !0]
    },
    YL = {},
    X3Q = {
      [JL]: dw1,
      [WL]: [{
        [G8A]: mw1
      }, "supportsFIPS"]
    },
    z3Q = {
      [G8A]: mw1
    },
    V3Q = {
      [JL]: VHA,
      [WL]: [!0, {
        [JL]: dw1,
        [WL]: [z3Q, "supportsDualStack"]
      }]
    },
    F3Q = [C3Q],
    K3Q = [E3Q],
    D3Q = [{
      [G8A]: "Region"
    }],
    Ik4 = {
      version: "1.0",
      parameters: {
        Region: Y3Q,
        UseDualStack: J3Q,
        UseFIPS: J3Q,
        Endpoint: Y3Q
      },
      rules: [{
        conditions: [{
          [JL]: I3Q,
          [WL]: [W3Q]
        }],
        rules: [{
          conditions: F3Q,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: Q8A
        }, {
          conditions: K3Q,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: Q8A
        }, {
          endpoint: {
            url: W3Q,
            properties: YL,
            headers: YL
          },
          type: B8A
        }],
        type: Ov
      }, {
        conditions: [{
          [JL]: I3Q,
          [WL]: D3Q
        }],
        rules: [{
          conditions: [{
            [JL]: "aws.partition",
            [WL]: D3Q,
            assign: mw1
          }],
          rules: [{
            conditions: [C3Q, E3Q],
            rules: [{
              conditions: [{
                [JL]: VHA,
                [WL]: [Z3Q, X3Q]
              }, V3Q],
              rules: [{
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: YL,
                  headers: YL
                },
                type: B8A
              }],
              type: Ov
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: Q8A
            }],
            type: Ov
          }, {
            conditions: F3Q,
            rules: [{
              conditions: [{
                [JL]: VHA,
                [WL]: [X3Q, Z3Q]
              }],
              rules: [{
                conditions: [{
                  [JL]: "stringEquals",
                  [WL]: [{
                    [JL]: dw1,
                    [WL]: [z3Q, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://portal.sso.{Region}.amazonaws.com",
                  properties: YL,
                  headers: YL
                },
                type: B8A
              }, {
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: YL,
                  headers: YL
                },
                type: B8A
              }],
              type: Ov
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: Q8A
            }],
            type: Ov
          }, {
            conditions: K3Q,
            rules: [{
              conditions: [V3Q],
              rules: [{
                endpoint: {
                  url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: YL,
                  headers: YL
                },
                type: B8A
              }],
              type: Ov
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: Q8A
            }],
            type: Ov
          }, {
            endpoint: {
              url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
              properties: YL,
              headers: YL
            },
            type: B8A
          }],
          type: Ov
        }],
        type: Ov
      }, {
        error: "Invalid Configuration: Missing Region",
        type: Q8A
      }]
    };
  U3Q.ruleSet = Ik4
})
// @from(Start 2738970, End 2739534)
L3Q = z((q3Q) => {
  Object.defineProperty(q3Q, "__esModule", {
    value: !0
  });
  q3Q.defaultEndpointResolver = void 0;
  var Yk4 = p4A(),
    cw1 = FI(),
    Jk4 = w3Q(),
    Wk4 = new cw1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    Xk4 = (A, Q = {}) => {
      return Wk4.get(A, () => (0, cw1.resolveEndpoint)(Jk4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  q3Q.defaultEndpointResolver = Xk4;
  cw1.customEndpointFunctions.aws = Yk4.awsEndpointFunctions
})
// @from(Start 2739540, End 2740949)
P3Q = z((R3Q) => {
  Object.defineProperty(R3Q, "__esModule", {
    value: !0
  });
  R3Q.getRuntimeConfig = void 0;
  var Vk4 = MF(),
    Fk4 = iB(),
    Kk4 = K6(),
    Dk4 = NJ(),
    M3Q = Fd(),
    O3Q = O2(),
    Hk4 = fw1(),
    Ck4 = L3Q(),
    Ek4 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? M3Q.fromBase64,
        base64Encoder: A?.base64Encoder ?? M3Q.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? Ck4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Hk4.defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Vk4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Fk4.NoAuthSigner
        }],
        logger: A?.logger ?? new Kk4.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO",
        urlParser: A?.urlParser ?? Dk4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? O3Q.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? O3Q.toUtf8
      }
    };
  R3Q.getRuntimeConfig = Ek4
})
// @from(Start 2740955, End 2743993)
PX = z((GU7, x3Q) => {
  var {
    create: zk4,
    defineProperty: FHA,
    getOwnPropertyDescriptor: Uk4,
    getOwnPropertyNames: $k4,
    getPrototypeOf: wk4
  } = Object, qk4 = Object.prototype.hasOwnProperty, pw1 = (A, Q) => FHA(A, "name", {
    value: Q,
    configurable: !0
  }), Nk4 = (A, Q) => {
    for (var B in Q) FHA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, k3Q = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of $k4(Q))
        if (!qk4.call(A, Z) && Z !== B) FHA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Uk4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Lk4 = (A, Q, B) => (B = A != null ? zk4(wk4(A)) : {}, k3Q(Q || !A || !A.__esModule ? FHA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), Mk4 = (A) => k3Q(FHA({}, "__esModule", {
    value: !0
  }), A), y3Q = {};
  Nk4(y3Q, {
    resolveDefaultsModeConfig: () => xk4
  });
  x3Q.exports = Mk4(y3Q);
  var Ok4 = f8(),
    j3Q = uI(),
    Rk4 = j2(),
    Tk4 = "AWS_EXECUTION_ENV",
    S3Q = "AWS_REGION",
    _3Q = "AWS_DEFAULT_REGION",
    Pk4 = "AWS_EC2_METADATA_DISABLED",
    jk4 = ["in-region", "cross-region", "mobile", "standard", "legacy"],
    Sk4 = "/latest/meta-data/placement/region",
    _k4 = "AWS_DEFAULTS_MODE",
    kk4 = "defaults_mode",
    yk4 = {
      environmentVariableSelector: (A) => {
        return A[_k4]
      },
      configFileSelector: (A) => {
        return A[kk4]
      },
      default: "legacy"
    },
    xk4 = pw1(({
      region: A = (0, j3Q.loadConfig)(Ok4.NODE_REGION_CONFIG_OPTIONS),
      defaultsMode: Q = (0, j3Q.loadConfig)(yk4)
    } = {}) => (0, Rk4.memoize)(async () => {
      let B = typeof Q === "function" ? await Q() : Q;
      switch (B?.toLowerCase()) {
        case "auto":
          return vk4(A);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
          return Promise.resolve(B?.toLocaleLowerCase());
        case void 0:
          return Promise.resolve("legacy");
        default:
          throw Error(`Invalid parameter for "defaultsMode", expect ${jk4.join(", ")}, got ${B}`)
      }
    }), "resolveDefaultsModeConfig"),
    vk4 = pw1(async (A) => {
      if (A) {
        let Q = typeof A === "function" ? await A() : A,
          B = await bk4();
        if (!B) return "standard";
        if (Q === B) return "in-region";
        else return "cross-region"
      }
      return "standard"
    }, "resolveNodeDefaultsModeAuto"),
    bk4 = pw1(async () => {
      if (process.env[Tk4] && (process.env[S3Q] || process.env[_3Q])) return process.env[S3Q] ?? process.env[_3Q];
      if (!process.env[Pk4]) try {
        let {
          getInstanceMetadataEndpoint: A,
          httpRequest: Q
        } = await Promise.resolve().then(() => Lk4(OV())), B = await A();
        return (await Q({
          ...B,
          path: Sk4
        })).toString()
      } catch (A) {}
    }, "inferPhysicalRegion")
})
// @from(Start 2743999, End 2746298)
m3Q = z((g3Q) => {
  Object.defineProperty(g3Q, "__esModule", {
    value: !0
  });
  g3Q.getRuntimeConfig = void 0;
  var fk4 = yr(),
    hk4 = fk4.__importDefault(c5Q()),
    v3Q = MF(),
    b3Q = XHA(),
    GgA = f8(),
    gk4 = RX(),
    f3Q = D6(),
    dr = uI(),
    h3Q = IZ(),
    uk4 = TX(),
    mk4 = KW(),
    dk4 = P3Q(),
    ck4 = K6(),
    pk4 = PX(),
    lk4 = K6(),
    ik4 = (A) => {
      (0, lk4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, pk4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(ck4.loadConfigsForDefaultMode),
        G = (0, dk4.getRuntimeConfig)(A);
      (0, v3Q.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, dr.loadConfig)(v3Q.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? uk4.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, b3Q.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: hk4.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, dr.loadConfig)(f3Q.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, dr.loadConfig)(GgA.NODE_REGION_CONFIG_OPTIONS, {
          ...GgA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: h3Q.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, dr.loadConfig)({
          ...f3Q.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || mk4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? gk4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? h3Q.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, dr.loadConfig)(GgA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, dr.loadConfig)(GgA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, dr.loadConfig)(b3Q.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  g3Q.getRuntimeConfig = ik4
})
// @from(Start 2746304, End 2748907)
KHA = z((IU7, n3Q) => {
  var {
    defineProperty: ZgA,
    getOwnPropertyDescriptor: nk4,
    getOwnPropertyNames: ak4
  } = Object, sk4 = Object.prototype.hasOwnProperty, MS = (A, Q) => ZgA(A, "name", {
    value: Q,
    configurable: !0
  }), rk4 = (A, Q) => {
    for (var B in Q) ZgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ok4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ak4(Q))
        if (!sk4.call(A, Z) && Z !== B) ZgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = nk4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, tk4 = (A) => ok4(ZgA({}, "__esModule", {
    value: !0
  }), A), c3Q = {};
  rk4(c3Q, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => By4,
    NODE_REGION_CONFIG_OPTIONS: () => Qy4,
    REGION_ENV_NAME: () => p3Q,
    REGION_INI_NAME: () => l3Q,
    getAwsRegionExtensionConfiguration: () => ek4,
    resolveAwsRegionExtensionConfiguration: () => Ay4,
    resolveRegionConfig: () => Gy4
  });
  n3Q.exports = tk4(c3Q);
  var ek4 = MS((A) => {
      return {
        setRegion(Q) {
          A.region = Q
        },
        region() {
          return A.region
        }
      }
    }, "getAwsRegionExtensionConfiguration"),
    Ay4 = MS((A) => {
      return {
        region: A.region()
      }
    }, "resolveAwsRegionExtensionConfiguration"),
    p3Q = "AWS_REGION",
    l3Q = "region",
    Qy4 = {
      environmentVariableSelector: MS((A) => A[p3Q], "environmentVariableSelector"),
      configFileSelector: MS((A) => A[l3Q], "configFileSelector"),
      default: MS(() => {
        throw Error("Region is missing")
      }, "default")
    },
    By4 = {
      preferredFile: "credentials"
    },
    i3Q = MS((A) => typeof A === "string" && (A.startsWith("fips-") || A.endsWith("-fips")), "isFipsRegion"),
    d3Q = MS((A) => i3Q(A) ? ["fips-aws-global", "aws-fips"].includes(A) ? "us-east-1" : A.replace(/fips-(dkr-|prod-)?|-fips/, "") : A, "getRealRegion"),
    Gy4 = MS((A) => {
      let {
        region: Q,
        useFipsEndpoint: B
      } = A;
      if (!Q) throw Error("Region is missing");
      return Object.assign(A, {
        region: MS(async () => {
          if (typeof Q === "string") return d3Q(Q);
          let G = await Q();
          return d3Q(G)
        }, "region"),
        useFipsEndpoint: MS(async () => {
          let G = typeof Q === "string" ? Q : await Q();
          if (i3Q(G)) return !0;
          return typeof B !== "function" ? Promise.resolve(!!B) : B()
        }, "useFipsEndpoint")
      })
    }, "resolveRegionConfig")
})
// @from(Start 2748913, End 2765461)
q7Q = z((YU7, w7Q) => {
  var {
    defineProperty: IgA,
    getOwnPropertyDescriptor: Zy4,
    getOwnPropertyNames: Iy4
  } = Object, Yy4 = Object.prototype.hasOwnProperty, N5 = (A, Q) => IgA(A, "name", {
    value: Q,
    configurable: !0
  }), Jy4 = (A, Q) => {
    for (var B in Q) IgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Wy4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Iy4(Q))
        if (!Yy4.call(A, Z) && Z !== B) IgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Zy4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Xy4 = (A) => Wy4(IgA({}, "__esModule", {
    value: !0
  }), A), A7Q = {};
  Jy4(A7Q, {
    GetRoleCredentialsCommand: () => z7Q,
    GetRoleCredentialsRequestFilterSensitiveLog: () => I7Q,
    GetRoleCredentialsResponseFilterSensitiveLog: () => J7Q,
    InvalidRequestException: () => Q7Q,
    ListAccountRolesCommand: () => lw1,
    ListAccountRolesRequestFilterSensitiveLog: () => W7Q,
    ListAccountsCommand: () => iw1,
    ListAccountsRequestFilterSensitiveLog: () => X7Q,
    LogoutCommand: () => U7Q,
    LogoutRequestFilterSensitiveLog: () => V7Q,
    ResourceNotFoundException: () => B7Q,
    RoleCredentialsFilterSensitiveLog: () => Y7Q,
    SSO: () => $7Q,
    SSOClient: () => JgA,
    SSOServiceException: () => Z8A,
    TooManyRequestsException: () => G7Q,
    UnauthorizedException: () => Z7Q,
    __Client: () => X2.Client,
    paginateListAccountRoles: () => vy4,
    paginateListAccounts: () => by4
  });
  w7Q.exports = Xy4(A7Q);
  var a3Q = yDA(),
    Vy4 = xDA(),
    Fy4 = vDA(),
    s3Q = r4A(),
    Ky4 = f8(),
    Rv = iB(),
    Dy4 = LX(),
    HHA = q5(),
    r3Q = D6(),
    o3Q = fw1(),
    Hy4 = N5((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal"
      })
    }, "resolveClientEndpointParameters"),
    YgA = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    Cy4 = m3Q(),
    t3Q = KHA(),
    e3Q = nC(),
    X2 = K6(),
    Ey4 = N5((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    zy4 = N5((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    Uy4 = N5((A, Q) => {
      let B = Object.assign((0, t3Q.getAwsRegionExtensionConfiguration)(A), (0, X2.getDefaultExtensionConfiguration)(A), (0, e3Q.getHttpHandlerExtensionConfiguration)(A), Ey4(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, t3Q.resolveAwsRegionExtensionConfiguration)(B), (0, X2.resolveDefaultRuntimeConfig)(B), (0, e3Q.resolveHttpHandlerRuntimeConfig)(B), zy4(B))
    }, "resolveRuntimeExtensions"),
    JgA = class extends X2.Client {
      static {
        N5(this, "SSOClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, Cy4.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = Hy4(Q),
          G = (0, s3Q.resolveUserAgentConfig)(B),
          Z = (0, r3Q.resolveRetryConfig)(G),
          I = (0, Ky4.resolveRegionConfig)(Z),
          Y = (0, a3Q.resolveHostHeaderConfig)(I),
          J = (0, HHA.resolveEndpointConfig)(Y),
          W = (0, o3Q.resolveHttpAuthSchemeConfig)(J),
          X = Uy4(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, s3Q.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, r3Q.getRetryPlugin)(this.config)), this.middlewareStack.use((0, Dy4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, a3Q.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, Vy4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, Fy4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, Rv.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: o3Q.defaultSSOHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: N5(async (V) => new Rv.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, Rv.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    WgA = GZ(),
    Z8A = class A extends X2.ServiceException {
      static {
        N5(this, "SSOServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    Q7Q = class A extends Z8A {
      static {
        N5(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    B7Q = class A extends Z8A {
      static {
        N5(this, "ResourceNotFoundException")
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    G7Q = class A extends Z8A {
      static {
        N5(this, "TooManyRequestsException")
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    Z7Q = class A extends Z8A {
      static {
        N5(this, "UnauthorizedException")
      }
      name = "UnauthorizedException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    I7Q = N5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: X2.SENSITIVE_STRING
      }
    }), "GetRoleCredentialsRequestFilterSensitiveLog"),
    Y7Q = N5((A) => ({
      ...A,
      ...A.secretAccessKey && {
        secretAccessKey: X2.SENSITIVE_STRING
      },
      ...A.sessionToken && {
        sessionToken: X2.SENSITIVE_STRING
      }
    }), "RoleCredentialsFilterSensitiveLog"),
    J7Q = N5((A) => ({
      ...A,
      ...A.roleCredentials && {
        roleCredentials: Y7Q(A.roleCredentials)
      }
    }), "GetRoleCredentialsResponseFilterSensitiveLog"),
    W7Q = N5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: X2.SENSITIVE_STRING
      }
    }), "ListAccountRolesRequestFilterSensitiveLog"),
    X7Q = N5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: X2.SENSITIVE_STRING
      }
    }), "ListAccountsRequestFilterSensitiveLog"),
    V7Q = N5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: X2.SENSITIVE_STRING
      }
    }), "LogoutRequestFilterSensitiveLog"),
    DHA = MF(),
    $y4 = N5(async (A, Q) => {
      let B = (0, Rv.requestBuilder)(A, Q),
        G = (0, X2.map)({}, X2.isSerializableHeaderValue, {
          [FgA]: A[VgA]
        });
      B.bp("/federation/credentials");
      let Z = (0, X2.map)({
          [yy4]: [, (0, X2.expectNonNull)(A[ky4], "roleName")],
          [K7Q]: [, (0, X2.expectNonNull)(A[F7Q], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_GetRoleCredentialsCommand"),
    wy4 = N5(async (A, Q) => {
      let B = (0, Rv.requestBuilder)(A, Q),
        G = (0, X2.map)({}, X2.isSerializableHeaderValue, {
          [FgA]: A[VgA]
        });
      B.bp("/assignment/roles");
      let Z = (0, X2.map)({
          [E7Q]: [, A[C7Q]],
          [H7Q]: [() => A.maxResults !== void 0, () => A[D7Q].toString()],
          [K7Q]: [, (0, X2.expectNonNull)(A[F7Q], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountRolesCommand"),
    qy4 = N5(async (A, Q) => {
      let B = (0, Rv.requestBuilder)(A, Q),
        G = (0, X2.map)({}, X2.isSerializableHeaderValue, {
          [FgA]: A[VgA]
        });
      B.bp("/assignment/accounts");
      let Z = (0, X2.map)({
          [E7Q]: [, A[C7Q]],
          [H7Q]: [() => A.maxResults !== void 0, () => A[D7Q].toString()]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountsCommand"),
    Ny4 = N5(async (A, Q) => {
      let B = (0, Rv.requestBuilder)(A, Q),
        G = (0, X2.map)({}, X2.isSerializableHeaderValue, {
          [FgA]: A[VgA]
        });
      B.bp("/logout");
      let Z;
      return B.m("POST").h(G).b(Z), B.build()
    }, "se_LogoutCommand"),
    Ly4 = N5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return XgA(A, Q);
      let B = (0, X2.map)({
          $metadata: $d(A)
        }),
        G = (0, X2.expectNonNull)((0, X2.expectObject)(await (0, DHA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, X2.take)(G, {
          roleCredentials: X2._json
        });
      return Object.assign(B, Z), B
    }, "de_GetRoleCredentialsCommand"),
    My4 = N5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return XgA(A, Q);
      let B = (0, X2.map)({
          $metadata: $d(A)
        }),
        G = (0, X2.expectNonNull)((0, X2.expectObject)(await (0, DHA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, X2.take)(G, {
          nextToken: X2.expectString,
          roleList: X2._json
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountRolesCommand"),
    Oy4 = N5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return XgA(A, Q);
      let B = (0, X2.map)({
          $metadata: $d(A)
        }),
        G = (0, X2.expectNonNull)((0, X2.expectObject)(await (0, DHA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, X2.take)(G, {
          accountList: X2._json,
          nextToken: X2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountsCommand"),
    Ry4 = N5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return XgA(A, Q);
      let B = (0, X2.map)({
        $metadata: $d(A)
      });
      return await (0, X2.collectBody)(A.body, Q), B
    }, "de_LogoutCommand"),
    XgA = N5(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, DHA.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, DHA.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await Py4(B, Q);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await jy4(B, Q);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await Sy4(B, Q);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await _y4(B, Q);
        default:
          let Z = B.body;
          return Ty4({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    Ty4 = (0, X2.withBaseException)(Z8A),
    Py4 = N5(async (A, Q) => {
      let B = (0, X2.map)({}),
        G = A.body,
        Z = (0, X2.take)(G, {
          message: X2.expectString
        });
      Object.assign(B, Z);
      let I = new Q7Q({
        $metadata: $d(A),
        ...B
      });
      return (0, X2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    jy4 = N5(async (A, Q) => {
      let B = (0, X2.map)({}),
        G = A.body,
        Z = (0, X2.take)(G, {
          message: X2.expectString
        });
      Object.assign(B, Z);
      let I = new B7Q({
        $metadata: $d(A),
        ...B
      });
      return (0, X2.decorateServiceException)(I, A.body)
    }, "de_ResourceNotFoundExceptionRes"),
    Sy4 = N5(async (A, Q) => {
      let B = (0, X2.map)({}),
        G = A.body,
        Z = (0, X2.take)(G, {
          message: X2.expectString
        });
      Object.assign(B, Z);
      let I = new G7Q({
        $metadata: $d(A),
        ...B
      });
      return (0, X2.decorateServiceException)(I, A.body)
    }, "de_TooManyRequestsExceptionRes"),
    _y4 = N5(async (A, Q) => {
      let B = (0, X2.map)({}),
        G = A.body,
        Z = (0, X2.take)(G, {
          message: X2.expectString
        });
      Object.assign(B, Z);
      let I = new Z7Q({
        $metadata: $d(A),
        ...B
      });
      return (0, X2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedExceptionRes"),
    $d = N5((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    F7Q = "accountId",
    VgA = "accessToken",
    K7Q = "account_id",
    D7Q = "maxResults",
    H7Q = "max_result",
    C7Q = "nextToken",
    E7Q = "next_token",
    ky4 = "roleName",
    yy4 = "role_name",
    FgA = "x-amz-sso_bearer_token",
    z7Q = class extends X2.Command.classBuilder().ep(YgA).m(function(A, Q, B, G) {
      return [(0, WgA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, HHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(I7Q, J7Q).ser($y4).de(Ly4).build() {
      static {
        N5(this, "GetRoleCredentialsCommand")
      }
    },
    lw1 = class extends X2.Command.classBuilder().ep(YgA).m(function(A, Q, B, G) {
      return [(0, WgA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, HHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(W7Q, void 0).ser(wy4).de(My4).build() {
      static {
        N5(this, "ListAccountRolesCommand")
      }
    },
    iw1 = class extends X2.Command.classBuilder().ep(YgA).m(function(A, Q, B, G) {
      return [(0, WgA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, HHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(X7Q, void 0).ser(qy4).de(Oy4).build() {
      static {
        N5(this, "ListAccountsCommand")
      }
    },
    U7Q = class extends X2.Command.classBuilder().ep(YgA).m(function(A, Q, B, G) {
      return [(0, WgA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, HHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(V7Q, void 0).ser(Ny4).de(Ry4).build() {
      static {
        N5(this, "LogoutCommand")
      }
    },
    xy4 = {
      GetRoleCredentialsCommand: z7Q,
      ListAccountRolesCommand: lw1,
      ListAccountsCommand: iw1,
      LogoutCommand: U7Q
    },
    $7Q = class extends JgA {
      static {
        N5(this, "SSO")
      }
    };
  (0, X2.createAggregatedClient)(xy4, $7Q);
  var vy4 = (0, Rv.createPaginator)(JgA, lw1, "nextToken", "nextToken", "maxResults"),
    by4 = (0, Rv.createPaginator)(JgA, iw1, "nextToken", "nextToken", "maxResults")
})
// @from(Start 2765467, End 2766938)
aw1 = z((N7Q) => {
  Object.defineProperty(N7Q, "__esModule", {
    value: !0
  });
  N7Q.resolveHttpAuthSchemeConfig = N7Q.defaultSSOOIDCHttpAuthSchemeProvider = N7Q.defaultSSOOIDCHttpAuthSchemeParametersProvider = void 0;
  var fy4 = MF(),
    nw1 = w7(),
    hy4 = async (A, Q, B) => {
      return {
        operation: (0, nw1.getSmithyContext)(Q).operation,
        region: await (0, nw1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  N7Q.defaultSSOOIDCHttpAuthSchemeParametersProvider = hy4;

  function gy4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function uy4(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var my4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "CreateToken": {
        Q.push(uy4(A));
        break
      }
      default:
        Q.push(gy4(A))
    }
    return Q
  };
  N7Q.defaultSSOOIDCHttpAuthSchemeProvider = my4;
  var dy4 = (A) => {
    let Q = (0, fy4.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, nw1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  N7Q.resolveHttpAuthSchemeConfig = dy4
})
// @from(Start 2766944, End 2771229)
sw1 = z((HU7, ly4) => {
  ly4.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.840.0",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=18.0.0"
    },
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["./sso-oidc.d.ts", "./sso-oidc.js", "./sts.d.ts", "./sts.js", "dist-*/**"],
    browser: {
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./sso-oidc": {
        types: "./dist-types/submodules/sso-oidc/index.d.ts",
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js"
      },
      "./sts": {
        types: "./dist-types/submodules/sts/index.d.ts",
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js"
      }
    }
  }
})
// @from(Start 2771235, End 2775902)
u7Q = z((h7Q) => {
  Object.defineProperty(h7Q, "__esModule", {
    value: !0
  });
  h7Q.ruleSet = void 0;
  var x7Q = "required",
    VL = "fn",
    FL = "argv",
    J8A = "ref",
    M7Q = !0,
    O7Q = "isSet",
    CHA = "booleanEquals",
    I8A = "error",
    Y8A = "endpoint",
    Tv = "tree",
    rw1 = "PartitionResult",
    ow1 = "getAttr",
    R7Q = {
      [x7Q]: !1,
      type: "String"
    },
    T7Q = {
      [x7Q]: !0,
      default: !1,
      type: "Boolean"
    },
    P7Q = {
      [J8A]: "Endpoint"
    },
    v7Q = {
      [VL]: CHA,
      [FL]: [{
        [J8A]: "UseFIPS"
      }, !0]
    },
    b7Q = {
      [VL]: CHA,
      [FL]: [{
        [J8A]: "UseDualStack"
      }, !0]
    },
    XL = {},
    j7Q = {
      [VL]: ow1,
      [FL]: [{
        [J8A]: rw1
      }, "supportsFIPS"]
    },
    f7Q = {
      [J8A]: rw1
    },
    S7Q = {
      [VL]: CHA,
      [FL]: [!0, {
        [VL]: ow1,
        [FL]: [f7Q, "supportsDualStack"]
      }]
    },
    _7Q = [v7Q],
    k7Q = [b7Q],
    y7Q = [{
      [J8A]: "Region"
    }],
    iy4 = {
      version: "1.0",
      parameters: {
        Region: R7Q,
        UseDualStack: T7Q,
        UseFIPS: T7Q,
        Endpoint: R7Q
      },
      rules: [{
        conditions: [{
          [VL]: O7Q,
          [FL]: [P7Q]
        }],
        rules: [{
          conditions: _7Q,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: I8A
        }, {
          conditions: k7Q,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: I8A
        }, {
          endpoint: {
            url: P7Q,
            properties: XL,
            headers: XL
          },
          type: Y8A
        }],
        type: Tv
      }, {
        conditions: [{
          [VL]: O7Q,
          [FL]: y7Q
        }],
        rules: [{
          conditions: [{
            [VL]: "aws.partition",
            [FL]: y7Q,
            assign: rw1
          }],
          rules: [{
            conditions: [v7Q, b7Q],
            rules: [{
              conditions: [{
                [VL]: CHA,
                [FL]: [M7Q, j7Q]
              }, S7Q],
              rules: [{
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: XL,
                  headers: XL
                },
                type: Y8A
              }],
              type: Tv
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: I8A
            }],
            type: Tv
          }, {
            conditions: _7Q,
            rules: [{
              conditions: [{
                [VL]: CHA,
                [FL]: [j7Q, M7Q]
              }],
              rules: [{
                conditions: [{
                  [VL]: "stringEquals",
                  [FL]: [{
                    [VL]: ow1,
                    [FL]: [f7Q, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://oidc.{Region}.amazonaws.com",
                  properties: XL,
                  headers: XL
                },
                type: Y8A
              }, {
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: XL,
                  headers: XL
                },
                type: Y8A
              }],
              type: Tv
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: I8A
            }],
            type: Tv
          }, {
            conditions: k7Q,
            rules: [{
              conditions: [S7Q],
              rules: [{
                endpoint: {
                  url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: XL,
                  headers: XL
                },
                type: Y8A
              }],
              type: Tv
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: I8A
            }],
            type: Tv
          }, {
            endpoint: {
              url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
              properties: XL,
              headers: XL
            },
            type: Y8A
          }],
          type: Tv
        }],
        type: Tv
      }, {
        error: "Invalid Configuration: Missing Region",
        type: I8A
      }]
    };
  h7Q.ruleSet = iy4
})
// @from(Start 2775908, End 2776472)
c7Q = z((m7Q) => {
  Object.defineProperty(m7Q, "__esModule", {
    value: !0
  });
  m7Q.defaultEndpointResolver = void 0;
  var ny4 = p4A(),
    tw1 = FI(),
    ay4 = u7Q(),
    sy4 = new tw1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    ry4 = (A, Q = {}) => {
      return sy4.get(A, () => (0, tw1.resolveEndpoint)(ay4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  m7Q.defaultEndpointResolver = ry4;
  tw1.customEndpointFunctions.aws = ny4.awsEndpointFunctions
})
// @from(Start 2776478, End 2777896)
a7Q = z((i7Q) => {
  Object.defineProperty(i7Q, "__esModule", {
    value: !0
  });
  i7Q.getRuntimeConfig = void 0;
  var oy4 = MF(),
    ty4 = iB(),
    ey4 = K6(),
    Ax4 = NJ(),
    p7Q = Fd(),
    l7Q = O2(),
    Qx4 = aw1(),
    Bx4 = c7Q(),
    Gx4 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? p7Q.fromBase64,
        base64Encoder: A?.base64Encoder ?? p7Q.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? Bx4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Qx4.defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new oy4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new ty4.NoAuthSigner
        }],
        logger: A?.logger ?? new ey4.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO OIDC",
        urlParser: A?.urlParser ?? Ax4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? l7Q.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? l7Q.toUtf8
      }
    };
  i7Q.getRuntimeConfig = Gx4
})
// @from(Start 2777902, End 2780201)
QGQ = z((e7Q) => {
  Object.defineProperty(e7Q, "__esModule", {
    value: !0
  });
  e7Q.getRuntimeConfig = void 0;
  var Zx4 = yr(),
    Ix4 = Zx4.__importDefault(sw1()),
    s7Q = MF(),
    r7Q = XHA(),
    KgA = f8(),
    Yx4 = RX(),
    o7Q = D6(),
    cr = uI(),
    t7Q = IZ(),
    Jx4 = TX(),
    Wx4 = KW(),
    Xx4 = a7Q(),
    Vx4 = K6(),
    Fx4 = PX(),
    Kx4 = K6(),
    Dx4 = (A) => {
      (0, Kx4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, Fx4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(Vx4.loadConfigsForDefaultMode),
        G = (0, Xx4.getRuntimeConfig)(A);
      (0, s7Q.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, cr.loadConfig)(s7Q.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? Jx4.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, r7Q.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: Ix4.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, cr.loadConfig)(o7Q.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, cr.loadConfig)(KgA.NODE_REGION_CONFIG_OPTIONS, {
          ...KgA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: t7Q.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, cr.loadConfig)({
          ...o7Q.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || Wx4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? Yx4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? t7Q.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, cr.loadConfig)(KgA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, cr.loadConfig)(KgA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, cr.loadConfig)(r7Q.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  e7Q.getRuntimeConfig = Dx4
})
// @from(Start 2780207, End 2800034)
Qq1 = z(($U7, PGQ) => {
  var {
    defineProperty: DgA,
    getOwnPropertyDescriptor: Hx4,
    getOwnPropertyNames: Cx4
  } = Object, Ex4 = Object.prototype.hasOwnProperty, O6 = (A, Q) => DgA(A, "name", {
    value: Q,
    configurable: !0
  }), zx4 = (A, Q) => {
    for (var B in Q) DgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Ux4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Cx4(Q))
        if (!Ex4.call(A, Z) && Z !== B) DgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Hx4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, $x4 = (A) => Ux4(DgA({}, "__esModule", {
    value: !0
  }), A), XGQ = {};
  zx4(XGQ, {
    $Command: () => KGQ.Command,
    AccessDeniedException: () => DGQ,
    AuthorizationPendingException: () => HGQ,
    CreateTokenCommand: () => RGQ,
    CreateTokenRequestFilterSensitiveLog: () => CGQ,
    CreateTokenResponseFilterSensitiveLog: () => EGQ,
    ExpiredTokenException: () => zGQ,
    InternalServerException: () => UGQ,
    InvalidClientException: () => $GQ,
    InvalidGrantException: () => wGQ,
    InvalidRequestException: () => qGQ,
    InvalidScopeException: () => NGQ,
    SSOOIDC: () => TGQ,
    SSOOIDCClient: () => FGQ,
    SSOOIDCServiceException: () => Hw,
    SlowDownException: () => LGQ,
    UnauthorizedClientException: () => MGQ,
    UnsupportedGrantTypeException: () => OGQ,
    __Client: () => VGQ.Client
  });
  PGQ.exports = $x4(XGQ);
  var BGQ = yDA(),
    wx4 = xDA(),
    qx4 = vDA(),
    GGQ = r4A(),
    Nx4 = f8(),
    ew1 = iB(),
    Lx4 = LX(),
    Mx4 = q5(),
    ZGQ = D6(),
    VGQ = K6(),
    IGQ = aw1(),
    Ox4 = O6((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth"
      })
    }, "resolveClientEndpointParameters"),
    Rx4 = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    Tx4 = QGQ(),
    YGQ = KHA(),
    JGQ = nC(),
    WGQ = K6(),
    Px4 = O6((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    jx4 = O6((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    Sx4 = O6((A, Q) => {
      let B = Object.assign((0, YGQ.getAwsRegionExtensionConfiguration)(A), (0, WGQ.getDefaultExtensionConfiguration)(A), (0, JGQ.getHttpHandlerExtensionConfiguration)(A), Px4(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, YGQ.resolveAwsRegionExtensionConfiguration)(B), (0, WGQ.resolveDefaultRuntimeConfig)(B), (0, JGQ.resolveHttpHandlerRuntimeConfig)(B), jx4(B))
    }, "resolveRuntimeExtensions"),
    FGQ = class extends VGQ.Client {
      static {
        O6(this, "SSOOIDCClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, Tx4.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = Ox4(Q),
          G = (0, GGQ.resolveUserAgentConfig)(B),
          Z = (0, ZGQ.resolveRetryConfig)(G),
          I = (0, Nx4.resolveRegionConfig)(Z),
          Y = (0, BGQ.resolveHostHeaderConfig)(I),
          J = (0, Mx4.resolveEndpointConfig)(Y),
          W = (0, IGQ.resolveHttpAuthSchemeConfig)(J),
          X = Sx4(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, GGQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, ZGQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, Lx4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, BGQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, wx4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, qx4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, ew1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: IGQ.defaultSSOOIDCHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: O6(async (V) => new ew1.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, ew1.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    _x4 = K6(),
    kx4 = q5(),
    yx4 = GZ(),
    KGQ = K6(),
    W8A = K6(),
    xx4 = K6(),
    Hw = class A extends xx4.ServiceException {
      static {
        O6(this, "SSOOIDCServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    DGQ = class A extends Hw {
      static {
        O6(this, "AccessDeniedException")
      }
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    HGQ = class A extends Hw {
      static {
        O6(this, "AuthorizationPendingException")
      }
      name = "AuthorizationPendingException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    CGQ = O6((A) => ({
      ...A,
      ...A.clientSecret && {
        clientSecret: W8A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: W8A.SENSITIVE_STRING
      },
      ...A.codeVerifier && {
        codeVerifier: W8A.SENSITIVE_STRING
      }
    }), "CreateTokenRequestFilterSensitiveLog"),
    EGQ = O6((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: W8A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: W8A.SENSITIVE_STRING
      },
      ...A.idToken && {
        idToken: W8A.SENSITIVE_STRING
      }
    }), "CreateTokenResponseFilterSensitiveLog"),
    zGQ = class A extends Hw {
      static {
        O6(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    UGQ = class A extends Hw {
      static {
        O6(this, "InternalServerException")
      }
      name = "InternalServerException";
      $fault = "server";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    $GQ = class A extends Hw {
      static {
        O6(this, "InvalidClientException")
      }
      name = "InvalidClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    wGQ = class A extends Hw {
      static {
        O6(this, "InvalidGrantException")
      }
      name = "InvalidGrantException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    qGQ = class A extends Hw {
      static {
        O6(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    NGQ = class A extends Hw {
      static {
        O6(this, "InvalidScopeException")
      }
      name = "InvalidScopeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    LGQ = class A extends Hw {
      static {
        O6(this, "SlowDownException")
      }
      name = "SlowDownException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    MGQ = class A extends Hw {
      static {
        O6(this, "UnauthorizedClientException")
      }
      name = "UnauthorizedClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    OGQ = class A extends Hw {
      static {
        O6(this, "UnsupportedGrantTypeException")
      }
      name = "UnsupportedGrantTypeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    Aq1 = MF(),
    vx4 = iB(),
    B2 = K6(),
    bx4 = O6(async (A, Q) => {
      let B = (0, vx4.requestBuilder)(A, Q),
        G = {
          "content-type": "application/json"
        };
      B.bp("/token");
      let Z;
      return Z = JSON.stringify((0, B2.take)(A, {
        clientId: [],
        clientSecret: [],
        code: [],
        codeVerifier: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: O6((I) => (0, B2._json)(I), "scope")
      })), B.m("POST").h(G).b(Z), B.build()
    }, "se_CreateTokenCommand"),
    fx4 = O6(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return hx4(A, Q);
      let B = (0, B2.map)({
          $metadata: KL(A)
        }),
        G = (0, B2.expectNonNull)((0, B2.expectObject)(await (0, Aq1.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, B2.take)(G, {
          accessToken: B2.expectString,
          expiresIn: B2.expectInt32,
          idToken: B2.expectString,
          refreshToken: B2.expectString,
          tokenType: B2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_CreateTokenCommand"),
    hx4 = O6(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, Aq1.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, Aq1.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
          throw await ux4(B, Q);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
          throw await mx4(B, Q);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
          throw await dx4(B, Q);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
          throw await cx4(B, Q);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
          throw await px4(B, Q);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
          throw await lx4(B, Q);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
          throw await ix4(B, Q);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
          throw await nx4(B, Q);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
          throw await ax4(B, Q);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
          throw await sx4(B, Q);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
          throw await rx4(B, Q);
        default:
          let Z = B.body;
          return gx4({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    gx4 = (0, B2.withBaseException)(Hw),
    ux4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new DGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_AccessDeniedExceptionRes"),
    mx4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new HGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_AuthorizationPendingExceptionRes"),
    dx4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new zGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_ExpiredTokenExceptionRes"),
    cx4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new UGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_InternalServerExceptionRes"),
    px4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new $GQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_InvalidClientExceptionRes"),
    lx4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new wGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_InvalidGrantExceptionRes"),
    ix4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new qGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    nx4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new NGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_InvalidScopeExceptionRes"),
    ax4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new LGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_SlowDownExceptionRes"),
    sx4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new MGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedClientExceptionRes"),
    rx4 = O6(async (A, Q) => {
      let B = (0, B2.map)({}),
        G = A.body,
        Z = (0, B2.take)(G, {
          error: B2.expectString,
          error_description: B2.expectString
        });
      Object.assign(B, Z);
      let I = new OGQ({
        $metadata: KL(A),
        ...B
      });
      return (0, B2.decorateServiceException)(I, A.body)
    }, "de_UnsupportedGrantTypeExceptionRes"),
    KL = O6((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    RGQ = class extends KGQ.Command.classBuilder().ep(Rx4).m(function(A, Q, B, G) {
      return [(0, yx4.getSerdePlugin)(B, this.serialize, this.deserialize), (0, kx4.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(CGQ, EGQ).ser(bx4).de(fx4).build() {
      static {
        O6(this, "CreateTokenCommand")
      }
    },
    ox4 = {
      CreateTokenCommand: RGQ
    },
    TGQ = class extends FGQ {
      static {
        O6(this, "SSOOIDC")
      }
    };
  (0, _x4.createAggregatedClient)(ox4, TGQ)
})
// @from(Start 2800040, End 2806209)
bGQ = z((LU7, vGQ) => {
  var {
    create: tx4,
    defineProperty: zHA,
    getOwnPropertyDescriptor: ex4,
    getOwnPropertyNames: Av4,
    getPrototypeOf: Qv4
  } = Object, Bv4 = Object.prototype.hasOwnProperty, Pv = (A, Q) => zHA(A, "name", {
    value: Q,
    configurable: !0
  }), Gv4 = (A, Q) => {
    for (var B in Q) zHA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, _GQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Av4(Q))
        if (!Bv4.call(A, Z) && Z !== B) zHA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = ex4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, kGQ = (A, Q, B) => (B = A != null ? tx4(Qv4(A)) : {}, _GQ(Q || !A || !A.__esModule ? zHA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), Zv4 = (A) => _GQ(zHA({}, "__esModule", {
    value: !0
  }), A), yGQ = {};
  Gv4(yGQ, {
    fromEnvSigningName: () => Jv4,
    fromSso: () => xGQ,
    fromStatic: () => Hv4,
    nodeProvider: () => Cv4
  });
  vGQ.exports = Zv4(yGQ);
  var Iv4 = QL(),
    Yv4 = $$1(),
    Cw = j2(),
    Jv4 = Pv(({
      logger: A,
      signingName: Q
    } = {}) => async () => {
      if (A?.debug?.("@aws-sdk/token-providers - fromEnvSigningName"), !Q) throw new Cw.TokenProviderError("Please pass 'signingName' to compute environment variable key", {
        logger: A
      });
      let B = (0, Yv4.getBearerTokenEnvKey)(Q);
      if (!(B in process.env)) throw new Cw.TokenProviderError(`Token not present in '${B}' environment variable`, {
        logger: A
      });
      let G = {
        token: process.env[B]
      };
      return (0, Iv4.setTokenFeature)(G, "BEARER_SERVICE_ENV_VARS", "3"), G
    }, "fromEnvSigningName"),
    Wv4 = 300000,
    Bq1 = "To refresh this SSO session run 'aws sso login' with the corresponding profile.",
    Xv4 = Pv(async (A, Q = {}) => {
      let {
        SSOOIDCClient: B
      } = await Promise.resolve().then(() => kGQ(Qq1()));
      return new B(Object.assign({}, Q.clientConfig ?? {}, {
        region: A ?? Q.clientConfig?.region,
        logger: Q.clientConfig?.logger ?? Q.parentClientConfig?.logger
      }))
    }, "getSsoOidcClient"),
    Vv4 = Pv(async (A, Q, B = {}) => {
      let {
        CreateTokenCommand: G
      } = await Promise.resolve().then(() => kGQ(Qq1()));
      return (await Xv4(Q, B)).send(new G({
        clientId: A.clientId,
        clientSecret: A.clientSecret,
        refreshToken: A.refreshToken,
        grantType: "refresh_token"
      }))
    }, "getNewSsoOidcToken"),
    jGQ = Pv((A) => {
      if (A.expiration && A.expiration.getTime() < Date.now()) throw new Cw.TokenProviderError(`Token is expired. ${Bq1}`, !1)
    }, "validateTokenExpiry"),
    pr = Pv((A, Q, B = !1) => {
      if (typeof Q > "u") throw new Cw.TokenProviderError(`Value not present for '${A}' in SSO Token${B?". Cannot refresh":""}. ${Bq1}`, !1)
    }, "validateTokenKey"),
    EHA = SG(),
    Fv4 = UA("fs"),
    {
      writeFile: Kv4
    } = Fv4.promises,
    Dv4 = Pv((A, Q) => {
      let B = (0, EHA.getSSOTokenFilepath)(A),
        G = JSON.stringify(Q, null, 2);
      return Kv4(B, G)
    }, "writeSSOTokenToFile"),
    SGQ = new Date(0),
    xGQ = Pv((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/token-providers - fromSso");
      let G = await (0, EHA.parseKnownFiles)(B),
        Z = (0, EHA.getProfileName)({
          profile: B.profile ?? Q?.profile
        }),
        I = G[Z];
      if (!I) throw new Cw.TokenProviderError(`Profile '${Z}' could not be found in shared credentials file.`, !1);
      else if (!I.sso_session) throw new Cw.TokenProviderError(`Profile '${Z}' is missing required property 'sso_session'.`);
      let Y = I.sso_session,
        W = (await (0, EHA.loadSsoSessionData)(B))[Y];
      if (!W) throw new Cw.TokenProviderError(`Sso session '${Y}' could not be found in shared credentials file.`, !1);
      for (let C of ["sso_start_url", "sso_region"])
        if (!W[C]) throw new Cw.TokenProviderError(`Sso session '${Y}' is missing required property '${C}'.`, !1);
      let {
        sso_start_url: X,
        sso_region: V
      } = W, F;
      try {
        F = await (0, EHA.getSSOTokenFromFile)(Y)
      } catch (C) {
        throw new Cw.TokenProviderError(`The SSO session token associated with profile=${Z} was not found or is invalid. ${Bq1}`, !1)
      }
      pr("accessToken", F.accessToken), pr("expiresAt", F.expiresAt);
      let {
        accessToken: K,
        expiresAt: D
      } = F, H = {
        token: K,
        expiration: new Date(D)
      };
      if (H.expiration.getTime() - Date.now() > Wv4) return H;
      if (Date.now() - SGQ.getTime() < 30000) return jGQ(H), H;
      pr("clientId", F.clientId, !0), pr("clientSecret", F.clientSecret, !0), pr("refreshToken", F.refreshToken, !0);
      try {
        SGQ.setTime(Date.now());
        let C = await Vv4(F, V, B);
        pr("accessToken", C.accessToken), pr("expiresIn", C.expiresIn);
        let E = new Date(Date.now() + C.expiresIn * 1000);
        try {
          await Dv4(Y, {
            ...F,
            accessToken: C.accessToken,
            expiresAt: E.toISOString(),
            refreshToken: C.refreshToken
          })
        } catch (U) {}
        return {
          token: C.accessToken,
          expiration: E
        }
      } catch (C) {
        return jGQ(H), H
      }
    }, "fromSso"),
    Hv4 = Pv(({
      token: A,
      logger: Q
    }) => async () => {
      if (Q?.debug("@aws-sdk/token-providers - fromStatic"), !A || !A.token) throw new Cw.TokenProviderError("Please pass a valid token to fromStatic", !1);
      return A
    }, "fromStatic"),
    Cv4 = Pv((A = {}) => (0, Cw.memoize)((0, Cw.chain)(xGQ(A), async () => {
      throw new Cw.TokenProviderError("Could not load token from any providers", !1)
    }), (Q) => Q.expiration !== void 0 && Q.expiration.getTime() - Date.now() < 300000, (Q) => Q.expiration !== void 0), "nodeProvider")
})
// @from(Start 2806215, End 2813457)
Zq1 = z((MU7, lGQ) => {
  var {
    defineProperty: CgA,
    getOwnPropertyDescriptor: Ev4,
    getOwnPropertyNames: gGQ
  } = Object, zv4 = Object.prototype.hasOwnProperty, EgA = (A, Q) => CgA(A, "name", {
    value: Q,
    configurable: !0
  }), Uv4 = (A, Q) => function() {
    return A && (Q = (0, A[gGQ(A)[0]])(A = 0)), Q
  }, uGQ = (A, Q) => {
    for (var B in Q) CgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, $v4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gGQ(Q))
        if (!zv4.call(A, Z) && Z !== B) CgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Ev4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, wv4 = (A) => $v4(CgA({}, "__esModule", {
    value: !0
  }), A), mGQ = {};
  uGQ(mGQ, {
    GetRoleCredentialsCommand: () => Gq1.GetRoleCredentialsCommand,
    SSOClient: () => Gq1.SSOClient
  });
  var Gq1, qv4 = Uv4({
      "src/loadSso.ts"() {
        Gq1 = q7Q()
      }
    }),
    dGQ = {};
  uGQ(dGQ, {
    fromSSO: () => Lv4,
    isSsoProfile: () => cGQ,
    validateSsoProfile: () => pGQ
  });
  lGQ.exports = wv4(dGQ);
  var cGQ = EgA((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    fGQ = QL(),
    Nv4 = bGQ(),
    pR = j2(),
    HgA = SG(),
    UHA = !1,
    hGQ = EgA(async ({
      ssoStartUrl: A,
      ssoSession: Q,
      ssoAccountId: B,
      ssoRegion: G,
      ssoRoleName: Z,
      ssoClient: I,
      clientConfig: Y,
      parentClientConfig: J,
      profile: W,
      logger: X
    }) => {
      let V, F = "To refresh this SSO session run aws sso login with the corresponding profile.";
      if (Q) try {
        let v = await (0, Nv4.fromSso)({
          profile: W
        })();
        V = {
          accessToken: v.token,
          expiresAt: new Date(v.expiration).toISOString()
        }
      } catch (v) {
        throw new pR.CredentialsProviderError(v.message, {
          tryNextLink: UHA,
          logger: X
        })
      } else try {
        V = await (0, HgA.getSSOTokenFromFile)(A)
      } catch (v) {
        throw new pR.CredentialsProviderError("The SSO session associated with this profile is invalid. To refresh this SSO session run aws sso login with the corresponding profile.", {
          tryNextLink: UHA,
          logger: X
        })
      }
      if (new Date(V.expiresAt).getTime() - Date.now() <= 0) throw new pR.CredentialsProviderError("The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile.", {
        tryNextLink: UHA,
        logger: X
      });
      let {
        accessToken: K
      } = V, {
        SSOClient: D,
        GetRoleCredentialsCommand: H
      } = await Promise.resolve().then(() => (qv4(), mGQ)), C = I || new D(Object.assign({}, Y ?? {}, {
        logger: Y?.logger ?? J?.logger,
        region: Y?.region ?? G
      })), E;
      try {
        E = await C.send(new H({
          accountId: B,
          roleName: Z,
          accessToken: K
        }))
      } catch (v) {
        throw new pR.CredentialsProviderError(v, {
          tryNextLink: UHA,
          logger: X
        })
      }
      let {
        roleCredentials: {
          accessKeyId: U,
          secretAccessKey: q,
          sessionToken: w,
          expiration: N,
          credentialScope: R,
          accountId: T
        } = {}
      } = E;
      if (!U || !q || !w || !N) throw new pR.CredentialsProviderError("SSO returns an invalid temporary credential.", {
        tryNextLink: UHA,
        logger: X
      });
      let y = {
        accessKeyId: U,
        secretAccessKey: q,
        sessionToken: w,
        expiration: new Date(N),
        ...R && {
          credentialScope: R
        },
        ...T && {
          accountId: T
        }
      };
      if (Q)(0, fGQ.setCredentialFeature)(y, "CREDENTIALS_SSO", "s");
      else(0, fGQ.setCredentialFeature)(y, "CREDENTIALS_SSO_LEGACY", "u");
      return y
    }, "resolveSSOCredentials"),
    pGQ = EgA((A, Q) => {
      let {
        sso_start_url: B,
        sso_account_id: G,
        sso_region: Z,
        sso_role_name: I
      } = A;
      if (!B || !G || !Z || !I) throw new pR.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(A).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, {
        tryNextLink: !1,
        logger: Q
      });
      return A
    }, "validateSsoProfile"),
    Lv4 = EgA((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
      let {
        ssoStartUrl: B,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoSession: Y
      } = A, {
        ssoClient: J
      } = A, W = (0, HgA.getProfileName)({
        profile: A.profile ?? Q?.profile
      });
      if (!B && !G && !Z && !I && !Y) {
        let V = (await (0, HgA.parseKnownFiles)(A))[W];
        if (!V) throw new pR.CredentialsProviderError(`Profile ${W} was not found.`, {
          logger: A.logger
        });
        if (!cGQ(V)) throw new pR.CredentialsProviderError(`Profile ${W} is not configured with SSO credentials.`, {
          logger: A.logger
        });
        if (V?.sso_session) {
          let U = (await (0, HgA.loadSsoSessionData)(A))[V.sso_session],
            q = ` configurations in profile ${W} and sso-session ${V.sso_session}`;
          if (Z && Z !== U.sso_region) throw new pR.CredentialsProviderError("Conflicting SSO region" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          if (B && B !== U.sso_start_url) throw new pR.CredentialsProviderError("Conflicting SSO start_url" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          V.sso_region = U.sso_region, V.sso_start_url = U.sso_start_url
        }
        let {
          sso_start_url: F,
          sso_account_id: K,
          sso_region: D,
          sso_role_name: H,
          sso_session: C
        } = pGQ(V, A.logger);
        return hGQ({
          ssoStartUrl: F,
          ssoSession: C,
          ssoAccountId: K,
          ssoRegion: D,
          ssoRoleName: H,
          ssoClient: J,
          clientConfig: A.clientConfig,
          parentClientConfig: A.parentClientConfig,
          profile: W
        })
      } else if (!B || !G || !Z || !I) throw new pR.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', {
        tryNextLink: !1,
        logger: A.logger
      });
      else return hGQ({
        ssoStartUrl: B,
        ssoSession: Y,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoClient: J,
        clientConfig: A.clientConfig,
        parentClientConfig: A.parentClientConfig,
        profile: W
      })
    }, "fromSSO")
})
// @from(Start 2813463, End 2815120)
Yq1 = z((iGQ) => {
  Object.defineProperty(iGQ, "__esModule", {
    value: !0
  });
  iGQ.resolveHttpAuthSchemeConfig = iGQ.resolveStsAuthConfig = iGQ.defaultSTSHttpAuthSchemeProvider = iGQ.defaultSTSHttpAuthSchemeParametersProvider = void 0;
  var Mv4 = MF(),
    Iq1 = w7(),
    Ov4 = $HA(),
    Rv4 = async (A, Q, B) => {
      return {
        operation: (0, Iq1.getSmithyContext)(Q).operation,
        region: await (0, Iq1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  iGQ.defaultSTSHttpAuthSchemeParametersProvider = Rv4;

  function Tv4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function Pv4(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var jv4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "AssumeRoleWithWebIdentity": {
        Q.push(Pv4(A));
        break
      }
      default:
        Q.push(Tv4(A))
    }
    return Q
  };
  iGQ.defaultSTSHttpAuthSchemeProvider = jv4;
  var Sv4 = (A) => Object.assign(A, {
    stsClientCtor: Ov4.STSClient
  });
  iGQ.resolveStsAuthConfig = Sv4;
  var _v4 = (A) => {
    let Q = iGQ.resolveStsAuthConfig(A),
      B = (0, Mv4.resolveAwsSdkSigV4Config)(Q);
    return Object.assign(B, {
      authSchemePreference: (0, Iq1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  iGQ.resolveHttpAuthSchemeConfig = _v4
})
// @from(Start 2815126, End 2816014)
wHA = z((sGQ) => {
  Object.defineProperty(sGQ, "__esModule", {
    value: !0
  });
  sGQ.commonParams = sGQ.resolveClientEndpointParameters = void 0;
  var xv4 = (A) => {
    return Object.assign(A, {
      useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
      useFipsEndpoint: A.useFipsEndpoint ?? !1,
      useGlobalEndpoint: A.useGlobalEndpoint ?? !1,
      defaultSigningName: "sts"
    })
  };
  sGQ.resolveClientEndpointParameters = xv4;
  sGQ.commonParams = {
    UseGlobalEndpoint: {
      type: "builtInParams",
      name: "useGlobalEndpoint"
    },
    UseFIPS: {
      type: "builtInParams",
      name: "useFipsEndpoint"
    },
    Endpoint: {
      type: "builtInParams",
      name: "endpoint"
    },
    Region: {
      type: "builtInParams",
      name: "region"
    },
    UseDualStack: {
      type: "builtInParams",
      name: "useDualstackEndpoint"
    }
  }
})
// @from(Start 2816020, End 2824197)
wZQ = z((UZQ) => {
  Object.defineProperty(UZQ, "__esModule", {
    value: !0
  });
  UZQ.ruleSet = void 0;
  var WZQ = "required",
    h8 = "type",
    s3 = "fn",
    r3 = "argv",
    qd = "ref",
    oGQ = !1,
    Jq1 = !0,
    wd = "booleanEquals",
    eK = "stringEquals",
    XZQ = "sigv4",
    VZQ = "sts",
    FZQ = "us-east-1",
    mI = "endpoint",
    tGQ = "https://sts.{Region}.{PartitionResult#dnsSuffix}",
    OS = "tree",
    X8A = "error",
    Xq1 = "getAttr",
    eGQ = {
      [WZQ]: !1,
      [h8]: "String"
    },
    Wq1 = {
      [WZQ]: !0,
      default: !1,
      [h8]: "Boolean"
    },
    KZQ = {
      [qd]: "Endpoint"
    },
    AZQ = {
      [s3]: "isSet",
      [r3]: [{
        [qd]: "Region"
      }]
    },
    AD = {
      [qd]: "Region"
    },
    QZQ = {
      [s3]: "aws.partition",
      [r3]: [AD],
      assign: "PartitionResult"
    },
    DZQ = {
      [qd]: "UseFIPS"
    },
    HZQ = {
      [qd]: "UseDualStack"
    },
    $H = {
      url: "https://sts.amazonaws.com",
      properties: {
        authSchemes: [{
          name: XZQ,
          signingName: VZQ,
          signingRegion: FZQ
        }]
      },
      headers: {}
    },
    Ew = {},
    BZQ = {
      conditions: [{
        [s3]: eK,
        [r3]: [AD, "aws-global"]
      }],
      [mI]: $H,
      [h8]: mI
    },
    CZQ = {
      [s3]: wd,
      [r3]: [DZQ, !0]
    },
    EZQ = {
      [s3]: wd,
      [r3]: [HZQ, !0]
    },
    GZQ = {
      [s3]: Xq1,
      [r3]: [{
        [qd]: "PartitionResult"
      }, "supportsFIPS"]
    },
    zZQ = {
      [qd]: "PartitionResult"
    },
    ZZQ = {
      [s3]: wd,
      [r3]: [!0, {
        [s3]: Xq1,
        [r3]: [zZQ, "supportsDualStack"]
      }]
    },
    IZQ = [{
      [s3]: "isSet",
      [r3]: [KZQ]
    }],
    YZQ = [CZQ],
    JZQ = [EZQ],
    bv4 = {
      version: "1.0",
      parameters: {
        Region: eGQ,
        UseDualStack: Wq1,
        UseFIPS: Wq1,
        Endpoint: eGQ,
        UseGlobalEndpoint: Wq1
      },
      rules: [{
        conditions: [{
          [s3]: wd,
          [r3]: [{
            [qd]: "UseGlobalEndpoint"
          }, Jq1]
        }, {
          [s3]: "not",
          [r3]: IZQ
        }, AZQ, QZQ, {
          [s3]: wd,
          [r3]: [DZQ, oGQ]
        }, {
          [s3]: wd,
          [r3]: [HZQ, oGQ]
        }],
        rules: [{
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "ap-northeast-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "ap-south-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "ap-southeast-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "ap-southeast-2"]
          }],
          endpoint: $H,
          [h8]: mI
        }, BZQ, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "ca-central-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "eu-central-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "eu-north-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "eu-west-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "eu-west-2"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "eu-west-3"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "sa-east-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, FZQ]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "us-east-2"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "us-west-1"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          conditions: [{
            [s3]: eK,
            [r3]: [AD, "us-west-2"]
          }],
          endpoint: $H,
          [h8]: mI
        }, {
          endpoint: {
            url: tGQ,
            properties: {
              authSchemes: [{
                name: XZQ,
                signingName: VZQ,
                signingRegion: "{Region}"
              }]
            },
            headers: Ew
          },
          [h8]: mI
        }],
        [h8]: OS
      }, {
        conditions: IZQ,
        rules: [{
          conditions: YZQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          [h8]: X8A
        }, {
          conditions: JZQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          [h8]: X8A
        }, {
          endpoint: {
            url: KZQ,
            properties: Ew,
            headers: Ew
          },
          [h8]: mI
        }],
        [h8]: OS
      }, {
        conditions: [AZQ],
        rules: [{
          conditions: [QZQ],
          rules: [{
            conditions: [CZQ, EZQ],
            rules: [{
              conditions: [{
                [s3]: wd,
                [r3]: [Jq1, GZQ]
              }, ZZQ],
              rules: [{
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: Ew,
                  headers: Ew
                },
                [h8]: mI
              }],
              [h8]: OS
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              [h8]: X8A
            }],
            [h8]: OS
          }, {
            conditions: YZQ,
            rules: [{
              conditions: [{
                [s3]: wd,
                [r3]: [GZQ, Jq1]
              }],
              rules: [{
                conditions: [{
                  [s3]: eK,
                  [r3]: [{
                    [s3]: Xq1,
                    [r3]: [zZQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://sts.{Region}.amazonaws.com",
                  properties: Ew,
                  headers: Ew
                },
                [h8]: mI
              }, {
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: Ew,
                  headers: Ew
                },
                [h8]: mI
              }],
              [h8]: OS
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              [h8]: X8A
            }],
            [h8]: OS
          }, {
            conditions: JZQ,
            rules: [{
              conditions: [ZZQ],
              rules: [{
                endpoint: {
                  url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: Ew,
                  headers: Ew
                },
                [h8]: mI
              }],
              [h8]: OS
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              [h8]: X8A
            }],
            [h8]: OS
          }, BZQ, {
            endpoint: {
              url: tGQ,
              properties: Ew,
              headers: Ew
            },
            [h8]: mI
          }],
          [h8]: OS
        }],
        [h8]: OS
      }, {
        error: "Invalid Configuration: Missing Region",
        [h8]: X8A
      }]
    };
  UZQ.ruleSet = bv4
})
// @from(Start 2824203, End 2824788)
LZQ = z((qZQ) => {
  Object.defineProperty(qZQ, "__esModule", {
    value: !0
  });
  qZQ.defaultEndpointResolver = void 0;
  var fv4 = p4A(),
    Vq1 = FI(),
    hv4 = wZQ(),
    gv4 = new Vq1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    }),
    uv4 = (A, Q = {}) => {
      return gv4.get(A, () => (0, Vq1.resolveEndpoint)(hv4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  qZQ.defaultEndpointResolver = uv4;
  Vq1.customEndpointFunctions.aws = fv4.awsEndpointFunctions
})
// @from(Start 2824794, End 2826203)
PZQ = z((RZQ) => {
  Object.defineProperty(RZQ, "__esModule", {
    value: !0
  });
  RZQ.getRuntimeConfig = void 0;
  var mv4 = MF(),
    dv4 = iB(),
    cv4 = K6(),
    pv4 = NJ(),
    MZQ = Fd(),
    OZQ = O2(),
    lv4 = Yq1(),
    iv4 = LZQ(),
    nv4 = (A) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: A?.base64Decoder ?? MZQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? MZQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? iv4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? lv4.defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new mv4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new dv4.NoAuthSigner
        }],
        logger: A?.logger ?? new cv4.NoOpLogger,
        serviceId: A?.serviceId ?? "STS",
        urlParser: A?.urlParser ?? pv4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? OZQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? OZQ.toUtf8
      }
    };
  RZQ.getRuntimeConfig = nv4
})
// @from(Start 2826209, End 2829011)
xZQ = z((kZQ) => {
  Object.defineProperty(kZQ, "__esModule", {
    value: !0
  });
  kZQ.getRuntimeConfig = void 0;
  var av4 = yr(),
    sv4 = av4.__importDefault(sw1()),
    Fq1 = MF(),
    jZQ = XHA(),
    zgA = f8(),
    rv4 = iB(),
    ov4 = RX(),
    SZQ = D6(),
    lr = uI(),
    _ZQ = IZ(),
    tv4 = TX(),
    ev4 = KW(),
    Ab4 = PZQ(),
    Qb4 = K6(),
    Bb4 = PX(),
    Gb4 = K6(),
    Zb4 = (A) => {
      (0, Gb4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, Bb4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(Qb4.loadConfigsForDefaultMode),
        G = (0, Ab4.getRuntimeConfig)(A);
      (0, Fq1.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, lr.loadConfig)(Fq1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? tv4.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, jZQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: sv4.default.version
        }),
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (I) => I.getIdentityProvider("aws.auth#sigv4") || (async (Y) => await A.credentialDefaultProvider(Y?.__config || {})()),
          signer: new Fq1.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (I) => I.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new rv4.NoAuthSigner
        }],
        maxAttempts: A?.maxAttempts ?? (0, lr.loadConfig)(SZQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, lr.loadConfig)(zgA.NODE_REGION_CONFIG_OPTIONS, {
          ...zgA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: _ZQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, lr.loadConfig)({
          ...SZQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || ev4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? ov4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? _ZQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, lr.loadConfig)(zgA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, lr.loadConfig)(zgA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, lr.loadConfig)(jZQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  kZQ.getRuntimeConfig = Zb4
})
// @from(Start 2829017, End 2830036)
fZQ = z((vZQ) => {
  Object.defineProperty(vZQ, "__esModule", {
    value: !0
  });
  vZQ.resolveHttpAuthRuntimeConfig = vZQ.getHttpAuthExtensionConfiguration = void 0;
  var Ib4 = (A) => {
    let {
      httpAuthSchemes: Q,
      httpAuthSchemeProvider: B,
      credentials: G
    } = A;
    return {
      setHttpAuthScheme(Z) {
        let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
        if (I === -1) Q.push(Z);
        else Q.splice(I, 1, Z)
      },
      httpAuthSchemes() {
        return Q
      },
      setHttpAuthSchemeProvider(Z) {
        B = Z
      },
      httpAuthSchemeProvider() {
        return B
      },
      setCredentials(Z) {
        G = Z
      },
      credentials() {
        return G
      }
    }
  };
  vZQ.getHttpAuthExtensionConfiguration = Ib4;
  var Yb4 = (A) => {
    return {
      httpAuthSchemes: A.httpAuthSchemes(),
      httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
      credentials: A.credentials()
    }
  };
  vZQ.resolveHttpAuthRuntimeConfig = Yb4
})
// @from(Start 2830042, End 2830767)
pZQ = z((dZQ) => {
  Object.defineProperty(dZQ, "__esModule", {
    value: !0
  });
  dZQ.resolveRuntimeExtensions = void 0;
  var hZQ = KHA(),
    gZQ = nC(),
    uZQ = K6(),
    mZQ = fZQ(),
    Wb4 = (A, Q) => {
      let B = Object.assign((0, hZQ.getAwsRegionExtensionConfiguration)(A), (0, uZQ.getDefaultExtensionConfiguration)(A), (0, gZQ.getHttpHandlerExtensionConfiguration)(A), (0, mZQ.getHttpAuthExtensionConfiguration)(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, hZQ.resolveAwsRegionExtensionConfiguration)(B), (0, uZQ.resolveDefaultRuntimeConfig)(B), (0, gZQ.resolveHttpHandlerRuntimeConfig)(B), (0, mZQ.resolveHttpAuthRuntimeConfig)(B))
    };
  dZQ.resolveRuntimeExtensions = Wb4
})
// @from(Start 2830773, End 2832755)
$HA = z((Dq1) => {
  Object.defineProperty(Dq1, "__esModule", {
    value: !0
  });
  Dq1.STSClient = Dq1.__Client = void 0;
  var lZQ = yDA(),
    Xb4 = xDA(),
    Vb4 = vDA(),
    iZQ = r4A(),
    Fb4 = f8(),
    Kq1 = iB(),
    Kb4 = LX(),
    Db4 = q5(),
    nZQ = D6(),
    sZQ = K6();
  Object.defineProperty(Dq1, "__Client", {
    enumerable: !0,
    get: function() {
      return sZQ.Client
    }
  });
  var aZQ = Yq1(),
    Hb4 = wHA(),
    Cb4 = xZQ(),
    Eb4 = pZQ();
  class rZQ extends sZQ.Client {
    config;
    constructor(...[A]) {
      let Q = (0, Cb4.getRuntimeConfig)(A || {});
      super(Q);
      this.initConfig = Q;
      let B = (0, Hb4.resolveClientEndpointParameters)(Q),
        G = (0, iZQ.resolveUserAgentConfig)(B),
        Z = (0, nZQ.resolveRetryConfig)(G),
        I = (0, Fb4.resolveRegionConfig)(Z),
        Y = (0, lZQ.resolveHostHeaderConfig)(I),
        J = (0, Db4.resolveEndpointConfig)(Y),
        W = (0, aZQ.resolveHttpAuthSchemeConfig)(J),
        X = (0, Eb4.resolveRuntimeExtensions)(W, A?.extensions || []);
      this.config = X, this.middlewareStack.use((0, iZQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, nZQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, Kb4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, lZQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, Xb4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, Vb4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, Kq1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: aZQ.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (V) => new Kq1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": V.credentials
        })
      })), this.middlewareStack.use((0, Kq1.getHttpSigningPlugin)(this.config))
    }
    destroy() {
      super.destroy()
    }
  }
  Dq1.STSClient = rZQ
})
// @from(Start 2832761, End 2856133)
pq1 = z((vU7, cq1) => {
  var {
    defineProperty: UgA,
    getOwnPropertyDescriptor: zb4,
    getOwnPropertyNames: Ub4
  } = Object, $b4 = Object.prototype.hasOwnProperty, S2 = (A, Q) => UgA(A, "name", {
    value: Q,
    configurable: !0
  }), wb4 = (A, Q) => {
    for (var B in Q) UgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, bq1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Ub4(Q))
        if (!$b4.call(A, Z) && Z !== B) UgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = zb4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, qb4 = (A, Q, B) => (bq1(A, Q, "default"), B && bq1(B, Q, "default")), Nb4 = (A) => bq1(UgA({}, "__esModule", {
    value: !0
  }), A), hq1 = {};
  wb4(hq1, {
    AssumeRoleCommand: () => mq1,
    AssumeRoleResponseFilterSensitiveLog: () => AIQ,
    AssumeRoleWithWebIdentityCommand: () => dq1,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => JIQ,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => WIQ,
    ClientInputEndpointParameters: () => Hf4.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => gq1,
    ExpiredTokenException: () => QIQ,
    IDPCommunicationErrorException: () => XIQ,
    IDPRejectedClaimException: () => IIQ,
    InvalidIdentityTokenException: () => YIQ,
    MalformedPolicyDocumentException: () => BIQ,
    PackedPolicyTooLargeException: () => GIQ,
    RegionDisabledException: () => ZIQ,
    STS: () => wIQ,
    STSServiceException: () => Sv,
    decorateDefaultCredentialProvider: () => zf4,
    getDefaultRoleAssumer: () => RIQ,
    getDefaultRoleAssumerWithWebIdentity: () => TIQ
  });
  cq1.exports = Nb4(hq1);
  qb4(hq1, $HA(), cq1.exports);
  var Lb4 = K6(),
    Mb4 = q5(),
    Ob4 = GZ(),
    Rb4 = K6(),
    Tb4 = wHA(),
    eZQ = K6(),
    Pb4 = K6(),
    Sv = class A extends Pb4.ServiceException {
      static {
        S2(this, "STSServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    gq1 = S2((A) => ({
      ...A,
      ...A.SecretAccessKey && {
        SecretAccessKey: eZQ.SENSITIVE_STRING
      }
    }), "CredentialsFilterSensitiveLog"),
    AIQ = S2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: gq1(A.Credentials)
      }
    }), "AssumeRoleResponseFilterSensitiveLog"),
    QIQ = class A extends Sv {
      static {
        S2(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    BIQ = class A extends Sv {
      static {
        S2(this, "MalformedPolicyDocumentException")
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    GIQ = class A extends Sv {
      static {
        S2(this, "PackedPolicyTooLargeException")
      }
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    ZIQ = class A extends Sv {
      static {
        S2(this, "RegionDisabledException")
      }
      name = "RegionDisabledException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    IIQ = class A extends Sv {
      static {
        S2(this, "IDPRejectedClaimException")
      }
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    YIQ = class A extends Sv {
      static {
        S2(this, "InvalidIdentityTokenException")
      }
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    JIQ = S2((A) => ({
      ...A,
      ...A.WebIdentityToken && {
        WebIdentityToken: eZQ.SENSITIVE_STRING
      }
    }), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog"),
    WIQ = S2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: gq1(A.Credentials)
      }
    }), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog"),
    XIQ = class A extends Sv {
      static {
        S2(this, "IDPCommunicationErrorException")
      }
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    uq1 = MF(),
    jb4 = nC(),
    q7 = K6(),
    Sb4 = S2(async (A, Q) => {
      let B = CIQ,
        G;
      return G = $IQ({
        ...mb4(A, Q),
        [zIQ]: If4,
        [UIQ]: EIQ
      }), HIQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleCommand"),
    _b4 = S2(async (A, Q) => {
      let B = CIQ,
        G;
      return G = $IQ({
        ...db4(A, Q),
        [zIQ]: Yf4,
        [UIQ]: EIQ
      }), HIQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleWithWebIdentityCommand"),
    kb4 = S2(async (A, Q) => {
      if (A.statusCode >= 300) return VIQ(A, Q);
      let B = await (0, uq1.parseXmlBody)(A.body, Q),
        G = {};
      return G = sb4(B.AssumeRoleResult, Q), {
        $metadata: _v(A),
        ...G
      }
    }, "de_AssumeRoleCommand"),
    yb4 = S2(async (A, Q) => {
      if (A.statusCode >= 300) return VIQ(A, Q);
      let B = await (0, uq1.parseXmlBody)(A.body, Q),
        G = {};
      return G = rb4(B.AssumeRoleWithWebIdentityResult, Q), {
        $metadata: _v(A),
        ...G
      }
    }, "de_AssumeRoleWithWebIdentityCommand"),
    VIQ = S2(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, uq1.parseXmlErrorBody)(A.body, Q)
        },
        G = Jf4(A, B.body);
      switch (G) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await xb4(B, Q);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await hb4(B, Q);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await gb4(B, Q);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await ub4(B, Q);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await vb4(B, Q);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await bb4(B, Q);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await fb4(B, Q);
        default:
          let Z = B.body;
          return Zf4({
            output: A,
            parsedBody: Z.Error,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    xb4 = S2(async (A, Q) => {
      let B = A.body,
        G = ob4(B.Error, Q),
        Z = new QIQ({
          $metadata: _v(A),
          ...G
        });
      return (0, q7.decorateServiceException)(Z, B)
    }, "de_ExpiredTokenExceptionRes"),
    vb4 = S2(async (A, Q) => {
      let B = A.body,
        G = tb4(B.Error, Q),
        Z = new XIQ({
          $metadata: _v(A),
          ...G
        });
      return (0, q7.decorateServiceException)(Z, B)
    }, "de_IDPCommunicationErrorExceptionRes"),
    bb4 = S2(async (A, Q) => {
      let B = A.body,
        G = eb4(B.Error, Q),
        Z = new IIQ({
          $metadata: _v(A),
          ...G
        });
      return (0, q7.decorateServiceException)(Z, B)
    }, "de_IDPRejectedClaimExceptionRes"),
    fb4 = S2(async (A, Q) => {
      let B = A.body,
        G = Af4(B.Error, Q),
        Z = new YIQ({
          $metadata: _v(A),
          ...G
        });
      return (0, q7.decorateServiceException)(Z, B)
    }, "de_InvalidIdentityTokenExceptionRes"),
    hb4 = S2(async (A, Q) => {
      let B = A.body,
        G = Qf4(B.Error, Q),
        Z = new BIQ({
          $metadata: _v(A),
          ...G
        });
      return (0, q7.decorateServiceException)(Z, B)
    }, "de_MalformedPolicyDocumentExceptionRes"),
    gb4 = S2(async (A, Q) => {
      let B = A.body,
        G = Bf4(B.Error, Q),
        Z = new GIQ({
          $metadata: _v(A),
          ...G
        });
      return (0, q7.decorateServiceException)(Z, B)
    }, "de_PackedPolicyTooLargeExceptionRes"),
    ub4 = S2(async (A, Q) => {
      let B = A.body,
        G = Gf4(B.Error, Q),
        Z = new ZIQ({
          $metadata: _v(A),
          ...G
        });
      return (0, q7.decorateServiceException)(Z, B)
    }, "de_RegionDisabledExceptionRes"),
    mb4 = S2((A, Q) => {
      let B = {};
      if (A[E8A] != null) B[E8A] = A[E8A];
      if (A[z8A] != null) B[z8A] = A[z8A];
      if (A[H8A] != null) {
        let G = FIQ(A[H8A], Q);
        if (A[H8A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[D8A] != null) B[D8A] = A[D8A];
      if (A[K8A] != null) B[K8A] = A[K8A];
      if (A[Sq1] != null) {
        let G = ab4(A[Sq1], Q);
        if (A[Sq1]?.length === 0) B.Tags = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `Tags.${Z}`;
          B[Y] = I
        })
      }
      if (A[kq1] != null) {
        let G = nb4(A[kq1], Q);
        if (A[kq1]?.length === 0) B.TransitiveTagKeys = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `TransitiveTagKeys.${Z}`;
          B[Y] = I
        })
      }
      if (A[wq1] != null) B[wq1] = A[wq1];
      if (A[Pq1] != null) B[Pq1] = A[Pq1];
      if (A[_q1] != null) B[_q1] = A[_q1];
      if (A[jv] != null) B[jv] = A[jv];
      if (A[Lq1] != null) {
        let G = lb4(A[Lq1], Q);
        if (A[Lq1]?.length === 0) B.ProvidedContexts = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `ProvidedContexts.${Z}`;
          B[Y] = I
        })
      }
      return B
    }, "se_AssumeRoleRequest"),
    db4 = S2((A, Q) => {
      let B = {};
      if (A[E8A] != null) B[E8A] = A[E8A];
      if (A[z8A] != null) B[z8A] = A[z8A];
      if (A[xq1] != null) B[xq1] = A[xq1];
      if (A[Mq1] != null) B[Mq1] = A[Mq1];
      if (A[H8A] != null) {
        let G = FIQ(A[H8A], Q);
        if (A[H8A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[D8A] != null) B[D8A] = A[D8A];
      if (A[K8A] != null) B[K8A] = A[K8A];
      return B
    }, "se_AssumeRoleWithWebIdentityRequest"),
    FIQ = S2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = cb4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_policyDescriptorListType"),
    cb4 = S2((A, Q) => {
      let B = {};
      if (A[vq1] != null) B[vq1] = A[vq1];
      return B
    }, "se_PolicyDescriptorType"),
    pb4 = S2((A, Q) => {
      let B = {};
      if (A[Nq1] != null) B[Nq1] = A[Nq1];
      if (A[Uq1] != null) B[Uq1] = A[Uq1];
      return B
    }, "se_ProvidedContext"),
    lb4 = S2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = pb4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_ProvidedContextsListType"),
    ib4 = S2((A, Q) => {
      let B = {};
      if (A[qq1] != null) B[qq1] = A[qq1];
      if (A[yq1] != null) B[yq1] = A[yq1];
      return B
    }, "se_Tag"),
    nb4 = S2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        B[`member.${G}`] = Z, G++
      }
      return B
    }, "se_tagKeyListType"),
    ab4 = S2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = ib4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_tagListType"),
    KIQ = S2((A, Q) => {
      let B = {};
      if (A[Cq1] != null) B[Cq1] = (0, q7.expectString)(A[Cq1]);
      if (A[Eq1] != null) B[Eq1] = (0, q7.expectString)(A[Eq1]);
      return B
    }, "de_AssumedRoleUser"),
    sb4 = S2((A, Q) => {
      let B = {};
      if (A[F8A] != null) B[F8A] = DIQ(A[F8A], Q);
      if (A[V8A] != null) B[V8A] = KIQ(A[V8A], Q);
      if (A[C8A] != null) B[C8A] = (0, q7.strictParseInt32)(A[C8A]);
      if (A[jv] != null) B[jv] = (0, q7.expectString)(A[jv]);
      return B
    }, "de_AssumeRoleResponse"),
    rb4 = S2((A, Q) => {
      let B = {};
      if (A[F8A] != null) B[F8A] = DIQ(A[F8A], Q);
      if (A[Tq1] != null) B[Tq1] = (0, q7.expectString)(A[Tq1]);
      if (A[V8A] != null) B[V8A] = KIQ(A[V8A], Q);
      if (A[C8A] != null) B[C8A] = (0, q7.strictParseInt32)(A[C8A]);
      if (A[Oq1] != null) B[Oq1] = (0, q7.expectString)(A[Oq1]);
      if (A[zq1] != null) B[zq1] = (0, q7.expectString)(A[zq1]);
      if (A[jv] != null) B[jv] = (0, q7.expectString)(A[jv]);
      return B
    }, "de_AssumeRoleWithWebIdentityResponse"),
    DIQ = S2((A, Q) => {
      let B = {};
      if (A[Hq1] != null) B[Hq1] = (0, q7.expectString)(A[Hq1]);
      if (A[Rq1] != null) B[Rq1] = (0, q7.expectString)(A[Rq1]);
      if (A[jq1] != null) B[jq1] = (0, q7.expectString)(A[jq1]);
      if (A[$q1] != null) B[$q1] = (0, q7.expectNonNull)((0, q7.parseRfc3339DateTimeWithOffset)(A[$q1]));
      return B
    }, "de_Credentials"),
    ob4 = S2((A, Q) => {
      let B = {};
      if (A[DW] != null) B[DW] = (0, q7.expectString)(A[DW]);
      return B
    }, "de_ExpiredTokenException"),
    tb4 = S2((A, Q) => {
      let B = {};
      if (A[DW] != null) B[DW] = (0, q7.expectString)(A[DW]);
      return B
    }, "de_IDPCommunicationErrorException"),
    eb4 = S2((A, Q) => {
      let B = {};
      if (A[DW] != null) B[DW] = (0, q7.expectString)(A[DW]);
      return B
    }, "de_IDPRejectedClaimException"),
    Af4 = S2((A, Q) => {
      let B = {};
      if (A[DW] != null) B[DW] = (0, q7.expectString)(A[DW]);
      return B
    }, "de_InvalidIdentityTokenException"),
    Qf4 = S2((A, Q) => {
      let B = {};
      if (A[DW] != null) B[DW] = (0, q7.expectString)(A[DW]);
      return B
    }, "de_MalformedPolicyDocumentException"),
    Bf4 = S2((A, Q) => {
      let B = {};
      if (A[DW] != null) B[DW] = (0, q7.expectString)(A[DW]);
      return B
    }, "de_PackedPolicyTooLargeException"),
    Gf4 = S2((A, Q) => {
      let B = {};
      if (A[DW] != null) B[DW] = (0, q7.expectString)(A[DW]);
      return B
    }, "de_RegionDisabledException"),
    _v = S2((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    Zf4 = (0, q7.withBaseException)(Sv),
    HIQ = S2(async (A, Q, B, G, Z) => {
      let {
        hostname: I,
        protocol: Y = "https",
        port: J,
        path: W
      } = await A.endpoint(), X = {
        protocol: Y,
        hostname: I,
        port: J,
        method: "POST",
        path: W.endsWith("/") ? W.slice(0, -1) + B : W + B,
        headers: Q
      };
      if (G !== void 0) X.hostname = G;
      if (Z !== void 0) X.body = Z;
      return new jb4.HttpRequest(X)
    }, "buildHttpRpcRequest"),
    CIQ = {
      "content-type": "application/x-www-form-urlencoded"
    },
    EIQ = "2011-06-15",
    zIQ = "Action",
    Hq1 = "AccessKeyId",
    If4 = "AssumeRole",
    Cq1 = "AssumedRoleId",
    V8A = "AssumedRoleUser",
    Yf4 = "AssumeRoleWithWebIdentity",
    Eq1 = "Arn",
    zq1 = "Audience",
    F8A = "Credentials",
    Uq1 = "ContextAssertion",
    K8A = "DurationSeconds",
    $q1 = "Expiration",
    wq1 = "ExternalId",
    qq1 = "Key",
    D8A = "Policy",
    H8A = "PolicyArns",
    Nq1 = "ProviderArn",
    Lq1 = "ProvidedContexts",
    Mq1 = "ProviderId",
    C8A = "PackedPolicySize",
    Oq1 = "Provider",
    E8A = "RoleArn",
    z8A = "RoleSessionName",
    Rq1 = "SecretAccessKey",
    Tq1 = "SubjectFromWebIdentityToken",
    jv = "SourceIdentity",
    Pq1 = "SerialNumber",
    jq1 = "SessionToken",
    Sq1 = "Tags",
    _q1 = "TokenCode",
    kq1 = "TransitiveTagKeys",
    UIQ = "Version",
    yq1 = "Value",
    xq1 = "WebIdentityToken",
    vq1 = "arn",
    DW = "message",
    $IQ = S2((A) => Object.entries(A).map(([Q, B]) => (0, q7.extendedEncodeURIComponent)(Q) + "=" + (0, q7.extendedEncodeURIComponent)(B)).join("&"), "buildFormUrlencodedString"),
    Jf4 = S2((A, Q) => {
      if (Q.Error?.Code !== void 0) return Q.Error.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadQueryErrorCode"),
    mq1 = class extends Rb4.Command.classBuilder().ep(Tb4.commonParams).m(function(A, Q, B, G) {
      return [(0, Ob4.getSerdePlugin)(B, this.serialize, this.deserialize), (0, Mb4.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(void 0, AIQ).ser(Sb4).de(kb4).build() {
      static {
        S2(this, "AssumeRoleCommand")
      }
    },
    Wf4 = q5(),
    Xf4 = GZ(),
    Vf4 = K6(),
    Ff4 = wHA(),
    dq1 = class extends Vf4.Command.classBuilder().ep(Ff4.commonParams).m(function(A, Q, B, G) {
      return [(0, Xf4.getSerdePlugin)(B, this.serialize, this.deserialize), (0, Wf4.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(JIQ, WIQ).ser(_b4).de(yb4).build() {
      static {
        S2(this, "AssumeRoleWithWebIdentityCommand")
      }
    },
    Kf4 = $HA(),
    Df4 = {
      AssumeRoleCommand: mq1,
      AssumeRoleWithWebIdentityCommand: dq1
    },
    wIQ = class extends Kf4.STSClient {
      static {
        S2(this, "STS")
      }
    };
  (0, Lb4.createAggregatedClient)(Df4, wIQ);
  var Hf4 = wHA(),
    fq1 = QL(),
    tZQ = "us-east-1",
    qIQ = S2((A) => {
      if (typeof A?.Arn === "string") {
        let Q = A.Arn.split(":");
        if (Q.length > 4 && Q[4] !== "") return Q[4]
      }
      return
    }, "getAccountIdFromAssumedRoleUser"),
    NIQ = S2(async (A, Q, B) => {
      let G = typeof A === "function" ? await A() : A,
        Z = typeof Q === "function" ? await Q() : Q;
      return B?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${G} (provider)`, `${Z} (parent client)`, `${tZQ} (STS default)`), G ?? Z ?? tZQ
    }, "resolveRegion"),
    Cf4 = S2((A, Q) => {
      let B, G;
      return async (Z, I) => {
        if (G = Z, !B) {
          let {
            logger: V = A?.parentClientConfig?.logger,
            region: F,
            requestHandler: K = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: D
          } = A, H = await NIQ(F, A?.parentClientConfig?.region, D), C = !LIQ(K);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            credentialDefaultProvider: S2(() => async () => G, "credentialDefaultProvider"),
            region: H,
            requestHandler: C ? K : void 0,
            logger: V
          })
        }
        let {
          Credentials: Y,
          AssumedRoleUser: J
        } = await B.send(new mq1(I));
        if (!Y || !Y.AccessKeyId || !Y.SecretAccessKey) throw Error(`Invalid response from STS.assumeRole call with role ${I.RoleArn}`);
        let W = qIQ(J),
          X = {
            accessKeyId: Y.AccessKeyId,
            secretAccessKey: Y.SecretAccessKey,
            sessionToken: Y.SessionToken,
            expiration: Y.Expiration,
            ...Y.CredentialScope && {
              credentialScope: Y.CredentialScope
            },
            ...W && {
              accountId: W
            }
          };
        return (0, fq1.setCredentialFeature)(X, "CREDENTIALS_STS_ASSUME_ROLE", "i"), X
      }
    }, "getDefaultRoleAssumer"),
    Ef4 = S2((A, Q) => {
      let B;
      return async (G) => {
        if (!B) {
          let {
            logger: W = A?.parentClientConfig?.logger,
            region: X,
            requestHandler: V = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: F
          } = A, K = await NIQ(X, A?.parentClientConfig?.region, F), D = !LIQ(V);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            region: K,
            requestHandler: D ? V : void 0,
            logger: W
          })
        }
        let {
          Credentials: Z,
          AssumedRoleUser: I
        } = await B.send(new dq1(G));
        if (!Z || !Z.AccessKeyId || !Z.SecretAccessKey) throw Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${G.RoleArn}`);
        let Y = qIQ(I),
          J = {
            accessKeyId: Z.AccessKeyId,
            secretAccessKey: Z.SecretAccessKey,
            sessionToken: Z.SessionToken,
            expiration: Z.Expiration,
            ...Z.CredentialScope && {
              credentialScope: Z.CredentialScope
            },
            ...Y && {
              accountId: Y
            }
          };
        if (Y)(0, fq1.setCredentialFeature)(J, "RESOLVED_ACCOUNT_ID", "T");
        return (0, fq1.setCredentialFeature)(J, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"), J
      }
    }, "getDefaultRoleAssumerWithWebIdentity"),
    LIQ = S2((A) => {
      return A?.metadata?.handlerProtocol === "h2"
    }, "isH2"),
    MIQ = $HA(),
    OIQ = S2((A, Q) => {
      if (!Q) return A;
      else return class extends A {
        static {
          S2(this, "CustomizableSTSClient")
        }
        constructor(G) {
          super(G);
          for (let Z of Q) this.middlewareStack.use(Z)
        }
      }
    }, "getCustomizableStsClientCtor"),
    RIQ = S2((A = {}, Q) => Cf4(A, OIQ(MIQ.STSClient, Q)), "getDefaultRoleAssumer"),
    TIQ = S2((A = {}, Q) => Ef4(A, OIQ(MIQ.STSClient, Q)), "getDefaultRoleAssumerWithWebIdentity"),
    zf4 = S2((A) => (Q) => A({
      roleAssumer: RIQ(Q),
      roleAssumerWithWebIdentity: TIQ(Q),
      ...Q
    }), "decorateDefaultCredentialProvider")
})
// @from(Start 2856139, End 2859381)
nq1 = z((gU7, SIQ) => {
  var {
    defineProperty: $gA,
    getOwnPropertyDescriptor: Uf4,
    getOwnPropertyNames: $f4
  } = Object, wf4 = Object.prototype.hasOwnProperty, iq1 = (A, Q) => $gA(A, "name", {
    value: Q,
    configurable: !0
  }), qf4 = (A, Q) => {
    for (var B in Q) $gA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Nf4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of $f4(Q))
        if (!wf4.call(A, Z) && Z !== B) $gA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Uf4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Lf4 = (A) => Nf4($gA({}, "__esModule", {
    value: !0
  }), A), jIQ = {};
  qf4(jIQ, {
    fromProcess: () => jf4
  });
  SIQ.exports = Lf4(jIQ);
  var PIQ = SG(),
    lq1 = j2(),
    Mf4 = UA("child_process"),
    Of4 = UA("util"),
    Rf4 = QL(),
    Tf4 = iq1((A, Q, B) => {
      if (Q.Version !== 1) throw Error(`Profile ${A} credential_process did not return Version 1.`);
      if (Q.AccessKeyId === void 0 || Q.SecretAccessKey === void 0) throw Error(`Profile ${A} credential_process returned invalid credentials.`);
      if (Q.Expiration) {
        let I = new Date;
        if (new Date(Q.Expiration) < I) throw Error(`Profile ${A} credential_process returned expired credentials.`)
      }
      let G = Q.AccountId;
      if (!G && B?.[A]?.aws_account_id) G = B[A].aws_account_id;
      let Z = {
        accessKeyId: Q.AccessKeyId,
        secretAccessKey: Q.SecretAccessKey,
        ...Q.SessionToken && {
          sessionToken: Q.SessionToken
        },
        ...Q.Expiration && {
          expiration: new Date(Q.Expiration)
        },
        ...Q.CredentialScope && {
          credentialScope: Q.CredentialScope
        },
        ...G && {
          accountId: G
        }
      };
      return (0, Rf4.setCredentialFeature)(Z, "CREDENTIALS_PROCESS", "w"), Z
    }, "getValidatedProcessCredentials"),
    Pf4 = iq1(async (A, Q, B) => {
      let G = Q[A];
      if (Q[A]) {
        let Z = G.credential_process;
        if (Z !== void 0) {
          let I = (0, Of4.promisify)(Mf4.exec);
          try {
            let {
              stdout: Y
            } = await I(Z), J;
            try {
              J = JSON.parse(Y.trim())
            } catch {
              throw Error(`Profile ${A} credential_process returned invalid JSON.`)
            }
            return Tf4(A, J, Q)
          } catch (Y) {
            throw new lq1.CredentialsProviderError(Y.message, {
              logger: B
            })
          }
        } else throw new lq1.CredentialsProviderError(`Profile ${A} did not contain credential_process.`, {
          logger: B
        })
      } else throw new lq1.CredentialsProviderError(`Profile ${A} could not be found in shared credentials file.`, {
        logger: B
      })
    }, "resolveProcessCredentials"),
    jf4 = iq1((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
      let B = await (0, PIQ.parseKnownFiles)(A);
      return Pf4((0, PIQ.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), B, A.logger)
    }, "fromProcess")
})
// @from(Start 2859387, End 2861711)
aq1 = z((RS) => {
  var Sf4 = RS && RS.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    _f4 = RS && RS.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    kf4 = RS && RS.__importStar || function() {
      var A = function(Q) {
        return A = Object.getOwnPropertyNames || function(B) {
          var G = [];
          for (var Z in B)
            if (Object.prototype.hasOwnProperty.call(B, Z)) G[G.length] = Z;
          return G
        }, A(Q)
      };
      return function(Q) {
        if (Q && Q.__esModule) return Q;
        var B = {};
        if (Q != null) {
          for (var G = A(Q), Z = 0; Z < G.length; Z++)
            if (G[Z] !== "default") Sf4(B, Q, G[Z])
        }
        return _f4(B, Q), B
      }
    }();
  Object.defineProperty(RS, "__esModule", {
    value: !0
  });
  RS.fromWebToken = void 0;
  var yf4 = (A) => async (Q) => {
    A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    let {
      roleArn: B,
      roleSessionName: G,
      webIdentityToken: Z,
      providerId: I,
      policyArns: Y,
      policy: J,
      durationSeconds: W
    } = A, {
      roleAssumerWithWebIdentity: X
    } = A;
    if (!X) {
      let {
        getDefaultRoleAssumerWithWebIdentity: V
      } = await Promise.resolve().then(() => kf4(pq1()));
      X = V({
        ...A.clientConfig,
        credentialProviderLogger: A.logger,
        parentClientConfig: {
          ...Q?.callerClientConfig,
          ...A.parentClientConfig
        }
      }, A.clientPlugins)
    }
    return X({
      RoleArn: B,
      RoleSessionName: G ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: Z,
      ProviderId: I,
      PolicyArns: Y,
      Policy: J,
      DurationSeconds: W
    })
  };
  RS.fromWebToken = yf4
})
// @from(Start 2861717, End 2862792)
xIQ = z((kIQ) => {
  Object.defineProperty(kIQ, "__esModule", {
    value: !0
  });
  kIQ.fromTokenFile = void 0;
  var xf4 = QL(),
    vf4 = j2(),
    bf4 = UA("fs"),
    ff4 = aq1(),
    _IQ = "AWS_WEB_IDENTITY_TOKEN_FILE",
    hf4 = "AWS_ROLE_ARN",
    gf4 = "AWS_ROLE_SESSION_NAME",
    uf4 = (A = {}) => async () => {
      A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
      let Q = A?.webIdentityTokenFile ?? process.env[_IQ],
        B = A?.roleArn ?? process.env[hf4],
        G = A?.roleSessionName ?? process.env[gf4];
      if (!Q || !B) throw new vf4.CredentialsProviderError("Web identity configuration not specified", {
        logger: A.logger
      });
      let Z = await (0, ff4.fromWebToken)({
        ...A,
        webIdentityToken: (0, bf4.readFileSync)(Q, {
          encoding: "ascii"
        }),
        roleArn: B,
        roleSessionName: G
      })();
      if (Q === process.env[_IQ])(0, xf4.setCredentialFeature)(Z, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
      return Z
    };
  kIQ.fromTokenFile = uf4
})
// @from(Start 2862798, End 2863494)
oq1 = z((dU7, wgA) => {
  var {
    defineProperty: vIQ,
    getOwnPropertyDescriptor: mf4,
    getOwnPropertyNames: df4
  } = Object, cf4 = Object.prototype.hasOwnProperty, sq1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of df4(Q))
        if (!cf4.call(A, Z) && Z !== B) vIQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = mf4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bIQ = (A, Q, B) => (sq1(A, Q, "default"), B && sq1(B, Q, "default")), pf4 = (A) => sq1(vIQ({}, "__esModule", {
    value: !0
  }), A), rq1 = {};
  wgA.exports = pf4(rq1);
  bIQ(rq1, xIQ(), wgA.exports);
  bIQ(rq1, aq1(), wgA.exports)
})
// @from(Start 2863500, End 2873222)
pIQ = z((cU7, cIQ) => {
  var {
    create: lf4,
    defineProperty: NHA,
    getOwnPropertyDescriptor: if4,
    getOwnPropertyNames: nf4,
    getPrototypeOf: af4
  } = Object, sf4 = Object.prototype.hasOwnProperty, jX = (A, Q) => NHA(A, "name", {
    value: Q,
    configurable: !0
  }), rf4 = (A, Q) => {
    for (var B in Q) NHA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, uIQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of nf4(Q))
        if (!sf4.call(A, Z) && Z !== B) NHA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = if4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Nd = (A, Q, B) => (B = A != null ? lf4(af4(A)) : {}, uIQ(Q || !A || !A.__esModule ? NHA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), of4 = (A) => uIQ(NHA({}, "__esModule", {
    value: !0
  }), A), mIQ = {};
  rf4(mIQ, {
    fromIni: () => Xh4
  });
  cIQ.exports = of4(mIQ);
  var eq1 = SG(),
    Ld = QL(),
    qHA = j2(),
    tf4 = jX((A, Q, B) => {
      let G = {
        EcsContainer: jX(async (Z) => {
          let {
            fromHttp: I
          } = await Promise.resolve().then(() => Nd(vw1())), {
            fromContainerMetadata: Y
          } = await Promise.resolve().then(() => Nd(OV()));
          return B?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => (0, qHA.chain)(I(Z ?? {}), Y(Z))().then(tq1)
        }, "EcsContainer"),
        Ec2InstanceMetadata: jX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
          let {
            fromInstanceMetadata: I
          } = await Promise.resolve().then(() => Nd(OV()));
          return async () => I(Z)().then(tq1)
        }, "Ec2InstanceMetadata"),
        Environment: jX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
          let {
            fromEnv: I
          } = await Promise.resolve().then(() => Nd(Tw1()));
          return async () => I(Z)().then(tq1)
        }, "Environment")
      };
      if (A in G) return G[A];
      else throw new qHA.CredentialsProviderError(`Unsupported credential source in profile ${Q}. Got ${A}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, {
        logger: B
      })
    }, "resolveCredentialSource"),
    tq1 = jX((A) => (0, Ld.setCredentialFeature)(A, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"), "setNamedProvider"),
    ef4 = jX((A, {
      profile: Q = "default",
      logger: B
    } = {}) => {
      return Boolean(A) && typeof A === "object" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof A.external_id) > -1 && ["undefined", "string"].indexOf(typeof A.mfa_serial) > -1 && (Ah4(A, {
        profile: Q,
        logger: B
      }) || Qh4(A, {
        profile: Q,
        logger: B
      }))
    }, "isAssumeRoleProfile"),
    Ah4 = jX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.source_profile === "string" && typeof A.credential_source > "u";
      if (G) B?.debug?.(`    ${Q} isAssumeRoleWithSourceProfile source_profile=${A.source_profile}`);
      return G
    }, "isAssumeRoleWithSourceProfile"),
    Qh4 = jX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.credential_source === "string" && typeof A.source_profile > "u";
      if (G) B?.debug?.(`    ${Q} isCredentialSourceProfile credential_source=${A.credential_source}`);
      return G
    }, "isCredentialSourceProfile"),
    Bh4 = jX(async (A, Q, B, G = {}) => {
      B.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
      let Z = Q[A],
        {
          source_profile: I,
          region: Y
        } = Z;
      if (!B.roleAssumer) {
        let {
          getDefaultRoleAssumer: W
        } = await Promise.resolve().then(() => Nd(pq1()));
        B.roleAssumer = W({
          ...B.clientConfig,
          credentialProviderLogger: B.logger,
          parentClientConfig: {
            ...B?.parentClientConfig,
            region: Y ?? B?.parentClientConfig?.region
          }
        }, B.clientPlugins)
      }
      if (I && I in G) throw new qHA.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${(0,eq1.getProfileName)(B)}. Profiles visited: ` + Object.keys(G).join(", "), {
        logger: B.logger
      });
      B.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${I?`source_profile=[${I}]`:`profile=[${A}]`}`);
      let J = I ? dIQ(I, Q, B, {
        ...G,
        [I]: !0
      }, fIQ(Q[I] ?? {})) : (await tf4(Z.credential_source, A, B.logger)(B))();
      if (fIQ(Z)) return J.then((W) => (0, Ld.setCredentialFeature)(W, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      else {
        let W = {
            RoleArn: Z.role_arn,
            RoleSessionName: Z.role_session_name || `aws-sdk-js-${Date.now()}`,
            ExternalId: Z.external_id,
            DurationSeconds: parseInt(Z.duration_seconds || "3600", 10)
          },
          {
            mfa_serial: X
          } = Z;
        if (X) {
          if (!B.mfaCodeProvider) throw new qHA.CredentialsProviderError(`Profile ${A} requires multi-factor authentication, but no MFA code callback was provided.`, {
            logger: B.logger,
            tryNextLink: !1
          });
          W.SerialNumber = X, W.TokenCode = await B.mfaCodeProvider(X)
        }
        let V = await J;
        return B.roleAssumer(V, W).then((F) => (0, Ld.setCredentialFeature)(F, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"))
      }
    }, "resolveAssumeRoleCredentials"),
    fIQ = jX((A) => {
      return !A.role_arn && !!A.credential_source
    }, "isCredentialSourceWithoutRoleArn"),
    Gh4 = jX((A) => Boolean(A) && typeof A === "object" && typeof A.credential_process === "string", "isProcessProfile"),
    Zh4 = jX(async (A, Q) => Promise.resolve().then(() => Nd(nq1())).then(({
      fromProcess: B
    }) => B({
      ...A,
      profile: Q
    })().then((G) => (0, Ld.setCredentialFeature)(G, "CREDENTIALS_PROFILE_PROCESS", "v"))), "resolveProcessCredentials"),
    Ih4 = jX(async (A, Q, B = {}) => {
      let {
        fromSSO: G
      } = await Promise.resolve().then(() => Nd(Zq1()));
      return G({
        profile: A,
        logger: B.logger,
        parentClientConfig: B.parentClientConfig,
        clientConfig: B.clientConfig
      })().then((Z) => {
        if (Q.sso_session) return (0, Ld.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO", "r");
        else return (0, Ld.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      })
    }, "resolveSsoCredentials"),
    Yh4 = jX((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    hIQ = jX((A) => Boolean(A) && typeof A === "object" && typeof A.aws_access_key_id === "string" && typeof A.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof A.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof A.aws_account_id) > -1, "isStaticCredsProfile"),
    gIQ = jX(async (A, Q) => {
      Q?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
      let B = {
        accessKeyId: A.aws_access_key_id,
        secretAccessKey: A.aws_secret_access_key,
        sessionToken: A.aws_session_token,
        ...A.aws_credential_scope && {
          credentialScope: A.aws_credential_scope
        },
        ...A.aws_account_id && {
          accountId: A.aws_account_id
        }
      };
      return (0, Ld.setCredentialFeature)(B, "CREDENTIALS_PROFILE", "n")
    }, "resolveStaticCredentials"),
    Jh4 = jX((A) => Boolean(A) && typeof A === "object" && typeof A.web_identity_token_file === "string" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1, "isWebIdentityProfile"),
    Wh4 = jX(async (A, Q) => Promise.resolve().then(() => Nd(oq1())).then(({
      fromTokenFile: B
    }) => B({
      webIdentityTokenFile: A.web_identity_token_file,
      roleArn: A.role_arn,
      roleSessionName: A.role_session_name,
      roleAssumerWithWebIdentity: Q.roleAssumerWithWebIdentity,
      logger: Q.logger,
      parentClientConfig: Q.parentClientConfig
    })().then((G) => (0, Ld.setCredentialFeature)(G, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))), "resolveWebIdentityCredentials"),
    dIQ = jX(async (A, Q, B, G = {}, Z = !1) => {
      let I = Q[A];
      if (Object.keys(G).length > 0 && hIQ(I)) return gIQ(I, B);
      if (Z || ef4(I, {
          profile: A,
          logger: B.logger
        })) return Bh4(A, Q, B, G);
      if (hIQ(I)) return gIQ(I, B);
      if (Jh4(I)) return Wh4(I, B);
      if (Gh4(I)) return Zh4(B, A);
      if (Yh4(I)) return await Ih4(A, I, B);
      throw new qHA.CredentialsProviderError(`Could not resolve credentials using profile: [${A}] in configuration/credentials file(s).`, {
        logger: B.logger
      })
    }, "resolveProfileData"),
    Xh4 = jX((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
      let G = await (0, eq1.parseKnownFiles)(B);
      return dIQ((0, eq1.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), G, B)
    }, "fromIni")
})
// @from(Start 2873228, End 2878190)
tIQ = z((pU7, oIQ) => {
  var {
    create: Vh4,
    defineProperty: LHA,
    getOwnPropertyDescriptor: Fh4,
    getOwnPropertyNames: Kh4,
    getPrototypeOf: Dh4
  } = Object, Hh4 = Object.prototype.hasOwnProperty, qgA = (A, Q) => LHA(A, "name", {
    value: Q,
    configurable: !0
  }), Ch4 = (A, Q) => {
    for (var B in Q) LHA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, nIQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Kh4(Q))
        if (!Hh4.call(A, Z) && Z !== B) LHA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Fh4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, U8A = (A, Q, B) => (B = A != null ? Vh4(Dh4(A)) : {}, nIQ(Q || !A || !A.__esModule ? LHA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), Eh4 = (A) => nIQ(LHA({}, "__esModule", {
    value: !0
  }), A), aIQ = {};
  Ch4(aIQ, {
    credentialsTreatedAsExpired: () => rIQ,
    credentialsWillNeedRefresh: () => sIQ,
    defaultProvider: () => $h4
  });
  oIQ.exports = Eh4(aIQ);
  var AN1 = Tw1(),
    zh4 = SG(),
    ir = j2(),
    lIQ = "AWS_EC2_METADATA_DISABLED",
    Uh4 = qgA(async (A) => {
      let {
        ENV_CMDS_FULL_URI: Q,
        ENV_CMDS_RELATIVE_URI: B,
        fromContainerMetadata: G,
        fromInstanceMetadata: Z
      } = await Promise.resolve().then(() => U8A(OV()));
      if (process.env[B] || process.env[Q]) {
        A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        let {
          fromHttp: I
        } = await Promise.resolve().then(() => U8A(vw1()));
        return (0, ir.chain)(I(A), G(A))
      }
      if (process.env[lIQ] && process.env[lIQ] !== "false") return async () => {
        throw new ir.CredentialsProviderError("EC2 Instance Metadata Service access disabled", {
          logger: A.logger
        })
      };
      return A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), Z(A)
    }, "remoteProvider"),
    iIQ = !1,
    $h4 = qgA((A = {}) => (0, ir.memoize)((0, ir.chain)(async () => {
      if (A.profile ?? process.env[zh4.ENV_PROFILE]) {
        if (process.env[AN1.ENV_KEY] && process.env[AN1.ENV_SECRET]) {
          if (!iIQ)(A.logger?.warn && A.logger?.constructor?.name !== "NoOpLogger" ? A.logger.warn : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), iIQ = !0
        }
        throw new ir.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
          logger: A.logger,
          tryNextLink: !0
        })
      }
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), (0, AN1.fromEnv)(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
      let {
        ssoStartUrl: Q,
        ssoAccountId: B,
        ssoRegion: G,
        ssoRoleName: Z,
        ssoSession: I
      } = A;
      if (!Q && !B && !G && !Z && !I) throw new ir.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", {
        logger: A.logger
      });
      let {
        fromSSO: Y
      } = await Promise.resolve().then(() => U8A(Zq1()));
      return Y(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
      let {
        fromIni: Q
      } = await Promise.resolve().then(() => U8A(pIQ()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
      let {
        fromProcess: Q
      } = await Promise.resolve().then(() => U8A(nq1()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
      let {
        fromTokenFile: Q
      } = await Promise.resolve().then(() => U8A(oq1()));
      return Q(A)()
    }, async () => {
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await Uh4(A))()
    }, async () => {
      throw new ir.CredentialsProviderError("Could not load credentials from any providers", {
        tryNextLink: !1,
        logger: A.logger
      })
    }), rIQ, sIQ), "defaultProvider"),
    sIQ = qgA((A) => A?.expiration !== void 0, "credentialsWillNeedRefresh"),
    rIQ = qgA((A) => A?.expiration !== void 0 && A.expiration.getTime() - Date.now() < 300000, "credentialsTreatedAsExpired")
})
// @from(Start 2878196, End 2886373)
NYQ = z((wYQ) => {
  Object.defineProperty(wYQ, "__esModule", {
    value: !0
  });
  wYQ.ruleSet = void 0;
  var VYQ = "required",
    g8 = "type",
    o3 = "fn",
    t3 = "argv",
    Od = "ref",
    eIQ = !1,
    QN1 = !0,
    Md = "booleanEquals",
    QD = "stringEquals",
    FYQ = "sigv4",
    KYQ = "sts",
    DYQ = "us-east-1",
    dI = "endpoint",
    AYQ = "https://sts.{Region}.{PartitionResult#dnsSuffix}",
    TS = "tree",
    $8A = "error",
    GN1 = "getAttr",
    QYQ = {
      [VYQ]: !1,
      [g8]: "String"
    },
    BN1 = {
      [VYQ]: !0,
      default: !1,
      [g8]: "Boolean"
    },
    HYQ = {
      [Od]: "Endpoint"
    },
    BYQ = {
      [o3]: "isSet",
      [t3]: [{
        [Od]: "Region"
      }]
    },
    BD = {
      [Od]: "Region"
    },
    GYQ = {
      [o3]: "aws.partition",
      [t3]: [BD],
      assign: "PartitionResult"
    },
    CYQ = {
      [Od]: "UseFIPS"
    },
    EYQ = {
      [Od]: "UseDualStack"
    },
    wH = {
      url: "https://sts.amazonaws.com",
      properties: {
        authSchemes: [{
          name: FYQ,
          signingName: KYQ,
          signingRegion: DYQ
        }]
      },
      headers: {}
    },
    zw = {},
    ZYQ = {
      conditions: [{
        [o3]: QD,
        [t3]: [BD, "aws-global"]
      }],
      [dI]: wH,
      [g8]: dI
    },
    zYQ = {
      [o3]: Md,
      [t3]: [CYQ, !0]
    },
    UYQ = {
      [o3]: Md,
      [t3]: [EYQ, !0]
    },
    IYQ = {
      [o3]: GN1,
      [t3]: [{
        [Od]: "PartitionResult"
      }, "supportsFIPS"]
    },
    $YQ = {
      [Od]: "PartitionResult"
    },
    YYQ = {
      [o3]: Md,
      [t3]: [!0, {
        [o3]: GN1,
        [t3]: [$YQ, "supportsDualStack"]
      }]
    },
    JYQ = [{
      [o3]: "isSet",
      [t3]: [HYQ]
    }],
    WYQ = [zYQ],
    XYQ = [UYQ],
    wh4 = {
      version: "1.0",
      parameters: {
        Region: QYQ,
        UseDualStack: BN1,
        UseFIPS: BN1,
        Endpoint: QYQ,
        UseGlobalEndpoint: BN1
      },
      rules: [{
        conditions: [{
          [o3]: Md,
          [t3]: [{
            [Od]: "UseGlobalEndpoint"
          }, QN1]
        }, {
          [o3]: "not",
          [t3]: JYQ
        }, BYQ, GYQ, {
          [o3]: Md,
          [t3]: [CYQ, eIQ]
        }, {
          [o3]: Md,
          [t3]: [EYQ, eIQ]
        }],
        rules: [{
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "ap-northeast-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "ap-south-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "ap-southeast-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "ap-southeast-2"]
          }],
          endpoint: wH,
          [g8]: dI
        }, ZYQ, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "ca-central-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "eu-central-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "eu-north-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "eu-west-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "eu-west-2"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "eu-west-3"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "sa-east-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, DYQ]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "us-east-2"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "us-west-1"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          conditions: [{
            [o3]: QD,
            [t3]: [BD, "us-west-2"]
          }],
          endpoint: wH,
          [g8]: dI
        }, {
          endpoint: {
            url: AYQ,
            properties: {
              authSchemes: [{
                name: FYQ,
                signingName: KYQ,
                signingRegion: "{Region}"
              }]
            },
            headers: zw
          },
          [g8]: dI
        }],
        [g8]: TS
      }, {
        conditions: JYQ,
        rules: [{
          conditions: WYQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          [g8]: $8A
        }, {
          conditions: XYQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          [g8]: $8A
        }, {
          endpoint: {
            url: HYQ,
            properties: zw,
            headers: zw
          },
          [g8]: dI
        }],
        [g8]: TS
      }, {
        conditions: [BYQ],
        rules: [{
          conditions: [GYQ],
          rules: [{
            conditions: [zYQ, UYQ],
            rules: [{
              conditions: [{
                [o3]: Md,
                [t3]: [QN1, IYQ]
              }, YYQ],
              rules: [{
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: zw,
                  headers: zw
                },
                [g8]: dI
              }],
              [g8]: TS
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              [g8]: $8A
            }],
            [g8]: TS
          }, {
            conditions: WYQ,
            rules: [{
              conditions: [{
                [o3]: Md,
                [t3]: [IYQ, QN1]
              }],
              rules: [{
                conditions: [{
                  [o3]: QD,
                  [t3]: [{
                    [o3]: GN1,
                    [t3]: [$YQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://sts.{Region}.amazonaws.com",
                  properties: zw,
                  headers: zw
                },
                [g8]: dI
              }, {
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: zw,
                  headers: zw
                },
                [g8]: dI
              }],
              [g8]: TS
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              [g8]: $8A
            }],
            [g8]: TS
          }, {
            conditions: XYQ,
            rules: [{
              conditions: [YYQ],
              rules: [{
                endpoint: {
                  url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: zw,
                  headers: zw
                },
                [g8]: dI
              }],
              [g8]: TS
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              [g8]: $8A
            }],
            [g8]: TS
          }, ZYQ, {
            endpoint: {
              url: AYQ,
              properties: zw,
              headers: zw
            },
            [g8]: dI
          }],
          [g8]: TS
        }],
        [g8]: TS
      }, {
        error: "Invalid Configuration: Missing Region",
        [g8]: $8A
      }]
    };
  wYQ.ruleSet = wh4
})
// @from(Start 2886379, End 2886964)
OYQ = z((LYQ) => {
  Object.defineProperty(LYQ, "__esModule", {
    value: !0
  });
  LYQ.defaultEndpointResolver = void 0;
  var qh4 = p4A(),
    ZN1 = FI(),
    Nh4 = NYQ(),
    Lh4 = new ZN1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    }),
    Mh4 = (A, Q = {}) => {
      return Lh4.get(A, () => (0, ZN1.resolveEndpoint)(Nh4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  LYQ.defaultEndpointResolver = Mh4;
  ZN1.customEndpointFunctions.aws = qh4.awsEndpointFunctions
})
// @from(Start 2886970, End 2888379)
SYQ = z((PYQ) => {
  Object.defineProperty(PYQ, "__esModule", {
    value: !0
  });
  PYQ.getRuntimeConfig = void 0;
  var Oh4 = MF(),
    Rh4 = iB(),
    Th4 = K6(),
    Ph4 = NJ(),
    RYQ = Fd(),
    TYQ = O2(),
    jh4 = Rw1(),
    Sh4 = OYQ(),
    _h4 = (A) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: A?.base64Decoder ?? RYQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? RYQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? Sh4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? jh4.defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Oh4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Rh4.NoAuthSigner
        }],
        logger: A?.logger ?? new Th4.NoOpLogger,
        serviceId: A?.serviceId ?? "STS",
        urlParser: A?.urlParser ?? Ph4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? TYQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? TYQ.toUtf8
      }
    };
  PYQ.getRuntimeConfig = _h4
})
// @from(Start 2888385, End 2891289)
fYQ = z((vYQ) => {
  Object.defineProperty(vYQ, "__esModule", {
    value: !0
  });
  vYQ.getRuntimeConfig = void 0;
  var kh4 = yr(),
    yh4 = kh4.__importDefault(Y5Q()),
    IN1 = MF(),
    _YQ = tIQ(),
    kYQ = XHA(),
    NgA = f8(),
    xh4 = iB(),
    vh4 = RX(),
    yYQ = D6(),
    nr = uI(),
    xYQ = IZ(),
    bh4 = TX(),
    fh4 = KW(),
    hh4 = SYQ(),
    gh4 = K6(),
    uh4 = PX(),
    mh4 = K6(),
    dh4 = (A) => {
      (0, mh4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, uh4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(gh4.loadConfigsForDefaultMode),
        G = (0, hh4.getRuntimeConfig)(A);
      (0, IN1.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, nr.loadConfig)(IN1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? bh4.calculateBodyLength,
        credentialDefaultProvider: A?.credentialDefaultProvider ?? _YQ.defaultProvider,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, kYQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: yh4.default.version
        }),
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (I) => I.getIdentityProvider("aws.auth#sigv4") || (async (Y) => await (0, _YQ.defaultProvider)(Y?.__config || {})()),
          signer: new IN1.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (I) => I.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new xh4.NoAuthSigner
        }],
        maxAttempts: A?.maxAttempts ?? (0, nr.loadConfig)(yYQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, nr.loadConfig)(NgA.NODE_REGION_CONFIG_OPTIONS, {
          ...NgA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: xYQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, nr.loadConfig)({
          ...yYQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || fh4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? vh4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? xYQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, nr.loadConfig)(NgA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, nr.loadConfig)(NgA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, nr.loadConfig)(kYQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  vYQ.getRuntimeConfig = dh4
})
// @from(Start 2891295, End 2892314)
uYQ = z((hYQ) => {
  Object.defineProperty(hYQ, "__esModule", {
    value: !0
  });
  hYQ.resolveHttpAuthRuntimeConfig = hYQ.getHttpAuthExtensionConfiguration = void 0;
  var ch4 = (A) => {
    let {
      httpAuthSchemes: Q,
      httpAuthSchemeProvider: B,
      credentials: G
    } = A;
    return {
      setHttpAuthScheme(Z) {
        let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
        if (I === -1) Q.push(Z);
        else Q.splice(I, 1, Z)
      },
      httpAuthSchemes() {
        return Q
      },
      setHttpAuthSchemeProvider(Z) {
        B = Z
      },
      httpAuthSchemeProvider() {
        return B
      },
      setCredentials(Z) {
        G = Z
      },
      credentials() {
        return G
      }
    }
  };
  hYQ.getHttpAuthExtensionConfiguration = ch4;
  var ph4 = (A) => {
    return {
      httpAuthSchemes: A.httpAuthSchemes(),
      httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
      credentials: A.credentials()
    }
  };
  hYQ.resolveHttpAuthRuntimeConfig = ph4
})
// @from(Start 2892320, End 2893045)
nYQ = z((lYQ) => {
  Object.defineProperty(lYQ, "__esModule", {
    value: !0
  });
  lYQ.resolveRuntimeExtensions = void 0;
  var mYQ = KHA(),
    dYQ = nC(),
    cYQ = K6(),
    pYQ = uYQ(),
    ih4 = (A, Q) => {
      let B = Object.assign((0, mYQ.getAwsRegionExtensionConfiguration)(A), (0, cYQ.getDefaultExtensionConfiguration)(A), (0, dYQ.getHttpHandlerExtensionConfiguration)(A), (0, pYQ.getHttpAuthExtensionConfiguration)(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, mYQ.resolveAwsRegionExtensionConfiguration)(B), (0, cYQ.resolveDefaultRuntimeConfig)(B), (0, dYQ.resolveHttpHandlerRuntimeConfig)(B), (0, pYQ.resolveHttpAuthRuntimeConfig)(B))
    };
  lYQ.resolveRuntimeExtensions = ih4
})
// @from(Start 2893051, End 2895032)
WHA = z((JN1) => {
  Object.defineProperty(JN1, "__esModule", {
    value: !0
  });
  JN1.STSClient = JN1.__Client = void 0;
  var aYQ = yDA(),
    nh4 = xDA(),
    ah4 = vDA(),
    sYQ = r4A(),
    sh4 = f8(),
    YN1 = iB(),
    rh4 = LX(),
    oh4 = q5(),
    rYQ = D6(),
    tYQ = K6();
  Object.defineProperty(JN1, "__Client", {
    enumerable: !0,
    get: function() {
      return tYQ.Client
    }
  });
  var oYQ = Rw1(),
    th4 = IL(),
    eh4 = fYQ(),
    Ag4 = nYQ();
  class eYQ extends tYQ.Client {
    config;
    constructor(...[A]) {
      let Q = (0, eh4.getRuntimeConfig)(A || {});
      super(Q);
      this.initConfig = Q;
      let B = (0, th4.resolveClientEndpointParameters)(Q),
        G = (0, sYQ.resolveUserAgentConfig)(B),
        Z = (0, rYQ.resolveRetryConfig)(G),
        I = (0, sh4.resolveRegionConfig)(Z),
        Y = (0, aYQ.resolveHostHeaderConfig)(I),
        J = (0, oh4.resolveEndpointConfig)(Y),
        W = (0, oYQ.resolveHttpAuthSchemeConfig)(J),
        X = (0, Ag4.resolveRuntimeExtensions)(W, A?.extensions || []);
      this.config = X, this.middlewareStack.use((0, sYQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, rYQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, rh4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, aYQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, nh4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, ah4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, YN1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: oYQ.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (V) => new YN1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": V.credentials
        })
      })), this.middlewareStack.use((0, YN1.getHttpSigningPlugin)(this.config))
    }
    destroy() {
      super.destroy()
    }
  }
  JN1.STSClient = eYQ
})
// @from(Start 2895038, End 2932689)
bJQ = z((eU7, cN1) => {
  var {
    defineProperty: LgA,
    getOwnPropertyDescriptor: Qg4,
    getOwnPropertyNames: Bg4
  } = Object, Gg4 = Object.prototype.hasOwnProperty, XQ = (A, Q) => LgA(A, "name", {
    value: Q,
    configurable: !0
  }), Zg4 = (A, Q) => {
    for (var B in Q) LgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, fN1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Bg4(Q))
        if (!Gg4.call(A, Z) && Z !== B) LgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Qg4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Ig4 = (A, Q, B) => (fN1(A, Q, "default"), B && fN1(B, Q, "default")), Yg4 = (A) => fN1(LgA({}, "__esModule", {
    value: !0
  }), A), gN1 = {};
  Zg4(gN1, {
    AssumeRoleCommand: () => mN1,
    AssumeRoleResponseFilterSensitiveLog: () => FJQ,
    AssumeRoleWithSAMLCommand: () => qJQ,
    AssumeRoleWithSAMLRequestFilterSensitiveLog: () => KJQ,
    AssumeRoleWithSAMLResponseFilterSensitiveLog: () => DJQ,
    AssumeRoleWithWebIdentityCommand: () => dN1,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => HJQ,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => CJQ,
    AssumeRootCommand: () => NJQ,
    AssumeRootResponseFilterSensitiveLog: () => EJQ,
    ClientInputEndpointParameters: () => yu4.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => ar,
    DecodeAuthorizationMessageCommand: () => LJQ,
    ExpiredTokenException: () => GJQ,
    GetAccessKeyInfoCommand: () => MJQ,
    GetCallerIdentityCommand: () => OJQ,
    GetFederationTokenCommand: () => RJQ,
    GetFederationTokenResponseFilterSensitiveLog: () => zJQ,
    GetSessionTokenCommand: () => TJQ,
    GetSessionTokenResponseFilterSensitiveLog: () => UJQ,
    IDPCommunicationErrorException: () => XJQ,
    IDPRejectedClaimException: () => JJQ,
    InvalidAuthorizationMessageException: () => VJQ,
    InvalidIdentityTokenException: () => WJQ,
    MalformedPolicyDocumentException: () => ZJQ,
    PackedPolicyTooLargeException: () => IJQ,
    RegionDisabledException: () => YJQ,
    STS: () => PJQ,
    STSServiceException: () => PS,
    decorateDefaultCredentialProvider: () => bu4,
    getDefaultRoleAssumer: () => xJQ,
    getDefaultRoleAssumerWithWebIdentity: () => vJQ
  });
  cN1.exports = Yg4(gN1);
  Ig4(gN1, WHA(), cN1.exports);
  var vv = q5(),
    bv = GZ(),
    Jg4 = IL(),
    P2 = K6(),
    PS = class A extends P2.ServiceException {
      static {
        XQ(this, "STSServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    GJQ = class A extends PS {
      static {
        XQ(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    ZJQ = class A extends PS {
      static {
        XQ(this, "MalformedPolicyDocumentException")
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    IJQ = class A extends PS {
      static {
        XQ(this, "PackedPolicyTooLargeException")
      }
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    YJQ = class A extends PS {
      static {
        XQ(this, "RegionDisabledException")
      }
      name = "RegionDisabledException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    JJQ = class A extends PS {
      static {
        XQ(this, "IDPRejectedClaimException")
      }
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    WJQ = class A extends PS {
      static {
        XQ(this, "InvalidIdentityTokenException")
      }
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    XJQ = class A extends PS {
      static {
        XQ(this, "IDPCommunicationErrorException")
      }
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    VJQ = class A extends PS {
      static {
        XQ(this, "InvalidAuthorizationMessageException")
      }
      name = "InvalidAuthorizationMessageException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidAuthorizationMessageException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    ar = XQ((A) => ({
      ...A,
      ...A.SecretAccessKey && {
        SecretAccessKey: P2.SENSITIVE_STRING
      }
    }), "CredentialsFilterSensitiveLog"),
    FJQ = XQ((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ar(A.Credentials)
      }
    }), "AssumeRoleResponseFilterSensitiveLog"),
    KJQ = XQ((A) => ({
      ...A,
      ...A.SAMLAssertion && {
        SAMLAssertion: P2.SENSITIVE_STRING
      }
    }), "AssumeRoleWithSAMLRequestFilterSensitiveLog"),
    DJQ = XQ((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ar(A.Credentials)
      }
    }), "AssumeRoleWithSAMLResponseFilterSensitiveLog"),
    HJQ = XQ((A) => ({
      ...A,
      ...A.WebIdentityToken && {
        WebIdentityToken: P2.SENSITIVE_STRING
      }
    }), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog"),
    CJQ = XQ((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ar(A.Credentials)
      }
    }), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog"),
    EJQ = XQ((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ar(A.Credentials)
      }
    }), "AssumeRootResponseFilterSensitiveLog"),
    zJQ = XQ((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ar(A.Credentials)
      }
    }), "GetFederationTokenResponseFilterSensitiveLog"),
    UJQ = XQ((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ar(A.Credentials)
      }
    }), "GetSessionTokenResponseFilterSensitiveLog"),
    jS = MF(),
    Wg4 = nC(),
    Xg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...vg4(A, Q),
        [mv]: Du4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_AssumeRoleCommand"),
    Vg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...bg4(A, Q),
        [mv]: Hu4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_AssumeRoleWithSAMLCommand"),
    Fg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...fg4(A, Q),
        [mv]: Cu4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_AssumeRoleWithWebIdentityCommand"),
    Kg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...hg4(A, Q),
        [mv]: Eu4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_AssumeRootCommand"),
    Dg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...gg4(A, Q),
        [mv]: zu4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_DecodeAuthorizationMessageCommand"),
    Hg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...ug4(A, Q),
        [mv]: Uu4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_GetAccessKeyInfoCommand"),
    Cg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...mg4(A, Q),
        [mv]: $u4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_GetCallerIdentityCommand"),
    Eg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...dg4(A, Q),
        [mv]: wu4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_GetFederationTokenCommand"),
    zg4 = XQ(async (A, Q) => {
      let B = gv,
        G;
      return G = cv({
        ...cg4(A, Q),
        [mv]: qu4,
        [dv]: uv
      }), hv(Q, B, "/", void 0, G)
    }, "se_GetSessionTokenCommand"),
    Ug4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = ag4(B.AssumeRoleResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_AssumeRoleCommand"),
    $g4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = sg4(B.AssumeRoleWithSAMLResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_AssumeRoleWithSAMLCommand"),
    wg4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = rg4(B.AssumeRoleWithWebIdentityResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_AssumeRoleWithWebIdentityCommand"),
    qg4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = og4(B.AssumeRootResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_AssumeRootCommand"),
    Ng4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = tg4(B.DecodeAuthorizationMessageResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_DecodeAuthorizationMessageCommand"),
    Lg4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = Qu4(B.GetAccessKeyInfoResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_GetAccessKeyInfoCommand"),
    Mg4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = Bu4(B.GetCallerIdentityResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_GetCallerIdentityCommand"),
    Og4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = Gu4(B.GetFederationTokenResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_GetFederationTokenCommand"),
    Rg4 = XQ(async (A, Q) => {
      if (A.statusCode >= 300) return fv(A, Q);
      let B = await (0, jS.parseXmlBody)(A.body, Q),
        G = {};
      return G = Zu4(B.GetSessionTokenResult, Q), {
        $metadata: GD(A),
        ...G
      }
    }, "de_GetSessionTokenCommand"),
    fv = XQ(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, jS.parseXmlErrorBody)(A.body, Q)
        },
        G = Nu4(A, B.body);
      switch (G) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await Tg4(B, Q);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await kg4(B, Q);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await yg4(B, Q);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await xg4(B, Q);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await jg4(B, Q);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await _g4(B, Q);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await Pg4(B, Q);
        case "InvalidAuthorizationMessageException":
        case "com.amazonaws.sts#InvalidAuthorizationMessageException":
          throw await Sg4(B, Q);
        default:
          let Z = B.body;
          return Ku4({
            output: A,
            parsedBody: Z.Error,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    Tg4 = XQ(async (A, Q) => {
      let B = A.body,
        G = eg4(B.Error, Q),
        Z = new GJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_ExpiredTokenExceptionRes"),
    Pg4 = XQ(async (A, Q) => {
      let B = A.body,
        G = Iu4(B.Error, Q),
        Z = new XJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_IDPCommunicationErrorExceptionRes"),
    jg4 = XQ(async (A, Q) => {
      let B = A.body,
        G = Yu4(B.Error, Q),
        Z = new JJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_IDPRejectedClaimExceptionRes"),
    Sg4 = XQ(async (A, Q) => {
      let B = A.body,
        G = Ju4(B.Error, Q),
        Z = new VJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_InvalidAuthorizationMessageExceptionRes"),
    _g4 = XQ(async (A, Q) => {
      let B = A.body,
        G = Wu4(B.Error, Q),
        Z = new WJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_InvalidIdentityTokenExceptionRes"),
    kg4 = XQ(async (A, Q) => {
      let B = A.body,
        G = Xu4(B.Error, Q),
        Z = new ZJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_MalformedPolicyDocumentExceptionRes"),
    yg4 = XQ(async (A, Q) => {
      let B = A.body,
        G = Vu4(B.Error, Q),
        Z = new IJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_PackedPolicyTooLargeExceptionRes"),
    xg4 = XQ(async (A, Q) => {
      let B = A.body,
        G = Fu4(B.Error, Q),
        Z = new YJQ({
          $metadata: GD(A),
          ...G
        });
      return (0, P2.decorateServiceException)(Z, B)
    }, "de_RegionDisabledExceptionRes"),
    vg4 = XQ((A, Q) => {
      let B = {};
      if (A[xv] != null) B[xv] = A[xv];
      if (A[L8A] != null) B[L8A] = A[L8A];
      if (A[HL] != null) {
        let G = MgA(A[HL], Q);
        if (A[HL]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[DL] != null) B[DL] = A[DL];
      if (A[RF] != null) B[RF] = A[RF];
      if (A[O8A] != null) {
        let G = wJQ(A[O8A], Q);
        if (A[O8A]?.length === 0) B.Tags = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `Tags.${Z}`;
          B[Y] = I
        })
      }
      if (A[kN1] != null) {
        let G = ng4(A[kN1], Q);
        if (A[kN1]?.length === 0) B.TransitiveTagKeys = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `TransitiveTagKeys.${Z}`;
          B[Y] = I
        })
      }
      if (A[KN1] != null) B[KN1] = A[KN1];
      if (A[M8A] != null) B[M8A] = A[M8A];
      if (A[R8A] != null) B[R8A] = A[R8A];
      if (A[sC] != null) B[sC] = A[sC];
      if (A[NN1] != null) {
        let G = lg4(A[NN1], Q);
        if (A[NN1]?.length === 0) B.ProvidedContexts = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `ProvidedContexts.${Z}`;
          B[Y] = I
        })
      }
      return B
    }, "se_AssumeRoleRequest"),
    bg4 = XQ((A, Q) => {
      let B = {};
      if (A[xv] != null) B[xv] = A[xv];
      if (A[wN1] != null) B[wN1] = A[wN1];
      if (A[TN1] != null) B[TN1] = A[TN1];
      if (A[HL] != null) {
        let G = MgA(A[HL], Q);
        if (A[HL]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[DL] != null) B[DL] = A[DL];
      if (A[RF] != null) B[RF] = A[RF];
      return B
    }, "se_AssumeRoleWithSAMLRequest"),
    fg4 = XQ((A, Q) => {
      let B = {};
      if (A[xv] != null) B[xv] = A[xv];
      if (A[L8A] != null) B[L8A] = A[L8A];
      if (A[vN1] != null) B[vN1] = A[vN1];
      if (A[LN1] != null) B[LN1] = A[LN1];
      if (A[HL] != null) {
        let G = MgA(A[HL], Q);
        if (A[HL]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[DL] != null) B[DL] = A[DL];
      if (A[RF] != null) B[RF] = A[RF];
      return B
    }, "se_AssumeRoleWithWebIdentityRequest"),
    hg4 = XQ((A, Q) => {
      let B = {};
      if (A[_N1] != null) B[_N1] = A[_N1];
      if (A[QJQ] != null) {
        let G = $JQ(A[QJQ], Q);
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `TaskPolicyArn.${Z}`;
          B[Y] = I
        })
      }
      if (A[RF] != null) B[RF] = A[RF];
      return B
    }, "se_AssumeRootRequest"),
    gg4 = XQ((A, Q) => {
      let B = {};
      if (A[DN1] != null) B[DN1] = A[DN1];
      return B
    }, "se_DecodeAuthorizationMessageRequest"),
    ug4 = XQ((A, Q) => {
      let B = {};
      if (A[w8A] != null) B[w8A] = A[w8A];
      return B
    }, "se_GetAccessKeyInfoRequest"),
    mg4 = XQ((A, Q) => {
      return {}
    }, "se_GetCallerIdentityRequest"),
    dg4 = XQ((A, Q) => {
      let B = {};
      if (A[UN1] != null) B[UN1] = A[UN1];
      if (A[DL] != null) B[DL] = A[DL];
      if (A[HL] != null) {
        let G = MgA(A[HL], Q);
        if (A[HL]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[RF] != null) B[RF] = A[RF];
      if (A[O8A] != null) {
        let G = wJQ(A[O8A], Q);
        if (A[O8A]?.length === 0) B.Tags = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `Tags.${Z}`;
          B[Y] = I
        })
      }
      return B
    }, "se_GetFederationTokenRequest"),
    cg4 = XQ((A, Q) => {
      let B = {};
      if (A[RF] != null) B[RF] = A[RF];
      if (A[M8A] != null) B[M8A] = A[M8A];
      if (A[R8A] != null) B[R8A] = A[R8A];
      return B
    }, "se_GetSessionTokenRequest"),
    MgA = XQ((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = $JQ(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_policyDescriptorListType"),
    $JQ = XQ((A, Q) => {
      let B = {};
      if (A[bN1] != null) B[bN1] = A[bN1];
      return B
    }, "se_PolicyDescriptorType"),
    pg4 = XQ((A, Q) => {
      let B = {};
      if (A[qN1] != null) B[qN1] = A[qN1];
      if (A[XN1] != null) B[XN1] = A[XN1];
      return B
    }, "se_ProvidedContext"),
    lg4 = XQ((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = pg4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_ProvidedContextsListType"),
    ig4 = XQ((A, Q) => {
      let B = {};
      if (A[zN1] != null) B[zN1] = A[zN1];
      if (A[xN1] != null) B[xN1] = A[xN1];
      return B
    }, "se_Tag"),
    ng4 = XQ((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        B[`member.${G}`] = Z, G++
      }
      return B
    }, "se_tagKeyListType"),
    wJQ = XQ((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = ig4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_tagListType"),
    uN1 = XQ((A, Q) => {
      let B = {};
      if (A[WN1] != null) B[WN1] = (0, P2.expectString)(A[WN1]);
      if (A[yv] != null) B[yv] = (0, P2.expectString)(A[yv]);
      return B
    }, "de_AssumedRoleUser"),
    ag4 = XQ((A, Q) => {
      let B = {};
      if (A[OF] != null) B[OF] = T8A(A[OF], Q);
      if (A[kv] != null) B[kv] = uN1(A[kv], Q);
      if (A[CL] != null) B[CL] = (0, P2.strictParseInt32)(A[CL]);
      if (A[sC] != null) B[sC] = (0, P2.expectString)(A[sC]);
      return B
    }, "de_AssumeRoleResponse"),
    sg4 = XQ((A, Q) => {
      let B = {};
      if (A[OF] != null) B[OF] = T8A(A[OF], Q);
      if (A[kv] != null) B[kv] = uN1(A[kv], Q);
      if (A[CL] != null) B[CL] = (0, P2.strictParseInt32)(A[CL]);
      if (A[ON1] != null) B[ON1] = (0, P2.expectString)(A[ON1]);
      if (A[jN1] != null) B[jN1] = (0, P2.expectString)(A[jN1]);
      if (A[EN1] != null) B[EN1] = (0, P2.expectString)(A[EN1]);
      if (A[N8A] != null) B[N8A] = (0, P2.expectString)(A[N8A]);
      if (A[$N1] != null) B[$N1] = (0, P2.expectString)(A[$N1]);
      if (A[sC] != null) B[sC] = (0, P2.expectString)(A[sC]);
      return B
    }, "de_AssumeRoleWithSAMLResponse"),
    rg4 = XQ((A, Q) => {
      let B = {};
      if (A[OF] != null) B[OF] = T8A(A[OF], Q);
      if (A[PN1] != null) B[PN1] = (0, P2.expectString)(A[PN1]);
      if (A[kv] != null) B[kv] = uN1(A[kv], Q);
      if (A[CL] != null) B[CL] = (0, P2.strictParseInt32)(A[CL]);
      if (A[MN1] != null) B[MN1] = (0, P2.expectString)(A[MN1]);
      if (A[N8A] != null) B[N8A] = (0, P2.expectString)(A[N8A]);
      if (A[sC] != null) B[sC] = (0, P2.expectString)(A[sC]);
      return B
    }, "de_AssumeRoleWithWebIdentityResponse"),
    og4 = XQ((A, Q) => {
      let B = {};
      if (A[OF] != null) B[OF] = T8A(A[OF], Q);
      if (A[sC] != null) B[sC] = (0, P2.expectString)(A[sC]);
      return B
    }, "de_AssumeRootResponse"),
    T8A = XQ((A, Q) => {
      let B = {};
      if (A[w8A] != null) B[w8A] = (0, P2.expectString)(A[w8A]);
      if (A[RN1] != null) B[RN1] = (0, P2.expectString)(A[RN1]);
      if (A[SN1] != null) B[SN1] = (0, P2.expectString)(A[SN1]);
      if (A[FN1] != null) B[FN1] = (0, P2.expectNonNull)((0, P2.parseRfc3339DateTimeWithOffset)(A[FN1]));
      return B
    }, "de_Credentials"),
    tg4 = XQ((A, Q) => {
      let B = {};
      if (A[VN1] != null) B[VN1] = (0, P2.expectString)(A[VN1]);
      return B
    }, "de_DecodeAuthorizationMessageResponse"),
    eg4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_ExpiredTokenException"),
    Au4 = XQ((A, Q) => {
      let B = {};
      if (A[CN1] != null) B[CN1] = (0, P2.expectString)(A[CN1]);
      if (A[yv] != null) B[yv] = (0, P2.expectString)(A[yv]);
      return B
    }, "de_FederatedUser"),
    Qu4 = XQ((A, Q) => {
      let B = {};
      if (A[q8A] != null) B[q8A] = (0, P2.expectString)(A[q8A]);
      return B
    }, "de_GetAccessKeyInfoResponse"),
    Bu4 = XQ((A, Q) => {
      let B = {};
      if (A[yN1] != null) B[yN1] = (0, P2.expectString)(A[yN1]);
      if (A[q8A] != null) B[q8A] = (0, P2.expectString)(A[q8A]);
      if (A[yv] != null) B[yv] = (0, P2.expectString)(A[yv]);
      return B
    }, "de_GetCallerIdentityResponse"),
    Gu4 = XQ((A, Q) => {
      let B = {};
      if (A[OF] != null) B[OF] = T8A(A[OF], Q);
      if (A[HN1] != null) B[HN1] = Au4(A[HN1], Q);
      if (A[CL] != null) B[CL] = (0, P2.strictParseInt32)(A[CL]);
      return B
    }, "de_GetFederationTokenResponse"),
    Zu4 = XQ((A, Q) => {
      let B = {};
      if (A[OF] != null) B[OF] = T8A(A[OF], Q);
      return B
    }, "de_GetSessionTokenResponse"),
    Iu4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_IDPCommunicationErrorException"),
    Yu4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_IDPRejectedClaimException"),
    Ju4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_InvalidAuthorizationMessageException"),
    Wu4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_InvalidIdentityTokenException"),
    Xu4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_MalformedPolicyDocumentException"),
    Vu4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_PackedPolicyTooLargeException"),
    Fu4 = XQ((A, Q) => {
      let B = {};
      if (A[cI] != null) B[cI] = (0, P2.expectString)(A[cI]);
      return B
    }, "de_RegionDisabledException"),
    GD = XQ((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    Ku4 = (0, P2.withBaseException)(PS),
    hv = XQ(async (A, Q, B, G, Z) => {
      let {
        hostname: I,
        protocol: Y = "https",
        port: J,
        path: W
      } = await A.endpoint(), X = {
        protocol: Y,
        hostname: I,
        port: J,
        method: "POST",
        path: W.endsWith("/") ? W.slice(0, -1) + B : W + B,
        headers: Q
      };
      if (G !== void 0) X.hostname = G;
      if (Z !== void 0) X.body = Z;
      return new Wg4.HttpRequest(X)
    }, "buildHttpRpcRequest"),
    gv = {
      "content-type": "application/x-www-form-urlencoded"
    },
    uv = "2011-06-15",
    mv = "Action",
    w8A = "AccessKeyId",
    Du4 = "AssumeRole",
    WN1 = "AssumedRoleId",
    kv = "AssumedRoleUser",
    Hu4 = "AssumeRoleWithSAML",
    Cu4 = "AssumeRoleWithWebIdentity",
    Eu4 = "AssumeRoot",
    q8A = "Account",
    yv = "Arn",
    N8A = "Audience",
    OF = "Credentials",
    XN1 = "ContextAssertion",
    zu4 = "DecodeAuthorizationMessage",
    VN1 = "DecodedMessage",
    RF = "DurationSeconds",
    FN1 = "Expiration",
    KN1 = "ExternalId",
    DN1 = "EncodedMessage",
    HN1 = "FederatedUser",
    CN1 = "FederatedUserId",
    Uu4 = "GetAccessKeyInfo",
    $u4 = "GetCallerIdentity",
    wu4 = "GetFederationToken",
    qu4 = "GetSessionToken",
    EN1 = "Issuer",
    zN1 = "Key",
    UN1 = "Name",
    $N1 = "NameQualifier",
    DL = "Policy",
    HL = "PolicyArns",
    wN1 = "PrincipalArn",
    qN1 = "ProviderArn",
    NN1 = "ProvidedContexts",
    LN1 = "ProviderId",
    CL = "PackedPolicySize",
    MN1 = "Provider",
    xv = "RoleArn",
    L8A = "RoleSessionName",
    ON1 = "Subject",
    RN1 = "SecretAccessKey",
    TN1 = "SAMLAssertion",
    PN1 = "SubjectFromWebIdentityToken",
    sC = "SourceIdentity",
    M8A = "SerialNumber",
    jN1 = "SubjectType",
    SN1 = "SessionToken",
    O8A = "Tags",
    R8A = "TokenCode",
    _N1 = "TargetPrincipal",
    QJQ = "TaskPolicyArn",
    kN1 = "TransitiveTagKeys",
    yN1 = "UserId",
    dv = "Version",
    xN1 = "Value",
    vN1 = "WebIdentityToken",
    bN1 = "arn",
    cI = "message",
    cv = XQ((A) => Object.entries(A).map(([Q, B]) => (0, P2.extendedEncodeURIComponent)(Q) + "=" + (0, P2.extendedEncodeURIComponent)(B)).join("&"), "buildFormUrlencodedString"),
    Nu4 = XQ((A, Q) => {
      if (Q.Error?.Code !== void 0) return Q.Error.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadQueryErrorCode"),
    mN1 = class extends P2.Command.classBuilder().ep(Jg4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(void 0, FJQ).ser(Xg4).de(Ug4).build() {
      static {
        XQ(this, "AssumeRoleCommand")
      }
    },
    Lu4 = IL(),
    qJQ = class extends P2.Command.classBuilder().ep(Lu4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithSAML", {}).n("STSClient", "AssumeRoleWithSAMLCommand").f(KJQ, DJQ).ser(Vg4).de($g4).build() {
      static {
        XQ(this, "AssumeRoleWithSAMLCommand")
      }
    },
    Mu4 = IL(),
    dN1 = class extends P2.Command.classBuilder().ep(Mu4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(HJQ, CJQ).ser(Fg4).de(wg4).build() {
      static {
        XQ(this, "AssumeRoleWithWebIdentityCommand")
      }
    },
    Ou4 = IL(),
    NJQ = class extends P2.Command.classBuilder().ep(Ou4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoot", {}).n("STSClient", "AssumeRootCommand").f(void 0, EJQ).ser(Kg4).de(qg4).build() {
      static {
        XQ(this, "AssumeRootCommand")
      }
    },
    Ru4 = IL(),
    LJQ = class extends P2.Command.classBuilder().ep(Ru4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "DecodeAuthorizationMessage", {}).n("STSClient", "DecodeAuthorizationMessageCommand").f(void 0, void 0).ser(Dg4).de(Ng4).build() {
      static {
        XQ(this, "DecodeAuthorizationMessageCommand")
      }
    },
    Tu4 = IL(),
    MJQ = class extends P2.Command.classBuilder().ep(Tu4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "GetAccessKeyInfo", {}).n("STSClient", "GetAccessKeyInfoCommand").f(void 0, void 0).ser(Hg4).de(Lg4).build() {
      static {
        XQ(this, "GetAccessKeyInfoCommand")
      }
    },
    Pu4 = IL(),
    OJQ = class extends P2.Command.classBuilder().ep(Pu4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "GetCallerIdentity", {}).n("STSClient", "GetCallerIdentityCommand").f(void 0, void 0).ser(Cg4).de(Mg4).build() {
      static {
        XQ(this, "GetCallerIdentityCommand")
      }
    },
    ju4 = IL(),
    RJQ = class extends P2.Command.classBuilder().ep(ju4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "GetFederationToken", {}).n("STSClient", "GetFederationTokenCommand").f(void 0, zJQ).ser(Eg4).de(Og4).build() {
      static {
        XQ(this, "GetFederationTokenCommand")
      }
    },
    Su4 = IL(),
    TJQ = class extends P2.Command.classBuilder().ep(Su4.commonParams).m(function(A, Q, B, G) {
      return [(0, bv.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vv.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "GetSessionToken", {}).n("STSClient", "GetSessionTokenCommand").f(void 0, UJQ).ser(zg4).de(Rg4).build() {
      static {
        XQ(this, "GetSessionTokenCommand")
      }
    },
    _u4 = WHA(),
    ku4 = {
      AssumeRoleCommand: mN1,
      AssumeRoleWithSAMLCommand: qJQ,
      AssumeRoleWithWebIdentityCommand: dN1,
      AssumeRootCommand: NJQ,
      DecodeAuthorizationMessageCommand: LJQ,
      GetAccessKeyInfoCommand: MJQ,
      GetCallerIdentityCommand: OJQ,
      GetFederationTokenCommand: RJQ,
      GetSessionTokenCommand: TJQ
    },
    PJQ = class extends _u4.STSClient {
      static {
        XQ(this, "STS")
      }
    };
  (0, P2.createAggregatedClient)(ku4, PJQ);
  var yu4 = IL(),
    hN1 = QL(),
    BJQ = "us-east-1",
    jJQ = XQ((A) => {
      if (typeof A?.Arn === "string") {
        let Q = A.Arn.split(":");
        if (Q.length > 4 && Q[4] !== "") return Q[4]
      }
      return
    }, "getAccountIdFromAssumedRoleUser"),
    SJQ = XQ(async (A, Q, B) => {
      let G = typeof A === "function" ? await A() : A,
        Z = typeof Q === "function" ? await Q() : Q;
      return B?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${G} (provider)`, `${Z} (parent client)`, `${BJQ} (STS default)`), G ?? Z ?? BJQ
    }, "resolveRegion"),
    xu4 = XQ((A, Q) => {
      let B, G;
      return async (Z, I) => {
        if (G = Z, !B) {
          let {
            logger: V = A?.parentClientConfig?.logger,
            region: F,
            requestHandler: K = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: D
          } = A, H = await SJQ(F, A?.parentClientConfig?.region, D), C = !_JQ(K);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            credentialDefaultProvider: XQ(() => async () => G, "credentialDefaultProvider"),
            region: H,
            requestHandler: C ? K : void 0,
            logger: V
          })
        }
        let {
          Credentials: Y,
          AssumedRoleUser: J
        } = await B.send(new mN1(I));
        if (!Y || !Y.AccessKeyId || !Y.SecretAccessKey) throw Error(`Invalid response from STS.assumeRole call with role ${I.RoleArn}`);
        let W = jJQ(J),
          X = {
            accessKeyId: Y.AccessKeyId,
            secretAccessKey: Y.SecretAccessKey,
            sessionToken: Y.SessionToken,
            expiration: Y.Expiration,
            ...Y.CredentialScope && {
              credentialScope: Y.CredentialScope
            },
            ...W && {
              accountId: W
            }
          };
        return (0, hN1.setCredentialFeature)(X, "CREDENTIALS_STS_ASSUME_ROLE", "i"), X
      }
    }, "getDefaultRoleAssumer"),
    vu4 = XQ((A, Q) => {
      let B;
      return async (G) => {
        if (!B) {
          let {
            logger: W = A?.parentClientConfig?.logger,
            region: X,
            requestHandler: V = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: F
          } = A, K = await SJQ(X, A?.parentClientConfig?.region, F), D = !_JQ(V);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            region: K,
            requestHandler: D ? V : void 0,
            logger: W
          })
        }
        let {
          Credentials: Z,
          AssumedRoleUser: I
        } = await B.send(new dN1(G));
        if (!Z || !Z.AccessKeyId || !Z.SecretAccessKey) throw Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${G.RoleArn}`);
        let Y = jJQ(I),
          J = {
            accessKeyId: Z.AccessKeyId,
            secretAccessKey: Z.SecretAccessKey,
            sessionToken: Z.SessionToken,
            expiration: Z.Expiration,
            ...Z.CredentialScope && {
              credentialScope: Z.CredentialScope
            },
            ...Y && {
              accountId: Y
            }
          };
        if (Y)(0, hN1.setCredentialFeature)(J, "RESOLVED_ACCOUNT_ID", "T");
        return (0, hN1.setCredentialFeature)(J, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"), J
      }
    }, "getDefaultRoleAssumerWithWebIdentity"),
    _JQ = XQ((A) => {
      return A?.metadata?.handlerProtocol === "h2"
    }, "isH2"),
    kJQ = WHA(),
    yJQ = XQ((A, Q) => {
      if (!Q) return A;
      else return class extends A {
        static {
          XQ(this, "CustomizableSTSClient")
        }
        constructor(G) {
          super(G);
          for (let Z of Q) this.middlewareStack.use(Z)
        }
      }
    }, "getCustomizableStsClientCtor"),
    xJQ = XQ((A = {}, Q) => xu4(A, yJQ(kJQ.STSClient, Q)), "getDefaultRoleAssumer"),
    vJQ = XQ((A = {}, Q) => vu4(A, yJQ(kJQ.STSClient, Q)), "getDefaultRoleAssumerWithWebIdentity"),
    bu4 = XQ((A) => (Q) => A({
      roleAssumer: xJQ(Q),
      roleAssumerWithWebIdentity: vJQ(Q),
      ...Q
    }), "decorateDefaultCredentialProvider")
})
// @from(Start 2932695, End 2949950)
sr = z((V$7, TgA) => {
  var fJQ, hJQ, gJQ, uJQ, mJQ, dJQ, cJQ, pJQ, lJQ, iJQ, nJQ, aJQ, sJQ, OgA, pN1, rJQ, oJQ, tJQ, P8A, eJQ, AWQ, QWQ, BWQ, GWQ, ZWQ, IWQ, YWQ, JWQ, RgA, WWQ, XWQ, VWQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof TgA === "object" && typeof V$7 === "object") A(B(Q, B(V$7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    fJQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, hJQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, gJQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, uJQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, mJQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, dJQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, cJQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, pJQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, lJQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, iJQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, nJQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, aJQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, sJQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) RgA(Y, I, J)
    }, RgA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, OgA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, pN1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, rJQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(pN1(arguments[Y]));
      return I
    }, oJQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, tJQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, P8A = function(I) {
      return this instanceof P8A ? (this.v = I, this) : new P8A(I)
    }, eJQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof P8A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, AWQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: P8A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, QWQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof OgA === "function" ? OgA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, BWQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    GWQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") RgA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, ZWQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, IWQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, YWQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, JWQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, WWQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    XWQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, VWQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", fJQ), A("__assign", hJQ), A("__rest", gJQ), A("__decorate", uJQ), A("__param", mJQ), A("__esDecorate", dJQ), A("__runInitializers", cJQ), A("__propKey", pJQ), A("__setFunctionName", lJQ), A("__metadata", iJQ), A("__awaiter", nJQ), A("__generator", aJQ), A("__exportStar", sJQ), A("__createBinding", RgA), A("__values", OgA), A("__read", pN1), A("__spread", rJQ), A("__spreadArrays", oJQ), A("__spreadArray", tJQ), A("__await", P8A), A("__asyncGenerator", eJQ), A("__asyncDelegator", AWQ), A("__asyncValues", QWQ), A("__makeTemplateObject", BWQ), A("__importStar", GWQ), A("__importDefault", ZWQ), A("__classPrivateFieldGet", IWQ), A("__classPrivateFieldSet", YWQ), A("__classPrivateFieldIn", JWQ), A("__addDisposableResource", WWQ), A("__disposeResources", XWQ), A("__rewriteRelativeImportExtension", VWQ)
  })
})
// @from(Start 2949956, End 2951004)
KWQ = z((FWQ) => {
  Object.defineProperty(FWQ, "__esModule", {
    value: !0
  });
  FWQ.propertyProviderChain = FWQ.createCredentialChain = void 0;
  var fu4 = j2(),
    hu4 = (...A) => {
      let Q = -1,
        G = Object.assign(async (Z) => {
          let I = await FWQ.propertyProviderChain(...A)(Z);
          if (!I.expiration && Q !== -1) I.expiration = new Date(Date.now() + Q);
          return I
        }, {
          expireAfter(Z) {
            if (Z < 300000) throw Error("@aws-sdk/credential-providers - createCredentialChain(...).expireAfter(ms) may not be called with a duration lower than five minutes.");
            return Q = Z, G
          }
        });
      return G
    };
  FWQ.createCredentialChain = hu4;
  var gu4 = (...A) => async (Q) => {
    if (A.length === 0) throw new fu4.ProviderError("No providers in chain");
    let B;
    for (let G of A) try {
      return await G(Q)
    } catch (Z) {
      if (B = Z, Z?.tryNextLink) continue;
      throw Z
    }
    throw B
  };
  FWQ.propertyProviderChain = gu4
})
// @from(Start 2951010, End 2953793)
iN1 = z((K$7, qWQ) => {
  var {
    defineProperty: PgA,
    getOwnPropertyDescriptor: mu4,
    getOwnPropertyNames: du4
  } = Object, cu4 = Object.prototype.hasOwnProperty, jgA = (A, Q) => PgA(A, "name", {
    value: Q,
    configurable: !0
  }), pu4 = (A, Q) => {
    for (var B in Q) PgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, lu4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of du4(Q))
        if (!cu4.call(A, Z) && Z !== B) PgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = mu4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, iu4 = (A) => lu4(PgA({}, "__esModule", {
    value: !0
  }), A), DWQ = {};
  pu4(DWQ, {
    AlgorithmId: () => zWQ,
    EndpointURLScheme: () => EWQ,
    FieldPosition: () => UWQ,
    HttpApiKeyAuthLocation: () => CWQ,
    HttpAuthLocation: () => HWQ,
    IniSectionType: () => $WQ,
    RequestHandlerProtocol: () => wWQ,
    SMITHY_CONTEXT_KEY: () => ou4,
    getDefaultClientConfiguration: () => su4,
    resolveDefaultRuntimeConfig: () => ru4
  });
  qWQ.exports = iu4(DWQ);
  var HWQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(HWQ || {}),
    CWQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(CWQ || {}),
    EWQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(EWQ || {}),
    zWQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(zWQ || {}),
    nu4 = jgA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    au4 = jgA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    su4 = jgA((A) => {
      return nu4(A)
    }, "getDefaultClientConfiguration"),
    ru4 = jgA((A) => {
      return au4(A)
    }, "resolveDefaultRuntimeConfig"),
    UWQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(UWQ || {}),
    ou4 = "__smithy_context",
    $WQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })($WQ || {}),
    wWQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(wWQ || {})
})
// @from(Start 2953799, End 2958305)
iz = z((D$7, RWQ) => {
  var {
    defineProperty: SgA,
    getOwnPropertyDescriptor: tu4,
    getOwnPropertyNames: eu4
  } = Object, Am4 = Object.prototype.hasOwnProperty, Rd = (A, Q) => SgA(A, "name", {
    value: Q,
    configurable: !0
  }), Qm4 = (A, Q) => {
    for (var B in Q) SgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Bm4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of eu4(Q))
        if (!Am4.call(A, Z) && Z !== B) SgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = tu4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Gm4 = (A) => Bm4(SgA({}, "__esModule", {
    value: !0
  }), A), NWQ = {};
  Qm4(NWQ, {
    Field: () => Ym4,
    Fields: () => Jm4,
    HttpRequest: () => Wm4,
    HttpResponse: () => Xm4,
    IHttpRequest: () => LWQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => Zm4,
    isValidHostname: () => OWQ,
    resolveHttpHandlerRuntimeConfig: () => Im4
  });
  RWQ.exports = Gm4(NWQ);
  var Zm4 = Rd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    Im4 = Rd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    LWQ = iN1(),
    Ym4 = class {
      static {
        Rd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = LWQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    Jm4 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Rd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    Wm4 = class A {
      static {
        Rd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = MWQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function MWQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Rd(MWQ, "cloneQuery");
  var Xm4 = class {
    static {
      Rd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function OWQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Rd(OWQ, "isValidHostname")
})
// @from(Start 2958311, End 2960174)
MHA = z((z$7, _WQ) => {
  var {
    defineProperty: kgA,
    getOwnPropertyDescriptor: Vm4,
    getOwnPropertyNames: Fm4
  } = Object, Km4 = Object.prototype.hasOwnProperty, _gA = (A, Q) => kgA(A, "name", {
    value: Q,
    configurable: !0
  }), Dm4 = (A, Q) => {
    for (var B in Q) kgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Hm4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Fm4(Q))
        if (!Km4.call(A, Z) && Z !== B) kgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Vm4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Cm4 = (A) => Hm4(kgA({}, "__esModule", {
    value: !0
  }), A), TWQ = {};
  Dm4(TWQ, {
    getHostHeaderPlugin: () => zm4,
    hostHeaderMiddleware: () => jWQ,
    hostHeaderMiddlewareOptions: () => SWQ,
    resolveHostHeaderConfig: () => PWQ
  });
  _WQ.exports = Cm4(TWQ);
  var Em4 = iz();

  function PWQ(A) {
    return A
  }
  _gA(PWQ, "resolveHostHeaderConfig");
  var jWQ = _gA((A) => (Q) => async (B) => {
      if (!Em4.HttpRequest.isInstance(B.request)) return Q(B);
      let {
        request: G
      } = B, {
        handlerProtocol: Z = ""
      } = A.requestHandler.metadata || {};
      if (Z.indexOf("h2") >= 0 && !G.headers[":authority"]) delete G.headers.host, G.headers[":authority"] = G.hostname + (G.port ? ":" + G.port : "");
      else if (!G.headers.host) {
        let I = G.hostname;
        if (G.port != null) I += `:${G.port}`;
        G.headers.host = I
      }
      return Q(B)
    }, "hostHeaderMiddleware"),
    SWQ = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: !0
    },
    zm4 = _gA((A) => ({
      applyToStack: _gA((Q) => {
        Q.add(jWQ(A), SWQ)
      }, "applyToStack")
    }), "getHostHeaderPlugin")
})
// @from(Start 2960180, End 2962480)
OHA = z((U$7, vWQ) => {
  var {
    defineProperty: ygA,
    getOwnPropertyDescriptor: Um4,
    getOwnPropertyNames: $m4
  } = Object, wm4 = Object.prototype.hasOwnProperty, nN1 = (A, Q) => ygA(A, "name", {
    value: Q,
    configurable: !0
  }), qm4 = (A, Q) => {
    for (var B in Q) ygA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Nm4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of $m4(Q))
        if (!wm4.call(A, Z) && Z !== B) ygA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Um4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Lm4 = (A) => Nm4(ygA({}, "__esModule", {
    value: !0
  }), A), kWQ = {};
  qm4(kWQ, {
    getLoggerPlugin: () => Mm4,
    loggerMiddleware: () => yWQ,
    loggerMiddlewareOptions: () => xWQ
  });
  vWQ.exports = Lm4(kWQ);
  var yWQ = nN1(() => (A, Q) => async (B) => {
      try {
        let G = await A(B),
          {
            clientName: Z,
            commandName: I,
            logger: Y,
            dynamoDbDocumentClientOptions: J = {}
          } = Q,
          {
            overrideInputFilterSensitiveLog: W,
            overrideOutputFilterSensitiveLog: X
          } = J,
          V = W ?? Q.inputFilterSensitiveLog,
          F = X ?? Q.outputFilterSensitiveLog,
          {
            $metadata: K,
            ...D
          } = G.output;
        return Y?.info?.({
          clientName: Z,
          commandName: I,
          input: V(B.input),
          output: F(D),
          metadata: K
        }), G
      } catch (G) {
        let {
          clientName: Z,
          commandName: I,
          logger: Y,
          dynamoDbDocumentClientOptions: J = {}
        } = Q, {
          overrideInputFilterSensitiveLog: W
        } = J, X = W ?? Q.inputFilterSensitiveLog;
        throw Y?.error?.({
          clientName: Z,
          commandName: I,
          input: X(B.input),
          error: G,
          metadata: G.$metadata
        }), G
      }
    }, "loggerMiddleware"),
    xWQ = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: !0
    },
    Mm4 = nN1((A) => ({
      applyToStack: nN1((Q) => {
        Q.add(yWQ(), xWQ)
      }, "applyToStack")
    }), "getLoggerPlugin")
})
// @from(Start 2962486, End 2964418)
RHA = z(($$7, gWQ) => {
  var {
    defineProperty: vgA,
    getOwnPropertyDescriptor: Om4,
    getOwnPropertyNames: Rm4
  } = Object, Tm4 = Object.prototype.hasOwnProperty, xgA = (A, Q) => vgA(A, "name", {
    value: Q,
    configurable: !0
  }), Pm4 = (A, Q) => {
    for (var B in Q) vgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, jm4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Rm4(Q))
        if (!Tm4.call(A, Z) && Z !== B) vgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Om4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Sm4 = (A) => jm4(vgA({}, "__esModule", {
    value: !0
  }), A), bWQ = {};
  Pm4(bWQ, {
    addRecursionDetectionMiddlewareOptions: () => hWQ,
    getRecursionDetectionPlugin: () => xm4,
    recursionDetectionMiddleware: () => fWQ
  });
  gWQ.exports = Sm4(bWQ);
  var _m4 = iz(),
    aN1 = "X-Amzn-Trace-Id",
    km4 = "AWS_LAMBDA_FUNCTION_NAME",
    ym4 = "_X_AMZN_TRACE_ID",
    fWQ = xgA((A) => (Q) => async (B) => {
      let {
        request: G
      } = B;
      if (!_m4.HttpRequest.isInstance(G) || A.runtime !== "node") return Q(B);
      let Z = Object.keys(G.headers ?? {}).find((W) => W.toLowerCase() === aN1.toLowerCase()) ?? aN1;
      if (G.headers.hasOwnProperty(Z)) return Q(B);
      let I = process.env[km4],
        Y = process.env[ym4],
        J = xgA((W) => typeof W === "string" && W.length > 0, "nonEmptyString");
      if (J(I) && J(Y)) G.headers[aN1] = Y;
      return Q({
        ...B,
        request: G
      })
    }, "recursionDetectionMiddleware"),
    hWQ = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: !0,
      priority: "low"
    },
    xm4 = xgA((A) => ({
      applyToStack: xgA((Q) => {
        Q.add(fWQ(A), hWQ)
      }, "applyToStack")
    }), "getRecursionDetectionPlugin")
})
// @from(Start 2964424, End 2975882)
S8A = z((w$7, sWQ) => {
  var {
    defineProperty: bgA,
    getOwnPropertyDescriptor: vm4,
    getOwnPropertyNames: bm4
  } = Object, fm4 = Object.prototype.hasOwnProperty, j8A = (A, Q) => bgA(A, "name", {
    value: Q,
    configurable: !0
  }), hm4 = (A, Q) => {
    for (var B in Q) bgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, gm4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of bm4(Q))
        if (!fm4.call(A, Z) && Z !== B) bgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = vm4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, um4 = (A) => gm4(bgA({}, "__esModule", {
    value: !0
  }), A), mWQ = {};
  hm4(mWQ, {
    ConditionObject: () => jZ.ConditionObject,
    DeprecatedObject: () => jZ.DeprecatedObject,
    EndpointError: () => jZ.EndpointError,
    EndpointObject: () => jZ.EndpointObject,
    EndpointObjectHeaders: () => jZ.EndpointObjectHeaders,
    EndpointObjectProperties: () => jZ.EndpointObjectProperties,
    EndpointParams: () => jZ.EndpointParams,
    EndpointResolverOptions: () => jZ.EndpointResolverOptions,
    EndpointRuleObject: () => jZ.EndpointRuleObject,
    ErrorRuleObject: () => jZ.ErrorRuleObject,
    EvaluateOptions: () => jZ.EvaluateOptions,
    Expression: () => jZ.Expression,
    FunctionArgv: () => jZ.FunctionArgv,
    FunctionObject: () => jZ.FunctionObject,
    FunctionReturn: () => jZ.FunctionReturn,
    ParameterObject: () => jZ.ParameterObject,
    ReferenceObject: () => jZ.ReferenceObject,
    ReferenceRecord: () => jZ.ReferenceRecord,
    RuleSetObject: () => jZ.RuleSetObject,
    RuleSetRules: () => jZ.RuleSetRules,
    TreeRuleObject: () => jZ.TreeRuleObject,
    awsEndpointFunctions: () => aWQ,
    getUserAgentPrefix: () => pm4,
    isIpAddress: () => jZ.isIpAddress,
    partition: () => iWQ,
    resolveEndpoint: () => jZ.resolveEndpoint,
    setPartitionInfo: () => nWQ,
    useDefaultPartitionInfo: () => cm4
  });
  sWQ.exports = um4(mWQ);
  var jZ = FI(),
    dWQ = j8A((A, Q = !1) => {
      if (Q) {
        for (let B of A.split("."))
          if (!dWQ(B)) return !1;
        return !0
      }
      if (!(0, jZ.isValidHostLabel)(A)) return !1;
      if (A.length < 3 || A.length > 63) return !1;
      if (A !== A.toLowerCase()) return !1;
      if ((0, jZ.isIpAddress)(A)) return !1;
      return !0
    }, "isVirtualHostableS3Bucket"),
    uWQ = ":",
    mm4 = "/",
    dm4 = j8A((A) => {
      let Q = A.split(uWQ);
      if (Q.length < 6) return null;
      let [B, G, Z, I, Y, ...J] = Q;
      if (B !== "arn" || G === "" || Z === "" || J.join(uWQ) === "") return null;
      let W = J.map((X) => X.split(mm4)).flat();
      return {
        partition: G,
        service: Z,
        region: I,
        accountId: Y,
        resourceId: W
      }
    }, "parseArn"),
    cWQ = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-east-2": {
            description: "Asia Pacific (Taipei)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "cloud.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-e-global": {
            description: "AWS ISOE (Europe) global region"
          },
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "csp.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "AWS ISOF global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      }, {
        id: "aws-eusc",
        outputs: {
          dnsSuffix: "amazonaws.eu",
          dualStackDnsSuffix: "amazonaws.eu",
          implicitGlobalRegion: "eusc-de-east-1",
          name: "aws-eusc",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
        regions: {
          "eusc-de-east-1": {
            description: "EU (Germany)"
          }
        }
      }],
      version: "1.1"
    },
    pWQ = cWQ,
    lWQ = "",
    iWQ = j8A((A) => {
      let {
        partitions: Q
      } = pWQ;
      for (let G of Q) {
        let {
          regions: Z,
          outputs: I
        } = G;
        for (let [Y, J] of Object.entries(Z))
          if (Y === A) return {
            ...I,
            ...J
          }
      }
      for (let G of Q) {
        let {
          regionRegex: Z,
          outputs: I
        } = G;
        if (new RegExp(Z).test(A)) return {
          ...I
        }
      }
      let B = Q.find((G) => G.id === "aws");
      if (!B) throw Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      return {
        ...B.outputs
      }
    }, "partition"),
    nWQ = j8A((A, Q = "") => {
      pWQ = A, lWQ = Q
    }, "setPartitionInfo"),
    cm4 = j8A(() => {
      nWQ(cWQ, "")
    }, "useDefaultPartitionInfo"),
    pm4 = j8A(() => lWQ, "getUserAgentPrefix"),
    aWQ = {
      isVirtualHostableS3Bucket: dWQ,
      parseArn: dm4,
      partition: iWQ
    };
  jZ.customEndpointFunctions.aws = aWQ
})
// @from(Start 2975888, End 2993143)
rr = z((q$7, ggA) => {
  var rWQ, oWQ, tWQ, eWQ, AXQ, QXQ, BXQ, GXQ, ZXQ, IXQ, YXQ, JXQ, WXQ, fgA, sN1, XXQ, VXQ, FXQ, _8A, KXQ, DXQ, HXQ, CXQ, EXQ, zXQ, UXQ, $XQ, wXQ, hgA, qXQ, NXQ, LXQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof ggA === "object" && typeof q$7 === "object") A(B(Q, B(q$7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    rWQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, oWQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, tWQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, eWQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, AXQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, QXQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, BXQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, GXQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, ZXQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, IXQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, YXQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, JXQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, WXQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) hgA(Y, I, J)
    }, hgA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, fgA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, sN1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, XXQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(sN1(arguments[Y]));
      return I
    }, VXQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, FXQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, _8A = function(I) {
      return this instanceof _8A ? (this.v = I, this) : new _8A(I)
    }, KXQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof _8A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, DXQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: _8A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, HXQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof fgA === "function" ? fgA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, CXQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    EXQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") hgA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, zXQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, UXQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, $XQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, wXQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, qXQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    NXQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, LXQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", rWQ), A("__assign", oWQ), A("__rest", tWQ), A("__decorate", eWQ), A("__param", AXQ), A("__esDecorate", QXQ), A("__runInitializers", BXQ), A("__propKey", GXQ), A("__setFunctionName", ZXQ), A("__metadata", IXQ), A("__awaiter", YXQ), A("__generator", JXQ), A("__exportStar", WXQ), A("__createBinding", hgA), A("__values", fgA), A("__read", sN1), A("__spread", XXQ), A("__spreadArrays", VXQ), A("__spreadArray", FXQ), A("__await", _8A), A("__asyncGenerator", KXQ), A("__asyncDelegator", DXQ), A("__asyncValues", HXQ), A("__makeTemplateObject", CXQ), A("__importStar", EXQ), A("__importDefault", zXQ), A("__classPrivateFieldGet", UXQ), A("__classPrivateFieldSet", $XQ), A("__classPrivateFieldIn", wXQ), A("__addDisposableResource", qXQ), A("__disposeResources", NXQ), A("__rewriteRelativeImportExtension", LXQ)
  })
})
// @from(Start 2993149, End 2995132)
lR = z((N$7, PXQ) => {
  var {
    defineProperty: ugA,
    getOwnPropertyDescriptor: lm4,
    getOwnPropertyNames: im4
  } = Object, nm4 = Object.prototype.hasOwnProperty, mgA = (A, Q) => ugA(A, "name", {
    value: Q,
    configurable: !0
  }), am4 = (A, Q) => {
    for (var B in Q) ugA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, sm4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of im4(Q))
        if (!nm4.call(A, Z) && Z !== B) ugA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = lm4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, rm4 = (A) => sm4(ugA({}, "__esModule", {
    value: !0
  }), A), MXQ = {};
  am4(MXQ, {
    emitWarningIfUnsupportedVersion: () => om4,
    setCredentialFeature: () => OXQ,
    setFeature: () => RXQ,
    setTokenFeature: () => TXQ,
    state: () => rN1
  });
  PXQ.exports = rm4(MXQ);
  var rN1 = {
      warningEmitted: !1
    },
    om4 = mgA((A) => {
      if (A && !rN1.warningEmitted && parseInt(A.substring(1, A.indexOf("."))) < 18) rN1.warningEmitted = !0, process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`)
    }, "emitWarningIfUnsupportedVersion");

  function OXQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  mgA(OXQ, "setCredentialFeature");

  function RXQ(A, Q, B) {
    if (!A.__aws_sdk_context) A.__aws_sdk_context = {
      features: {}
    };
    else if (!A.__aws_sdk_context.features) A.__aws_sdk_context.features = {};
    A.__aws_sdk_context.features[Q] = B
  }
  mgA(RXQ, "setFeature");

  function TXQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  mgA(TXQ, "setTokenFeature")
})
// @from(Start 2995138, End 2996091)
_XQ = z((L$7, SXQ) => {
  var {
    defineProperty: dgA,
    getOwnPropertyDescriptor: tm4,
    getOwnPropertyNames: em4
  } = Object, Ad4 = Object.prototype.hasOwnProperty, Qd4 = (A, Q) => dgA(A, "name", {
    value: Q,
    configurable: !0
  }), Bd4 = (A, Q) => {
    for (var B in Q) dgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Gd4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of em4(Q))
        if (!Ad4.call(A, Z) && Z !== B) dgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = tm4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Zd4 = (A) => Gd4(dgA({}, "__esModule", {
    value: !0
  }), A), jXQ = {};
  Bd4(jXQ, {
    isArrayBuffer: () => Id4
  });
  SXQ.exports = Zd4(jXQ);
  var Id4 = Qd4((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 2996097, End 2997150)
vXQ = z((M$7, xXQ) => {
  var {
    defineProperty: cgA,
    getOwnPropertyDescriptor: Yd4,
    getOwnPropertyNames: Jd4
  } = Object, Wd4 = Object.prototype.hasOwnProperty, oN1 = (A, Q) => cgA(A, "name", {
    value: Q,
    configurable: !0
  }), Xd4 = (A, Q) => {
    for (var B in Q) cgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Vd4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Jd4(Q))
        if (!Wd4.call(A, Z) && Z !== B) cgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Yd4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Fd4 = (A) => Vd4(cgA({}, "__esModule", {
    value: !0
  }), A), kXQ = {};
  Xd4(kXQ, {
    escapeUri: () => yXQ,
    escapeUriPath: () => Dd4
  });
  xXQ.exports = Fd4(kXQ);
  var yXQ = oN1((A) => encodeURIComponent(A).replace(/[!'()*]/g, Kd4), "escapeUri"),
    Kd4 = oN1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    Dd4 = oN1((A) => A.split("/").map(yXQ).join("/"), "escapeUriPath")
})
// @from(Start 2997156, End 3014069)
XVQ = z((O$7, WVQ) => {
  var {
    defineProperty: rgA,
    getOwnPropertyDescriptor: Hd4,
    getOwnPropertyNames: Cd4
  } = Object, Ed4 = Object.prototype.hasOwnProperty, ZD = (A, Q) => rgA(A, "name", {
    value: Q,
    configurable: !0
  }), zd4 = (A, Q) => {
    for (var B in Q) rgA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Ud4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Cd4(Q))
        if (!Ed4.call(A, Z) && Z !== B) rgA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Hd4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, $d4 = (A) => Ud4(rgA({}, "__esModule", {
    value: !0
  }), A), uXQ = {};
  zd4(uXQ, {
    ALGORITHM_IDENTIFIER: () => pgA,
    ALGORITHM_IDENTIFIER_V4A: () => Ld4,
    ALGORITHM_QUERY_PARAM: () => mXQ,
    ALWAYS_UNSIGNABLE_HEADERS: () => sXQ,
    AMZ_DATE_HEADER: () => IL1,
    AMZ_DATE_QUERY_PARAM: () => QL1,
    AUTH_HEADER: () => ZL1,
    CREDENTIAL_QUERY_PARAM: () => dXQ,
    DATE_HEADER: () => lXQ,
    EVENT_ALGORITHM_IDENTIFIER: () => tXQ,
    EXPIRES_QUERY_PARAM: () => pXQ,
    GENERATED_HEADERS: () => iXQ,
    HOST_HEADER: () => qd4,
    KEY_TYPE_IDENTIFIER: () => YL1,
    MAX_CACHE_SIZE: () => AVQ,
    MAX_PRESIGNED_TTL: () => QVQ,
    PROXY_HEADER_PATTERN: () => rXQ,
    REGION_SET_PARAM: () => wd4,
    SEC_HEADER_PATTERN: () => oXQ,
    SHA256_HEADER: () => sgA,
    SIGNATURE_HEADER: () => nXQ,
    SIGNATURE_QUERY_PARAM: () => BL1,
    SIGNED_HEADERS_QUERY_PARAM: () => cXQ,
    SignatureV4: () => xd4,
    SignatureV4Base: () => JVQ,
    TOKEN_HEADER: () => aXQ,
    TOKEN_QUERY_PARAM: () => GL1,
    UNSIGNABLE_PATTERNS: () => Nd4,
    UNSIGNED_PAYLOAD: () => eXQ,
    clearCredentialCache: () => Od4,
    createScope: () => igA,
    getCanonicalHeaders: () => tN1,
    getCanonicalQuery: () => YVQ,
    getPayloadHash: () => ngA,
    getSigningKey: () => BVQ,
    hasHeader: () => GVQ,
    moveHeadersToQuery: () => IVQ,
    prepareRequest: () => AL1,
    signatureV4aContainer: () => vd4
  });
  WVQ.exports = $d4(uXQ);
  var bXQ = O2(),
    mXQ = "X-Amz-Algorithm",
    dXQ = "X-Amz-Credential",
    QL1 = "X-Amz-Date",
    cXQ = "X-Amz-SignedHeaders",
    pXQ = "X-Amz-Expires",
    BL1 = "X-Amz-Signature",
    GL1 = "X-Amz-Security-Token",
    wd4 = "X-Amz-Region-Set",
    ZL1 = "authorization",
    IL1 = QL1.toLowerCase(),
    lXQ = "date",
    iXQ = [ZL1, IL1, lXQ],
    nXQ = BL1.toLowerCase(),
    sgA = "x-amz-content-sha256",
    aXQ = GL1.toLowerCase(),
    qd4 = "host",
    sXQ = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0
    },
    rXQ = /^proxy-/,
    oXQ = /^sec-/,
    Nd4 = [/^proxy-/i, /^sec-/i],
    pgA = "AWS4-HMAC-SHA256",
    Ld4 = "AWS4-ECDSA-P256-SHA256",
    tXQ = "AWS4-HMAC-SHA256-PAYLOAD",
    eXQ = "UNSIGNED-PAYLOAD",
    AVQ = 50,
    YL1 = "aws4_request",
    QVQ = 604800,
    Td = Jd(),
    Md4 = O2(),
    k8A = {},
    lgA = [],
    igA = ZD((A, Q, B) => `${A}/${Q}/${B}/${YL1}`, "createScope"),
    BVQ = ZD(async (A, Q, B, G, Z) => {
      let I = await fXQ(A, Q.secretAccessKey, Q.accessKeyId),
        Y = `${B}:${G}:${Z}:${(0,Td.toHex)(I)}:${Q.sessionToken}`;
      if (Y in k8A) return k8A[Y];
      lgA.push(Y);
      while (lgA.length > AVQ) delete k8A[lgA.shift()];
      let J = `AWS4${Q.secretAccessKey}`;
      for (let W of [B, G, Z, YL1]) J = await fXQ(A, J, W);
      return k8A[Y] = J
    }, "getSigningKey"),
    Od4 = ZD(() => {
      lgA.length = 0, Object.keys(k8A).forEach((A) => {
        delete k8A[A]
      })
    }, "clearCredentialCache"),
    fXQ = ZD((A, Q, B) => {
      let G = new A(Q);
      return G.update((0, Md4.toUint8Array)(B)), G.digest()
    }, "hmac"),
    tN1 = ZD(({
      headers: A
    }, Q, B) => {
      let G = {};
      for (let Z of Object.keys(A).sort()) {
        if (A[Z] == null) continue;
        let I = Z.toLowerCase();
        if (I in sXQ || Q?.has(I) || rXQ.test(I) || oXQ.test(I)) {
          if (!B || B && !B.has(I)) continue
        }
        G[I] = A[Z].trim().replace(/\s+/g, " ")
      }
      return G
    }, "getCanonicalHeaders"),
    Rd4 = _XQ(),
    Td4 = O2(),
    ngA = ZD(async ({
      headers: A,
      body: Q
    }, B) => {
      for (let G of Object.keys(A))
        if (G.toLowerCase() === sgA) return A[G];
      if (Q == null) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      else if (typeof Q === "string" || ArrayBuffer.isView(Q) || (0, Rd4.isArrayBuffer)(Q)) {
        let G = new B;
        return G.update((0, Td4.toUint8Array)(Q)), (0, Td.toHex)(await G.digest())
      }
      return eXQ
    }, "getPayloadHash"),
    hXQ = O2(),
    Pd4 = class {
      static {
        ZD(this, "HeaderFormatter")
      }
      format(A) {
        let Q = [];
        for (let Z of Object.keys(A)) {
          let I = (0, hXQ.fromUtf8)(Z);
          Q.push(Uint8Array.from([I.byteLength]), I, this.formatHeaderValue(A[Z]))
        }
        let B = new Uint8Array(Q.reduce((Z, I) => Z + I.byteLength, 0)),
          G = 0;
        for (let Z of Q) B.set(Z, G), G += Z.byteLength;
        return B
      }
      formatHeaderValue(A) {
        switch (A.type) {
          case "boolean":
            return Uint8Array.from([A.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, A.value]);
          case "short":
            let Q = new DataView(new ArrayBuffer(3));
            return Q.setUint8(0, 3), Q.setInt16(1, A.value, !1), new Uint8Array(Q.buffer);
          case "integer":
            let B = new DataView(new ArrayBuffer(5));
            return B.setUint8(0, 4), B.setInt32(1, A.value, !1), new Uint8Array(B.buffer);
          case "long":
            let G = new Uint8Array(9);
            return G[0] = 5, G.set(A.value.bytes, 1), G;
          case "binary":
            let Z = new DataView(new ArrayBuffer(3 + A.value.byteLength));
            Z.setUint8(0, 6), Z.setUint16(1, A.value.byteLength, !1);
            let I = new Uint8Array(Z.buffer);
            return I.set(A.value, 3), I;
          case "string":
            let Y = (0, hXQ.fromUtf8)(A.value),
              J = new DataView(new ArrayBuffer(3 + Y.byteLength));
            J.setUint8(0, 7), J.setUint16(1, Y.byteLength, !1);
            let W = new Uint8Array(J.buffer);
            return W.set(Y, 3), W;
          case "timestamp":
            let X = new Uint8Array(9);
            return X[0] = 8, X.set(Sd4.fromNumber(A.value.valueOf()).bytes, 1), X;
          case "uuid":
            if (!jd4.test(A.value)) throw Error(`Invalid UUID received: ${A.value}`);
            let V = new Uint8Array(17);
            return V[0] = 9, V.set((0, Td.fromHex)(A.value.replace(/\-/g, "")), 1), V
        }
      }
    },
    jd4 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    Sd4 = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static {
        ZD(this, "Int64")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) eN1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) eN1(Q);
        return parseInt((0, Td.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };

  function eN1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  ZD(eN1, "negate");
  var GVQ = ZD((A, Q) => {
      A = A.toLowerCase();
      for (let B of Object.keys(Q))
        if (A === B.toLowerCase()) return !0;
      return !1
    }, "hasHeader"),
    ZVQ = iz(),
    IVQ = ZD((A, Q = {}) => {
      let {
        headers: B,
        query: G = {}
      } = ZVQ.HttpRequest.clone(A);
      for (let Z of Object.keys(B)) {
        let I = Z.toLowerCase();
        if (I.slice(0, 6) === "x-amz-" && !Q.unhoistableHeaders?.has(I) || Q.hoistableHeaders?.has(I)) G[Z] = B[Z], delete B[Z]
      }
      return {
        ...A,
        headers: B,
        query: G
      }
    }, "moveHeadersToQuery"),
    AL1 = ZD((A) => {
      A = ZVQ.HttpRequest.clone(A);
      for (let Q of Object.keys(A.headers))
        if (iXQ.indexOf(Q.toLowerCase()) > -1) delete A.headers[Q];
      return A
    }, "prepareRequest"),
    gXQ = w7(),
    _d4 = O2(),
    agA = vXQ(),
    YVQ = ZD(({
      query: A = {}
    }) => {
      let Q = [],
        B = {};
      for (let G of Object.keys(A)) {
        if (G.toLowerCase() === nXQ) continue;
        let Z = (0, agA.escapeUri)(G);
        Q.push(Z);
        let I = A[G];
        if (typeof I === "string") B[Z] = `${Z}=${(0,agA.escapeUri)(I)}`;
        else if (Array.isArray(I)) B[Z] = I.slice(0).reduce((Y, J) => Y.concat([`${Z}=${(0,agA.escapeUri)(J)}`]), []).sort().join("&")
      }
      return Q.sort().map((G) => B[G]).filter((G) => G).join("&")
    }, "getCanonicalQuery"),
    kd4 = ZD((A) => yd4(A).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601"),
    yd4 = ZD((A) => {
      if (typeof A === "number") return new Date(A * 1000);
      if (typeof A === "string") {
        if (Number(A)) return new Date(Number(A) * 1000);
        return new Date(A)
      }
      return A
    }, "toDate"),
    JVQ = class {
      static {
        ZD(this, "SignatureV4Base")
      }
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        this.service = G, this.sha256 = Z, this.uriEscapePath = I, this.applyChecksum = typeof A === "boolean" ? A : !0, this.regionProvider = (0, gXQ.normalizeProvider)(B), this.credentialProvider = (0, gXQ.normalizeProvider)(Q)
      }
      createCanonicalRequest(A, Q, B) {
        let G = Object.keys(Q).sort();
        return `${A.method}
${this.getCanonicalPath(A)}
${YVQ(A)}
${G.map((Z)=>`${Z}:${Q[Z]}`).join(`
`)}

${G.join(";")}
${B}`
      }
      async createStringToSign(A, Q, B, G) {
        let Z = new this.sha256;
        Z.update((0, _d4.toUint8Array)(B));
        let I = await Z.digest();
        return `${G}
${A}
${Q}
${(0,Td.toHex)(I)}`
      }
      getCanonicalPath({
        path: A
      }) {
        if (this.uriEscapePath) {
          let Q = [];
          for (let Z of A.split("/")) {
            if (Z?.length === 0) continue;
            if (Z === ".") continue;
            if (Z === "..") Q.pop();
            else Q.push(Z)
          }
          let B = `${A?.startsWith("/")?"/":""}${Q.join("/")}${Q.length>0&&A?.endsWith("/")?"/":""}`;
          return (0, agA.escapeUri)(B).replace(/%2F/g, "/")
        }
        return A
      }
      validateResolvedCredentials(A) {
        if (typeof A !== "object" || typeof A.accessKeyId !== "string" || typeof A.secretAccessKey !== "string") throw Error("Resolved credential object is not valid")
      }
      formatDate(A) {
        let Q = kd4(A).replace(/[\-:]/g, "");
        return {
          longDate: Q,
          shortDate: Q.slice(0, 8)
        }
      }
      getCanonicalHeaderList(A) {
        return Object.keys(A).sort().join(";")
      }
    },
    xd4 = class extends JVQ {
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        super({
          applyChecksum: A,
          credentials: Q,
          region: B,
          service: G,
          sha256: Z,
          uriEscapePath: I
        });
        this.headerFormatter = new Pd4
      }
      static {
        ZD(this, "SignatureV4")
      }
      async presign(A, Q = {}) {
        let {
          signingDate: B = new Date,
          expiresIn: G = 3600,
          unsignableHeaders: Z,
          unhoistableHeaders: I,
          signableHeaders: Y,
          hoistableHeaders: J,
          signingRegion: W,
          signingService: X
        } = Q, V = await this.credentialProvider();
        this.validateResolvedCredentials(V);
        let F = W ?? await this.regionProvider(),
          {
            longDate: K,
            shortDate: D
          } = this.formatDate(B);
        if (G > QVQ) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        let H = igA(D, F, X ?? this.service),
          C = IVQ(AL1(A), {
            unhoistableHeaders: I,
            hoistableHeaders: J
          });
        if (V.sessionToken) C.query[GL1] = V.sessionToken;
        C.query[mXQ] = pgA, C.query[dXQ] = `${V.accessKeyId}/${H}`, C.query[QL1] = K, C.query[pXQ] = G.toString(10);
        let E = tN1(C, Z, Y);
        return C.query[cXQ] = this.getCanonicalHeaderList(E), C.query[BL1] = await this.getSignature(K, H, this.getSigningKey(V, F, D, X), this.createCanonicalRequest(C, E, await ngA(A, this.sha256))), C
      }
      async sign(A, Q) {
        if (typeof A === "string") return this.signString(A, Q);
        else if (A.headers && A.payload) return this.signEvent(A, Q);
        else if (A.message) return this.signMessage(A, Q);
        else return this.signRequest(A, Q)
      }
      async signEvent({
        headers: A,
        payload: Q
      }, {
        signingDate: B = new Date,
        priorSignature: G,
        signingRegion: Z,
        signingService: I
      }) {
        let Y = Z ?? await this.regionProvider(),
          {
            shortDate: J,
            longDate: W
          } = this.formatDate(B),
          X = igA(J, Y, I ?? this.service),
          V = await ngA({
            headers: {},
            body: Q
          }, this.sha256),
          F = new this.sha256;
        F.update(A);
        let K = (0, Td.toHex)(await F.digest()),
          D = [tXQ, W, X, G, K, V].join(`
`);
        return this.signString(D, {
          signingDate: B,
          signingRegion: Y,
          signingService: I
        })
      }
      async signMessage(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      }) {
        return this.signEvent({
          headers: this.headerFormatter.format(A.message.headers),
          payload: A.message.body
        }, {
          signingDate: Q,
          signingRegion: B,
          signingService: G,
          priorSignature: A.priorSignature
        }).then((I) => {
          return {
            message: A.message,
            signature: I
          }
        })
      }
      async signString(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      } = {}) {
        let Z = await this.credentialProvider();
        this.validateResolvedCredentials(Z);
        let I = B ?? await this.regionProvider(),
          {
            shortDate: Y
          } = this.formatDate(Q),
          J = new this.sha256(await this.getSigningKey(Z, I, Y, G));
        return J.update((0, bXQ.toUint8Array)(A)), (0, Td.toHex)(await J.digest())
      }
      async signRequest(A, {
        signingDate: Q = new Date,
        signableHeaders: B,
        unsignableHeaders: G,
        signingRegion: Z,
        signingService: I
      } = {}) {
        let Y = await this.credentialProvider();
        this.validateResolvedCredentials(Y);
        let J = Z ?? await this.regionProvider(),
          W = AL1(A),
          {
            longDate: X,
            shortDate: V
          } = this.formatDate(Q),
          F = igA(V, J, I ?? this.service);
        if (W.headers[IL1] = X, Y.sessionToken) W.headers[aXQ] = Y.sessionToken;
        let K = await ngA(W, this.sha256);
        if (!GVQ(sgA, W.headers) && this.applyChecksum) W.headers[sgA] = K;
        let D = tN1(W, G, B),
          H = await this.getSignature(X, F, this.getSigningKey(Y, J, V, I), this.createCanonicalRequest(W, D, K));
        return W.headers[ZL1] = `${pgA} Credential=${Y.accessKeyId}/${F}, SignedHeaders=${this.getCanonicalHeaderList(D)}, Signature=${H}`, W
      }
      async getSignature(A, Q, B, G) {
        let Z = await this.createStringToSign(A, Q, G, pgA),
          I = new this.sha256(await B);
        return I.update((0, bXQ.toUint8Array)(Z)), (0, Td.toHex)(await I.digest())
      }
      getSigningKey(A, Q, B, G) {
        return BVQ(this.sha256, A, B, Q, G || this.service)
      }
    },
    vd4 = {
      SignatureV4a: null
    }
})
// @from(Start 3014075, End 3023489)
VL1 = z((j$7, NVQ) => {
  var {
    defineProperty: ogA,
    getOwnPropertyDescriptor: bd4,
    getOwnPropertyNames: fd4
  } = Object, hd4 = Object.prototype.hasOwnProperty, HW = (A, Q) => ogA(A, "name", {
    value: Q,
    configurable: !0
  }), gd4 = (A, Q) => {
    for (var B in Q) ogA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ud4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of fd4(Q))
        if (!hd4.call(A, Z) && Z !== B) ogA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = bd4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, md4 = (A) => ud4(ogA({}, "__esModule", {
    value: !0
  }), A), zVQ = {};
  gd4(zVQ, {
    AWSSDKSigV4Signer: () => ld4,
    AwsSdkSigV4ASigner: () => nd4,
    AwsSdkSigV4Signer: () => XL1,
    NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => ad4,
    NODE_SIGV4A_CONFIG_OPTIONS: () => od4,
    getBearerTokenEnvKey: () => UVQ,
    resolveAWSSDKSigV4Config: () => ed4,
    resolveAwsSdkSigV4AConfig: () => rd4,
    resolveAwsSdkSigV4Config: () => $VQ,
    validateSigningProperties: () => WL1
  });
  NVQ.exports = md4(zVQ);
  var dd4 = iz(),
    cd4 = iz(),
    VVQ = HW((A) => cd4.HttpResponse.isInstance(A) ? A.headers?.date ?? A.headers?.Date : void 0, "getDateHeader"),
    JL1 = HW((A) => new Date(Date.now() + A), "getSkewCorrectedDate"),
    pd4 = HW((A, Q) => Math.abs(JL1(Q).getTime() - A) >= 300000, "isClockSkewed"),
    FVQ = HW((A, Q) => {
      let B = Date.parse(A);
      if (pd4(B, Q)) return B - Date.now();
      return Q
    }, "getUpdatedSystemClockOffset"),
    THA = HW((A, Q) => {
      if (!Q) throw Error(`Property \`${A}\` is not resolved for AWS SDK SigV4Auth`);
      return Q
    }, "throwSigningPropertyError"),
    WL1 = HW(async (A) => {
      let Q = THA("context", A.context),
        B = THA("config", A.config),
        G = Q.endpointV2?.properties?.authSchemes?.[0],
        I = await THA("signer", B.signer)(G),
        Y = A?.signingRegion,
        J = A?.signingRegionSet,
        W = A?.signingName;
      return {
        config: B,
        signer: I,
        signingRegion: Y,
        signingRegionSet: J,
        signingName: W
      }
    }, "validateSigningProperties"),
    XL1 = class {
      static {
        HW(this, "AwsSdkSigV4Signer")
      }
      async sign(A, Q, B) {
        if (!dd4.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let G = await WL1(B),
          {
            config: Z,
            signer: I
          } = G,
          {
            signingRegion: Y,
            signingName: J
          } = G,
          W = B.context;
        if (W?.authSchemes?.length ?? !1) {
          let [V, F] = W.authSchemes;
          if (V?.name === "sigv4a" && F?.name === "sigv4") Y = F?.signingRegion ?? Y, J = F?.signingName ?? J
        }
        return await I.sign(A, {
          signingDate: JL1(Z.systemClockOffset),
          signingRegion: Y,
          signingService: J
        })
      }
      errorHandler(A) {
        return (Q) => {
          let B = Q.ServerTime ?? VVQ(Q.$response);
          if (B) {
            let G = THA("config", A.config),
              Z = G.systemClockOffset;
            if (G.systemClockOffset = FVQ(B, G.systemClockOffset), G.systemClockOffset !== Z && Q.$metadata) Q.$metadata.clockSkewCorrected = !0
          }
          throw Q
        }
      }
      successHandler(A, Q) {
        let B = VVQ(A);
        if (B) {
          let G = THA("config", Q.config);
          G.systemClockOffset = FVQ(B, G.systemClockOffset)
        }
      }
    },
    ld4 = XL1,
    id4 = iz(),
    nd4 = class extends XL1 {
      static {
        HW(this, "AwsSdkSigV4ASigner")
      }
      async sign(A, Q, B) {
        if (!id4.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let {
          config: G,
          signer: Z,
          signingRegion: I,
          signingRegionSet: Y,
          signingName: J
        } = await WL1(B), X = (await G.sigv4aSigningRegionSet?.() ?? Y ?? [I]).join(",");
        return await Z.sign(A, {
          signingDate: JL1(G.systemClockOffset),
          signingRegion: X,
          signingService: J
        })
      }
    },
    KVQ = HW((A) => typeof A === "string" && A.length > 0 ? A.split(",").map((Q) => Q.trim()) : [], "getArrayForCommaSeparatedString"),
    UVQ = HW((A) => `AWS_BEARER_TOKEN_${A.replace(/[\s-]/g,"_").toUpperCase()}`, "getBearerTokenEnvKey"),
    DVQ = "AWS_AUTH_SCHEME_PREFERENCE",
    HVQ = "auth_scheme_preference",
    ad4 = {
      environmentVariableSelector: HW((A, Q) => {
        if (Q?.signingName) {
          if (UVQ(Q.signingName) in A) return ["httpBearerAuth"]
        }
        if (!(DVQ in A)) return;
        return KVQ(A[DVQ])
      }, "environmentVariableSelector"),
      configFileSelector: HW((A) => {
        if (!(HVQ in A)) return;
        return KVQ(A[HVQ])
      }, "configFileSelector"),
      default: []
    },
    sd4 = iB(),
    CVQ = j2(),
    rd4 = HW((A) => {
      return A.sigv4aSigningRegionSet = (0, sd4.normalizeProvider)(A.sigv4aSigningRegionSet), A
    }, "resolveAwsSdkSigV4AConfig"),
    od4 = {
      environmentVariableSelector(A) {
        if (A.AWS_SIGV4A_SIGNING_REGION_SET) return A.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((Q) => Q.trim());
        throw new CVQ.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
          tryNextLink: !0
        })
      },
      configFileSelector(A) {
        if (A.sigv4a_signing_region_set) return (A.sigv4a_signing_region_set ?? "").split(",").map((Q) => Q.trim());
        throw new CVQ.ProviderError("sigv4a_signing_region_set not set in profile.", {
          tryNextLink: !0
        })
      },
      default: void 0
    },
    td4 = lR(),
    or = iB(),
    EVQ = XVQ(),
    $VQ = HW((A) => {
      let Q = A.credentials,
        B = !!A.credentials,
        G = void 0;
      Object.defineProperty(A, "credentials", {
        set(X) {
          if (X && X !== Q && X !== G) B = !0;
          Q = X;
          let V = wVQ(A, {
              credentials: Q,
              credentialDefaultProvider: A.credentialDefaultProvider
            }),
            F = qVQ(A, V);
          if (B && !F.attributed) G = HW(async (K) => F(K).then((D) => (0, td4.setCredentialFeature)(D, "CREDENTIALS_CODE", "e")), "resolvedCredentials"), G.memoized = F.memoized, G.configBound = F.configBound, G.attributed = !0;
          else G = F
        },
        get() {
          return G
        },
        enumerable: !0,
        configurable: !0
      }), A.credentials = Q;
      let {
        signingEscapePath: Z = !0,
        systemClockOffset: I = A.systemClockOffset || 0,
        sha256: Y
      } = A, J;
      if (A.signer) J = (0, or.normalizeProvider)(A.signer);
      else if (A.regionInfoProvider) J = HW(() => (0, or.normalizeProvider)(A.region)().then(async (X) => [await A.regionInfoProvider(X, {
        useFipsEndpoint: await A.useFipsEndpoint(),
        useDualstackEndpoint: await A.useDualstackEndpoint()
      }) || {}, X]).then(([X, V]) => {
        let {
          signingRegion: F,
          signingService: K
        } = X;
        A.signingRegion = A.signingRegion || F || V, A.signingName = A.signingName || K || A.serviceId;
        let D = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || EVQ.SignatureV4)(D)
      }), "signer");
      else J = HW(async (X) => {
        X = Object.assign({}, {
          name: "sigv4",
          signingName: A.signingName || A.defaultSigningName,
          signingRegion: await (0, or.normalizeProvider)(A.region)(),
          properties: {}
        }, X);
        let {
          signingRegion: V,
          signingName: F
        } = X;
        A.signingRegion = A.signingRegion || V, A.signingName = A.signingName || F || A.serviceId;
        let K = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || EVQ.SignatureV4)(K)
      }, "signer");
      return Object.assign(A, {
        systemClockOffset: I,
        signingEscapePath: Z,
        signer: J
      })
    }, "resolveAwsSdkSigV4Config"),
    ed4 = $VQ;

  function wVQ(A, {
    credentials: Q,
    credentialDefaultProvider: B
  }) {
    let G;
    if (Q)
      if (!Q?.memoized) G = (0, or.memoizeIdentityProvider)(Q, or.isIdentityExpired, or.doesIdentityRequireRefresh);
      else G = Q;
    else if (B) G = (0, or.normalizeProvider)(B(Object.assign({}, A, {
      parentClientConfig: A
    })));
    else G = HW(async () => {
      throw Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.")
    }, "credentialsProvider");
    return G.memoized = !0, G
  }
  HW(wVQ, "normalizeCredentialProvider");

  function qVQ(A, Q) {
    if (Q.configBound) return Q;
    let B = HW(async (G) => Q({
      ...G,
      callerClientConfig: A
    }), "fn");
    return B.memoized = Q.memoized, B.configBound = !0, B
  }
  HW(qVQ, "bindCallerConfig")
})
// @from(Start 3023495, End 3023982)
OVQ = z((LVQ) => {
  Object.defineProperty(LVQ, "__esModule", {
    value: !0
  });
  LVQ.fromBase64 = void 0;
  var Ac4 = hI(),
    Qc4 = /^[A-Za-z0-9+/]*={0,2}$/,
    Bc4 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!Qc4.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, Ac4.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  LVQ.fromBase64 = Bc4
})
// @from(Start 3023988, End 3024567)
PVQ = z((RVQ) => {
  Object.defineProperty(RVQ, "__esModule", {
    value: !0
  });
  RVQ.toBase64 = void 0;
  var Gc4 = hI(),
    Zc4 = O2(),
    Ic4 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, Zc4.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, Gc4.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  RVQ.toBase64 = Ic4
})
// @from(Start 3024573, End 3025268)
Pd = z((x$7, tgA) => {
  var {
    defineProperty: jVQ,
    getOwnPropertyDescriptor: Yc4,
    getOwnPropertyNames: Jc4
  } = Object, Wc4 = Object.prototype.hasOwnProperty, FL1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Jc4(Q))
        if (!Wc4.call(A, Z) && Z !== B) jVQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Yc4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, SVQ = (A, Q, B) => (FL1(A, Q, "default"), B && FL1(B, Q, "default")), Xc4 = (A) => FL1(jVQ({}, "__esModule", {
    value: !0
  }), A), KL1 = {};
  tgA.exports = Xc4(KL1);
  SVQ(KL1, OVQ(), tgA.exports);
  SVQ(KL1, PVQ(), tgA.exports)
})
// @from(Start 3025274, End 3039298)
r6 = z((v$7, $L1) => {
  var {
    defineProperty: egA,
    getOwnPropertyDescriptor: Vc4,
    getOwnPropertyNames: Fc4
  } = Object, Kc4 = Object.prototype.hasOwnProperty, P3 = (A, Q) => egA(A, "name", {
    value: Q,
    configurable: !0
  }), Dc4 = (A, Q) => {
    for (var B in Q) egA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, HL1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Fc4(Q))
        if (!Kc4.call(A, Z) && Z !== B) egA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Vc4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Hc4 = (A, Q, B) => (HL1(A, Q, "default"), B && HL1(B, Q, "default")), Cc4 = (A) => HL1(egA({}, "__esModule", {
    value: !0
  }), A), zL1 = {};
  Dc4(zL1, {
    Client: () => Ec4,
    Command: () => yVQ,
    NoOpLogger: () => yc4,
    SENSITIVE_STRING: () => Uc4,
    ServiceException: () => wc4,
    _json: () => EL1,
    collectBody: () => DL1.collectBody,
    convertMap: () => xc4,
    createAggregatedClient: () => $c4,
    decorateServiceException: () => xVQ,
    emitWarningIfUnsupportedVersion: () => Mc4,
    extendedEncodeURIComponent: () => DL1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => _c4,
    getDefaultClientConfiguration: () => jc4,
    getDefaultExtensionConfiguration: () => bVQ,
    getValueFromTextNode: () => fVQ,
    isSerializableHeaderValue: () => kc4,
    loadConfigsForDefaultMode: () => Lc4,
    map: () => UL1,
    resolveDefaultRuntimeConfig: () => Sc4,
    resolvedPath: () => DL1.resolvedPath,
    serializeDateTime: () => uc4,
    serializeFloat: () => gc4,
    take: () => vc4,
    throwDefaultError: () => vVQ,
    withBaseException: () => qc4
  });
  $L1.exports = Cc4(zL1);
  var kVQ = uR(),
    Ec4 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, kVQ.constructStack)()
      }
      static {
        P3(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    DL1 = w5(),
    CL1 = iN1(),
    yVQ = class {
      constructor() {
        this.middlewareStack = (0, kVQ.constructStack)()
      }
      static {
        P3(this, "Command")
      }
      static classBuilder() {
        return new zc4
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [CL1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    zc4 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        P3(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      sc(A) {
        return this._operationSchema = A, this._smithyContext.operationSchema = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends yVQ {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this), this.schema = A._operationSchema
          }
          static {
            P3(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    Uc4 = "***SensitiveInformation***",
    $c4 = P3((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = P3(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    wc4 = class A extends Error {
      static {
        P3(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    xVQ = P3((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    vVQ = P3(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = Nc4(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw xVQ(Y, Q)
    }, "throwDefaultError"),
    qc4 = P3((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        vVQ({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    Nc4 = P3((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    Lc4 = P3((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    _VQ = !1,
    Mc4 = P3((A) => {
      if (A && !_VQ && parseInt(A.substring(1, A.indexOf("."))) < 16) _VQ = !0
    }, "emitWarningIfUnsupportedVersion"),
    Oc4 = P3((A) => {
      let Q = [];
      for (let B in CL1.AlgorithmId) {
        let G = CL1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    Rc4 = P3((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    Tc4 = P3((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    Pc4 = P3((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    bVQ = P3((A) => {
      return Object.assign(Oc4(A), Tc4(A))
    }, "getDefaultExtensionConfiguration"),
    jc4 = bVQ,
    Sc4 = P3((A) => {
      return Object.assign(Rc4(A), Pc4(A))
    }, "resolveDefaultRuntimeConfig"),
    _c4 = P3((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    fVQ = P3((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = fVQ(A[B]);
      return A
    }, "getValueFromTextNode"),
    kc4 = P3((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    yc4 = class {
      static {
        P3(this, "NoOpLogger")
      }
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };

  function UL1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, bc4(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      hVQ(G, null, I, Y)
    }
    return G
  }
  P3(UL1, "map");
  var xc4 = P3((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    vc4 = P3((A, Q) => {
      let B = {};
      for (let G in Q) hVQ(B, A, Q, G);
      return B
    }, "take"),
    bc4 = P3((A, Q, B) => {
      return UL1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    hVQ = P3((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = fc4, W = hc4, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    fc4 = P3((A) => A != null, "nonNullish"),
    hc4 = P3((A) => A, "pass"),
    gc4 = P3((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    uc4 = P3((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    EL1 = P3((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(EL1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = EL1(A[B])
        }
        return Q
      }
      return A
    }, "_json");
  Hc4(zL1, s6(), $L1.exports)
})
// @from(Start 3039304, End 3084495)
AFQ = z((m$7, eVQ) => {
  var {
    defineProperty: QuA,
    getOwnPropertyDescriptor: mc4,
    getOwnPropertyNames: dc4
  } = Object, cc4 = Object.prototype.hasOwnProperty, I3 = (A, Q) => QuA(A, "name", {
    value: Q,
    configurable: !0
  }), pc4 = (A, Q) => {
    for (var B in Q) QuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, lc4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of dc4(Q))
        if (!cc4.call(A, Z) && Z !== B) QuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = mc4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ic4 = (A) => lc4(QuA({}, "__esModule", {
    value: !0
  }), A), cVQ = {};
  pc4(cVQ, {
    AwsEc2QueryProtocol: () => qp4,
    AwsJson1_0Protocol: () => Yp4,
    AwsJson1_1Protocol: () => Jp4,
    AwsJsonRpcProtocol: () => TL1,
    AwsQueryProtocol: () => aVQ,
    AwsRestJsonProtocol: () => Xp4,
    AwsRestXmlProtocol: () => Tp4,
    JsonCodec: () => RL1,
    JsonShapeDeserializer: () => iVQ,
    JsonShapeSerializer: () => nVQ,
    XmlCodec: () => tVQ,
    XmlShapeDeserializer: () => PL1,
    XmlShapeSerializer: () => oVQ,
    _toBool: () => ac4,
    _toNum: () => sc4,
    _toStr: () => nc4,
    awsExpectUnion: () => Fp4,
    loadRestJsonErrorCode: () => OL1,
    loadRestXmlErrorCode: () => rVQ,
    parseJsonBody: () => ML1,
    parseJsonErrorBody: () => Qp4,
    parseXmlBody: () => sVQ,
    parseXmlErrorBody: () => Op4
  });
  eVQ.exports = ic4(cVQ);
  var nc4 = I3((A) => {
      if (A == null) return A;
      if (typeof A === "number" || typeof A === "bigint") {
        let Q = Error(`Received number ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      if (typeof A === "boolean") {
        let Q = Error(`Received boolean ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      return A
    }, "_toStr"),
    ac4 = I3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (A !== "" && Q !== "false" && Q !== "true") {
          let B = Error(`Received string "${A}" where a boolean was expected.`);
          B.name = "Warning", console.warn(B)
        }
        return A !== "" && Q !== "false"
      }
      return A
    }, "_toBool"),
    sc4 = I3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = Number(A);
        if (Q.toString() !== A) {
          let B = Error(`Received string "${A}" where a number was expected.`);
          return B.name = "Warning", console.warn(B), A
        }
        return Q
      }
      return A
    }, "_toNum"),
    rc4 = w5(),
    y8A = b4(),
    oc4 = oK(),
    er = class {
      static {
        I3(this, "SerdeContextConfig")
      }
      serdeContext;
      setSerdeContext(A) {
        this.serdeContext = A
      }
    },
    PHA = b4(),
    x8A = s6(),
    tc4 = Pd(),
    ec4 = s6();

  function pVQ(A, Q, B) {
    if (B?.source) {
      let G = B.source;
      if (typeof Q === "number") {
        if (Q > Number.MAX_SAFE_INTEGER || Q < Number.MIN_SAFE_INTEGER || G !== String(Q))
          if (G.includes(".")) return new ec4.NumericValue(G, "bigDecimal");
          else return BigInt(G)
      }
    }
    return Q
  }
  I3(pVQ, "jsonReviver");
  var Ap4 = r6(),
    lVQ = I3((A, Q) => (0, Ap4.collectBody)(A, Q).then((B) => Q.utf8Encoder(B)), "collectBodyString"),
    ML1 = I3((A, Q) => lVQ(A, Q).then((B) => {
      if (B.length) try {
        return JSON.parse(B)
      } catch (G) {
        if (G?.name === "SyntaxError") Object.defineProperty(G, "$responseBodyText", {
          value: B
        });
        throw G
      }
      return {}
    }), "parseJsonBody"),
    Qp4 = I3(async (A, Q) => {
      let B = await ML1(A, Q);
      return B.message = B.message ?? B.Message, B
    }, "parseJsonErrorBody"),
    OL1 = I3((A, Q) => {
      let B = I3((I, Y) => Object.keys(I).find((J) => J.toLowerCase() === Y.toLowerCase()), "findKey"),
        G = I3((I) => {
          let Y = I;
          if (typeof Y === "number") Y = Y.toString();
          if (Y.indexOf(",") >= 0) Y = Y.split(",")[0];
          if (Y.indexOf(":") >= 0) Y = Y.split(":")[0];
          if (Y.indexOf("#") >= 0) Y = Y.split("#")[1];
          return Y
        }, "sanitizeErrorCode"),
        Z = B(A.headers, "x-amzn-errortype");
      if (Z !== void 0) return G(A.headers[Z]);
      if (Q && typeof Q === "object") {
        let I = B(Q, "code");
        if (I && Q[I] !== void 0) return G(Q[I]);
        if (Q.__type !== void 0) return G(Q.__type)
      }
    }, "loadRestJsonErrorCode"),
    iVQ = class extends er {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        I3(this, "JsonShapeDeserializer")
      }
      async read(A, Q) {
        return this._read(A, typeof Q === "string" ? JSON.parse(Q, pVQ) : await ML1(Q, this.serdeContext))
      }
      readObject(A, Q) {
        return this._read(A, Q)
      }
      _read(A, Q) {
        let B = Q !== null && typeof Q === "object",
          G = PHA.NormalizedSchema.of(A);
        if (G.isListSchema() && Array.isArray(Q)) {
          let I = G.getValueSchema(),
            Y = [],
            J = !!G.getMergedTraits().sparse;
          for (let W of Q)
            if (J || W != null) Y.push(this._read(I, W));
          return Y
        } else if (G.isMapSchema() && B) {
          let I = G.getValueSchema(),
            Y = {},
            J = !!G.getMergedTraits().sparse;
          for (let [W, X] of Object.entries(Q))
            if (J || X != null) Y[W] = this._read(I, X);
          return Y
        } else if (G.isStructSchema() && B) {
          let I = {};
          for (let [Y, J] of G.structIterator()) {
            let W = this.settings.jsonName ? J.getMergedTraits().jsonName ?? Y : Y,
              X = this._read(J, Q[W]);
            if (X != null) I[Y] = X
          }
          return I
        }
        if (G.isBlobSchema() && typeof Q === "string") return (0, tc4.fromBase64)(Q);
        let Z = G.getMergedTraits().mediaType;
        if (G.isStringSchema() && typeof Q === "string" && Z) {
          if (Z === "application/json" || Z.endsWith("+json")) return x8A.LazyJsonString.from(Q)
        }
        if (G.isTimestampSchema()) {
          let I = this.settings.timestampFormat;
          switch (I.useTrait ? G.getSchema() === PHA.SCHEMA.TIMESTAMP_DEFAULT ? I.default : G.getSchema() ?? I.default : I.default) {
            case PHA.SCHEMA.TIMESTAMP_DATE_TIME:
              return (0, x8A.parseRfc3339DateTimeWithOffset)(Q);
            case PHA.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, x8A.parseRfc7231DateTime)(Q);
            case PHA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return (0, x8A.parseEpochTimestamp)(Q);
            default:
              return console.warn("Missing timestamp format, parsing value with Date constructor:", Q), new Date(Q)
          }
        }
        if (G.isBigIntegerSchema() && (typeof Q === "number" || typeof Q === "string")) return BigInt(Q);
        if (G.isBigDecimalSchema() && Q != null) {
          if (Q instanceof x8A.NumericValue) return Q;
          return new x8A.NumericValue(String(Q), "bigDecimal")
        }
        if (G.isNumericSchema() && typeof Q === "string") switch (Q) {
          case "Infinity":
            return 1 / 0;
          case "-Infinity":
            return -1 / 0;
          case "NaN":
            return NaN
        }
        return Q
      }
    },
    v8A = b4(),
    Bp4 = s6(),
    Gp4 = s6(),
    Zp4 = s6(),
    gVQ = String.fromCharCode(925),
    Ip4 = class {
      static {
        I3(this, "JsonReplacer")
      }
      values = new Map;
      counter = 0;
      stage = 0;
      createReplacer() {
        if (this.stage === 1) throw Error("@aws-sdk/core/protocols - JsonReplacer already created.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        return this.stage = 1, (A, Q) => {
          if (Q instanceof Zp4.NumericValue) {
            let B = `${gVQ+NaN+this.counter++}_` + Q.string;
            return this.values.set(`"${B}"`, Q.string), B
          }
          if (typeof Q === "bigint") {
            let B = Q.toString(),
              G = `${gVQ+"b"+this.counter++}_` + B;
            return this.values.set(`"${G}"`, B), G
          }
          return Q
        }
      }
      replaceInJson(A) {
        if (this.stage === 0) throw Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        if (this.stage = 2, this.counter === 0) return A;
        for (let [Q, B] of this.values) A = A.replace(Q, B);
        return A
      }
    },
    nVQ = class extends er {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        I3(this, "JsonShapeSerializer")
      }
      buffer;
      rootSchema;
      write(A, Q) {
        this.rootSchema = v8A.NormalizedSchema.of(A), this.buffer = this._write(this.rootSchema, Q)
      }
      flush() {
        if (this.rootSchema?.isStructSchema() || this.rootSchema?.isDocumentSchema()) {
          let A = new Ip4;
          return A.replaceInJson(JSON.stringify(this.buffer, A.createReplacer(), 0))
        }
        return this.buffer
      }
      _write(A, Q, B) {
        let G = Q !== null && typeof Q === "object",
          Z = v8A.NormalizedSchema.of(A);
        if (Z.isListSchema() && Array.isArray(Q)) {
          let Y = Z.getValueSchema(),
            J = [],
            W = !!Z.getMergedTraits().sparse;
          for (let X of Q)
            if (W || X != null) J.push(this._write(Y, X));
          return J
        } else if (Z.isMapSchema() && G) {
          let Y = Z.getValueSchema(),
            J = {},
            W = !!Z.getMergedTraits().sparse;
          for (let [X, V] of Object.entries(Q))
            if (W || V != null) J[X] = this._write(Y, V);
          return J
        } else if (Z.isStructSchema() && G) {
          let Y = {};
          for (let [J, W] of Z.structIterator()) {
            let X = this.settings.jsonName ? W.getMergedTraits().jsonName ?? J : J,
              V = this._write(W, Q[J], Z);
            if (V !== void 0) Y[X] = V
          }
          return Y
        }
        if (Q === null && B?.isStructSchema()) return;
        if (Z.isBlobSchema() && (Q instanceof Uint8Array || typeof Q === "string")) {
          if (Z === this.rootSchema) return Q;
          if (!this.serdeContext?.base64Encoder) throw Error("Missing base64Encoder in serdeContext");
          return this.serdeContext?.base64Encoder(Q)
        }
        if (Z.isTimestampSchema() && Q instanceof Date) {
          let Y = this.settings.timestampFormat;
          switch (Y.useTrait ? Z.getSchema() === v8A.SCHEMA.TIMESTAMP_DEFAULT ? Y.default : Z.getSchema() ?? Y.default : Y.default) {
            case v8A.SCHEMA.TIMESTAMP_DATE_TIME:
              return Q.toISOString().replace(".000Z", "Z");
            case v8A.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, Bp4.dateToUtcString)(Q);
            case v8A.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return Q.getTime() / 1000;
            default:
              return console.warn("Missing timestamp format, using epoch seconds", Q), Q.getTime() / 1000
          }
        }
        if (Z.isNumericSchema() && typeof Q === "number") {
          if (Math.abs(Q) === 1 / 0 || isNaN(Q)) return String(Q)
        }
        let I = Z.getMergedTraits().mediaType;
        if (Z.isStringSchema() && typeof Q === "string" && I) {
          if (I === "application/json" || I.endsWith("+json")) return Gp4.LazyJsonString.from(Q)
        }
        return Q
      }
    },
    RL1 = class extends er {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        I3(this, "JsonCodec")
      }
      createSerializer() {
        let A = new nVQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new iVQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    TL1 = class extends rc4.RpcProtocol {
      static {
        I3(this, "AwsJsonRpcProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        this.codec = new RL1({
          timestampFormat: {
            useTrait: !0,
            default: y8A.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          jsonName: !1
        }), this.serializer = this.codec.createSerializer(), this.deserializer = this.codec.createDeserializer()
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
            "x-amz-target": (this.getJsonRpcVersion() === "1.0" ? "JsonRpc10." : "JsonProtocol.") + y8A.NormalizedSchema.of(A).getName()
          }), (0, y8A.deref)(A.input) === "unit" || !G.body) G.body = "{}";
        try {
          G.headers["content-length"] = String((0, oc4.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      getPayloadCodec() {
        return this.codec
      }
      async handleError(A, Q, B, G, Z) {
        let I = OL1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = y8A.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = y8A.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = y8A.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    Yp4 = class extends TL1 {
      static {
        I3(this, "AwsJson1_0Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_0"
      }
      getJsonRpcVersion() {
        return "1.0"
      }
    },
    Jp4 = class extends TL1 {
      static {
        I3(this, "AwsJson1_1Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_1"
      }
      getJsonRpcVersion() {
        return "1.1"
      }
    },
    wL1 = w5(),
    jHA = b4(),
    Wp4 = oK(),
    Xp4 = class extends wL1.HttpBindingProtocol {
      static {
        I3(this, "AwsRestJsonProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: jHA.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          httpBindings: !0,
          jsonName: !0
        };
        this.codec = new RL1(Q), this.serializer = new wL1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new wL1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getShapeId() {
        return "aws.protocols#restJson1"
      }
      getPayloadCodec() {
        return this.codec
      }
      setSerdeContext(A) {
        this.codec.setSerdeContext(A), super.setSerdeContext(A)
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = jHA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (!G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/json"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/json"
          }
        }
        if (G.headers["content-type"] && !G.body) G.body = "{}";
        if (G.body) try {
          G.headers["content-length"] = String((0, Wp4.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async handleError(A, Q, B, G, Z) {
        let I = OL1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = jHA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = jHA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = jHA.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    Vp4 = r6(),
    Fp4 = I3((A) => {
      if (A == null) return;
      if (typeof A === "object" && "__type" in A) delete A.__type;
      return (0, Vp4.expectUnion)(A)
    }, "awsExpectUnion"),
    qL1 = w5(),
    jd = b4(),
    Kp4 = oK(),
    Dp4 = w5(),
    uVQ = b4(),
    Hp4 = r6(),
    Cp4 = O2(),
    Ep4 = wS(),
    PL1 = class extends er {
      constructor(A) {
        super();
        this.settings = A, this.stringDeserializer = new Dp4.FromStringShapeDeserializer(A)
      }
      static {
        I3(this, "XmlShapeDeserializer")
      }
      stringDeserializer;
      setSerdeContext(A) {
        this.serdeContext = A, this.stringDeserializer.setSerdeContext(A)
      }
      read(A, Q, B) {
        let G = uVQ.NormalizedSchema.of(A),
          Z = G.getMemberSchemas();
        if (G.isStructSchema() && G.isMemberSchema() && !!Object.values(Z).find((W) => {
            return !!W.getMemberTraits().eventPayload
          })) {
          let W = {},
            X = Object.keys(Z)[0];
          if (Z[X].isBlobSchema()) W[X] = Q;
          else W[X] = this.read(Z[X], Q);
          return W
        }
        let Y = (this.serdeContext?.utf8Encoder ?? Cp4.toUtf8)(Q),
          J = this.parseXml(Y);
        return this.readSchema(A, B ? J[B] : J)
      }
      readSchema(A, Q) {
        let B = uVQ.NormalizedSchema.of(A),
          G = B.getMergedTraits(),
          Z = B.getSchema();
        if (B.isListSchema() && !Array.isArray(Q)) return this.readSchema(Z, [Q]);
        if (Q == null) return Q;
        if (typeof Q === "object") {
          let I = !!G.sparse,
            Y = !!G.xmlFlattened;
          if (B.isListSchema()) {
            let W = B.getValueSchema(),
              X = [],
              V = W.getMergedTraits().xmlName ?? "member",
              F = Y ? Q : (Q[0] ?? Q)[V],
              K = Array.isArray(F) ? F : [F];
            for (let D of K)
              if (D != null || I) X.push(this.readSchema(W, D));
            return X
          }
          let J = {};
          if (B.isMapSchema()) {
            let W = B.getKeySchema(),
              X = B.getValueSchema(),
              V;
            if (Y) V = Array.isArray(Q) ? Q : [Q];
            else V = Array.isArray(Q.entry) ? Q.entry : [Q.entry];
            let F = W.getMergedTraits().xmlName ?? "key",
              K = X.getMergedTraits().xmlName ?? "value";
            for (let D of V) {
              let H = D[F],
                C = D[K];
              if (C != null || I) J[H] = this.readSchema(X, C)
            }
            return J
          }
          if (B.isStructSchema()) {
            for (let [W, X] of B.structIterator()) {
              let V = X.getMergedTraits(),
                F = !V.httpPayload ? X.getMemberTraits().xmlName ?? W : V.xmlName ?? X.getName();
              if (Q[F] != null) J[W] = this.readSchema(X, Q[F])
            }
            return J
          }
          if (B.isDocumentSchema()) return Q;
          throw Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${B.getName(!0)}`)
        } else {
          if (B.isListSchema()) return [];
          else if (B.isMapSchema() || B.isStructSchema()) return {};
          return this.stringDeserializer.read(B, Q)
        }
      }
      parseXml(A) {
        if (A.length) {
          let Q = new Ep4.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: I3((Y, J) => J.trim() === "" && J.includes(`
`) ? "" : void 0, "tagValueProcessor")
          });
          Q.addEntity("#xD", "\r"), Q.addEntity("#10", `
`);
          let B;
          try {
            B = Q.parse(A, !0)
          } catch (Y) {
            if (Y && typeof Y === "object") Object.defineProperty(Y, "$responseBodyText", {
              value: A
            });
            throw Y
          }
          let G = "#text",
            Z = Object.keys(B)[0],
            I = B[Z];
          if (I[G]) I[Z] = I[G], delete I[G];
          return (0, Hp4.getValueFromTextNode)(I)
        }
        return {}
      }
    },
    NL1 = w5(),
    AuA = b4(),
    zp4 = s6(),
    Up4 = r6(),
    $p4 = Pd(),
    wp4 = class extends er {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        I3(this, "QueryShapeSerializer")
      }
      buffer;
      write(A, Q, B = "") {
        if (this.buffer === void 0) this.buffer = "";
        let G = AuA.NormalizedSchema.of(A);
        if (B && !B.endsWith(".")) B += ".";
        if (G.isBlobSchema()) {
          if (typeof Q === "string" || Q instanceof Uint8Array) this.writeKey(B), this.writeValue((this.serdeContext?.base64Encoder ?? $p4.toBase64)(Q))
        } else if (G.isBooleanSchema() || G.isNumericSchema() || G.isStringSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigIntegerSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigDecimalSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(Q instanceof zp4.NumericValue ? Q.string : String(Q))
        } else if (G.isTimestampSchema()) {
          if (Q instanceof Date) switch (this.writeKey(B), (0, NL1.determineTimestampFormat)(G, this.settings)) {
            case AuA.SCHEMA.TIMESTAMP_DATE_TIME:
              this.writeValue(Q.toISOString().replace(".000Z", "Z"));
              break;
            case AuA.SCHEMA.TIMESTAMP_HTTP_DATE:
              this.writeValue((0, Up4.dateToUtcString)(Q));
              break;
            case AuA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              this.writeValue(String(Q.getTime() / 1000));
              break
          }
        } else if (G.isDocumentSchema()) throw Error(`@aws-sdk/core/protocols - QuerySerializer unsupported document type ${G.getName(!0)}`);
        else if (G.isListSchema()) {
          if (Array.isArray(Q))
            if (Q.length === 0) {
              if (this.settings.serializeEmptyLists) this.writeKey(B), this.writeValue("")
            } else {
              let Z = G.getValueSchema(),
                I = this.settings.flattenLists || G.getMergedTraits().xmlFlattened,
                Y = 1;
              for (let J of Q) {
                if (J == null) continue;
                let W = this.getKey("member", Z.getMergedTraits().xmlName),
                  X = I ? `${B}${Y}` : `${B}${W}.${Y}`;
                this.write(Z, J, X), ++Y
              }
            }
        } else if (G.isMapSchema()) {
          if (Q && typeof Q === "object") {
            let Z = G.getKeySchema(),
              I = G.getValueSchema(),
              Y = G.getMergedTraits().xmlFlattened,
              J = 1;
            for (let [W, X] of Object.entries(Q)) {
              if (X == null) continue;
              let V = this.getKey("key", Z.getMergedTraits().xmlName),
                F = Y ? `${B}${J}.${V}` : `${B}entry.${J}.${V}`,
                K = this.getKey("value", I.getMergedTraits().xmlName),
                D = Y ? `${B}${J}.${K}` : `${B}entry.${J}.${K}`;
              this.write(Z, W, F), this.write(I, X, D), ++J
            }
          }
        } else if (G.isStructSchema()) {
          if (Q && typeof Q === "object")
            for (let [Z, I] of G.structIterator()) {
              if (Q[Z] == null) continue;
              let Y = this.getKey(Z, I.getMergedTraits().xmlName),
                J = `${B}${Y}`;
              this.write(I, Q[Z], J)
            }
        } else if (G.isUnitSchema());
        else throw Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${G.getName(!0)}`)
      }
      flush() {
        if (this.buffer === void 0) throw Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
        let A = this.buffer;
        return delete this.buffer, A
      }
      getKey(A, Q) {
        let B = Q ?? A;
        if (this.settings.capitalizeKeys) return B[0].toUpperCase() + B.slice(1);
        return B
      }
      writeKey(A) {
        if (A.endsWith(".")) A = A.slice(0, A.length - 1);
        this.buffer += `&${(0,NL1.extendedEncodeURIComponent)(A)}=`
      }
      writeValue(A) {
        this.buffer += (0, NL1.extendedEncodeURIComponent)(A)
      }
    },
    aVQ = class extends qL1.RpcProtocol {
      constructor(A) {
        super({
          defaultNamespace: A.defaultNamespace
        });
        this.options = A;
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: jd.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !1,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace,
          serializeEmptyLists: !0
        };
        this.serializer = new wp4(Q), this.deserializer = new PL1(Q)
      }
      static {
        I3(this, "AwsQueryProtocol")
      }
      serializer;
      deserializer;
      getShapeId() {
        return "aws.protocols#awsQuery"
      }
      setSerdeContext(A) {
        this.serializer.setSerdeContext(A), this.deserializer.setSerdeContext(A)
      }
      getPayloadCodec() {
        throw Error("AWSQuery protocol has no payload codec.")
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": "application/x-www-form-urlencoded"
          }), (0, jd.deref)(A.input) === "unit" || !G.body) G.body = "";
        if (G.body = `Action=${A.name.split("#")[1]}&Version=${this.options.version}` + G.body, G.body.endsWith("&")) G.body = G.body.slice(-1);
        try {
          G.headers["content-length"] = String((0, Kp4.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        let G = this.deserializer,
          Z = jd.NormalizedSchema.of(A.output),
          I = {};
        if (B.statusCode >= 300) {
          let X = await (0, qL1.collectBody)(B.body, Q);
          if (X.byteLength > 0) Object.assign(I, await G.read(jd.SCHEMA.DOCUMENT, X));
          await this.handleError(A, Q, B, I, this.deserializeMetadata(B))
        }
        for (let X in B.headers) {
          let V = B.headers[X];
          delete B.headers[X], B.headers[X.toLowerCase()] = V
        }
        let Y = Z.isStructSchema() && this.useNestedResult() ? A.name.split("#")[1] + "Result" : void 0,
          J = await (0, qL1.collectBody)(B.body, Q);
        if (J.byteLength > 0) Object.assign(I, await G.read(Z, J, Y));
        return {
          $metadata: this.deserializeMetadata(B),
          ...I
        }
      }
      useNestedResult() {
        return !0
      }
      async handleError(A, Q, B, G, Z) {
        let I = this.loadQueryErrorCode(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = this.loadQueryError(G),
          X = jd.TypeRegistry.for(Y),
          V;
        try {
          if (V = X.find((C) => jd.NormalizedSchema.of(C).getMergedTraits().awsQueryError?.[0] === J), !V) V = X.getSchema(I)
        } catch (C) {
          let E = jd.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (E) {
            let U = E.ctor;
            throw Object.assign(new U(J), W)
          }
          throw Error(J)
        }
        let F = jd.NormalizedSchema.of(V),
          K = this.loadQueryErrorMessage(G),
          D = new V.ctor(K),
          H = {};
        for (let [C, E] of F.structIterator()) {
          let U = E.getMergedTraits().xmlName ?? C,
            q = W[U] ?? G[U];
          H[C] = this.deserializer.readSchema(E, q)
        }
        throw Object.assign(D, {
          $metadata: Z,
          $response: B,
          $fault: F.getMergedTraits().error,
          message: K,
          ...H
        }), D
      }
      loadQueryErrorCode(A, Q) {
        let B = (Q.Errors?.[0]?.Error ?? Q.Errors?.Error ?? Q.Error)?.Code;
        if (B !== void 0) return B;
        if (A.statusCode == 404) return "NotFound"
      }
      loadQueryError(A) {
        return A.Errors?.[0]?.Error ?? A.Errors?.Error ?? A.Error
      }
      loadQueryErrorMessage(A) {
        let Q = this.loadQueryError(A);
        return Q?.message ?? Q?.Message ?? A.message ?? A.Message ?? "Unknown"
      }
    },
    qp4 = class extends aVQ {
      constructor(A) {
        super(A);
        this.options = A;
        let Q = {
          capitalizeKeys: !0,
          flattenLists: !0,
          serializeEmptyLists: !1
        };
        Object.assign(this.serializer.settings, Q)
      }
      static {
        I3(this, "AwsEc2QueryProtocol")
      }
      useNestedResult() {
        return !1
      }
    },
    LL1 = w5(),
    SHA = b4(),
    Np4 = oK(),
    Lp4 = r6(),
    Mp4 = wS(),
    sVQ = I3((A, Q) => lVQ(A, Q).then((B) => {
      if (B.length) {
        let G = new Mp4.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: !0,
          ignoreAttributes: !1,
          ignoreDeclaration: !0,
          parseTagValue: !1,
          trimValues: !1,
          tagValueProcessor: I3((W, X) => X.trim() === "" && X.includes(`
`) ? "" : void 0, "tagValueProcessor")
        });
        G.addEntity("#xD", "\r"), G.addEntity("#10", `
`);
        let Z;
        try {
          Z = G.parse(B, !0)
        } catch (W) {
          if (W && typeof W === "object") Object.defineProperty(W, "$responseBodyText", {
            value: B
          });
          throw W
        }
        let I = "#text",
          Y = Object.keys(Z)[0],
          J = Z[Y];
        if (J[I]) J[Y] = J[I], delete J[I];
        return (0, Lp4.getValueFromTextNode)(J)
      }
      return {}
    }), "parseXmlBody"),
    Op4 = I3(async (A, Q) => {
      let B = await sVQ(A, Q);
      if (B.Error) B.Error.message = B.Error.message ?? B.Error.Message;
      return B
    }, "parseXmlErrorBody"),
    rVQ = I3((A, Q) => {
      if (Q?.Error?.Code !== void 0) return Q.Error.Code;
      if (Q?.Code !== void 0) return Q.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadRestXmlErrorCode"),
    SS = rDA(),
    tr = b4(),
    Rp4 = s6(),
    mVQ = r6(),
    dVQ = Pd(),
    oVQ = class extends er {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        I3(this, "XmlShapeSerializer")
      }
      stringBuffer;
      byteBuffer;
      buffer;
      write(A, Q) {
        let B = tr.NormalizedSchema.of(A);
        if (B.isStringSchema() && typeof Q === "string") this.stringBuffer = Q;
        else if (B.isBlobSchema()) this.byteBuffer = "byteLength" in Q ? Q : (this.serdeContext?.base64Decoder ?? dVQ.fromBase64)(Q);
        else {
          this.buffer = this.writeStruct(B, Q, void 0);
          let G = B.getMergedTraits();
          if (G.httpPayload && !G.xmlName) this.buffer.withName(B.getName())
        }
      }
      flush() {
        if (this.byteBuffer !== void 0) {
          let Q = this.byteBuffer;
          return delete this.byteBuffer, Q
        }
        if (this.stringBuffer !== void 0) {
          let Q = this.stringBuffer;
          return delete this.stringBuffer, Q
        }
        let A = this.buffer;
        if (this.settings.xmlNamespace) {
          if (!A?.attributes?.xmlns) A.addAttribute("xmlns", this.settings.xmlNamespace)
        }
        return delete this.buffer, A.toString()
      }
      writeStruct(A, Q, B) {
        let G = A.getMergedTraits(),
          Z = A.isMemberSchema() && !G.httpPayload ? A.getMemberTraits().xmlName ?? A.getMemberName() : G.xmlName ?? A.getName();
        if (!Z || !A.isStructSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${A.getName(!0)}.`);
        let I = SS.XmlNode.of(Z),
          [Y, J] = this.getXmlnsAttribute(A, B);
        if (J) I.addAttribute(Y, J);
        for (let [W, X] of A.structIterator()) {
          let V = Q[W];
          if (V != null) {
            if (X.getMergedTraits().xmlAttribute) {
              I.addAttribute(X.getMergedTraits().xmlName ?? W, this.writeSimple(X, V));
              continue
            }
            if (X.isListSchema()) this.writeList(X, V, I, J);
            else if (X.isMapSchema()) this.writeMap(X, V, I, J);
            else if (X.isStructSchema()) I.addChildNode(this.writeStruct(X, V, J));
            else {
              let F = SS.XmlNode.of(X.getMergedTraits().xmlName ?? X.getMemberName());
              this.writeSimpleInto(X, V, F, J), I.addChildNode(F)
            }
          }
        }
        return I
      }
      writeList(A, Q, B, G) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${A.getName(!0)}`);
        let Z = A.getMergedTraits(),
          I = A.getValueSchema(),
          Y = I.getMergedTraits(),
          J = !!Y.sparse,
          W = !!Z.xmlFlattened,
          [X, V] = this.getXmlnsAttribute(A, G),
          F = I3((K, D) => {
            if (I.isListSchema()) this.writeList(I, Array.isArray(D) ? D : [D], K, V);
            else if (I.isMapSchema()) this.writeMap(I, D, K, V);
            else if (I.isStructSchema()) {
              let H = this.writeStruct(I, D, V);
              K.addChildNode(H.withName(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member"))
            } else {
              let H = SS.XmlNode.of(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member");
              this.writeSimpleInto(I, D, H, V), K.addChildNode(H)
            }
          }, "writeItem");
        if (W) {
          for (let K of Q)
            if (J || K != null) F(B, K)
        } else {
          let K = SS.XmlNode.of(Z.xmlName ?? A.getMemberName());
          if (V) K.addAttribute(X, V);
          for (let D of Q)
            if (J || D != null) F(K, D);
          B.addChildNode(K)
        }
      }
      writeMap(A, Q, B, G, Z = !1) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${A.getName(!0)}`);
        let I = A.getMergedTraits(),
          Y = A.getKeySchema(),
          W = Y.getMergedTraits().xmlName ?? "key",
          X = A.getValueSchema(),
          V = X.getMergedTraits(),
          F = V.xmlName ?? "value",
          K = !!V.sparse,
          D = !!I.xmlFlattened,
          [H, C] = this.getXmlnsAttribute(A, G),
          E = I3((U, q, w) => {
            let N = SS.XmlNode.of(W, q),
              [R, T] = this.getXmlnsAttribute(Y, C);
            if (T) N.addAttribute(R, T);
            U.addChildNode(N);
            let y = SS.XmlNode.of(F);
            if (X.isListSchema()) this.writeList(X, w, y, C);
            else if (X.isMapSchema()) this.writeMap(X, w, y, C, !0);
            else if (X.isStructSchema()) y = this.writeStruct(X, w, C);
            else this.writeSimpleInto(X, w, y, C);
            U.addChildNode(y)
          }, "addKeyValue");
        if (D) {
          for (let [U, q] of Object.entries(Q))
            if (K || q != null) {
              let w = SS.XmlNode.of(I.xmlName ?? A.getMemberName());
              E(w, U, q), B.addChildNode(w)
            }
        } else {
          let U;
          if (!Z) {
            if (U = SS.XmlNode.of(I.xmlName ?? A.getMemberName()), C) U.addAttribute(H, C);
            B.addChildNode(U)
          }
          for (let [q, w] of Object.entries(Q))
            if (K || w != null) {
              let N = SS.XmlNode.of("entry");
              E(N, q, w), (Z ? B : U).addChildNode(N)
            }
        }
      }
      writeSimple(A, Q) {
        if (Q === null) throw Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
        let B = tr.NormalizedSchema.of(A),
          G = null;
        if (Q && typeof Q === "object")
          if (B.isBlobSchema()) G = (this.serdeContext?.base64Encoder ?? dVQ.toBase64)(Q);
          else if (B.isTimestampSchema() && Q instanceof Date) {
          let Z = this.settings.timestampFormat;
          switch (Z.useTrait ? B.getSchema() === tr.SCHEMA.TIMESTAMP_DEFAULT ? Z.default : B.getSchema() ?? Z.default : Z.default) {
            case tr.SCHEMA.TIMESTAMP_DATE_TIME:
              G = Q.toISOString().replace(".000Z", "Z");
              break;
            case tr.SCHEMA.TIMESTAMP_HTTP_DATE:
              G = (0, mVQ.dateToUtcString)(Q);
              break;
            case tr.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              G = String(Q.getTime() / 1000);
              break;
            default:
              console.warn("Missing timestamp format, using http date", Q), G = (0, mVQ.dateToUtcString)(Q);
              break
          }
        } else if (B.isBigDecimalSchema() && Q) {
          if (Q instanceof Rp4.NumericValue) return Q.string;
          return String(Q)
        } else if (B.isMapSchema() || B.isListSchema()) throw Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
        else throw Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${B.getName(!0)}`);
        if (B.isStringSchema() || B.isBooleanSchema() || B.isNumericSchema() || B.isBigIntegerSchema() || B.isBigDecimalSchema()) G = String(Q);
        if (G === null) throw Error(`Unhandled schema-value pair ${B.getName(!0)}=${Q}`);
        return G
      }
      writeSimpleInto(A, Q, B, G) {
        let Z = this.writeSimple(A, Q),
          I = tr.NormalizedSchema.of(A),
          Y = new SS.XmlText(Z),
          [J, W] = this.getXmlnsAttribute(I, G);
        if (W) B.addAttribute(J, W);
        B.addChildNode(Y)
      }
      getXmlnsAttribute(A, Q) {
        let B = A.getMergedTraits(),
          [G, Z] = B.xmlNamespace ?? [];
        if (Z && Z !== Q) return [G ? `xmlns:${G}` : "xmlns", Z];
        return [void 0, void 0]
      }
    },
    tVQ = class extends er {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        I3(this, "XmlCodec")
      }
      createSerializer() {
        let A = new oVQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new PL1(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    Tp4 = class extends LL1.HttpBindingProtocol {
      static {
        I3(this, "AwsRestXmlProtocol")
      }
      codec;
      serializer;
      deserializer;
      constructor(A) {
        super(A);
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: SHA.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !0,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace
        };
        this.codec = new tVQ(Q), this.serializer = new LL1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new LL1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getPayloadCodec() {
        return this.codec
      }
      getShapeId() {
        return "aws.protocols#restXml"
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = SHA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (G.path = String(G.path).split("/").filter((Y) => {
            return Y !== "{Bucket}"
          }).join("/") || "/", !G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/xml"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/xml"
          }
        }
        if (G.headers["content-type"] === "application/xml") {
          if (typeof G.body === "string") G.body = '<?xml version="1.0" encoding="UTF-8"?>' + G.body
        }
        if (G.body) try {
          G.headers["content-length"] = String((0, Np4.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        return super.deserializeResponse(A, Q, B)
      }
      async handleError(A, Q, B, G, Z) {
        let I = rVQ(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = SHA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = SHA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = SHA.NormalizedSchema.of(X),
          F = G.Error?.message ?? G.Error?.Message ?? G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().xmlName ?? H,
            U = G.Error?.[E] ?? G[E];
          D[H] = this.codec.createDeserializer().readSchema(C, U)
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    }
})
// @from(Start 3084501, End 3084698)
TF = z((_HA) => {
  Object.defineProperty(_HA, "__esModule", {
    value: !0
  });
  var jL1 = rr();
  jL1.__exportStar(lR(), _HA);
  jL1.__exportStar(VL1(), _HA);
  jL1.__exportStar(AFQ(), _HA)
})
// @from(Start 3084704, End 3090358)
b8A = z((Iw7, KFQ) => {
  var {
    defineProperty: GuA,
    getOwnPropertyDescriptor: Pp4,
    getOwnPropertyNames: jp4
  } = Object, Sp4 = Object.prototype.hasOwnProperty, pv = (A, Q) => GuA(A, "name", {
    value: Q,
    configurable: !0
  }), _p4 = (A, Q) => {
    for (var B in Q) GuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, kp4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of jp4(Q))
        if (!Sp4.call(A, Z) && Z !== B) GuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Pp4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, yp4 = (A) => kp4(GuA({}, "__esModule", {
    value: !0
  }), A), ZFQ = {};
  _p4(ZFQ, {
    DEFAULT_UA_APP_ID: () => IFQ,
    getUserAgentMiddlewareOptions: () => FFQ,
    getUserAgentPlugin: () => mp4,
    resolveUserAgentConfig: () => JFQ,
    userAgentMiddleware: () => VFQ
  });
  KFQ.exports = yp4(ZFQ);
  var xp4 = iB(),
    IFQ = void 0;

  function YFQ(A) {
    if (A === void 0) return !0;
    return typeof A === "string" && A.length <= 50
  }
  pv(YFQ, "isValidUserAgentAppId");

  function JFQ(A) {
    let Q = (0, xp4.normalizeProvider)(A.userAgentAppId ?? IFQ),
      {
        customUserAgent: B
      } = A;
    return Object.assign(A, {
      customUserAgent: typeof B === "string" ? [
        [B]
      ] : B,
      userAgentAppId: pv(async () => {
        let G = await Q();
        if (!YFQ(G)) {
          let Z = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console : A.logger;
          if (typeof G !== "string") Z?.warn("userAgentAppId must be a string or undefined.");
          else if (G.length > 50) Z?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.")
        }
        return G
      }, "userAgentAppId")
    })
  }
  pv(JFQ, "resolveUserAgentConfig");
  var vp4 = S8A(),
    bp4 = iz(),
    _S = TF(),
    fp4 = /\d{12}\.ddb/;
  async function WFQ(A, Q, B) {
    if (B.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor")(0, _S.setFeature)(A, "PROTOCOL_RPC_V2_CBOR", "M");
    if (typeof Q.retryStrategy === "function") {
      let I = await Q.retryStrategy();
      if (typeof I.acquireInitialRetryToken === "function")
        if (I.constructor?.name?.includes("Adaptive"))(0, _S.setFeature)(A, "RETRY_MODE_ADAPTIVE", "F");
        else(0, _S.setFeature)(A, "RETRY_MODE_STANDARD", "E");
      else(0, _S.setFeature)(A, "RETRY_MODE_LEGACY", "D")
    }
    if (typeof Q.accountIdEndpointMode === "function") {
      let I = A.endpointV2;
      if (String(I?.url?.hostname).match(fp4))(0, _S.setFeature)(A, "ACCOUNT_ID_ENDPOINT", "O");
      switch (await Q.accountIdEndpointMode?.()) {
        case "disabled":
          (0, _S.setFeature)(A, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, _S.setFeature)(A, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, _S.setFeature)(A, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break
      }
    }
    let Z = A.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (Z?.$source) {
      let I = Z;
      if (I.accountId)(0, _S.setFeature)(A, "RESOLVED_ACCOUNT_ID", "T");
      for (let [Y, J] of Object.entries(I.$source ?? {}))(0, _S.setFeature)(A, Y, J)
    }
  }
  pv(WFQ, "checkFeatures");
  var QFQ = "user-agent",
    SL1 = "x-amz-user-agent",
    BFQ = " ",
    _L1 = "/",
    hp4 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
    gp4 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
    GFQ = "-",
    up4 = 1024;

  function XFQ(A) {
    let Q = "";
    for (let B in A) {
      let G = A[B];
      if (Q.length + G.length + 1 <= up4) {
        if (Q.length) Q += "," + G;
        else Q += G;
        continue
      }
      break
    }
    return Q
  }
  pv(XFQ, "encodeFeatures");
  var VFQ = pv((A) => (Q, B) => async (G) => {
      let {
        request: Z
      } = G;
      if (!bp4.HttpRequest.isInstance(Z)) return Q(G);
      let {
        headers: I
      } = Z, Y = B?.userAgent?.map(BuA) || [], J = (await A.defaultUserAgentProvider()).map(BuA);
      await WFQ(B, A, G);
      let W = B;
      J.push(`m/${XFQ(Object.assign({},B.__smithy_context?.features,W.__aws_sdk_context?.features))}`);
      let X = A?.customUserAgent?.map(BuA) || [],
        V = await A.userAgentAppId();
      if (V) J.push(BuA([`app/${V}`]));
      let F = (0, vp4.getUserAgentPrefix)(),
        K = (F ? [F] : []).concat([...J, ...Y, ...X]).join(BFQ),
        D = [...J.filter((H) => H.startsWith("aws-sdk-")), ...X].join(BFQ);
      if (A.runtime !== "browser") {
        if (D) I[SL1] = I[SL1] ? `${I[QFQ]} ${D}` : D;
        I[QFQ] = K
      } else I[SL1] = K;
      return Q({
        ...G,
        request: Z
      })
    }, "userAgentMiddleware"),
    BuA = pv((A) => {
      let Q = A[0].split(_L1).map((Y) => Y.replace(hp4, GFQ)).join(_L1),
        B = A[1]?.replace(gp4, GFQ),
        G = Q.indexOf(_L1),
        Z = Q.substring(0, G),
        I = Q.substring(G + 1);
      if (Z === "api") I = I.toLowerCase();
      return [Z, I, B].filter((Y) => Y && Y.length > 0).reduce((Y, J, W) => {
        switch (W) {
          case 0:
            return J;
          case 1:
            return `${Y}/${J}`;
          default:
            return `${Y}#${J}`
        }
      }, "")
    }, "escapeUserAgent"),
    FFQ = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: !0
    },
    mp4 = pv((A) => ({
      applyToStack: pv((Q) => {
        Q.add(VFQ(A), FFQ)
      }, "applyToStack")
    }), "getUserAgentPlugin")
})
// @from(Start 3090364, End 3092110)
yL1 = z((DFQ) => {
  Object.defineProperty(DFQ, "__esModule", {
    value: !0
  });
  DFQ.resolveHttpAuthSchemeConfig = DFQ.defaultCognitoIdentityHttpAuthSchemeProvider = DFQ.defaultCognitoIdentityHttpAuthSchemeParametersProvider = void 0;
  var dp4 = TF(),
    kL1 = w7(),
    cp4 = async (A, Q, B) => {
      return {
        operation: (0, kL1.getSmithyContext)(Q).operation,
        region: await (0, kL1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  DFQ.defaultCognitoIdentityHttpAuthSchemeParametersProvider = cp4;

  function pp4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "cognito-identity",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function ZuA(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var lp4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "GetCredentialsForIdentity": {
        Q.push(ZuA(A));
        break
      }
      case "GetId": {
        Q.push(ZuA(A));
        break
      }
      case "GetOpenIdToken": {
        Q.push(ZuA(A));
        break
      }
      case "UnlinkIdentity": {
        Q.push(ZuA(A));
        break
      }
      default:
        Q.push(pp4(A))
    }
    return Q
  };
  DFQ.defaultCognitoIdentityHttpAuthSchemeProvider = lp4;
  var ip4 = (A) => {
    let Q = (0, dp4.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, kL1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  DFQ.resolveHttpAuthSchemeConfig = ip4
})
// @from(Start 3092116, End 3096061)
CFQ = z((Jw7, sp4) => {
  sp4.exports = {
    name: "@aws-sdk/client-cognito-identity",
    description: "AWS SDK for JavaScript Cognito Identity Client for Node.js, Browser and React Native",
    version: "3.840.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-cognito-identity",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo cognito-identity",
      "test:e2e": "yarn g:vitest run -c vitest.config.e2e.ts --mode development",
      "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.ts"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/credential-provider-node": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@aws-sdk/client-iam": "3.840.0",
      "@tsconfig/node18": "18.2.4",
      "@types/chai": "^4.2.11",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-cognito-identity"
    }
  }
})
// @from(Start 3096067, End 3098140)
xL1 = z((Ww7, LFQ) => {
  var {
    defineProperty: IuA,
    getOwnPropertyDescriptor: rp4,
    getOwnPropertyNames: op4
  } = Object, tp4 = Object.prototype.hasOwnProperty, ep4 = (A, Q) => IuA(A, "name", {
    value: Q,
    configurable: !0
  }), Al4 = (A, Q) => {
    for (var B in Q) IuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Ql4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of op4(Q))
        if (!tp4.call(A, Z) && Z !== B) IuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = rp4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Bl4 = (A) => Ql4(IuA({}, "__esModule", {
    value: !0
  }), A), EFQ = {};
  Al4(EFQ, {
    ENV_ACCOUNT_ID: () => NFQ,
    ENV_CREDENTIAL_SCOPE: () => qFQ,
    ENV_EXPIRATION: () => wFQ,
    ENV_KEY: () => zFQ,
    ENV_SECRET: () => UFQ,
    ENV_SESSION: () => $FQ,
    fromEnv: () => Il4
  });
  LFQ.exports = Bl4(EFQ);
  var Gl4 = lR(),
    Zl4 = j2(),
    zFQ = "AWS_ACCESS_KEY_ID",
    UFQ = "AWS_SECRET_ACCESS_KEY",
    $FQ = "AWS_SESSION_TOKEN",
    wFQ = "AWS_CREDENTIAL_EXPIRATION",
    qFQ = "AWS_CREDENTIAL_SCOPE",
    NFQ = "AWS_ACCOUNT_ID",
    Il4 = ep4((A) => async () => {
      A?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
      let Q = process.env[zFQ],
        B = process.env[UFQ],
        G = process.env[$FQ],
        Z = process.env[wFQ],
        I = process.env[qFQ],
        Y = process.env[NFQ];
      if (Q && B) {
        let J = {
          accessKeyId: Q,
          secretAccessKey: B,
          ...G && {
            sessionToken: G
          },
          ...Z && {
            expiration: new Date(Z)
          },
          ...I && {
            credentialScope: I
          },
          ...Y && {
            accountId: Y
          }
        };
        return (0, Gl4.setCredentialFeature)(J, "CREDENTIALS_ENV_VARS", "g"), J
      }
      throw new Zl4.CredentialsProviderError("Unable to find environment variable credentials.", {
        logger: A?.logger
      })
    }, "fromEnv")
})
// @from(Start 3098146, End 3099269)
RFQ = z((MFQ) => {
  Object.defineProperty(MFQ, "__esModule", {
    value: !0
  });
  MFQ.checkUrl = void 0;
  var Yl4 = j2(),
    Jl4 = "169.254.170.2",
    Wl4 = "169.254.170.23",
    Xl4 = "[fd00:ec2::23]",
    Vl4 = (A, Q) => {
      if (A.protocol === "https:") return;
      if (A.hostname === Jl4 || A.hostname === Wl4 || A.hostname === Xl4) return;
      if (A.hostname.includes("[")) {
        if (A.hostname === "[::1]" || A.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") return
      } else {
        if (A.hostname === "localhost") return;
        let B = A.hostname.split("."),
          G = (Z) => {
            let I = parseInt(Z, 10);
            return 0 <= I && I <= 255
          };
        if (B[0] === "127" && G(B[1]) && G(B[2]) && G(B[3]) && B.length === 4) return
      }
      throw new Yl4.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, {
        logger: Q
      })
    };
  MFQ.checkUrl = Vl4
})
// @from(Start 3099275, End 3101016)
PFQ = z((TFQ) => {
  Object.defineProperty(TFQ, "__esModule", {
    value: !0
  });
  TFQ.createGetRequest = Hl4;
  TFQ.getCredentials = Cl4;
  var vL1 = j2(),
    Fl4 = iz(),
    Kl4 = r6(),
    Dl4 = Xd();

  function Hl4(A) {
    return new Fl4.HttpRequest({
      protocol: A.protocol,
      hostname: A.hostname,
      port: Number(A.port),
      path: A.pathname,
      query: Array.from(A.searchParams.entries()).reduce((Q, [B, G]) => {
        return Q[B] = G, Q
      }, {}),
      fragment: A.hash
    })
  }
  async function Cl4(A, Q) {
    let G = await (0, Dl4.sdkStreamMixin)(A.body).transformToString();
    if (A.statusCode === 200) {
      let Z = JSON.parse(G);
      if (typeof Z.AccessKeyId !== "string" || typeof Z.SecretAccessKey !== "string" || typeof Z.Token !== "string" || typeof Z.Expiration !== "string") throw new vL1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", {
        logger: Q
      });
      return {
        accessKeyId: Z.AccessKeyId,
        secretAccessKey: Z.SecretAccessKey,
        sessionToken: Z.Token,
        expiration: (0, Kl4.parseRfc3339DateTime)(Z.Expiration)
      }
    }
    if (A.statusCode >= 400 && A.statusCode < 500) {
      let Z = {};
      try {
        Z = JSON.parse(G)
      } catch (I) {}
      throw Object.assign(new vL1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
        logger: Q
      }), {
        Code: Z.Code,
        Message: Z.Message
      })
    }
    throw new vL1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
      logger: Q
    })
  }
})
// @from(Start 3101022, End 3101392)
_FQ = z((jFQ) => {
  Object.defineProperty(jFQ, "__esModule", {
    value: !0
  });
  jFQ.retryWrapper = void 0;
  var Ul4 = (A, Q, B) => {
    return async () => {
      for (let G = 0; G < Q; ++G) try {
        return await A()
      } catch (Z) {
        await new Promise((I) => setTimeout(I, B))
      }
      return await A()
    }
  };
  jFQ.retryWrapper = Ul4
})
// @from(Start 3101398, End 3103885)
bFQ = z((xFQ) => {
  Object.defineProperty(xFQ, "__esModule", {
    value: !0
  });
  xFQ.fromHttp = void 0;
  var $l4 = rr(),
    wl4 = lR(),
    ql4 = IZ(),
    kFQ = j2(),
    Nl4 = $l4.__importDefault(UA("fs/promises")),
    Ll4 = RFQ(),
    yFQ = PFQ(),
    Ml4 = _FQ(),
    Ol4 = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    Rl4 = "http://169.254.170.2",
    Tl4 = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    Pl4 = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",
    jl4 = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    Sl4 = (A = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let Q, B = A.awsContainerCredentialsRelativeUri ?? process.env[Ol4],
        G = A.awsContainerCredentialsFullUri ?? process.env[Tl4],
        Z = A.awsContainerAuthorizationToken ?? process.env[jl4],
        I = A.awsContainerAuthorizationTokenFile ?? process.env[Pl4],
        Y = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console.warn : A.logger.warn;
      if (B && G) Y("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."), Y("awsContainerCredentialsFullUri will take precedence.");
      if (Z && I) Y("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."), Y("awsContainerAuthorizationToken will take precedence.");
      if (G) Q = G;
      else if (B) Q = `${Rl4}${B}`;
      else throw new kFQ.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, {
        logger: A.logger
      });
      let J = new URL(Q);
      (0, Ll4.checkUrl)(J, A.logger);
      let W = new ql4.NodeHttpHandler({
        requestTimeout: A.timeout ?? 1000,
        connectionTimeout: A.timeout ?? 1000
      });
      return (0, Ml4.retryWrapper)(async () => {
        let X = (0, yFQ.createGetRequest)(J);
        if (Z) X.headers.Authorization = Z;
        else if (I) X.headers.Authorization = (await Nl4.default.readFile(I)).toString();
        try {
          let V = await W.handle(X);
          return (0, yFQ.getCredentials)(V.response).then((F) => (0, wl4.setCredentialFeature)(F, "CREDENTIALS_HTTP", "z"))
        } catch (V) {
          throw new kFQ.CredentialsProviderError(String(V), {
            logger: A.logger
          })
        }
      }, A.maxRetries ?? 3, A.timeout ?? 1000)
    };
  xFQ.fromHttp = Sl4
})
// @from(Start 3103891, End 3104143)
fL1 = z((bL1) => {
  Object.defineProperty(bL1, "__esModule", {
    value: !0
  });
  bL1.fromHttp = void 0;
  var _l4 = bFQ();
  Object.defineProperty(bL1, "fromHttp", {
    enumerable: !0,
    get: function() {
      return _l4.fromHttp
    }
  })
})
// @from(Start 3104149, End 3105837)
gL1 = z((fFQ) => {
  Object.defineProperty(fFQ, "__esModule", {
    value: !0
  });
  fFQ.resolveHttpAuthSchemeConfig = fFQ.defaultSSOHttpAuthSchemeProvider = fFQ.defaultSSOHttpAuthSchemeParametersProvider = void 0;
  var yl4 = TF(),
    hL1 = w7(),
    xl4 = async (A, Q, B) => {
      return {
        operation: (0, hL1.getSmithyContext)(Q).operation,
        region: await (0, hL1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  fFQ.defaultSSOHttpAuthSchemeParametersProvider = xl4;

  function vl4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "awsssoportal",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function YuA(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var bl4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "GetRoleCredentials": {
        Q.push(YuA(A));
        break
      }
      case "ListAccountRoles": {
        Q.push(YuA(A));
        break
      }
      case "ListAccounts": {
        Q.push(YuA(A));
        break
      }
      case "Logout": {
        Q.push(YuA(A));
        break
      }
      default:
        Q.push(vl4(A))
    }
    return Q
  };
  fFQ.defaultSSOHttpAuthSchemeProvider = bl4;
  var fl4 = (A) => {
    let Q = (0, yl4.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, hL1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  fFQ.resolveHttpAuthSchemeConfig = fl4
})
// @from(Start 3105843, End 3109431)
gFQ = z((Cw7, ul4) => {
  ul4.exports = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.840.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  }
})
// @from(Start 3109437, End 3111613)
kHA = z((Ew7, iFQ) => {
  var {
    defineProperty: WuA,
    getOwnPropertyDescriptor: ml4,
    getOwnPropertyNames: dl4
  } = Object, cl4 = Object.prototype.hasOwnProperty, JuA = (A, Q) => WuA(A, "name", {
    value: Q,
    configurable: !0
  }), pl4 = (A, Q) => {
    for (var B in Q) WuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ll4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of dl4(Q))
        if (!cl4.call(A, Z) && Z !== B) WuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = ml4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, il4 = (A) => ll4(WuA({}, "__esModule", {
    value: !0
  }), A), mFQ = {};
  pl4(mFQ, {
    NODE_APP_ID_CONFIG_OPTIONS: () => ol4,
    UA_APP_ID_ENV_NAME: () => pFQ,
    UA_APP_ID_INI_NAME: () => lFQ,
    createDefaultUserAgentProvider: () => cFQ,
    crtAvailability: () => dFQ,
    defaultUserAgent: () => al4
  });
  iFQ.exports = il4(mFQ);
  var uFQ = UA("os"),
    uL1 = UA("process"),
    dFQ = {
      isCrtAvailable: !1
    },
    nl4 = JuA(() => {
      if (dFQ.isCrtAvailable) return ["md/crt-avail"];
      return null
    }, "isCrtAvailable"),
    cFQ = JuA(({
      serviceId: A,
      clientVersion: Q
    }) => {
      return async (B) => {
        let G = [
            ["aws-sdk-js", Q],
            ["ua", "2.1"],
            [`os/${(0,uFQ.platform)()}`, (0, uFQ.release)()],
            ["lang/js"],
            ["md/nodejs", `${uL1.versions.node}`]
          ],
          Z = nl4();
        if (Z) G.push(Z);
        if (A) G.push([`api/${A}`, Q]);
        if (uL1.env.AWS_EXECUTION_ENV) G.push([`exec-env/${uL1.env.AWS_EXECUTION_ENV}`]);
        let I = await B?.userAgentAppId?.();
        return I ? [...G, [`app/${I}`]] : [...G]
      }
    }, "createDefaultUserAgentProvider"),
    al4 = cFQ,
    sl4 = b8A(),
    pFQ = "AWS_SDK_UA_APP_ID",
    lFQ = "sdk_ua_app_id",
    rl4 = "sdk-ua-app-id",
    ol4 = {
      environmentVariableSelector: JuA((A) => A[pFQ], "environmentVariableSelector"),
      configFileSelector: JuA((A) => A[lFQ] ?? A[rl4], "configFileSelector"),
      default: sl4.DEFAULT_UA_APP_ID
    }
})
// @from(Start 3111619, End 3116316)
XKQ = z((JKQ) => {
  Object.defineProperty(JKQ, "__esModule", {
    value: !0
  });
  JKQ.ruleSet = void 0;
  var GKQ = "required",
    zL = "fn",
    UL = "argv",
    g8A = "ref",
    nFQ = !0,
    aFQ = "isSet",
    yHA = "booleanEquals",
    f8A = "error",
    h8A = "endpoint",
    lv = "tree",
    mL1 = "PartitionResult",
    dL1 = "getAttr",
    sFQ = {
      [GKQ]: !1,
      type: "String"
    },
    rFQ = {
      [GKQ]: !0,
      default: !1,
      type: "Boolean"
    },
    oFQ = {
      [g8A]: "Endpoint"
    },
    ZKQ = {
      [zL]: yHA,
      [UL]: [{
        [g8A]: "UseFIPS"
      }, !0]
    },
    IKQ = {
      [zL]: yHA,
      [UL]: [{
        [g8A]: "UseDualStack"
      }, !0]
    },
    EL = {},
    tFQ = {
      [zL]: dL1,
      [UL]: [{
        [g8A]: mL1
      }, "supportsFIPS"]
    },
    YKQ = {
      [g8A]: mL1
    },
    eFQ = {
      [zL]: yHA,
      [UL]: [!0, {
        [zL]: dL1,
        [UL]: [YKQ, "supportsDualStack"]
      }]
    },
    AKQ = [ZKQ],
    QKQ = [IKQ],
    BKQ = [{
      [g8A]: "Region"
    }],
    tl4 = {
      version: "1.0",
      parameters: {
        Region: sFQ,
        UseDualStack: rFQ,
        UseFIPS: rFQ,
        Endpoint: sFQ
      },
      rules: [{
        conditions: [{
          [zL]: aFQ,
          [UL]: [oFQ]
        }],
        rules: [{
          conditions: AKQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: f8A
        }, {
          conditions: QKQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: f8A
        }, {
          endpoint: {
            url: oFQ,
            properties: EL,
            headers: EL
          },
          type: h8A
        }],
        type: lv
      }, {
        conditions: [{
          [zL]: aFQ,
          [UL]: BKQ
        }],
        rules: [{
          conditions: [{
            [zL]: "aws.partition",
            [UL]: BKQ,
            assign: mL1
          }],
          rules: [{
            conditions: [ZKQ, IKQ],
            rules: [{
              conditions: [{
                [zL]: yHA,
                [UL]: [nFQ, tFQ]
              }, eFQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: EL,
                  headers: EL
                },
                type: h8A
              }],
              type: lv
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: f8A
            }],
            type: lv
          }, {
            conditions: AKQ,
            rules: [{
              conditions: [{
                [zL]: yHA,
                [UL]: [tFQ, nFQ]
              }],
              rules: [{
                conditions: [{
                  [zL]: "stringEquals",
                  [UL]: [{
                    [zL]: dL1,
                    [UL]: [YKQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://portal.sso.{Region}.amazonaws.com",
                  properties: EL,
                  headers: EL
                },
                type: h8A
              }, {
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: EL,
                  headers: EL
                },
                type: h8A
              }],
              type: lv
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: f8A
            }],
            type: lv
          }, {
            conditions: QKQ,
            rules: [{
              conditions: [eFQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: EL,
                  headers: EL
                },
                type: h8A
              }],
              type: lv
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: f8A
            }],
            type: lv
          }, {
            endpoint: {
              url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
              properties: EL,
              headers: EL
            },
            type: h8A
          }],
          type: lv
        }],
        type: lv
      }, {
        error: "Invalid Configuration: Missing Region",
        type: f8A
      }]
    };
  JKQ.ruleSet = tl4
})
// @from(Start 3116322, End 3116886)
KKQ = z((VKQ) => {
  Object.defineProperty(VKQ, "__esModule", {
    value: !0
  });
  VKQ.defaultEndpointResolver = void 0;
  var el4 = S8A(),
    cL1 = FI(),
    Ai4 = XKQ(),
    Qi4 = new cL1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    Bi4 = (A, Q = {}) => {
      return Qi4.get(A, () => (0, cL1.resolveEndpoint)(Ai4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  VKQ.defaultEndpointResolver = Bi4;
  cL1.customEndpointFunctions.aws = el4.awsEndpointFunctions
})
// @from(Start 3116892, End 3118301)
zKQ = z((CKQ) => {
  Object.defineProperty(CKQ, "__esModule", {
    value: !0
  });
  CKQ.getRuntimeConfig = void 0;
  var Gi4 = TF(),
    Zi4 = iB(),
    Ii4 = r6(),
    Yi4 = NJ(),
    DKQ = Pd(),
    HKQ = O2(),
    Ji4 = gL1(),
    Wi4 = KKQ(),
    Xi4 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? DKQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? DKQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? Wi4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Ji4.defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Gi4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Zi4.NoAuthSigner
        }],
        logger: A?.logger ?? new Ii4.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO",
        urlParser: A?.urlParser ?? Yi4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? HKQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? HKQ.toUtf8
      }
    };
  CKQ.getRuntimeConfig = Xi4
})
// @from(Start 3118307, End 3120606)
MKQ = z((NKQ) => {
  Object.defineProperty(NKQ, "__esModule", {
    value: !0
  });
  NKQ.getRuntimeConfig = void 0;
  var Vi4 = rr(),
    Fi4 = Vi4.__importDefault(gFQ()),
    UKQ = TF(),
    $KQ = kHA(),
    XuA = f8(),
    Ki4 = RX(),
    wKQ = D6(),
    Ao = uI(),
    qKQ = IZ(),
    Di4 = TX(),
    Hi4 = KW(),
    Ci4 = zKQ(),
    Ei4 = r6(),
    zi4 = PX(),
    Ui4 = r6(),
    $i4 = (A) => {
      (0, Ui4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, zi4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(Ei4.loadConfigsForDefaultMode),
        G = (0, Ci4.getRuntimeConfig)(A);
      (0, UKQ.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Ao.loadConfig)(UKQ.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? Di4.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, $KQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: Fi4.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, Ao.loadConfig)(wKQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Ao.loadConfig)(XuA.NODE_REGION_CONFIG_OPTIONS, {
          ...XuA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: qKQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Ao.loadConfig)({
          ...wKQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || Hi4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? Ki4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? qKQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Ao.loadConfig)(XuA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Ao.loadConfig)(XuA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Ao.loadConfig)($KQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  NKQ.getRuntimeConfig = $i4
})
// @from(Start 3120612, End 3123215)
xHA = z((qw7, SKQ) => {
  var {
    defineProperty: VuA,
    getOwnPropertyDescriptor: wi4,
    getOwnPropertyNames: qi4
  } = Object, Ni4 = Object.prototype.hasOwnProperty, kS = (A, Q) => VuA(A, "name", {
    value: Q,
    configurable: !0
  }), Li4 = (A, Q) => {
    for (var B in Q) VuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Mi4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qi4(Q))
        if (!Ni4.call(A, Z) && Z !== B) VuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wi4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Oi4 = (A) => Mi4(VuA({}, "__esModule", {
    value: !0
  }), A), RKQ = {};
  Li4(RKQ, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => ji4,
    NODE_REGION_CONFIG_OPTIONS: () => Pi4,
    REGION_ENV_NAME: () => TKQ,
    REGION_INI_NAME: () => PKQ,
    getAwsRegionExtensionConfiguration: () => Ri4,
    resolveAwsRegionExtensionConfiguration: () => Ti4,
    resolveRegionConfig: () => Si4
  });
  SKQ.exports = Oi4(RKQ);
  var Ri4 = kS((A) => {
      return {
        setRegion(Q) {
          A.region = Q
        },
        region() {
          return A.region
        }
      }
    }, "getAwsRegionExtensionConfiguration"),
    Ti4 = kS((A) => {
      return {
        region: A.region()
      }
    }, "resolveAwsRegionExtensionConfiguration"),
    TKQ = "AWS_REGION",
    PKQ = "region",
    Pi4 = {
      environmentVariableSelector: kS((A) => A[TKQ], "environmentVariableSelector"),
      configFileSelector: kS((A) => A[PKQ], "configFileSelector"),
      default: kS(() => {
        throw Error("Region is missing")
      }, "default")
    },
    ji4 = {
      preferredFile: "credentials"
    },
    jKQ = kS((A) => typeof A === "string" && (A.startsWith("fips-") || A.endsWith("-fips")), "isFipsRegion"),
    OKQ = kS((A) => jKQ(A) ? ["fips-aws-global", "aws-fips"].includes(A) ? "us-east-1" : A.replace(/fips-(dkr-|prod-)?|-fips/, "") : A, "getRealRegion"),
    Si4 = kS((A) => {
      let {
        region: Q,
        useFipsEndpoint: B
      } = A;
      if (!Q) throw Error("Region is missing");
      return Object.assign(A, {
        region: kS(async () => {
          if (typeof Q === "string") return OKQ(Q);
          let G = await Q();
          return OKQ(G)
        }, "region"),
        useFipsEndpoint: kS(async () => {
          let G = typeof Q === "string" ? Q : await Q();
          if (jKQ(G)) return !0;
          return typeof B !== "function" ? Promise.resolve(!!B) : B()
        }, "useFipsEndpoint")
      })
    }, "resolveRegionConfig")
})
// @from(Start 3123221, End 3139769)
ZDQ = z((Nw7, GDQ) => {
  var {
    defineProperty: FuA,
    getOwnPropertyDescriptor: _i4,
    getOwnPropertyNames: ki4
  } = Object, yi4 = Object.prototype.hasOwnProperty, L5 = (A, Q) => FuA(A, "name", {
    value: Q,
    configurable: !0
  }), xi4 = (A, Q) => {
    for (var B in Q) FuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vi4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ki4(Q))
        if (!yi4.call(A, Z) && Z !== B) FuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _i4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bi4 = (A) => vi4(FuA({}, "__esModule", {
    value: !0
  }), A), fKQ = {};
  xi4(fKQ, {
    GetRoleCredentialsCommand: () => ADQ,
    GetRoleCredentialsRequestFilterSensitiveLog: () => dKQ,
    GetRoleCredentialsResponseFilterSensitiveLog: () => pKQ,
    InvalidRequestException: () => hKQ,
    ListAccountRolesCommand: () => pL1,
    ListAccountRolesRequestFilterSensitiveLog: () => lKQ,
    ListAccountsCommand: () => lL1,
    ListAccountsRequestFilterSensitiveLog: () => iKQ,
    LogoutCommand: () => QDQ,
    LogoutRequestFilterSensitiveLog: () => nKQ,
    ResourceNotFoundException: () => gKQ,
    RoleCredentialsFilterSensitiveLog: () => cKQ,
    SSO: () => BDQ,
    SSOClient: () => DuA,
    SSOServiceException: () => u8A,
    TooManyRequestsException: () => uKQ,
    UnauthorizedException: () => mKQ,
    __Client: () => V2.Client,
    paginateListAccountRoles: () => Wn4,
    paginateListAccounts: () => Xn4
  });
  GDQ.exports = bi4(fKQ);
  var _KQ = MHA(),
    fi4 = OHA(),
    hi4 = RHA(),
    kKQ = b8A(),
    gi4 = f8(),
    iv = iB(),
    ui4 = LX(),
    bHA = q5(),
    yKQ = D6(),
    xKQ = gL1(),
    mi4 = L5((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal"
      })
    }, "resolveClientEndpointParameters"),
    KuA = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    di4 = MKQ(),
    vKQ = xHA(),
    bKQ = iz(),
    V2 = r6(),
    ci4 = L5((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    pi4 = L5((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    li4 = L5((A, Q) => {
      let B = Object.assign((0, vKQ.getAwsRegionExtensionConfiguration)(A), (0, V2.getDefaultExtensionConfiguration)(A), (0, bKQ.getHttpHandlerExtensionConfiguration)(A), ci4(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, vKQ.resolveAwsRegionExtensionConfiguration)(B), (0, V2.resolveDefaultRuntimeConfig)(B), (0, bKQ.resolveHttpHandlerRuntimeConfig)(B), pi4(B))
    }, "resolveRuntimeExtensions"),
    DuA = class extends V2.Client {
      static {
        L5(this, "SSOClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, di4.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = mi4(Q),
          G = (0, kKQ.resolveUserAgentConfig)(B),
          Z = (0, yKQ.resolveRetryConfig)(G),
          I = (0, gi4.resolveRegionConfig)(Z),
          Y = (0, _KQ.resolveHostHeaderConfig)(I),
          J = (0, bHA.resolveEndpointConfig)(Y),
          W = (0, xKQ.resolveHttpAuthSchemeConfig)(J),
          X = li4(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, kKQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, yKQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, ui4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, _KQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, fi4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, hi4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, iv.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: xKQ.defaultSSOHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: L5(async (V) => new iv.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, iv.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    HuA = GZ(),
    u8A = class A extends V2.ServiceException {
      static {
        L5(this, "SSOServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    hKQ = class A extends u8A {
      static {
        L5(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    gKQ = class A extends u8A {
      static {
        L5(this, "ResourceNotFoundException")
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    uKQ = class A extends u8A {
      static {
        L5(this, "TooManyRequestsException")
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    mKQ = class A extends u8A {
      static {
        L5(this, "UnauthorizedException")
      }
      name = "UnauthorizedException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    dKQ = L5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: V2.SENSITIVE_STRING
      }
    }), "GetRoleCredentialsRequestFilterSensitiveLog"),
    cKQ = L5((A) => ({
      ...A,
      ...A.secretAccessKey && {
        secretAccessKey: V2.SENSITIVE_STRING
      },
      ...A.sessionToken && {
        sessionToken: V2.SENSITIVE_STRING
      }
    }), "RoleCredentialsFilterSensitiveLog"),
    pKQ = L5((A) => ({
      ...A,
      ...A.roleCredentials && {
        roleCredentials: cKQ(A.roleCredentials)
      }
    }), "GetRoleCredentialsResponseFilterSensitiveLog"),
    lKQ = L5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: V2.SENSITIVE_STRING
      }
    }), "ListAccountRolesRequestFilterSensitiveLog"),
    iKQ = L5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: V2.SENSITIVE_STRING
      }
    }), "ListAccountsRequestFilterSensitiveLog"),
    nKQ = L5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: V2.SENSITIVE_STRING
      }
    }), "LogoutRequestFilterSensitiveLog"),
    vHA = TF(),
    ii4 = L5(async (A, Q) => {
      let B = (0, iv.requestBuilder)(A, Q),
        G = (0, V2.map)({}, V2.isSerializableHeaderValue, {
          [zuA]: A[EuA]
        });
      B.bp("/federation/credentials");
      let Z = (0, V2.map)({
          [Yn4]: [, (0, V2.expectNonNull)(A[In4], "roleName")],
          [sKQ]: [, (0, V2.expectNonNull)(A[aKQ], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_GetRoleCredentialsCommand"),
    ni4 = L5(async (A, Q) => {
      let B = (0, iv.requestBuilder)(A, Q),
        G = (0, V2.map)({}, V2.isSerializableHeaderValue, {
          [zuA]: A[EuA]
        });
      B.bp("/assignment/roles");
      let Z = (0, V2.map)({
          [eKQ]: [, A[tKQ]],
          [oKQ]: [() => A.maxResults !== void 0, () => A[rKQ].toString()],
          [sKQ]: [, (0, V2.expectNonNull)(A[aKQ], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountRolesCommand"),
    ai4 = L5(async (A, Q) => {
      let B = (0, iv.requestBuilder)(A, Q),
        G = (0, V2.map)({}, V2.isSerializableHeaderValue, {
          [zuA]: A[EuA]
        });
      B.bp("/assignment/accounts");
      let Z = (0, V2.map)({
          [eKQ]: [, A[tKQ]],
          [oKQ]: [() => A.maxResults !== void 0, () => A[rKQ].toString()]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountsCommand"),
    si4 = L5(async (A, Q) => {
      let B = (0, iv.requestBuilder)(A, Q),
        G = (0, V2.map)({}, V2.isSerializableHeaderValue, {
          [zuA]: A[EuA]
        });
      B.bp("/logout");
      let Z;
      return B.m("POST").h(G).b(Z), B.build()
    }, "se_LogoutCommand"),
    ri4 = L5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return CuA(A, Q);
      let B = (0, V2.map)({
          $metadata: Sd(A)
        }),
        G = (0, V2.expectNonNull)((0, V2.expectObject)(await (0, vHA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, V2.take)(G, {
          roleCredentials: V2._json
        });
      return Object.assign(B, Z), B
    }, "de_GetRoleCredentialsCommand"),
    oi4 = L5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return CuA(A, Q);
      let B = (0, V2.map)({
          $metadata: Sd(A)
        }),
        G = (0, V2.expectNonNull)((0, V2.expectObject)(await (0, vHA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, V2.take)(G, {
          nextToken: V2.expectString,
          roleList: V2._json
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountRolesCommand"),
    ti4 = L5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return CuA(A, Q);
      let B = (0, V2.map)({
          $metadata: Sd(A)
        }),
        G = (0, V2.expectNonNull)((0, V2.expectObject)(await (0, vHA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, V2.take)(G, {
          accountList: V2._json,
          nextToken: V2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountsCommand"),
    ei4 = L5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return CuA(A, Q);
      let B = (0, V2.map)({
        $metadata: Sd(A)
      });
      return await (0, V2.collectBody)(A.body, Q), B
    }, "de_LogoutCommand"),
    CuA = L5(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, vHA.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, vHA.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await Qn4(B, Q);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await Bn4(B, Q);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await Gn4(B, Q);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await Zn4(B, Q);
        default:
          let Z = B.body;
          return An4({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    An4 = (0, V2.withBaseException)(u8A),
    Qn4 = L5(async (A, Q) => {
      let B = (0, V2.map)({}),
        G = A.body,
        Z = (0, V2.take)(G, {
          message: V2.expectString
        });
      Object.assign(B, Z);
      let I = new hKQ({
        $metadata: Sd(A),
        ...B
      });
      return (0, V2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    Bn4 = L5(async (A, Q) => {
      let B = (0, V2.map)({}),
        G = A.body,
        Z = (0, V2.take)(G, {
          message: V2.expectString
        });
      Object.assign(B, Z);
      let I = new gKQ({
        $metadata: Sd(A),
        ...B
      });
      return (0, V2.decorateServiceException)(I, A.body)
    }, "de_ResourceNotFoundExceptionRes"),
    Gn4 = L5(async (A, Q) => {
      let B = (0, V2.map)({}),
        G = A.body,
        Z = (0, V2.take)(G, {
          message: V2.expectString
        });
      Object.assign(B, Z);
      let I = new uKQ({
        $metadata: Sd(A),
        ...B
      });
      return (0, V2.decorateServiceException)(I, A.body)
    }, "de_TooManyRequestsExceptionRes"),
    Zn4 = L5(async (A, Q) => {
      let B = (0, V2.map)({}),
        G = A.body,
        Z = (0, V2.take)(G, {
          message: V2.expectString
        });
      Object.assign(B, Z);
      let I = new mKQ({
        $metadata: Sd(A),
        ...B
      });
      return (0, V2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedExceptionRes"),
    Sd = L5((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    aKQ = "accountId",
    EuA = "accessToken",
    sKQ = "account_id",
    rKQ = "maxResults",
    oKQ = "max_result",
    tKQ = "nextToken",
    eKQ = "next_token",
    In4 = "roleName",
    Yn4 = "role_name",
    zuA = "x-amz-sso_bearer_token",
    ADQ = class extends V2.Command.classBuilder().ep(KuA).m(function(A, Q, B, G) {
      return [(0, HuA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, bHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(dKQ, pKQ).ser(ii4).de(ri4).build() {
      static {
        L5(this, "GetRoleCredentialsCommand")
      }
    },
    pL1 = class extends V2.Command.classBuilder().ep(KuA).m(function(A, Q, B, G) {
      return [(0, HuA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, bHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(lKQ, void 0).ser(ni4).de(oi4).build() {
      static {
        L5(this, "ListAccountRolesCommand")
      }
    },
    lL1 = class extends V2.Command.classBuilder().ep(KuA).m(function(A, Q, B, G) {
      return [(0, HuA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, bHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(iKQ, void 0).ser(ai4).de(ti4).build() {
      static {
        L5(this, "ListAccountsCommand")
      }
    },
    QDQ = class extends V2.Command.classBuilder().ep(KuA).m(function(A, Q, B, G) {
      return [(0, HuA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, bHA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(nKQ, void 0).ser(si4).de(ei4).build() {
      static {
        L5(this, "LogoutCommand")
      }
    },
    Jn4 = {
      GetRoleCredentialsCommand: ADQ,
      ListAccountRolesCommand: pL1,
      ListAccountsCommand: lL1,
      LogoutCommand: QDQ
    },
    BDQ = class extends DuA {
      static {
        L5(this, "SSO")
      }
    };
  (0, V2.createAggregatedClient)(Jn4, BDQ);
  var Wn4 = (0, iv.createPaginator)(DuA, pL1, "nextToken", "nextToken", "maxResults"),
    Xn4 = (0, iv.createPaginator)(DuA, lL1, "nextToken", "nextToken", "maxResults")
})
// @from(Start 3139775, End 3141246)
nL1 = z((IDQ) => {
  Object.defineProperty(IDQ, "__esModule", {
    value: !0
  });
  IDQ.resolveHttpAuthSchemeConfig = IDQ.defaultSSOOIDCHttpAuthSchemeProvider = IDQ.defaultSSOOIDCHttpAuthSchemeParametersProvider = void 0;
  var Vn4 = TF(),
    iL1 = w7(),
    Fn4 = async (A, Q, B) => {
      return {
        operation: (0, iL1.getSmithyContext)(Q).operation,
        region: await (0, iL1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  IDQ.defaultSSOOIDCHttpAuthSchemeParametersProvider = Fn4;

  function Kn4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function Dn4(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var Hn4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "CreateToken": {
        Q.push(Dn4(A));
        break
      }
      default:
        Q.push(Kn4(A))
    }
    return Q
  };
  IDQ.defaultSSOOIDCHttpAuthSchemeProvider = Hn4;
  var Cn4 = (A) => {
    let Q = (0, Vn4.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, iL1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  IDQ.resolveHttpAuthSchemeConfig = Cn4
})
// @from(Start 3141252, End 3145537)
aL1 = z((Sw7, Un4) => {
  Un4.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.840.0",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=18.0.0"
    },
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["./sso-oidc.d.ts", "./sso-oidc.js", "./sts.d.ts", "./sts.js", "dist-*/**"],
    browser: {
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./sso-oidc": {
        types: "./dist-types/submodules/sso-oidc/index.d.ts",
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js"
      },
      "./sts": {
        types: "./dist-types/submodules/sts/index.d.ts",
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js"
      }
    }
  }
})
// @from(Start 3145543, End 3150210)
LDQ = z((qDQ) => {
  Object.defineProperty(qDQ, "__esModule", {
    value: !0
  });
  qDQ.ruleSet = void 0;
  var zDQ = "required",
    wL = "fn",
    qL = "argv",
    c8A = "ref",
    JDQ = !0,
    WDQ = "isSet",
    fHA = "booleanEquals",
    m8A = "error",
    d8A = "endpoint",
    av = "tree",
    sL1 = "PartitionResult",
    rL1 = "getAttr",
    XDQ = {
      [zDQ]: !1,
      type: "String"
    },
    VDQ = {
      [zDQ]: !0,
      default: !1,
      type: "Boolean"
    },
    FDQ = {
      [c8A]: "Endpoint"
    },
    UDQ = {
      [wL]: fHA,
      [qL]: [{
        [c8A]: "UseFIPS"
      }, !0]
    },
    $DQ = {
      [wL]: fHA,
      [qL]: [{
        [c8A]: "UseDualStack"
      }, !0]
    },
    $L = {},
    KDQ = {
      [wL]: rL1,
      [qL]: [{
        [c8A]: sL1
      }, "supportsFIPS"]
    },
    wDQ = {
      [c8A]: sL1
    },
    DDQ = {
      [wL]: fHA,
      [qL]: [!0, {
        [wL]: rL1,
        [qL]: [wDQ, "supportsDualStack"]
      }]
    },
    HDQ = [UDQ],
    CDQ = [$DQ],
    EDQ = [{
      [c8A]: "Region"
    }],
    $n4 = {
      version: "1.0",
      parameters: {
        Region: XDQ,
        UseDualStack: VDQ,
        UseFIPS: VDQ,
        Endpoint: XDQ
      },
      rules: [{
        conditions: [{
          [wL]: WDQ,
          [qL]: [FDQ]
        }],
        rules: [{
          conditions: HDQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: m8A
        }, {
          conditions: CDQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: m8A
        }, {
          endpoint: {
            url: FDQ,
            properties: $L,
            headers: $L
          },
          type: d8A
        }],
        type: av
      }, {
        conditions: [{
          [wL]: WDQ,
          [qL]: EDQ
        }],
        rules: [{
          conditions: [{
            [wL]: "aws.partition",
            [qL]: EDQ,
            assign: sL1
          }],
          rules: [{
            conditions: [UDQ, $DQ],
            rules: [{
              conditions: [{
                [wL]: fHA,
                [qL]: [JDQ, KDQ]
              }, DDQ],
              rules: [{
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: $L,
                  headers: $L
                },
                type: d8A
              }],
              type: av
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: m8A
            }],
            type: av
          }, {
            conditions: HDQ,
            rules: [{
              conditions: [{
                [wL]: fHA,
                [qL]: [KDQ, JDQ]
              }],
              rules: [{
                conditions: [{
                  [wL]: "stringEquals",
                  [qL]: [{
                    [wL]: rL1,
                    [qL]: [wDQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://oidc.{Region}.amazonaws.com",
                  properties: $L,
                  headers: $L
                },
                type: d8A
              }, {
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: $L,
                  headers: $L
                },
                type: d8A
              }],
              type: av
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: m8A
            }],
            type: av
          }, {
            conditions: CDQ,
            rules: [{
              conditions: [DDQ],
              rules: [{
                endpoint: {
                  url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: $L,
                  headers: $L
                },
                type: d8A
              }],
              type: av
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: m8A
            }],
            type: av
          }, {
            endpoint: {
              url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
              properties: $L,
              headers: $L
            },
            type: d8A
          }],
          type: av
        }],
        type: av
      }, {
        error: "Invalid Configuration: Missing Region",
        type: m8A
      }]
    };
  qDQ.ruleSet = $n4
})
// @from(Start 3150216, End 3150780)
RDQ = z((MDQ) => {
  Object.defineProperty(MDQ, "__esModule", {
    value: !0
  });
  MDQ.defaultEndpointResolver = void 0;
  var wn4 = S8A(),
    oL1 = FI(),
    qn4 = LDQ(),
    Nn4 = new oL1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    Ln4 = (A, Q = {}) => {
      return Nn4.get(A, () => (0, oL1.resolveEndpoint)(qn4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  MDQ.defaultEndpointResolver = Ln4;
  oL1.customEndpointFunctions.aws = wn4.awsEndpointFunctions
})
// @from(Start 3150786, End 3152204)
_DQ = z((jDQ) => {
  Object.defineProperty(jDQ, "__esModule", {
    value: !0
  });
  jDQ.getRuntimeConfig = void 0;
  var Mn4 = TF(),
    On4 = iB(),
    Rn4 = r6(),
    Tn4 = NJ(),
    TDQ = Pd(),
    PDQ = O2(),
    Pn4 = nL1(),
    jn4 = RDQ(),
    Sn4 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? TDQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? TDQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? jn4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Pn4.defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Mn4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new On4.NoAuthSigner
        }],
        logger: A?.logger ?? new Rn4.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO OIDC",
        urlParser: A?.urlParser ?? Tn4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? PDQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? PDQ.toUtf8
      }
    };
  jDQ.getRuntimeConfig = Sn4
})
// @from(Start 3152210, End 3154509)
hDQ = z((bDQ) => {
  Object.defineProperty(bDQ, "__esModule", {
    value: !0
  });
  bDQ.getRuntimeConfig = void 0;
  var _n4 = rr(),
    kn4 = _n4.__importDefault(aL1()),
    kDQ = TF(),
    yDQ = kHA(),
    UuA = f8(),
    yn4 = RX(),
    xDQ = D6(),
    Qo = uI(),
    vDQ = IZ(),
    xn4 = TX(),
    vn4 = KW(),
    bn4 = _DQ(),
    fn4 = r6(),
    hn4 = PX(),
    gn4 = r6(),
    un4 = (A) => {
      (0, gn4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, hn4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(fn4.loadConfigsForDefaultMode),
        G = (0, bn4.getRuntimeConfig)(A);
      (0, kDQ.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Qo.loadConfig)(kDQ.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? xn4.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, yDQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: kn4.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, Qo.loadConfig)(xDQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Qo.loadConfig)(UuA.NODE_REGION_CONFIG_OPTIONS, {
          ...UuA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: vDQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Qo.loadConfig)({
          ...xDQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || vn4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? yn4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? vDQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Qo.loadConfig)(UuA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Qo.loadConfig)(UuA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Qo.loadConfig)(yDQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  bDQ.getRuntimeConfig = un4
})
// @from(Start 3154515, End 3174342)
AM1 = z((vw7, FHQ) => {
  var {
    defineProperty: $uA,
    getOwnPropertyDescriptor: mn4,
    getOwnPropertyNames: dn4
  } = Object, cn4 = Object.prototype.hasOwnProperty, R6 = (A, Q) => $uA(A, "name", {
    value: Q,
    configurable: !0
  }), pn4 = (A, Q) => {
    for (var B in Q) $uA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ln4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of dn4(Q))
        if (!cn4.call(A, Z) && Z !== B) $uA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = mn4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, in4 = (A) => ln4($uA({}, "__esModule", {
    value: !0
  }), A), iDQ = {};
  pn4(iDQ, {
    $Command: () => sDQ.Command,
    AccessDeniedException: () => rDQ,
    AuthorizationPendingException: () => oDQ,
    CreateTokenCommand: () => XHQ,
    CreateTokenRequestFilterSensitiveLog: () => tDQ,
    CreateTokenResponseFilterSensitiveLog: () => eDQ,
    ExpiredTokenException: () => AHQ,
    InternalServerException: () => QHQ,
    InvalidClientException: () => BHQ,
    InvalidGrantException: () => GHQ,
    InvalidRequestException: () => ZHQ,
    InvalidScopeException: () => IHQ,
    SSOOIDC: () => VHQ,
    SSOOIDCClient: () => aDQ,
    SSOOIDCServiceException: () => Uw,
    SlowDownException: () => YHQ,
    UnauthorizedClientException: () => JHQ,
    UnsupportedGrantTypeException: () => WHQ,
    __Client: () => nDQ.Client
  });
  FHQ.exports = in4(iDQ);
  var gDQ = MHA(),
    nn4 = OHA(),
    an4 = RHA(),
    uDQ = b8A(),
    sn4 = f8(),
    tL1 = iB(),
    rn4 = LX(),
    on4 = q5(),
    mDQ = D6(),
    nDQ = r6(),
    dDQ = nL1(),
    tn4 = R6((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth"
      })
    }, "resolveClientEndpointParameters"),
    en4 = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    Aa4 = hDQ(),
    cDQ = xHA(),
    pDQ = iz(),
    lDQ = r6(),
    Qa4 = R6((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    Ba4 = R6((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    Ga4 = R6((A, Q) => {
      let B = Object.assign((0, cDQ.getAwsRegionExtensionConfiguration)(A), (0, lDQ.getDefaultExtensionConfiguration)(A), (0, pDQ.getHttpHandlerExtensionConfiguration)(A), Qa4(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, cDQ.resolveAwsRegionExtensionConfiguration)(B), (0, lDQ.resolveDefaultRuntimeConfig)(B), (0, pDQ.resolveHttpHandlerRuntimeConfig)(B), Ba4(B))
    }, "resolveRuntimeExtensions"),
    aDQ = class extends nDQ.Client {
      static {
        R6(this, "SSOOIDCClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, Aa4.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = tn4(Q),
          G = (0, uDQ.resolveUserAgentConfig)(B),
          Z = (0, mDQ.resolveRetryConfig)(G),
          I = (0, sn4.resolveRegionConfig)(Z),
          Y = (0, gDQ.resolveHostHeaderConfig)(I),
          J = (0, on4.resolveEndpointConfig)(Y),
          W = (0, dDQ.resolveHttpAuthSchemeConfig)(J),
          X = Ga4(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, uDQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, mDQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, rn4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, gDQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, nn4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, an4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, tL1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: dDQ.defaultSSOOIDCHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: R6(async (V) => new tL1.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, tL1.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    Za4 = r6(),
    Ia4 = q5(),
    Ya4 = GZ(),
    sDQ = r6(),
    p8A = r6(),
    Ja4 = r6(),
    Uw = class A extends Ja4.ServiceException {
      static {
        R6(this, "SSOOIDCServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    rDQ = class A extends Uw {
      static {
        R6(this, "AccessDeniedException")
      }
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    oDQ = class A extends Uw {
      static {
        R6(this, "AuthorizationPendingException")
      }
      name = "AuthorizationPendingException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    tDQ = R6((A) => ({
      ...A,
      ...A.clientSecret && {
        clientSecret: p8A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: p8A.SENSITIVE_STRING
      },
      ...A.codeVerifier && {
        codeVerifier: p8A.SENSITIVE_STRING
      }
    }), "CreateTokenRequestFilterSensitiveLog"),
    eDQ = R6((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: p8A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: p8A.SENSITIVE_STRING
      },
      ...A.idToken && {
        idToken: p8A.SENSITIVE_STRING
      }
    }), "CreateTokenResponseFilterSensitiveLog"),
    AHQ = class A extends Uw {
      static {
        R6(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    QHQ = class A extends Uw {
      static {
        R6(this, "InternalServerException")
      }
      name = "InternalServerException";
      $fault = "server";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    BHQ = class A extends Uw {
      static {
        R6(this, "InvalidClientException")
      }
      name = "InvalidClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    GHQ = class A extends Uw {
      static {
        R6(this, "InvalidGrantException")
      }
      name = "InvalidGrantException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    ZHQ = class A extends Uw {
      static {
        R6(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    IHQ = class A extends Uw {
      static {
        R6(this, "InvalidScopeException")
      }
      name = "InvalidScopeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    YHQ = class A extends Uw {
      static {
        R6(this, "SlowDownException")
      }
      name = "SlowDownException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    JHQ = class A extends Uw {
      static {
        R6(this, "UnauthorizedClientException")
      }
      name = "UnauthorizedClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    WHQ = class A extends Uw {
      static {
        R6(this, "UnsupportedGrantTypeException")
      }
      name = "UnsupportedGrantTypeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    eL1 = TF(),
    Wa4 = iB(),
    G2 = r6(),
    Xa4 = R6(async (A, Q) => {
      let B = (0, Wa4.requestBuilder)(A, Q),
        G = {
          "content-type": "application/json"
        };
      B.bp("/token");
      let Z;
      return Z = JSON.stringify((0, G2.take)(A, {
        clientId: [],
        clientSecret: [],
        code: [],
        codeVerifier: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: R6((I) => (0, G2._json)(I), "scope")
      })), B.m("POST").h(G).b(Z), B.build()
    }, "se_CreateTokenCommand"),
    Va4 = R6(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return Fa4(A, Q);
      let B = (0, G2.map)({
          $metadata: NL(A)
        }),
        G = (0, G2.expectNonNull)((0, G2.expectObject)(await (0, eL1.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, G2.take)(G, {
          accessToken: G2.expectString,
          expiresIn: G2.expectInt32,
          idToken: G2.expectString,
          refreshToken: G2.expectString,
          tokenType: G2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_CreateTokenCommand"),
    Fa4 = R6(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, eL1.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, eL1.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
          throw await Da4(B, Q);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
          throw await Ha4(B, Q);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
          throw await Ca4(B, Q);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
          throw await Ea4(B, Q);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
          throw await za4(B, Q);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
          throw await Ua4(B, Q);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
          throw await $a4(B, Q);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
          throw await wa4(B, Q);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
          throw await qa4(B, Q);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
          throw await Na4(B, Q);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
          throw await La4(B, Q);
        default:
          let Z = B.body;
          return Ka4({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    Ka4 = (0, G2.withBaseException)(Uw),
    Da4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new rDQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_AccessDeniedExceptionRes"),
    Ha4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new oDQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_AuthorizationPendingExceptionRes"),
    Ca4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new AHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_ExpiredTokenExceptionRes"),
    Ea4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new QHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_InternalServerExceptionRes"),
    za4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new BHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_InvalidClientExceptionRes"),
    Ua4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new GHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_InvalidGrantExceptionRes"),
    $a4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new ZHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    wa4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new IHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_InvalidScopeExceptionRes"),
    qa4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new YHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_SlowDownExceptionRes"),
    Na4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new JHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedClientExceptionRes"),
    La4 = R6(async (A, Q) => {
      let B = (0, G2.map)({}),
        G = A.body,
        Z = (0, G2.take)(G, {
          error: G2.expectString,
          error_description: G2.expectString
        });
      Object.assign(B, Z);
      let I = new WHQ({
        $metadata: NL(A),
        ...B
      });
      return (0, G2.decorateServiceException)(I, A.body)
    }, "de_UnsupportedGrantTypeExceptionRes"),
    NL = R6((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    XHQ = class extends sDQ.Command.classBuilder().ep(en4).m(function(A, Q, B, G) {
      return [(0, Ya4.getSerdePlugin)(B, this.serialize, this.deserialize), (0, Ia4.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(tDQ, eDQ).ser(Xa4).de(Va4).build() {
      static {
        R6(this, "CreateTokenCommand")
      }
    },
    Ma4 = {
      CreateTokenCommand: XHQ
    },
    VHQ = class extends aDQ {
      static {
        R6(this, "SSOOIDC")
      }
    };
  (0, Za4.createAggregatedClient)(Ma4, VHQ)
})
// @from(Start 3174348, End 3180517)
$HQ = z((gw7, UHQ) => {
  var {
    create: Oa4,
    defineProperty: gHA,
    getOwnPropertyDescriptor: Ra4,
    getOwnPropertyNames: Ta4,
    getPrototypeOf: Pa4
  } = Object, ja4 = Object.prototype.hasOwnProperty, sv = (A, Q) => gHA(A, "name", {
    value: Q,
    configurable: !0
  }), Sa4 = (A, Q) => {
    for (var B in Q) gHA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, HHQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Ta4(Q))
        if (!ja4.call(A, Z) && Z !== B) gHA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Ra4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, CHQ = (A, Q, B) => (B = A != null ? Oa4(Pa4(A)) : {}, HHQ(Q || !A || !A.__esModule ? gHA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), _a4 = (A) => HHQ(gHA({}, "__esModule", {
    value: !0
  }), A), EHQ = {};
  Sa4(EHQ, {
    fromEnvSigningName: () => xa4,
    fromSso: () => zHQ,
    fromStatic: () => ma4,
    nodeProvider: () => da4
  });
  UHQ.exports = _a4(EHQ);
  var ka4 = lR(),
    ya4 = VL1(),
    $w = j2(),
    xa4 = sv(({
      logger: A,
      signingName: Q
    } = {}) => async () => {
      if (A?.debug?.("@aws-sdk/token-providers - fromEnvSigningName"), !Q) throw new $w.TokenProviderError("Please pass 'signingName' to compute environment variable key", {
        logger: A
      });
      let B = (0, ya4.getBearerTokenEnvKey)(Q);
      if (!(B in process.env)) throw new $w.TokenProviderError(`Token not present in '${B}' environment variable`, {
        logger: A
      });
      let G = {
        token: process.env[B]
      };
      return (0, ka4.setTokenFeature)(G, "BEARER_SERVICE_ENV_VARS", "3"), G
    }, "fromEnvSigningName"),
    va4 = 300000,
    QM1 = "To refresh this SSO session run 'aws sso login' with the corresponding profile.",
    ba4 = sv(async (A, Q = {}) => {
      let {
        SSOOIDCClient: B
      } = await Promise.resolve().then(() => CHQ(AM1()));
      return new B(Object.assign({}, Q.clientConfig ?? {}, {
        region: A ?? Q.clientConfig?.region,
        logger: Q.clientConfig?.logger ?? Q.parentClientConfig?.logger
      }))
    }, "getSsoOidcClient"),
    fa4 = sv(async (A, Q, B = {}) => {
      let {
        CreateTokenCommand: G
      } = await Promise.resolve().then(() => CHQ(AM1()));
      return (await ba4(Q, B)).send(new G({
        clientId: A.clientId,
        clientSecret: A.clientSecret,
        refreshToken: A.refreshToken,
        grantType: "refresh_token"
      }))
    }, "getNewSsoOidcToken"),
    KHQ = sv((A) => {
      if (A.expiration && A.expiration.getTime() < Date.now()) throw new $w.TokenProviderError(`Token is expired. ${QM1}`, !1)
    }, "validateTokenExpiry"),
    Bo = sv((A, Q, B = !1) => {
      if (typeof Q > "u") throw new $w.TokenProviderError(`Value not present for '${A}' in SSO Token${B?". Cannot refresh":""}. ${QM1}`, !1)
    }, "validateTokenKey"),
    hHA = SG(),
    ha4 = UA("fs"),
    {
      writeFile: ga4
    } = ha4.promises,
    ua4 = sv((A, Q) => {
      let B = (0, hHA.getSSOTokenFilepath)(A),
        G = JSON.stringify(Q, null, 2);
      return ga4(B, G)
    }, "writeSSOTokenToFile"),
    DHQ = new Date(0),
    zHQ = sv((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/token-providers - fromSso");
      let G = await (0, hHA.parseKnownFiles)(B),
        Z = (0, hHA.getProfileName)({
          profile: B.profile ?? Q?.profile
        }),
        I = G[Z];
      if (!I) throw new $w.TokenProviderError(`Profile '${Z}' could not be found in shared credentials file.`, !1);
      else if (!I.sso_session) throw new $w.TokenProviderError(`Profile '${Z}' is missing required property 'sso_session'.`);
      let Y = I.sso_session,
        W = (await (0, hHA.loadSsoSessionData)(B))[Y];
      if (!W) throw new $w.TokenProviderError(`Sso session '${Y}' could not be found in shared credentials file.`, !1);
      for (let C of ["sso_start_url", "sso_region"])
        if (!W[C]) throw new $w.TokenProviderError(`Sso session '${Y}' is missing required property '${C}'.`, !1);
      let {
        sso_start_url: X,
        sso_region: V
      } = W, F;
      try {
        F = await (0, hHA.getSSOTokenFromFile)(Y)
      } catch (C) {
        throw new $w.TokenProviderError(`The SSO session token associated with profile=${Z} was not found or is invalid. ${QM1}`, !1)
      }
      Bo("accessToken", F.accessToken), Bo("expiresAt", F.expiresAt);
      let {
        accessToken: K,
        expiresAt: D
      } = F, H = {
        token: K,
        expiration: new Date(D)
      };
      if (H.expiration.getTime() - Date.now() > va4) return H;
      if (Date.now() - DHQ.getTime() < 30000) return KHQ(H), H;
      Bo("clientId", F.clientId, !0), Bo("clientSecret", F.clientSecret, !0), Bo("refreshToken", F.refreshToken, !0);
      try {
        DHQ.setTime(Date.now());
        let C = await fa4(F, V, B);
        Bo("accessToken", C.accessToken), Bo("expiresIn", C.expiresIn);
        let E = new Date(Date.now() + C.expiresIn * 1000);
        try {
          await ua4(Y, {
            ...F,
            accessToken: C.accessToken,
            expiresAt: E.toISOString(),
            refreshToken: C.refreshToken
          })
        } catch (U) {}
        return {
          token: C.accessToken,
          expiration: E
        }
      } catch (C) {
        return KHQ(H), H
      }
    }, "fromSso"),
    ma4 = sv(({
      token: A,
      logger: Q
    }) => async () => {
      if (Q?.debug("@aws-sdk/token-providers - fromStatic"), !A || !A.token) throw new $w.TokenProviderError("Please pass a valid token to fromStatic", !1);
      return A
    }, "fromStatic"),
    da4 = sv((A = {}) => (0, $w.memoize)((0, $w.chain)(zHQ(A), async () => {
      throw new $w.TokenProviderError("Could not load token from any providers", !1)
    }), (Q) => Q.expiration !== void 0 && Q.expiration.getTime() - Date.now() < 300000, (Q) => Q.expiration !== void 0), "nodeProvider")
})
// @from(Start 3180523, End 3187765)
GM1 = z((uw7, PHQ) => {
  var {
    defineProperty: quA,
    getOwnPropertyDescriptor: ca4,
    getOwnPropertyNames: NHQ
  } = Object, pa4 = Object.prototype.hasOwnProperty, NuA = (A, Q) => quA(A, "name", {
    value: Q,
    configurable: !0
  }), la4 = (A, Q) => function() {
    return A && (Q = (0, A[NHQ(A)[0]])(A = 0)), Q
  }, LHQ = (A, Q) => {
    for (var B in Q) quA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ia4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of NHQ(Q))
        if (!pa4.call(A, Z) && Z !== B) quA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = ca4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, na4 = (A) => ia4(quA({}, "__esModule", {
    value: !0
  }), A), MHQ = {};
  LHQ(MHQ, {
    GetRoleCredentialsCommand: () => BM1.GetRoleCredentialsCommand,
    SSOClient: () => BM1.SSOClient
  });
  var BM1, aa4 = la4({
      "src/loadSso.ts"() {
        BM1 = ZDQ()
      }
    }),
    OHQ = {};
  LHQ(OHQ, {
    fromSSO: () => ra4,
    isSsoProfile: () => RHQ,
    validateSsoProfile: () => THQ
  });
  PHQ.exports = na4(OHQ);
  var RHQ = NuA((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    wHQ = lR(),
    sa4 = $HQ(),
    iR = j2(),
    wuA = SG(),
    uHA = !1,
    qHQ = NuA(async ({
      ssoStartUrl: A,
      ssoSession: Q,
      ssoAccountId: B,
      ssoRegion: G,
      ssoRoleName: Z,
      ssoClient: I,
      clientConfig: Y,
      parentClientConfig: J,
      profile: W,
      logger: X
    }) => {
      let V, F = "To refresh this SSO session run aws sso login with the corresponding profile.";
      if (Q) try {
        let v = await (0, sa4.fromSso)({
          profile: W
        })();
        V = {
          accessToken: v.token,
          expiresAt: new Date(v.expiration).toISOString()
        }
      } catch (v) {
        throw new iR.CredentialsProviderError(v.message, {
          tryNextLink: uHA,
          logger: X
        })
      } else try {
        V = await (0, wuA.getSSOTokenFromFile)(A)
      } catch (v) {
        throw new iR.CredentialsProviderError("The SSO session associated with this profile is invalid. To refresh this SSO session run aws sso login with the corresponding profile.", {
          tryNextLink: uHA,
          logger: X
        })
      }
      if (new Date(V.expiresAt).getTime() - Date.now() <= 0) throw new iR.CredentialsProviderError("The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile.", {
        tryNextLink: uHA,
        logger: X
      });
      let {
        accessToken: K
      } = V, {
        SSOClient: D,
        GetRoleCredentialsCommand: H
      } = await Promise.resolve().then(() => (aa4(), MHQ)), C = I || new D(Object.assign({}, Y ?? {}, {
        logger: Y?.logger ?? J?.logger,
        region: Y?.region ?? G
      })), E;
      try {
        E = await C.send(new H({
          accountId: B,
          roleName: Z,
          accessToken: K
        }))
      } catch (v) {
        throw new iR.CredentialsProviderError(v, {
          tryNextLink: uHA,
          logger: X
        })
      }
      let {
        roleCredentials: {
          accessKeyId: U,
          secretAccessKey: q,
          sessionToken: w,
          expiration: N,
          credentialScope: R,
          accountId: T
        } = {}
      } = E;
      if (!U || !q || !w || !N) throw new iR.CredentialsProviderError("SSO returns an invalid temporary credential.", {
        tryNextLink: uHA,
        logger: X
      });
      let y = {
        accessKeyId: U,
        secretAccessKey: q,
        sessionToken: w,
        expiration: new Date(N),
        ...R && {
          credentialScope: R
        },
        ...T && {
          accountId: T
        }
      };
      if (Q)(0, wHQ.setCredentialFeature)(y, "CREDENTIALS_SSO", "s");
      else(0, wHQ.setCredentialFeature)(y, "CREDENTIALS_SSO_LEGACY", "u");
      return y
    }, "resolveSSOCredentials"),
    THQ = NuA((A, Q) => {
      let {
        sso_start_url: B,
        sso_account_id: G,
        sso_region: Z,
        sso_role_name: I
      } = A;
      if (!B || !G || !Z || !I) throw new iR.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(A).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, {
        tryNextLink: !1,
        logger: Q
      });
      return A
    }, "validateSsoProfile"),
    ra4 = NuA((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
      let {
        ssoStartUrl: B,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoSession: Y
      } = A, {
        ssoClient: J
      } = A, W = (0, wuA.getProfileName)({
        profile: A.profile ?? Q?.profile
      });
      if (!B && !G && !Z && !I && !Y) {
        let V = (await (0, wuA.parseKnownFiles)(A))[W];
        if (!V) throw new iR.CredentialsProviderError(`Profile ${W} was not found.`, {
          logger: A.logger
        });
        if (!RHQ(V)) throw new iR.CredentialsProviderError(`Profile ${W} is not configured with SSO credentials.`, {
          logger: A.logger
        });
        if (V?.sso_session) {
          let U = (await (0, wuA.loadSsoSessionData)(A))[V.sso_session],
            q = ` configurations in profile ${W} and sso-session ${V.sso_session}`;
          if (Z && Z !== U.sso_region) throw new iR.CredentialsProviderError("Conflicting SSO region" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          if (B && B !== U.sso_start_url) throw new iR.CredentialsProviderError("Conflicting SSO start_url" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          V.sso_region = U.sso_region, V.sso_start_url = U.sso_start_url
        }
        let {
          sso_start_url: F,
          sso_account_id: K,
          sso_region: D,
          sso_role_name: H,
          sso_session: C
        } = THQ(V, A.logger);
        return qHQ({
          ssoStartUrl: F,
          ssoSession: C,
          ssoAccountId: K,
          ssoRegion: D,
          ssoRoleName: H,
          ssoClient: J,
          clientConfig: A.clientConfig,
          parentClientConfig: A.parentClientConfig,
          profile: W
        })
      } else if (!B || !G || !Z || !I) throw new iR.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', {
        tryNextLink: !1,
        logger: A.logger
      });
      else return qHQ({
        ssoStartUrl: B,
        ssoSession: Y,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoClient: J,
        clientConfig: A.clientConfig,
        parentClientConfig: A.parentClientConfig,
        profile: W
      })
    }, "fromSSO")
})
// @from(Start 3187771, End 3189428)
IM1 = z((jHQ) => {
  Object.defineProperty(jHQ, "__esModule", {
    value: !0
  });
  jHQ.resolveHttpAuthSchemeConfig = jHQ.resolveStsAuthConfig = jHQ.defaultSTSHttpAuthSchemeProvider = jHQ.defaultSTSHttpAuthSchemeParametersProvider = void 0;
  var oa4 = TF(),
    ZM1 = w7(),
    ta4 = mHA(),
    ea4 = async (A, Q, B) => {
      return {
        operation: (0, ZM1.getSmithyContext)(Q).operation,
        region: await (0, ZM1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  jHQ.defaultSTSHttpAuthSchemeParametersProvider = ea4;

  function As4(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function Qs4(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var Bs4 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "AssumeRoleWithWebIdentity": {
        Q.push(Qs4(A));
        break
      }
      default:
        Q.push(As4(A))
    }
    return Q
  };
  jHQ.defaultSTSHttpAuthSchemeProvider = Bs4;
  var Gs4 = (A) => Object.assign(A, {
    stsClientCtor: ta4.STSClient
  });
  jHQ.resolveStsAuthConfig = Gs4;
  var Zs4 = (A) => {
    let Q = jHQ.resolveStsAuthConfig(A),
      B = (0, oa4.resolveAwsSdkSigV4Config)(Q);
    return Object.assign(B, {
      authSchemePreference: (0, ZM1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  jHQ.resolveHttpAuthSchemeConfig = Zs4
})
// @from(Start 3189434, End 3190322)
dHA = z((kHQ) => {
  Object.defineProperty(kHQ, "__esModule", {
    value: !0
  });
  kHQ.commonParams = kHQ.resolveClientEndpointParameters = void 0;
  var Js4 = (A) => {
    return Object.assign(A, {
      useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
      useFipsEndpoint: A.useFipsEndpoint ?? !1,
      useGlobalEndpoint: A.useGlobalEndpoint ?? !1,
      defaultSigningName: "sts"
    })
  };
  kHQ.resolveClientEndpointParameters = Js4;
  kHQ.commonParams = {
    UseGlobalEndpoint: {
      type: "builtInParams",
      name: "useGlobalEndpoint"
    },
    UseFIPS: {
      type: "builtInParams",
      name: "useFipsEndpoint"
    },
    Endpoint: {
      type: "builtInParams",
      name: "endpoint"
    },
    Region: {
      type: "builtInParams",
      name: "region"
    },
    UseDualStack: {
      type: "builtInParams",
      name: "useDualstackEndpoint"
    }
  }
})
// @from(Start 3190328, End 3198505)
GCQ = z((QCQ) => {
  Object.defineProperty(QCQ, "__esModule", {
    value: !0
  });
  QCQ.ruleSet = void 0;
  var lHQ = "required",
    u8 = "type",
    e3 = "fn",
    A7 = "argv",
    kd = "ref",
    xHQ = !1,
    YM1 = !0,
    _d = "booleanEquals",
    ID = "stringEquals",
    iHQ = "sigv4",
    nHQ = "sts",
    aHQ = "us-east-1",
    pI = "endpoint",
    vHQ = "https://sts.{Region}.{PartitionResult#dnsSuffix}",
    yS = "tree",
    l8A = "error",
    WM1 = "getAttr",
    bHQ = {
      [lHQ]: !1,
      [u8]: "String"
    },
    JM1 = {
      [lHQ]: !0,
      default: !1,
      [u8]: "Boolean"
    },
    sHQ = {
      [kd]: "Endpoint"
    },
    fHQ = {
      [e3]: "isSet",
      [A7]: [{
        [kd]: "Region"
      }]
    },
    YD = {
      [kd]: "Region"
    },
    hHQ = {
      [e3]: "aws.partition",
      [A7]: [YD],
      assign: "PartitionResult"
    },
    rHQ = {
      [kd]: "UseFIPS"
    },
    oHQ = {
      [kd]: "UseDualStack"
    },
    qH = {
      url: "https://sts.amazonaws.com",
      properties: {
        authSchemes: [{
          name: iHQ,
          signingName: nHQ,
          signingRegion: aHQ
        }]
      },
      headers: {}
    },
    ww = {},
    gHQ = {
      conditions: [{
        [e3]: ID,
        [A7]: [YD, "aws-global"]
      }],
      [pI]: qH,
      [u8]: pI
    },
    tHQ = {
      [e3]: _d,
      [A7]: [rHQ, !0]
    },
    eHQ = {
      [e3]: _d,
      [A7]: [oHQ, !0]
    },
    uHQ = {
      [e3]: WM1,
      [A7]: [{
        [kd]: "PartitionResult"
      }, "supportsFIPS"]
    },
    ACQ = {
      [kd]: "PartitionResult"
    },
    mHQ = {
      [e3]: _d,
      [A7]: [!0, {
        [e3]: WM1,
        [A7]: [ACQ, "supportsDualStack"]
      }]
    },
    dHQ = [{
      [e3]: "isSet",
      [A7]: [sHQ]
    }],
    cHQ = [tHQ],
    pHQ = [eHQ],
    Xs4 = {
      version: "1.0",
      parameters: {
        Region: bHQ,
        UseDualStack: JM1,
        UseFIPS: JM1,
        Endpoint: bHQ,
        UseGlobalEndpoint: JM1
      },
      rules: [{
        conditions: [{
          [e3]: _d,
          [A7]: [{
            [kd]: "UseGlobalEndpoint"
          }, YM1]
        }, {
          [e3]: "not",
          [A7]: dHQ
        }, fHQ, hHQ, {
          [e3]: _d,
          [A7]: [rHQ, xHQ]
        }, {
          [e3]: _d,
          [A7]: [oHQ, xHQ]
        }],
        rules: [{
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "ap-northeast-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "ap-south-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "ap-southeast-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "ap-southeast-2"]
          }],
          endpoint: qH,
          [u8]: pI
        }, gHQ, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "ca-central-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "eu-central-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "eu-north-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "eu-west-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "eu-west-2"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "eu-west-3"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "sa-east-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, aHQ]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "us-east-2"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "us-west-1"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          conditions: [{
            [e3]: ID,
            [A7]: [YD, "us-west-2"]
          }],
          endpoint: qH,
          [u8]: pI
        }, {
          endpoint: {
            url: vHQ,
            properties: {
              authSchemes: [{
                name: iHQ,
                signingName: nHQ,
                signingRegion: "{Region}"
              }]
            },
            headers: ww
          },
          [u8]: pI
        }],
        [u8]: yS
      }, {
        conditions: dHQ,
        rules: [{
          conditions: cHQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          [u8]: l8A
        }, {
          conditions: pHQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          [u8]: l8A
        }, {
          endpoint: {
            url: sHQ,
            properties: ww,
            headers: ww
          },
          [u8]: pI
        }],
        [u8]: yS
      }, {
        conditions: [fHQ],
        rules: [{
          conditions: [hHQ],
          rules: [{
            conditions: [tHQ, eHQ],
            rules: [{
              conditions: [{
                [e3]: _d,
                [A7]: [YM1, uHQ]
              }, mHQ],
              rules: [{
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: ww,
                  headers: ww
                },
                [u8]: pI
              }],
              [u8]: yS
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              [u8]: l8A
            }],
            [u8]: yS
          }, {
            conditions: cHQ,
            rules: [{
              conditions: [{
                [e3]: _d,
                [A7]: [uHQ, YM1]
              }],
              rules: [{
                conditions: [{
                  [e3]: ID,
                  [A7]: [{
                    [e3]: WM1,
                    [A7]: [ACQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://sts.{Region}.amazonaws.com",
                  properties: ww,
                  headers: ww
                },
                [u8]: pI
              }, {
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: ww,
                  headers: ww
                },
                [u8]: pI
              }],
              [u8]: yS
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              [u8]: l8A
            }],
            [u8]: yS
          }, {
            conditions: pHQ,
            rules: [{
              conditions: [mHQ],
              rules: [{
                endpoint: {
                  url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: ww,
                  headers: ww
                },
                [u8]: pI
              }],
              [u8]: yS
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              [u8]: l8A
            }],
            [u8]: yS
          }, gHQ, {
            endpoint: {
              url: vHQ,
              properties: ww,
              headers: ww
            },
            [u8]: pI
          }],
          [u8]: yS
        }],
        [u8]: yS
      }, {
        error: "Invalid Configuration: Missing Region",
        [u8]: l8A
      }]
    };
  QCQ.ruleSet = Xs4
})
// @from(Start 3198511, End 3199096)
YCQ = z((ZCQ) => {
  Object.defineProperty(ZCQ, "__esModule", {
    value: !0
  });
  ZCQ.defaultEndpointResolver = void 0;
  var Vs4 = S8A(),
    XM1 = FI(),
    Fs4 = GCQ(),
    Ks4 = new XM1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    }),
    Ds4 = (A, Q = {}) => {
      return Ks4.get(A, () => (0, XM1.resolveEndpoint)(Fs4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  ZCQ.defaultEndpointResolver = Ds4;
  XM1.customEndpointFunctions.aws = Vs4.awsEndpointFunctions
})
// @from(Start 3199102, End 3200511)
FCQ = z((XCQ) => {
  Object.defineProperty(XCQ, "__esModule", {
    value: !0
  });
  XCQ.getRuntimeConfig = void 0;
  var Hs4 = TF(),
    Cs4 = iB(),
    Es4 = r6(),
    zs4 = NJ(),
    JCQ = Pd(),
    WCQ = O2(),
    Us4 = IM1(),
    $s4 = YCQ(),
    ws4 = (A) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: A?.base64Decoder ?? JCQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? JCQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? $s4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Us4.defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Hs4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Cs4.NoAuthSigner
        }],
        logger: A?.logger ?? new Es4.NoOpLogger,
        serviceId: A?.serviceId ?? "STS",
        urlParser: A?.urlParser ?? zs4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? WCQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? WCQ.toUtf8
      }
    };
  XCQ.getRuntimeConfig = ws4
})
// @from(Start 3200517, End 3203319)
zCQ = z((CCQ) => {
  Object.defineProperty(CCQ, "__esModule", {
    value: !0
  });
  CCQ.getRuntimeConfig = void 0;
  var qs4 = rr(),
    Ns4 = qs4.__importDefault(aL1()),
    VM1 = TF(),
    KCQ = kHA(),
    LuA = f8(),
    Ls4 = iB(),
    Ms4 = RX(),
    DCQ = D6(),
    Go = uI(),
    HCQ = IZ(),
    Os4 = TX(),
    Rs4 = KW(),
    Ts4 = FCQ(),
    Ps4 = r6(),
    js4 = PX(),
    Ss4 = r6(),
    _s4 = (A) => {
      (0, Ss4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, js4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(Ps4.loadConfigsForDefaultMode),
        G = (0, Ts4.getRuntimeConfig)(A);
      (0, VM1.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Go.loadConfig)(VM1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? Os4.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, KCQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: Ns4.default.version
        }),
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (I) => I.getIdentityProvider("aws.auth#sigv4") || (async (Y) => await A.credentialDefaultProvider(Y?.__config || {})()),
          signer: new VM1.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (I) => I.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Ls4.NoAuthSigner
        }],
        maxAttempts: A?.maxAttempts ?? (0, Go.loadConfig)(DCQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Go.loadConfig)(LuA.NODE_REGION_CONFIG_OPTIONS, {
          ...LuA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: HCQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Go.loadConfig)({
          ...DCQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || Rs4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? Ms4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? HCQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Go.loadConfig)(LuA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Go.loadConfig)(LuA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Go.loadConfig)(KCQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  CCQ.getRuntimeConfig = _s4
})
// @from(Start 3203325, End 3204344)
wCQ = z((UCQ) => {
  Object.defineProperty(UCQ, "__esModule", {
    value: !0
  });
  UCQ.resolveHttpAuthRuntimeConfig = UCQ.getHttpAuthExtensionConfiguration = void 0;
  var ks4 = (A) => {
    let {
      httpAuthSchemes: Q,
      httpAuthSchemeProvider: B,
      credentials: G
    } = A;
    return {
      setHttpAuthScheme(Z) {
        let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
        if (I === -1) Q.push(Z);
        else Q.splice(I, 1, Z)
      },
      httpAuthSchemes() {
        return Q
      },
      setHttpAuthSchemeProvider(Z) {
        B = Z
      },
      httpAuthSchemeProvider() {
        return B
      },
      setCredentials(Z) {
        G = Z
      },
      credentials() {
        return G
      }
    }
  };
  UCQ.getHttpAuthExtensionConfiguration = ks4;
  var ys4 = (A) => {
    return {
      httpAuthSchemes: A.httpAuthSchemes(),
      httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
      credentials: A.credentials()
    }
  };
  UCQ.resolveHttpAuthRuntimeConfig = ys4
})
// @from(Start 3204350, End 3205075)
TCQ = z((OCQ) => {
  Object.defineProperty(OCQ, "__esModule", {
    value: !0
  });
  OCQ.resolveRuntimeExtensions = void 0;
  var qCQ = xHA(),
    NCQ = iz(),
    LCQ = r6(),
    MCQ = wCQ(),
    vs4 = (A, Q) => {
      let B = Object.assign((0, qCQ.getAwsRegionExtensionConfiguration)(A), (0, LCQ.getDefaultExtensionConfiguration)(A), (0, NCQ.getHttpHandlerExtensionConfiguration)(A), (0, MCQ.getHttpAuthExtensionConfiguration)(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, qCQ.resolveAwsRegionExtensionConfiguration)(B), (0, LCQ.resolveDefaultRuntimeConfig)(B), (0, NCQ.resolveHttpHandlerRuntimeConfig)(B), (0, MCQ.resolveHttpAuthRuntimeConfig)(B))
    };
  OCQ.resolveRuntimeExtensions = vs4
})
// @from(Start 3205081, End 3207063)
mHA = z((KM1) => {
  Object.defineProperty(KM1, "__esModule", {
    value: !0
  });
  KM1.STSClient = KM1.__Client = void 0;
  var PCQ = MHA(),
    bs4 = OHA(),
    fs4 = RHA(),
    jCQ = b8A(),
    hs4 = f8(),
    FM1 = iB(),
    gs4 = LX(),
    us4 = q5(),
    SCQ = D6(),
    kCQ = r6();
  Object.defineProperty(KM1, "__Client", {
    enumerable: !0,
    get: function() {
      return kCQ.Client
    }
  });
  var _CQ = IM1(),
    ms4 = dHA(),
    ds4 = zCQ(),
    cs4 = TCQ();
  class yCQ extends kCQ.Client {
    config;
    constructor(...[A]) {
      let Q = (0, ds4.getRuntimeConfig)(A || {});
      super(Q);
      this.initConfig = Q;
      let B = (0, ms4.resolveClientEndpointParameters)(Q),
        G = (0, jCQ.resolveUserAgentConfig)(B),
        Z = (0, SCQ.resolveRetryConfig)(G),
        I = (0, hs4.resolveRegionConfig)(Z),
        Y = (0, PCQ.resolveHostHeaderConfig)(I),
        J = (0, us4.resolveEndpointConfig)(Y),
        W = (0, _CQ.resolveHttpAuthSchemeConfig)(J),
        X = (0, cs4.resolveRuntimeExtensions)(W, A?.extensions || []);
      this.config = X, this.middlewareStack.use((0, jCQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, SCQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, gs4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, PCQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, bs4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, fs4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, FM1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: _CQ.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (V) => new FM1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": V.credentials
        })
      })), this.middlewareStack.use((0, FM1.getHttpSigningPlugin)(this.config))
    }
    destroy() {
      super.destroy()
    }
  }
  KM1.STSClient = yCQ
})
// @from(Start 3207069, End 3230441)
cM1 = z((ow7, dM1) => {
  var {
    defineProperty: MuA,
    getOwnPropertyDescriptor: ps4,
    getOwnPropertyNames: ls4
  } = Object, is4 = Object.prototype.hasOwnProperty, _2 = (A, Q) => MuA(A, "name", {
    value: Q,
    configurable: !0
  }), ns4 = (A, Q) => {
    for (var B in Q) MuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vM1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ls4(Q))
        if (!is4.call(A, Z) && Z !== B) MuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = ps4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, as4 = (A, Q, B) => (vM1(A, Q, "default"), B && vM1(B, Q, "default")), ss4 = (A) => vM1(MuA({}, "__esModule", {
    value: !0
  }), A), fM1 = {};
  ns4(fM1, {
    AssumeRoleCommand: () => uM1,
    AssumeRoleResponseFilterSensitiveLog: () => fCQ,
    AssumeRoleWithWebIdentityCommand: () => mM1,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => pCQ,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => lCQ,
    ClientInputEndpointParameters: () => mr4.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => hM1,
    ExpiredTokenException: () => hCQ,
    IDPCommunicationErrorException: () => iCQ,
    IDPRejectedClaimException: () => dCQ,
    InvalidIdentityTokenException: () => cCQ,
    MalformedPolicyDocumentException: () => gCQ,
    PackedPolicyTooLargeException: () => uCQ,
    RegionDisabledException: () => mCQ,
    STS: () => GEQ,
    STSServiceException: () => ov,
    decorateDefaultCredentialProvider: () => pr4,
    getDefaultRoleAssumer: () => XEQ,
    getDefaultRoleAssumerWithWebIdentity: () => VEQ
  });
  dM1.exports = ss4(fM1);
  as4(fM1, mHA(), dM1.exports);
  var rs4 = r6(),
    os4 = q5(),
    ts4 = GZ(),
    es4 = r6(),
    Ar4 = dHA(),
    bCQ = r6(),
    Qr4 = r6(),
    ov = class A extends Qr4.ServiceException {
      static {
        _2(this, "STSServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    hM1 = _2((A) => ({
      ...A,
      ...A.SecretAccessKey && {
        SecretAccessKey: bCQ.SENSITIVE_STRING
      }
    }), "CredentialsFilterSensitiveLog"),
    fCQ = _2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: hM1(A.Credentials)
      }
    }), "AssumeRoleResponseFilterSensitiveLog"),
    hCQ = class A extends ov {
      static {
        _2(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    gCQ = class A extends ov {
      static {
        _2(this, "MalformedPolicyDocumentException")
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    uCQ = class A extends ov {
      static {
        _2(this, "PackedPolicyTooLargeException")
      }
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    mCQ = class A extends ov {
      static {
        _2(this, "RegionDisabledException")
      }
      name = "RegionDisabledException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    dCQ = class A extends ov {
      static {
        _2(this, "IDPRejectedClaimException")
      }
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    cCQ = class A extends ov {
      static {
        _2(this, "InvalidIdentityTokenException")
      }
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    pCQ = _2((A) => ({
      ...A,
      ...A.WebIdentityToken && {
        WebIdentityToken: bCQ.SENSITIVE_STRING
      }
    }), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog"),
    lCQ = _2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: hM1(A.Credentials)
      }
    }), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog"),
    iCQ = class A extends ov {
      static {
        _2(this, "IDPCommunicationErrorException")
      }
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    gM1 = TF(),
    Br4 = iz(),
    N7 = r6(),
    Gr4 = _2(async (A, Q) => {
      let B = tCQ,
        G;
      return G = BEQ({
        ...Hr4(A, Q),
        [AEQ]: kr4,
        [QEQ]: eCQ
      }), oCQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleCommand"),
    Zr4 = _2(async (A, Q) => {
      let B = tCQ,
        G;
      return G = BEQ({
        ...Cr4(A, Q),
        [AEQ]: yr4,
        [QEQ]: eCQ
      }), oCQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleWithWebIdentityCommand"),
    Ir4 = _2(async (A, Q) => {
      if (A.statusCode >= 300) return nCQ(A, Q);
      let B = await (0, gM1.parseXmlBody)(A.body, Q),
        G = {};
      return G = Nr4(B.AssumeRoleResult, Q), {
        $metadata: tv(A),
        ...G
      }
    }, "de_AssumeRoleCommand"),
    Yr4 = _2(async (A, Q) => {
      if (A.statusCode >= 300) return nCQ(A, Q);
      let B = await (0, gM1.parseXmlBody)(A.body, Q),
        G = {};
      return G = Lr4(B.AssumeRoleWithWebIdentityResult, Q), {
        $metadata: tv(A),
        ...G
      }
    }, "de_AssumeRoleWithWebIdentityCommand"),
    nCQ = _2(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, gM1.parseXmlErrorBody)(A.body, Q)
        },
        G = xr4(A, B.body);
      switch (G) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await Jr4(B, Q);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await Fr4(B, Q);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await Kr4(B, Q);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await Dr4(B, Q);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await Wr4(B, Q);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await Xr4(B, Q);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await Vr4(B, Q);
        default:
          let Z = B.body;
          return _r4({
            output: A,
            parsedBody: Z.Error,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    Jr4 = _2(async (A, Q) => {
      let B = A.body,
        G = Mr4(B.Error, Q),
        Z = new hCQ({
          $metadata: tv(A),
          ...G
        });
      return (0, N7.decorateServiceException)(Z, B)
    }, "de_ExpiredTokenExceptionRes"),
    Wr4 = _2(async (A, Q) => {
      let B = A.body,
        G = Or4(B.Error, Q),
        Z = new iCQ({
          $metadata: tv(A),
          ...G
        });
      return (0, N7.decorateServiceException)(Z, B)
    }, "de_IDPCommunicationErrorExceptionRes"),
    Xr4 = _2(async (A, Q) => {
      let B = A.body,
        G = Rr4(B.Error, Q),
        Z = new dCQ({
          $metadata: tv(A),
          ...G
        });
      return (0, N7.decorateServiceException)(Z, B)
    }, "de_IDPRejectedClaimExceptionRes"),
    Vr4 = _2(async (A, Q) => {
      let B = A.body,
        G = Tr4(B.Error, Q),
        Z = new cCQ({
          $metadata: tv(A),
          ...G
        });
      return (0, N7.decorateServiceException)(Z, B)
    }, "de_InvalidIdentityTokenExceptionRes"),
    Fr4 = _2(async (A, Q) => {
      let B = A.body,
        G = Pr4(B.Error, Q),
        Z = new gCQ({
          $metadata: tv(A),
          ...G
        });
      return (0, N7.decorateServiceException)(Z, B)
    }, "de_MalformedPolicyDocumentExceptionRes"),
    Kr4 = _2(async (A, Q) => {
      let B = A.body,
        G = jr4(B.Error, Q),
        Z = new uCQ({
          $metadata: tv(A),
          ...G
        });
      return (0, N7.decorateServiceException)(Z, B)
    }, "de_PackedPolicyTooLargeExceptionRes"),
    Dr4 = _2(async (A, Q) => {
      let B = A.body,
        G = Sr4(B.Error, Q),
        Z = new mCQ({
          $metadata: tv(A),
          ...G
        });
      return (0, N7.decorateServiceException)(Z, B)
    }, "de_RegionDisabledExceptionRes"),
    Hr4 = _2((A, Q) => {
      let B = {};
      if (A[t8A] != null) B[t8A] = A[t8A];
      if (A[e8A] != null) B[e8A] = A[e8A];
      if (A[r8A] != null) {
        let G = aCQ(A[r8A], Q);
        if (A[r8A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[s8A] != null) B[s8A] = A[s8A];
      if (A[a8A] != null) B[a8A] = A[a8A];
      if (A[jM1] != null) {
        let G = qr4(A[jM1], Q);
        if (A[jM1]?.length === 0) B.Tags = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `Tags.${Z}`;
          B[Y] = I
        })
      }
      if (A[_M1] != null) {
        let G = wr4(A[_M1], Q);
        if (A[_M1]?.length === 0) B.TransitiveTagKeys = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `TransitiveTagKeys.${Z}`;
          B[Y] = I
        })
      }
      if (A[$M1] != null) B[$M1] = A[$M1];
      if (A[TM1] != null) B[TM1] = A[TM1];
      if (A[SM1] != null) B[SM1] = A[SM1];
      if (A[rv] != null) B[rv] = A[rv];
      if (A[NM1] != null) {
        let G = Ur4(A[NM1], Q);
        if (A[NM1]?.length === 0) B.ProvidedContexts = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `ProvidedContexts.${Z}`;
          B[Y] = I
        })
      }
      return B
    }, "se_AssumeRoleRequest"),
    Cr4 = _2((A, Q) => {
      let B = {};
      if (A[t8A] != null) B[t8A] = A[t8A];
      if (A[e8A] != null) B[e8A] = A[e8A];
      if (A[yM1] != null) B[yM1] = A[yM1];
      if (A[LM1] != null) B[LM1] = A[LM1];
      if (A[r8A] != null) {
        let G = aCQ(A[r8A], Q);
        if (A[r8A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[s8A] != null) B[s8A] = A[s8A];
      if (A[a8A] != null) B[a8A] = A[a8A];
      return B
    }, "se_AssumeRoleWithWebIdentityRequest"),
    aCQ = _2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = Er4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_policyDescriptorListType"),
    Er4 = _2((A, Q) => {
      let B = {};
      if (A[xM1] != null) B[xM1] = A[xM1];
      return B
    }, "se_PolicyDescriptorType"),
    zr4 = _2((A, Q) => {
      let B = {};
      if (A[qM1] != null) B[qM1] = A[qM1];
      if (A[zM1] != null) B[zM1] = A[zM1];
      return B
    }, "se_ProvidedContext"),
    Ur4 = _2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = zr4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_ProvidedContextsListType"),
    $r4 = _2((A, Q) => {
      let B = {};
      if (A[wM1] != null) B[wM1] = A[wM1];
      if (A[kM1] != null) B[kM1] = A[kM1];
      return B
    }, "se_Tag"),
    wr4 = _2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        B[`member.${G}`] = Z, G++
      }
      return B
    }, "se_tagKeyListType"),
    qr4 = _2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = $r4(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_tagListType"),
    sCQ = _2((A, Q) => {
      let B = {};
      if (A[HM1] != null) B[HM1] = (0, N7.expectString)(A[HM1]);
      if (A[CM1] != null) B[CM1] = (0, N7.expectString)(A[CM1]);
      return B
    }, "de_AssumedRoleUser"),
    Nr4 = _2((A, Q) => {
      let B = {};
      if (A[n8A] != null) B[n8A] = rCQ(A[n8A], Q);
      if (A[i8A] != null) B[i8A] = sCQ(A[i8A], Q);
      if (A[o8A] != null) B[o8A] = (0, N7.strictParseInt32)(A[o8A]);
      if (A[rv] != null) B[rv] = (0, N7.expectString)(A[rv]);
      return B
    }, "de_AssumeRoleResponse"),
    Lr4 = _2((A, Q) => {
      let B = {};
      if (A[n8A] != null) B[n8A] = rCQ(A[n8A], Q);
      if (A[RM1] != null) B[RM1] = (0, N7.expectString)(A[RM1]);
      if (A[i8A] != null) B[i8A] = sCQ(A[i8A], Q);
      if (A[o8A] != null) B[o8A] = (0, N7.strictParseInt32)(A[o8A]);
      if (A[MM1] != null) B[MM1] = (0, N7.expectString)(A[MM1]);
      if (A[EM1] != null) B[EM1] = (0, N7.expectString)(A[EM1]);
      if (A[rv] != null) B[rv] = (0, N7.expectString)(A[rv]);
      return B
    }, "de_AssumeRoleWithWebIdentityResponse"),
    rCQ = _2((A, Q) => {
      let B = {};
      if (A[DM1] != null) B[DM1] = (0, N7.expectString)(A[DM1]);
      if (A[OM1] != null) B[OM1] = (0, N7.expectString)(A[OM1]);
      if (A[PM1] != null) B[PM1] = (0, N7.expectString)(A[PM1]);
      if (A[UM1] != null) B[UM1] = (0, N7.expectNonNull)((0, N7.parseRfc3339DateTimeWithOffset)(A[UM1]));
      return B
    }, "de_Credentials"),
    Mr4 = _2((A, Q) => {
      let B = {};
      if (A[CW] != null) B[CW] = (0, N7.expectString)(A[CW]);
      return B
    }, "de_ExpiredTokenException"),
    Or4 = _2((A, Q) => {
      let B = {};
      if (A[CW] != null) B[CW] = (0, N7.expectString)(A[CW]);
      return B
    }, "de_IDPCommunicationErrorException"),
    Rr4 = _2((A, Q) => {
      let B = {};
      if (A[CW] != null) B[CW] = (0, N7.expectString)(A[CW]);
      return B
    }, "de_IDPRejectedClaimException"),
    Tr4 = _2((A, Q) => {
      let B = {};
      if (A[CW] != null) B[CW] = (0, N7.expectString)(A[CW]);
      return B
    }, "de_InvalidIdentityTokenException"),
    Pr4 = _2((A, Q) => {
      let B = {};
      if (A[CW] != null) B[CW] = (0, N7.expectString)(A[CW]);
      return B
    }, "de_MalformedPolicyDocumentException"),
    jr4 = _2((A, Q) => {
      let B = {};
      if (A[CW] != null) B[CW] = (0, N7.expectString)(A[CW]);
      return B
    }, "de_PackedPolicyTooLargeException"),
    Sr4 = _2((A, Q) => {
      let B = {};
      if (A[CW] != null) B[CW] = (0, N7.expectString)(A[CW]);
      return B
    }, "de_RegionDisabledException"),
    tv = _2((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    _r4 = (0, N7.withBaseException)(ov),
    oCQ = _2(async (A, Q, B, G, Z) => {
      let {
        hostname: I,
        protocol: Y = "https",
        port: J,
        path: W
      } = await A.endpoint(), X = {
        protocol: Y,
        hostname: I,
        port: J,
        method: "POST",
        path: W.endsWith("/") ? W.slice(0, -1) + B : W + B,
        headers: Q
      };
      if (G !== void 0) X.hostname = G;
      if (Z !== void 0) X.body = Z;
      return new Br4.HttpRequest(X)
    }, "buildHttpRpcRequest"),
    tCQ = {
      "content-type": "application/x-www-form-urlencoded"
    },
    eCQ = "2011-06-15",
    AEQ = "Action",
    DM1 = "AccessKeyId",
    kr4 = "AssumeRole",
    HM1 = "AssumedRoleId",
    i8A = "AssumedRoleUser",
    yr4 = "AssumeRoleWithWebIdentity",
    CM1 = "Arn",
    EM1 = "Audience",
    n8A = "Credentials",
    zM1 = "ContextAssertion",
    a8A = "DurationSeconds",
    UM1 = "Expiration",
    $M1 = "ExternalId",
    wM1 = "Key",
    s8A = "Policy",
    r8A = "PolicyArns",
    qM1 = "ProviderArn",
    NM1 = "ProvidedContexts",
    LM1 = "ProviderId",
    o8A = "PackedPolicySize",
    MM1 = "Provider",
    t8A = "RoleArn",
    e8A = "RoleSessionName",
    OM1 = "SecretAccessKey",
    RM1 = "SubjectFromWebIdentityToken",
    rv = "SourceIdentity",
    TM1 = "SerialNumber",
    PM1 = "SessionToken",
    jM1 = "Tags",
    SM1 = "TokenCode",
    _M1 = "TransitiveTagKeys",
    QEQ = "Version",
    kM1 = "Value",
    yM1 = "WebIdentityToken",
    xM1 = "arn",
    CW = "message",
    BEQ = _2((A) => Object.entries(A).map(([Q, B]) => (0, N7.extendedEncodeURIComponent)(Q) + "=" + (0, N7.extendedEncodeURIComponent)(B)).join("&"), "buildFormUrlencodedString"),
    xr4 = _2((A, Q) => {
      if (Q.Error?.Code !== void 0) return Q.Error.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadQueryErrorCode"),
    uM1 = class extends es4.Command.classBuilder().ep(Ar4.commonParams).m(function(A, Q, B, G) {
      return [(0, ts4.getSerdePlugin)(B, this.serialize, this.deserialize), (0, os4.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(void 0, fCQ).ser(Gr4).de(Ir4).build() {
      static {
        _2(this, "AssumeRoleCommand")
      }
    },
    vr4 = q5(),
    br4 = GZ(),
    fr4 = r6(),
    hr4 = dHA(),
    mM1 = class extends fr4.Command.classBuilder().ep(hr4.commonParams).m(function(A, Q, B, G) {
      return [(0, br4.getSerdePlugin)(B, this.serialize, this.deserialize), (0, vr4.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(pCQ, lCQ).ser(Zr4).de(Yr4).build() {
      static {
        _2(this, "AssumeRoleWithWebIdentityCommand")
      }
    },
    gr4 = mHA(),
    ur4 = {
      AssumeRoleCommand: uM1,
      AssumeRoleWithWebIdentityCommand: mM1
    },
    GEQ = class extends gr4.STSClient {
      static {
        _2(this, "STS")
      }
    };
  (0, rs4.createAggregatedClient)(ur4, GEQ);
  var mr4 = dHA(),
    bM1 = lR(),
    vCQ = "us-east-1",
    ZEQ = _2((A) => {
      if (typeof A?.Arn === "string") {
        let Q = A.Arn.split(":");
        if (Q.length > 4 && Q[4] !== "") return Q[4]
      }
      return
    }, "getAccountIdFromAssumedRoleUser"),
    IEQ = _2(async (A, Q, B) => {
      let G = typeof A === "function" ? await A() : A,
        Z = typeof Q === "function" ? await Q() : Q;
      return B?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${G} (provider)`, `${Z} (parent client)`, `${vCQ} (STS default)`), G ?? Z ?? vCQ
    }, "resolveRegion"),
    dr4 = _2((A, Q) => {
      let B, G;
      return async (Z, I) => {
        if (G = Z, !B) {
          let {
            logger: V = A?.parentClientConfig?.logger,
            region: F,
            requestHandler: K = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: D
          } = A, H = await IEQ(F, A?.parentClientConfig?.region, D), C = !YEQ(K);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            credentialDefaultProvider: _2(() => async () => G, "credentialDefaultProvider"),
            region: H,
            requestHandler: C ? K : void 0,
            logger: V
          })
        }
        let {
          Credentials: Y,
          AssumedRoleUser: J
        } = await B.send(new uM1(I));
        if (!Y || !Y.AccessKeyId || !Y.SecretAccessKey) throw Error(`Invalid response from STS.assumeRole call with role ${I.RoleArn}`);
        let W = ZEQ(J),
          X = {
            accessKeyId: Y.AccessKeyId,
            secretAccessKey: Y.SecretAccessKey,
            sessionToken: Y.SessionToken,
            expiration: Y.Expiration,
            ...Y.CredentialScope && {
              credentialScope: Y.CredentialScope
            },
            ...W && {
              accountId: W
            }
          };
        return (0, bM1.setCredentialFeature)(X, "CREDENTIALS_STS_ASSUME_ROLE", "i"), X
      }
    }, "getDefaultRoleAssumer"),
    cr4 = _2((A, Q) => {
      let B;
      return async (G) => {
        if (!B) {
          let {
            logger: W = A?.parentClientConfig?.logger,
            region: X,
            requestHandler: V = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: F
          } = A, K = await IEQ(X, A?.parentClientConfig?.region, F), D = !YEQ(V);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            region: K,
            requestHandler: D ? V : void 0,
            logger: W
          })
        }
        let {
          Credentials: Z,
          AssumedRoleUser: I
        } = await B.send(new mM1(G));
        if (!Z || !Z.AccessKeyId || !Z.SecretAccessKey) throw Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${G.RoleArn}`);
        let Y = ZEQ(I),
          J = {
            accessKeyId: Z.AccessKeyId,
            secretAccessKey: Z.SecretAccessKey,
            sessionToken: Z.SessionToken,
            expiration: Z.Expiration,
            ...Z.CredentialScope && {
              credentialScope: Z.CredentialScope
            },
            ...Y && {
              accountId: Y
            }
          };
        if (Y)(0, bM1.setCredentialFeature)(J, "RESOLVED_ACCOUNT_ID", "T");
        return (0, bM1.setCredentialFeature)(J, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"), J
      }
    }, "getDefaultRoleAssumerWithWebIdentity"),
    YEQ = _2((A) => {
      return A?.metadata?.handlerProtocol === "h2"
    }, "isH2"),
    JEQ = mHA(),
    WEQ = _2((A, Q) => {
      if (!Q) return A;
      else return class extends A {
        static {
          _2(this, "CustomizableSTSClient")
        }
        constructor(G) {
          super(G);
          for (let Z of Q) this.middlewareStack.use(Z)
        }
      }
    }, "getCustomizableStsClientCtor"),
    XEQ = _2((A = {}, Q) => dr4(A, WEQ(JEQ.STSClient, Q)), "getDefaultRoleAssumer"),
    VEQ = _2((A = {}, Q) => cr4(A, WEQ(JEQ.STSClient, Q)), "getDefaultRoleAssumerWithWebIdentity"),
    pr4 = _2((A) => (Q) => A({
      roleAssumer: XEQ(Q),
      roleAssumerWithWebIdentity: VEQ(Q),
      ...Q
    }), "decorateDefaultCredentialProvider")
})
// @from(Start 3230447, End 3233689)
iM1 = z((Qq7, DEQ) => {
  var {
    defineProperty: OuA,
    getOwnPropertyDescriptor: lr4,
    getOwnPropertyNames: ir4
  } = Object, nr4 = Object.prototype.hasOwnProperty, lM1 = (A, Q) => OuA(A, "name", {
    value: Q,
    configurable: !0
  }), ar4 = (A, Q) => {
    for (var B in Q) OuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, sr4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ir4(Q))
        if (!nr4.call(A, Z) && Z !== B) OuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = lr4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, rr4 = (A) => sr4(OuA({}, "__esModule", {
    value: !0
  }), A), KEQ = {};
  ar4(KEQ, {
    fromProcess: () => Bo4
  });
  DEQ.exports = rr4(KEQ);
  var FEQ = SG(),
    pM1 = j2(),
    or4 = UA("child_process"),
    tr4 = UA("util"),
    er4 = lR(),
    Ao4 = lM1((A, Q, B) => {
      if (Q.Version !== 1) throw Error(`Profile ${A} credential_process did not return Version 1.`);
      if (Q.AccessKeyId === void 0 || Q.SecretAccessKey === void 0) throw Error(`Profile ${A} credential_process returned invalid credentials.`);
      if (Q.Expiration) {
        let I = new Date;
        if (new Date(Q.Expiration) < I) throw Error(`Profile ${A} credential_process returned expired credentials.`)
      }
      let G = Q.AccountId;
      if (!G && B?.[A]?.aws_account_id) G = B[A].aws_account_id;
      let Z = {
        accessKeyId: Q.AccessKeyId,
        secretAccessKey: Q.SecretAccessKey,
        ...Q.SessionToken && {
          sessionToken: Q.SessionToken
        },
        ...Q.Expiration && {
          expiration: new Date(Q.Expiration)
        },
        ...Q.CredentialScope && {
          credentialScope: Q.CredentialScope
        },
        ...G && {
          accountId: G
        }
      };
      return (0, er4.setCredentialFeature)(Z, "CREDENTIALS_PROCESS", "w"), Z
    }, "getValidatedProcessCredentials"),
    Qo4 = lM1(async (A, Q, B) => {
      let G = Q[A];
      if (Q[A]) {
        let Z = G.credential_process;
        if (Z !== void 0) {
          let I = (0, tr4.promisify)(or4.exec);
          try {
            let {
              stdout: Y
            } = await I(Z), J;
            try {
              J = JSON.parse(Y.trim())
            } catch {
              throw Error(`Profile ${A} credential_process returned invalid JSON.`)
            }
            return Ao4(A, J, Q)
          } catch (Y) {
            throw new pM1.CredentialsProviderError(Y.message, {
              logger: B
            })
          }
        } else throw new pM1.CredentialsProviderError(`Profile ${A} did not contain credential_process.`, {
          logger: B
        })
      } else throw new pM1.CredentialsProviderError(`Profile ${A} could not be found in shared credentials file.`, {
        logger: B
      })
    }, "resolveProcessCredentials"),
    Bo4 = lM1((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
      let B = await (0, FEQ.parseKnownFiles)(A);
      return Qo4((0, FEQ.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), B, A.logger)
    }, "fromProcess")
})
// @from(Start 3233695, End 3236019)
nM1 = z((xS) => {
  var Go4 = xS && xS.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    Zo4 = xS && xS.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    Io4 = xS && xS.__importStar || function() {
      var A = function(Q) {
        return A = Object.getOwnPropertyNames || function(B) {
          var G = [];
          for (var Z in B)
            if (Object.prototype.hasOwnProperty.call(B, Z)) G[G.length] = Z;
          return G
        }, A(Q)
      };
      return function(Q) {
        if (Q && Q.__esModule) return Q;
        var B = {};
        if (Q != null) {
          for (var G = A(Q), Z = 0; Z < G.length; Z++)
            if (G[Z] !== "default") Go4(B, Q, G[Z])
        }
        return Zo4(B, Q), B
      }
    }();
  Object.defineProperty(xS, "__esModule", {
    value: !0
  });
  xS.fromWebToken = void 0;
  var Yo4 = (A) => async (Q) => {
    A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    let {
      roleArn: B,
      roleSessionName: G,
      webIdentityToken: Z,
      providerId: I,
      policyArns: Y,
      policy: J,
      durationSeconds: W
    } = A, {
      roleAssumerWithWebIdentity: X
    } = A;
    if (!X) {
      let {
        getDefaultRoleAssumerWithWebIdentity: V
      } = await Promise.resolve().then(() => Io4(cM1()));
      X = V({
        ...A.clientConfig,
        credentialProviderLogger: A.logger,
        parentClientConfig: {
          ...Q?.callerClientConfig,
          ...A.parentClientConfig
        }
      }, A.clientPlugins)
    }
    return X({
      RoleArn: B,
      RoleSessionName: G ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: Z,
      ProviderId: I,
      PolicyArns: Y,
      Policy: J,
      DurationSeconds: W
    })
  };
  xS.fromWebToken = Yo4
})
// @from(Start 3236025, End 3237100)
zEQ = z((CEQ) => {
  Object.defineProperty(CEQ, "__esModule", {
    value: !0
  });
  CEQ.fromTokenFile = void 0;
  var Jo4 = lR(),
    Wo4 = j2(),
    Xo4 = UA("fs"),
    Vo4 = nM1(),
    HEQ = "AWS_WEB_IDENTITY_TOKEN_FILE",
    Fo4 = "AWS_ROLE_ARN",
    Ko4 = "AWS_ROLE_SESSION_NAME",
    Do4 = (A = {}) => async () => {
      A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
      let Q = A?.webIdentityTokenFile ?? process.env[HEQ],
        B = A?.roleArn ?? process.env[Fo4],
        G = A?.roleSessionName ?? process.env[Ko4];
      if (!Q || !B) throw new Wo4.CredentialsProviderError("Web identity configuration not specified", {
        logger: A.logger
      });
      let Z = await (0, Vo4.fromWebToken)({
        ...A,
        webIdentityToken: (0, Xo4.readFileSync)(Q, {
          encoding: "ascii"
        }),
        roleArn: B,
        roleSessionName: G
      })();
      if (Q === process.env[HEQ])(0, Jo4.setCredentialFeature)(Z, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
      return Z
    };
  CEQ.fromTokenFile = Do4
})
// @from(Start 3237106, End 3237802)
rM1 = z((Zq7, RuA) => {
  var {
    defineProperty: UEQ,
    getOwnPropertyDescriptor: Ho4,
    getOwnPropertyNames: Co4
  } = Object, Eo4 = Object.prototype.hasOwnProperty, aM1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Co4(Q))
        if (!Eo4.call(A, Z) && Z !== B) UEQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Ho4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, $EQ = (A, Q, B) => (aM1(A, Q, "default"), B && aM1(B, Q, "default")), zo4 = (A) => aM1(UEQ({}, "__esModule", {
    value: !0
  }), A), sM1 = {};
  RuA.exports = zo4(sM1);
  $EQ(sM1, zEQ(), RuA.exports);
  $EQ(sM1, nM1(), RuA.exports)
})
// @from(Start 3237808, End 3247530)
TEQ = z((Iq7, REQ) => {
  var {
    create: Uo4,
    defineProperty: pHA,
    getOwnPropertyDescriptor: $o4,
    getOwnPropertyNames: wo4,
    getPrototypeOf: qo4
  } = Object, No4 = Object.prototype.hasOwnProperty, SX = (A, Q) => pHA(A, "name", {
    value: Q,
    configurable: !0
  }), Lo4 = (A, Q) => {
    for (var B in Q) pHA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, LEQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of wo4(Q))
        if (!No4.call(A, Z) && Z !== B) pHA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = $o4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, yd = (A, Q, B) => (B = A != null ? Uo4(qo4(A)) : {}, LEQ(Q || !A || !A.__esModule ? pHA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), Mo4 = (A) => LEQ(pHA({}, "__esModule", {
    value: !0
  }), A), MEQ = {};
  Lo4(MEQ, {
    fromIni: () => bo4
  });
  REQ.exports = Mo4(MEQ);
  var tM1 = SG(),
    xd = lR(),
    cHA = j2(),
    Oo4 = SX((A, Q, B) => {
      let G = {
        EcsContainer: SX(async (Z) => {
          let {
            fromHttp: I
          } = await Promise.resolve().then(() => yd(fL1())), {
            fromContainerMetadata: Y
          } = await Promise.resolve().then(() => yd(OV()));
          return B?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => (0, cHA.chain)(I(Z ?? {}), Y(Z))().then(oM1)
        }, "EcsContainer"),
        Ec2InstanceMetadata: SX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
          let {
            fromInstanceMetadata: I
          } = await Promise.resolve().then(() => yd(OV()));
          return async () => I(Z)().then(oM1)
        }, "Ec2InstanceMetadata"),
        Environment: SX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
          let {
            fromEnv: I
          } = await Promise.resolve().then(() => yd(xL1()));
          return async () => I(Z)().then(oM1)
        }, "Environment")
      };
      if (A in G) return G[A];
      else throw new cHA.CredentialsProviderError(`Unsupported credential source in profile ${Q}. Got ${A}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, {
        logger: B
      })
    }, "resolveCredentialSource"),
    oM1 = SX((A) => (0, xd.setCredentialFeature)(A, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"), "setNamedProvider"),
    Ro4 = SX((A, {
      profile: Q = "default",
      logger: B
    } = {}) => {
      return Boolean(A) && typeof A === "object" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof A.external_id) > -1 && ["undefined", "string"].indexOf(typeof A.mfa_serial) > -1 && (To4(A, {
        profile: Q,
        logger: B
      }) || Po4(A, {
        profile: Q,
        logger: B
      }))
    }, "isAssumeRoleProfile"),
    To4 = SX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.source_profile === "string" && typeof A.credential_source > "u";
      if (G) B?.debug?.(`    ${Q} isAssumeRoleWithSourceProfile source_profile=${A.source_profile}`);
      return G
    }, "isAssumeRoleWithSourceProfile"),
    Po4 = SX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.credential_source === "string" && typeof A.source_profile > "u";
      if (G) B?.debug?.(`    ${Q} isCredentialSourceProfile credential_source=${A.credential_source}`);
      return G
    }, "isCredentialSourceProfile"),
    jo4 = SX(async (A, Q, B, G = {}) => {
      B.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
      let Z = Q[A],
        {
          source_profile: I,
          region: Y
        } = Z;
      if (!B.roleAssumer) {
        let {
          getDefaultRoleAssumer: W
        } = await Promise.resolve().then(() => yd(cM1()));
        B.roleAssumer = W({
          ...B.clientConfig,
          credentialProviderLogger: B.logger,
          parentClientConfig: {
            ...B?.parentClientConfig,
            region: Y ?? B?.parentClientConfig?.region
          }
        }, B.clientPlugins)
      }
      if (I && I in G) throw new cHA.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${(0,tM1.getProfileName)(B)}. Profiles visited: ` + Object.keys(G).join(", "), {
        logger: B.logger
      });
      B.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${I?`source_profile=[${I}]`:`profile=[${A}]`}`);
      let J = I ? OEQ(I, Q, B, {
        ...G,
        [I]: !0
      }, wEQ(Q[I] ?? {})) : (await Oo4(Z.credential_source, A, B.logger)(B))();
      if (wEQ(Z)) return J.then((W) => (0, xd.setCredentialFeature)(W, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      else {
        let W = {
            RoleArn: Z.role_arn,
            RoleSessionName: Z.role_session_name || `aws-sdk-js-${Date.now()}`,
            ExternalId: Z.external_id,
            DurationSeconds: parseInt(Z.duration_seconds || "3600", 10)
          },
          {
            mfa_serial: X
          } = Z;
        if (X) {
          if (!B.mfaCodeProvider) throw new cHA.CredentialsProviderError(`Profile ${A} requires multi-factor authentication, but no MFA code callback was provided.`, {
            logger: B.logger,
            tryNextLink: !1
          });
          W.SerialNumber = X, W.TokenCode = await B.mfaCodeProvider(X)
        }
        let V = await J;
        return B.roleAssumer(V, W).then((F) => (0, xd.setCredentialFeature)(F, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"))
      }
    }, "resolveAssumeRoleCredentials"),
    wEQ = SX((A) => {
      return !A.role_arn && !!A.credential_source
    }, "isCredentialSourceWithoutRoleArn"),
    So4 = SX((A) => Boolean(A) && typeof A === "object" && typeof A.credential_process === "string", "isProcessProfile"),
    _o4 = SX(async (A, Q) => Promise.resolve().then(() => yd(iM1())).then(({
      fromProcess: B
    }) => B({
      ...A,
      profile: Q
    })().then((G) => (0, xd.setCredentialFeature)(G, "CREDENTIALS_PROFILE_PROCESS", "v"))), "resolveProcessCredentials"),
    ko4 = SX(async (A, Q, B = {}) => {
      let {
        fromSSO: G
      } = await Promise.resolve().then(() => yd(GM1()));
      return G({
        profile: A,
        logger: B.logger,
        parentClientConfig: B.parentClientConfig,
        clientConfig: B.clientConfig
      })().then((Z) => {
        if (Q.sso_session) return (0, xd.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO", "r");
        else return (0, xd.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      })
    }, "resolveSsoCredentials"),
    yo4 = SX((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    qEQ = SX((A) => Boolean(A) && typeof A === "object" && typeof A.aws_access_key_id === "string" && typeof A.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof A.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof A.aws_account_id) > -1, "isStaticCredsProfile"),
    NEQ = SX(async (A, Q) => {
      Q?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
      let B = {
        accessKeyId: A.aws_access_key_id,
        secretAccessKey: A.aws_secret_access_key,
        sessionToken: A.aws_session_token,
        ...A.aws_credential_scope && {
          credentialScope: A.aws_credential_scope
        },
        ...A.aws_account_id && {
          accountId: A.aws_account_id
        }
      };
      return (0, xd.setCredentialFeature)(B, "CREDENTIALS_PROFILE", "n")
    }, "resolveStaticCredentials"),
    xo4 = SX((A) => Boolean(A) && typeof A === "object" && typeof A.web_identity_token_file === "string" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1, "isWebIdentityProfile"),
    vo4 = SX(async (A, Q) => Promise.resolve().then(() => yd(rM1())).then(({
      fromTokenFile: B
    }) => B({
      webIdentityTokenFile: A.web_identity_token_file,
      roleArn: A.role_arn,
      roleSessionName: A.role_session_name,
      roleAssumerWithWebIdentity: Q.roleAssumerWithWebIdentity,
      logger: Q.logger,
      parentClientConfig: Q.parentClientConfig
    })().then((G) => (0, xd.setCredentialFeature)(G, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))), "resolveWebIdentityCredentials"),
    OEQ = SX(async (A, Q, B, G = {}, Z = !1) => {
      let I = Q[A];
      if (Object.keys(G).length > 0 && qEQ(I)) return NEQ(I, B);
      if (Z || Ro4(I, {
          profile: A,
          logger: B.logger
        })) return jo4(A, Q, B, G);
      if (qEQ(I)) return NEQ(I, B);
      if (xo4(I)) return vo4(I, B);
      if (So4(I)) return _o4(B, A);
      if (yo4(I)) return await ko4(A, I, B);
      throw new cHA.CredentialsProviderError(`Could not resolve credentials using profile: [${A}] in configuration/credentials file(s).`, {
        logger: B.logger
      })
    }, "resolveProfileData"),
    bo4 = SX((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
      let G = await (0, tM1.parseKnownFiles)(B);
      return OEQ((0, tM1.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), G, B)
    }, "fromIni")
})
// @from(Start 3247536, End 3252498)
vEQ = z((Yq7, xEQ) => {
  var {
    create: fo4,
    defineProperty: lHA,
    getOwnPropertyDescriptor: ho4,
    getOwnPropertyNames: go4,
    getPrototypeOf: uo4
  } = Object, mo4 = Object.prototype.hasOwnProperty, TuA = (A, Q) => lHA(A, "name", {
    value: Q,
    configurable: !0
  }), do4 = (A, Q) => {
    for (var B in Q) lHA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, SEQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of go4(Q))
        if (!mo4.call(A, Z) && Z !== B) lHA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = ho4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, A6A = (A, Q, B) => (B = A != null ? fo4(uo4(A)) : {}, SEQ(Q || !A || !A.__esModule ? lHA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), co4 = (A) => SEQ(lHA({}, "__esModule", {
    value: !0
  }), A), _EQ = {};
  do4(_EQ, {
    credentialsTreatedAsExpired: () => yEQ,
    credentialsWillNeedRefresh: () => kEQ,
    defaultProvider: () => io4
  });
  xEQ.exports = co4(_EQ);
  var eM1 = xL1(),
    po4 = SG(),
    Zo = j2(),
    PEQ = "AWS_EC2_METADATA_DISABLED",
    lo4 = TuA(async (A) => {
      let {
        ENV_CMDS_FULL_URI: Q,
        ENV_CMDS_RELATIVE_URI: B,
        fromContainerMetadata: G,
        fromInstanceMetadata: Z
      } = await Promise.resolve().then(() => A6A(OV()));
      if (process.env[B] || process.env[Q]) {
        A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        let {
          fromHttp: I
        } = await Promise.resolve().then(() => A6A(fL1()));
        return (0, Zo.chain)(I(A), G(A))
      }
      if (process.env[PEQ] && process.env[PEQ] !== "false") return async () => {
        throw new Zo.CredentialsProviderError("EC2 Instance Metadata Service access disabled", {
          logger: A.logger
        })
      };
      return A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), Z(A)
    }, "remoteProvider"),
    jEQ = !1,
    io4 = TuA((A = {}) => (0, Zo.memoize)((0, Zo.chain)(async () => {
      if (A.profile ?? process.env[po4.ENV_PROFILE]) {
        if (process.env[eM1.ENV_KEY] && process.env[eM1.ENV_SECRET]) {
          if (!jEQ)(A.logger?.warn && A.logger?.constructor?.name !== "NoOpLogger" ? A.logger.warn : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), jEQ = !0
        }
        throw new Zo.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
          logger: A.logger,
          tryNextLink: !0
        })
      }
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), (0, eM1.fromEnv)(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
      let {
        ssoStartUrl: Q,
        ssoAccountId: B,
        ssoRegion: G,
        ssoRoleName: Z,
        ssoSession: I
      } = A;
      if (!Q && !B && !G && !Z && !I) throw new Zo.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", {
        logger: A.logger
      });
      let {
        fromSSO: Y
      } = await Promise.resolve().then(() => A6A(GM1()));
      return Y(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
      let {
        fromIni: Q
      } = await Promise.resolve().then(() => A6A(TEQ()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
      let {
        fromProcess: Q
      } = await Promise.resolve().then(() => A6A(iM1()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
      let {
        fromTokenFile: Q
      } = await Promise.resolve().then(() => A6A(rM1()));
      return Q(A)()
    }, async () => {
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await lo4(A))()
    }, async () => {
      throw new Zo.CredentialsProviderError("Could not load credentials from any providers", {
        tryNextLink: !1,
        logger: A.logger
      })
    }), yEQ, kEQ), "defaultProvider"),
    kEQ = TuA((A) => A?.expiration !== void 0, "credentialsWillNeedRefresh"),
    yEQ = TuA((A) => A?.expiration !== void 0 && A.expiration.getTime() - Date.now() < 300000, "credentialsTreatedAsExpired")
})
// @from(Start 3252504, End 3258679)
tEQ = z((rEQ) => {
  Object.defineProperty(rEQ, "__esModule", {
    value: !0
  });
  rEQ.ruleSet = void 0;
  var iEQ = "required",
    NH = "fn",
    LH = "argv",
    B6A = "ref",
    bEQ = !0,
    fEQ = "isSet",
    aHA = "booleanEquals",
    Q6A = "error",
    vS = "endpoint",
    ev = "tree",
    AO1 = "PartitionResult",
    QO1 = "getAttr",
    iHA = "stringEquals",
    hEQ = {
      [iEQ]: !1,
      type: "String"
    },
    gEQ = {
      [iEQ]: !0,
      default: !1,
      type: "Boolean"
    },
    uEQ = {
      [B6A]: "Endpoint"
    },
    nEQ = {
      [NH]: aHA,
      [LH]: [{
        [B6A]: "UseFIPS"
      }, !0]
    },
    aEQ = {
      [NH]: aHA,
      [LH]: [{
        [B6A]: "UseDualStack"
      }, !0]
    },
    _X = {},
    nHA = {
      [B6A]: "Region"
    },
    mEQ = {
      [NH]: QO1,
      [LH]: [{
        [B6A]: AO1
      }, "supportsFIPS"]
    },
    sEQ = {
      [B6A]: AO1
    },
    dEQ = {
      [NH]: aHA,
      [LH]: [!0, {
        [NH]: QO1,
        [LH]: [sEQ, "supportsDualStack"]
      }]
    },
    cEQ = [nEQ],
    pEQ = [aEQ],
    lEQ = [nHA],
    no4 = {
      version: "1.0",
      parameters: {
        Region: hEQ,
        UseDualStack: gEQ,
        UseFIPS: gEQ,
        Endpoint: hEQ
      },
      rules: [{
        conditions: [{
          [NH]: fEQ,
          [LH]: [uEQ]
        }],
        rules: [{
          conditions: cEQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: Q6A
        }, {
          conditions: pEQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: Q6A
        }, {
          endpoint: {
            url: uEQ,
            properties: _X,
            headers: _X
          },
          type: vS
        }],
        type: ev
      }, {
        conditions: [{
          [NH]: fEQ,
          [LH]: lEQ
        }],
        rules: [{
          conditions: [{
            [NH]: "aws.partition",
            [LH]: lEQ,
            assign: AO1
          }],
          rules: [{
            conditions: [nEQ, aEQ],
            rules: [{
              conditions: [{
                [NH]: aHA,
                [LH]: [bEQ, mEQ]
              }, dEQ],
              rules: [{
                conditions: [{
                  [NH]: iHA,
                  [LH]: [nHA, "us-east-1"]
                }],
                endpoint: {
                  url: "https://cognito-identity-fips.us-east-1.amazonaws.com",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }, {
                conditions: [{
                  [NH]: iHA,
                  [LH]: [nHA, "us-east-2"]
                }],
                endpoint: {
                  url: "https://cognito-identity-fips.us-east-2.amazonaws.com",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }, {
                conditions: [{
                  [NH]: iHA,
                  [LH]: [nHA, "us-west-1"]
                }],
                endpoint: {
                  url: "https://cognito-identity-fips.us-west-1.amazonaws.com",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }, {
                conditions: [{
                  [NH]: iHA,
                  [LH]: [nHA, "us-west-2"]
                }],
                endpoint: {
                  url: "https://cognito-identity-fips.us-west-2.amazonaws.com",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }, {
                endpoint: {
                  url: "https://cognito-identity-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }],
              type: ev
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: Q6A
            }],
            type: ev
          }, {
            conditions: cEQ,
            rules: [{
              conditions: [{
                [NH]: aHA,
                [LH]: [mEQ, bEQ]
              }],
              rules: [{
                endpoint: {
                  url: "https://cognito-identity-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }],
              type: ev
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: Q6A
            }],
            type: ev
          }, {
            conditions: pEQ,
            rules: [{
              conditions: [dEQ],
              rules: [{
                conditions: [{
                  [NH]: iHA,
                  [LH]: ["aws", {
                    [NH]: QO1,
                    [LH]: [sEQ, "name"]
                  }]
                }],
                endpoint: {
                  url: "https://cognito-identity.{Region}.amazonaws.com",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }, {
                endpoint: {
                  url: "https://cognito-identity.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: _X,
                  headers: _X
                },
                type: vS
              }],
              type: ev
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: Q6A
            }],
            type: ev
          }, {
            endpoint: {
              url: "https://cognito-identity.{Region}.{PartitionResult#dnsSuffix}",
              properties: _X,
              headers: _X
            },
            type: vS
          }],
          type: ev
        }],
        type: ev
      }, {
        error: "Invalid Configuration: Missing Region",
        type: Q6A
      }]
    };
  rEQ.ruleSet = no4
})
// @from(Start 3258685, End 3259249)
QzQ = z((eEQ) => {
  Object.defineProperty(eEQ, "__esModule", {
    value: !0
  });
  eEQ.defaultEndpointResolver = void 0;
  var ao4 = S8A(),
    BO1 = FI(),
    so4 = tEQ(),
    ro4 = new BO1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    oo4 = (A, Q = {}) => {
      return ro4.get(A, () => (0, BO1.resolveEndpoint)(so4.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  eEQ.defaultEndpointResolver = oo4;
  BO1.customEndpointFunctions.aws = ao4.awsEndpointFunctions
})
// @from(Start 3259255, End 3260689)
YzQ = z((ZzQ) => {
  Object.defineProperty(ZzQ, "__esModule", {
    value: !0
  });
  ZzQ.getRuntimeConfig = void 0;
  var to4 = TF(),
    eo4 = iB(),
    At4 = r6(),
    Qt4 = NJ(),
    BzQ = Pd(),
    GzQ = O2(),
    Bt4 = yL1(),
    Gt4 = QzQ(),
    Zt4 = (A) => {
      return {
        apiVersion: "2014-06-30",
        base64Decoder: A?.base64Decoder ?? BzQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? BzQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? Gt4.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Bt4.defaultCognitoIdentityHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new to4.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new eo4.NoAuthSigner
        }],
        logger: A?.logger ?? new At4.NoOpLogger,
        serviceId: A?.serviceId ?? "Cognito Identity",
        urlParser: A?.urlParser ?? Qt4.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? GzQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? GzQ.toUtf8
      }
    };
  ZzQ.getRuntimeConfig = Zt4
})
// @from(Start 3260695, End 3263099)
DzQ = z((FzQ) => {
  Object.defineProperty(FzQ, "__esModule", {
    value: !0
  });
  FzQ.getRuntimeConfig = void 0;
  var It4 = rr(),
    Yt4 = It4.__importDefault(CFQ()),
    JzQ = TF(),
    Jt4 = vEQ(),
    WzQ = kHA(),
    PuA = f8(),
    Wt4 = RX(),
    XzQ = D6(),
    Io = uI(),
    VzQ = IZ(),
    Xt4 = TX(),
    Vt4 = KW(),
    Ft4 = YzQ(),
    Kt4 = r6(),
    Dt4 = PX(),
    Ht4 = r6(),
    Ct4 = (A) => {
      (0, Ht4.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, Dt4.resolveDefaultsModeConfig)(A),
        B = () => Q().then(Kt4.loadConfigsForDefaultMode),
        G = (0, Ft4.getRuntimeConfig)(A);
      (0, JzQ.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Io.loadConfig)(JzQ.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? Xt4.calculateBodyLength,
        credentialDefaultProvider: A?.credentialDefaultProvider ?? Jt4.defaultProvider,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, WzQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: Yt4.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, Io.loadConfig)(XzQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Io.loadConfig)(PuA.NODE_REGION_CONFIG_OPTIONS, {
          ...PuA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: VzQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Io.loadConfig)({
          ...XzQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || Vt4.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? Wt4.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? VzQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Io.loadConfig)(PuA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Io.loadConfig)(PuA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Io.loadConfig)(WzQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  FzQ.getRuntimeConfig = Ct4
})
// @from(Start 3263105, End 3305945)
FUQ = z((Fq7, VUQ) => {
  var {
    defineProperty: SuA,
    getOwnPropertyDescriptor: Et4,
    getOwnPropertyNames: zt4
  } = Object, Ut4 = Object.prototype.hasOwnProperty, m0 = (A, Q) => SuA(A, "name", {
    value: Q,
    configurable: !0
  }), $t4 = (A, Q) => {
    for (var B in Q) SuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, wt4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of zt4(Q))
        if (!Ut4.call(A, Z) && Z !== B) SuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Et4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, qt4 = (A) => wt4(SuA({}, "__esModule", {
    value: !0
  }), A), $zQ = {};
  $t4($zQ, {
    AmbiguousRoleResolutionType: () => _t4,
    CognitoIdentity: () => XUQ,
    CognitoIdentityClient: () => ZO1,
    CognitoIdentityServiceException: () => qw,
    ConcurrentModificationException: () => SzQ,
    CreateIdentityPoolCommand: () => mzQ,
    CredentialsFilterSensitiveLog: () => kzQ,
    DeleteIdentitiesCommand: () => dzQ,
    DeleteIdentityPoolCommand: () => czQ,
    DescribeIdentityCommand: () => pzQ,
    DescribeIdentityPoolCommand: () => lzQ,
    DeveloperUserAlreadyRegisteredException: () => jzQ,
    ErrorCode: () => kt4,
    ExternalServiceException: () => TzQ,
    GetCredentialsForIdentityCommand: () => izQ,
    GetCredentialsForIdentityInputFilterSensitiveLog: () => _zQ,
    GetCredentialsForIdentityResponseFilterSensitiveLog: () => yzQ,
    GetIdCommand: () => nzQ,
    GetIdInputFilterSensitiveLog: () => xzQ,
    GetIdentityPoolRolesCommand: () => azQ,
    GetOpenIdTokenCommand: () => szQ,
    GetOpenIdTokenForDeveloperIdentityCommand: () => rzQ,
    GetOpenIdTokenForDeveloperIdentityInputFilterSensitiveLog: () => fzQ,
    GetOpenIdTokenForDeveloperIdentityResponseFilterSensitiveLog: () => hzQ,
    GetOpenIdTokenInputFilterSensitiveLog: () => vzQ,
    GetOpenIdTokenResponseFilterSensitiveLog: () => bzQ,
    GetPrincipalTagAttributeMapCommand: () => ozQ,
    InternalErrorException: () => wzQ,
    InvalidIdentityPoolConfigurationException: () => PzQ,
    InvalidParameterException: () => qzQ,
    LimitExceededException: () => NzQ,
    ListIdentitiesCommand: () => tzQ,
    ListIdentityPoolsCommand: () => IO1,
    ListTagsForResourceCommand: () => ezQ,
    LookupDeveloperIdentityCommand: () => AUQ,
    MappingRuleMatchType: () => yt4,
    MergeDeveloperIdentitiesCommand: () => QUQ,
    NotAuthorizedException: () => LzQ,
    ResourceConflictException: () => MzQ,
    ResourceNotFoundException: () => RzQ,
    RoleMappingType: () => xt4,
    SetIdentityPoolRolesCommand: () => BUQ,
    SetPrincipalTagAttributeMapCommand: () => GUQ,
    TagResourceCommand: () => ZUQ,
    TooManyRequestsException: () => OzQ,
    UnlinkDeveloperIdentityCommand: () => IUQ,
    UnlinkIdentityCommand: () => YUQ,
    UnlinkIdentityInputFilterSensitiveLog: () => gzQ,
    UntagResourceCommand: () => JUQ,
    UpdateIdentityPoolCommand: () => WUQ,
    __Client: () => h0.Client,
    paginateListIdentityPools: () => pe4
  });
  VUQ.exports = qt4($zQ);
  var HzQ = MHA(),
    Nt4 = OHA(),
    Lt4 = RHA(),
    CzQ = b8A(),
    Mt4 = f8(),
    juA = iB(),
    Ot4 = LX(),
    lI = q5(),
    EzQ = D6(),
    zzQ = yL1(),
    Rt4 = m0((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "cognito-identity"
      })
    }, "resolveClientEndpointParameters"),
    hY = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    Tt4 = DzQ(),
    UzQ = xHA(),
    GO1 = iz(),
    h0 = r6(),
    Pt4 = m0((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    jt4 = m0((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    St4 = m0((A, Q) => {
      let B = Object.assign((0, UzQ.getAwsRegionExtensionConfiguration)(A), (0, h0.getDefaultExtensionConfiguration)(A), (0, GO1.getHttpHandlerExtensionConfiguration)(A), Pt4(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, UzQ.resolveAwsRegionExtensionConfiguration)(B), (0, h0.resolveDefaultRuntimeConfig)(B), (0, GO1.resolveHttpHandlerRuntimeConfig)(B), jt4(B))
    }, "resolveRuntimeExtensions"),
    ZO1 = class extends h0.Client {
      static {
        m0(this, "CognitoIdentityClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, Tt4.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = Rt4(Q),
          G = (0, CzQ.resolveUserAgentConfig)(B),
          Z = (0, EzQ.resolveRetryConfig)(G),
          I = (0, Mt4.resolveRegionConfig)(Z),
          Y = (0, HzQ.resolveHostHeaderConfig)(I),
          J = (0, lI.resolveEndpointConfig)(Y),
          W = (0, zzQ.resolveHttpAuthSchemeConfig)(J),
          X = St4(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, CzQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, EzQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, Ot4.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, HzQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, Nt4.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, Lt4.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, juA.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: zzQ.defaultCognitoIdentityHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: m0(async (V) => new juA.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, juA.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    gY = GZ(),
    EW = TF(),
    qw = class A extends h0.ServiceException {
      static {
        m0(this, "CognitoIdentityServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    _t4 = {
      AUTHENTICATED_ROLE: "AuthenticatedRole",
      DENY: "Deny"
    },
    wzQ = class A extends qw {
      static {
        m0(this, "InternalErrorException")
      }
      name = "InternalErrorException";
      $fault = "server";
      constructor(Q) {
        super({
          name: "InternalErrorException",
          $fault: "server",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    qzQ = class A extends qw {
      static {
        m0(this, "InvalidParameterException")
      }
      name = "InvalidParameterException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidParameterException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    NzQ = class A extends qw {
      static {
        m0(this, "LimitExceededException")
      }
      name = "LimitExceededException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "LimitExceededException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    LzQ = class A extends qw {
      static {
        m0(this, "NotAuthorizedException")
      }
      name = "NotAuthorizedException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "NotAuthorizedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    MzQ = class A extends qw {
      static {
        m0(this, "ResourceConflictException")
      }
      name = "ResourceConflictException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ResourceConflictException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    OzQ = class A extends qw {
      static {
        m0(this, "TooManyRequestsException")
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    kt4 = {
      ACCESS_DENIED: "AccessDenied",
      INTERNAL_SERVER_ERROR: "InternalServerError"
    },
    RzQ = class A extends qw {
      static {
        m0(this, "ResourceNotFoundException")
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    TzQ = class A extends qw {
      static {
        m0(this, "ExternalServiceException")
      }
      name = "ExternalServiceException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ExternalServiceException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    PzQ = class A extends qw {
      static {
        m0(this, "InvalidIdentityPoolConfigurationException")
      }
      name = "InvalidIdentityPoolConfigurationException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidIdentityPoolConfigurationException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    yt4 = {
      CONTAINS: "Contains",
      EQUALS: "Equals",
      NOT_EQUAL: "NotEqual",
      STARTS_WITH: "StartsWith"
    },
    xt4 = {
      RULES: "Rules",
      TOKEN: "Token"
    },
    jzQ = class A extends qw {
      static {
        m0(this, "DeveloperUserAlreadyRegisteredException")
      }
      name = "DeveloperUserAlreadyRegisteredException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "DeveloperUserAlreadyRegisteredException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    SzQ = class A extends qw {
      static {
        m0(this, "ConcurrentModificationException")
      }
      name = "ConcurrentModificationException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ConcurrentModificationException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    _zQ = m0((A) => ({
      ...A,
      ...A.Logins && {
        Logins: h0.SENSITIVE_STRING
      }
    }), "GetCredentialsForIdentityInputFilterSensitiveLog"),
    kzQ = m0((A) => ({
      ...A,
      ...A.SecretKey && {
        SecretKey: h0.SENSITIVE_STRING
      }
    }), "CredentialsFilterSensitiveLog"),
    yzQ = m0((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: kzQ(A.Credentials)
      }
    }), "GetCredentialsForIdentityResponseFilterSensitiveLog"),
    xzQ = m0((A) => ({
      ...A,
      ...A.Logins && {
        Logins: h0.SENSITIVE_STRING
      }
    }), "GetIdInputFilterSensitiveLog"),
    vzQ = m0((A) => ({
      ...A,
      ...A.Logins && {
        Logins: h0.SENSITIVE_STRING
      }
    }), "GetOpenIdTokenInputFilterSensitiveLog"),
    bzQ = m0((A) => ({
      ...A,
      ...A.Token && {
        Token: h0.SENSITIVE_STRING
      }
    }), "GetOpenIdTokenResponseFilterSensitiveLog"),
    fzQ = m0((A) => ({
      ...A,
      ...A.Logins && {
        Logins: h0.SENSITIVE_STRING
      }
    }), "GetOpenIdTokenForDeveloperIdentityInputFilterSensitiveLog"),
    hzQ = m0((A) => ({
      ...A,
      ...A.Token && {
        Token: h0.SENSITIVE_STRING
      }
    }), "GetOpenIdTokenForDeveloperIdentityResponseFilterSensitiveLog"),
    gzQ = m0((A) => ({
      ...A,
      ...A.Logins && {
        Logins: h0.SENSITIVE_STRING
      }
    }), "UnlinkIdentityInputFilterSensitiveLog"),
    vt4 = m0(async (A, Q) => {
      let B = iI("CreateIdentityPool"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_CreateIdentityPoolCommand"),
    bt4 = m0(async (A, Q) => {
      let B = iI("DeleteIdentities"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_DeleteIdentitiesCommand"),
    ft4 = m0(async (A, Q) => {
      let B = iI("DeleteIdentityPool"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_DeleteIdentityPoolCommand"),
    ht4 = m0(async (A, Q) => {
      let B = iI("DescribeIdentity"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_DescribeIdentityCommand"),
    gt4 = m0(async (A, Q) => {
      let B = iI("DescribeIdentityPool"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_DescribeIdentityPoolCommand"),
    ut4 = m0(async (A, Q) => {
      let B = iI("GetCredentialsForIdentity"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_GetCredentialsForIdentityCommand"),
    mt4 = m0(async (A, Q) => {
      let B = iI("GetId"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_GetIdCommand"),
    dt4 = m0(async (A, Q) => {
      let B = iI("GetIdentityPoolRoles"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_GetIdentityPoolRolesCommand"),
    ct4 = m0(async (A, Q) => {
      let B = iI("GetOpenIdToken"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_GetOpenIdTokenCommand"),
    pt4 = m0(async (A, Q) => {
      let B = iI("GetOpenIdTokenForDeveloperIdentity"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_GetOpenIdTokenForDeveloperIdentityCommand"),
    lt4 = m0(async (A, Q) => {
      let B = iI("GetPrincipalTagAttributeMap"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_GetPrincipalTagAttributeMapCommand"),
    it4 = m0(async (A, Q) => {
      let B = iI("ListIdentities"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_ListIdentitiesCommand"),
    nt4 = m0(async (A, Q) => {
      let B = iI("ListIdentityPools"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_ListIdentityPoolsCommand"),
    at4 = m0(async (A, Q) => {
      let B = iI("ListTagsForResource"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_ListTagsForResourceCommand"),
    st4 = m0(async (A, Q) => {
      let B = iI("LookupDeveloperIdentity"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_LookupDeveloperIdentityCommand"),
    rt4 = m0(async (A, Q) => {
      let B = iI("MergeDeveloperIdentities"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_MergeDeveloperIdentitiesCommand"),
    ot4 = m0(async (A, Q) => {
      let B = iI("SetIdentityPoolRoles"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_SetIdentityPoolRolesCommand"),
    tt4 = m0(async (A, Q) => {
      let B = iI("SetPrincipalTagAttributeMap"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_SetPrincipalTagAttributeMapCommand"),
    et4 = m0(async (A, Q) => {
      let B = iI("TagResource"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_TagResourceCommand"),
    Ae4 = m0(async (A, Q) => {
      let B = iI("UnlinkDeveloperIdentity"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_UnlinkDeveloperIdentityCommand"),
    Qe4 = m0(async (A, Q) => {
      let B = iI("UnlinkIdentity"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_UnlinkIdentityCommand"),
    Be4 = m0(async (A, Q) => {
      let B = iI("UntagResource"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_UntagResourceCommand"),
    Ge4 = m0(async (A, Q) => {
      let B = iI("UpdateIdentityPool"),
        G;
      return G = JSON.stringify((0, h0._json)(A)), mY(Q, B, "/", void 0, G)
    }, "se_UpdateIdentityPoolCommand"),
    Ze4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_CreateIdentityPoolCommand"),
    Ie4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_DeleteIdentitiesCommand"),
    Ye4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      return await (0, h0.collectBody)(A.body, Q), {
        $metadata: Y3(A)
      }
    }, "de_DeleteIdentityPoolCommand"),
    Je4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = uzQ(B, Q), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_DescribeIdentityCommand"),
    We4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_DescribeIdentityPoolCommand"),
    Xe4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = ge4(B, Q), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_GetCredentialsForIdentityCommand"),
    Ve4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_GetIdCommand"),
    Fe4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_GetIdentityPoolRolesCommand"),
    Ke4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_GetOpenIdTokenCommand"),
    De4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_GetOpenIdTokenForDeveloperIdentityCommand"),
    He4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_GetPrincipalTagAttributeMapCommand"),
    Ce4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = me4(B, Q), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_ListIdentitiesCommand"),
    Ee4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_ListIdentityPoolsCommand"),
    ze4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_ListTagsForResourceCommand"),
    Ue4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_LookupDeveloperIdentityCommand"),
    $e4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_MergeDeveloperIdentitiesCommand"),
    we4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      return await (0, h0.collectBody)(A.body, Q), {
        $metadata: Y3(A)
      }
    }, "de_SetIdentityPoolRolesCommand"),
    qe4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_SetPrincipalTagAttributeMapCommand"),
    Ne4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_TagResourceCommand"),
    Le4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      return await (0, h0.collectBody)(A.body, Q), {
        $metadata: Y3(A)
      }
    }, "de_UnlinkDeveloperIdentityCommand"),
    Me4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      return await (0, h0.collectBody)(A.body, Q), {
        $metadata: Y3(A)
      }
    }, "de_UnlinkIdentityCommand"),
    Oe4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_UntagResourceCommand"),
    Re4 = m0(async (A, Q) => {
      if (A.statusCode >= 300) return uY(A, Q);
      let B = await (0, EW.parseJsonBody)(A.body, Q),
        G = {};
      return G = (0, h0._json)(B), {
        $metadata: Y3(A),
        ...G
      }
    }, "de_UpdateIdentityPoolCommand"),
    uY = m0(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, EW.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, EW.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentity#InternalErrorException":
          throw await Se4(B, Q);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentity#InvalidParameterException":
          throw await ke4(B, Q);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentity#LimitExceededException":
          throw await ye4(B, Q);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentity#NotAuthorizedException":
          throw await xe4(B, Q);
        case "ResourceConflictException":
        case "com.amazonaws.cognitoidentity#ResourceConflictException":
          throw await ve4(B, Q);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentity#TooManyRequestsException":
          throw await fe4(B, Q);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
          throw await be4(B, Q);
        case "ExternalServiceException":
        case "com.amazonaws.cognitoidentity#ExternalServiceException":
          throw await je4(B, Q);
        case "InvalidIdentityPoolConfigurationException":
        case "com.amazonaws.cognitoidentity#InvalidIdentityPoolConfigurationException":
          throw await _e4(B, Q);
        case "DeveloperUserAlreadyRegisteredException":
        case "com.amazonaws.cognitoidentity#DeveloperUserAlreadyRegisteredException":
          throw await Pe4(B, Q);
        case "ConcurrentModificationException":
        case "com.amazonaws.cognitoidentity#ConcurrentModificationException":
          throw await Te4(B, Q);
        default:
          let Z = B.body;
          return de4({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    Te4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new SzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_ConcurrentModificationExceptionRes"),
    Pe4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new jzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_DeveloperUserAlreadyRegisteredExceptionRes"),
    je4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new TzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_ExternalServiceExceptionRes"),
    Se4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new wzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_InternalErrorExceptionRes"),
    _e4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new PzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_InvalidIdentityPoolConfigurationExceptionRes"),
    ke4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new qzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_InvalidParameterExceptionRes"),
    ye4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new NzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_LimitExceededExceptionRes"),
    xe4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new LzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_NotAuthorizedExceptionRes"),
    ve4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new MzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_ResourceConflictExceptionRes"),
    be4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new RzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_ResourceNotFoundExceptionRes"),
    fe4 = m0(async (A, Q) => {
      let B = A.body,
        G = (0, h0._json)(B),
        Z = new OzQ({
          $metadata: Y3(A),
          ...G
        });
      return (0, h0.decorateServiceException)(Z, B)
    }, "de_TooManyRequestsExceptionRes"),
    he4 = m0((A, Q) => {
      return (0, h0.take)(A, {
        AccessKeyId: h0.expectString,
        Expiration: m0((B) => (0, h0.expectNonNull)((0, h0.parseEpochTimestamp)((0, h0.expectNumber)(B))), "Expiration"),
        SecretKey: h0.expectString,
        SessionToken: h0.expectString
      })
    }, "de_Credentials"),
    ge4 = m0((A, Q) => {
      return (0, h0.take)(A, {
        Credentials: m0((B) => he4(B, Q), "Credentials"),
        IdentityId: h0.expectString
      })
    }, "de_GetCredentialsForIdentityResponse"),
    ue4 = m0((A, Q) => {
      return (A || []).filter((G) => G != null).map((G) => {
        return uzQ(G, Q)
      })
    }, "de_IdentitiesList"),
    uzQ = m0((A, Q) => {
      return (0, h0.take)(A, {
        CreationDate: m0((B) => (0, h0.expectNonNull)((0, h0.parseEpochTimestamp)((0, h0.expectNumber)(B))), "CreationDate"),
        IdentityId: h0.expectString,
        LastModifiedDate: m0((B) => (0, h0.expectNonNull)((0, h0.parseEpochTimestamp)((0, h0.expectNumber)(B))), "LastModifiedDate"),
        Logins: h0._json
      })
    }, "de_IdentityDescription"),
    me4 = m0((A, Q) => {
      return (0, h0.take)(A, {
        Identities: m0((B) => ue4(B, Q), "Identities"),
        IdentityPoolId: h0.expectString,
        NextToken: h0.expectString
      })
    }, "de_ListIdentitiesResponse"),
    Y3 = m0((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    de4 = (0, h0.withBaseException)(qw),
    mY = m0(async (A, Q, B, G, Z) => {
      let {
        hostname: I,
        protocol: Y = "https",
        port: J,
        path: W
      } = await A.endpoint(), X = {
        protocol: Y,
        hostname: I,
        port: J,
        method: "POST",
        path: W.endsWith("/") ? W.slice(0, -1) + B : W + B,
        headers: Q
      };
      if (G !== void 0) X.hostname = G;
      if (Z !== void 0) X.body = Z;
      return new GO1.HttpRequest(X)
    }, "buildHttpRpcRequest");

  function iI(A) {
    return {
      "content-type": "application/x-amz-json-1.1",
      "x-amz-target": `AWSCognitoIdentityService.${A}`
    }
  }
  m0(iI, "sharedHeaders");
  var mzQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "CreateIdentityPool", {}).n("CognitoIdentityClient", "CreateIdentityPoolCommand").f(void 0, void 0).ser(vt4).de(Ze4).build() {
      static {
        m0(this, "CreateIdentityPoolCommand")
      }
    },
    dzQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "DeleteIdentities", {}).n("CognitoIdentityClient", "DeleteIdentitiesCommand").f(void 0, void 0).ser(bt4).de(Ie4).build() {
      static {
        m0(this, "DeleteIdentitiesCommand")
      }
    },
    czQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "DeleteIdentityPool", {}).n("CognitoIdentityClient", "DeleteIdentityPoolCommand").f(void 0, void 0).ser(ft4).de(Ye4).build() {
      static {
        m0(this, "DeleteIdentityPoolCommand")
      }
    },
    pzQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "DescribeIdentity", {}).n("CognitoIdentityClient", "DescribeIdentityCommand").f(void 0, void 0).ser(ht4).de(Je4).build() {
      static {
        m0(this, "DescribeIdentityCommand")
      }
    },
    lzQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "DescribeIdentityPool", {}).n("CognitoIdentityClient", "DescribeIdentityPoolCommand").f(void 0, void 0).ser(gt4).de(We4).build() {
      static {
        m0(this, "DescribeIdentityPoolCommand")
      }
    },
    izQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "GetCredentialsForIdentity", {}).n("CognitoIdentityClient", "GetCredentialsForIdentityCommand").f(_zQ, yzQ).ser(ut4).de(Xe4).build() {
      static {
        m0(this, "GetCredentialsForIdentityCommand")
      }
    },
    nzQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "GetId", {}).n("CognitoIdentityClient", "GetIdCommand").f(xzQ, void 0).ser(mt4).de(Ve4).build() {
      static {
        m0(this, "GetIdCommand")
      }
    },
    azQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "GetIdentityPoolRoles", {}).n("CognitoIdentityClient", "GetIdentityPoolRolesCommand").f(void 0, void 0).ser(dt4).de(Fe4).build() {
      static {
        m0(this, "GetIdentityPoolRolesCommand")
      }
    },
    szQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "GetOpenIdToken", {}).n("CognitoIdentityClient", "GetOpenIdTokenCommand").f(vzQ, bzQ).ser(ct4).de(Ke4).build() {
      static {
        m0(this, "GetOpenIdTokenCommand")
      }
    },
    rzQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "GetOpenIdTokenForDeveloperIdentity", {}).n("CognitoIdentityClient", "GetOpenIdTokenForDeveloperIdentityCommand").f(fzQ, hzQ).ser(pt4).de(De4).build() {
      static {
        m0(this, "GetOpenIdTokenForDeveloperIdentityCommand")
      }
    },
    ozQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "GetPrincipalTagAttributeMap", {}).n("CognitoIdentityClient", "GetPrincipalTagAttributeMapCommand").f(void 0, void 0).ser(lt4).de(He4).build() {
      static {
        m0(this, "GetPrincipalTagAttributeMapCommand")
      }
    },
    tzQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "ListIdentities", {}).n("CognitoIdentityClient", "ListIdentitiesCommand").f(void 0, void 0).ser(it4).de(Ce4).build() {
      static {
        m0(this, "ListIdentitiesCommand")
      }
    },
    IO1 = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "ListIdentityPools", {}).n("CognitoIdentityClient", "ListIdentityPoolsCommand").f(void 0, void 0).ser(nt4).de(Ee4).build() {
      static {
        m0(this, "ListIdentityPoolsCommand")
      }
    },
    ezQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "ListTagsForResource", {}).n("CognitoIdentityClient", "ListTagsForResourceCommand").f(void 0, void 0).ser(at4).de(ze4).build() {
      static {
        m0(this, "ListTagsForResourceCommand")
      }
    },
    AUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "LookupDeveloperIdentity", {}).n("CognitoIdentityClient", "LookupDeveloperIdentityCommand").f(void 0, void 0).ser(st4).de(Ue4).build() {
      static {
        m0(this, "LookupDeveloperIdentityCommand")
      }
    },
    QUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "MergeDeveloperIdentities", {}).n("CognitoIdentityClient", "MergeDeveloperIdentitiesCommand").f(void 0, void 0).ser(rt4).de($e4).build() {
      static {
        m0(this, "MergeDeveloperIdentitiesCommand")
      }
    },
    BUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "SetIdentityPoolRoles", {}).n("CognitoIdentityClient", "SetIdentityPoolRolesCommand").f(void 0, void 0).ser(ot4).de(we4).build() {
      static {
        m0(this, "SetIdentityPoolRolesCommand")
      }
    },
    GUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "SetPrincipalTagAttributeMap", {}).n("CognitoIdentityClient", "SetPrincipalTagAttributeMapCommand").f(void 0, void 0).ser(tt4).de(qe4).build() {
      static {
        m0(this, "SetPrincipalTagAttributeMapCommand")
      }
    },
    ZUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "TagResource", {}).n("CognitoIdentityClient", "TagResourceCommand").f(void 0, void 0).ser(et4).de(Ne4).build() {
      static {
        m0(this, "TagResourceCommand")
      }
    },
    IUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "UnlinkDeveloperIdentity", {}).n("CognitoIdentityClient", "UnlinkDeveloperIdentityCommand").f(void 0, void 0).ser(Ae4).de(Le4).build() {
      static {
        m0(this, "UnlinkDeveloperIdentityCommand")
      }
    },
    YUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "UnlinkIdentity", {}).n("CognitoIdentityClient", "UnlinkIdentityCommand").f(gzQ, void 0).ser(Qe4).de(Me4).build() {
      static {
        m0(this, "UnlinkIdentityCommand")
      }
    },
    JUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "UntagResource", {}).n("CognitoIdentityClient", "UntagResourceCommand").f(void 0, void 0).ser(Be4).de(Oe4).build() {
      static {
        m0(this, "UntagResourceCommand")
      }
    },
    WUQ = class extends h0.Command.classBuilder().ep(hY).m(function(A, Q, B, G) {
      return [(0, gY.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lI.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSCognitoIdentityService", "UpdateIdentityPool", {}).n("CognitoIdentityClient", "UpdateIdentityPoolCommand").f(void 0, void 0).ser(Ge4).de(Re4).build() {
      static {
        m0(this, "UpdateIdentityPoolCommand")
      }
    },
    ce4 = {
      CreateIdentityPoolCommand: mzQ,
      DeleteIdentitiesCommand: dzQ,
      DeleteIdentityPoolCommand: czQ,
      DescribeIdentityCommand: pzQ,
      DescribeIdentityPoolCommand: lzQ,
      GetCredentialsForIdentityCommand: izQ,
      GetIdCommand: nzQ,
      GetIdentityPoolRolesCommand: azQ,
      GetOpenIdTokenCommand: szQ,
      GetOpenIdTokenForDeveloperIdentityCommand: rzQ,
      GetPrincipalTagAttributeMapCommand: ozQ,
      ListIdentitiesCommand: tzQ,
      ListIdentityPoolsCommand: IO1,
      ListTagsForResourceCommand: ezQ,
      LookupDeveloperIdentityCommand: AUQ,
      MergeDeveloperIdentitiesCommand: QUQ,
      SetIdentityPoolRolesCommand: BUQ,
      SetPrincipalTagAttributeMapCommand: GUQ,
      TagResourceCommand: ZUQ,
      UnlinkDeveloperIdentityCommand: IUQ,
      UnlinkIdentityCommand: YUQ,
      UntagResourceCommand: JUQ,
      UpdateIdentityPoolCommand: WUQ
    },
    XUQ = class extends ZO1 {
      static {
        m0(this, "CognitoIdentity")
      }
    };
  (0, h0.createAggregatedClient)(ce4, XUQ);
  var pe4 = (0, juA.createPaginator)(ZO1, IO1, "NextToken", "NextToken", "MaxResults")
})
// @from(Start 3305951, End 3313370)
VO1 = z((fq7, NUQ) => {
  var {
    defineProperty: kuA,
    getOwnPropertyDescriptor: le4,
    getOwnPropertyNames: KUQ
  } = Object, ie4 = Object.prototype.hasOwnProperty, Nw = (A, Q) => kuA(A, "name", {
    value: Q,
    configurable: !0
  }), ne4 = (A, Q) => function() {
    return A && (Q = (0, A[KUQ(A)[0]])(A = 0)), Q
  }, DUQ = (A, Q) => {
    for (var B in Q) kuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ae4 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of KUQ(Q))
        if (!ie4.call(A, Z) && Z !== B) kuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = le4(Q, Z)) || G.enumerable
        })
    }
    return A
  }, se4 = (A) => ae4(kuA({}, "__esModule", {
    value: !0
  }), A), JO1 = {};
  DUQ(JO1, {
    CognitoIdentityClient: () => _uA.CognitoIdentityClient,
    GetCredentialsForIdentityCommand: () => _uA.GetCredentialsForIdentityCommand,
    GetIdCommand: () => _uA.GetIdCommand
  });
  var _uA, HUQ = ne4({
      "src/loadCognitoIdentity.ts"() {
        _uA = FUQ()
      }
    }),
    CUQ = {};
  DUQ(CUQ, {
    fromCognitoIdentity: () => XO1,
    fromCognitoIdentityPool: () => wUQ
  });
  NUQ.exports = se4(CUQ);
  var yuA = j2();

  function WO1(A) {
    return Promise.all(Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      if (typeof G === "string") Q.push([B, G]);
      else Q.push(G().then((Z) => [B, Z]));
      return Q
    }, [])).then((Q) => Q.reduce((B, [G, Z]) => {
      return B[G] = Z, B
    }, {}))
  }
  Nw(WO1, "resolveLogins");

  function XO1(A) {
    return async (Q) => {
      A.logger?.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
      let {
        GetCredentialsForIdentityCommand: B,
        CognitoIdentityClient: G
      } = await Promise.resolve().then(() => (HUQ(), JO1)), Z = Nw((X) => A.clientConfig?.[X] ?? A.parentClientConfig?.[X] ?? Q?.callerClientConfig?.[X], "fromConfigs"), {
        Credentials: {
          AccessKeyId: I = EUQ(A.logger),
          Expiration: Y,
          SecretKey: J = UUQ(A.logger),
          SessionToken: W
        } = zUQ(A.logger)
      } = await (A.client ?? new G(Object.assign({}, A.clientConfig ?? {}, {
        region: Z("region"),
        profile: Z("profile")
      }))).send(new B({
        CustomRoleArn: A.customRoleArn,
        IdentityId: A.identityId,
        Logins: A.logins ? await WO1(A.logins) : void 0
      }));
      return {
        identityId: A.identityId,
        accessKeyId: I,
        secretAccessKey: J,
        sessionToken: W,
        expiration: Y
      }
    }
  }
  Nw(XO1, "fromCognitoIdentity");

  function EUQ(A) {
    throw new yuA.CredentialsProviderError("Response from Amazon Cognito contained no access key ID", {
      logger: A
    })
  }
  Nw(EUQ, "throwOnMissingAccessKeyId");

  function zUQ(A) {
    throw new yuA.CredentialsProviderError("Response from Amazon Cognito contained no credentials", {
      logger: A
    })
  }
  Nw(zUQ, "throwOnMissingCredentials");

  function UUQ(A) {
    throw new yuA.CredentialsProviderError("Response from Amazon Cognito contained no secret key", {
      logger: A
    })
  }
  Nw(UUQ, "throwOnMissingSecretKey");
  var YO1 = "IdentityIds",
    re4 = class {
      constructor(A = "aws:cognito-identity-ids") {
        this.dbName = A
      }
      static {
        Nw(this, "IndexedDbStorage")
      }
      getItem(A) {
        return this.withObjectStore("readonly", (Q) => {
          let B = Q.get(A);
          return new Promise((G) => {
            B.onerror = () => G(null), B.onsuccess = () => G(B.result ? B.result.value : null)
          })
        }).catch(() => null)
      }
      removeItem(A) {
        return this.withObjectStore("readwrite", (Q) => {
          let B = Q.delete(A);
          return new Promise((G, Z) => {
            B.onerror = () => Z(B.error), B.onsuccess = () => G()
          })
        })
      }
      setItem(A, Q) {
        return this.withObjectStore("readwrite", (B) => {
          let G = B.put({
            id: A,
            value: Q
          });
          return new Promise((Z, I) => {
            G.onerror = () => I(G.error), G.onsuccess = () => Z()
          })
        })
      }
      getDb() {
        let A = self.indexedDB.open(this.dbName, 1);
        return new Promise((Q, B) => {
          A.onsuccess = () => {
            Q(A.result)
          }, A.onerror = () => {
            B(A.error)
          }, A.onblocked = () => {
            B(Error("Unable to access DB"))
          }, A.onupgradeneeded = () => {
            let G = A.result;
            G.onerror = () => {
              B(Error("Failed to create object store"))
            }, G.createObjectStore(YO1, {
              keyPath: "id"
            })
          }
        })
      }
      withObjectStore(A, Q) {
        return this.getDb().then((B) => {
          let G = B.transaction(YO1, A);
          return G.oncomplete = () => B.close(), new Promise((Z, I) => {
            G.onerror = () => I(G.error), Z(Q(G.objectStore(YO1)))
          }).catch((Z) => {
            throw B.close(), Z
          })
        })
      }
    },
    oe4 = class {
      constructor(A = {}) {
        this.store = A
      }
      static {
        Nw(this, "InMemoryStorage")
      }
      getItem(A) {
        if (A in this.store) return this.store[A];
        return null
      }
      removeItem(A) {
        delete this.store[A]
      }
      setItem(A, Q) {
        this.store[A] = Q
      }
    },
    te4 = new oe4;

  function $UQ() {
    if (typeof self === "object" && self.indexedDB) return new re4;
    if (typeof window === "object" && window.localStorage) return window.localStorage;
    return te4
  }
  Nw($UQ, "localStorage");

  function wUQ({
    accountId: A,
    cache: Q = $UQ(),
    client: B,
    clientConfig: G,
    customRoleArn: Z,
    identityPoolId: I,
    logins: Y,
    userIdentifier: J = !Y || Object.keys(Y).length === 0 ? "ANONYMOUS" : void 0,
    logger: W,
    parentClientConfig: X
  }) {
    W?.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
    let V = J ? `aws:cognito-identity-credentials:${I}:${J}` : void 0,
      F = Nw(async (K) => {
        let {
          GetIdCommand: D,
          CognitoIdentityClient: H
        } = await Promise.resolve().then(() => (HUQ(), JO1)), C = Nw((q) => G?.[q] ?? X?.[q] ?? K?.callerClientConfig?.[q], "fromConfigs"), E = B ?? new H(Object.assign({}, G ?? {}, {
          region: C("region"),
          profile: C("profile")
        })), U = V && await Q.getItem(V);
        if (!U) {
          let {
            IdentityId: q = qUQ(W)
          } = await E.send(new D({
            AccountId: A,
            IdentityPoolId: I,
            Logins: Y ? await WO1(Y) : void 0
          }));
          if (U = q, V) Promise.resolve(Q.setItem(V, U)).catch(() => {})
        }
        return F = XO1({
          client: E,
          customRoleArn: Z,
          logins: Y,
          identityId: U
        }), F(K)
      }, "provider");
    return (K) => F(K).catch(async (D) => {
      if (V) Promise.resolve(Q.removeItem(V)).catch(() => {});
      throw D
    })
  }
  Nw(wUQ, "fromCognitoIdentityPool");

  function qUQ(A) {
    throw new yuA.CredentialsProviderError("Response from Amazon Cognito contained no identity ID", {
      logger: A
    })
  }
  Nw(qUQ, "throwOnMissingId")
})
// @from(Start 3313376, End 3313616)
OUQ = z((LUQ) => {
  Object.defineProperty(LUQ, "__esModule", {
    value: !0
  });
  LUQ.fromCognitoIdentity = void 0;
  var ee4 = VO1(),
    AA8 = (A) => (0, ee4.fromCognitoIdentity)({
      ...A
    });
  LUQ.fromCognitoIdentity = AA8
})
// @from(Start 3313622, End 3313874)
PUQ = z((RUQ) => {
  Object.defineProperty(RUQ, "__esModule", {
    value: !0
  });
  RUQ.fromCognitoIdentityPool = void 0;
  var QA8 = VO1(),
    BA8 = (A) => (0, QA8.fromCognitoIdentityPool)({
      ...A
    });
  RUQ.fromCognitoIdentityPool = BA8
})
// @from(Start 3313880, End 3314208)
_UQ = z((jUQ) => {
  Object.defineProperty(jUQ, "__esModule", {
    value: !0
  });
  jUQ.fromContainerMetadata = void 0;
  var GA8 = OV(),
    ZA8 = (A) => {
      return A?.logger?.debug("@smithy/credential-provider-imds", "fromContainerMetadata"), (0, GA8.fromContainerMetadata)(A)
    };
  jUQ.fromContainerMetadata = ZA8
})
// @from(Start 3314214, End 3316197)
LL = z((cq7, bUQ) => {
  var {
    defineProperty: xuA,
    getOwnPropertyDescriptor: IA8,
    getOwnPropertyNames: YA8
  } = Object, JA8 = Object.prototype.hasOwnProperty, vuA = (A, Q) => xuA(A, "name", {
    value: Q,
    configurable: !0
  }), WA8 = (A, Q) => {
    for (var B in Q) xuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, XA8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of YA8(Q))
        if (!JA8.call(A, Z) && Z !== B) xuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = IA8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, VA8 = (A) => XA8(xuA({}, "__esModule", {
    value: !0
  }), A), kUQ = {};
  WA8(kUQ, {
    emitWarningIfUnsupportedVersion: () => FA8,
    setCredentialFeature: () => yUQ,
    setFeature: () => xUQ,
    setTokenFeature: () => vUQ,
    state: () => FO1
  });
  bUQ.exports = VA8(kUQ);
  var FO1 = {
      warningEmitted: !1
    },
    FA8 = vuA((A) => {
      if (A && !FO1.warningEmitted && parseInt(A.substring(1, A.indexOf("."))) < 18) FO1.warningEmitted = !0, process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`)
    }, "emitWarningIfUnsupportedVersion");

  function yUQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  vuA(yUQ, "setCredentialFeature");

  function xUQ(A, Q, B) {
    if (!A.__aws_sdk_context) A.__aws_sdk_context = {
      features: {}
    };
    else if (!A.__aws_sdk_context.features) A.__aws_sdk_context.features = {};
    A.__aws_sdk_context.features[Q] = B
  }
  vuA(xUQ, "setFeature");

  function vUQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  vuA(vUQ, "setTokenFeature")
})
// @from(Start 3316203, End 3317326)
gUQ = z((fUQ) => {
  Object.defineProperty(fUQ, "__esModule", {
    value: !0
  });
  fUQ.checkUrl = void 0;
  var KA8 = j2(),
    DA8 = "169.254.170.2",
    HA8 = "169.254.170.23",
    CA8 = "[fd00:ec2::23]",
    EA8 = (A, Q) => {
      if (A.protocol === "https:") return;
      if (A.hostname === DA8 || A.hostname === HA8 || A.hostname === CA8) return;
      if (A.hostname.includes("[")) {
        if (A.hostname === "[::1]" || A.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") return
      } else {
        if (A.hostname === "localhost") return;
        let B = A.hostname.split("."),
          G = (Z) => {
            let I = parseInt(Z, 10);
            return 0 <= I && I <= 255
          };
        if (B[0] === "127" && G(B[1]) && G(B[2]) && G(B[3]) && B.length === 4) return
      }
      throw new KA8.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, {
        logger: Q
      })
    };
  fUQ.checkUrl = EA8
})
// @from(Start 3317332, End 3320115)
KO1 = z((lq7, aUQ) => {
  var {
    defineProperty: buA,
    getOwnPropertyDescriptor: zA8,
    getOwnPropertyNames: UA8
  } = Object, $A8 = Object.prototype.hasOwnProperty, fuA = (A, Q) => buA(A, "name", {
    value: Q,
    configurable: !0
  }), wA8 = (A, Q) => {
    for (var B in Q) buA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, qA8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of UA8(Q))
        if (!$A8.call(A, Z) && Z !== B) buA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = zA8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, NA8 = (A) => qA8(buA({}, "__esModule", {
    value: !0
  }), A), uUQ = {};
  wA8(uUQ, {
    AlgorithmId: () => pUQ,
    EndpointURLScheme: () => cUQ,
    FieldPosition: () => lUQ,
    HttpApiKeyAuthLocation: () => dUQ,
    HttpAuthLocation: () => mUQ,
    IniSectionType: () => iUQ,
    RequestHandlerProtocol: () => nUQ,
    SMITHY_CONTEXT_KEY: () => TA8,
    getDefaultClientConfiguration: () => OA8,
    resolveDefaultRuntimeConfig: () => RA8
  });
  aUQ.exports = NA8(uUQ);
  var mUQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(mUQ || {}),
    dUQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(dUQ || {}),
    cUQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(cUQ || {}),
    pUQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(pUQ || {}),
    LA8 = fuA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    MA8 = fuA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    OA8 = fuA((A) => {
      return LA8(A)
    }, "getDefaultClientConfiguration"),
    RA8 = fuA((A) => {
      return MA8(A)
    }, "resolveDefaultRuntimeConfig"),
    lUQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(lUQ || {}),
    TA8 = "__smithy_context",
    iUQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(iUQ || {}),
    nUQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(nUQ || {})
})
// @from(Start 3320121, End 3324627)
Lw = z((iq7, eUQ) => {
  var {
    defineProperty: huA,
    getOwnPropertyDescriptor: PA8,
    getOwnPropertyNames: jA8
  } = Object, SA8 = Object.prototype.hasOwnProperty, vd = (A, Q) => huA(A, "name", {
    value: Q,
    configurable: !0
  }), _A8 = (A, Q) => {
    for (var B in Q) huA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, kA8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of jA8(Q))
        if (!SA8.call(A, Z) && Z !== B) huA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = PA8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, yA8 = (A) => kA8(huA({}, "__esModule", {
    value: !0
  }), A), sUQ = {};
  _A8(sUQ, {
    Field: () => bA8,
    Fields: () => fA8,
    HttpRequest: () => hA8,
    HttpResponse: () => gA8,
    IHttpRequest: () => rUQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => xA8,
    isValidHostname: () => tUQ,
    resolveHttpHandlerRuntimeConfig: () => vA8
  });
  eUQ.exports = yA8(sUQ);
  var xA8 = vd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    vA8 = vd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    rUQ = KO1(),
    bA8 = class {
      static {
        vd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = rUQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    fA8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        vd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    hA8 = class A {
      static {
        vd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = oUQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function oUQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  vd(oUQ, "cloneQuery");
  var gA8 = class {
    static {
      vd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function tUQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  vd(tUQ, "isValidHostname")
})
// @from(Start 3324633, End 3338657)
S3 = z((rq7, $O1) => {
  var {
    defineProperty: guA,
    getOwnPropertyDescriptor: uA8,
    getOwnPropertyNames: mA8
  } = Object, dA8 = Object.prototype.hasOwnProperty, j3 = (A, Q) => guA(A, "name", {
    value: Q,
    configurable: !0
  }), cA8 = (A, Q) => {
    for (var B in Q) guA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, HO1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of mA8(Q))
        if (!dA8.call(A, Z) && Z !== B) guA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = uA8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, pA8 = (A, Q, B) => (HO1(A, Q, "default"), B && HO1(B, Q, "default")), lA8 = (A) => HO1(guA({}, "__esModule", {
    value: !0
  }), A), zO1 = {};
  cA8(zO1, {
    Client: () => iA8,
    Command: () => B$Q,
    NoOpLogger: () => X18,
    SENSITIVE_STRING: () => aA8,
    ServiceException: () => rA8,
    _json: () => EO1,
    collectBody: () => DO1.collectBody,
    convertMap: () => V18,
    createAggregatedClient: () => sA8,
    decorateServiceException: () => G$Q,
    emitWarningIfUnsupportedVersion: () => A18,
    extendedEncodeURIComponent: () => DO1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => J18,
    getDefaultClientConfiguration: () => I18,
    getDefaultExtensionConfiguration: () => I$Q,
    getValueFromTextNode: () => Y$Q,
    isSerializableHeaderValue: () => W18,
    loadConfigsForDefaultMode: () => eA8,
    map: () => UO1,
    resolveDefaultRuntimeConfig: () => Y18,
    resolvedPath: () => DO1.resolvedPath,
    serializeDateTime: () => E18,
    serializeFloat: () => C18,
    take: () => F18,
    throwDefaultError: () => Z$Q,
    withBaseException: () => oA8
  });
  $O1.exports = lA8(zO1);
  var Q$Q = uR(),
    iA8 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, Q$Q.constructStack)()
      }
      static {
        j3(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    DO1 = w5(),
    CO1 = KO1(),
    B$Q = class {
      constructor() {
        this.middlewareStack = (0, Q$Q.constructStack)()
      }
      static {
        j3(this, "Command")
      }
      static classBuilder() {
        return new nA8
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [CO1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    nA8 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        j3(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      sc(A) {
        return this._operationSchema = A, this._smithyContext.operationSchema = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends B$Q {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this), this.schema = A._operationSchema
          }
          static {
            j3(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    aA8 = "***SensitiveInformation***",
    sA8 = j3((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = j3(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    rA8 = class A extends Error {
      static {
        j3(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    G$Q = j3((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    Z$Q = j3(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = tA8(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw G$Q(Y, Q)
    }, "throwDefaultError"),
    oA8 = j3((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        Z$Q({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    tA8 = j3((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    eA8 = j3((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    A$Q = !1,
    A18 = j3((A) => {
      if (A && !A$Q && parseInt(A.substring(1, A.indexOf("."))) < 16) A$Q = !0
    }, "emitWarningIfUnsupportedVersion"),
    Q18 = j3((A) => {
      let Q = [];
      for (let B in CO1.AlgorithmId) {
        let G = CO1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    B18 = j3((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    G18 = j3((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    Z18 = j3((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    I$Q = j3((A) => {
      return Object.assign(Q18(A), G18(A))
    }, "getDefaultExtensionConfiguration"),
    I18 = I$Q,
    Y18 = j3((A) => {
      return Object.assign(B18(A), Z18(A))
    }, "resolveDefaultRuntimeConfig"),
    J18 = j3((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    Y$Q = j3((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = Y$Q(A[B]);
      return A
    }, "getValueFromTextNode"),
    W18 = j3((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    X18 = class {
      static {
        j3(this, "NoOpLogger")
      }
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };

  function UO1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, K18(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      J$Q(G, null, I, Y)
    }
    return G
  }
  j3(UO1, "map");
  var V18 = j3((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    F18 = j3((A, Q) => {
      let B = {};
      for (let G in Q) J$Q(B, A, Q, G);
      return B
    }, "take"),
    K18 = j3((A, Q, B) => {
      return UO1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    J$Q = j3((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = D18, W = H18, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    D18 = j3((A) => A != null, "nonNullish"),
    H18 = j3((A) => A, "pass"),
    C18 = j3((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    E18 = j3((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    EO1 = j3((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(EO1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = EO1(A[B])
        }
        return Q
      }
      return A
    }, "_json");
  pA8(zO1, s6(), $O1.exports)
})
// @from(Start 3338663, End 3340404)
X$Q = z((W$Q) => {
  Object.defineProperty(W$Q, "__esModule", {
    value: !0
  });
  W$Q.createGetRequest = w18;
  W$Q.getCredentials = q18;
  var wO1 = j2(),
    z18 = Lw(),
    U18 = S3(),
    $18 = Xd();

  function w18(A) {
    return new z18.HttpRequest({
      protocol: A.protocol,
      hostname: A.hostname,
      port: Number(A.port),
      path: A.pathname,
      query: Array.from(A.searchParams.entries()).reduce((Q, [B, G]) => {
        return Q[B] = G, Q
      }, {}),
      fragment: A.hash
    })
  }
  async function q18(A, Q) {
    let G = await (0, $18.sdkStreamMixin)(A.body).transformToString();
    if (A.statusCode === 200) {
      let Z = JSON.parse(G);
      if (typeof Z.AccessKeyId !== "string" || typeof Z.SecretAccessKey !== "string" || typeof Z.Token !== "string" || typeof Z.Expiration !== "string") throw new wO1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", {
        logger: Q
      });
      return {
        accessKeyId: Z.AccessKeyId,
        secretAccessKey: Z.SecretAccessKey,
        sessionToken: Z.Token,
        expiration: (0, U18.parseRfc3339DateTime)(Z.Expiration)
      }
    }
    if (A.statusCode >= 400 && A.statusCode < 500) {
      let Z = {};
      try {
        Z = JSON.parse(G)
      } catch (I) {}
      throw Object.assign(new wO1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
        logger: Q
      }), {
        Code: Z.Code,
        Message: Z.Message
      })
    }
    throw new wO1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
      logger: Q
    })
  }
})
// @from(Start 3340410, End 3340780)
K$Q = z((V$Q) => {
  Object.defineProperty(V$Q, "__esModule", {
    value: !0
  });
  V$Q.retryWrapper = void 0;
  var M18 = (A, Q, B) => {
    return async () => {
      for (let G = 0; G < Q; ++G) try {
        return await A()
      } catch (Z) {
        await new Promise((I) => setTimeout(I, B))
      }
      return await A()
    }
  };
  V$Q.retryWrapper = M18
})
// @from(Start 3340786, End 3343273)
z$Q = z((C$Q) => {
  Object.defineProperty(C$Q, "__esModule", {
    value: !0
  });
  C$Q.fromHttp = void 0;
  var O18 = sr(),
    R18 = LL(),
    T18 = IZ(),
    D$Q = j2(),
    P18 = O18.__importDefault(UA("fs/promises")),
    j18 = gUQ(),
    H$Q = X$Q(),
    S18 = K$Q(),
    _18 = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    k18 = "http://169.254.170.2",
    y18 = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    x18 = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",
    v18 = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    b18 = (A = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let Q, B = A.awsContainerCredentialsRelativeUri ?? process.env[_18],
        G = A.awsContainerCredentialsFullUri ?? process.env[y18],
        Z = A.awsContainerAuthorizationToken ?? process.env[v18],
        I = A.awsContainerAuthorizationTokenFile ?? process.env[x18],
        Y = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console.warn : A.logger.warn;
      if (B && G) Y("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."), Y("awsContainerCredentialsFullUri will take precedence.");
      if (Z && I) Y("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."), Y("awsContainerAuthorizationToken will take precedence.");
      if (G) Q = G;
      else if (B) Q = `${k18}${B}`;
      else throw new D$Q.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, {
        logger: A.logger
      });
      let J = new URL(Q);
      (0, j18.checkUrl)(J, A.logger);
      let W = new T18.NodeHttpHandler({
        requestTimeout: A.timeout ?? 1000,
        connectionTimeout: A.timeout ?? 1000
      });
      return (0, S18.retryWrapper)(async () => {
        let X = (0, H$Q.createGetRequest)(J);
        if (Z) X.headers.Authorization = Z;
        else if (I) X.headers.Authorization = (await P18.default.readFile(I)).toString();
        try {
          let V = await W.handle(X);
          return (0, H$Q.getCredentials)(V.response).then((F) => (0, R18.setCredentialFeature)(F, "CREDENTIALS_HTTP", "z"))
        } catch (V) {
          throw new D$Q.CredentialsProviderError(String(V), {
            logger: A.logger
          })
        }
      }, A.maxRetries ?? 3, A.timeout ?? 1000)
    };
  C$Q.fromHttp = b18
})
// @from(Start 3343279, End 3343531)
uuA = z((qO1) => {
  Object.defineProperty(qO1, "__esModule", {
    value: !0
  });
  qO1.fromHttp = void 0;
  var f18 = z$Q();
  Object.defineProperty(qO1, "fromHttp", {
    enumerable: !0,
    get: function() {
      return f18.fromHttp
    }
  })
})
// @from(Start 3343537, End 3345610)
duA = z((YN7, O$Q) => {
  var {
    defineProperty: muA,
    getOwnPropertyDescriptor: g18,
    getOwnPropertyNames: u18
  } = Object, m18 = Object.prototype.hasOwnProperty, d18 = (A, Q) => muA(A, "name", {
    value: Q,
    configurable: !0
  }), c18 = (A, Q) => {
    for (var B in Q) muA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, p18 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of u18(Q))
        if (!m18.call(A, Z) && Z !== B) muA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = g18(Q, Z)) || G.enumerable
        })
    }
    return A
  }, l18 = (A) => p18(muA({}, "__esModule", {
    value: !0
  }), A), U$Q = {};
  c18(U$Q, {
    ENV_ACCOUNT_ID: () => M$Q,
    ENV_CREDENTIAL_SCOPE: () => L$Q,
    ENV_EXPIRATION: () => N$Q,
    ENV_KEY: () => $$Q,
    ENV_SECRET: () => w$Q,
    ENV_SESSION: () => q$Q,
    fromEnv: () => a18
  });
  O$Q.exports = l18(U$Q);
  var i18 = LL(),
    n18 = j2(),
    $$Q = "AWS_ACCESS_KEY_ID",
    w$Q = "AWS_SECRET_ACCESS_KEY",
    q$Q = "AWS_SESSION_TOKEN",
    N$Q = "AWS_CREDENTIAL_EXPIRATION",
    L$Q = "AWS_CREDENTIAL_SCOPE",
    M$Q = "AWS_ACCOUNT_ID",
    a18 = d18((A) => async () => {
      A?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
      let Q = process.env[$$Q],
        B = process.env[w$Q],
        G = process.env[q$Q],
        Z = process.env[N$Q],
        I = process.env[L$Q],
        Y = process.env[M$Q];
      if (Q && B) {
        let J = {
          accessKeyId: Q,
          secretAccessKey: B,
          ...G && {
            sessionToken: G
          },
          ...Z && {
            expiration: new Date(Z)
          },
          ...I && {
            credentialScope: I
          },
          ...Y && {
            accountId: Y
          }
        };
        return (0, i18.setCredentialFeature)(J, "CREDENTIALS_ENV_VARS", "g"), J
      }
      throw new n18.CredentialsProviderError("Unable to find environment variable credentials.", {
        logger: A?.logger
      })
    }, "fromEnv")
})
// @from(Start 3345616, End 3345803)
P$Q = z((R$Q) => {
  Object.defineProperty(R$Q, "__esModule", {
    value: !0
  });
  R$Q.fromEnv = void 0;
  var s18 = duA(),
    r18 = (A) => (0, s18.fromEnv)(A);
  R$Q.fromEnv = r18
})
// @from(Start 3345809, End 3347672)
luA = z((WN7, y$Q) => {
  var {
    defineProperty: puA,
    getOwnPropertyDescriptor: o18,
    getOwnPropertyNames: t18
  } = Object, e18 = Object.prototype.hasOwnProperty, cuA = (A, Q) => puA(A, "name", {
    value: Q,
    configurable: !0
  }), A08 = (A, Q) => {
    for (var B in Q) puA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Q08 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of t18(Q))
        if (!e18.call(A, Z) && Z !== B) puA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = o18(Q, Z)) || G.enumerable
        })
    }
    return A
  }, B08 = (A) => Q08(puA({}, "__esModule", {
    value: !0
  }), A), j$Q = {};
  A08(j$Q, {
    getHostHeaderPlugin: () => Z08,
    hostHeaderMiddleware: () => _$Q,
    hostHeaderMiddlewareOptions: () => k$Q,
    resolveHostHeaderConfig: () => S$Q
  });
  y$Q.exports = B08(j$Q);
  var G08 = Lw();

  function S$Q(A) {
    return A
  }
  cuA(S$Q, "resolveHostHeaderConfig");
  var _$Q = cuA((A) => (Q) => async (B) => {
      if (!G08.HttpRequest.isInstance(B.request)) return Q(B);
      let {
        request: G
      } = B, {
        handlerProtocol: Z = ""
      } = A.requestHandler.metadata || {};
      if (Z.indexOf("h2") >= 0 && !G.headers[":authority"]) delete G.headers.host, G.headers[":authority"] = G.hostname + (G.port ? ":" + G.port : "");
      else if (!G.headers.host) {
        let I = G.hostname;
        if (G.port != null) I += `:${G.port}`;
        G.headers.host = I
      }
      return Q(B)
    }, "hostHeaderMiddleware"),
    k$Q = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: !0
    },
    Z08 = cuA((A) => ({
      applyToStack: cuA((Q) => {
        Q.add(_$Q(A), k$Q)
      }, "applyToStack")
    }), "getHostHeaderPlugin")
})
// @from(Start 3347678, End 3349978)
nuA = z((XN7, f$Q) => {
  var {
    defineProperty: iuA,
    getOwnPropertyDescriptor: I08,
    getOwnPropertyNames: Y08
  } = Object, J08 = Object.prototype.hasOwnProperty, NO1 = (A, Q) => iuA(A, "name", {
    value: Q,
    configurable: !0
  }), W08 = (A, Q) => {
    for (var B in Q) iuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, X08 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Y08(Q))
        if (!J08.call(A, Z) && Z !== B) iuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = I08(Q, Z)) || G.enumerable
        })
    }
    return A
  }, V08 = (A) => X08(iuA({}, "__esModule", {
    value: !0
  }), A), x$Q = {};
  W08(x$Q, {
    getLoggerPlugin: () => F08,
    loggerMiddleware: () => v$Q,
    loggerMiddlewareOptions: () => b$Q
  });
  f$Q.exports = V08(x$Q);
  var v$Q = NO1(() => (A, Q) => async (B) => {
      try {
        let G = await A(B),
          {
            clientName: Z,
            commandName: I,
            logger: Y,
            dynamoDbDocumentClientOptions: J = {}
          } = Q,
          {
            overrideInputFilterSensitiveLog: W,
            overrideOutputFilterSensitiveLog: X
          } = J,
          V = W ?? Q.inputFilterSensitiveLog,
          F = X ?? Q.outputFilterSensitiveLog,
          {
            $metadata: K,
            ...D
          } = G.output;
        return Y?.info?.({
          clientName: Z,
          commandName: I,
          input: V(B.input),
          output: F(D),
          metadata: K
        }), G
      } catch (G) {
        let {
          clientName: Z,
          commandName: I,
          logger: Y,
          dynamoDbDocumentClientOptions: J = {}
        } = Q, {
          overrideInputFilterSensitiveLog: W
        } = J, X = W ?? Q.inputFilterSensitiveLog;
        throw Y?.error?.({
          clientName: Z,
          commandName: I,
          input: X(B.input),
          error: G,
          metadata: G.$metadata
        }), G
      }
    }, "loggerMiddleware"),
    b$Q = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: !0
    },
    F08 = NO1((A) => ({
      applyToStack: NO1((Q) => {
        Q.add(v$Q(), b$Q)
      }, "applyToStack")
    }), "getLoggerPlugin")
})
// @from(Start 3349984, End 3351916)
ruA = z((VN7, m$Q) => {
  var {
    defineProperty: suA,
    getOwnPropertyDescriptor: K08,
    getOwnPropertyNames: D08
  } = Object, H08 = Object.prototype.hasOwnProperty, auA = (A, Q) => suA(A, "name", {
    value: Q,
    configurable: !0
  }), C08 = (A, Q) => {
    for (var B in Q) suA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, E08 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of D08(Q))
        if (!H08.call(A, Z) && Z !== B) suA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = K08(Q, Z)) || G.enumerable
        })
    }
    return A
  }, z08 = (A) => E08(suA({}, "__esModule", {
    value: !0
  }), A), h$Q = {};
  C08(h$Q, {
    addRecursionDetectionMiddlewareOptions: () => u$Q,
    getRecursionDetectionPlugin: () => q08,
    recursionDetectionMiddleware: () => g$Q
  });
  m$Q.exports = z08(h$Q);
  var U08 = Lw(),
    LO1 = "X-Amzn-Trace-Id",
    $08 = "AWS_LAMBDA_FUNCTION_NAME",
    w08 = "_X_AMZN_TRACE_ID",
    g$Q = auA((A) => (Q) => async (B) => {
      let {
        request: G
      } = B;
      if (!U08.HttpRequest.isInstance(G) || A.runtime !== "node") return Q(B);
      let Z = Object.keys(G.headers ?? {}).find((W) => W.toLowerCase() === LO1.toLowerCase()) ?? LO1;
      if (G.headers.hasOwnProperty(Z)) return Q(B);
      let I = process.env[$08],
        Y = process.env[w08],
        J = auA((W) => typeof W === "string" && W.length > 0, "nonEmptyString");
      if (J(I) && J(Y)) G.headers[LO1] = Y;
      return Q({
        ...B,
        request: G
      })
    }, "recursionDetectionMiddleware"),
    u$Q = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: !0,
      priority: "low"
    },
    q08 = auA((A) => ({
      applyToStack: auA((Q) => {
        Q.add(g$Q(A), u$Q)
      }, "applyToStack")
    }), "getRecursionDetectionPlugin")
})
// @from(Start 3351922, End 3363380)
sHA = z((FN7, o$Q) => {
  var {
    defineProperty: ouA,
    getOwnPropertyDescriptor: N08,
    getOwnPropertyNames: L08
  } = Object, M08 = Object.prototype.hasOwnProperty, G6A = (A, Q) => ouA(A, "name", {
    value: Q,
    configurable: !0
  }), O08 = (A, Q) => {
    for (var B in Q) ouA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, R08 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of L08(Q))
        if (!M08.call(A, Z) && Z !== B) ouA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = N08(Q, Z)) || G.enumerable
        })
    }
    return A
  }, T08 = (A) => R08(ouA({}, "__esModule", {
    value: !0
  }), A), c$Q = {};
  O08(c$Q, {
    ConditionObject: () => SZ.ConditionObject,
    DeprecatedObject: () => SZ.DeprecatedObject,
    EndpointError: () => SZ.EndpointError,
    EndpointObject: () => SZ.EndpointObject,
    EndpointObjectHeaders: () => SZ.EndpointObjectHeaders,
    EndpointObjectProperties: () => SZ.EndpointObjectProperties,
    EndpointParams: () => SZ.EndpointParams,
    EndpointResolverOptions: () => SZ.EndpointResolverOptions,
    EndpointRuleObject: () => SZ.EndpointRuleObject,
    ErrorRuleObject: () => SZ.ErrorRuleObject,
    EvaluateOptions: () => SZ.EvaluateOptions,
    Expression: () => SZ.Expression,
    FunctionArgv: () => SZ.FunctionArgv,
    FunctionObject: () => SZ.FunctionObject,
    FunctionReturn: () => SZ.FunctionReturn,
    ParameterObject: () => SZ.ParameterObject,
    ReferenceObject: () => SZ.ReferenceObject,
    ReferenceRecord: () => SZ.ReferenceRecord,
    RuleSetObject: () => SZ.RuleSetObject,
    RuleSetRules: () => SZ.RuleSetRules,
    TreeRuleObject: () => SZ.TreeRuleObject,
    awsEndpointFunctions: () => r$Q,
    getUserAgentPrefix: () => _08,
    isIpAddress: () => SZ.isIpAddress,
    partition: () => a$Q,
    resolveEndpoint: () => SZ.resolveEndpoint,
    setPartitionInfo: () => s$Q,
    useDefaultPartitionInfo: () => S08
  });
  o$Q.exports = T08(c$Q);
  var SZ = FI(),
    p$Q = G6A((A, Q = !1) => {
      if (Q) {
        for (let B of A.split("."))
          if (!p$Q(B)) return !1;
        return !0
      }
      if (!(0, SZ.isValidHostLabel)(A)) return !1;
      if (A.length < 3 || A.length > 63) return !1;
      if (A !== A.toLowerCase()) return !1;
      if ((0, SZ.isIpAddress)(A)) return !1;
      return !0
    }, "isVirtualHostableS3Bucket"),
    d$Q = ":",
    P08 = "/",
    j08 = G6A((A) => {
      let Q = A.split(d$Q);
      if (Q.length < 6) return null;
      let [B, G, Z, I, Y, ...J] = Q;
      if (B !== "arn" || G === "" || Z === "" || J.join(d$Q) === "") return null;
      let W = J.map((X) => X.split(P08)).flat();
      return {
        partition: G,
        service: Z,
        region: I,
        accountId: Y,
        resourceId: W
      }
    }, "parseArn"),
    l$Q = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-east-2": {
            description: "Asia Pacific (Taipei)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "cloud.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-e-global": {
            description: "AWS ISOE (Europe) global region"
          },
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "csp.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "AWS ISOF global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      }, {
        id: "aws-eusc",
        outputs: {
          dnsSuffix: "amazonaws.eu",
          dualStackDnsSuffix: "amazonaws.eu",
          implicitGlobalRegion: "eusc-de-east-1",
          name: "aws-eusc",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
        regions: {
          "eusc-de-east-1": {
            description: "EU (Germany)"
          }
        }
      }],
      version: "1.1"
    },
    i$Q = l$Q,
    n$Q = "",
    a$Q = G6A((A) => {
      let {
        partitions: Q
      } = i$Q;
      for (let G of Q) {
        let {
          regions: Z,
          outputs: I
        } = G;
        for (let [Y, J] of Object.entries(Z))
          if (Y === A) return {
            ...I,
            ...J
          }
      }
      for (let G of Q) {
        let {
          regionRegex: Z,
          outputs: I
        } = G;
        if (new RegExp(Z).test(A)) return {
          ...I
        }
      }
      let B = Q.find((G) => G.id === "aws");
      if (!B) throw Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      return {
        ...B.outputs
      }
    }, "partition"),
    s$Q = G6A((A, Q = "") => {
      i$Q = A, n$Q = Q
    }, "setPartitionInfo"),
    S08 = G6A(() => {
      s$Q(l$Q, "")
    }, "useDefaultPartitionInfo"),
    _08 = G6A(() => n$Q, "getUserAgentPrefix"),
    r$Q = {
      isVirtualHostableS3Bucket: p$Q,
      parseArn: j08,
      partition: a$Q
    };
  SZ.customEndpointFunctions.aws = r$Q
})
// @from(Start 3363386, End 3364339)
AwQ = z((KN7, e$Q) => {
  var {
    defineProperty: tuA,
    getOwnPropertyDescriptor: k08,
    getOwnPropertyNames: y08
  } = Object, x08 = Object.prototype.hasOwnProperty, v08 = (A, Q) => tuA(A, "name", {
    value: Q,
    configurable: !0
  }), b08 = (A, Q) => {
    for (var B in Q) tuA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, f08 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of y08(Q))
        if (!x08.call(A, Z) && Z !== B) tuA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = k08(Q, Z)) || G.enumerable
        })
    }
    return A
  }, h08 = (A) => f08(tuA({}, "__esModule", {
    value: !0
  }), A), t$Q = {};
  b08(t$Q, {
    isArrayBuffer: () => g08
  });
  e$Q.exports = h08(t$Q);
  var g08 = v08((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 3364345, End 3365398)
ZwQ = z((DN7, GwQ) => {
  var {
    defineProperty: euA,
    getOwnPropertyDescriptor: u08,
    getOwnPropertyNames: m08
  } = Object, d08 = Object.prototype.hasOwnProperty, MO1 = (A, Q) => euA(A, "name", {
    value: Q,
    configurable: !0
  }), c08 = (A, Q) => {
    for (var B in Q) euA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, p08 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of m08(Q))
        if (!d08.call(A, Z) && Z !== B) euA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = u08(Q, Z)) || G.enumerable
        })
    }
    return A
  }, l08 = (A) => p08(euA({}, "__esModule", {
    value: !0
  }), A), QwQ = {};
  c08(QwQ, {
    escapeUri: () => BwQ,
    escapeUriPath: () => n08
  });
  GwQ.exports = l08(QwQ);
  var BwQ = MO1((A) => encodeURIComponent(A).replace(/[!'()*]/g, i08), "escapeUri"),
    i08 = MO1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    n08 = MO1((A) => A.split("/").map(BwQ).join("/"), "escapeUriPath")
})
// @from(Start 3365404, End 3382317)
kwQ = z((HN7, _wQ) => {
  var {
    defineProperty: YmA,
    getOwnPropertyDescriptor: a08,
    getOwnPropertyNames: s08
  } = Object, r08 = Object.prototype.hasOwnProperty, JD = (A, Q) => YmA(A, "name", {
    value: Q,
    configurable: !0
  }), o08 = (A, Q) => {
    for (var B in Q) YmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, t08 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of s08(Q))
        if (!r08.call(A, Z) && Z !== B) YmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = a08(Q, Z)) || G.enumerable
        })
    }
    return A
  }, e08 = (A) => t08(YmA({}, "__esModule", {
    value: !0
  }), A), XwQ = {};
  o08(XwQ, {
    ALGORITHM_IDENTIFIER: () => AmA,
    ALGORITHM_IDENTIFIER_V4A: () => GQ8,
    ALGORITHM_QUERY_PARAM: () => VwQ,
    ALWAYS_UNSIGNABLE_HEADERS: () => UwQ,
    AMZ_DATE_HEADER: () => kO1,
    AMZ_DATE_QUERY_PARAM: () => PO1,
    AUTH_HEADER: () => _O1,
    CREDENTIAL_QUERY_PARAM: () => FwQ,
    DATE_HEADER: () => HwQ,
    EVENT_ALGORITHM_IDENTIFIER: () => qwQ,
    EXPIRES_QUERY_PARAM: () => DwQ,
    GENERATED_HEADERS: () => CwQ,
    HOST_HEADER: () => QQ8,
    KEY_TYPE_IDENTIFIER: () => yO1,
    MAX_CACHE_SIZE: () => LwQ,
    MAX_PRESIGNED_TTL: () => MwQ,
    PROXY_HEADER_PATTERN: () => $wQ,
    REGION_SET_PARAM: () => AQ8,
    SEC_HEADER_PATTERN: () => wwQ,
    SHA256_HEADER: () => ImA,
    SIGNATURE_HEADER: () => EwQ,
    SIGNATURE_QUERY_PARAM: () => jO1,
    SIGNED_HEADERS_QUERY_PARAM: () => KwQ,
    SignatureV4: () => HQ8,
    SignatureV4Base: () => SwQ,
    TOKEN_HEADER: () => zwQ,
    TOKEN_QUERY_PARAM: () => SO1,
    UNSIGNABLE_PATTERNS: () => BQ8,
    UNSIGNED_PAYLOAD: () => NwQ,
    clearCredentialCache: () => IQ8,
    createScope: () => BmA,
    getCanonicalHeaders: () => OO1,
    getCanonicalQuery: () => jwQ,
    getPayloadHash: () => GmA,
    getSigningKey: () => OwQ,
    hasHeader: () => RwQ,
    moveHeadersToQuery: () => PwQ,
    prepareRequest: () => TO1,
    signatureV4aContainer: () => CQ8
  });
  _wQ.exports = e08(XwQ);
  var IwQ = O2(),
    VwQ = "X-Amz-Algorithm",
    FwQ = "X-Amz-Credential",
    PO1 = "X-Amz-Date",
    KwQ = "X-Amz-SignedHeaders",
    DwQ = "X-Amz-Expires",
    jO1 = "X-Amz-Signature",
    SO1 = "X-Amz-Security-Token",
    AQ8 = "X-Amz-Region-Set",
    _O1 = "authorization",
    kO1 = PO1.toLowerCase(),
    HwQ = "date",
    CwQ = [_O1, kO1, HwQ],
    EwQ = jO1.toLowerCase(),
    ImA = "x-amz-content-sha256",
    zwQ = SO1.toLowerCase(),
    QQ8 = "host",
    UwQ = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0
    },
    $wQ = /^proxy-/,
    wwQ = /^sec-/,
    BQ8 = [/^proxy-/i, /^sec-/i],
    AmA = "AWS4-HMAC-SHA256",
    GQ8 = "AWS4-ECDSA-P256-SHA256",
    qwQ = "AWS4-HMAC-SHA256-PAYLOAD",
    NwQ = "UNSIGNED-PAYLOAD",
    LwQ = 50,
    yO1 = "aws4_request",
    MwQ = 604800,
    bd = Jd(),
    ZQ8 = O2(),
    Z6A = {},
    QmA = [],
    BmA = JD((A, Q, B) => `${A}/${Q}/${B}/${yO1}`, "createScope"),
    OwQ = JD(async (A, Q, B, G, Z) => {
      let I = await YwQ(A, Q.secretAccessKey, Q.accessKeyId),
        Y = `${B}:${G}:${Z}:${(0,bd.toHex)(I)}:${Q.sessionToken}`;
      if (Y in Z6A) return Z6A[Y];
      QmA.push(Y);
      while (QmA.length > LwQ) delete Z6A[QmA.shift()];
      let J = `AWS4${Q.secretAccessKey}`;
      for (let W of [B, G, Z, yO1]) J = await YwQ(A, J, W);
      return Z6A[Y] = J
    }, "getSigningKey"),
    IQ8 = JD(() => {
      QmA.length = 0, Object.keys(Z6A).forEach((A) => {
        delete Z6A[A]
      })
    }, "clearCredentialCache"),
    YwQ = JD((A, Q, B) => {
      let G = new A(Q);
      return G.update((0, ZQ8.toUint8Array)(B)), G.digest()
    }, "hmac"),
    OO1 = JD(({
      headers: A
    }, Q, B) => {
      let G = {};
      for (let Z of Object.keys(A).sort()) {
        if (A[Z] == null) continue;
        let I = Z.toLowerCase();
        if (I in UwQ || Q?.has(I) || $wQ.test(I) || wwQ.test(I)) {
          if (!B || B && !B.has(I)) continue
        }
        G[I] = A[Z].trim().replace(/\s+/g, " ")
      }
      return G
    }, "getCanonicalHeaders"),
    YQ8 = AwQ(),
    JQ8 = O2(),
    GmA = JD(async ({
      headers: A,
      body: Q
    }, B) => {
      for (let G of Object.keys(A))
        if (G.toLowerCase() === ImA) return A[G];
      if (Q == null) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      else if (typeof Q === "string" || ArrayBuffer.isView(Q) || (0, YQ8.isArrayBuffer)(Q)) {
        let G = new B;
        return G.update((0, JQ8.toUint8Array)(Q)), (0, bd.toHex)(await G.digest())
      }
      return NwQ
    }, "getPayloadHash"),
    JwQ = O2(),
    WQ8 = class {
      static {
        JD(this, "HeaderFormatter")
      }
      format(A) {
        let Q = [];
        for (let Z of Object.keys(A)) {
          let I = (0, JwQ.fromUtf8)(Z);
          Q.push(Uint8Array.from([I.byteLength]), I, this.formatHeaderValue(A[Z]))
        }
        let B = new Uint8Array(Q.reduce((Z, I) => Z + I.byteLength, 0)),
          G = 0;
        for (let Z of Q) B.set(Z, G), G += Z.byteLength;
        return B
      }
      formatHeaderValue(A) {
        switch (A.type) {
          case "boolean":
            return Uint8Array.from([A.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, A.value]);
          case "short":
            let Q = new DataView(new ArrayBuffer(3));
            return Q.setUint8(0, 3), Q.setInt16(1, A.value, !1), new Uint8Array(Q.buffer);
          case "integer":
            let B = new DataView(new ArrayBuffer(5));
            return B.setUint8(0, 4), B.setInt32(1, A.value, !1), new Uint8Array(B.buffer);
          case "long":
            let G = new Uint8Array(9);
            return G[0] = 5, G.set(A.value.bytes, 1), G;
          case "binary":
            let Z = new DataView(new ArrayBuffer(3 + A.value.byteLength));
            Z.setUint8(0, 6), Z.setUint16(1, A.value.byteLength, !1);
            let I = new Uint8Array(Z.buffer);
            return I.set(A.value, 3), I;
          case "string":
            let Y = (0, JwQ.fromUtf8)(A.value),
              J = new DataView(new ArrayBuffer(3 + Y.byteLength));
            J.setUint8(0, 7), J.setUint16(1, Y.byteLength, !1);
            let W = new Uint8Array(J.buffer);
            return W.set(Y, 3), W;
          case "timestamp":
            let X = new Uint8Array(9);
            return X[0] = 8, X.set(VQ8.fromNumber(A.value.valueOf()).bytes, 1), X;
          case "uuid":
            if (!XQ8.test(A.value)) throw Error(`Invalid UUID received: ${A.value}`);
            let V = new Uint8Array(17);
            return V[0] = 9, V.set((0, bd.fromHex)(A.value.replace(/\-/g, "")), 1), V
        }
      }
    },
    XQ8 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    VQ8 = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static {
        JD(this, "Int64")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) RO1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) RO1(Q);
        return parseInt((0, bd.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };

  function RO1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  JD(RO1, "negate");
  var RwQ = JD((A, Q) => {
      A = A.toLowerCase();
      for (let B of Object.keys(Q))
        if (A === B.toLowerCase()) return !0;
      return !1
    }, "hasHeader"),
    TwQ = Lw(),
    PwQ = JD((A, Q = {}) => {
      let {
        headers: B,
        query: G = {}
      } = TwQ.HttpRequest.clone(A);
      for (let Z of Object.keys(B)) {
        let I = Z.toLowerCase();
        if (I.slice(0, 6) === "x-amz-" && !Q.unhoistableHeaders?.has(I) || Q.hoistableHeaders?.has(I)) G[Z] = B[Z], delete B[Z]
      }
      return {
        ...A,
        headers: B,
        query: G
      }
    }, "moveHeadersToQuery"),
    TO1 = JD((A) => {
      A = TwQ.HttpRequest.clone(A);
      for (let Q of Object.keys(A.headers))
        if (CwQ.indexOf(Q.toLowerCase()) > -1) delete A.headers[Q];
      return A
    }, "prepareRequest"),
    WwQ = w7(),
    FQ8 = O2(),
    ZmA = ZwQ(),
    jwQ = JD(({
      query: A = {}
    }) => {
      let Q = [],
        B = {};
      for (let G of Object.keys(A)) {
        if (G.toLowerCase() === EwQ) continue;
        let Z = (0, ZmA.escapeUri)(G);
        Q.push(Z);
        let I = A[G];
        if (typeof I === "string") B[Z] = `${Z}=${(0,ZmA.escapeUri)(I)}`;
        else if (Array.isArray(I)) B[Z] = I.slice(0).reduce((Y, J) => Y.concat([`${Z}=${(0,ZmA.escapeUri)(J)}`]), []).sort().join("&")
      }
      return Q.sort().map((G) => B[G]).filter((G) => G).join("&")
    }, "getCanonicalQuery"),
    KQ8 = JD((A) => DQ8(A).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601"),
    DQ8 = JD((A) => {
      if (typeof A === "number") return new Date(A * 1000);
      if (typeof A === "string") {
        if (Number(A)) return new Date(Number(A) * 1000);
        return new Date(A)
      }
      return A
    }, "toDate"),
    SwQ = class {
      static {
        JD(this, "SignatureV4Base")
      }
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        this.service = G, this.sha256 = Z, this.uriEscapePath = I, this.applyChecksum = typeof A === "boolean" ? A : !0, this.regionProvider = (0, WwQ.normalizeProvider)(B), this.credentialProvider = (0, WwQ.normalizeProvider)(Q)
      }
      createCanonicalRequest(A, Q, B) {
        let G = Object.keys(Q).sort();
        return `${A.method}
${this.getCanonicalPath(A)}
${jwQ(A)}
${G.map((Z)=>`${Z}:${Q[Z]}`).join(`
`)}

${G.join(";")}
${B}`
      }
      async createStringToSign(A, Q, B, G) {
        let Z = new this.sha256;
        Z.update((0, FQ8.toUint8Array)(B));
        let I = await Z.digest();
        return `${G}
${A}
${Q}
${(0,bd.toHex)(I)}`
      }
      getCanonicalPath({
        path: A
      }) {
        if (this.uriEscapePath) {
          let Q = [];
          for (let Z of A.split("/")) {
            if (Z?.length === 0) continue;
            if (Z === ".") continue;
            if (Z === "..") Q.pop();
            else Q.push(Z)
          }
          let B = `${A?.startsWith("/")?"/":""}${Q.join("/")}${Q.length>0&&A?.endsWith("/")?"/":""}`;
          return (0, ZmA.escapeUri)(B).replace(/%2F/g, "/")
        }
        return A
      }
      validateResolvedCredentials(A) {
        if (typeof A !== "object" || typeof A.accessKeyId !== "string" || typeof A.secretAccessKey !== "string") throw Error("Resolved credential object is not valid")
      }
      formatDate(A) {
        let Q = KQ8(A).replace(/[\-:]/g, "");
        return {
          longDate: Q,
          shortDate: Q.slice(0, 8)
        }
      }
      getCanonicalHeaderList(A) {
        return Object.keys(A).sort().join(";")
      }
    },
    HQ8 = class extends SwQ {
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        super({
          applyChecksum: A,
          credentials: Q,
          region: B,
          service: G,
          sha256: Z,
          uriEscapePath: I
        });
        this.headerFormatter = new WQ8
      }
      static {
        JD(this, "SignatureV4")
      }
      async presign(A, Q = {}) {
        let {
          signingDate: B = new Date,
          expiresIn: G = 3600,
          unsignableHeaders: Z,
          unhoistableHeaders: I,
          signableHeaders: Y,
          hoistableHeaders: J,
          signingRegion: W,
          signingService: X
        } = Q, V = await this.credentialProvider();
        this.validateResolvedCredentials(V);
        let F = W ?? await this.regionProvider(),
          {
            longDate: K,
            shortDate: D
          } = this.formatDate(B);
        if (G > MwQ) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        let H = BmA(D, F, X ?? this.service),
          C = PwQ(TO1(A), {
            unhoistableHeaders: I,
            hoistableHeaders: J
          });
        if (V.sessionToken) C.query[SO1] = V.sessionToken;
        C.query[VwQ] = AmA, C.query[FwQ] = `${V.accessKeyId}/${H}`, C.query[PO1] = K, C.query[DwQ] = G.toString(10);
        let E = OO1(C, Z, Y);
        return C.query[KwQ] = this.getCanonicalHeaderList(E), C.query[jO1] = await this.getSignature(K, H, this.getSigningKey(V, F, D, X), this.createCanonicalRequest(C, E, await GmA(A, this.sha256))), C
      }
      async sign(A, Q) {
        if (typeof A === "string") return this.signString(A, Q);
        else if (A.headers && A.payload) return this.signEvent(A, Q);
        else if (A.message) return this.signMessage(A, Q);
        else return this.signRequest(A, Q)
      }
      async signEvent({
        headers: A,
        payload: Q
      }, {
        signingDate: B = new Date,
        priorSignature: G,
        signingRegion: Z,
        signingService: I
      }) {
        let Y = Z ?? await this.regionProvider(),
          {
            shortDate: J,
            longDate: W
          } = this.formatDate(B),
          X = BmA(J, Y, I ?? this.service),
          V = await GmA({
            headers: {},
            body: Q
          }, this.sha256),
          F = new this.sha256;
        F.update(A);
        let K = (0, bd.toHex)(await F.digest()),
          D = [qwQ, W, X, G, K, V].join(`
`);
        return this.signString(D, {
          signingDate: B,
          signingRegion: Y,
          signingService: I
        })
      }
      async signMessage(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      }) {
        return this.signEvent({
          headers: this.headerFormatter.format(A.message.headers),
          payload: A.message.body
        }, {
          signingDate: Q,
          signingRegion: B,
          signingService: G,
          priorSignature: A.priorSignature
        }).then((I) => {
          return {
            message: A.message,
            signature: I
          }
        })
      }
      async signString(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      } = {}) {
        let Z = await this.credentialProvider();
        this.validateResolvedCredentials(Z);
        let I = B ?? await this.regionProvider(),
          {
            shortDate: Y
          } = this.formatDate(Q),
          J = new this.sha256(await this.getSigningKey(Z, I, Y, G));
        return J.update((0, IwQ.toUint8Array)(A)), (0, bd.toHex)(await J.digest())
      }
      async signRequest(A, {
        signingDate: Q = new Date,
        signableHeaders: B,
        unsignableHeaders: G,
        signingRegion: Z,
        signingService: I
      } = {}) {
        let Y = await this.credentialProvider();
        this.validateResolvedCredentials(Y);
        let J = Z ?? await this.regionProvider(),
          W = TO1(A),
          {
            longDate: X,
            shortDate: V
          } = this.formatDate(Q),
          F = BmA(V, J, I ?? this.service);
        if (W.headers[kO1] = X, Y.sessionToken) W.headers[zwQ] = Y.sessionToken;
        let K = await GmA(W, this.sha256);
        if (!RwQ(ImA, W.headers) && this.applyChecksum) W.headers[ImA] = K;
        let D = OO1(W, G, B),
          H = await this.getSignature(X, F, this.getSigningKey(Y, J, V, I), this.createCanonicalRequest(W, D, K));
        return W.headers[_O1] = `${AmA} Credential=${Y.accessKeyId}/${F}, SignedHeaders=${this.getCanonicalHeaderList(D)}, Signature=${H}`, W
      }
      async getSignature(A, Q, B, G) {
        let Z = await this.createStringToSign(A, Q, G, AmA),
          I = new this.sha256(await B);
        return I.update((0, IwQ.toUint8Array)(Z)), (0, bd.toHex)(await I.digest())
      }
      getSigningKey(A, Q, B, G) {
        return OwQ(this.sha256, A, B, Q, G || this.service)
      }
    },
    CQ8 = {
      SignatureV4a: null
    }
})
// @from(Start 3382323, End 3391737)
fO1 = z((UN7, lwQ) => {
  var {
    defineProperty: JmA,
    getOwnPropertyDescriptor: EQ8,
    getOwnPropertyNames: zQ8
  } = Object, UQ8 = Object.prototype.hasOwnProperty, zW = (A, Q) => JmA(A, "name", {
    value: Q,
    configurable: !0
  }), $Q8 = (A, Q) => {
    for (var B in Q) JmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, wQ8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of zQ8(Q))
        if (!UQ8.call(A, Z) && Z !== B) JmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = EQ8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, qQ8 = (A) => wQ8(JmA({}, "__esModule", {
    value: !0
  }), A), uwQ = {};
  $Q8(uwQ, {
    AWSSDKSigV4Signer: () => OQ8,
    AwsSdkSigV4ASigner: () => TQ8,
    AwsSdkSigV4Signer: () => bO1,
    NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => PQ8,
    NODE_SIGV4A_CONFIG_OPTIONS: () => _Q8,
    getBearerTokenEnvKey: () => mwQ,
    resolveAWSSDKSigV4Config: () => yQ8,
    resolveAwsSdkSigV4AConfig: () => SQ8,
    resolveAwsSdkSigV4Config: () => dwQ,
    validateSigningProperties: () => vO1
  });
  lwQ.exports = qQ8(uwQ);
  var NQ8 = Lw(),
    LQ8 = Lw(),
    ywQ = zW((A) => LQ8.HttpResponse.isInstance(A) ? A.headers?.date ?? A.headers?.Date : void 0, "getDateHeader"),
    xO1 = zW((A) => new Date(Date.now() + A), "getSkewCorrectedDate"),
    MQ8 = zW((A, Q) => Math.abs(xO1(Q).getTime() - A) >= 300000, "isClockSkewed"),
    xwQ = zW((A, Q) => {
      let B = Date.parse(A);
      if (MQ8(B, Q)) return B - Date.now();
      return Q
    }, "getUpdatedSystemClockOffset"),
    rHA = zW((A, Q) => {
      if (!Q) throw Error(`Property \`${A}\` is not resolved for AWS SDK SigV4Auth`);
      return Q
    }, "throwSigningPropertyError"),
    vO1 = zW(async (A) => {
      let Q = rHA("context", A.context),
        B = rHA("config", A.config),
        G = Q.endpointV2?.properties?.authSchemes?.[0],
        I = await rHA("signer", B.signer)(G),
        Y = A?.signingRegion,
        J = A?.signingRegionSet,
        W = A?.signingName;
      return {
        config: B,
        signer: I,
        signingRegion: Y,
        signingRegionSet: J,
        signingName: W
      }
    }, "validateSigningProperties"),
    bO1 = class {
      static {
        zW(this, "AwsSdkSigV4Signer")
      }
      async sign(A, Q, B) {
        if (!NQ8.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let G = await vO1(B),
          {
            config: Z,
            signer: I
          } = G,
          {
            signingRegion: Y,
            signingName: J
          } = G,
          W = B.context;
        if (W?.authSchemes?.length ?? !1) {
          let [V, F] = W.authSchemes;
          if (V?.name === "sigv4a" && F?.name === "sigv4") Y = F?.signingRegion ?? Y, J = F?.signingName ?? J
        }
        return await I.sign(A, {
          signingDate: xO1(Z.systemClockOffset),
          signingRegion: Y,
          signingService: J
        })
      }
      errorHandler(A) {
        return (Q) => {
          let B = Q.ServerTime ?? ywQ(Q.$response);
          if (B) {
            let G = rHA("config", A.config),
              Z = G.systemClockOffset;
            if (G.systemClockOffset = xwQ(B, G.systemClockOffset), G.systemClockOffset !== Z && Q.$metadata) Q.$metadata.clockSkewCorrected = !0
          }
          throw Q
        }
      }
      successHandler(A, Q) {
        let B = ywQ(A);
        if (B) {
          let G = rHA("config", Q.config);
          G.systemClockOffset = xwQ(B, G.systemClockOffset)
        }
      }
    },
    OQ8 = bO1,
    RQ8 = Lw(),
    TQ8 = class extends bO1 {
      static {
        zW(this, "AwsSdkSigV4ASigner")
      }
      async sign(A, Q, B) {
        if (!RQ8.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let {
          config: G,
          signer: Z,
          signingRegion: I,
          signingRegionSet: Y,
          signingName: J
        } = await vO1(B), X = (await G.sigv4aSigningRegionSet?.() ?? Y ?? [I]).join(",");
        return await Z.sign(A, {
          signingDate: xO1(G.systemClockOffset),
          signingRegion: X,
          signingService: J
        })
      }
    },
    vwQ = zW((A) => typeof A === "string" && A.length > 0 ? A.split(",").map((Q) => Q.trim()) : [], "getArrayForCommaSeparatedString"),
    mwQ = zW((A) => `AWS_BEARER_TOKEN_${A.replace(/[\s-]/g,"_").toUpperCase()}`, "getBearerTokenEnvKey"),
    bwQ = "AWS_AUTH_SCHEME_PREFERENCE",
    fwQ = "auth_scheme_preference",
    PQ8 = {
      environmentVariableSelector: zW((A, Q) => {
        if (Q?.signingName) {
          if (mwQ(Q.signingName) in A) return ["httpBearerAuth"]
        }
        if (!(bwQ in A)) return;
        return vwQ(A[bwQ])
      }, "environmentVariableSelector"),
      configFileSelector: zW((A) => {
        if (!(fwQ in A)) return;
        return vwQ(A[fwQ])
      }, "configFileSelector"),
      default: []
    },
    jQ8 = iB(),
    hwQ = j2(),
    SQ8 = zW((A) => {
      return A.sigv4aSigningRegionSet = (0, jQ8.normalizeProvider)(A.sigv4aSigningRegionSet), A
    }, "resolveAwsSdkSigV4AConfig"),
    _Q8 = {
      environmentVariableSelector(A) {
        if (A.AWS_SIGV4A_SIGNING_REGION_SET) return A.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((Q) => Q.trim());
        throw new hwQ.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
          tryNextLink: !0
        })
      },
      configFileSelector(A) {
        if (A.sigv4a_signing_region_set) return (A.sigv4a_signing_region_set ?? "").split(",").map((Q) => Q.trim());
        throw new hwQ.ProviderError("sigv4a_signing_region_set not set in profile.", {
          tryNextLink: !0
        })
      },
      default: void 0
    },
    kQ8 = LL(),
    Yo = iB(),
    gwQ = kwQ(),
    dwQ = zW((A) => {
      let Q = A.credentials,
        B = !!A.credentials,
        G = void 0;
      Object.defineProperty(A, "credentials", {
        set(X) {
          if (X && X !== Q && X !== G) B = !0;
          Q = X;
          let V = cwQ(A, {
              credentials: Q,
              credentialDefaultProvider: A.credentialDefaultProvider
            }),
            F = pwQ(A, V);
          if (B && !F.attributed) G = zW(async (K) => F(K).then((D) => (0, kQ8.setCredentialFeature)(D, "CREDENTIALS_CODE", "e")), "resolvedCredentials"), G.memoized = F.memoized, G.configBound = F.configBound, G.attributed = !0;
          else G = F
        },
        get() {
          return G
        },
        enumerable: !0,
        configurable: !0
      }), A.credentials = Q;
      let {
        signingEscapePath: Z = !0,
        systemClockOffset: I = A.systemClockOffset || 0,
        sha256: Y
      } = A, J;
      if (A.signer) J = (0, Yo.normalizeProvider)(A.signer);
      else if (A.regionInfoProvider) J = zW(() => (0, Yo.normalizeProvider)(A.region)().then(async (X) => [await A.regionInfoProvider(X, {
        useFipsEndpoint: await A.useFipsEndpoint(),
        useDualstackEndpoint: await A.useDualstackEndpoint()
      }) || {}, X]).then(([X, V]) => {
        let {
          signingRegion: F,
          signingService: K
        } = X;
        A.signingRegion = A.signingRegion || F || V, A.signingName = A.signingName || K || A.serviceId;
        let D = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || gwQ.SignatureV4)(D)
      }), "signer");
      else J = zW(async (X) => {
        X = Object.assign({}, {
          name: "sigv4",
          signingName: A.signingName || A.defaultSigningName,
          signingRegion: await (0, Yo.normalizeProvider)(A.region)(),
          properties: {}
        }, X);
        let {
          signingRegion: V,
          signingName: F
        } = X;
        A.signingRegion = A.signingRegion || V, A.signingName = A.signingName || F || A.serviceId;
        let K = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || gwQ.SignatureV4)(K)
      }, "signer");
      return Object.assign(A, {
        systemClockOffset: I,
        signingEscapePath: Z,
        signer: J
      })
    }, "resolveAwsSdkSigV4Config"),
    yQ8 = dwQ;

  function cwQ(A, {
    credentials: Q,
    credentialDefaultProvider: B
  }) {
    let G;
    if (Q)
      if (!Q?.memoized) G = (0, Yo.memoizeIdentityProvider)(Q, Yo.isIdentityExpired, Yo.doesIdentityRequireRefresh);
      else G = Q;
    else if (B) G = (0, Yo.normalizeProvider)(B(Object.assign({}, A, {
      parentClientConfig: A
    })));
    else G = zW(async () => {
      throw Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.")
    }, "credentialsProvider");
    return G.memoized = !0, G
  }
  zW(cwQ, "normalizeCredentialProvider");

  function pwQ(A, Q) {
    if (Q.configBound) return Q;
    let B = zW(async (G) => Q({
      ...G,
      callerClientConfig: A
    }), "fn");
    return B.memoized = Q.memoized, B.configBound = !0, B
  }
  zW(pwQ, "bindCallerConfig")
})
// @from(Start 3391743, End 3392230)
awQ = z((iwQ) => {
  Object.defineProperty(iwQ, "__esModule", {
    value: !0
  });
  iwQ.fromBase64 = void 0;
  var xQ8 = hI(),
    vQ8 = /^[A-Za-z0-9+/]*={0,2}$/,
    bQ8 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!vQ8.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, xQ8.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  iwQ.fromBase64 = bQ8
})
// @from(Start 3392236, End 3392815)
owQ = z((swQ) => {
  Object.defineProperty(swQ, "__esModule", {
    value: !0
  });
  swQ.toBase64 = void 0;
  var fQ8 = hI(),
    hQ8 = O2(),
    gQ8 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, hQ8.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, fQ8.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  swQ.toBase64 = gQ8
})
// @from(Start 3392821, End 3393516)
Jo = z((LN7, WmA) => {
  var {
    defineProperty: twQ,
    getOwnPropertyDescriptor: uQ8,
    getOwnPropertyNames: mQ8
  } = Object, dQ8 = Object.prototype.hasOwnProperty, hO1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of mQ8(Q))
        if (!dQ8.call(A, Z) && Z !== B) twQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = uQ8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ewQ = (A, Q, B) => (hO1(A, Q, "default"), B && hO1(B, Q, "default")), cQ8 = (A) => hO1(twQ({}, "__esModule", {
    value: !0
  }), A), gO1 = {};
  WmA.exports = cQ8(gO1);
  ewQ(gO1, awQ(), WmA.exports);
  ewQ(gO1, owQ(), WmA.exports)
})
// @from(Start 3393522, End 3438713)
CqQ = z((MN7, HqQ) => {
  var {
    defineProperty: VmA,
    getOwnPropertyDescriptor: pQ8,
    getOwnPropertyNames: lQ8
  } = Object, iQ8 = Object.prototype.hasOwnProperty, J3 = (A, Q) => VmA(A, "name", {
    value: Q,
    configurable: !0
  }), nQ8 = (A, Q) => {
    for (var B in Q) VmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, aQ8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of lQ8(Q))
        if (!iQ8.call(A, Z) && Z !== B) VmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = pQ8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, sQ8 = (A) => aQ8(VmA({}, "__esModule", {
    value: !0
  }), A), ZqQ = {};
  nQ8(ZqQ, {
    AwsEc2QueryProtocol: () => MB8,
    AwsJson1_0Protocol: () => XB8,
    AwsJson1_1Protocol: () => VB8,
    AwsJsonRpcProtocol: () => nO1,
    AwsQueryProtocol: () => XqQ,
    AwsRestJsonProtocol: () => KB8,
    AwsRestXmlProtocol: () => SB8,
    JsonCodec: () => iO1,
    JsonShapeDeserializer: () => JqQ,
    JsonShapeSerializer: () => WqQ,
    XmlCodec: () => DqQ,
    XmlShapeDeserializer: () => aO1,
    XmlShapeSerializer: () => KqQ,
    _toBool: () => oQ8,
    _toNum: () => tQ8,
    _toStr: () => rQ8,
    awsExpectUnion: () => HB8,
    loadRestJsonErrorCode: () => lO1,
    loadRestXmlErrorCode: () => FqQ,
    parseJsonBody: () => pO1,
    parseJsonErrorBody: () => ZB8,
    parseXmlBody: () => VqQ,
    parseXmlErrorBody: () => PB8
  });
  HqQ.exports = sQ8(ZqQ);
  var rQ8 = J3((A) => {
      if (A == null) return A;
      if (typeof A === "number" || typeof A === "bigint") {
        let Q = Error(`Received number ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      if (typeof A === "boolean") {
        let Q = Error(`Received boolean ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      return A
    }, "_toStr"),
    oQ8 = J3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (A !== "" && Q !== "false" && Q !== "true") {
          let B = Error(`Received string "${A}" where a boolean was expected.`);
          B.name = "Warning", console.warn(B)
        }
        return A !== "" && Q !== "false"
      }
      return A
    }, "_toBool"),
    tQ8 = J3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = Number(A);
        if (Q.toString() !== A) {
          let B = Error(`Received string "${A}" where a number was expected.`);
          return B.name = "Warning", console.warn(B), A
        }
        return Q
      }
      return A
    }, "_toNum"),
    eQ8 = w5(),
    I6A = b4(),
    AB8 = oK(),
    Xo = class {
      static {
        J3(this, "SerdeContextConfig")
      }
      serdeContext;
      setSerdeContext(A) {
        this.serdeContext = A
      }
    },
    oHA = b4(),
    Y6A = s6(),
    QB8 = Jo(),
    BB8 = s6();

  function IqQ(A, Q, B) {
    if (B?.source) {
      let G = B.source;
      if (typeof Q === "number") {
        if (Q > Number.MAX_SAFE_INTEGER || Q < Number.MIN_SAFE_INTEGER || G !== String(Q))
          if (G.includes(".")) return new BB8.NumericValue(G, "bigDecimal");
          else return BigInt(G)
      }
    }
    return Q
  }
  J3(IqQ, "jsonReviver");
  var GB8 = S3(),
    YqQ = J3((A, Q) => (0, GB8.collectBody)(A, Q).then((B) => Q.utf8Encoder(B)), "collectBodyString"),
    pO1 = J3((A, Q) => YqQ(A, Q).then((B) => {
      if (B.length) try {
        return JSON.parse(B)
      } catch (G) {
        if (G?.name === "SyntaxError") Object.defineProperty(G, "$responseBodyText", {
          value: B
        });
        throw G
      }
      return {}
    }), "parseJsonBody"),
    ZB8 = J3(async (A, Q) => {
      let B = await pO1(A, Q);
      return B.message = B.message ?? B.Message, B
    }, "parseJsonErrorBody"),
    lO1 = J3((A, Q) => {
      let B = J3((I, Y) => Object.keys(I).find((J) => J.toLowerCase() === Y.toLowerCase()), "findKey"),
        G = J3((I) => {
          let Y = I;
          if (typeof Y === "number") Y = Y.toString();
          if (Y.indexOf(",") >= 0) Y = Y.split(",")[0];
          if (Y.indexOf(":") >= 0) Y = Y.split(":")[0];
          if (Y.indexOf("#") >= 0) Y = Y.split("#")[1];
          return Y
        }, "sanitizeErrorCode"),
        Z = B(A.headers, "x-amzn-errortype");
      if (Z !== void 0) return G(A.headers[Z]);
      if (Q && typeof Q === "object") {
        let I = B(Q, "code");
        if (I && Q[I] !== void 0) return G(Q[I]);
        if (Q.__type !== void 0) return G(Q.__type)
      }
    }, "loadRestJsonErrorCode"),
    JqQ = class extends Xo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        J3(this, "JsonShapeDeserializer")
      }
      async read(A, Q) {
        return this._read(A, typeof Q === "string" ? JSON.parse(Q, IqQ) : await pO1(Q, this.serdeContext))
      }
      readObject(A, Q) {
        return this._read(A, Q)
      }
      _read(A, Q) {
        let B = Q !== null && typeof Q === "object",
          G = oHA.NormalizedSchema.of(A);
        if (G.isListSchema() && Array.isArray(Q)) {
          let I = G.getValueSchema(),
            Y = [],
            J = !!G.getMergedTraits().sparse;
          for (let W of Q)
            if (J || W != null) Y.push(this._read(I, W));
          return Y
        } else if (G.isMapSchema() && B) {
          let I = G.getValueSchema(),
            Y = {},
            J = !!G.getMergedTraits().sparse;
          for (let [W, X] of Object.entries(Q))
            if (J || X != null) Y[W] = this._read(I, X);
          return Y
        } else if (G.isStructSchema() && B) {
          let I = {};
          for (let [Y, J] of G.structIterator()) {
            let W = this.settings.jsonName ? J.getMergedTraits().jsonName ?? Y : Y,
              X = this._read(J, Q[W]);
            if (X != null) I[Y] = X
          }
          return I
        }
        if (G.isBlobSchema() && typeof Q === "string") return (0, QB8.fromBase64)(Q);
        let Z = G.getMergedTraits().mediaType;
        if (G.isStringSchema() && typeof Q === "string" && Z) {
          if (Z === "application/json" || Z.endsWith("+json")) return Y6A.LazyJsonString.from(Q)
        }
        if (G.isTimestampSchema()) {
          let I = this.settings.timestampFormat;
          switch (I.useTrait ? G.getSchema() === oHA.SCHEMA.TIMESTAMP_DEFAULT ? I.default : G.getSchema() ?? I.default : I.default) {
            case oHA.SCHEMA.TIMESTAMP_DATE_TIME:
              return (0, Y6A.parseRfc3339DateTimeWithOffset)(Q);
            case oHA.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, Y6A.parseRfc7231DateTime)(Q);
            case oHA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return (0, Y6A.parseEpochTimestamp)(Q);
            default:
              return console.warn("Missing timestamp format, parsing value with Date constructor:", Q), new Date(Q)
          }
        }
        if (G.isBigIntegerSchema() && (typeof Q === "number" || typeof Q === "string")) return BigInt(Q);
        if (G.isBigDecimalSchema() && Q != null) {
          if (Q instanceof Y6A.NumericValue) return Q;
          return new Y6A.NumericValue(String(Q), "bigDecimal")
        }
        if (G.isNumericSchema() && typeof Q === "string") switch (Q) {
          case "Infinity":
            return 1 / 0;
          case "-Infinity":
            return -1 / 0;
          case "NaN":
            return NaN
        }
        return Q
      }
    },
    J6A = b4(),
    IB8 = s6(),
    YB8 = s6(),
    JB8 = s6(),
    AqQ = String.fromCharCode(925),
    WB8 = class {
      static {
        J3(this, "JsonReplacer")
      }
      values = new Map;
      counter = 0;
      stage = 0;
      createReplacer() {
        if (this.stage === 1) throw Error("@aws-sdk/core/protocols - JsonReplacer already created.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        return this.stage = 1, (A, Q) => {
          if (Q instanceof JB8.NumericValue) {
            let B = `${AqQ+NaN+this.counter++}_` + Q.string;
            return this.values.set(`"${B}"`, Q.string), B
          }
          if (typeof Q === "bigint") {
            let B = Q.toString(),
              G = `${AqQ+"b"+this.counter++}_` + B;
            return this.values.set(`"${G}"`, B), G
          }
          return Q
        }
      }
      replaceInJson(A) {
        if (this.stage === 0) throw Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        if (this.stage = 2, this.counter === 0) return A;
        for (let [Q, B] of this.values) A = A.replace(Q, B);
        return A
      }
    },
    WqQ = class extends Xo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        J3(this, "JsonShapeSerializer")
      }
      buffer;
      rootSchema;
      write(A, Q) {
        this.rootSchema = J6A.NormalizedSchema.of(A), this.buffer = this._write(this.rootSchema, Q)
      }
      flush() {
        if (this.rootSchema?.isStructSchema() || this.rootSchema?.isDocumentSchema()) {
          let A = new WB8;
          return A.replaceInJson(JSON.stringify(this.buffer, A.createReplacer(), 0))
        }
        return this.buffer
      }
      _write(A, Q, B) {
        let G = Q !== null && typeof Q === "object",
          Z = J6A.NormalizedSchema.of(A);
        if (Z.isListSchema() && Array.isArray(Q)) {
          let Y = Z.getValueSchema(),
            J = [],
            W = !!Z.getMergedTraits().sparse;
          for (let X of Q)
            if (W || X != null) J.push(this._write(Y, X));
          return J
        } else if (Z.isMapSchema() && G) {
          let Y = Z.getValueSchema(),
            J = {},
            W = !!Z.getMergedTraits().sparse;
          for (let [X, V] of Object.entries(Q))
            if (W || V != null) J[X] = this._write(Y, V);
          return J
        } else if (Z.isStructSchema() && G) {
          let Y = {};
          for (let [J, W] of Z.structIterator()) {
            let X = this.settings.jsonName ? W.getMergedTraits().jsonName ?? J : J,
              V = this._write(W, Q[J], Z);
            if (V !== void 0) Y[X] = V
          }
          return Y
        }
        if (Q === null && B?.isStructSchema()) return;
        if (Z.isBlobSchema() && (Q instanceof Uint8Array || typeof Q === "string")) {
          if (Z === this.rootSchema) return Q;
          if (!this.serdeContext?.base64Encoder) throw Error("Missing base64Encoder in serdeContext");
          return this.serdeContext?.base64Encoder(Q)
        }
        if (Z.isTimestampSchema() && Q instanceof Date) {
          let Y = this.settings.timestampFormat;
          switch (Y.useTrait ? Z.getSchema() === J6A.SCHEMA.TIMESTAMP_DEFAULT ? Y.default : Z.getSchema() ?? Y.default : Y.default) {
            case J6A.SCHEMA.TIMESTAMP_DATE_TIME:
              return Q.toISOString().replace(".000Z", "Z");
            case J6A.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, IB8.dateToUtcString)(Q);
            case J6A.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return Q.getTime() / 1000;
            default:
              return console.warn("Missing timestamp format, using epoch seconds", Q), Q.getTime() / 1000
          }
        }
        if (Z.isNumericSchema() && typeof Q === "number") {
          if (Math.abs(Q) === 1 / 0 || isNaN(Q)) return String(Q)
        }
        let I = Z.getMergedTraits().mediaType;
        if (Z.isStringSchema() && typeof Q === "string" && I) {
          if (I === "application/json" || I.endsWith("+json")) return YB8.LazyJsonString.from(Q)
        }
        return Q
      }
    },
    iO1 = class extends Xo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        J3(this, "JsonCodec")
      }
      createSerializer() {
        let A = new WqQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new JqQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    nO1 = class extends eQ8.RpcProtocol {
      static {
        J3(this, "AwsJsonRpcProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        this.codec = new iO1({
          timestampFormat: {
            useTrait: !0,
            default: I6A.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          jsonName: !1
        }), this.serializer = this.codec.createSerializer(), this.deserializer = this.codec.createDeserializer()
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
            "x-amz-target": (this.getJsonRpcVersion() === "1.0" ? "JsonRpc10." : "JsonProtocol.") + I6A.NormalizedSchema.of(A).getName()
          }), (0, I6A.deref)(A.input) === "unit" || !G.body) G.body = "{}";
        try {
          G.headers["content-length"] = String((0, AB8.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      getPayloadCodec() {
        return this.codec
      }
      async handleError(A, Q, B, G, Z) {
        let I = lO1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = I6A.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = I6A.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = I6A.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    XB8 = class extends nO1 {
      static {
        J3(this, "AwsJson1_0Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_0"
      }
      getJsonRpcVersion() {
        return "1.0"
      }
    },
    VB8 = class extends nO1 {
      static {
        J3(this, "AwsJson1_1Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_1"
      }
      getJsonRpcVersion() {
        return "1.1"
      }
    },
    uO1 = w5(),
    tHA = b4(),
    FB8 = oK(),
    KB8 = class extends uO1.HttpBindingProtocol {
      static {
        J3(this, "AwsRestJsonProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: tHA.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          httpBindings: !0,
          jsonName: !0
        };
        this.codec = new iO1(Q), this.serializer = new uO1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new uO1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getShapeId() {
        return "aws.protocols#restJson1"
      }
      getPayloadCodec() {
        return this.codec
      }
      setSerdeContext(A) {
        this.codec.setSerdeContext(A), super.setSerdeContext(A)
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = tHA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (!G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/json"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/json"
          }
        }
        if (G.headers["content-type"] && !G.body) G.body = "{}";
        if (G.body) try {
          G.headers["content-length"] = String((0, FB8.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async handleError(A, Q, B, G, Z) {
        let I = lO1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = tHA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = tHA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = tHA.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    DB8 = S3(),
    HB8 = J3((A) => {
      if (A == null) return;
      if (typeof A === "object" && "__type" in A) delete A.__type;
      return (0, DB8.expectUnion)(A)
    }, "awsExpectUnion"),
    mO1 = w5(),
    fd = b4(),
    CB8 = oK(),
    EB8 = w5(),
    QqQ = b4(),
    zB8 = S3(),
    UB8 = O2(),
    $B8 = wS(),
    aO1 = class extends Xo {
      constructor(A) {
        super();
        this.settings = A, this.stringDeserializer = new EB8.FromStringShapeDeserializer(A)
      }
      static {
        J3(this, "XmlShapeDeserializer")
      }
      stringDeserializer;
      setSerdeContext(A) {
        this.serdeContext = A, this.stringDeserializer.setSerdeContext(A)
      }
      read(A, Q, B) {
        let G = QqQ.NormalizedSchema.of(A),
          Z = G.getMemberSchemas();
        if (G.isStructSchema() && G.isMemberSchema() && !!Object.values(Z).find((W) => {
            return !!W.getMemberTraits().eventPayload
          })) {
          let W = {},
            X = Object.keys(Z)[0];
          if (Z[X].isBlobSchema()) W[X] = Q;
          else W[X] = this.read(Z[X], Q);
          return W
        }
        let Y = (this.serdeContext?.utf8Encoder ?? UB8.toUtf8)(Q),
          J = this.parseXml(Y);
        return this.readSchema(A, B ? J[B] : J)
      }
      readSchema(A, Q) {
        let B = QqQ.NormalizedSchema.of(A),
          G = B.getMergedTraits(),
          Z = B.getSchema();
        if (B.isListSchema() && !Array.isArray(Q)) return this.readSchema(Z, [Q]);
        if (Q == null) return Q;
        if (typeof Q === "object") {
          let I = !!G.sparse,
            Y = !!G.xmlFlattened;
          if (B.isListSchema()) {
            let W = B.getValueSchema(),
              X = [],
              V = W.getMergedTraits().xmlName ?? "member",
              F = Y ? Q : (Q[0] ?? Q)[V],
              K = Array.isArray(F) ? F : [F];
            for (let D of K)
              if (D != null || I) X.push(this.readSchema(W, D));
            return X
          }
          let J = {};
          if (B.isMapSchema()) {
            let W = B.getKeySchema(),
              X = B.getValueSchema(),
              V;
            if (Y) V = Array.isArray(Q) ? Q : [Q];
            else V = Array.isArray(Q.entry) ? Q.entry : [Q.entry];
            let F = W.getMergedTraits().xmlName ?? "key",
              K = X.getMergedTraits().xmlName ?? "value";
            for (let D of V) {
              let H = D[F],
                C = D[K];
              if (C != null || I) J[H] = this.readSchema(X, C)
            }
            return J
          }
          if (B.isStructSchema()) {
            for (let [W, X] of B.structIterator()) {
              let V = X.getMergedTraits(),
                F = !V.httpPayload ? X.getMemberTraits().xmlName ?? W : V.xmlName ?? X.getName();
              if (Q[F] != null) J[W] = this.readSchema(X, Q[F])
            }
            return J
          }
          if (B.isDocumentSchema()) return Q;
          throw Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${B.getName(!0)}`)
        } else {
          if (B.isListSchema()) return [];
          else if (B.isMapSchema() || B.isStructSchema()) return {};
          return this.stringDeserializer.read(B, Q)
        }
      }
      parseXml(A) {
        if (A.length) {
          let Q = new $B8.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: J3((Y, J) => J.trim() === "" && J.includes(`
`) ? "" : void 0, "tagValueProcessor")
          });
          Q.addEntity("#xD", "\r"), Q.addEntity("#10", `
`);
          let B;
          try {
            B = Q.parse(A, !0)
          } catch (Y) {
            if (Y && typeof Y === "object") Object.defineProperty(Y, "$responseBodyText", {
              value: A
            });
            throw Y
          }
          let G = "#text",
            Z = Object.keys(B)[0],
            I = B[Z];
          if (I[G]) I[Z] = I[G], delete I[G];
          return (0, zB8.getValueFromTextNode)(I)
        }
        return {}
      }
    },
    dO1 = w5(),
    XmA = b4(),
    wB8 = s6(),
    qB8 = S3(),
    NB8 = Jo(),
    LB8 = class extends Xo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        J3(this, "QueryShapeSerializer")
      }
      buffer;
      write(A, Q, B = "") {
        if (this.buffer === void 0) this.buffer = "";
        let G = XmA.NormalizedSchema.of(A);
        if (B && !B.endsWith(".")) B += ".";
        if (G.isBlobSchema()) {
          if (typeof Q === "string" || Q instanceof Uint8Array) this.writeKey(B), this.writeValue((this.serdeContext?.base64Encoder ?? NB8.toBase64)(Q))
        } else if (G.isBooleanSchema() || G.isNumericSchema() || G.isStringSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigIntegerSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigDecimalSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(Q instanceof wB8.NumericValue ? Q.string : String(Q))
        } else if (G.isTimestampSchema()) {
          if (Q instanceof Date) switch (this.writeKey(B), (0, dO1.determineTimestampFormat)(G, this.settings)) {
            case XmA.SCHEMA.TIMESTAMP_DATE_TIME:
              this.writeValue(Q.toISOString().replace(".000Z", "Z"));
              break;
            case XmA.SCHEMA.TIMESTAMP_HTTP_DATE:
              this.writeValue((0, qB8.dateToUtcString)(Q));
              break;
            case XmA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              this.writeValue(String(Q.getTime() / 1000));
              break
          }
        } else if (G.isDocumentSchema()) throw Error(`@aws-sdk/core/protocols - QuerySerializer unsupported document type ${G.getName(!0)}`);
        else if (G.isListSchema()) {
          if (Array.isArray(Q))
            if (Q.length === 0) {
              if (this.settings.serializeEmptyLists) this.writeKey(B), this.writeValue("")
            } else {
              let Z = G.getValueSchema(),
                I = this.settings.flattenLists || G.getMergedTraits().xmlFlattened,
                Y = 1;
              for (let J of Q) {
                if (J == null) continue;
                let W = this.getKey("member", Z.getMergedTraits().xmlName),
                  X = I ? `${B}${Y}` : `${B}${W}.${Y}`;
                this.write(Z, J, X), ++Y
              }
            }
        } else if (G.isMapSchema()) {
          if (Q && typeof Q === "object") {
            let Z = G.getKeySchema(),
              I = G.getValueSchema(),
              Y = G.getMergedTraits().xmlFlattened,
              J = 1;
            for (let [W, X] of Object.entries(Q)) {
              if (X == null) continue;
              let V = this.getKey("key", Z.getMergedTraits().xmlName),
                F = Y ? `${B}${J}.${V}` : `${B}entry.${J}.${V}`,
                K = this.getKey("value", I.getMergedTraits().xmlName),
                D = Y ? `${B}${J}.${K}` : `${B}entry.${J}.${K}`;
              this.write(Z, W, F), this.write(I, X, D), ++J
            }
          }
        } else if (G.isStructSchema()) {
          if (Q && typeof Q === "object")
            for (let [Z, I] of G.structIterator()) {
              if (Q[Z] == null) continue;
              let Y = this.getKey(Z, I.getMergedTraits().xmlName),
                J = `${B}${Y}`;
              this.write(I, Q[Z], J)
            }
        } else if (G.isUnitSchema());
        else throw Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${G.getName(!0)}`)
      }
      flush() {
        if (this.buffer === void 0) throw Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
        let A = this.buffer;
        return delete this.buffer, A
      }
      getKey(A, Q) {
        let B = Q ?? A;
        if (this.settings.capitalizeKeys) return B[0].toUpperCase() + B.slice(1);
        return B
      }
      writeKey(A) {
        if (A.endsWith(".")) A = A.slice(0, A.length - 1);
        this.buffer += `&${(0,dO1.extendedEncodeURIComponent)(A)}=`
      }
      writeValue(A) {
        this.buffer += (0, dO1.extendedEncodeURIComponent)(A)
      }
    },
    XqQ = class extends mO1.RpcProtocol {
      constructor(A) {
        super({
          defaultNamespace: A.defaultNamespace
        });
        this.options = A;
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: fd.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !1,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace,
          serializeEmptyLists: !0
        };
        this.serializer = new LB8(Q), this.deserializer = new aO1(Q)
      }
      static {
        J3(this, "AwsQueryProtocol")
      }
      serializer;
      deserializer;
      getShapeId() {
        return "aws.protocols#awsQuery"
      }
      setSerdeContext(A) {
        this.serializer.setSerdeContext(A), this.deserializer.setSerdeContext(A)
      }
      getPayloadCodec() {
        throw Error("AWSQuery protocol has no payload codec.")
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": "application/x-www-form-urlencoded"
          }), (0, fd.deref)(A.input) === "unit" || !G.body) G.body = "";
        if (G.body = `Action=${A.name.split("#")[1]}&Version=${this.options.version}` + G.body, G.body.endsWith("&")) G.body = G.body.slice(-1);
        try {
          G.headers["content-length"] = String((0, CB8.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        let G = this.deserializer,
          Z = fd.NormalizedSchema.of(A.output),
          I = {};
        if (B.statusCode >= 300) {
          let X = await (0, mO1.collectBody)(B.body, Q);
          if (X.byteLength > 0) Object.assign(I, await G.read(fd.SCHEMA.DOCUMENT, X));
          await this.handleError(A, Q, B, I, this.deserializeMetadata(B))
        }
        for (let X in B.headers) {
          let V = B.headers[X];
          delete B.headers[X], B.headers[X.toLowerCase()] = V
        }
        let Y = Z.isStructSchema() && this.useNestedResult() ? A.name.split("#")[1] + "Result" : void 0,
          J = await (0, mO1.collectBody)(B.body, Q);
        if (J.byteLength > 0) Object.assign(I, await G.read(Z, J, Y));
        return {
          $metadata: this.deserializeMetadata(B),
          ...I
        }
      }
      useNestedResult() {
        return !0
      }
      async handleError(A, Q, B, G, Z) {
        let I = this.loadQueryErrorCode(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = this.loadQueryError(G),
          X = fd.TypeRegistry.for(Y),
          V;
        try {
          if (V = X.find((C) => fd.NormalizedSchema.of(C).getMergedTraits().awsQueryError?.[0] === J), !V) V = X.getSchema(I)
        } catch (C) {
          let E = fd.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (E) {
            let U = E.ctor;
            throw Object.assign(new U(J), W)
          }
          throw Error(J)
        }
        let F = fd.NormalizedSchema.of(V),
          K = this.loadQueryErrorMessage(G),
          D = new V.ctor(K),
          H = {};
        for (let [C, E] of F.structIterator()) {
          let U = E.getMergedTraits().xmlName ?? C,
            q = W[U] ?? G[U];
          H[C] = this.deserializer.readSchema(E, q)
        }
        throw Object.assign(D, {
          $metadata: Z,
          $response: B,
          $fault: F.getMergedTraits().error,
          message: K,
          ...H
        }), D
      }
      loadQueryErrorCode(A, Q) {
        let B = (Q.Errors?.[0]?.Error ?? Q.Errors?.Error ?? Q.Error)?.Code;
        if (B !== void 0) return B;
        if (A.statusCode == 404) return "NotFound"
      }
      loadQueryError(A) {
        return A.Errors?.[0]?.Error ?? A.Errors?.Error ?? A.Error
      }
      loadQueryErrorMessage(A) {
        let Q = this.loadQueryError(A);
        return Q?.message ?? Q?.Message ?? A.message ?? A.Message ?? "Unknown"
      }
    },
    MB8 = class extends XqQ {
      constructor(A) {
        super(A);
        this.options = A;
        let Q = {
          capitalizeKeys: !0,
          flattenLists: !0,
          serializeEmptyLists: !1
        };
        Object.assign(this.serializer.settings, Q)
      }
      static {
        J3(this, "AwsEc2QueryProtocol")
      }
      useNestedResult() {
        return !1
      }
    },
    cO1 = w5(),
    eHA = b4(),
    OB8 = oK(),
    RB8 = S3(),
    TB8 = wS(),
    VqQ = J3((A, Q) => YqQ(A, Q).then((B) => {
      if (B.length) {
        let G = new TB8.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: !0,
          ignoreAttributes: !1,
          ignoreDeclaration: !0,
          parseTagValue: !1,
          trimValues: !1,
          tagValueProcessor: J3((W, X) => X.trim() === "" && X.includes(`
`) ? "" : void 0, "tagValueProcessor")
        });
        G.addEntity("#xD", "\r"), G.addEntity("#10", `
`);
        let Z;
        try {
          Z = G.parse(B, !0)
        } catch (W) {
          if (W && typeof W === "object") Object.defineProperty(W, "$responseBodyText", {
            value: B
          });
          throw W
        }
        let I = "#text",
          Y = Object.keys(Z)[0],
          J = Z[Y];
        if (J[I]) J[Y] = J[I], delete J[I];
        return (0, RB8.getValueFromTextNode)(J)
      }
      return {}
    }), "parseXmlBody"),
    PB8 = J3(async (A, Q) => {
      let B = await VqQ(A, Q);
      if (B.Error) B.Error.message = B.Error.message ?? B.Error.Message;
      return B
    }, "parseXmlErrorBody"),
    FqQ = J3((A, Q) => {
      if (Q?.Error?.Code !== void 0) return Q.Error.Code;
      if (Q?.Code !== void 0) return Q.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadRestXmlErrorCode"),
    bS = rDA(),
    Wo = b4(),
    jB8 = s6(),
    BqQ = S3(),
    GqQ = Jo(),
    KqQ = class extends Xo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        J3(this, "XmlShapeSerializer")
      }
      stringBuffer;
      byteBuffer;
      buffer;
      write(A, Q) {
        let B = Wo.NormalizedSchema.of(A);
        if (B.isStringSchema() && typeof Q === "string") this.stringBuffer = Q;
        else if (B.isBlobSchema()) this.byteBuffer = "byteLength" in Q ? Q : (this.serdeContext?.base64Decoder ?? GqQ.fromBase64)(Q);
        else {
          this.buffer = this.writeStruct(B, Q, void 0);
          let G = B.getMergedTraits();
          if (G.httpPayload && !G.xmlName) this.buffer.withName(B.getName())
        }
      }
      flush() {
        if (this.byteBuffer !== void 0) {
          let Q = this.byteBuffer;
          return delete this.byteBuffer, Q
        }
        if (this.stringBuffer !== void 0) {
          let Q = this.stringBuffer;
          return delete this.stringBuffer, Q
        }
        let A = this.buffer;
        if (this.settings.xmlNamespace) {
          if (!A?.attributes?.xmlns) A.addAttribute("xmlns", this.settings.xmlNamespace)
        }
        return delete this.buffer, A.toString()
      }
      writeStruct(A, Q, B) {
        let G = A.getMergedTraits(),
          Z = A.isMemberSchema() && !G.httpPayload ? A.getMemberTraits().xmlName ?? A.getMemberName() : G.xmlName ?? A.getName();
        if (!Z || !A.isStructSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${A.getName(!0)}.`);
        let I = bS.XmlNode.of(Z),
          [Y, J] = this.getXmlnsAttribute(A, B);
        if (J) I.addAttribute(Y, J);
        for (let [W, X] of A.structIterator()) {
          let V = Q[W];
          if (V != null) {
            if (X.getMergedTraits().xmlAttribute) {
              I.addAttribute(X.getMergedTraits().xmlName ?? W, this.writeSimple(X, V));
              continue
            }
            if (X.isListSchema()) this.writeList(X, V, I, J);
            else if (X.isMapSchema()) this.writeMap(X, V, I, J);
            else if (X.isStructSchema()) I.addChildNode(this.writeStruct(X, V, J));
            else {
              let F = bS.XmlNode.of(X.getMergedTraits().xmlName ?? X.getMemberName());
              this.writeSimpleInto(X, V, F, J), I.addChildNode(F)
            }
          }
        }
        return I
      }
      writeList(A, Q, B, G) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${A.getName(!0)}`);
        let Z = A.getMergedTraits(),
          I = A.getValueSchema(),
          Y = I.getMergedTraits(),
          J = !!Y.sparse,
          W = !!Z.xmlFlattened,
          [X, V] = this.getXmlnsAttribute(A, G),
          F = J3((K, D) => {
            if (I.isListSchema()) this.writeList(I, Array.isArray(D) ? D : [D], K, V);
            else if (I.isMapSchema()) this.writeMap(I, D, K, V);
            else if (I.isStructSchema()) {
              let H = this.writeStruct(I, D, V);
              K.addChildNode(H.withName(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member"))
            } else {
              let H = bS.XmlNode.of(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member");
              this.writeSimpleInto(I, D, H, V), K.addChildNode(H)
            }
          }, "writeItem");
        if (W) {
          for (let K of Q)
            if (J || K != null) F(B, K)
        } else {
          let K = bS.XmlNode.of(Z.xmlName ?? A.getMemberName());
          if (V) K.addAttribute(X, V);
          for (let D of Q)
            if (J || D != null) F(K, D);
          B.addChildNode(K)
        }
      }
      writeMap(A, Q, B, G, Z = !1) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${A.getName(!0)}`);
        let I = A.getMergedTraits(),
          Y = A.getKeySchema(),
          W = Y.getMergedTraits().xmlName ?? "key",
          X = A.getValueSchema(),
          V = X.getMergedTraits(),
          F = V.xmlName ?? "value",
          K = !!V.sparse,
          D = !!I.xmlFlattened,
          [H, C] = this.getXmlnsAttribute(A, G),
          E = J3((U, q, w) => {
            let N = bS.XmlNode.of(W, q),
              [R, T] = this.getXmlnsAttribute(Y, C);
            if (T) N.addAttribute(R, T);
            U.addChildNode(N);
            let y = bS.XmlNode.of(F);
            if (X.isListSchema()) this.writeList(X, w, y, C);
            else if (X.isMapSchema()) this.writeMap(X, w, y, C, !0);
            else if (X.isStructSchema()) y = this.writeStruct(X, w, C);
            else this.writeSimpleInto(X, w, y, C);
            U.addChildNode(y)
          }, "addKeyValue");
        if (D) {
          for (let [U, q] of Object.entries(Q))
            if (K || q != null) {
              let w = bS.XmlNode.of(I.xmlName ?? A.getMemberName());
              E(w, U, q), B.addChildNode(w)
            }
        } else {
          let U;
          if (!Z) {
            if (U = bS.XmlNode.of(I.xmlName ?? A.getMemberName()), C) U.addAttribute(H, C);
            B.addChildNode(U)
          }
          for (let [q, w] of Object.entries(Q))
            if (K || w != null) {
              let N = bS.XmlNode.of("entry");
              E(N, q, w), (Z ? B : U).addChildNode(N)
            }
        }
      }
      writeSimple(A, Q) {
        if (Q === null) throw Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
        let B = Wo.NormalizedSchema.of(A),
          G = null;
        if (Q && typeof Q === "object")
          if (B.isBlobSchema()) G = (this.serdeContext?.base64Encoder ?? GqQ.toBase64)(Q);
          else if (B.isTimestampSchema() && Q instanceof Date) {
          let Z = this.settings.timestampFormat;
          switch (Z.useTrait ? B.getSchema() === Wo.SCHEMA.TIMESTAMP_DEFAULT ? Z.default : B.getSchema() ?? Z.default : Z.default) {
            case Wo.SCHEMA.TIMESTAMP_DATE_TIME:
              G = Q.toISOString().replace(".000Z", "Z");
              break;
            case Wo.SCHEMA.TIMESTAMP_HTTP_DATE:
              G = (0, BqQ.dateToUtcString)(Q);
              break;
            case Wo.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              G = String(Q.getTime() / 1000);
              break;
            default:
              console.warn("Missing timestamp format, using http date", Q), G = (0, BqQ.dateToUtcString)(Q);
              break
          }
        } else if (B.isBigDecimalSchema() && Q) {
          if (Q instanceof jB8.NumericValue) return Q.string;
          return String(Q)
        } else if (B.isMapSchema() || B.isListSchema()) throw Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
        else throw Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${B.getName(!0)}`);
        if (B.isStringSchema() || B.isBooleanSchema() || B.isNumericSchema() || B.isBigIntegerSchema() || B.isBigDecimalSchema()) G = String(Q);
        if (G === null) throw Error(`Unhandled schema-value pair ${B.getName(!0)}=${Q}`);
        return G
      }
      writeSimpleInto(A, Q, B, G) {
        let Z = this.writeSimple(A, Q),
          I = Wo.NormalizedSchema.of(A),
          Y = new bS.XmlText(Z),
          [J, W] = this.getXmlnsAttribute(I, G);
        if (W) B.addAttribute(J, W);
        B.addChildNode(Y)
      }
      getXmlnsAttribute(A, Q) {
        let B = A.getMergedTraits(),
          [G, Z] = B.xmlNamespace ?? [];
        if (Z && Z !== Q) return [G ? `xmlns:${G}` : "xmlns", Z];
        return [void 0, void 0]
      }
    },
    DqQ = class extends Xo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        J3(this, "XmlCodec")
      }
      createSerializer() {
        let A = new KqQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new aO1(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    SB8 = class extends cO1.HttpBindingProtocol {
      static {
        J3(this, "AwsRestXmlProtocol")
      }
      codec;
      serializer;
      deserializer;
      constructor(A) {
        super(A);
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: eHA.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !0,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace
        };
        this.codec = new DqQ(Q), this.serializer = new cO1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new cO1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getPayloadCodec() {
        return this.codec
      }
      getShapeId() {
        return "aws.protocols#restXml"
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = eHA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (G.path = String(G.path).split("/").filter((Y) => {
            return Y !== "{Bucket}"
          }).join("/") || "/", !G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/xml"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/xml"
          }
        }
        if (G.headers["content-type"] === "application/xml") {
          if (typeof G.body === "string") G.body = '<?xml version="1.0" encoding="UTF-8"?>' + G.body
        }
        if (G.body) try {
          G.headers["content-length"] = String((0, OB8.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        return super.deserializeResponse(A, Q, B)
      }
      async handleError(A, Q, B, G, Z) {
        let I = FqQ(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = eHA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = eHA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = eHA.NormalizedSchema.of(X),
          F = G.Error?.message ?? G.Error?.Message ?? G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().xmlName ?? H,
            U = G.Error?.[E] ?? G[E];
          D[H] = this.codec.createDeserializer().readSchema(C, U)
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    }
})
// @from(Start 3438719, End 3438916)
nz = z((ACA) => {
  Object.defineProperty(ACA, "__esModule", {
    value: !0
  });
  var sO1 = sr();
  sO1.__exportStar(LL(), ACA);
  sO1.__exportStar(fO1(), ACA);
  sO1.__exportStar(CqQ(), ACA)
})
// @from(Start 3438922, End 3444576)
QCA = z((dN7, TqQ) => {
  var {
    defineProperty: KmA,
    getOwnPropertyDescriptor: _B8,
    getOwnPropertyNames: kB8
  } = Object, yB8 = Object.prototype.hasOwnProperty, Ab = (A, Q) => KmA(A, "name", {
    value: Q,
    configurable: !0
  }), xB8 = (A, Q) => {
    for (var B in Q) KmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vB8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of kB8(Q))
        if (!yB8.call(A, Z) && Z !== B) KmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _B8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bB8 = (A) => vB8(KmA({}, "__esModule", {
    value: !0
  }), A), $qQ = {};
  xB8($qQ, {
    DEFAULT_UA_APP_ID: () => wqQ,
    getUserAgentMiddlewareOptions: () => RqQ,
    getUserAgentPlugin: () => pB8,
    resolveUserAgentConfig: () => NqQ,
    userAgentMiddleware: () => OqQ
  });
  TqQ.exports = bB8($qQ);
  var fB8 = iB(),
    wqQ = void 0;

  function qqQ(A) {
    if (A === void 0) return !0;
    return typeof A === "string" && A.length <= 50
  }
  Ab(qqQ, "isValidUserAgentAppId");

  function NqQ(A) {
    let Q = (0, fB8.normalizeProvider)(A.userAgentAppId ?? wqQ),
      {
        customUserAgent: B
      } = A;
    return Object.assign(A, {
      customUserAgent: typeof B === "string" ? [
        [B]
      ] : B,
      userAgentAppId: Ab(async () => {
        let G = await Q();
        if (!qqQ(G)) {
          let Z = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console : A.logger;
          if (typeof G !== "string") Z?.warn("userAgentAppId must be a string or undefined.");
          else if (G.length > 50) Z?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.")
        }
        return G
      }, "userAgentAppId")
    })
  }
  Ab(NqQ, "resolveUserAgentConfig");
  var hB8 = sHA(),
    gB8 = Lw(),
    fS = nz(),
    uB8 = /\d{12}\.ddb/;
  async function LqQ(A, Q, B) {
    if (B.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor")(0, fS.setFeature)(A, "PROTOCOL_RPC_V2_CBOR", "M");
    if (typeof Q.retryStrategy === "function") {
      let I = await Q.retryStrategy();
      if (typeof I.acquireInitialRetryToken === "function")
        if (I.constructor?.name?.includes("Adaptive"))(0, fS.setFeature)(A, "RETRY_MODE_ADAPTIVE", "F");
        else(0, fS.setFeature)(A, "RETRY_MODE_STANDARD", "E");
      else(0, fS.setFeature)(A, "RETRY_MODE_LEGACY", "D")
    }
    if (typeof Q.accountIdEndpointMode === "function") {
      let I = A.endpointV2;
      if (String(I?.url?.hostname).match(uB8))(0, fS.setFeature)(A, "ACCOUNT_ID_ENDPOINT", "O");
      switch (await Q.accountIdEndpointMode?.()) {
        case "disabled":
          (0, fS.setFeature)(A, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, fS.setFeature)(A, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, fS.setFeature)(A, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break
      }
    }
    let Z = A.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (Z?.$source) {
      let I = Z;
      if (I.accountId)(0, fS.setFeature)(A, "RESOLVED_ACCOUNT_ID", "T");
      for (let [Y, J] of Object.entries(I.$source ?? {}))(0, fS.setFeature)(A, Y, J)
    }
  }
  Ab(LqQ, "checkFeatures");
  var EqQ = "user-agent",
    rO1 = "x-amz-user-agent",
    zqQ = " ",
    oO1 = "/",
    mB8 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
    dB8 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
    UqQ = "-",
    cB8 = 1024;

  function MqQ(A) {
    let Q = "";
    for (let B in A) {
      let G = A[B];
      if (Q.length + G.length + 1 <= cB8) {
        if (Q.length) Q += "," + G;
        else Q += G;
        continue
      }
      break
    }
    return Q
  }
  Ab(MqQ, "encodeFeatures");
  var OqQ = Ab((A) => (Q, B) => async (G) => {
      let {
        request: Z
      } = G;
      if (!gB8.HttpRequest.isInstance(Z)) return Q(G);
      let {
        headers: I
      } = Z, Y = B?.userAgent?.map(FmA) || [], J = (await A.defaultUserAgentProvider()).map(FmA);
      await LqQ(B, A, G);
      let W = B;
      J.push(`m/${MqQ(Object.assign({},B.__smithy_context?.features,W.__aws_sdk_context?.features))}`);
      let X = A?.customUserAgent?.map(FmA) || [],
        V = await A.userAgentAppId();
      if (V) J.push(FmA([`app/${V}`]));
      let F = (0, hB8.getUserAgentPrefix)(),
        K = (F ? [F] : []).concat([...J, ...Y, ...X]).join(zqQ),
        D = [...J.filter((H) => H.startsWith("aws-sdk-")), ...X].join(zqQ);
      if (A.runtime !== "browser") {
        if (D) I[rO1] = I[rO1] ? `${I[EqQ]} ${D}` : D;
        I[EqQ] = K
      } else I[rO1] = K;
      return Q({
        ...G,
        request: Z
      })
    }, "userAgentMiddleware"),
    FmA = Ab((A) => {
      let Q = A[0].split(oO1).map((Y) => Y.replace(mB8, UqQ)).join(oO1),
        B = A[1]?.replace(dB8, UqQ),
        G = Q.indexOf(oO1),
        Z = Q.substring(0, G),
        I = Q.substring(G + 1);
      if (Z === "api") I = I.toLowerCase();
      return [Z, I, B].filter((Y) => Y && Y.length > 0).reduce((Y, J, W) => {
        switch (W) {
          case 0:
            return J;
          case 1:
            return `${Y}/${J}`;
          default:
            return `${Y}#${J}`
        }
      }, "")
    }, "escapeUserAgent"),
    RqQ = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: !0
    },
    pB8 = Ab((A) => ({
      applyToStack: Ab((Q) => {
        Q.add(OqQ(A), RqQ)
      }, "applyToStack")
    }), "getUserAgentPlugin")
})
// @from(Start 3444582, End 3446239)
eO1 = z((PqQ) => {
  Object.defineProperty(PqQ, "__esModule", {
    value: !0
  });
  PqQ.resolveHttpAuthSchemeConfig = PqQ.resolveStsAuthConfig = PqQ.defaultSTSHttpAuthSchemeProvider = PqQ.defaultSTSHttpAuthSchemeParametersProvider = void 0;
  var lB8 = nz(),
    tO1 = w7(),
    iB8 = BCA(),
    nB8 = async (A, Q, B) => {
      return {
        operation: (0, tO1.getSmithyContext)(Q).operation,
        region: await (0, tO1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  PqQ.defaultSTSHttpAuthSchemeParametersProvider = nB8;

  function aB8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function sB8(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var rB8 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "AssumeRoleWithWebIdentity": {
        Q.push(sB8(A));
        break
      }
      default:
        Q.push(aB8(A))
    }
    return Q
  };
  PqQ.defaultSTSHttpAuthSchemeProvider = rB8;
  var oB8 = (A) => Object.assign(A, {
    stsClientCtor: iB8.STSClient
  });
  PqQ.resolveStsAuthConfig = oB8;
  var tB8 = (A) => {
    let Q = PqQ.resolveStsAuthConfig(A),
      B = (0, lB8.resolveAwsSdkSigV4Config)(Q);
    return Object.assign(B, {
      authSchemePreference: (0, tO1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  PqQ.resolveHttpAuthSchemeConfig = tB8
})
// @from(Start 3446245, End 3447133)
GCA = z((_qQ) => {
  Object.defineProperty(_qQ, "__esModule", {
    value: !0
  });
  _qQ.commonParams = _qQ.resolveClientEndpointParameters = void 0;
  var Q28 = (A) => {
    return Object.assign(A, {
      useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
      useFipsEndpoint: A.useFipsEndpoint ?? !1,
      useGlobalEndpoint: A.useGlobalEndpoint ?? !1,
      defaultSigningName: "sts"
    })
  };
  _qQ.resolveClientEndpointParameters = Q28;
  _qQ.commonParams = {
    UseGlobalEndpoint: {
      type: "builtInParams",
      name: "useGlobalEndpoint"
    },
    UseFIPS: {
      type: "builtInParams",
      name: "useFipsEndpoint"
    },
    Endpoint: {
      type: "builtInParams",
      name: "endpoint"
    },
    Region: {
      type: "builtInParams",
      name: "region"
    },
    UseDualStack: {
      type: "builtInParams",
      name: "useDualstackEndpoint"
    }
  }
})
// @from(Start 3447139, End 3451424)
AR1 = z((lN7, G28) => {
  G28.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.840.0",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=18.0.0"
    },
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["./sso-oidc.d.ts", "./sso-oidc.js", "./sts.d.ts", "./sts.js", "dist-*/**"],
    browser: {
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./sso-oidc": {
        types: "./dist-types/submodules/sso-oidc/index.d.ts",
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js"
      },
      "./sts": {
        types: "./dist-types/submodules/sts/index.d.ts",
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js"
      }
    }
  }
})
// @from(Start 3451430, End 3453606)
CmA = z((iN7, gqQ) => {
  var {
    defineProperty: HmA,
    getOwnPropertyDescriptor: Z28,
    getOwnPropertyNames: I28
  } = Object, Y28 = Object.prototype.hasOwnProperty, DmA = (A, Q) => HmA(A, "name", {
    value: Q,
    configurable: !0
  }), J28 = (A, Q) => {
    for (var B in Q) HmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, W28 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of I28(Q))
        if (!Y28.call(A, Z) && Z !== B) HmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Z28(Q, Z)) || G.enumerable
        })
    }
    return A
  }, X28 = (A) => W28(HmA({}, "__esModule", {
    value: !0
  }), A), xqQ = {};
  J28(xqQ, {
    NODE_APP_ID_CONFIG_OPTIONS: () => H28,
    UA_APP_ID_ENV_NAME: () => fqQ,
    UA_APP_ID_INI_NAME: () => hqQ,
    createDefaultUserAgentProvider: () => bqQ,
    crtAvailability: () => vqQ,
    defaultUserAgent: () => F28
  });
  gqQ.exports = X28(xqQ);
  var yqQ = UA("os"),
    QR1 = UA("process"),
    vqQ = {
      isCrtAvailable: !1
    },
    V28 = DmA(() => {
      if (vqQ.isCrtAvailable) return ["md/crt-avail"];
      return null
    }, "isCrtAvailable"),
    bqQ = DmA(({
      serviceId: A,
      clientVersion: Q
    }) => {
      return async (B) => {
        let G = [
            ["aws-sdk-js", Q],
            ["ua", "2.1"],
            [`os/${(0,yqQ.platform)()}`, (0, yqQ.release)()],
            ["lang/js"],
            ["md/nodejs", `${QR1.versions.node}`]
          ],
          Z = V28();
        if (Z) G.push(Z);
        if (A) G.push([`api/${A}`, Q]);
        if (QR1.env.AWS_EXECUTION_ENV) G.push([`exec-env/${QR1.env.AWS_EXECUTION_ENV}`]);
        let I = await B?.userAgentAppId?.();
        return I ? [...G, [`app/${I}`]] : [...G]
      }
    }, "createDefaultUserAgentProvider"),
    F28 = bqQ,
    K28 = QCA(),
    fqQ = "AWS_SDK_UA_APP_ID",
    hqQ = "sdk_ua_app_id",
    D28 = "sdk-ua-app-id",
    H28 = {
      environmentVariableSelector: DmA((A) => A[fqQ], "environmentVariableSelector"),
      configFileSelector: DmA((A) => A[hqQ] ?? A[D28], "configFileSelector"),
      default: K28.DEFAULT_UA_APP_ID
    }
})
// @from(Start 3453612, End 3461789)
XNQ = z((JNQ) => {
  Object.defineProperty(JNQ, "__esModule", {
    value: !0
  });
  JNQ.ruleSet = void 0;
  var oqQ = "required",
    m8 = "type",
    Q7 = "fn",
    B7 = "argv",
    gd = "ref",
    uqQ = !1,
    BR1 = !0,
    hd = "booleanEquals",
    WD = "stringEquals",
    tqQ = "sigv4",
    eqQ = "sts",
    ANQ = "us-east-1",
    nI = "endpoint",
    mqQ = "https://sts.{Region}.{PartitionResult#dnsSuffix}",
    hS = "tree",
    W6A = "error",
    ZR1 = "getAttr",
    dqQ = {
      [oqQ]: !1,
      [m8]: "String"
    },
    GR1 = {
      [oqQ]: !0,
      default: !1,
      [m8]: "Boolean"
    },
    QNQ = {
      [gd]: "Endpoint"
    },
    cqQ = {
      [Q7]: "isSet",
      [B7]: [{
        [gd]: "Region"
      }]
    },
    XD = {
      [gd]: "Region"
    },
    pqQ = {
      [Q7]: "aws.partition",
      [B7]: [XD],
      assign: "PartitionResult"
    },
    BNQ = {
      [gd]: "UseFIPS"
    },
    GNQ = {
      [gd]: "UseDualStack"
    },
    MH = {
      url: "https://sts.amazonaws.com",
      properties: {
        authSchemes: [{
          name: tqQ,
          signingName: eqQ,
          signingRegion: ANQ
        }]
      },
      headers: {}
    },
    Mw = {},
    lqQ = {
      conditions: [{
        [Q7]: WD,
        [B7]: [XD, "aws-global"]
      }],
      [nI]: MH,
      [m8]: nI
    },
    ZNQ = {
      [Q7]: hd,
      [B7]: [BNQ, !0]
    },
    INQ = {
      [Q7]: hd,
      [B7]: [GNQ, !0]
    },
    iqQ = {
      [Q7]: ZR1,
      [B7]: [{
        [gd]: "PartitionResult"
      }, "supportsFIPS"]
    },
    YNQ = {
      [gd]: "PartitionResult"
    },
    nqQ = {
      [Q7]: hd,
      [B7]: [!0, {
        [Q7]: ZR1,
        [B7]: [YNQ, "supportsDualStack"]
      }]
    },
    aqQ = [{
      [Q7]: "isSet",
      [B7]: [QNQ]
    }],
    sqQ = [ZNQ],
    rqQ = [INQ],
    C28 = {
      version: "1.0",
      parameters: {
        Region: dqQ,
        UseDualStack: GR1,
        UseFIPS: GR1,
        Endpoint: dqQ,
        UseGlobalEndpoint: GR1
      },
      rules: [{
        conditions: [{
          [Q7]: hd,
          [B7]: [{
            [gd]: "UseGlobalEndpoint"
          }, BR1]
        }, {
          [Q7]: "not",
          [B7]: aqQ
        }, cqQ, pqQ, {
          [Q7]: hd,
          [B7]: [BNQ, uqQ]
        }, {
          [Q7]: hd,
          [B7]: [GNQ, uqQ]
        }],
        rules: [{
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "ap-northeast-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "ap-south-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "ap-southeast-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "ap-southeast-2"]
          }],
          endpoint: MH,
          [m8]: nI
        }, lqQ, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "ca-central-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "eu-central-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "eu-north-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "eu-west-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "eu-west-2"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "eu-west-3"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "sa-east-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, ANQ]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "us-east-2"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "us-west-1"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          conditions: [{
            [Q7]: WD,
            [B7]: [XD, "us-west-2"]
          }],
          endpoint: MH,
          [m8]: nI
        }, {
          endpoint: {
            url: mqQ,
            properties: {
              authSchemes: [{
                name: tqQ,
                signingName: eqQ,
                signingRegion: "{Region}"
              }]
            },
            headers: Mw
          },
          [m8]: nI
        }],
        [m8]: hS
      }, {
        conditions: aqQ,
        rules: [{
          conditions: sqQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          [m8]: W6A
        }, {
          conditions: rqQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          [m8]: W6A
        }, {
          endpoint: {
            url: QNQ,
            properties: Mw,
            headers: Mw
          },
          [m8]: nI
        }],
        [m8]: hS
      }, {
        conditions: [cqQ],
        rules: [{
          conditions: [pqQ],
          rules: [{
            conditions: [ZNQ, INQ],
            rules: [{
              conditions: [{
                [Q7]: hd,
                [B7]: [BR1, iqQ]
              }, nqQ],
              rules: [{
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: Mw,
                  headers: Mw
                },
                [m8]: nI
              }],
              [m8]: hS
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              [m8]: W6A
            }],
            [m8]: hS
          }, {
            conditions: sqQ,
            rules: [{
              conditions: [{
                [Q7]: hd,
                [B7]: [iqQ, BR1]
              }],
              rules: [{
                conditions: [{
                  [Q7]: WD,
                  [B7]: [{
                    [Q7]: ZR1,
                    [B7]: [YNQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://sts.{Region}.amazonaws.com",
                  properties: Mw,
                  headers: Mw
                },
                [m8]: nI
              }, {
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: Mw,
                  headers: Mw
                },
                [m8]: nI
              }],
              [m8]: hS
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              [m8]: W6A
            }],
            [m8]: hS
          }, {
            conditions: rqQ,
            rules: [{
              conditions: [nqQ],
              rules: [{
                endpoint: {
                  url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: Mw,
                  headers: Mw
                },
                [m8]: nI
              }],
              [m8]: hS
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              [m8]: W6A
            }],
            [m8]: hS
          }, lqQ, {
            endpoint: {
              url: mqQ,
              properties: Mw,
              headers: Mw
            },
            [m8]: nI
          }],
          [m8]: hS
        }],
        [m8]: hS
      }, {
        error: "Invalid Configuration: Missing Region",
        [m8]: W6A
      }]
    };
  JNQ.ruleSet = C28
})
// @from(Start 3461795, End 3462380)
KNQ = z((VNQ) => {
  Object.defineProperty(VNQ, "__esModule", {
    value: !0
  });
  VNQ.defaultEndpointResolver = void 0;
  var E28 = sHA(),
    IR1 = FI(),
    z28 = XNQ(),
    U28 = new IR1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    }),
    $28 = (A, Q = {}) => {
      return U28.get(A, () => (0, IR1.resolveEndpoint)(z28.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  VNQ.defaultEndpointResolver = $28;
  IR1.customEndpointFunctions.aws = E28.awsEndpointFunctions
})
// @from(Start 3462386, End 3463795)
zNQ = z((CNQ) => {
  Object.defineProperty(CNQ, "__esModule", {
    value: !0
  });
  CNQ.getRuntimeConfig = void 0;
  var w28 = nz(),
    q28 = iB(),
    N28 = S3(),
    L28 = NJ(),
    DNQ = Jo(),
    HNQ = O2(),
    M28 = eO1(),
    O28 = KNQ(),
    R28 = (A) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: A?.base64Decoder ?? DNQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? DNQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? O28.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? M28.defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new w28.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new q28.NoAuthSigner
        }],
        logger: A?.logger ?? new N28.NoOpLogger,
        serviceId: A?.serviceId ?? "STS",
        urlParser: A?.urlParser ?? L28.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? HNQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? HNQ.toUtf8
      }
    };
  CNQ.getRuntimeConfig = R28
})
// @from(Start 3463801, End 3466603)
LNQ = z((qNQ) => {
  Object.defineProperty(qNQ, "__esModule", {
    value: !0
  });
  qNQ.getRuntimeConfig = void 0;
  var T28 = sr(),
    P28 = T28.__importDefault(AR1()),
    YR1 = nz(),
    UNQ = CmA(),
    EmA = f8(),
    j28 = iB(),
    S28 = RX(),
    $NQ = D6(),
    Vo = uI(),
    wNQ = IZ(),
    _28 = TX(),
    k28 = KW(),
    y28 = zNQ(),
    x28 = S3(),
    v28 = PX(),
    b28 = S3(),
    f28 = (A) => {
      (0, b28.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, v28.resolveDefaultsModeConfig)(A),
        B = () => Q().then(x28.loadConfigsForDefaultMode),
        G = (0, y28.getRuntimeConfig)(A);
      (0, YR1.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Vo.loadConfig)(YR1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? _28.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, UNQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: P28.default.version
        }),
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (I) => I.getIdentityProvider("aws.auth#sigv4") || (async (Y) => await A.credentialDefaultProvider(Y?.__config || {})()),
          signer: new YR1.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (I) => I.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new j28.NoAuthSigner
        }],
        maxAttempts: A?.maxAttempts ?? (0, Vo.loadConfig)($NQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Vo.loadConfig)(EmA.NODE_REGION_CONFIG_OPTIONS, {
          ...EmA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: wNQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Vo.loadConfig)({
          ...$NQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || k28.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? S28.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? wNQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Vo.loadConfig)(EmA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Vo.loadConfig)(EmA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Vo.loadConfig)(UNQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  qNQ.getRuntimeConfig = f28
})
// @from(Start 3466609, End 3469212)
UmA = z((oN7, jNQ) => {
  var {
    defineProperty: zmA,
    getOwnPropertyDescriptor: h28,
    getOwnPropertyNames: g28
  } = Object, u28 = Object.prototype.hasOwnProperty, gS = (A, Q) => zmA(A, "name", {
    value: Q,
    configurable: !0
  }), m28 = (A, Q) => {
    for (var B in Q) zmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, d28 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of g28(Q))
        if (!u28.call(A, Z) && Z !== B) zmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = h28(Q, Z)) || G.enumerable
        })
    }
    return A
  }, c28 = (A) => d28(zmA({}, "__esModule", {
    value: !0
  }), A), ONQ = {};
  m28(ONQ, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => n28,
    NODE_REGION_CONFIG_OPTIONS: () => i28,
    REGION_ENV_NAME: () => RNQ,
    REGION_INI_NAME: () => TNQ,
    getAwsRegionExtensionConfiguration: () => p28,
    resolveAwsRegionExtensionConfiguration: () => l28,
    resolveRegionConfig: () => a28
  });
  jNQ.exports = c28(ONQ);
  var p28 = gS((A) => {
      return {
        setRegion(Q) {
          A.region = Q
        },
        region() {
          return A.region
        }
      }
    }, "getAwsRegionExtensionConfiguration"),
    l28 = gS((A) => {
      return {
        region: A.region()
      }
    }, "resolveAwsRegionExtensionConfiguration"),
    RNQ = "AWS_REGION",
    TNQ = "region",
    i28 = {
      environmentVariableSelector: gS((A) => A[RNQ], "environmentVariableSelector"),
      configFileSelector: gS((A) => A[TNQ], "configFileSelector"),
      default: gS(() => {
        throw Error("Region is missing")
      }, "default")
    },
    n28 = {
      preferredFile: "credentials"
    },
    PNQ = gS((A) => typeof A === "string" && (A.startsWith("fips-") || A.endsWith("-fips")), "isFipsRegion"),
    MNQ = gS((A) => PNQ(A) ? ["fips-aws-global", "aws-fips"].includes(A) ? "us-east-1" : A.replace(/fips-(dkr-|prod-)?|-fips/, "") : A, "getRealRegion"),
    a28 = gS((A) => {
      let {
        region: Q,
        useFipsEndpoint: B
      } = A;
      if (!Q) throw Error("Region is missing");
      return Object.assign(A, {
        region: gS(async () => {
          if (typeof Q === "string") return MNQ(Q);
          let G = await Q();
          return MNQ(G)
        }, "region"),
        useFipsEndpoint: gS(async () => {
          let G = typeof Q === "string" ? Q : await Q();
          if (PNQ(G)) return !0;
          return typeof B !== "function" ? Promise.resolve(!!B) : B()
        }, "useFipsEndpoint")
      })
    }, "resolveRegionConfig")
})
// @from(Start 3469218, End 3470237)
kNQ = z((SNQ) => {
  Object.defineProperty(SNQ, "__esModule", {
    value: !0
  });
  SNQ.resolveHttpAuthRuntimeConfig = SNQ.getHttpAuthExtensionConfiguration = void 0;
  var s28 = (A) => {
    let {
      httpAuthSchemes: Q,
      httpAuthSchemeProvider: B,
      credentials: G
    } = A;
    return {
      setHttpAuthScheme(Z) {
        let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
        if (I === -1) Q.push(Z);
        else Q.splice(I, 1, Z)
      },
      httpAuthSchemes() {
        return Q
      },
      setHttpAuthSchemeProvider(Z) {
        B = Z
      },
      httpAuthSchemeProvider() {
        return B
      },
      setCredentials(Z) {
        G = Z
      },
      credentials() {
        return G
      }
    }
  };
  SNQ.getHttpAuthExtensionConfiguration = s28;
  var r28 = (A) => {
    return {
      httpAuthSchemes: A.httpAuthSchemes(),
      httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
      credentials: A.credentials()
    }
  };
  SNQ.resolveHttpAuthRuntimeConfig = r28
})
// @from(Start 3470243, End 3470968)
gNQ = z((fNQ) => {
  Object.defineProperty(fNQ, "__esModule", {
    value: !0
  });
  fNQ.resolveRuntimeExtensions = void 0;
  var yNQ = UmA(),
    xNQ = Lw(),
    vNQ = S3(),
    bNQ = kNQ(),
    t28 = (A, Q) => {
      let B = Object.assign((0, yNQ.getAwsRegionExtensionConfiguration)(A), (0, vNQ.getDefaultExtensionConfiguration)(A), (0, xNQ.getHttpHandlerExtensionConfiguration)(A), (0, bNQ.getHttpAuthExtensionConfiguration)(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, yNQ.resolveAwsRegionExtensionConfiguration)(B), (0, vNQ.resolveDefaultRuntimeConfig)(B), (0, xNQ.resolveHttpHandlerRuntimeConfig)(B), (0, bNQ.resolveHttpAuthRuntimeConfig)(B))
    };
  fNQ.resolveRuntimeExtensions = t28
})
// @from(Start 3470974, End 3472956)
BCA = z((WR1) => {
  Object.defineProperty(WR1, "__esModule", {
    value: !0
  });
  WR1.STSClient = WR1.__Client = void 0;
  var uNQ = luA(),
    e28 = nuA(),
    A98 = ruA(),
    mNQ = QCA(),
    Q98 = f8(),
    JR1 = iB(),
    B98 = LX(),
    G98 = q5(),
    dNQ = D6(),
    pNQ = S3();
  Object.defineProperty(WR1, "__Client", {
    enumerable: !0,
    get: function() {
      return pNQ.Client
    }
  });
  var cNQ = eO1(),
    Z98 = GCA(),
    I98 = LNQ(),
    Y98 = gNQ();
  class lNQ extends pNQ.Client {
    config;
    constructor(...[A]) {
      let Q = (0, I98.getRuntimeConfig)(A || {});
      super(Q);
      this.initConfig = Q;
      let B = (0, Z98.resolveClientEndpointParameters)(Q),
        G = (0, mNQ.resolveUserAgentConfig)(B),
        Z = (0, dNQ.resolveRetryConfig)(G),
        I = (0, Q98.resolveRegionConfig)(Z),
        Y = (0, uNQ.resolveHostHeaderConfig)(I),
        J = (0, G98.resolveEndpointConfig)(Y),
        W = (0, cNQ.resolveHttpAuthSchemeConfig)(J),
        X = (0, Y98.resolveRuntimeExtensions)(W, A?.extensions || []);
      this.config = X, this.middlewareStack.use((0, mNQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, dNQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, B98.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, uNQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, e28.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, A98.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, JR1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: cNQ.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (V) => new JR1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": V.credentials
        })
      })), this.middlewareStack.use((0, JR1.getHttpSigningPlugin)(this.config))
    }
    destroy() {
      super.destroy()
    }
  }
  WR1.STSClient = lNQ
})
// @from(Start 3472962, End 3496334)
wmA = z((BL7, hR1) => {
  var {
    defineProperty: $mA,
    getOwnPropertyDescriptor: J98,
    getOwnPropertyNames: W98
  } = Object, X98 = Object.prototype.hasOwnProperty, k2 = (A, Q) => $mA(A, "name", {
    value: Q,
    configurable: !0
  }), V98 = (A, Q) => {
    for (var B in Q) $mA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, _R1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of W98(Q))
        if (!X98.call(A, Z) && Z !== B) $mA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = J98(Q, Z)) || G.enumerable
        })
    }
    return A
  }, F98 = (A, Q, B) => (_R1(A, Q, "default"), B && _R1(B, Q, "default")), K98 = (A) => _R1($mA({}, "__esModule", {
    value: !0
  }), A), yR1 = {};
  V98(yR1, {
    AssumeRoleCommand: () => bR1,
    AssumeRoleResponseFilterSensitiveLog: () => sNQ,
    AssumeRoleWithWebIdentityCommand: () => fR1,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => BLQ,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => GLQ,
    ClientInputEndpointParameters: () => Z48.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => xR1,
    ExpiredTokenException: () => rNQ,
    IDPCommunicationErrorException: () => ZLQ,
    IDPRejectedClaimException: () => ALQ,
    InvalidIdentityTokenException: () => QLQ,
    MalformedPolicyDocumentException: () => oNQ,
    PackedPolicyTooLargeException: () => tNQ,
    RegionDisabledException: () => eNQ,
    STS: () => CLQ,
    STSServiceException: () => Bb,
    decorateDefaultCredentialProvider: () => J48,
    getDefaultRoleAssumer: () => qLQ,
    getDefaultRoleAssumerWithWebIdentity: () => NLQ
  });
  hR1.exports = K98(yR1);
  F98(yR1, BCA(), hR1.exports);
  var D98 = S3(),
    H98 = q5(),
    C98 = GZ(),
    E98 = S3(),
    z98 = GCA(),
    aNQ = S3(),
    U98 = S3(),
    Bb = class A extends U98.ServiceException {
      static {
        k2(this, "STSServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    xR1 = k2((A) => ({
      ...A,
      ...A.SecretAccessKey && {
        SecretAccessKey: aNQ.SENSITIVE_STRING
      }
    }), "CredentialsFilterSensitiveLog"),
    sNQ = k2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: xR1(A.Credentials)
      }
    }), "AssumeRoleResponseFilterSensitiveLog"),
    rNQ = class A extends Bb {
      static {
        k2(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    oNQ = class A extends Bb {
      static {
        k2(this, "MalformedPolicyDocumentException")
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    tNQ = class A extends Bb {
      static {
        k2(this, "PackedPolicyTooLargeException")
      }
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    eNQ = class A extends Bb {
      static {
        k2(this, "RegionDisabledException")
      }
      name = "RegionDisabledException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    ALQ = class A extends Bb {
      static {
        k2(this, "IDPRejectedClaimException")
      }
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    QLQ = class A extends Bb {
      static {
        k2(this, "InvalidIdentityTokenException")
      }
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    BLQ = k2((A) => ({
      ...A,
      ...A.WebIdentityToken && {
        WebIdentityToken: aNQ.SENSITIVE_STRING
      }
    }), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog"),
    GLQ = k2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: xR1(A.Credentials)
      }
    }), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog"),
    ZLQ = class A extends Bb {
      static {
        k2(this, "IDPCommunicationErrorException")
      }
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    vR1 = nz(),
    $98 = Lw(),
    L7 = S3(),
    w98 = k2(async (A, Q) => {
      let B = VLQ,
        G;
      return G = HLQ({
        ..._98(A, Q),
        [KLQ]: s98,
        [DLQ]: FLQ
      }), XLQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleCommand"),
    q98 = k2(async (A, Q) => {
      let B = VLQ,
        G;
      return G = HLQ({
        ...k98(A, Q),
        [KLQ]: r98,
        [DLQ]: FLQ
      }), XLQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleWithWebIdentityCommand"),
    N98 = k2(async (A, Q) => {
      if (A.statusCode >= 300) return ILQ(A, Q);
      let B = await (0, vR1.parseXmlBody)(A.body, Q),
        G = {};
      return G = g98(B.AssumeRoleResult, Q), {
        $metadata: Gb(A),
        ...G
      }
    }, "de_AssumeRoleCommand"),
    L98 = k2(async (A, Q) => {
      if (A.statusCode >= 300) return ILQ(A, Q);
      let B = await (0, vR1.parseXmlBody)(A.body, Q),
        G = {};
      return G = u98(B.AssumeRoleWithWebIdentityResult, Q), {
        $metadata: Gb(A),
        ...G
      }
    }, "de_AssumeRoleWithWebIdentityCommand"),
    ILQ = k2(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, vR1.parseXmlErrorBody)(A.body, Q)
        },
        G = o98(A, B.body);
      switch (G) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await M98(B, Q);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await P98(B, Q);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await j98(B, Q);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await S98(B, Q);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await O98(B, Q);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await R98(B, Q);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await T98(B, Q);
        default:
          let Z = B.body;
          return a98({
            output: A,
            parsedBody: Z.Error,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    M98 = k2(async (A, Q) => {
      let B = A.body,
        G = m98(B.Error, Q),
        Z = new rNQ({
          $metadata: Gb(A),
          ...G
        });
      return (0, L7.decorateServiceException)(Z, B)
    }, "de_ExpiredTokenExceptionRes"),
    O98 = k2(async (A, Q) => {
      let B = A.body,
        G = d98(B.Error, Q),
        Z = new ZLQ({
          $metadata: Gb(A),
          ...G
        });
      return (0, L7.decorateServiceException)(Z, B)
    }, "de_IDPCommunicationErrorExceptionRes"),
    R98 = k2(async (A, Q) => {
      let B = A.body,
        G = c98(B.Error, Q),
        Z = new ALQ({
          $metadata: Gb(A),
          ...G
        });
      return (0, L7.decorateServiceException)(Z, B)
    }, "de_IDPRejectedClaimExceptionRes"),
    T98 = k2(async (A, Q) => {
      let B = A.body,
        G = p98(B.Error, Q),
        Z = new QLQ({
          $metadata: Gb(A),
          ...G
        });
      return (0, L7.decorateServiceException)(Z, B)
    }, "de_InvalidIdentityTokenExceptionRes"),
    P98 = k2(async (A, Q) => {
      let B = A.body,
        G = l98(B.Error, Q),
        Z = new oNQ({
          $metadata: Gb(A),
          ...G
        });
      return (0, L7.decorateServiceException)(Z, B)
    }, "de_MalformedPolicyDocumentExceptionRes"),
    j98 = k2(async (A, Q) => {
      let B = A.body,
        G = i98(B.Error, Q),
        Z = new tNQ({
          $metadata: Gb(A),
          ...G
        });
      return (0, L7.decorateServiceException)(Z, B)
    }, "de_PackedPolicyTooLargeExceptionRes"),
    S98 = k2(async (A, Q) => {
      let B = A.body,
        G = n98(B.Error, Q),
        Z = new eNQ({
          $metadata: Gb(A),
          ...G
        });
      return (0, L7.decorateServiceException)(Z, B)
    }, "de_RegionDisabledExceptionRes"),
    _98 = k2((A, Q) => {
      let B = {};
      if (A[C6A] != null) B[C6A] = A[C6A];
      if (A[E6A] != null) B[E6A] = A[E6A];
      if (A[D6A] != null) {
        let G = YLQ(A[D6A], Q);
        if (A[D6A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[K6A] != null) B[K6A] = A[K6A];
      if (A[F6A] != null) B[F6A] = A[F6A];
      if (A[OR1] != null) {
        let G = h98(A[OR1], Q);
        if (A[OR1]?.length === 0) B.Tags = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `Tags.${Z}`;
          B[Y] = I
        })
      }
      if (A[TR1] != null) {
        let G = f98(A[TR1], Q);
        if (A[TR1]?.length === 0) B.TransitiveTagKeys = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `TransitiveTagKeys.${Z}`;
          B[Y] = I
        })
      }
      if (A[CR1] != null) B[CR1] = A[CR1];
      if (A[LR1] != null) B[LR1] = A[LR1];
      if (A[RR1] != null) B[RR1] = A[RR1];
      if (A[Qb] != null) B[Qb] = A[Qb];
      if (A[UR1] != null) {
        let G = v98(A[UR1], Q);
        if (A[UR1]?.length === 0) B.ProvidedContexts = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `ProvidedContexts.${Z}`;
          B[Y] = I
        })
      }
      return B
    }, "se_AssumeRoleRequest"),
    k98 = k2((A, Q) => {
      let B = {};
      if (A[C6A] != null) B[C6A] = A[C6A];
      if (A[E6A] != null) B[E6A] = A[E6A];
      if (A[jR1] != null) B[jR1] = A[jR1];
      if (A[$R1] != null) B[$R1] = A[$R1];
      if (A[D6A] != null) {
        let G = YLQ(A[D6A], Q);
        if (A[D6A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[K6A] != null) B[K6A] = A[K6A];
      if (A[F6A] != null) B[F6A] = A[F6A];
      return B
    }, "se_AssumeRoleWithWebIdentityRequest"),
    YLQ = k2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = y98(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_policyDescriptorListType"),
    y98 = k2((A, Q) => {
      let B = {};
      if (A[SR1] != null) B[SR1] = A[SR1];
      return B
    }, "se_PolicyDescriptorType"),
    x98 = k2((A, Q) => {
      let B = {};
      if (A[zR1] != null) B[zR1] = A[zR1];
      if (A[DR1] != null) B[DR1] = A[DR1];
      return B
    }, "se_ProvidedContext"),
    v98 = k2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = x98(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_ProvidedContextsListType"),
    b98 = k2((A, Q) => {
      let B = {};
      if (A[ER1] != null) B[ER1] = A[ER1];
      if (A[PR1] != null) B[PR1] = A[PR1];
      return B
    }, "se_Tag"),
    f98 = k2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        B[`member.${G}`] = Z, G++
      }
      return B
    }, "se_tagKeyListType"),
    h98 = k2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = b98(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_tagListType"),
    JLQ = k2((A, Q) => {
      let B = {};
      if (A[VR1] != null) B[VR1] = (0, L7.expectString)(A[VR1]);
      if (A[FR1] != null) B[FR1] = (0, L7.expectString)(A[FR1]);
      return B
    }, "de_AssumedRoleUser"),
    g98 = k2((A, Q) => {
      let B = {};
      if (A[V6A] != null) B[V6A] = WLQ(A[V6A], Q);
      if (A[X6A] != null) B[X6A] = JLQ(A[X6A], Q);
      if (A[H6A] != null) B[H6A] = (0, L7.strictParseInt32)(A[H6A]);
      if (A[Qb] != null) B[Qb] = (0, L7.expectString)(A[Qb]);
      return B
    }, "de_AssumeRoleResponse"),
    u98 = k2((A, Q) => {
      let B = {};
      if (A[V6A] != null) B[V6A] = WLQ(A[V6A], Q);
      if (A[NR1] != null) B[NR1] = (0, L7.expectString)(A[NR1]);
      if (A[X6A] != null) B[X6A] = JLQ(A[X6A], Q);
      if (A[H6A] != null) B[H6A] = (0, L7.strictParseInt32)(A[H6A]);
      if (A[wR1] != null) B[wR1] = (0, L7.expectString)(A[wR1]);
      if (A[KR1] != null) B[KR1] = (0, L7.expectString)(A[KR1]);
      if (A[Qb] != null) B[Qb] = (0, L7.expectString)(A[Qb]);
      return B
    }, "de_AssumeRoleWithWebIdentityResponse"),
    WLQ = k2((A, Q) => {
      let B = {};
      if (A[XR1] != null) B[XR1] = (0, L7.expectString)(A[XR1]);
      if (A[qR1] != null) B[qR1] = (0, L7.expectString)(A[qR1]);
      if (A[MR1] != null) B[MR1] = (0, L7.expectString)(A[MR1]);
      if (A[HR1] != null) B[HR1] = (0, L7.expectNonNull)((0, L7.parseRfc3339DateTimeWithOffset)(A[HR1]));
      return B
    }, "de_Credentials"),
    m98 = k2((A, Q) => {
      let B = {};
      if (A[UW] != null) B[UW] = (0, L7.expectString)(A[UW]);
      return B
    }, "de_ExpiredTokenException"),
    d98 = k2((A, Q) => {
      let B = {};
      if (A[UW] != null) B[UW] = (0, L7.expectString)(A[UW]);
      return B
    }, "de_IDPCommunicationErrorException"),
    c98 = k2((A, Q) => {
      let B = {};
      if (A[UW] != null) B[UW] = (0, L7.expectString)(A[UW]);
      return B
    }, "de_IDPRejectedClaimException"),
    p98 = k2((A, Q) => {
      let B = {};
      if (A[UW] != null) B[UW] = (0, L7.expectString)(A[UW]);
      return B
    }, "de_InvalidIdentityTokenException"),
    l98 = k2((A, Q) => {
      let B = {};
      if (A[UW] != null) B[UW] = (0, L7.expectString)(A[UW]);
      return B
    }, "de_MalformedPolicyDocumentException"),
    i98 = k2((A, Q) => {
      let B = {};
      if (A[UW] != null) B[UW] = (0, L7.expectString)(A[UW]);
      return B
    }, "de_PackedPolicyTooLargeException"),
    n98 = k2((A, Q) => {
      let B = {};
      if (A[UW] != null) B[UW] = (0, L7.expectString)(A[UW]);
      return B
    }, "de_RegionDisabledException"),
    Gb = k2((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    a98 = (0, L7.withBaseException)(Bb),
    XLQ = k2(async (A, Q, B, G, Z) => {
      let {
        hostname: I,
        protocol: Y = "https",
        port: J,
        path: W
      } = await A.endpoint(), X = {
        protocol: Y,
        hostname: I,
        port: J,
        method: "POST",
        path: W.endsWith("/") ? W.slice(0, -1) + B : W + B,
        headers: Q
      };
      if (G !== void 0) X.hostname = G;
      if (Z !== void 0) X.body = Z;
      return new $98.HttpRequest(X)
    }, "buildHttpRpcRequest"),
    VLQ = {
      "content-type": "application/x-www-form-urlencoded"
    },
    FLQ = "2011-06-15",
    KLQ = "Action",
    XR1 = "AccessKeyId",
    s98 = "AssumeRole",
    VR1 = "AssumedRoleId",
    X6A = "AssumedRoleUser",
    r98 = "AssumeRoleWithWebIdentity",
    FR1 = "Arn",
    KR1 = "Audience",
    V6A = "Credentials",
    DR1 = "ContextAssertion",
    F6A = "DurationSeconds",
    HR1 = "Expiration",
    CR1 = "ExternalId",
    ER1 = "Key",
    K6A = "Policy",
    D6A = "PolicyArns",
    zR1 = "ProviderArn",
    UR1 = "ProvidedContexts",
    $R1 = "ProviderId",
    H6A = "PackedPolicySize",
    wR1 = "Provider",
    C6A = "RoleArn",
    E6A = "RoleSessionName",
    qR1 = "SecretAccessKey",
    NR1 = "SubjectFromWebIdentityToken",
    Qb = "SourceIdentity",
    LR1 = "SerialNumber",
    MR1 = "SessionToken",
    OR1 = "Tags",
    RR1 = "TokenCode",
    TR1 = "TransitiveTagKeys",
    DLQ = "Version",
    PR1 = "Value",
    jR1 = "WebIdentityToken",
    SR1 = "arn",
    UW = "message",
    HLQ = k2((A) => Object.entries(A).map(([Q, B]) => (0, L7.extendedEncodeURIComponent)(Q) + "=" + (0, L7.extendedEncodeURIComponent)(B)).join("&"), "buildFormUrlencodedString"),
    o98 = k2((A, Q) => {
      if (Q.Error?.Code !== void 0) return Q.Error.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadQueryErrorCode"),
    bR1 = class extends E98.Command.classBuilder().ep(z98.commonParams).m(function(A, Q, B, G) {
      return [(0, C98.getSerdePlugin)(B, this.serialize, this.deserialize), (0, H98.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(void 0, sNQ).ser(w98).de(N98).build() {
      static {
        k2(this, "AssumeRoleCommand")
      }
    },
    t98 = q5(),
    e98 = GZ(),
    A48 = S3(),
    Q48 = GCA(),
    fR1 = class extends A48.Command.classBuilder().ep(Q48.commonParams).m(function(A, Q, B, G) {
      return [(0, e98.getSerdePlugin)(B, this.serialize, this.deserialize), (0, t98.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(BLQ, GLQ).ser(q98).de(L98).build() {
      static {
        k2(this, "AssumeRoleWithWebIdentityCommand")
      }
    },
    B48 = BCA(),
    G48 = {
      AssumeRoleCommand: bR1,
      AssumeRoleWithWebIdentityCommand: fR1
    },
    CLQ = class extends B48.STSClient {
      static {
        k2(this, "STS")
      }
    };
  (0, D98.createAggregatedClient)(G48, CLQ);
  var Z48 = GCA(),
    kR1 = LL(),
    nNQ = "us-east-1",
    ELQ = k2((A) => {
      if (typeof A?.Arn === "string") {
        let Q = A.Arn.split(":");
        if (Q.length > 4 && Q[4] !== "") return Q[4]
      }
      return
    }, "getAccountIdFromAssumedRoleUser"),
    zLQ = k2(async (A, Q, B) => {
      let G = typeof A === "function" ? await A() : A,
        Z = typeof Q === "function" ? await Q() : Q;
      return B?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${G} (provider)`, `${Z} (parent client)`, `${nNQ} (STS default)`), G ?? Z ?? nNQ
    }, "resolveRegion"),
    I48 = k2((A, Q) => {
      let B, G;
      return async (Z, I) => {
        if (G = Z, !B) {
          let {
            logger: V = A?.parentClientConfig?.logger,
            region: F,
            requestHandler: K = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: D
          } = A, H = await zLQ(F, A?.parentClientConfig?.region, D), C = !ULQ(K);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            credentialDefaultProvider: k2(() => async () => G, "credentialDefaultProvider"),
            region: H,
            requestHandler: C ? K : void 0,
            logger: V
          })
        }
        let {
          Credentials: Y,
          AssumedRoleUser: J
        } = await B.send(new bR1(I));
        if (!Y || !Y.AccessKeyId || !Y.SecretAccessKey) throw Error(`Invalid response from STS.assumeRole call with role ${I.RoleArn}`);
        let W = ELQ(J),
          X = {
            accessKeyId: Y.AccessKeyId,
            secretAccessKey: Y.SecretAccessKey,
            sessionToken: Y.SessionToken,
            expiration: Y.Expiration,
            ...Y.CredentialScope && {
              credentialScope: Y.CredentialScope
            },
            ...W && {
              accountId: W
            }
          };
        return (0, kR1.setCredentialFeature)(X, "CREDENTIALS_STS_ASSUME_ROLE", "i"), X
      }
    }, "getDefaultRoleAssumer"),
    Y48 = k2((A, Q) => {
      let B;
      return async (G) => {
        if (!B) {
          let {
            logger: W = A?.parentClientConfig?.logger,
            region: X,
            requestHandler: V = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: F
          } = A, K = await zLQ(X, A?.parentClientConfig?.region, F), D = !ULQ(V);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            region: K,
            requestHandler: D ? V : void 0,
            logger: W
          })
        }
        let {
          Credentials: Z,
          AssumedRoleUser: I
        } = await B.send(new fR1(G));
        if (!Z || !Z.AccessKeyId || !Z.SecretAccessKey) throw Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${G.RoleArn}`);
        let Y = ELQ(I),
          J = {
            accessKeyId: Z.AccessKeyId,
            secretAccessKey: Z.SecretAccessKey,
            sessionToken: Z.SessionToken,
            expiration: Z.Expiration,
            ...Z.CredentialScope && {
              credentialScope: Z.CredentialScope
            },
            ...Y && {
              accountId: Y
            }
          };
        if (Y)(0, kR1.setCredentialFeature)(J, "RESOLVED_ACCOUNT_ID", "T");
        return (0, kR1.setCredentialFeature)(J, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"), J
      }
    }, "getDefaultRoleAssumerWithWebIdentity"),
    ULQ = k2((A) => {
      return A?.metadata?.handlerProtocol === "h2"
    }, "isH2"),
    $LQ = BCA(),
    wLQ = k2((A, Q) => {
      if (!Q) return A;
      else return class extends A {
        static {
          k2(this, "CustomizableSTSClient")
        }
        constructor(G) {
          super(G);
          for (let Z of Q) this.middlewareStack.use(Z)
        }
      }
    }, "getCustomizableStsClientCtor"),
    qLQ = k2((A = {}, Q) => I48(A, wLQ($LQ.STSClient, Q)), "getDefaultRoleAssumer"),
    NLQ = k2((A = {}, Q) => Y48(A, wLQ($LQ.STSClient, Q)), "getDefaultRoleAssumerWithWebIdentity"),
    J48 = k2((A) => (Q) => A({
      roleAssumer: qLQ(Q),
      roleAssumerWithWebIdentity: NLQ(Q),
      ...Q
    }), "decorateDefaultCredentialProvider")
})
// @from(Start 3496340, End 3499582)
NmA = z((YL7, OLQ) => {
  var {
    defineProperty: qmA,
    getOwnPropertyDescriptor: W48,
    getOwnPropertyNames: X48
  } = Object, V48 = Object.prototype.hasOwnProperty, uR1 = (A, Q) => qmA(A, "name", {
    value: Q,
    configurable: !0
  }), F48 = (A, Q) => {
    for (var B in Q) qmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, K48 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of X48(Q))
        if (!V48.call(A, Z) && Z !== B) qmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = W48(Q, Z)) || G.enumerable
        })
    }
    return A
  }, D48 = (A) => K48(qmA({}, "__esModule", {
    value: !0
  }), A), MLQ = {};
  F48(MLQ, {
    fromProcess: () => $48
  });
  OLQ.exports = D48(MLQ);
  var LLQ = SG(),
    gR1 = j2(),
    H48 = UA("child_process"),
    C48 = UA("util"),
    E48 = LL(),
    z48 = uR1((A, Q, B) => {
      if (Q.Version !== 1) throw Error(`Profile ${A} credential_process did not return Version 1.`);
      if (Q.AccessKeyId === void 0 || Q.SecretAccessKey === void 0) throw Error(`Profile ${A} credential_process returned invalid credentials.`);
      if (Q.Expiration) {
        let I = new Date;
        if (new Date(Q.Expiration) < I) throw Error(`Profile ${A} credential_process returned expired credentials.`)
      }
      let G = Q.AccountId;
      if (!G && B?.[A]?.aws_account_id) G = B[A].aws_account_id;
      let Z = {
        accessKeyId: Q.AccessKeyId,
        secretAccessKey: Q.SecretAccessKey,
        ...Q.SessionToken && {
          sessionToken: Q.SessionToken
        },
        ...Q.Expiration && {
          expiration: new Date(Q.Expiration)
        },
        ...Q.CredentialScope && {
          credentialScope: Q.CredentialScope
        },
        ...G && {
          accountId: G
        }
      };
      return (0, E48.setCredentialFeature)(Z, "CREDENTIALS_PROCESS", "w"), Z
    }, "getValidatedProcessCredentials"),
    U48 = uR1(async (A, Q, B) => {
      let G = Q[A];
      if (Q[A]) {
        let Z = G.credential_process;
        if (Z !== void 0) {
          let I = (0, C48.promisify)(H48.exec);
          try {
            let {
              stdout: Y
            } = await I(Z), J;
            try {
              J = JSON.parse(Y.trim())
            } catch {
              throw Error(`Profile ${A} credential_process returned invalid JSON.`)
            }
            return z48(A, J, Q)
          } catch (Y) {
            throw new gR1.CredentialsProviderError(Y.message, {
              logger: B
            })
          }
        } else throw new gR1.CredentialsProviderError(`Profile ${A} did not contain credential_process.`, {
          logger: B
        })
      } else throw new gR1.CredentialsProviderError(`Profile ${A} could not be found in shared credentials file.`, {
        logger: B
      })
    }, "resolveProcessCredentials"),
    $48 = uR1((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
      let B = await (0, LLQ.parseKnownFiles)(A);
      return U48((0, LLQ.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), B, A.logger)
    }, "fromProcess")
})
// @from(Start 3499588, End 3501276)
dR1 = z((RLQ) => {
  Object.defineProperty(RLQ, "__esModule", {
    value: !0
  });
  RLQ.resolveHttpAuthSchemeConfig = RLQ.defaultSSOHttpAuthSchemeProvider = RLQ.defaultSSOHttpAuthSchemeParametersProvider = void 0;
  var w48 = nz(),
    mR1 = w7(),
    q48 = async (A, Q, B) => {
      return {
        operation: (0, mR1.getSmithyContext)(Q).operation,
        region: await (0, mR1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  RLQ.defaultSSOHttpAuthSchemeParametersProvider = q48;

  function N48(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "awsssoportal",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function LmA(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var L48 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "GetRoleCredentials": {
        Q.push(LmA(A));
        break
      }
      case "ListAccountRoles": {
        Q.push(LmA(A));
        break
      }
      case "ListAccounts": {
        Q.push(LmA(A));
        break
      }
      case "Logout": {
        Q.push(LmA(A));
        break
      }
      default:
        Q.push(N48(A))
    }
    return Q
  };
  RLQ.defaultSSOHttpAuthSchemeProvider = L48;
  var M48 = (A) => {
    let Q = (0, w48.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, mR1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  RLQ.resolveHttpAuthSchemeConfig = M48
})
// @from(Start 3501282, End 3504870)
PLQ = z((WL7, T48) => {
  T48.exports = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.840.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  }
})
// @from(Start 3504876, End 3509573)
lLQ = z((cLQ) => {
  Object.defineProperty(cLQ, "__esModule", {
    value: !0
  });
  cLQ.ruleSet = void 0;
  var gLQ = "required",
    OL = "fn",
    RL = "argv",
    $6A = "ref",
    jLQ = !0,
    SLQ = "isSet",
    ZCA = "booleanEquals",
    z6A = "error",
    U6A = "endpoint",
    Zb = "tree",
    cR1 = "PartitionResult",
    pR1 = "getAttr",
    _LQ = {
      [gLQ]: !1,
      type: "String"
    },
    kLQ = {
      [gLQ]: !0,
      default: !1,
      type: "Boolean"
    },
    yLQ = {
      [$6A]: "Endpoint"
    },
    uLQ = {
      [OL]: ZCA,
      [RL]: [{
        [$6A]: "UseFIPS"
      }, !0]
    },
    mLQ = {
      [OL]: ZCA,
      [RL]: [{
        [$6A]: "UseDualStack"
      }, !0]
    },
    ML = {},
    xLQ = {
      [OL]: pR1,
      [RL]: [{
        [$6A]: cR1
      }, "supportsFIPS"]
    },
    dLQ = {
      [$6A]: cR1
    },
    vLQ = {
      [OL]: ZCA,
      [RL]: [!0, {
        [OL]: pR1,
        [RL]: [dLQ, "supportsDualStack"]
      }]
    },
    bLQ = [uLQ],
    fLQ = [mLQ],
    hLQ = [{
      [$6A]: "Region"
    }],
    P48 = {
      version: "1.0",
      parameters: {
        Region: _LQ,
        UseDualStack: kLQ,
        UseFIPS: kLQ,
        Endpoint: _LQ
      },
      rules: [{
        conditions: [{
          [OL]: SLQ,
          [RL]: [yLQ]
        }],
        rules: [{
          conditions: bLQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: z6A
        }, {
          conditions: fLQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: z6A
        }, {
          endpoint: {
            url: yLQ,
            properties: ML,
            headers: ML
          },
          type: U6A
        }],
        type: Zb
      }, {
        conditions: [{
          [OL]: SLQ,
          [RL]: hLQ
        }],
        rules: [{
          conditions: [{
            [OL]: "aws.partition",
            [RL]: hLQ,
            assign: cR1
          }],
          rules: [{
            conditions: [uLQ, mLQ],
            rules: [{
              conditions: [{
                [OL]: ZCA,
                [RL]: [jLQ, xLQ]
              }, vLQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: ML,
                  headers: ML
                },
                type: U6A
              }],
              type: Zb
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: z6A
            }],
            type: Zb
          }, {
            conditions: bLQ,
            rules: [{
              conditions: [{
                [OL]: ZCA,
                [RL]: [xLQ, jLQ]
              }],
              rules: [{
                conditions: [{
                  [OL]: "stringEquals",
                  [RL]: [{
                    [OL]: pR1,
                    [RL]: [dLQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://portal.sso.{Region}.amazonaws.com",
                  properties: ML,
                  headers: ML
                },
                type: U6A
              }, {
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: ML,
                  headers: ML
                },
                type: U6A
              }],
              type: Zb
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: z6A
            }],
            type: Zb
          }, {
            conditions: fLQ,
            rules: [{
              conditions: [vLQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: ML,
                  headers: ML
                },
                type: U6A
              }],
              type: Zb
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: z6A
            }],
            type: Zb
          }, {
            endpoint: {
              url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
              properties: ML,
              headers: ML
            },
            type: U6A
          }],
          type: Zb
        }],
        type: Zb
      }, {
        error: "Invalid Configuration: Missing Region",
        type: z6A
      }]
    };
  cLQ.ruleSet = P48
})
// @from(Start 3509579, End 3510143)
aLQ = z((iLQ) => {
  Object.defineProperty(iLQ, "__esModule", {
    value: !0
  });
  iLQ.defaultEndpointResolver = void 0;
  var j48 = sHA(),
    lR1 = FI(),
    S48 = lLQ(),
    _48 = new lR1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    k48 = (A, Q = {}) => {
      return _48.get(A, () => (0, lR1.resolveEndpoint)(S48.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  iLQ.defaultEndpointResolver = k48;
  lR1.customEndpointFunctions.aws = j48.awsEndpointFunctions
})
// @from(Start 3510149, End 3511558)
eLQ = z((oLQ) => {
  Object.defineProperty(oLQ, "__esModule", {
    value: !0
  });
  oLQ.getRuntimeConfig = void 0;
  var y48 = nz(),
    x48 = iB(),
    v48 = S3(),
    b48 = NJ(),
    sLQ = Jo(),
    rLQ = O2(),
    f48 = dR1(),
    h48 = aLQ(),
    g48 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? sLQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? sLQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? h48.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? f48.defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new y48.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new x48.NoAuthSigner
        }],
        logger: A?.logger ?? new v48.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO",
        urlParser: A?.urlParser ?? b48.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? rLQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? rLQ.toUtf8
      }
    };
  oLQ.getRuntimeConfig = g48
})
// @from(Start 3511564, End 3513863)
YMQ = z((ZMQ) => {
  Object.defineProperty(ZMQ, "__esModule", {
    value: !0
  });
  ZMQ.getRuntimeConfig = void 0;
  var u48 = sr(),
    m48 = u48.__importDefault(PLQ()),
    AMQ = nz(),
    QMQ = CmA(),
    MmA = f8(),
    d48 = RX(),
    BMQ = D6(),
    Fo = uI(),
    GMQ = IZ(),
    c48 = TX(),
    p48 = KW(),
    l48 = eLQ(),
    i48 = S3(),
    n48 = PX(),
    a48 = S3(),
    s48 = (A) => {
      (0, a48.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, n48.resolveDefaultsModeConfig)(A),
        B = () => Q().then(i48.loadConfigsForDefaultMode),
        G = (0, l48.getRuntimeConfig)(A);
      (0, AMQ.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Fo.loadConfig)(AMQ.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? c48.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, QMQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: m48.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, Fo.loadConfig)(BMQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Fo.loadConfig)(MmA.NODE_REGION_CONFIG_OPTIONS, {
          ...MmA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: GMQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Fo.loadConfig)({
          ...BMQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || p48.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? d48.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? GMQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Fo.loadConfig)(MmA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Fo.loadConfig)(MmA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Fo.loadConfig)(QMQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  ZMQ.getRuntimeConfig = s48
})
// @from(Start 3513869, End 3530417)
xMQ = z((DL7, yMQ) => {
  var {
    defineProperty: OmA,
    getOwnPropertyDescriptor: r48,
    getOwnPropertyNames: o48
  } = Object, t48 = Object.prototype.hasOwnProperty, M5 = (A, Q) => OmA(A, "name", {
    value: Q,
    configurable: !0
  }), e48 = (A, Q) => {
    for (var B in Q) OmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, A88 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of o48(Q))
        if (!t48.call(A, Z) && Z !== B) OmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = r48(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Q88 = (A) => A88(OmA({}, "__esModule", {
    value: !0
  }), A), DMQ = {};
  e48(DMQ, {
    GetRoleCredentialsCommand: () => SMQ,
    GetRoleCredentialsRequestFilterSensitiveLog: () => UMQ,
    GetRoleCredentialsResponseFilterSensitiveLog: () => wMQ,
    InvalidRequestException: () => HMQ,
    ListAccountRolesCommand: () => iR1,
    ListAccountRolesRequestFilterSensitiveLog: () => qMQ,
    ListAccountsCommand: () => nR1,
    ListAccountsRequestFilterSensitiveLog: () => NMQ,
    LogoutCommand: () => _MQ,
    LogoutRequestFilterSensitiveLog: () => LMQ,
    ResourceNotFoundException: () => CMQ,
    RoleCredentialsFilterSensitiveLog: () => $MQ,
    SSO: () => kMQ,
    SSOClient: () => TmA,
    SSOServiceException: () => w6A,
    TooManyRequestsException: () => EMQ,
    UnauthorizedException: () => zMQ,
    __Client: () => F2.Client,
    paginateListAccountRoles: () => T88,
    paginateListAccounts: () => P88
  });
  yMQ.exports = Q88(DMQ);
  var JMQ = luA(),
    B88 = nuA(),
    G88 = ruA(),
    WMQ = QCA(),
    Z88 = f8(),
    Ib = iB(),
    I88 = LX(),
    YCA = q5(),
    XMQ = D6(),
    VMQ = dR1(),
    Y88 = M5((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal"
      })
    }, "resolveClientEndpointParameters"),
    RmA = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    J88 = YMQ(),
    FMQ = UmA(),
    KMQ = Lw(),
    F2 = S3(),
    W88 = M5((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    X88 = M5((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    V88 = M5((A, Q) => {
      let B = Object.assign((0, FMQ.getAwsRegionExtensionConfiguration)(A), (0, F2.getDefaultExtensionConfiguration)(A), (0, KMQ.getHttpHandlerExtensionConfiguration)(A), W88(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, FMQ.resolveAwsRegionExtensionConfiguration)(B), (0, F2.resolveDefaultRuntimeConfig)(B), (0, KMQ.resolveHttpHandlerRuntimeConfig)(B), X88(B))
    }, "resolveRuntimeExtensions"),
    TmA = class extends F2.Client {
      static {
        M5(this, "SSOClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, J88.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = Y88(Q),
          G = (0, WMQ.resolveUserAgentConfig)(B),
          Z = (0, XMQ.resolveRetryConfig)(G),
          I = (0, Z88.resolveRegionConfig)(Z),
          Y = (0, JMQ.resolveHostHeaderConfig)(I),
          J = (0, YCA.resolveEndpointConfig)(Y),
          W = (0, VMQ.resolveHttpAuthSchemeConfig)(J),
          X = V88(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, WMQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, XMQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, I88.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, JMQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, B88.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, G88.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, Ib.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: VMQ.defaultSSOHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: M5(async (V) => new Ib.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, Ib.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    PmA = GZ(),
    w6A = class A extends F2.ServiceException {
      static {
        M5(this, "SSOServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    HMQ = class A extends w6A {
      static {
        M5(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    CMQ = class A extends w6A {
      static {
        M5(this, "ResourceNotFoundException")
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    EMQ = class A extends w6A {
      static {
        M5(this, "TooManyRequestsException")
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    zMQ = class A extends w6A {
      static {
        M5(this, "UnauthorizedException")
      }
      name = "UnauthorizedException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    UMQ = M5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: F2.SENSITIVE_STRING
      }
    }), "GetRoleCredentialsRequestFilterSensitiveLog"),
    $MQ = M5((A) => ({
      ...A,
      ...A.secretAccessKey && {
        secretAccessKey: F2.SENSITIVE_STRING
      },
      ...A.sessionToken && {
        sessionToken: F2.SENSITIVE_STRING
      }
    }), "RoleCredentialsFilterSensitiveLog"),
    wMQ = M5((A) => ({
      ...A,
      ...A.roleCredentials && {
        roleCredentials: $MQ(A.roleCredentials)
      }
    }), "GetRoleCredentialsResponseFilterSensitiveLog"),
    qMQ = M5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: F2.SENSITIVE_STRING
      }
    }), "ListAccountRolesRequestFilterSensitiveLog"),
    NMQ = M5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: F2.SENSITIVE_STRING
      }
    }), "ListAccountsRequestFilterSensitiveLog"),
    LMQ = M5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: F2.SENSITIVE_STRING
      }
    }), "LogoutRequestFilterSensitiveLog"),
    ICA = nz(),
    F88 = M5(async (A, Q) => {
      let B = (0, Ib.requestBuilder)(A, Q),
        G = (0, F2.map)({}, F2.isSerializableHeaderValue, {
          [_mA]: A[SmA]
        });
      B.bp("/federation/credentials");
      let Z = (0, F2.map)({
          [O88]: [, (0, F2.expectNonNull)(A[M88], "roleName")],
          [OMQ]: [, (0, F2.expectNonNull)(A[MMQ], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_GetRoleCredentialsCommand"),
    K88 = M5(async (A, Q) => {
      let B = (0, Ib.requestBuilder)(A, Q),
        G = (0, F2.map)({}, F2.isSerializableHeaderValue, {
          [_mA]: A[SmA]
        });
      B.bp("/assignment/roles");
      let Z = (0, F2.map)({
          [jMQ]: [, A[PMQ]],
          [TMQ]: [() => A.maxResults !== void 0, () => A[RMQ].toString()],
          [OMQ]: [, (0, F2.expectNonNull)(A[MMQ], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountRolesCommand"),
    D88 = M5(async (A, Q) => {
      let B = (0, Ib.requestBuilder)(A, Q),
        G = (0, F2.map)({}, F2.isSerializableHeaderValue, {
          [_mA]: A[SmA]
        });
      B.bp("/assignment/accounts");
      let Z = (0, F2.map)({
          [jMQ]: [, A[PMQ]],
          [TMQ]: [() => A.maxResults !== void 0, () => A[RMQ].toString()]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountsCommand"),
    H88 = M5(async (A, Q) => {
      let B = (0, Ib.requestBuilder)(A, Q),
        G = (0, F2.map)({}, F2.isSerializableHeaderValue, {
          [_mA]: A[SmA]
        });
      B.bp("/logout");
      let Z;
      return B.m("POST").h(G).b(Z), B.build()
    }, "se_LogoutCommand"),
    C88 = M5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jmA(A, Q);
      let B = (0, F2.map)({
          $metadata: ud(A)
        }),
        G = (0, F2.expectNonNull)((0, F2.expectObject)(await (0, ICA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, F2.take)(G, {
          roleCredentials: F2._json
        });
      return Object.assign(B, Z), B
    }, "de_GetRoleCredentialsCommand"),
    E88 = M5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jmA(A, Q);
      let B = (0, F2.map)({
          $metadata: ud(A)
        }),
        G = (0, F2.expectNonNull)((0, F2.expectObject)(await (0, ICA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, F2.take)(G, {
          nextToken: F2.expectString,
          roleList: F2._json
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountRolesCommand"),
    z88 = M5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jmA(A, Q);
      let B = (0, F2.map)({
          $metadata: ud(A)
        }),
        G = (0, F2.expectNonNull)((0, F2.expectObject)(await (0, ICA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, F2.take)(G, {
          accountList: F2._json,
          nextToken: F2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountsCommand"),
    U88 = M5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jmA(A, Q);
      let B = (0, F2.map)({
        $metadata: ud(A)
      });
      return await (0, F2.collectBody)(A.body, Q), B
    }, "de_LogoutCommand"),
    jmA = M5(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, ICA.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, ICA.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await w88(B, Q);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await q88(B, Q);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await N88(B, Q);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await L88(B, Q);
        default:
          let Z = B.body;
          return $88({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    $88 = (0, F2.withBaseException)(w6A),
    w88 = M5(async (A, Q) => {
      let B = (0, F2.map)({}),
        G = A.body,
        Z = (0, F2.take)(G, {
          message: F2.expectString
        });
      Object.assign(B, Z);
      let I = new HMQ({
        $metadata: ud(A),
        ...B
      });
      return (0, F2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    q88 = M5(async (A, Q) => {
      let B = (0, F2.map)({}),
        G = A.body,
        Z = (0, F2.take)(G, {
          message: F2.expectString
        });
      Object.assign(B, Z);
      let I = new CMQ({
        $metadata: ud(A),
        ...B
      });
      return (0, F2.decorateServiceException)(I, A.body)
    }, "de_ResourceNotFoundExceptionRes"),
    N88 = M5(async (A, Q) => {
      let B = (0, F2.map)({}),
        G = A.body,
        Z = (0, F2.take)(G, {
          message: F2.expectString
        });
      Object.assign(B, Z);
      let I = new EMQ({
        $metadata: ud(A),
        ...B
      });
      return (0, F2.decorateServiceException)(I, A.body)
    }, "de_TooManyRequestsExceptionRes"),
    L88 = M5(async (A, Q) => {
      let B = (0, F2.map)({}),
        G = A.body,
        Z = (0, F2.take)(G, {
          message: F2.expectString
        });
      Object.assign(B, Z);
      let I = new zMQ({
        $metadata: ud(A),
        ...B
      });
      return (0, F2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedExceptionRes"),
    ud = M5((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    MMQ = "accountId",
    SmA = "accessToken",
    OMQ = "account_id",
    RMQ = "maxResults",
    TMQ = "max_result",
    PMQ = "nextToken",
    jMQ = "next_token",
    M88 = "roleName",
    O88 = "role_name",
    _mA = "x-amz-sso_bearer_token",
    SMQ = class extends F2.Command.classBuilder().ep(RmA).m(function(A, Q, B, G) {
      return [(0, PmA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, YCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(UMQ, wMQ).ser(F88).de(C88).build() {
      static {
        M5(this, "GetRoleCredentialsCommand")
      }
    },
    iR1 = class extends F2.Command.classBuilder().ep(RmA).m(function(A, Q, B, G) {
      return [(0, PmA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, YCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(qMQ, void 0).ser(K88).de(E88).build() {
      static {
        M5(this, "ListAccountRolesCommand")
      }
    },
    nR1 = class extends F2.Command.classBuilder().ep(RmA).m(function(A, Q, B, G) {
      return [(0, PmA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, YCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(NMQ, void 0).ser(D88).de(z88).build() {
      static {
        M5(this, "ListAccountsCommand")
      }
    },
    _MQ = class extends F2.Command.classBuilder().ep(RmA).m(function(A, Q, B, G) {
      return [(0, PmA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, YCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(LMQ, void 0).ser(H88).de(U88).build() {
      static {
        M5(this, "LogoutCommand")
      }
    },
    R88 = {
      GetRoleCredentialsCommand: SMQ,
      ListAccountRolesCommand: iR1,
      ListAccountsCommand: nR1,
      LogoutCommand: _MQ
    },
    kMQ = class extends TmA {
      static {
        M5(this, "SSO")
      }
    };
  (0, F2.createAggregatedClient)(R88, kMQ);
  var T88 = (0, Ib.createPaginator)(TmA, iR1, "nextToken", "nextToken", "maxResults"),
    P88 = (0, Ib.createPaginator)(TmA, nR1, "nextToken", "nextToken", "maxResults")
})
// @from(Start 3530423, End 3531894)
sR1 = z((vMQ) => {
  Object.defineProperty(vMQ, "__esModule", {
    value: !0
  });
  vMQ.resolveHttpAuthSchemeConfig = vMQ.defaultSSOOIDCHttpAuthSchemeProvider = vMQ.defaultSSOOIDCHttpAuthSchemeParametersProvider = void 0;
  var j88 = nz(),
    aR1 = w7(),
    S88 = async (A, Q, B) => {
      return {
        operation: (0, aR1.getSmithyContext)(Q).operation,
        region: await (0, aR1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  vMQ.defaultSSOOIDCHttpAuthSchemeParametersProvider = S88;

  function _88(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function k88(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var y88 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "CreateToken": {
        Q.push(k88(A));
        break
      }
      default:
        Q.push(_88(A))
    }
    return Q
  };
  vMQ.defaultSSOOIDCHttpAuthSchemeProvider = y88;
  var x88 = (A) => {
    let Q = (0, j88.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, aR1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  vMQ.resolveHttpAuthSchemeConfig = x88
})
// @from(Start 3531900, End 3536567)
eMQ = z((oMQ) => {
  Object.defineProperty(oMQ, "__esModule", {
    value: !0
  });
  oMQ.ruleSet = void 0;
  var nMQ = "required",
    PL = "fn",
    jL = "argv",
    L6A = "ref",
    fMQ = !0,
    hMQ = "isSet",
    JCA = "booleanEquals",
    q6A = "error",
    N6A = "endpoint",
    Yb = "tree",
    rR1 = "PartitionResult",
    oR1 = "getAttr",
    gMQ = {
      [nMQ]: !1,
      type: "String"
    },
    uMQ = {
      [nMQ]: !0,
      default: !1,
      type: "Boolean"
    },
    mMQ = {
      [L6A]: "Endpoint"
    },
    aMQ = {
      [PL]: JCA,
      [jL]: [{
        [L6A]: "UseFIPS"
      }, !0]
    },
    sMQ = {
      [PL]: JCA,
      [jL]: [{
        [L6A]: "UseDualStack"
      }, !0]
    },
    TL = {},
    dMQ = {
      [PL]: oR1,
      [jL]: [{
        [L6A]: rR1
      }, "supportsFIPS"]
    },
    rMQ = {
      [L6A]: rR1
    },
    cMQ = {
      [PL]: JCA,
      [jL]: [!0, {
        [PL]: oR1,
        [jL]: [rMQ, "supportsDualStack"]
      }]
    },
    pMQ = [aMQ],
    lMQ = [sMQ],
    iMQ = [{
      [L6A]: "Region"
    }],
    f88 = {
      version: "1.0",
      parameters: {
        Region: gMQ,
        UseDualStack: uMQ,
        UseFIPS: uMQ,
        Endpoint: gMQ
      },
      rules: [{
        conditions: [{
          [PL]: hMQ,
          [jL]: [mMQ]
        }],
        rules: [{
          conditions: pMQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: q6A
        }, {
          conditions: lMQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: q6A
        }, {
          endpoint: {
            url: mMQ,
            properties: TL,
            headers: TL
          },
          type: N6A
        }],
        type: Yb
      }, {
        conditions: [{
          [PL]: hMQ,
          [jL]: iMQ
        }],
        rules: [{
          conditions: [{
            [PL]: "aws.partition",
            [jL]: iMQ,
            assign: rR1
          }],
          rules: [{
            conditions: [aMQ, sMQ],
            rules: [{
              conditions: [{
                [PL]: JCA,
                [jL]: [fMQ, dMQ]
              }, cMQ],
              rules: [{
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: TL,
                  headers: TL
                },
                type: N6A
              }],
              type: Yb
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: q6A
            }],
            type: Yb
          }, {
            conditions: pMQ,
            rules: [{
              conditions: [{
                [PL]: JCA,
                [jL]: [dMQ, fMQ]
              }],
              rules: [{
                conditions: [{
                  [PL]: "stringEquals",
                  [jL]: [{
                    [PL]: oR1,
                    [jL]: [rMQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://oidc.{Region}.amazonaws.com",
                  properties: TL,
                  headers: TL
                },
                type: N6A
              }, {
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: TL,
                  headers: TL
                },
                type: N6A
              }],
              type: Yb
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: q6A
            }],
            type: Yb
          }, {
            conditions: lMQ,
            rules: [{
              conditions: [cMQ],
              rules: [{
                endpoint: {
                  url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: TL,
                  headers: TL
                },
                type: N6A
              }],
              type: Yb
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: q6A
            }],
            type: Yb
          }, {
            endpoint: {
              url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
              properties: TL,
              headers: TL
            },
            type: N6A
          }],
          type: Yb
        }],
        type: Yb
      }, {
        error: "Invalid Configuration: Missing Region",
        type: q6A
      }]
    };
  oMQ.ruleSet = f88
})
// @from(Start 3536573, End 3537137)
BOQ = z((AOQ) => {
  Object.defineProperty(AOQ, "__esModule", {
    value: !0
  });
  AOQ.defaultEndpointResolver = void 0;
  var h88 = sHA(),
    tR1 = FI(),
    g88 = eMQ(),
    u88 = new tR1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    m88 = (A, Q = {}) => {
      return u88.get(A, () => (0, tR1.resolveEndpoint)(g88.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  AOQ.defaultEndpointResolver = m88;
  tR1.customEndpointFunctions.aws = h88.awsEndpointFunctions
})
// @from(Start 3537143, End 3538561)
JOQ = z((IOQ) => {
  Object.defineProperty(IOQ, "__esModule", {
    value: !0
  });
  IOQ.getRuntimeConfig = void 0;
  var d88 = nz(),
    c88 = iB(),
    p88 = S3(),
    l88 = NJ(),
    GOQ = Jo(),
    ZOQ = O2(),
    i88 = sR1(),
    n88 = BOQ(),
    a88 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? GOQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? GOQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? n88.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? i88.defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new d88.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new c88.NoAuthSigner
        }],
        logger: A?.logger ?? new p88.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO OIDC",
        urlParser: A?.urlParser ?? l88.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? ZOQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? ZOQ.toUtf8
      }
    };
  IOQ.getRuntimeConfig = a88
})
// @from(Start 3538567, End 3540866)
HOQ = z((KOQ) => {
  Object.defineProperty(KOQ, "__esModule", {
    value: !0
  });
  KOQ.getRuntimeConfig = void 0;
  var s88 = sr(),
    r88 = s88.__importDefault(AR1()),
    WOQ = nz(),
    XOQ = CmA(),
    kmA = f8(),
    o88 = RX(),
    VOQ = D6(),
    Ko = uI(),
    FOQ = IZ(),
    t88 = TX(),
    e88 = KW(),
    A68 = JOQ(),
    Q68 = S3(),
    B68 = PX(),
    G68 = S3(),
    Z68 = (A) => {
      (0, G68.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, B68.resolveDefaultsModeConfig)(A),
        B = () => Q().then(Q68.loadConfigsForDefaultMode),
        G = (0, A68.getRuntimeConfig)(A);
      (0, WOQ.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Ko.loadConfig)(WOQ.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? t88.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, XOQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: r88.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, Ko.loadConfig)(VOQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Ko.loadConfig)(kmA.NODE_REGION_CONFIG_OPTIONS, {
          ...kmA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: FOQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Ko.loadConfig)({
          ...VOQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || e88.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? o88.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? FOQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Ko.loadConfig)(kmA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Ko.loadConfig)(kmA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Ko.loadConfig)(XOQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  KOQ.getRuntimeConfig = Z68
})
// @from(Start 3540872, End 3560699)
QT1 = z((OL7, mOQ) => {
  var {
    defineProperty: ymA,
    getOwnPropertyDescriptor: I68,
    getOwnPropertyNames: Y68
  } = Object, J68 = Object.prototype.hasOwnProperty, T6 = (A, Q) => ymA(A, "name", {
    value: Q,
    configurable: !0
  }), W68 = (A, Q) => {
    for (var B in Q) ymA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, X68 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Y68(Q))
        if (!J68.call(A, Z) && Z !== B) ymA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = I68(Q, Z)) || G.enumerable
        })
    }
    return A
  }, V68 = (A) => X68(ymA({}, "__esModule", {
    value: !0
  }), A), NOQ = {};
  W68(NOQ, {
    $Command: () => OOQ.Command,
    AccessDeniedException: () => ROQ,
    AuthorizationPendingException: () => TOQ,
    CreateTokenCommand: () => gOQ,
    CreateTokenRequestFilterSensitiveLog: () => POQ,
    CreateTokenResponseFilterSensitiveLog: () => jOQ,
    ExpiredTokenException: () => SOQ,
    InternalServerException: () => _OQ,
    InvalidClientException: () => kOQ,
    InvalidGrantException: () => yOQ,
    InvalidRequestException: () => xOQ,
    InvalidScopeException: () => vOQ,
    SSOOIDC: () => uOQ,
    SSOOIDCClient: () => MOQ,
    SSOOIDCServiceException: () => Ow,
    SlowDownException: () => bOQ,
    UnauthorizedClientException: () => fOQ,
    UnsupportedGrantTypeException: () => hOQ,
    __Client: () => LOQ.Client
  });
  mOQ.exports = V68(NOQ);
  var COQ = luA(),
    F68 = nuA(),
    K68 = ruA(),
    EOQ = QCA(),
    D68 = f8(),
    eR1 = iB(),
    H68 = LX(),
    C68 = q5(),
    zOQ = D6(),
    LOQ = S3(),
    UOQ = sR1(),
    E68 = T6((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth"
      })
    }, "resolveClientEndpointParameters"),
    z68 = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    U68 = HOQ(),
    $OQ = UmA(),
    wOQ = Lw(),
    qOQ = S3(),
    $68 = T6((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    w68 = T6((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    q68 = T6((A, Q) => {
      let B = Object.assign((0, $OQ.getAwsRegionExtensionConfiguration)(A), (0, qOQ.getDefaultExtensionConfiguration)(A), (0, wOQ.getHttpHandlerExtensionConfiguration)(A), $68(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, $OQ.resolveAwsRegionExtensionConfiguration)(B), (0, qOQ.resolveDefaultRuntimeConfig)(B), (0, wOQ.resolveHttpHandlerRuntimeConfig)(B), w68(B))
    }, "resolveRuntimeExtensions"),
    MOQ = class extends LOQ.Client {
      static {
        T6(this, "SSOOIDCClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, U68.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = E68(Q),
          G = (0, EOQ.resolveUserAgentConfig)(B),
          Z = (0, zOQ.resolveRetryConfig)(G),
          I = (0, D68.resolveRegionConfig)(Z),
          Y = (0, COQ.resolveHostHeaderConfig)(I),
          J = (0, C68.resolveEndpointConfig)(Y),
          W = (0, UOQ.resolveHttpAuthSchemeConfig)(J),
          X = q68(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, EOQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, zOQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, H68.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, COQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, F68.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, K68.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, eR1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: UOQ.defaultSSOOIDCHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: T6(async (V) => new eR1.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, eR1.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    N68 = S3(),
    L68 = q5(),
    M68 = GZ(),
    OOQ = S3(),
    M6A = S3(),
    O68 = S3(),
    Ow = class A extends O68.ServiceException {
      static {
        T6(this, "SSOOIDCServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    ROQ = class A extends Ow {
      static {
        T6(this, "AccessDeniedException")
      }
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    TOQ = class A extends Ow {
      static {
        T6(this, "AuthorizationPendingException")
      }
      name = "AuthorizationPendingException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    POQ = T6((A) => ({
      ...A,
      ...A.clientSecret && {
        clientSecret: M6A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: M6A.SENSITIVE_STRING
      },
      ...A.codeVerifier && {
        codeVerifier: M6A.SENSITIVE_STRING
      }
    }), "CreateTokenRequestFilterSensitiveLog"),
    jOQ = T6((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: M6A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: M6A.SENSITIVE_STRING
      },
      ...A.idToken && {
        idToken: M6A.SENSITIVE_STRING
      }
    }), "CreateTokenResponseFilterSensitiveLog"),
    SOQ = class A extends Ow {
      static {
        T6(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    _OQ = class A extends Ow {
      static {
        T6(this, "InternalServerException")
      }
      name = "InternalServerException";
      $fault = "server";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    kOQ = class A extends Ow {
      static {
        T6(this, "InvalidClientException")
      }
      name = "InvalidClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    yOQ = class A extends Ow {
      static {
        T6(this, "InvalidGrantException")
      }
      name = "InvalidGrantException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    xOQ = class A extends Ow {
      static {
        T6(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    vOQ = class A extends Ow {
      static {
        T6(this, "InvalidScopeException")
      }
      name = "InvalidScopeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    bOQ = class A extends Ow {
      static {
        T6(this, "SlowDownException")
      }
      name = "SlowDownException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    fOQ = class A extends Ow {
      static {
        T6(this, "UnauthorizedClientException")
      }
      name = "UnauthorizedClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    hOQ = class A extends Ow {
      static {
        T6(this, "UnsupportedGrantTypeException")
      }
      name = "UnsupportedGrantTypeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    AT1 = nz(),
    R68 = iB(),
    Z2 = S3(),
    T68 = T6(async (A, Q) => {
      let B = (0, R68.requestBuilder)(A, Q),
        G = {
          "content-type": "application/json"
        };
      B.bp("/token");
      let Z;
      return Z = JSON.stringify((0, Z2.take)(A, {
        clientId: [],
        clientSecret: [],
        code: [],
        codeVerifier: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: T6((I) => (0, Z2._json)(I), "scope")
      })), B.m("POST").h(G).b(Z), B.build()
    }, "se_CreateTokenCommand"),
    P68 = T6(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return j68(A, Q);
      let B = (0, Z2.map)({
          $metadata: SL(A)
        }),
        G = (0, Z2.expectNonNull)((0, Z2.expectObject)(await (0, AT1.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, Z2.take)(G, {
          accessToken: Z2.expectString,
          expiresIn: Z2.expectInt32,
          idToken: Z2.expectString,
          refreshToken: Z2.expectString,
          tokenType: Z2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_CreateTokenCommand"),
    j68 = T6(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, AT1.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, AT1.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
          throw await _68(B, Q);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
          throw await k68(B, Q);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
          throw await y68(B, Q);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
          throw await x68(B, Q);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
          throw await v68(B, Q);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
          throw await b68(B, Q);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
          throw await f68(B, Q);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
          throw await h68(B, Q);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
          throw await g68(B, Q);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
          throw await u68(B, Q);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
          throw await m68(B, Q);
        default:
          let Z = B.body;
          return S68({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    S68 = (0, Z2.withBaseException)(Ow),
    _68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new ROQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_AccessDeniedExceptionRes"),
    k68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new TOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_AuthorizationPendingExceptionRes"),
    y68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new SOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_ExpiredTokenExceptionRes"),
    x68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new _OQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_InternalServerExceptionRes"),
    v68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new kOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_InvalidClientExceptionRes"),
    b68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new yOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_InvalidGrantExceptionRes"),
    f68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new xOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    h68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new vOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_InvalidScopeExceptionRes"),
    g68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new bOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_SlowDownExceptionRes"),
    u68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new fOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedClientExceptionRes"),
    m68 = T6(async (A, Q) => {
      let B = (0, Z2.map)({}),
        G = A.body,
        Z = (0, Z2.take)(G, {
          error: Z2.expectString,
          error_description: Z2.expectString
        });
      Object.assign(B, Z);
      let I = new hOQ({
        $metadata: SL(A),
        ...B
      });
      return (0, Z2.decorateServiceException)(I, A.body)
    }, "de_UnsupportedGrantTypeExceptionRes"),
    SL = T6((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    gOQ = class extends OOQ.Command.classBuilder().ep(z68).m(function(A, Q, B, G) {
      return [(0, M68.getSerdePlugin)(B, this.serialize, this.deserialize), (0, L68.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(POQ, jOQ).ser(T68).de(P68).build() {
      static {
        T6(this, "CreateTokenCommand")
      }
    },
    d68 = {
      CreateTokenCommand: gOQ
    },
    uOQ = class extends MOQ {
      static {
        T6(this, "SSOOIDC")
      }
    };
  (0, N68.createAggregatedClient)(d68, uOQ)
})
// @from(Start 3560705, End 3566874)
sOQ = z((jL7, aOQ) => {
  var {
    create: c68,
    defineProperty: XCA,
    getOwnPropertyDescriptor: p68,
    getOwnPropertyNames: l68,
    getPrototypeOf: i68
  } = Object, n68 = Object.prototype.hasOwnProperty, Jb = (A, Q) => XCA(A, "name", {
    value: Q,
    configurable: !0
  }), a68 = (A, Q) => {
    for (var B in Q) XCA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, pOQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of l68(Q))
        if (!n68.call(A, Z) && Z !== B) XCA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = p68(Q, Z)) || G.enumerable
        })
    }
    return A
  }, lOQ = (A, Q, B) => (B = A != null ? c68(i68(A)) : {}, pOQ(Q || !A || !A.__esModule ? XCA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), s68 = (A) => pOQ(XCA({}, "__esModule", {
    value: !0
  }), A), iOQ = {};
  a68(iOQ, {
    fromEnvSigningName: () => t68,
    fromSso: () => nOQ,
    fromStatic: () => I58,
    nodeProvider: () => Y58
  });
  aOQ.exports = s68(iOQ);
  var r68 = LL(),
    o68 = fO1(),
    Rw = j2(),
    t68 = Jb(({
      logger: A,
      signingName: Q
    } = {}) => async () => {
      if (A?.debug?.("@aws-sdk/token-providers - fromEnvSigningName"), !Q) throw new Rw.TokenProviderError("Please pass 'signingName' to compute environment variable key", {
        logger: A
      });
      let B = (0, o68.getBearerTokenEnvKey)(Q);
      if (!(B in process.env)) throw new Rw.TokenProviderError(`Token not present in '${B}' environment variable`, {
        logger: A
      });
      let G = {
        token: process.env[B]
      };
      return (0, r68.setTokenFeature)(G, "BEARER_SERVICE_ENV_VARS", "3"), G
    }, "fromEnvSigningName"),
    e68 = 300000,
    BT1 = "To refresh this SSO session run 'aws sso login' with the corresponding profile.",
    A58 = Jb(async (A, Q = {}) => {
      let {
        SSOOIDCClient: B
      } = await Promise.resolve().then(() => lOQ(QT1()));
      return new B(Object.assign({}, Q.clientConfig ?? {}, {
        region: A ?? Q.clientConfig?.region,
        logger: Q.clientConfig?.logger ?? Q.parentClientConfig?.logger
      }))
    }, "getSsoOidcClient"),
    Q58 = Jb(async (A, Q, B = {}) => {
      let {
        CreateTokenCommand: G
      } = await Promise.resolve().then(() => lOQ(QT1()));
      return (await A58(Q, B)).send(new G({
        clientId: A.clientId,
        clientSecret: A.clientSecret,
        refreshToken: A.refreshToken,
        grantType: "refresh_token"
      }))
    }, "getNewSsoOidcToken"),
    dOQ = Jb((A) => {
      if (A.expiration && A.expiration.getTime() < Date.now()) throw new Rw.TokenProviderError(`Token is expired. ${BT1}`, !1)
    }, "validateTokenExpiry"),
    Do = Jb((A, Q, B = !1) => {
      if (typeof Q > "u") throw new Rw.TokenProviderError(`Value not present for '${A}' in SSO Token${B?". Cannot refresh":""}. ${BT1}`, !1)
    }, "validateTokenKey"),
    WCA = SG(),
    B58 = UA("fs"),
    {
      writeFile: G58
    } = B58.promises,
    Z58 = Jb((A, Q) => {
      let B = (0, WCA.getSSOTokenFilepath)(A),
        G = JSON.stringify(Q, null, 2);
      return G58(B, G)
    }, "writeSSOTokenToFile"),
    cOQ = new Date(0),
    nOQ = Jb((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/token-providers - fromSso");
      let G = await (0, WCA.parseKnownFiles)(B),
        Z = (0, WCA.getProfileName)({
          profile: B.profile ?? Q?.profile
        }),
        I = G[Z];
      if (!I) throw new Rw.TokenProviderError(`Profile '${Z}' could not be found in shared credentials file.`, !1);
      else if (!I.sso_session) throw new Rw.TokenProviderError(`Profile '${Z}' is missing required property 'sso_session'.`);
      let Y = I.sso_session,
        W = (await (0, WCA.loadSsoSessionData)(B))[Y];
      if (!W) throw new Rw.TokenProviderError(`Sso session '${Y}' could not be found in shared credentials file.`, !1);
      for (let C of ["sso_start_url", "sso_region"])
        if (!W[C]) throw new Rw.TokenProviderError(`Sso session '${Y}' is missing required property '${C}'.`, !1);
      let {
        sso_start_url: X,
        sso_region: V
      } = W, F;
      try {
        F = await (0, WCA.getSSOTokenFromFile)(Y)
      } catch (C) {
        throw new Rw.TokenProviderError(`The SSO session token associated with profile=${Z} was not found or is invalid. ${BT1}`, !1)
      }
      Do("accessToken", F.accessToken), Do("expiresAt", F.expiresAt);
      let {
        accessToken: K,
        expiresAt: D
      } = F, H = {
        token: K,
        expiration: new Date(D)
      };
      if (H.expiration.getTime() - Date.now() > e68) return H;
      if (Date.now() - cOQ.getTime() < 30000) return dOQ(H), H;
      Do("clientId", F.clientId, !0), Do("clientSecret", F.clientSecret, !0), Do("refreshToken", F.refreshToken, !0);
      try {
        cOQ.setTime(Date.now());
        let C = await Q58(F, V, B);
        Do("accessToken", C.accessToken), Do("expiresIn", C.expiresIn);
        let E = new Date(Date.now() + C.expiresIn * 1000);
        try {
          await Z58(Y, {
            ...F,
            accessToken: C.accessToken,
            expiresAt: E.toISOString(),
            refreshToken: C.refreshToken
          })
        } catch (U) {}
        return {
          token: C.accessToken,
          expiration: E
        }
      } catch (C) {
        return dOQ(H), H
      }
    }, "fromSso"),
    I58 = Jb(({
      token: A,
      logger: Q
    }) => async () => {
      if (Q?.debug("@aws-sdk/token-providers - fromStatic"), !A || !A.token) throw new Rw.TokenProviderError("Please pass a valid token to fromStatic", !1);
      return A
    }, "fromStatic"),
    Y58 = Jb((A = {}) => (0, Rw.memoize)((0, Rw.chain)(nOQ(A), async () => {
      throw new Rw.TokenProviderError("Could not load token from any providers", !1)
    }), (Q) => Q.expiration !== void 0 && Q.expiration.getTime() - Date.now() < 300000, (Q) => Q.expiration !== void 0), "nodeProvider")
})
// @from(Start 3566880, End 3574122)
fmA = z((SL7, ZRQ) => {
  var {
    defineProperty: vmA,
    getOwnPropertyDescriptor: J58,
    getOwnPropertyNames: tOQ
  } = Object, W58 = Object.prototype.hasOwnProperty, bmA = (A, Q) => vmA(A, "name", {
    value: Q,
    configurable: !0
  }), X58 = (A, Q) => function() {
    return A && (Q = (0, A[tOQ(A)[0]])(A = 0)), Q
  }, eOQ = (A, Q) => {
    for (var B in Q) vmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, V58 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of tOQ(Q))
        if (!W58.call(A, Z) && Z !== B) vmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = J58(Q, Z)) || G.enumerable
        })
    }
    return A
  }, F58 = (A) => V58(vmA({}, "__esModule", {
    value: !0
  }), A), ARQ = {};
  eOQ(ARQ, {
    GetRoleCredentialsCommand: () => GT1.GetRoleCredentialsCommand,
    SSOClient: () => GT1.SSOClient
  });
  var GT1, K58 = X58({
      "src/loadSso.ts"() {
        GT1 = xMQ()
      }
    }),
    QRQ = {};
  eOQ(QRQ, {
    fromSSO: () => H58,
    isSsoProfile: () => BRQ,
    validateSsoProfile: () => GRQ
  });
  ZRQ.exports = F58(QRQ);
  var BRQ = bmA((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    rOQ = LL(),
    D58 = sOQ(),
    nR = j2(),
    xmA = SG(),
    VCA = !1,
    oOQ = bmA(async ({
      ssoStartUrl: A,
      ssoSession: Q,
      ssoAccountId: B,
      ssoRegion: G,
      ssoRoleName: Z,
      ssoClient: I,
      clientConfig: Y,
      parentClientConfig: J,
      profile: W,
      logger: X
    }) => {
      let V, F = "To refresh this SSO session run aws sso login with the corresponding profile.";
      if (Q) try {
        let v = await (0, D58.fromSso)({
          profile: W
        })();
        V = {
          accessToken: v.token,
          expiresAt: new Date(v.expiration).toISOString()
        }
      } catch (v) {
        throw new nR.CredentialsProviderError(v.message, {
          tryNextLink: VCA,
          logger: X
        })
      } else try {
        V = await (0, xmA.getSSOTokenFromFile)(A)
      } catch (v) {
        throw new nR.CredentialsProviderError("The SSO session associated with this profile is invalid. To refresh this SSO session run aws sso login with the corresponding profile.", {
          tryNextLink: VCA,
          logger: X
        })
      }
      if (new Date(V.expiresAt).getTime() - Date.now() <= 0) throw new nR.CredentialsProviderError("The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile.", {
        tryNextLink: VCA,
        logger: X
      });
      let {
        accessToken: K
      } = V, {
        SSOClient: D,
        GetRoleCredentialsCommand: H
      } = await Promise.resolve().then(() => (K58(), ARQ)), C = I || new D(Object.assign({}, Y ?? {}, {
        logger: Y?.logger ?? J?.logger,
        region: Y?.region ?? G
      })), E;
      try {
        E = await C.send(new H({
          accountId: B,
          roleName: Z,
          accessToken: K
        }))
      } catch (v) {
        throw new nR.CredentialsProviderError(v, {
          tryNextLink: VCA,
          logger: X
        })
      }
      let {
        roleCredentials: {
          accessKeyId: U,
          secretAccessKey: q,
          sessionToken: w,
          expiration: N,
          credentialScope: R,
          accountId: T
        } = {}
      } = E;
      if (!U || !q || !w || !N) throw new nR.CredentialsProviderError("SSO returns an invalid temporary credential.", {
        tryNextLink: VCA,
        logger: X
      });
      let y = {
        accessKeyId: U,
        secretAccessKey: q,
        sessionToken: w,
        expiration: new Date(N),
        ...R && {
          credentialScope: R
        },
        ...T && {
          accountId: T
        }
      };
      if (Q)(0, rOQ.setCredentialFeature)(y, "CREDENTIALS_SSO", "s");
      else(0, rOQ.setCredentialFeature)(y, "CREDENTIALS_SSO_LEGACY", "u");
      return y
    }, "resolveSSOCredentials"),
    GRQ = bmA((A, Q) => {
      let {
        sso_start_url: B,
        sso_account_id: G,
        sso_region: Z,
        sso_role_name: I
      } = A;
      if (!B || !G || !Z || !I) throw new nR.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(A).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, {
        tryNextLink: !1,
        logger: Q
      });
      return A
    }, "validateSsoProfile"),
    H58 = bmA((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
      let {
        ssoStartUrl: B,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoSession: Y
      } = A, {
        ssoClient: J
      } = A, W = (0, xmA.getProfileName)({
        profile: A.profile ?? Q?.profile
      });
      if (!B && !G && !Z && !I && !Y) {
        let V = (await (0, xmA.parseKnownFiles)(A))[W];
        if (!V) throw new nR.CredentialsProviderError(`Profile ${W} was not found.`, {
          logger: A.logger
        });
        if (!BRQ(V)) throw new nR.CredentialsProviderError(`Profile ${W} is not configured with SSO credentials.`, {
          logger: A.logger
        });
        if (V?.sso_session) {
          let U = (await (0, xmA.loadSsoSessionData)(A))[V.sso_session],
            q = ` configurations in profile ${W} and sso-session ${V.sso_session}`;
          if (Z && Z !== U.sso_region) throw new nR.CredentialsProviderError("Conflicting SSO region" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          if (B && B !== U.sso_start_url) throw new nR.CredentialsProviderError("Conflicting SSO start_url" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          V.sso_region = U.sso_region, V.sso_start_url = U.sso_start_url
        }
        let {
          sso_start_url: F,
          sso_account_id: K,
          sso_region: D,
          sso_role_name: H,
          sso_session: C
        } = GRQ(V, A.logger);
        return oOQ({
          ssoStartUrl: F,
          ssoSession: C,
          ssoAccountId: K,
          ssoRegion: D,
          ssoRoleName: H,
          ssoClient: J,
          clientConfig: A.clientConfig,
          parentClientConfig: A.parentClientConfig,
          profile: W
        })
      } else if (!B || !G || !Z || !I) throw new nR.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', {
        tryNextLink: !1,
        logger: A.logger
      });
      else return oOQ({
        ssoStartUrl: B,
        ssoSession: Y,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoClient: J,
        clientConfig: A.clientConfig,
        parentClientConfig: A.parentClientConfig,
        profile: W
      })
    }, "fromSSO")
})
// @from(Start 3574128, End 3576452)
ZT1 = z((uS) => {
  var C58 = uS && uS.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    E58 = uS && uS.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    z58 = uS && uS.__importStar || function() {
      var A = function(Q) {
        return A = Object.getOwnPropertyNames || function(B) {
          var G = [];
          for (var Z in B)
            if (Object.prototype.hasOwnProperty.call(B, Z)) G[G.length] = Z;
          return G
        }, A(Q)
      };
      return function(Q) {
        if (Q && Q.__esModule) return Q;
        var B = {};
        if (Q != null) {
          for (var G = A(Q), Z = 0; Z < G.length; Z++)
            if (G[Z] !== "default") C58(B, Q, G[Z])
        }
        return E58(B, Q), B
      }
    }();
  Object.defineProperty(uS, "__esModule", {
    value: !0
  });
  uS.fromWebToken = void 0;
  var U58 = (A) => async (Q) => {
    A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    let {
      roleArn: B,
      roleSessionName: G,
      webIdentityToken: Z,
      providerId: I,
      policyArns: Y,
      policy: J,
      durationSeconds: W
    } = A, {
      roleAssumerWithWebIdentity: X
    } = A;
    if (!X) {
      let {
        getDefaultRoleAssumerWithWebIdentity: V
      } = await Promise.resolve().then(() => z58(wmA()));
      X = V({
        ...A.clientConfig,
        credentialProviderLogger: A.logger,
        parentClientConfig: {
          ...Q?.callerClientConfig,
          ...A.parentClientConfig
        }
      }, A.clientPlugins)
    }
    return X({
      RoleArn: B,
      RoleSessionName: G ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: Z,
      ProviderId: I,
      PolicyArns: Y,
      Policy: J,
      DurationSeconds: W
    })
  };
  uS.fromWebToken = U58
})
// @from(Start 3576458, End 3577533)
WRQ = z((YRQ) => {
  Object.defineProperty(YRQ, "__esModule", {
    value: !0
  });
  YRQ.fromTokenFile = void 0;
  var $58 = LL(),
    w58 = j2(),
    q58 = UA("fs"),
    N58 = ZT1(),
    IRQ = "AWS_WEB_IDENTITY_TOKEN_FILE",
    L58 = "AWS_ROLE_ARN",
    M58 = "AWS_ROLE_SESSION_NAME",
    O58 = (A = {}) => async () => {
      A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
      let Q = A?.webIdentityTokenFile ?? process.env[IRQ],
        B = A?.roleArn ?? process.env[L58],
        G = A?.roleSessionName ?? process.env[M58];
      if (!Q || !B) throw new w58.CredentialsProviderError("Web identity configuration not specified", {
        logger: A.logger
      });
      let Z = await (0, N58.fromWebToken)({
        ...A,
        webIdentityToken: (0, q58.readFileSync)(Q, {
          encoding: "ascii"
        }),
        roleArn: B,
        roleSessionName: G
      })();
      if (Q === process.env[IRQ])(0, $58.setCredentialFeature)(Z, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
      return Z
    };
  YRQ.fromTokenFile = O58
})
// @from(Start 3577539, End 3578235)
FCA = z((yL7, hmA) => {
  var {
    defineProperty: XRQ,
    getOwnPropertyDescriptor: R58,
    getOwnPropertyNames: T58
  } = Object, P58 = Object.prototype.hasOwnProperty, IT1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of T58(Q))
        if (!P58.call(A, Z) && Z !== B) XRQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = R58(Q, Z)) || G.enumerable
        })
    }
    return A
  }, VRQ = (A, Q, B) => (IT1(A, Q, "default"), B && IT1(B, Q, "default")), j58 = (A) => IT1(XRQ({}, "__esModule", {
    value: !0
  }), A), YT1 = {};
  hmA.exports = j58(YT1);
  VRQ(YT1, WRQ(), hmA.exports);
  VRQ(YT1, ZT1(), hmA.exports)
})
// @from(Start 3578241, End 3587963)
XT1 = z((xL7, zRQ) => {
  var {
    create: S58,
    defineProperty: DCA,
    getOwnPropertyDescriptor: _58,
    getOwnPropertyNames: k58,
    getPrototypeOf: y58
  } = Object, x58 = Object.prototype.hasOwnProperty, kX = (A, Q) => DCA(A, "name", {
    value: Q,
    configurable: !0
  }), v58 = (A, Q) => {
    for (var B in Q) DCA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, HRQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of k58(Q))
        if (!x58.call(A, Z) && Z !== B) DCA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _58(Q, Z)) || G.enumerable
        })
    }
    return A
  }, md = (A, Q, B) => (B = A != null ? S58(y58(A)) : {}, HRQ(Q || !A || !A.__esModule ? DCA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), b58 = (A) => HRQ(DCA({}, "__esModule", {
    value: !0
  }), A), CRQ = {};
  v58(CRQ, {
    fromIni: () => a58
  });
  zRQ.exports = b58(CRQ);
  var WT1 = SG(),
    dd = LL(),
    KCA = j2(),
    f58 = kX((A, Q, B) => {
      let G = {
        EcsContainer: kX(async (Z) => {
          let {
            fromHttp: I
          } = await Promise.resolve().then(() => md(uuA())), {
            fromContainerMetadata: Y
          } = await Promise.resolve().then(() => md(OV()));
          return B?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => (0, KCA.chain)(I(Z ?? {}), Y(Z))().then(JT1)
        }, "EcsContainer"),
        Ec2InstanceMetadata: kX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
          let {
            fromInstanceMetadata: I
          } = await Promise.resolve().then(() => md(OV()));
          return async () => I(Z)().then(JT1)
        }, "Ec2InstanceMetadata"),
        Environment: kX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
          let {
            fromEnv: I
          } = await Promise.resolve().then(() => md(duA()));
          return async () => I(Z)().then(JT1)
        }, "Environment")
      };
      if (A in G) return G[A];
      else throw new KCA.CredentialsProviderError(`Unsupported credential source in profile ${Q}. Got ${A}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, {
        logger: B
      })
    }, "resolveCredentialSource"),
    JT1 = kX((A) => (0, dd.setCredentialFeature)(A, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"), "setNamedProvider"),
    h58 = kX((A, {
      profile: Q = "default",
      logger: B
    } = {}) => {
      return Boolean(A) && typeof A === "object" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof A.external_id) > -1 && ["undefined", "string"].indexOf(typeof A.mfa_serial) > -1 && (g58(A, {
        profile: Q,
        logger: B
      }) || u58(A, {
        profile: Q,
        logger: B
      }))
    }, "isAssumeRoleProfile"),
    g58 = kX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.source_profile === "string" && typeof A.credential_source > "u";
      if (G) B?.debug?.(`    ${Q} isAssumeRoleWithSourceProfile source_profile=${A.source_profile}`);
      return G
    }, "isAssumeRoleWithSourceProfile"),
    u58 = kX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.credential_source === "string" && typeof A.source_profile > "u";
      if (G) B?.debug?.(`    ${Q} isCredentialSourceProfile credential_source=${A.credential_source}`);
      return G
    }, "isCredentialSourceProfile"),
    m58 = kX(async (A, Q, B, G = {}) => {
      B.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
      let Z = Q[A],
        {
          source_profile: I,
          region: Y
        } = Z;
      if (!B.roleAssumer) {
        let {
          getDefaultRoleAssumer: W
        } = await Promise.resolve().then(() => md(wmA()));
        B.roleAssumer = W({
          ...B.clientConfig,
          credentialProviderLogger: B.logger,
          parentClientConfig: {
            ...B?.parentClientConfig,
            region: Y ?? B?.parentClientConfig?.region
          }
        }, B.clientPlugins)
      }
      if (I && I in G) throw new KCA.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${(0,WT1.getProfileName)(B)}. Profiles visited: ` + Object.keys(G).join(", "), {
        logger: B.logger
      });
      B.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${I?`source_profile=[${I}]`:`profile=[${A}]`}`);
      let J = I ? ERQ(I, Q, B, {
        ...G,
        [I]: !0
      }, FRQ(Q[I] ?? {})) : (await f58(Z.credential_source, A, B.logger)(B))();
      if (FRQ(Z)) return J.then((W) => (0, dd.setCredentialFeature)(W, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      else {
        let W = {
            RoleArn: Z.role_arn,
            RoleSessionName: Z.role_session_name || `aws-sdk-js-${Date.now()}`,
            ExternalId: Z.external_id,
            DurationSeconds: parseInt(Z.duration_seconds || "3600", 10)
          },
          {
            mfa_serial: X
          } = Z;
        if (X) {
          if (!B.mfaCodeProvider) throw new KCA.CredentialsProviderError(`Profile ${A} requires multi-factor authentication, but no MFA code callback was provided.`, {
            logger: B.logger,
            tryNextLink: !1
          });
          W.SerialNumber = X, W.TokenCode = await B.mfaCodeProvider(X)
        }
        let V = await J;
        return B.roleAssumer(V, W).then((F) => (0, dd.setCredentialFeature)(F, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"))
      }
    }, "resolveAssumeRoleCredentials"),
    FRQ = kX((A) => {
      return !A.role_arn && !!A.credential_source
    }, "isCredentialSourceWithoutRoleArn"),
    d58 = kX((A) => Boolean(A) && typeof A === "object" && typeof A.credential_process === "string", "isProcessProfile"),
    c58 = kX(async (A, Q) => Promise.resolve().then(() => md(NmA())).then(({
      fromProcess: B
    }) => B({
      ...A,
      profile: Q
    })().then((G) => (0, dd.setCredentialFeature)(G, "CREDENTIALS_PROFILE_PROCESS", "v"))), "resolveProcessCredentials"),
    p58 = kX(async (A, Q, B = {}) => {
      let {
        fromSSO: G
      } = await Promise.resolve().then(() => md(fmA()));
      return G({
        profile: A,
        logger: B.logger,
        parentClientConfig: B.parentClientConfig,
        clientConfig: B.clientConfig
      })().then((Z) => {
        if (Q.sso_session) return (0, dd.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO", "r");
        else return (0, dd.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      })
    }, "resolveSsoCredentials"),
    l58 = kX((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    KRQ = kX((A) => Boolean(A) && typeof A === "object" && typeof A.aws_access_key_id === "string" && typeof A.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof A.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof A.aws_account_id) > -1, "isStaticCredsProfile"),
    DRQ = kX(async (A, Q) => {
      Q?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
      let B = {
        accessKeyId: A.aws_access_key_id,
        secretAccessKey: A.aws_secret_access_key,
        sessionToken: A.aws_session_token,
        ...A.aws_credential_scope && {
          credentialScope: A.aws_credential_scope
        },
        ...A.aws_account_id && {
          accountId: A.aws_account_id
        }
      };
      return (0, dd.setCredentialFeature)(B, "CREDENTIALS_PROFILE", "n")
    }, "resolveStaticCredentials"),
    i58 = kX((A) => Boolean(A) && typeof A === "object" && typeof A.web_identity_token_file === "string" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1, "isWebIdentityProfile"),
    n58 = kX(async (A, Q) => Promise.resolve().then(() => md(FCA())).then(({
      fromTokenFile: B
    }) => B({
      webIdentityTokenFile: A.web_identity_token_file,
      roleArn: A.role_arn,
      roleSessionName: A.role_session_name,
      roleAssumerWithWebIdentity: Q.roleAssumerWithWebIdentity,
      logger: Q.logger,
      parentClientConfig: Q.parentClientConfig
    })().then((G) => (0, dd.setCredentialFeature)(G, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))), "resolveWebIdentityCredentials"),
    ERQ = kX(async (A, Q, B, G = {}, Z = !1) => {
      let I = Q[A];
      if (Object.keys(G).length > 0 && KRQ(I)) return DRQ(I, B);
      if (Z || h58(I, {
          profile: A,
          logger: B.logger
        })) return m58(A, Q, B, G);
      if (KRQ(I)) return DRQ(I, B);
      if (i58(I)) return n58(I, B);
      if (d58(I)) return c58(B, A);
      if (l58(I)) return await p58(A, I, B);
      throw new KCA.CredentialsProviderError(`Could not resolve credentials using profile: [${A}] in configuration/credentials file(s).`, {
        logger: B.logger
      })
    }, "resolveProfileData"),
    a58 = kX((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
      let G = await (0, WT1.parseKnownFiles)(B);
      return ERQ((0, WT1.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), G, B)
    }, "fromIni")
})
// @from(Start 3587969, End 3588178)
wRQ = z((URQ) => {
  Object.defineProperty(URQ, "__esModule", {
    value: !0
  });
  URQ.fromIni = void 0;
  var s58 = XT1(),
    r58 = (A = {}) => (0, s58.fromIni)({
      ...A
    });
  URQ.fromIni = r58
})
// @from(Start 3588184, End 3588609)
LRQ = z((qRQ) => {
  Object.defineProperty(qRQ, "__esModule", {
    value: !0
  });
  qRQ.fromInstanceMetadata = void 0;
  var o58 = LL(),
    t58 = OV(),
    e58 = (A) => {
      return A?.logger?.debug("@smithy/credential-provider-imds", "fromInstanceMetadata"), async () => (0, t58.fromInstanceMetadata)(A)().then((Q) => (0, o58.setCredentialFeature)(Q, "CREDENTIALS_IMDS", "0"))
    };
  qRQ.fromInstanceMetadata = e58
})
// @from(Start 3588615, End 3593577)
_RQ = z((fL7, SRQ) => {
  var {
    create: A38,
    defineProperty: HCA,
    getOwnPropertyDescriptor: Q38,
    getOwnPropertyNames: B38,
    getPrototypeOf: G38
  } = Object, Z38 = Object.prototype.hasOwnProperty, gmA = (A, Q) => HCA(A, "name", {
    value: Q,
    configurable: !0
  }), I38 = (A, Q) => {
    for (var B in Q) HCA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, RRQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of B38(Q))
        if (!Z38.call(A, Z) && Z !== B) HCA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Q38(Q, Z)) || G.enumerable
        })
    }
    return A
  }, O6A = (A, Q, B) => (B = A != null ? A38(G38(A)) : {}, RRQ(Q || !A || !A.__esModule ? HCA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), Y38 = (A) => RRQ(HCA({}, "__esModule", {
    value: !0
  }), A), TRQ = {};
  I38(TRQ, {
    credentialsTreatedAsExpired: () => jRQ,
    credentialsWillNeedRefresh: () => PRQ,
    defaultProvider: () => X38
  });
  SRQ.exports = Y38(TRQ);
  var VT1 = duA(),
    J38 = SG(),
    Ho = j2(),
    MRQ = "AWS_EC2_METADATA_DISABLED",
    W38 = gmA(async (A) => {
      let {
        ENV_CMDS_FULL_URI: Q,
        ENV_CMDS_RELATIVE_URI: B,
        fromContainerMetadata: G,
        fromInstanceMetadata: Z
      } = await Promise.resolve().then(() => O6A(OV()));
      if (process.env[B] || process.env[Q]) {
        A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        let {
          fromHttp: I
        } = await Promise.resolve().then(() => O6A(uuA()));
        return (0, Ho.chain)(I(A), G(A))
      }
      if (process.env[MRQ] && process.env[MRQ] !== "false") return async () => {
        throw new Ho.CredentialsProviderError("EC2 Instance Metadata Service access disabled", {
          logger: A.logger
        })
      };
      return A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), Z(A)
    }, "remoteProvider"),
    ORQ = !1,
    X38 = gmA((A = {}) => (0, Ho.memoize)((0, Ho.chain)(async () => {
      if (A.profile ?? process.env[J38.ENV_PROFILE]) {
        if (process.env[VT1.ENV_KEY] && process.env[VT1.ENV_SECRET]) {
          if (!ORQ)(A.logger?.warn && A.logger?.constructor?.name !== "NoOpLogger" ? A.logger.warn : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), ORQ = !0
        }
        throw new Ho.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
          logger: A.logger,
          tryNextLink: !0
        })
      }
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), (0, VT1.fromEnv)(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
      let {
        ssoStartUrl: Q,
        ssoAccountId: B,
        ssoRegion: G,
        ssoRoleName: Z,
        ssoSession: I
      } = A;
      if (!Q && !B && !G && !Z && !I) throw new Ho.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", {
        logger: A.logger
      });
      let {
        fromSSO: Y
      } = await Promise.resolve().then(() => O6A(fmA()));
      return Y(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
      let {
        fromIni: Q
      } = await Promise.resolve().then(() => O6A(XT1()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
      let {
        fromProcess: Q
      } = await Promise.resolve().then(() => O6A(NmA()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
      let {
        fromTokenFile: Q
      } = await Promise.resolve().then(() => O6A(FCA()));
      return Q(A)()
    }, async () => {
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await W38(A))()
    }, async () => {
      throw new Ho.CredentialsProviderError("Could not load credentials from any providers", {
        tryNextLink: !1,
        logger: A.logger
      })
    }), jRQ, PRQ), "defaultProvider"),
    PRQ = gmA((A) => A?.expiration !== void 0, "credentialsWillNeedRefresh"),
    jRQ = gmA((A) => A?.expiration !== void 0 && A.expiration.getTime() - Date.now() < 300000, "credentialsTreatedAsExpired")
})
// @from(Start 3593583, End 3593828)
FT1 = z((kRQ) => {
  Object.defineProperty(kRQ, "__esModule", {
    value: !0
  });
  kRQ.fromNodeProviderChain = void 0;
  var V38 = _RQ(),
    F38 = (A = {}) => (0, V38.defaultProvider)({
      ...A
    });
  kRQ.fromNodeProviderChain = F38
})
// @from(Start 3593834, End 3594033)
bRQ = z((xRQ) => {
  Object.defineProperty(xRQ, "__esModule", {
    value: !0
  });
  xRQ.fromProcess = void 0;
  var K38 = NmA(),
    D38 = (A) => (0, K38.fromProcess)(A);
  xRQ.fromProcess = D38
})
// @from(Start 3594039, End 3594273)
gRQ = z((fRQ) => {
  Object.defineProperty(fRQ, "__esModule", {
    value: !0
  });
  fRQ.fromSSO = void 0;
  var H38 = fmA(),
    C38 = (A = {}) => {
      return (0, H38.fromSSO)({
        ...A
      })
    };
  fRQ.fromSSO = C38
})
// @from(Start 3594279, End 3594699)
mRQ = z((umA) => {
  Object.defineProperty(umA, "__esModule", {
    value: !0
  });
  umA.STSClient = umA.AssumeRoleCommand = void 0;
  var uRQ = wmA();
  Object.defineProperty(umA, "AssumeRoleCommand", {
    enumerable: !0,
    get: function() {
      return uRQ.AssumeRoleCommand
    }
  });
  Object.defineProperty(umA, "STSClient", {
    enumerable: !0,
    get: function() {
      return uRQ.STSClient
    }
  })
})
// @from(Start 3594705, End 3599482)
pRQ = z((mS) => {
  var z38 = mS && mS.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    U38 = mS && mS.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    $38 = mS && mS.__importStar || function() {
      var A = function(Q) {
        return A = Object.getOwnPropertyNames || function(B) {
          var G = [];
          for (var Z in B)
            if (Object.prototype.hasOwnProperty.call(B, Z)) G[G.length] = Z;
          return G
        }, A(Q)
      };
      return function(Q) {
        if (Q && Q.__esModule) return Q;
        var B = {};
        if (Q != null) {
          for (var G = A(Q), Z = 0; Z < G.length; Z++)
            if (G[Z] !== "default") z38(B, Q, G[Z])
        }
        return U38(B, Q), B
      }
    }();
  Object.defineProperty(mS, "__esModule", {
    value: !0
  });
  mS.fromTemporaryCredentials = void 0;
  var w38 = iB(),
    dRQ = j2(),
    q38 = "us-east-1",
    N38 = (A, Q, B) => {
      let G;
      return async (Z = {}) => {
        let {
          callerClientConfig: I
        } = Z, Y = A.clientConfig?.profile ?? I?.profile, J = A.logger ?? I?.logger;
        J?.debug("@aws-sdk/credential-providers - fromTemporaryCredentials (STS)");
        let W = {
          ...A.params,
          RoleSessionName: A.params.RoleSessionName ?? "aws-sdk-js-" + Date.now()
        };
        if (W?.SerialNumber) {
          if (!A.mfaCodeProvider) throw new dRQ.CredentialsProviderError("Temporary credential requires multi-factor authentication, but no MFA code callback was provided.", {
            tryNextLink: !1,
            logger: J
          });
          W.TokenCode = await A.mfaCodeProvider(W?.SerialNumber)
        }
        let {
          AssumeRoleCommand: X,
          STSClient: V
        } = await Promise.resolve().then(() => $38(mRQ()));
        if (!G) {
          let K = typeof Q === "function" ? Q() : void 0,
            D = [A.masterCredentials, A.clientConfig?.credentials, void I?.credentials, I?.credentialDefaultProvider?.(), K],
            H = "STS client default credentials";
          if (D[0]) H = "options.masterCredentials";
          else if (D[1]) H = "options.clientConfig.credentials";
          else if (D[2]) throw H = "caller client's credentials", Error("fromTemporaryCredentials recursion in callerClientConfig.credentials");
          else if (D[3]) H = "caller client's credentialDefaultProvider";
          else if (D[4]) H = "AWS SDK default credentials";
          let C = [A.clientConfig?.region, I?.region, await B?.({
              profile: Y
            }), q38],
            E = "default partition's default region";
          if (C[0]) E = "options.clientConfig.region";
          else if (C[1]) E = "caller client's region";
          else if (C[2]) E = "file or env region";
          let U = [cRQ(A.clientConfig?.requestHandler), cRQ(I?.requestHandler)],
            q = "STS default requestHandler";
          if (U[0]) q = "options.clientConfig.requestHandler";
          else if (U[1]) q = "caller client's requestHandler";
          J?.debug?.(`@aws-sdk/credential-providers - fromTemporaryCredentials STS client init with ${E}=${await(0,w38.normalizeProvider)(mmA(C))()}, ${H}, ${q}.`), G = new V({
            ...A.clientConfig,
            credentials: mmA(D),
            logger: J,
            profile: Y,
            region: mmA(C),
            requestHandler: mmA(U)
          })
        }
        if (A.clientPlugins)
          for (let K of A.clientPlugins) G.middlewareStack.use(K);
        let {
          Credentials: F
        } = await G.send(new X(W));
        if (!F || !F.AccessKeyId || !F.SecretAccessKey) throw new dRQ.CredentialsProviderError(`Invalid response from STS.assumeRole call with role ${W.RoleArn}`, {
          logger: J
        });
        return {
          accessKeyId: F.AccessKeyId,
          secretAccessKey: F.SecretAccessKey,
          sessionToken: F.SessionToken,
          expiration: F.Expiration,
          credentialScope: F.CredentialScope
        }
      }
    };
  mS.fromTemporaryCredentials = N38;
  var cRQ = (A) => {
      return A?.metadata?.handlerProtocol === "h2" ? void 0 : A
    },
    mmA = (A) => {
      for (let Q of A)
        if (Q !== void 0) return Q
    }
})
// @from(Start 3599488, End 3600185)
nRQ = z((lRQ) => {
  Object.defineProperty(lRQ, "__esModule", {
    value: !0
  });
  lRQ.fromTemporaryCredentials = void 0;
  var L38 = f8(),
    M38 = uI(),
    O38 = FT1(),
    R38 = pRQ(),
    T38 = (A) => {
      return (0, R38.fromTemporaryCredentials)(A, O38.fromNodeProviderChain, async ({
        profile: Q = process.env.AWS_PROFILE
      }) => (0, M38.loadConfig)({
        environmentVariableSelector: (B) => B.AWS_REGION,
        configFileSelector: (B) => {
          return B.region
        },
        default: () => {
          return
        }
      }, {
        ...L38.NODE_REGION_CONFIG_FILE_OPTIONS,
        profile: Q
      })())
    };
  lRQ.fromTemporaryCredentials = T38
})
// @from(Start 3600191, End 3600418)
rRQ = z((aRQ) => {
  Object.defineProperty(aRQ, "__esModule", {
    value: !0
  });
  aRQ.fromTokenFile = void 0;
  var P38 = FCA(),
    j38 = (A = {}) => (0, P38.fromTokenFile)({
      ...A
    });
  aRQ.fromTokenFile = j38
})
// @from(Start 3600424, End 3600643)
eRQ = z((oRQ) => {
  Object.defineProperty(oRQ, "__esModule", {
    value: !0
  });
  oRQ.fromWebToken = void 0;
  var S38 = FCA(),
    _38 = (A) => (0, S38.fromWebToken)({
      ...A
    });
  oRQ.fromWebToken = _38
})
// @from(Start 3600649, End 3601304)
KT1 = z((OH) => {
  Object.defineProperty(OH, "__esModule", {
    value: !0
  });
  OH.fromHttp = void 0;
  var Tw = sr();
  Tw.__exportStar(KWQ(), OH);
  Tw.__exportStar(OUQ(), OH);
  Tw.__exportStar(PUQ(), OH);
  Tw.__exportStar(_UQ(), OH);
  var k38 = uuA();
  Object.defineProperty(OH, "fromHttp", {
    enumerable: !0,
    get: function() {
      return k38.fromHttp
    }
  });
  Tw.__exportStar(P$Q(), OH);
  Tw.__exportStar(wRQ(), OH);
  Tw.__exportStar(LRQ(), OH);
  Tw.__exportStar(FT1(), OH);
  Tw.__exportStar(bRQ(), OH);
  Tw.__exportStar(gRQ(), OH);
  Tw.__exportStar(nRQ(), OH);
  Tw.__exportStar(rRQ(), OH);
  Tw.__exportStar(eRQ(), OH)
})
// @from(Start 3601307, End 3601374)
function QTQ(A) {
  return A?.name === "CredentialsProviderError"
}
// @from(Start 3601376, End 3601760)
function BTQ(A) {
  if (!A || typeof A !== "object") return !1;
  let Q = A;
  if (!Q.Credentials || typeof Q.Credentials !== "object") return !1;
  let B = Q.Credentials;
  return typeof B.AccessKeyId === "string" && typeof B.SecretAccessKey === "string" && typeof B.SessionToken === "string" && B.AccessKeyId.length > 0 && B.SecretAccessKey.length > 0 && B.SessionToken.length > 0
}
// @from(Start 3601761, End 3602057)
async function GTQ() {
  try {
    g("Clearing AWS credential provider cache"), await ATQ.fromIni({
      ignoreCache: !0
    })(), g("AWS credential provider cache refreshed")
  } catch (A) {
    g("Failed to clear AWS credential cache (this is expected if no credentials are configured)")
  }
}
// @from(Start 3602062, End 3602065)
dmA
// @from(Start 3602067, End 3602070)
ATQ
// @from(Start 3602072, End 3602164)
DT1 = async () => {
  await new dmA.STSClient().send(new dmA.GetCallerIdentityCommand({}))
}
// @from(Start 3602170, End 3602237)
HT1 = L(() => {
  V0();
  dmA = BA(bJQ(), 1), ATQ = BA(KT1(), 1)
})
// @from(Start 3602243, End 3605026)
CT1 = z((rL7, KTQ) => {
  var {
    defineProperty: cmA,
    getOwnPropertyDescriptor: x38,
    getOwnPropertyNames: v38
  } = Object, b38 = Object.prototype.hasOwnProperty, pmA = (A, Q) => cmA(A, "name", {
    value: Q,
    configurable: !0
  }), f38 = (A, Q) => {
    for (var B in Q) cmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, h38 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of v38(Q))
        if (!b38.call(A, Z) && Z !== B) cmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = x38(Q, Z)) || G.enumerable
        })
    }
    return A
  }, g38 = (A) => h38(cmA({}, "__esModule", {
    value: !0
  }), A), ZTQ = {};
  f38(ZTQ, {
    AlgorithmId: () => WTQ,
    EndpointURLScheme: () => JTQ,
    FieldPosition: () => XTQ,
    HttpApiKeyAuthLocation: () => YTQ,
    HttpAuthLocation: () => ITQ,
    IniSectionType: () => VTQ,
    RequestHandlerProtocol: () => FTQ,
    SMITHY_CONTEXT_KEY: () => p38,
    getDefaultClientConfiguration: () => d38,
    resolveDefaultRuntimeConfig: () => c38
  });
  KTQ.exports = g38(ZTQ);
  var ITQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(ITQ || {}),
    YTQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(YTQ || {}),
    JTQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(JTQ || {}),
    WTQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(WTQ || {}),
    u38 = pmA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    m38 = pmA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    d38 = pmA((A) => {
      return u38(A)
    }, "getDefaultClientConfiguration"),
    c38 = pmA((A) => {
      return m38(A)
    }, "resolveDefaultRuntimeConfig"),
    XTQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(XTQ || {}),
    p38 = "__smithy_context",
    VTQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(VTQ || {}),
    FTQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(FTQ || {})
})
// @from(Start 3605032, End 3609538)
az = z((oL7, zTQ) => {
  var {
    defineProperty: lmA,
    getOwnPropertyDescriptor: l38,
    getOwnPropertyNames: i38
  } = Object, n38 = Object.prototype.hasOwnProperty, cd = (A, Q) => lmA(A, "name", {
    value: Q,
    configurable: !0
  }), a38 = (A, Q) => {
    for (var B in Q) lmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, s38 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of i38(Q))
        if (!n38.call(A, Z) && Z !== B) lmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = l38(Q, Z)) || G.enumerable
        })
    }
    return A
  }, r38 = (A) => s38(lmA({}, "__esModule", {
    value: !0
  }), A), DTQ = {};
  a38(DTQ, {
    Field: () => e38,
    Fields: () => A78,
    HttpRequest: () => Q78,
    HttpResponse: () => B78,
    IHttpRequest: () => HTQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => o38,
    isValidHostname: () => ETQ,
    resolveHttpHandlerRuntimeConfig: () => t38
  });
  zTQ.exports = r38(DTQ);
  var o38 = cd((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    t38 = cd((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    HTQ = CT1(),
    e38 = class {
      static {
        cd(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = HTQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    A78 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        cd(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    Q78 = class A {
      static {
        cd(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = CTQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function CTQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  cd(CTQ, "cloneQuery");
  var B78 = class {
    static {
      cd(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function ETQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  cd(ETQ, "isValidHostname")
})
// @from(Start 3609544, End 3611407)
CCA = z((QM7, NTQ) => {
  var {
    defineProperty: nmA,
    getOwnPropertyDescriptor: G78,
    getOwnPropertyNames: Z78
  } = Object, I78 = Object.prototype.hasOwnProperty, imA = (A, Q) => nmA(A, "name", {
    value: Q,
    configurable: !0
  }), Y78 = (A, Q) => {
    for (var B in Q) nmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, J78 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Z78(Q))
        if (!I78.call(A, Z) && Z !== B) nmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = G78(Q, Z)) || G.enumerable
        })
    }
    return A
  }, W78 = (A) => J78(nmA({}, "__esModule", {
    value: !0
  }), A), UTQ = {};
  Y78(UTQ, {
    getHostHeaderPlugin: () => V78,
    hostHeaderMiddleware: () => wTQ,
    hostHeaderMiddlewareOptions: () => qTQ,
    resolveHostHeaderConfig: () => $TQ
  });
  NTQ.exports = W78(UTQ);
  var X78 = az();

  function $TQ(A) {
    return A
  }
  imA($TQ, "resolveHostHeaderConfig");
  var wTQ = imA((A) => (Q) => async (B) => {
      if (!X78.HttpRequest.isInstance(B.request)) return Q(B);
      let {
        request: G
      } = B, {
        handlerProtocol: Z = ""
      } = A.requestHandler.metadata || {};
      if (Z.indexOf("h2") >= 0 && !G.headers[":authority"]) delete G.headers.host, G.headers[":authority"] = G.hostname + (G.port ? ":" + G.port : "");
      else if (!G.headers.host) {
        let I = G.hostname;
        if (G.port != null) I += `:${G.port}`;
        G.headers.host = I
      }
      return Q(B)
    }, "hostHeaderMiddleware"),
    qTQ = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: !0
    },
    V78 = imA((A) => ({
      applyToStack: imA((Q) => {
        Q.add(wTQ(A), qTQ)
      }, "applyToStack")
    }), "getHostHeaderPlugin")
})
// @from(Start 3611413, End 3613713)
ECA = z((BM7, RTQ) => {
  var {
    defineProperty: amA,
    getOwnPropertyDescriptor: F78,
    getOwnPropertyNames: K78
  } = Object, D78 = Object.prototype.hasOwnProperty, ET1 = (A, Q) => amA(A, "name", {
    value: Q,
    configurable: !0
  }), H78 = (A, Q) => {
    for (var B in Q) amA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, C78 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of K78(Q))
        if (!D78.call(A, Z) && Z !== B) amA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = F78(Q, Z)) || G.enumerable
        })
    }
    return A
  }, E78 = (A) => C78(amA({}, "__esModule", {
    value: !0
  }), A), LTQ = {};
  H78(LTQ, {
    getLoggerPlugin: () => z78,
    loggerMiddleware: () => MTQ,
    loggerMiddlewareOptions: () => OTQ
  });
  RTQ.exports = E78(LTQ);
  var MTQ = ET1(() => (A, Q) => async (B) => {
      try {
        let G = await A(B),
          {
            clientName: Z,
            commandName: I,
            logger: Y,
            dynamoDbDocumentClientOptions: J = {}
          } = Q,
          {
            overrideInputFilterSensitiveLog: W,
            overrideOutputFilterSensitiveLog: X
          } = J,
          V = W ?? Q.inputFilterSensitiveLog,
          F = X ?? Q.outputFilterSensitiveLog,
          {
            $metadata: K,
            ...D
          } = G.output;
        return Y?.info?.({
          clientName: Z,
          commandName: I,
          input: V(B.input),
          output: F(D),
          metadata: K
        }), G
      } catch (G) {
        let {
          clientName: Z,
          commandName: I,
          logger: Y,
          dynamoDbDocumentClientOptions: J = {}
        } = Q, {
          overrideInputFilterSensitiveLog: W
        } = J, X = W ?? Q.inputFilterSensitiveLog;
        throw Y?.error?.({
          clientName: Z,
          commandName: I,
          input: X(B.input),
          error: G,
          metadata: G.$metadata
        }), G
      }
    }, "loggerMiddleware"),
    OTQ = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: !0
    },
    z78 = ET1((A) => ({
      applyToStack: ET1((Q) => {
        Q.add(MTQ(), OTQ)
      }, "applyToStack")
    }), "getLoggerPlugin")
})
// @from(Start 3613719, End 3615651)
zCA = z((GM7, STQ) => {
  var {
    defineProperty: rmA,
    getOwnPropertyDescriptor: U78,
    getOwnPropertyNames: $78
  } = Object, w78 = Object.prototype.hasOwnProperty, smA = (A, Q) => rmA(A, "name", {
    value: Q,
    configurable: !0
  }), q78 = (A, Q) => {
    for (var B in Q) rmA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, N78 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of $78(Q))
        if (!w78.call(A, Z) && Z !== B) rmA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = U78(Q, Z)) || G.enumerable
        })
    }
    return A
  }, L78 = (A) => N78(rmA({}, "__esModule", {
    value: !0
  }), A), TTQ = {};
  q78(TTQ, {
    addRecursionDetectionMiddlewareOptions: () => jTQ,
    getRecursionDetectionPlugin: () => T78,
    recursionDetectionMiddleware: () => PTQ
  });
  STQ.exports = L78(TTQ);
  var M78 = az(),
    zT1 = "X-Amzn-Trace-Id",
    O78 = "AWS_LAMBDA_FUNCTION_NAME",
    R78 = "_X_AMZN_TRACE_ID",
    PTQ = smA((A) => (Q) => async (B) => {
      let {
        request: G
      } = B;
      if (!M78.HttpRequest.isInstance(G) || A.runtime !== "node") return Q(B);
      let Z = Object.keys(G.headers ?? {}).find((W) => W.toLowerCase() === zT1.toLowerCase()) ?? zT1;
      if (G.headers.hasOwnProperty(Z)) return Q(B);
      let I = process.env[O78],
        Y = process.env[R78],
        J = smA((W) => typeof W === "string" && W.length > 0, "nonEmptyString");
      if (J(I) && J(Y)) G.headers[zT1] = Y;
      return Q({
        ...B,
        request: G
      })
    }, "recursionDetectionMiddleware"),
    jTQ = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: !0,
      priority: "low"
    },
    T78 = smA((A) => ({
      applyToStack: smA((Q) => {
        Q.add(PTQ(A), jTQ)
      }, "applyToStack")
    }), "getRecursionDetectionPlugin")
})
// @from(Start 3615657, End 3627115)
T6A = z((ZM7, uTQ) => {
  var {
    defineProperty: omA,
    getOwnPropertyDescriptor: P78,
    getOwnPropertyNames: j78
  } = Object, S78 = Object.prototype.hasOwnProperty, R6A = (A, Q) => omA(A, "name", {
    value: Q,
    configurable: !0
  }), _78 = (A, Q) => {
    for (var B in Q) omA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, k78 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of j78(Q))
        if (!S78.call(A, Z) && Z !== B) omA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = P78(Q, Z)) || G.enumerable
        })
    }
    return A
  }, y78 = (A) => k78(omA({}, "__esModule", {
    value: !0
  }), A), kTQ = {};
  _78(kTQ, {
    ConditionObject: () => _Z.ConditionObject,
    DeprecatedObject: () => _Z.DeprecatedObject,
    EndpointError: () => _Z.EndpointError,
    EndpointObject: () => _Z.EndpointObject,
    EndpointObjectHeaders: () => _Z.EndpointObjectHeaders,
    EndpointObjectProperties: () => _Z.EndpointObjectProperties,
    EndpointParams: () => _Z.EndpointParams,
    EndpointResolverOptions: () => _Z.EndpointResolverOptions,
    EndpointRuleObject: () => _Z.EndpointRuleObject,
    ErrorRuleObject: () => _Z.ErrorRuleObject,
    EvaluateOptions: () => _Z.EvaluateOptions,
    Expression: () => _Z.Expression,
    FunctionArgv: () => _Z.FunctionArgv,
    FunctionObject: () => _Z.FunctionObject,
    FunctionReturn: () => _Z.FunctionReturn,
    ParameterObject: () => _Z.ParameterObject,
    ReferenceObject: () => _Z.ReferenceObject,
    ReferenceRecord: () => _Z.ReferenceRecord,
    RuleSetObject: () => _Z.RuleSetObject,
    RuleSetRules: () => _Z.RuleSetRules,
    TreeRuleObject: () => _Z.TreeRuleObject,
    awsEndpointFunctions: () => gTQ,
    getUserAgentPrefix: () => f78,
    isIpAddress: () => _Z.isIpAddress,
    partition: () => fTQ,
    resolveEndpoint: () => _Z.resolveEndpoint,
    setPartitionInfo: () => hTQ,
    useDefaultPartitionInfo: () => b78
  });
  uTQ.exports = y78(kTQ);
  var _Z = FI(),
    yTQ = R6A((A, Q = !1) => {
      if (Q) {
        for (let B of A.split("."))
          if (!yTQ(B)) return !1;
        return !0
      }
      if (!(0, _Z.isValidHostLabel)(A)) return !1;
      if (A.length < 3 || A.length > 63) return !1;
      if (A !== A.toLowerCase()) return !1;
      if ((0, _Z.isIpAddress)(A)) return !1;
      return !0
    }, "isVirtualHostableS3Bucket"),
    _TQ = ":",
    x78 = "/",
    v78 = R6A((A) => {
      let Q = A.split(_TQ);
      if (Q.length < 6) return null;
      let [B, G, Z, I, Y, ...J] = Q;
      if (B !== "arn" || G === "" || Z === "" || J.join(_TQ) === "") return null;
      let W = J.map((X) => X.split(x78)).flat();
      return {
        partition: G,
        service: Z,
        region: I,
        accountId: Y,
        resourceId: W
      }
    }, "parseArn"),
    xTQ = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-east-2": {
            description: "Asia Pacific (Taipei)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "cloud.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-e-global": {
            description: "AWS ISOE (Europe) global region"
          },
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "csp.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "AWS ISOF global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      }, {
        id: "aws-eusc",
        outputs: {
          dnsSuffix: "amazonaws.eu",
          dualStackDnsSuffix: "amazonaws.eu",
          implicitGlobalRegion: "eusc-de-east-1",
          name: "aws-eusc",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
        regions: {
          "eusc-de-east-1": {
            description: "EU (Germany)"
          }
        }
      }],
      version: "1.1"
    },
    vTQ = xTQ,
    bTQ = "",
    fTQ = R6A((A) => {
      let {
        partitions: Q
      } = vTQ;
      for (let G of Q) {
        let {
          regions: Z,
          outputs: I
        } = G;
        for (let [Y, J] of Object.entries(Z))
          if (Y === A) return {
            ...I,
            ...J
          }
      }
      for (let G of Q) {
        let {
          regionRegex: Z,
          outputs: I
        } = G;
        if (new RegExp(Z).test(A)) return {
          ...I
        }
      }
      let B = Q.find((G) => G.id === "aws");
      if (!B) throw Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      return {
        ...B.outputs
      }
    }, "partition"),
    hTQ = R6A((A, Q = "") => {
      vTQ = A, bTQ = Q
    }, "setPartitionInfo"),
    b78 = R6A(() => {
      hTQ(xTQ, "")
    }, "useDefaultPartitionInfo"),
    f78 = R6A(() => bTQ, "getUserAgentPrefix"),
    gTQ = {
      isVirtualHostableS3Bucket: yTQ,
      parseArn: v78,
      partition: fTQ
    };
  _Z.customEndpointFunctions.aws = gTQ
})
// @from(Start 3627121, End 3644376)
Co = z((IM7, AdA) => {
  var mTQ, dTQ, cTQ, pTQ, lTQ, iTQ, nTQ, aTQ, sTQ, rTQ, oTQ, tTQ, eTQ, tmA, UT1, APQ, QPQ, BPQ, P6A, GPQ, ZPQ, IPQ, YPQ, JPQ, WPQ, XPQ, VPQ, FPQ, emA, KPQ, DPQ, HPQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof AdA === "object" && typeof IM7 === "object") A(B(Q, B(IM7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    mTQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, dTQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, cTQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, pTQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, lTQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, iTQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, nTQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, aTQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, sTQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, rTQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, oTQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, tTQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, eTQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) emA(Y, I, J)
    }, emA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, tmA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, UT1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, APQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(UT1(arguments[Y]));
      return I
    }, QPQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, BPQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, P6A = function(I) {
      return this instanceof P6A ? (this.v = I, this) : new P6A(I)
    }, GPQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof P6A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, ZPQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: P6A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, IPQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof tmA === "function" ? tmA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, YPQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    JPQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") emA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, WPQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, XPQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, VPQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, FPQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, KPQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    DPQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, HPQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", mTQ), A("__assign", dTQ), A("__rest", cTQ), A("__decorate", pTQ), A("__param", lTQ), A("__esDecorate", iTQ), A("__runInitializers", nTQ), A("__propKey", aTQ), A("__setFunctionName", sTQ), A("__metadata", rTQ), A("__awaiter", oTQ), A("__generator", tTQ), A("__exportStar", eTQ), A("__createBinding", emA), A("__values", tmA), A("__read", UT1), A("__spread", APQ), A("__spreadArrays", QPQ), A("__spreadArray", BPQ), A("__await", P6A), A("__asyncGenerator", GPQ), A("__asyncDelegator", ZPQ), A("__asyncValues", IPQ), A("__makeTemplateObject", YPQ), A("__importStar", JPQ), A("__importDefault", WPQ), A("__classPrivateFieldGet", XPQ), A("__classPrivateFieldSet", VPQ), A("__classPrivateFieldIn", FPQ), A("__addDisposableResource", KPQ), A("__disposeResources", DPQ), A("__rewriteRelativeImportExtension", HPQ)
  })
})
// @from(Start 3644382, End 3646365)
aR = z((YM7, $PQ) => {
  var {
    defineProperty: QdA,
    getOwnPropertyDescriptor: h78,
    getOwnPropertyNames: g78
  } = Object, u78 = Object.prototype.hasOwnProperty, BdA = (A, Q) => QdA(A, "name", {
    value: Q,
    configurable: !0
  }), m78 = (A, Q) => {
    for (var B in Q) QdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, d78 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of g78(Q))
        if (!u78.call(A, Z) && Z !== B) QdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = h78(Q, Z)) || G.enumerable
        })
    }
    return A
  }, c78 = (A) => d78(QdA({}, "__esModule", {
    value: !0
  }), A), CPQ = {};
  m78(CPQ, {
    emitWarningIfUnsupportedVersion: () => p78,
    setCredentialFeature: () => EPQ,
    setFeature: () => zPQ,
    setTokenFeature: () => UPQ,
    state: () => $T1
  });
  $PQ.exports = c78(CPQ);
  var $T1 = {
      warningEmitted: !1
    },
    p78 = BdA((A) => {
      if (A && !$T1.warningEmitted && parseInt(A.substring(1, A.indexOf("."))) < 18) $T1.warningEmitted = !0, process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`)
    }, "emitWarningIfUnsupportedVersion");

  function EPQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  BdA(EPQ, "setCredentialFeature");

  function zPQ(A, Q, B) {
    if (!A.__aws_sdk_context) A.__aws_sdk_context = {
      features: {}
    };
    else if (!A.__aws_sdk_context.features) A.__aws_sdk_context.features = {};
    A.__aws_sdk_context.features[Q] = B
  }
  BdA(zPQ, "setFeature");

  function UPQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  BdA(UPQ, "setTokenFeature")
})
// @from(Start 3646371, End 3647324)
NPQ = z((JM7, qPQ) => {
  var {
    defineProperty: GdA,
    getOwnPropertyDescriptor: l78,
    getOwnPropertyNames: i78
  } = Object, n78 = Object.prototype.hasOwnProperty, a78 = (A, Q) => GdA(A, "name", {
    value: Q,
    configurable: !0
  }), s78 = (A, Q) => {
    for (var B in Q) GdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, r78 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of i78(Q))
        if (!n78.call(A, Z) && Z !== B) GdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = l78(Q, Z)) || G.enumerable
        })
    }
    return A
  }, o78 = (A) => r78(GdA({}, "__esModule", {
    value: !0
  }), A), wPQ = {};
  s78(wPQ, {
    isArrayBuffer: () => t78
  });
  qPQ.exports = o78(wPQ);
  var t78 = a78((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 3647330, End 3648383)
RPQ = z((WM7, OPQ) => {
  var {
    defineProperty: ZdA,
    getOwnPropertyDescriptor: e78,
    getOwnPropertyNames: AG8
  } = Object, QG8 = Object.prototype.hasOwnProperty, wT1 = (A, Q) => ZdA(A, "name", {
    value: Q,
    configurable: !0
  }), BG8 = (A, Q) => {
    for (var B in Q) ZdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, GG8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of AG8(Q))
        if (!QG8.call(A, Z) && Z !== B) ZdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = e78(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ZG8 = (A) => GG8(ZdA({}, "__esModule", {
    value: !0
  }), A), LPQ = {};
  BG8(LPQ, {
    escapeUri: () => MPQ,
    escapeUriPath: () => YG8
  });
  OPQ.exports = ZG8(LPQ);
  var MPQ = wT1((A) => encodeURIComponent(A).replace(/[!'()*]/g, IG8), "escapeUri"),
    IG8 = wT1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    YG8 = wT1((A) => A.split("/").map(MPQ).join("/"), "escapeUriPath")
})
// @from(Start 3648389, End 3665302)
AjQ = z((XM7, ePQ) => {
  var {
    defineProperty: FdA,
    getOwnPropertyDescriptor: JG8,
    getOwnPropertyNames: WG8
  } = Object, XG8 = Object.prototype.hasOwnProperty, VD = (A, Q) => FdA(A, "name", {
    value: Q,
    configurable: !0
  }), VG8 = (A, Q) => {
    for (var B in Q) FdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, FG8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of WG8(Q))
        if (!XG8.call(A, Z) && Z !== B) FdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = JG8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, KG8 = (A) => FG8(FdA({}, "__esModule", {
    value: !0
  }), A), _PQ = {};
  VG8(_PQ, {
    ALGORITHM_IDENTIFIER: () => IdA,
    ALGORITHM_IDENTIFIER_V4A: () => EG8,
    ALGORITHM_QUERY_PARAM: () => kPQ,
    ALWAYS_UNSIGNABLE_HEADERS: () => uPQ,
    AMZ_DATE_HEADER: () => PT1,
    AMZ_DATE_QUERY_PARAM: () => MT1,
    AUTH_HEADER: () => TT1,
    CREDENTIAL_QUERY_PARAM: () => yPQ,
    DATE_HEADER: () => bPQ,
    EVENT_ALGORITHM_IDENTIFIER: () => cPQ,
    EXPIRES_QUERY_PARAM: () => vPQ,
    GENERATED_HEADERS: () => fPQ,
    HOST_HEADER: () => HG8,
    KEY_TYPE_IDENTIFIER: () => jT1,
    MAX_CACHE_SIZE: () => lPQ,
    MAX_PRESIGNED_TTL: () => iPQ,
    PROXY_HEADER_PATTERN: () => mPQ,
    REGION_SET_PARAM: () => DG8,
    SEC_HEADER_PATTERN: () => dPQ,
    SHA256_HEADER: () => VdA,
    SIGNATURE_HEADER: () => hPQ,
    SIGNATURE_QUERY_PARAM: () => OT1,
    SIGNED_HEADERS_QUERY_PARAM: () => xPQ,
    SignatureV4: () => TG8,
    SignatureV4Base: () => tPQ,
    TOKEN_HEADER: () => gPQ,
    TOKEN_QUERY_PARAM: () => RT1,
    UNSIGNABLE_PATTERNS: () => CG8,
    UNSIGNED_PAYLOAD: () => pPQ,
    clearCredentialCache: () => UG8,
    createScope: () => JdA,
    getCanonicalHeaders: () => qT1,
    getCanonicalQuery: () => oPQ,
    getPayloadHash: () => WdA,
    getSigningKey: () => nPQ,
    hasHeader: () => aPQ,
    moveHeadersToQuery: () => rPQ,
    prepareRequest: () => LT1,
    signatureV4aContainer: () => PG8
  });
  ePQ.exports = KG8(_PQ);
  var TPQ = O2(),
    kPQ = "X-Amz-Algorithm",
    yPQ = "X-Amz-Credential",
    MT1 = "X-Amz-Date",
    xPQ = "X-Amz-SignedHeaders",
    vPQ = "X-Amz-Expires",
    OT1 = "X-Amz-Signature",
    RT1 = "X-Amz-Security-Token",
    DG8 = "X-Amz-Region-Set",
    TT1 = "authorization",
    PT1 = MT1.toLowerCase(),
    bPQ = "date",
    fPQ = [TT1, PT1, bPQ],
    hPQ = OT1.toLowerCase(),
    VdA = "x-amz-content-sha256",
    gPQ = RT1.toLowerCase(),
    HG8 = "host",
    uPQ = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0
    },
    mPQ = /^proxy-/,
    dPQ = /^sec-/,
    CG8 = [/^proxy-/i, /^sec-/i],
    IdA = "AWS4-HMAC-SHA256",
    EG8 = "AWS4-ECDSA-P256-SHA256",
    cPQ = "AWS4-HMAC-SHA256-PAYLOAD",
    pPQ = "UNSIGNED-PAYLOAD",
    lPQ = 50,
    jT1 = "aws4_request",
    iPQ = 604800,
    pd = Jd(),
    zG8 = O2(),
    j6A = {},
    YdA = [],
    JdA = VD((A, Q, B) => `${A}/${Q}/${B}/${jT1}`, "createScope"),
    nPQ = VD(async (A, Q, B, G, Z) => {
      let I = await PPQ(A, Q.secretAccessKey, Q.accessKeyId),
        Y = `${B}:${G}:${Z}:${(0,pd.toHex)(I)}:${Q.sessionToken}`;
      if (Y in j6A) return j6A[Y];
      YdA.push(Y);
      while (YdA.length > lPQ) delete j6A[YdA.shift()];
      let J = `AWS4${Q.secretAccessKey}`;
      for (let W of [B, G, Z, jT1]) J = await PPQ(A, J, W);
      return j6A[Y] = J
    }, "getSigningKey"),
    UG8 = VD(() => {
      YdA.length = 0, Object.keys(j6A).forEach((A) => {
        delete j6A[A]
      })
    }, "clearCredentialCache"),
    PPQ = VD((A, Q, B) => {
      let G = new A(Q);
      return G.update((0, zG8.toUint8Array)(B)), G.digest()
    }, "hmac"),
    qT1 = VD(({
      headers: A
    }, Q, B) => {
      let G = {};
      for (let Z of Object.keys(A).sort()) {
        if (A[Z] == null) continue;
        let I = Z.toLowerCase();
        if (I in uPQ || Q?.has(I) || mPQ.test(I) || dPQ.test(I)) {
          if (!B || B && !B.has(I)) continue
        }
        G[I] = A[Z].trim().replace(/\s+/g, " ")
      }
      return G
    }, "getCanonicalHeaders"),
    $G8 = NPQ(),
    wG8 = O2(),
    WdA = VD(async ({
      headers: A,
      body: Q
    }, B) => {
      for (let G of Object.keys(A))
        if (G.toLowerCase() === VdA) return A[G];
      if (Q == null) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      else if (typeof Q === "string" || ArrayBuffer.isView(Q) || (0, $G8.isArrayBuffer)(Q)) {
        let G = new B;
        return G.update((0, wG8.toUint8Array)(Q)), (0, pd.toHex)(await G.digest())
      }
      return pPQ
    }, "getPayloadHash"),
    jPQ = O2(),
    qG8 = class {
      static {
        VD(this, "HeaderFormatter")
      }
      format(A) {
        let Q = [];
        for (let Z of Object.keys(A)) {
          let I = (0, jPQ.fromUtf8)(Z);
          Q.push(Uint8Array.from([I.byteLength]), I, this.formatHeaderValue(A[Z]))
        }
        let B = new Uint8Array(Q.reduce((Z, I) => Z + I.byteLength, 0)),
          G = 0;
        for (let Z of Q) B.set(Z, G), G += Z.byteLength;
        return B
      }
      formatHeaderValue(A) {
        switch (A.type) {
          case "boolean":
            return Uint8Array.from([A.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, A.value]);
          case "short":
            let Q = new DataView(new ArrayBuffer(3));
            return Q.setUint8(0, 3), Q.setInt16(1, A.value, !1), new Uint8Array(Q.buffer);
          case "integer":
            let B = new DataView(new ArrayBuffer(5));
            return B.setUint8(0, 4), B.setInt32(1, A.value, !1), new Uint8Array(B.buffer);
          case "long":
            let G = new Uint8Array(9);
            return G[0] = 5, G.set(A.value.bytes, 1), G;
          case "binary":
            let Z = new DataView(new ArrayBuffer(3 + A.value.byteLength));
            Z.setUint8(0, 6), Z.setUint16(1, A.value.byteLength, !1);
            let I = new Uint8Array(Z.buffer);
            return I.set(A.value, 3), I;
          case "string":
            let Y = (0, jPQ.fromUtf8)(A.value),
              J = new DataView(new ArrayBuffer(3 + Y.byteLength));
            J.setUint8(0, 7), J.setUint16(1, Y.byteLength, !1);
            let W = new Uint8Array(J.buffer);
            return W.set(Y, 3), W;
          case "timestamp":
            let X = new Uint8Array(9);
            return X[0] = 8, X.set(LG8.fromNumber(A.value.valueOf()).bytes, 1), X;
          case "uuid":
            if (!NG8.test(A.value)) throw Error(`Invalid UUID received: ${A.value}`);
            let V = new Uint8Array(17);
            return V[0] = 9, V.set((0, pd.fromHex)(A.value.replace(/\-/g, "")), 1), V
        }
      }
    },
    NG8 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    LG8 = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static {
        VD(this, "Int64")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) NT1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) NT1(Q);
        return parseInt((0, pd.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };

  function NT1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  VD(NT1, "negate");
  var aPQ = VD((A, Q) => {
      A = A.toLowerCase();
      for (let B of Object.keys(Q))
        if (A === B.toLowerCase()) return !0;
      return !1
    }, "hasHeader"),
    sPQ = az(),
    rPQ = VD((A, Q = {}) => {
      let {
        headers: B,
        query: G = {}
      } = sPQ.HttpRequest.clone(A);
      for (let Z of Object.keys(B)) {
        let I = Z.toLowerCase();
        if (I.slice(0, 6) === "x-amz-" && !Q.unhoistableHeaders?.has(I) || Q.hoistableHeaders?.has(I)) G[Z] = B[Z], delete B[Z]
      }
      return {
        ...A,
        headers: B,
        query: G
      }
    }, "moveHeadersToQuery"),
    LT1 = VD((A) => {
      A = sPQ.HttpRequest.clone(A);
      for (let Q of Object.keys(A.headers))
        if (fPQ.indexOf(Q.toLowerCase()) > -1) delete A.headers[Q];
      return A
    }, "prepareRequest"),
    SPQ = w7(),
    MG8 = O2(),
    XdA = RPQ(),
    oPQ = VD(({
      query: A = {}
    }) => {
      let Q = [],
        B = {};
      for (let G of Object.keys(A)) {
        if (G.toLowerCase() === hPQ) continue;
        let Z = (0, XdA.escapeUri)(G);
        Q.push(Z);
        let I = A[G];
        if (typeof I === "string") B[Z] = `${Z}=${(0,XdA.escapeUri)(I)}`;
        else if (Array.isArray(I)) B[Z] = I.slice(0).reduce((Y, J) => Y.concat([`${Z}=${(0,XdA.escapeUri)(J)}`]), []).sort().join("&")
      }
      return Q.sort().map((G) => B[G]).filter((G) => G).join("&")
    }, "getCanonicalQuery"),
    OG8 = VD((A) => RG8(A).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601"),
    RG8 = VD((A) => {
      if (typeof A === "number") return new Date(A * 1000);
      if (typeof A === "string") {
        if (Number(A)) return new Date(Number(A) * 1000);
        return new Date(A)
      }
      return A
    }, "toDate"),
    tPQ = class {
      static {
        VD(this, "SignatureV4Base")
      }
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        this.service = G, this.sha256 = Z, this.uriEscapePath = I, this.applyChecksum = typeof A === "boolean" ? A : !0, this.regionProvider = (0, SPQ.normalizeProvider)(B), this.credentialProvider = (0, SPQ.normalizeProvider)(Q)
      }
      createCanonicalRequest(A, Q, B) {
        let G = Object.keys(Q).sort();
        return `${A.method}
${this.getCanonicalPath(A)}
${oPQ(A)}
${G.map((Z)=>`${Z}:${Q[Z]}`).join(`
`)}

${G.join(";")}
${B}`
      }
      async createStringToSign(A, Q, B, G) {
        let Z = new this.sha256;
        Z.update((0, MG8.toUint8Array)(B));
        let I = await Z.digest();
        return `${G}
${A}
${Q}
${(0,pd.toHex)(I)}`
      }
      getCanonicalPath({
        path: A
      }) {
        if (this.uriEscapePath) {
          let Q = [];
          for (let Z of A.split("/")) {
            if (Z?.length === 0) continue;
            if (Z === ".") continue;
            if (Z === "..") Q.pop();
            else Q.push(Z)
          }
          let B = `${A?.startsWith("/")?"/":""}${Q.join("/")}${Q.length>0&&A?.endsWith("/")?"/":""}`;
          return (0, XdA.escapeUri)(B).replace(/%2F/g, "/")
        }
        return A
      }
      validateResolvedCredentials(A) {
        if (typeof A !== "object" || typeof A.accessKeyId !== "string" || typeof A.secretAccessKey !== "string") throw Error("Resolved credential object is not valid")
      }
      formatDate(A) {
        let Q = OG8(A).replace(/[\-:]/g, "");
        return {
          longDate: Q,
          shortDate: Q.slice(0, 8)
        }
      }
      getCanonicalHeaderList(A) {
        return Object.keys(A).sort().join(";")
      }
    },
    TG8 = class extends tPQ {
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        super({
          applyChecksum: A,
          credentials: Q,
          region: B,
          service: G,
          sha256: Z,
          uriEscapePath: I
        });
        this.headerFormatter = new qG8
      }
      static {
        VD(this, "SignatureV4")
      }
      async presign(A, Q = {}) {
        let {
          signingDate: B = new Date,
          expiresIn: G = 3600,
          unsignableHeaders: Z,
          unhoistableHeaders: I,
          signableHeaders: Y,
          hoistableHeaders: J,
          signingRegion: W,
          signingService: X
        } = Q, V = await this.credentialProvider();
        this.validateResolvedCredentials(V);
        let F = W ?? await this.regionProvider(),
          {
            longDate: K,
            shortDate: D
          } = this.formatDate(B);
        if (G > iPQ) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        let H = JdA(D, F, X ?? this.service),
          C = rPQ(LT1(A), {
            unhoistableHeaders: I,
            hoistableHeaders: J
          });
        if (V.sessionToken) C.query[RT1] = V.sessionToken;
        C.query[kPQ] = IdA, C.query[yPQ] = `${V.accessKeyId}/${H}`, C.query[MT1] = K, C.query[vPQ] = G.toString(10);
        let E = qT1(C, Z, Y);
        return C.query[xPQ] = this.getCanonicalHeaderList(E), C.query[OT1] = await this.getSignature(K, H, this.getSigningKey(V, F, D, X), this.createCanonicalRequest(C, E, await WdA(A, this.sha256))), C
      }
      async sign(A, Q) {
        if (typeof A === "string") return this.signString(A, Q);
        else if (A.headers && A.payload) return this.signEvent(A, Q);
        else if (A.message) return this.signMessage(A, Q);
        else return this.signRequest(A, Q)
      }
      async signEvent({
        headers: A,
        payload: Q
      }, {
        signingDate: B = new Date,
        priorSignature: G,
        signingRegion: Z,
        signingService: I
      }) {
        let Y = Z ?? await this.regionProvider(),
          {
            shortDate: J,
            longDate: W
          } = this.formatDate(B),
          X = JdA(J, Y, I ?? this.service),
          V = await WdA({
            headers: {},
            body: Q
          }, this.sha256),
          F = new this.sha256;
        F.update(A);
        let K = (0, pd.toHex)(await F.digest()),
          D = [cPQ, W, X, G, K, V].join(`
`);
        return this.signString(D, {
          signingDate: B,
          signingRegion: Y,
          signingService: I
        })
      }
      async signMessage(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      }) {
        return this.signEvent({
          headers: this.headerFormatter.format(A.message.headers),
          payload: A.message.body
        }, {
          signingDate: Q,
          signingRegion: B,
          signingService: G,
          priorSignature: A.priorSignature
        }).then((I) => {
          return {
            message: A.message,
            signature: I
          }
        })
      }
      async signString(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      } = {}) {
        let Z = await this.credentialProvider();
        this.validateResolvedCredentials(Z);
        let I = B ?? await this.regionProvider(),
          {
            shortDate: Y
          } = this.formatDate(Q),
          J = new this.sha256(await this.getSigningKey(Z, I, Y, G));
        return J.update((0, TPQ.toUint8Array)(A)), (0, pd.toHex)(await J.digest())
      }
      async signRequest(A, {
        signingDate: Q = new Date,
        signableHeaders: B,
        unsignableHeaders: G,
        signingRegion: Z,
        signingService: I
      } = {}) {
        let Y = await this.credentialProvider();
        this.validateResolvedCredentials(Y);
        let J = Z ?? await this.regionProvider(),
          W = LT1(A),
          {
            longDate: X,
            shortDate: V
          } = this.formatDate(Q),
          F = JdA(V, J, I ?? this.service);
        if (W.headers[PT1] = X, Y.sessionToken) W.headers[gPQ] = Y.sessionToken;
        let K = await WdA(W, this.sha256);
        if (!aPQ(VdA, W.headers) && this.applyChecksum) W.headers[VdA] = K;
        let D = qT1(W, G, B),
          H = await this.getSignature(X, F, this.getSigningKey(Y, J, V, I), this.createCanonicalRequest(W, D, K));
        return W.headers[TT1] = `${IdA} Credential=${Y.accessKeyId}/${F}, SignedHeaders=${this.getCanonicalHeaderList(D)}, Signature=${H}`, W
      }
      async getSignature(A, Q, B, G) {
        let Z = await this.createStringToSign(A, Q, G, IdA),
          I = new this.sha256(await B);
        return I.update((0, TPQ.toUint8Array)(Z)), (0, pd.toHex)(await I.digest())
      }
      getSigningKey(A, Q, B, G) {
        return nPQ(this.sha256, A, B, Q, G || this.service)
      }
    },
    PG8 = {
      SignatureV4a: null
    }
})
// @from(Start 3665308, End 3674722)
yT1 = z((DM7, DjQ) => {
  var {
    defineProperty: KdA,
    getOwnPropertyDescriptor: jG8,
    getOwnPropertyNames: SG8
  } = Object, _G8 = Object.prototype.hasOwnProperty, $W = (A, Q) => KdA(A, "name", {
    value: Q,
    configurable: !0
  }), kG8 = (A, Q) => {
    for (var B in Q) KdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, yG8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of SG8(Q))
        if (!_G8.call(A, Z) && Z !== B) KdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = jG8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, xG8 = (A) => yG8(KdA({}, "__esModule", {
    value: !0
  }), A), WjQ = {};
  kG8(WjQ, {
    AWSSDKSigV4Signer: () => hG8,
    AwsSdkSigV4ASigner: () => uG8,
    AwsSdkSigV4Signer: () => kT1,
    NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => mG8,
    NODE_SIGV4A_CONFIG_OPTIONS: () => pG8,
    getBearerTokenEnvKey: () => XjQ,
    resolveAWSSDKSigV4Config: () => iG8,
    resolveAwsSdkSigV4AConfig: () => cG8,
    resolveAwsSdkSigV4Config: () => VjQ,
    validateSigningProperties: () => _T1
  });
  DjQ.exports = xG8(WjQ);
  var vG8 = az(),
    bG8 = az(),
    QjQ = $W((A) => bG8.HttpResponse.isInstance(A) ? A.headers?.date ?? A.headers?.Date : void 0, "getDateHeader"),
    ST1 = $W((A) => new Date(Date.now() + A), "getSkewCorrectedDate"),
    fG8 = $W((A, Q) => Math.abs(ST1(Q).getTime() - A) >= 300000, "isClockSkewed"),
    BjQ = $W((A, Q) => {
      let B = Date.parse(A);
      if (fG8(B, Q)) return B - Date.now();
      return Q
    }, "getUpdatedSystemClockOffset"),
    UCA = $W((A, Q) => {
      if (!Q) throw Error(`Property \`${A}\` is not resolved for AWS SDK SigV4Auth`);
      return Q
    }, "throwSigningPropertyError"),
    _T1 = $W(async (A) => {
      let Q = UCA("context", A.context),
        B = UCA("config", A.config),
        G = Q.endpointV2?.properties?.authSchemes?.[0],
        I = await UCA("signer", B.signer)(G),
        Y = A?.signingRegion,
        J = A?.signingRegionSet,
        W = A?.signingName;
      return {
        config: B,
        signer: I,
        signingRegion: Y,
        signingRegionSet: J,
        signingName: W
      }
    }, "validateSigningProperties"),
    kT1 = class {
      static {
        $W(this, "AwsSdkSigV4Signer")
      }
      async sign(A, Q, B) {
        if (!vG8.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let G = await _T1(B),
          {
            config: Z,
            signer: I
          } = G,
          {
            signingRegion: Y,
            signingName: J
          } = G,
          W = B.context;
        if (W?.authSchemes?.length ?? !1) {
          let [V, F] = W.authSchemes;
          if (V?.name === "sigv4a" && F?.name === "sigv4") Y = F?.signingRegion ?? Y, J = F?.signingName ?? J
        }
        return await I.sign(A, {
          signingDate: ST1(Z.systemClockOffset),
          signingRegion: Y,
          signingService: J
        })
      }
      errorHandler(A) {
        return (Q) => {
          let B = Q.ServerTime ?? QjQ(Q.$response);
          if (B) {
            let G = UCA("config", A.config),
              Z = G.systemClockOffset;
            if (G.systemClockOffset = BjQ(B, G.systemClockOffset), G.systemClockOffset !== Z && Q.$metadata) Q.$metadata.clockSkewCorrected = !0
          }
          throw Q
        }
      }
      successHandler(A, Q) {
        let B = QjQ(A);
        if (B) {
          let G = UCA("config", Q.config);
          G.systemClockOffset = BjQ(B, G.systemClockOffset)
        }
      }
    },
    hG8 = kT1,
    gG8 = az(),
    uG8 = class extends kT1 {
      static {
        $W(this, "AwsSdkSigV4ASigner")
      }
      async sign(A, Q, B) {
        if (!gG8.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let {
          config: G,
          signer: Z,
          signingRegion: I,
          signingRegionSet: Y,
          signingName: J
        } = await _T1(B), X = (await G.sigv4aSigningRegionSet?.() ?? Y ?? [I]).join(",");
        return await Z.sign(A, {
          signingDate: ST1(G.systemClockOffset),
          signingRegion: X,
          signingService: J
        })
      }
    },
    GjQ = $W((A) => typeof A === "string" && A.length > 0 ? A.split(",").map((Q) => Q.trim()) : [], "getArrayForCommaSeparatedString"),
    XjQ = $W((A) => `AWS_BEARER_TOKEN_${A.replace(/[\s-]/g,"_").toUpperCase()}`, "getBearerTokenEnvKey"),
    ZjQ = "AWS_AUTH_SCHEME_PREFERENCE",
    IjQ = "auth_scheme_preference",
    mG8 = {
      environmentVariableSelector: $W((A, Q) => {
        if (Q?.signingName) {
          if (XjQ(Q.signingName) in A) return ["httpBearerAuth"]
        }
        if (!(ZjQ in A)) return;
        return GjQ(A[ZjQ])
      }, "environmentVariableSelector"),
      configFileSelector: $W((A) => {
        if (!(IjQ in A)) return;
        return GjQ(A[IjQ])
      }, "configFileSelector"),
      default: []
    },
    dG8 = iB(),
    YjQ = j2(),
    cG8 = $W((A) => {
      return A.sigv4aSigningRegionSet = (0, dG8.normalizeProvider)(A.sigv4aSigningRegionSet), A
    }, "resolveAwsSdkSigV4AConfig"),
    pG8 = {
      environmentVariableSelector(A) {
        if (A.AWS_SIGV4A_SIGNING_REGION_SET) return A.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((Q) => Q.trim());
        throw new YjQ.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
          tryNextLink: !0
        })
      },
      configFileSelector(A) {
        if (A.sigv4a_signing_region_set) return (A.sigv4a_signing_region_set ?? "").split(",").map((Q) => Q.trim());
        throw new YjQ.ProviderError("sigv4a_signing_region_set not set in profile.", {
          tryNextLink: !0
        })
      },
      default: void 0
    },
    lG8 = aR(),
    Eo = iB(),
    JjQ = AjQ(),
    VjQ = $W((A) => {
      let Q = A.credentials,
        B = !!A.credentials,
        G = void 0;
      Object.defineProperty(A, "credentials", {
        set(X) {
          if (X && X !== Q && X !== G) B = !0;
          Q = X;
          let V = FjQ(A, {
              credentials: Q,
              credentialDefaultProvider: A.credentialDefaultProvider
            }),
            F = KjQ(A, V);
          if (B && !F.attributed) G = $W(async (K) => F(K).then((D) => (0, lG8.setCredentialFeature)(D, "CREDENTIALS_CODE", "e")), "resolvedCredentials"), G.memoized = F.memoized, G.configBound = F.configBound, G.attributed = !0;
          else G = F
        },
        get() {
          return G
        },
        enumerable: !0,
        configurable: !0
      }), A.credentials = Q;
      let {
        signingEscapePath: Z = !0,
        systemClockOffset: I = A.systemClockOffset || 0,
        sha256: Y
      } = A, J;
      if (A.signer) J = (0, Eo.normalizeProvider)(A.signer);
      else if (A.regionInfoProvider) J = $W(() => (0, Eo.normalizeProvider)(A.region)().then(async (X) => [await A.regionInfoProvider(X, {
        useFipsEndpoint: await A.useFipsEndpoint(),
        useDualstackEndpoint: await A.useDualstackEndpoint()
      }) || {}, X]).then(([X, V]) => {
        let {
          signingRegion: F,
          signingService: K
        } = X;
        A.signingRegion = A.signingRegion || F || V, A.signingName = A.signingName || K || A.serviceId;
        let D = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || JjQ.SignatureV4)(D)
      }), "signer");
      else J = $W(async (X) => {
        X = Object.assign({}, {
          name: "sigv4",
          signingName: A.signingName || A.defaultSigningName,
          signingRegion: await (0, Eo.normalizeProvider)(A.region)(),
          properties: {}
        }, X);
        let {
          signingRegion: V,
          signingName: F
        } = X;
        A.signingRegion = A.signingRegion || V, A.signingName = A.signingName || F || A.serviceId;
        let K = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || JjQ.SignatureV4)(K)
      }, "signer");
      return Object.assign(A, {
        systemClockOffset: I,
        signingEscapePath: Z,
        signer: J
      })
    }, "resolveAwsSdkSigV4Config"),
    iG8 = VjQ;

  function FjQ(A, {
    credentials: Q,
    credentialDefaultProvider: B
  }) {
    let G;
    if (Q)
      if (!Q?.memoized) G = (0, Eo.memoizeIdentityProvider)(Q, Eo.isIdentityExpired, Eo.doesIdentityRequireRefresh);
      else G = Q;
    else if (B) G = (0, Eo.normalizeProvider)(B(Object.assign({}, A, {
      parentClientConfig: A
    })));
    else G = $W(async () => {
      throw Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.")
    }, "credentialsProvider");
    return G.memoized = !0, G
  }
  $W(FjQ, "normalizeCredentialProvider");

  function KjQ(A, Q) {
    if (Q.configBound) return Q;
    let B = $W(async (G) => Q({
      ...G,
      callerClientConfig: A
    }), "fn");
    return B.memoized = Q.memoized, B.configBound = !0, B
  }
  $W(KjQ, "bindCallerConfig")
})
// @from(Start 3674728, End 3675215)
EjQ = z((HjQ) => {
  Object.defineProperty(HjQ, "__esModule", {
    value: !0
  });
  HjQ.fromBase64 = void 0;
  var nG8 = hI(),
    aG8 = /^[A-Za-z0-9+/]*={0,2}$/,
    sG8 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!aG8.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, nG8.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  HjQ.fromBase64 = sG8
})
// @from(Start 3675221, End 3675800)
$jQ = z((zjQ) => {
  Object.defineProperty(zjQ, "__esModule", {
    value: !0
  });
  zjQ.toBase64 = void 0;
  var rG8 = hI(),
    oG8 = O2(),
    tG8 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, oG8.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, rG8.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  zjQ.toBase64 = tG8
})
// @from(Start 3675806, End 3676501)
ld = z((UM7, DdA) => {
  var {
    defineProperty: wjQ,
    getOwnPropertyDescriptor: eG8,
    getOwnPropertyNames: AZ8
  } = Object, QZ8 = Object.prototype.hasOwnProperty, xT1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of AZ8(Q))
        if (!QZ8.call(A, Z) && Z !== B) wjQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = eG8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, qjQ = (A, Q, B) => (xT1(A, Q, "default"), B && xT1(B, Q, "default")), BZ8 = (A) => xT1(wjQ({}, "__esModule", {
    value: !0
  }), A), vT1 = {};
  DdA.exports = BZ8(vT1);
  qjQ(vT1, EjQ(), DdA.exports);
  qjQ(vT1, $jQ(), DdA.exports)
})
// @from(Start 3676507, End 3690531)
o6 = z(($M7, dT1) => {
  var {
    defineProperty: HdA,
    getOwnPropertyDescriptor: GZ8,
    getOwnPropertyNames: ZZ8
  } = Object, IZ8 = Object.prototype.hasOwnProperty, _3 = (A, Q) => HdA(A, "name", {
    value: Q,
    configurable: !0
  }), YZ8 = (A, Q) => {
    for (var B in Q) HdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, fT1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ZZ8(Q))
        if (!IZ8.call(A, Z) && Z !== B) HdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = GZ8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, JZ8 = (A, Q, B) => (fT1(A, Q, "default"), B && fT1(B, Q, "default")), WZ8 = (A) => fT1(HdA({}, "__esModule", {
    value: !0
  }), A), uT1 = {};
  YZ8(uT1, {
    Client: () => XZ8,
    Command: () => MjQ,
    NoOpLogger: () => RZ8,
    SENSITIVE_STRING: () => FZ8,
    ServiceException: () => DZ8,
    _json: () => gT1,
    collectBody: () => bT1.collectBody,
    convertMap: () => TZ8,
    createAggregatedClient: () => KZ8,
    decorateServiceException: () => OjQ,
    emitWarningIfUnsupportedVersion: () => zZ8,
    extendedEncodeURIComponent: () => bT1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => MZ8,
    getDefaultClientConfiguration: () => NZ8,
    getDefaultExtensionConfiguration: () => TjQ,
    getValueFromTextNode: () => PjQ,
    isSerializableHeaderValue: () => OZ8,
    loadConfigsForDefaultMode: () => EZ8,
    map: () => mT1,
    resolveDefaultRuntimeConfig: () => LZ8,
    resolvedPath: () => bT1.resolvedPath,
    serializeDateTime: () => yZ8,
    serializeFloat: () => kZ8,
    take: () => PZ8,
    throwDefaultError: () => RjQ,
    withBaseException: () => HZ8
  });
  dT1.exports = WZ8(uT1);
  var LjQ = uR(),
    XZ8 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, LjQ.constructStack)()
      }
      static {
        _3(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    bT1 = w5(),
    hT1 = CT1(),
    MjQ = class {
      constructor() {
        this.middlewareStack = (0, LjQ.constructStack)()
      }
      static {
        _3(this, "Command")
      }
      static classBuilder() {
        return new VZ8
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [hT1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    VZ8 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        _3(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      sc(A) {
        return this._operationSchema = A, this._smithyContext.operationSchema = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends MjQ {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this), this.schema = A._operationSchema
          }
          static {
            _3(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    FZ8 = "***SensitiveInformation***",
    KZ8 = _3((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = _3(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    DZ8 = class A extends Error {
      static {
        _3(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    OjQ = _3((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    RjQ = _3(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = CZ8(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw OjQ(Y, Q)
    }, "throwDefaultError"),
    HZ8 = _3((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        RjQ({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    CZ8 = _3((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    EZ8 = _3((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    NjQ = !1,
    zZ8 = _3((A) => {
      if (A && !NjQ && parseInt(A.substring(1, A.indexOf("."))) < 16) NjQ = !0
    }, "emitWarningIfUnsupportedVersion"),
    UZ8 = _3((A) => {
      let Q = [];
      for (let B in hT1.AlgorithmId) {
        let G = hT1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    $Z8 = _3((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    wZ8 = _3((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    qZ8 = _3((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    TjQ = _3((A) => {
      return Object.assign(UZ8(A), wZ8(A))
    }, "getDefaultExtensionConfiguration"),
    NZ8 = TjQ,
    LZ8 = _3((A) => {
      return Object.assign($Z8(A), qZ8(A))
    }, "resolveDefaultRuntimeConfig"),
    MZ8 = _3((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    PjQ = _3((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = PjQ(A[B]);
      return A
    }, "getValueFromTextNode"),
    OZ8 = _3((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    RZ8 = class {
      static {
        _3(this, "NoOpLogger")
      }
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };

  function mT1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, jZ8(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      jjQ(G, null, I, Y)
    }
    return G
  }
  _3(mT1, "map");
  var TZ8 = _3((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    PZ8 = _3((A, Q) => {
      let B = {};
      for (let G in Q) jjQ(B, A, Q, G);
      return B
    }, "take"),
    jZ8 = _3((A, Q, B) => {
      return mT1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    jjQ = _3((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = SZ8, W = _Z8, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    SZ8 = _3((A) => A != null, "nonNullish"),
    _Z8 = _3((A) => A, "pass"),
    kZ8 = _3((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    yZ8 = _3((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    gT1 = _3((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(gT1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = gT1(A[B])
        }
        return Q
      }
      return A
    }, "_json");
  JZ8(uT1, s6(), dT1.exports)
})
// @from(Start 3690537, End 3735728)
ljQ = z((OM7, pjQ) => {
  var {
    defineProperty: EdA,
    getOwnPropertyDescriptor: xZ8,
    getOwnPropertyNames: vZ8
  } = Object, bZ8 = Object.prototype.hasOwnProperty, W3 = (A, Q) => EdA(A, "name", {
    value: Q,
    configurable: !0
  }), fZ8 = (A, Q) => {
    for (var B in Q) EdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, hZ8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of vZ8(Q))
        if (!bZ8.call(A, Z) && Z !== B) EdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = xZ8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, gZ8 = (A) => hZ8(EdA({}, "__esModule", {
    value: !0
  }), A), xjQ = {};
  fZ8(xjQ, {
    AwsEc2QueryProtocol: () => HI8,
    AwsJson1_0Protocol: () => eZ8,
    AwsJson1_1Protocol: () => AI8,
    AwsJsonRpcProtocol: () => rT1,
    AwsQueryProtocol: () => gjQ,
    AwsRestJsonProtocol: () => BI8,
    AwsRestXmlProtocol: () => wI8,
    JsonCodec: () => sT1,
    JsonShapeDeserializer: () => fjQ,
    JsonShapeSerializer: () => hjQ,
    XmlCodec: () => cjQ,
    XmlShapeDeserializer: () => oT1,
    XmlShapeSerializer: () => djQ,
    _toBool: () => mZ8,
    _toNum: () => dZ8,
    _toStr: () => uZ8,
    awsExpectUnion: () => ZI8,
    loadRestJsonErrorCode: () => aT1,
    loadRestXmlErrorCode: () => mjQ,
    parseJsonBody: () => nT1,
    parseJsonErrorBody: () => aZ8,
    parseXmlBody: () => ujQ,
    parseXmlErrorBody: () => UI8
  });
  pjQ.exports = gZ8(xjQ);
  var uZ8 = W3((A) => {
      if (A == null) return A;
      if (typeof A === "number" || typeof A === "bigint") {
        let Q = Error(`Received number ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      if (typeof A === "boolean") {
        let Q = Error(`Received boolean ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      return A
    }, "_toStr"),
    mZ8 = W3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (A !== "" && Q !== "false" && Q !== "true") {
          let B = Error(`Received string "${A}" where a boolean was expected.`);
          B.name = "Warning", console.warn(B)
        }
        return A !== "" && Q !== "false"
      }
      return A
    }, "_toBool"),
    dZ8 = W3((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = Number(A);
        if (Q.toString() !== A) {
          let B = Error(`Received string "${A}" where a number was expected.`);
          return B.name = "Warning", console.warn(B), A
        }
        return Q
      }
      return A
    }, "_toNum"),
    cZ8 = w5(),
    S6A = b4(),
    pZ8 = oK(),
    Uo = class {
      static {
        W3(this, "SerdeContextConfig")
      }
      serdeContext;
      setSerdeContext(A) {
        this.serdeContext = A
      }
    },
    $CA = b4(),
    _6A = s6(),
    lZ8 = ld(),
    iZ8 = s6();

  function vjQ(A, Q, B) {
    if (B?.source) {
      let G = B.source;
      if (typeof Q === "number") {
        if (Q > Number.MAX_SAFE_INTEGER || Q < Number.MIN_SAFE_INTEGER || G !== String(Q))
          if (G.includes(".")) return new iZ8.NumericValue(G, "bigDecimal");
          else return BigInt(G)
      }
    }
    return Q
  }
  W3(vjQ, "jsonReviver");
  var nZ8 = o6(),
    bjQ = W3((A, Q) => (0, nZ8.collectBody)(A, Q).then((B) => Q.utf8Encoder(B)), "collectBodyString"),
    nT1 = W3((A, Q) => bjQ(A, Q).then((B) => {
      if (B.length) try {
        return JSON.parse(B)
      } catch (G) {
        if (G?.name === "SyntaxError") Object.defineProperty(G, "$responseBodyText", {
          value: B
        });
        throw G
      }
      return {}
    }), "parseJsonBody"),
    aZ8 = W3(async (A, Q) => {
      let B = await nT1(A, Q);
      return B.message = B.message ?? B.Message, B
    }, "parseJsonErrorBody"),
    aT1 = W3((A, Q) => {
      let B = W3((I, Y) => Object.keys(I).find((J) => J.toLowerCase() === Y.toLowerCase()), "findKey"),
        G = W3((I) => {
          let Y = I;
          if (typeof Y === "number") Y = Y.toString();
          if (Y.indexOf(",") >= 0) Y = Y.split(",")[0];
          if (Y.indexOf(":") >= 0) Y = Y.split(":")[0];
          if (Y.indexOf("#") >= 0) Y = Y.split("#")[1];
          return Y
        }, "sanitizeErrorCode"),
        Z = B(A.headers, "x-amzn-errortype");
      if (Z !== void 0) return G(A.headers[Z]);
      if (Q && typeof Q === "object") {
        let I = B(Q, "code");
        if (I && Q[I] !== void 0) return G(Q[I]);
        if (Q.__type !== void 0) return G(Q.__type)
      }
    }, "loadRestJsonErrorCode"),
    fjQ = class extends Uo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        W3(this, "JsonShapeDeserializer")
      }
      async read(A, Q) {
        return this._read(A, typeof Q === "string" ? JSON.parse(Q, vjQ) : await nT1(Q, this.serdeContext))
      }
      readObject(A, Q) {
        return this._read(A, Q)
      }
      _read(A, Q) {
        let B = Q !== null && typeof Q === "object",
          G = $CA.NormalizedSchema.of(A);
        if (G.isListSchema() && Array.isArray(Q)) {
          let I = G.getValueSchema(),
            Y = [],
            J = !!G.getMergedTraits().sparse;
          for (let W of Q)
            if (J || W != null) Y.push(this._read(I, W));
          return Y
        } else if (G.isMapSchema() && B) {
          let I = G.getValueSchema(),
            Y = {},
            J = !!G.getMergedTraits().sparse;
          for (let [W, X] of Object.entries(Q))
            if (J || X != null) Y[W] = this._read(I, X);
          return Y
        } else if (G.isStructSchema() && B) {
          let I = {};
          for (let [Y, J] of G.structIterator()) {
            let W = this.settings.jsonName ? J.getMergedTraits().jsonName ?? Y : Y,
              X = this._read(J, Q[W]);
            if (X != null) I[Y] = X
          }
          return I
        }
        if (G.isBlobSchema() && typeof Q === "string") return (0, lZ8.fromBase64)(Q);
        let Z = G.getMergedTraits().mediaType;
        if (G.isStringSchema() && typeof Q === "string" && Z) {
          if (Z === "application/json" || Z.endsWith("+json")) return _6A.LazyJsonString.from(Q)
        }
        if (G.isTimestampSchema()) {
          let I = this.settings.timestampFormat;
          switch (I.useTrait ? G.getSchema() === $CA.SCHEMA.TIMESTAMP_DEFAULT ? I.default : G.getSchema() ?? I.default : I.default) {
            case $CA.SCHEMA.TIMESTAMP_DATE_TIME:
              return (0, _6A.parseRfc3339DateTimeWithOffset)(Q);
            case $CA.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, _6A.parseRfc7231DateTime)(Q);
            case $CA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return (0, _6A.parseEpochTimestamp)(Q);
            default:
              return console.warn("Missing timestamp format, parsing value with Date constructor:", Q), new Date(Q)
          }
        }
        if (G.isBigIntegerSchema() && (typeof Q === "number" || typeof Q === "string")) return BigInt(Q);
        if (G.isBigDecimalSchema() && Q != null) {
          if (Q instanceof _6A.NumericValue) return Q;
          return new _6A.NumericValue(String(Q), "bigDecimal")
        }
        if (G.isNumericSchema() && typeof Q === "string") switch (Q) {
          case "Infinity":
            return 1 / 0;
          case "-Infinity":
            return -1 / 0;
          case "NaN":
            return NaN
        }
        return Q
      }
    },
    k6A = b4(),
    sZ8 = s6(),
    rZ8 = s6(),
    oZ8 = s6(),
    SjQ = String.fromCharCode(925),
    tZ8 = class {
      static {
        W3(this, "JsonReplacer")
      }
      values = new Map;
      counter = 0;
      stage = 0;
      createReplacer() {
        if (this.stage === 1) throw Error("@aws-sdk/core/protocols - JsonReplacer already created.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        return this.stage = 1, (A, Q) => {
          if (Q instanceof oZ8.NumericValue) {
            let B = `${SjQ+NaN+this.counter++}_` + Q.string;
            return this.values.set(`"${B}"`, Q.string), B
          }
          if (typeof Q === "bigint") {
            let B = Q.toString(),
              G = `${SjQ+"b"+this.counter++}_` + B;
            return this.values.set(`"${G}"`, B), G
          }
          return Q
        }
      }
      replaceInJson(A) {
        if (this.stage === 0) throw Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
        if (this.stage === 2) throw Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        if (this.stage = 2, this.counter === 0) return A;
        for (let [Q, B] of this.values) A = A.replace(Q, B);
        return A
      }
    },
    hjQ = class extends Uo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        W3(this, "JsonShapeSerializer")
      }
      buffer;
      rootSchema;
      write(A, Q) {
        this.rootSchema = k6A.NormalizedSchema.of(A), this.buffer = this._write(this.rootSchema, Q)
      }
      flush() {
        if (this.rootSchema?.isStructSchema() || this.rootSchema?.isDocumentSchema()) {
          let A = new tZ8;
          return A.replaceInJson(JSON.stringify(this.buffer, A.createReplacer(), 0))
        }
        return this.buffer
      }
      _write(A, Q, B) {
        let G = Q !== null && typeof Q === "object",
          Z = k6A.NormalizedSchema.of(A);
        if (Z.isListSchema() && Array.isArray(Q)) {
          let Y = Z.getValueSchema(),
            J = [],
            W = !!Z.getMergedTraits().sparse;
          for (let X of Q)
            if (W || X != null) J.push(this._write(Y, X));
          return J
        } else if (Z.isMapSchema() && G) {
          let Y = Z.getValueSchema(),
            J = {},
            W = !!Z.getMergedTraits().sparse;
          for (let [X, V] of Object.entries(Q))
            if (W || V != null) J[X] = this._write(Y, V);
          return J
        } else if (Z.isStructSchema() && G) {
          let Y = {};
          for (let [J, W] of Z.structIterator()) {
            let X = this.settings.jsonName ? W.getMergedTraits().jsonName ?? J : J,
              V = this._write(W, Q[J], Z);
            if (V !== void 0) Y[X] = V
          }
          return Y
        }
        if (Q === null && B?.isStructSchema()) return;
        if (Z.isBlobSchema() && (Q instanceof Uint8Array || typeof Q === "string")) {
          if (Z === this.rootSchema) return Q;
          if (!this.serdeContext?.base64Encoder) throw Error("Missing base64Encoder in serdeContext");
          return this.serdeContext?.base64Encoder(Q)
        }
        if (Z.isTimestampSchema() && Q instanceof Date) {
          let Y = this.settings.timestampFormat;
          switch (Y.useTrait ? Z.getSchema() === k6A.SCHEMA.TIMESTAMP_DEFAULT ? Y.default : Z.getSchema() ?? Y.default : Y.default) {
            case k6A.SCHEMA.TIMESTAMP_DATE_TIME:
              return Q.toISOString().replace(".000Z", "Z");
            case k6A.SCHEMA.TIMESTAMP_HTTP_DATE:
              return (0, sZ8.dateToUtcString)(Q);
            case k6A.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              return Q.getTime() / 1000;
            default:
              return console.warn("Missing timestamp format, using epoch seconds", Q), Q.getTime() / 1000
          }
        }
        if (Z.isNumericSchema() && typeof Q === "number") {
          if (Math.abs(Q) === 1 / 0 || isNaN(Q)) return String(Q)
        }
        let I = Z.getMergedTraits().mediaType;
        if (Z.isStringSchema() && typeof Q === "string" && I) {
          if (I === "application/json" || I.endsWith("+json")) return rZ8.LazyJsonString.from(Q)
        }
        return Q
      }
    },
    sT1 = class extends Uo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        W3(this, "JsonCodec")
      }
      createSerializer() {
        let A = new hjQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new fjQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    rT1 = class extends cZ8.RpcProtocol {
      static {
        W3(this, "AwsJsonRpcProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        this.codec = new sT1({
          timestampFormat: {
            useTrait: !0,
            default: S6A.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          jsonName: !1
        }), this.serializer = this.codec.createSerializer(), this.deserializer = this.codec.createDeserializer()
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
            "x-amz-target": (this.getJsonRpcVersion() === "1.0" ? "JsonRpc10." : "JsonProtocol.") + S6A.NormalizedSchema.of(A).getName()
          }), (0, S6A.deref)(A.input) === "unit" || !G.body) G.body = "{}";
        try {
          G.headers["content-length"] = String((0, pZ8.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      getPayloadCodec() {
        return this.codec
      }
      async handleError(A, Q, B, G, Z) {
        let I = aT1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = S6A.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = S6A.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = S6A.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    eZ8 = class extends rT1 {
      static {
        W3(this, "AwsJson1_0Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_0"
      }
      getJsonRpcVersion() {
        return "1.0"
      }
    },
    AI8 = class extends rT1 {
      static {
        W3(this, "AwsJson1_1Protocol")
      }
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        })
      }
      getShapeId() {
        return "aws.protocols#awsJson1_1"
      }
      getJsonRpcVersion() {
        return "1.1"
      }
    },
    cT1 = w5(),
    wCA = b4(),
    QI8 = oK(),
    BI8 = class extends cT1.HttpBindingProtocol {
      static {
        W3(this, "AwsRestJsonProtocol")
      }
      serializer;
      deserializer;
      codec;
      constructor({
        defaultNamespace: A
      }) {
        super({
          defaultNamespace: A
        });
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: wCA.SCHEMA.TIMESTAMP_EPOCH_SECONDS
          },
          httpBindings: !0,
          jsonName: !0
        };
        this.codec = new sT1(Q), this.serializer = new cT1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new cT1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getShapeId() {
        return "aws.protocols#restJson1"
      }
      getPayloadCodec() {
        return this.codec
      }
      setSerdeContext(A) {
        this.codec.setSerdeContext(A), super.setSerdeContext(A)
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = wCA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (!G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/json"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/json"
          }
        }
        if (G.headers["content-type"] && !G.body) G.body = "{}";
        if (G.body) try {
          G.headers["content-length"] = String((0, QI8.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async handleError(A, Q, B, G, Z) {
        let I = aT1(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = wCA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = wCA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = wCA.NormalizedSchema.of(X),
          F = G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().jsonName ?? H;
          D[H] = this.codec.createDeserializer().readObject(C, G[E])
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    },
    GI8 = o6(),
    ZI8 = W3((A) => {
      if (A == null) return;
      if (typeof A === "object" && "__type" in A) delete A.__type;
      return (0, GI8.expectUnion)(A)
    }, "awsExpectUnion"),
    pT1 = w5(),
    id = b4(),
    II8 = oK(),
    YI8 = w5(),
    _jQ = b4(),
    JI8 = o6(),
    WI8 = O2(),
    XI8 = wS(),
    oT1 = class extends Uo {
      constructor(A) {
        super();
        this.settings = A, this.stringDeserializer = new YI8.FromStringShapeDeserializer(A)
      }
      static {
        W3(this, "XmlShapeDeserializer")
      }
      stringDeserializer;
      setSerdeContext(A) {
        this.serdeContext = A, this.stringDeserializer.setSerdeContext(A)
      }
      read(A, Q, B) {
        let G = _jQ.NormalizedSchema.of(A),
          Z = G.getMemberSchemas();
        if (G.isStructSchema() && G.isMemberSchema() && !!Object.values(Z).find((W) => {
            return !!W.getMemberTraits().eventPayload
          })) {
          let W = {},
            X = Object.keys(Z)[0];
          if (Z[X].isBlobSchema()) W[X] = Q;
          else W[X] = this.read(Z[X], Q);
          return W
        }
        let Y = (this.serdeContext?.utf8Encoder ?? WI8.toUtf8)(Q),
          J = this.parseXml(Y);
        return this.readSchema(A, B ? J[B] : J)
      }
      readSchema(A, Q) {
        let B = _jQ.NormalizedSchema.of(A),
          G = B.getMergedTraits(),
          Z = B.getSchema();
        if (B.isListSchema() && !Array.isArray(Q)) return this.readSchema(Z, [Q]);
        if (Q == null) return Q;
        if (typeof Q === "object") {
          let I = !!G.sparse,
            Y = !!G.xmlFlattened;
          if (B.isListSchema()) {
            let W = B.getValueSchema(),
              X = [],
              V = W.getMergedTraits().xmlName ?? "member",
              F = Y ? Q : (Q[0] ?? Q)[V],
              K = Array.isArray(F) ? F : [F];
            for (let D of K)
              if (D != null || I) X.push(this.readSchema(W, D));
            return X
          }
          let J = {};
          if (B.isMapSchema()) {
            let W = B.getKeySchema(),
              X = B.getValueSchema(),
              V;
            if (Y) V = Array.isArray(Q) ? Q : [Q];
            else V = Array.isArray(Q.entry) ? Q.entry : [Q.entry];
            let F = W.getMergedTraits().xmlName ?? "key",
              K = X.getMergedTraits().xmlName ?? "value";
            for (let D of V) {
              let H = D[F],
                C = D[K];
              if (C != null || I) J[H] = this.readSchema(X, C)
            }
            return J
          }
          if (B.isStructSchema()) {
            for (let [W, X] of B.structIterator()) {
              let V = X.getMergedTraits(),
                F = !V.httpPayload ? X.getMemberTraits().xmlName ?? W : V.xmlName ?? X.getName();
              if (Q[F] != null) J[W] = this.readSchema(X, Q[F])
            }
            return J
          }
          if (B.isDocumentSchema()) return Q;
          throw Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${B.getName(!0)}`)
        } else {
          if (B.isListSchema()) return [];
          else if (B.isMapSchema() || B.isStructSchema()) return {};
          return this.stringDeserializer.read(B, Q)
        }
      }
      parseXml(A) {
        if (A.length) {
          let Q = new XI8.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: W3((Y, J) => J.trim() === "" && J.includes(`
`) ? "" : void 0, "tagValueProcessor")
          });
          Q.addEntity("#xD", "\r"), Q.addEntity("#10", `
`);
          let B;
          try {
            B = Q.parse(A, !0)
          } catch (Y) {
            if (Y && typeof Y === "object") Object.defineProperty(Y, "$responseBodyText", {
              value: A
            });
            throw Y
          }
          let G = "#text",
            Z = Object.keys(B)[0],
            I = B[Z];
          if (I[G]) I[Z] = I[G], delete I[G];
          return (0, JI8.getValueFromTextNode)(I)
        }
        return {}
      }
    },
    lT1 = w5(),
    CdA = b4(),
    VI8 = s6(),
    FI8 = o6(),
    KI8 = ld(),
    DI8 = class extends Uo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        W3(this, "QueryShapeSerializer")
      }
      buffer;
      write(A, Q, B = "") {
        if (this.buffer === void 0) this.buffer = "";
        let G = CdA.NormalizedSchema.of(A);
        if (B && !B.endsWith(".")) B += ".";
        if (G.isBlobSchema()) {
          if (typeof Q === "string" || Q instanceof Uint8Array) this.writeKey(B), this.writeValue((this.serdeContext?.base64Encoder ?? KI8.toBase64)(Q))
        } else if (G.isBooleanSchema() || G.isNumericSchema() || G.isStringSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigIntegerSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(String(Q))
        } else if (G.isBigDecimalSchema()) {
          if (Q != null) this.writeKey(B), this.writeValue(Q instanceof VI8.NumericValue ? Q.string : String(Q))
        } else if (G.isTimestampSchema()) {
          if (Q instanceof Date) switch (this.writeKey(B), (0, lT1.determineTimestampFormat)(G, this.settings)) {
            case CdA.SCHEMA.TIMESTAMP_DATE_TIME:
              this.writeValue(Q.toISOString().replace(".000Z", "Z"));
              break;
            case CdA.SCHEMA.TIMESTAMP_HTTP_DATE:
              this.writeValue((0, FI8.dateToUtcString)(Q));
              break;
            case CdA.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              this.writeValue(String(Q.getTime() / 1000));
              break
          }
        } else if (G.isDocumentSchema()) throw Error(`@aws-sdk/core/protocols - QuerySerializer unsupported document type ${G.getName(!0)}`);
        else if (G.isListSchema()) {
          if (Array.isArray(Q))
            if (Q.length === 0) {
              if (this.settings.serializeEmptyLists) this.writeKey(B), this.writeValue("")
            } else {
              let Z = G.getValueSchema(),
                I = this.settings.flattenLists || G.getMergedTraits().xmlFlattened,
                Y = 1;
              for (let J of Q) {
                if (J == null) continue;
                let W = this.getKey("member", Z.getMergedTraits().xmlName),
                  X = I ? `${B}${Y}` : `${B}${W}.${Y}`;
                this.write(Z, J, X), ++Y
              }
            }
        } else if (G.isMapSchema()) {
          if (Q && typeof Q === "object") {
            let Z = G.getKeySchema(),
              I = G.getValueSchema(),
              Y = G.getMergedTraits().xmlFlattened,
              J = 1;
            for (let [W, X] of Object.entries(Q)) {
              if (X == null) continue;
              let V = this.getKey("key", Z.getMergedTraits().xmlName),
                F = Y ? `${B}${J}.${V}` : `${B}entry.${J}.${V}`,
                K = this.getKey("value", I.getMergedTraits().xmlName),
                D = Y ? `${B}${J}.${K}` : `${B}entry.${J}.${K}`;
              this.write(Z, W, F), this.write(I, X, D), ++J
            }
          }
        } else if (G.isStructSchema()) {
          if (Q && typeof Q === "object")
            for (let [Z, I] of G.structIterator()) {
              if (Q[Z] == null) continue;
              let Y = this.getKey(Z, I.getMergedTraits().xmlName),
                J = `${B}${Y}`;
              this.write(I, Q[Z], J)
            }
        } else if (G.isUnitSchema());
        else throw Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${G.getName(!0)}`)
      }
      flush() {
        if (this.buffer === void 0) throw Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
        let A = this.buffer;
        return delete this.buffer, A
      }
      getKey(A, Q) {
        let B = Q ?? A;
        if (this.settings.capitalizeKeys) return B[0].toUpperCase() + B.slice(1);
        return B
      }
      writeKey(A) {
        if (A.endsWith(".")) A = A.slice(0, A.length - 1);
        this.buffer += `&${(0,lT1.extendedEncodeURIComponent)(A)}=`
      }
      writeValue(A) {
        this.buffer += (0, lT1.extendedEncodeURIComponent)(A)
      }
    },
    gjQ = class extends pT1.RpcProtocol {
      constructor(A) {
        super({
          defaultNamespace: A.defaultNamespace
        });
        this.options = A;
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: id.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !1,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace,
          serializeEmptyLists: !0
        };
        this.serializer = new DI8(Q), this.deserializer = new oT1(Q)
      }
      static {
        W3(this, "AwsQueryProtocol")
      }
      serializer;
      deserializer;
      getShapeId() {
        return "aws.protocols#awsQuery"
      }
      setSerdeContext(A) {
        this.serializer.setSerdeContext(A), this.deserializer.setSerdeContext(A)
      }
      getPayloadCodec() {
        throw Error("AWSQuery protocol has no payload codec.")
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B);
        if (!G.path.endsWith("/")) G.path += "/";
        if (Object.assign(G.headers, {
            "content-type": "application/x-www-form-urlencoded"
          }), (0, id.deref)(A.input) === "unit" || !G.body) G.body = "";
        if (G.body = `Action=${A.name.split("#")[1]}&Version=${this.options.version}` + G.body, G.body.endsWith("&")) G.body = G.body.slice(-1);
        try {
          G.headers["content-length"] = String((0, II8.calculateBodyLength)(G.body))
        } catch (Z) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        let G = this.deserializer,
          Z = id.NormalizedSchema.of(A.output),
          I = {};
        if (B.statusCode >= 300) {
          let X = await (0, pT1.collectBody)(B.body, Q);
          if (X.byteLength > 0) Object.assign(I, await G.read(id.SCHEMA.DOCUMENT, X));
          await this.handleError(A, Q, B, I, this.deserializeMetadata(B))
        }
        for (let X in B.headers) {
          let V = B.headers[X];
          delete B.headers[X], B.headers[X.toLowerCase()] = V
        }
        let Y = Z.isStructSchema() && this.useNestedResult() ? A.name.split("#")[1] + "Result" : void 0,
          J = await (0, pT1.collectBody)(B.body, Q);
        if (J.byteLength > 0) Object.assign(I, await G.read(Z, J, Y));
        return {
          $metadata: this.deserializeMetadata(B),
          ...I
        }
      }
      useNestedResult() {
        return !0
      }
      async handleError(A, Q, B, G, Z) {
        let I = this.loadQueryErrorCode(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = this.loadQueryError(G),
          X = id.TypeRegistry.for(Y),
          V;
        try {
          if (V = X.find((C) => id.NormalizedSchema.of(C).getMergedTraits().awsQueryError?.[0] === J), !V) V = X.getSchema(I)
        } catch (C) {
          let E = id.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (E) {
            let U = E.ctor;
            throw Object.assign(new U(J), W)
          }
          throw Error(J)
        }
        let F = id.NormalizedSchema.of(V),
          K = this.loadQueryErrorMessage(G),
          D = new V.ctor(K),
          H = {};
        for (let [C, E] of F.structIterator()) {
          let U = E.getMergedTraits().xmlName ?? C,
            q = W[U] ?? G[U];
          H[C] = this.deserializer.readSchema(E, q)
        }
        throw Object.assign(D, {
          $metadata: Z,
          $response: B,
          $fault: F.getMergedTraits().error,
          message: K,
          ...H
        }), D
      }
      loadQueryErrorCode(A, Q) {
        let B = (Q.Errors?.[0]?.Error ?? Q.Errors?.Error ?? Q.Error)?.Code;
        if (B !== void 0) return B;
        if (A.statusCode == 404) return "NotFound"
      }
      loadQueryError(A) {
        return A.Errors?.[0]?.Error ?? A.Errors?.Error ?? A.Error
      }
      loadQueryErrorMessage(A) {
        let Q = this.loadQueryError(A);
        return Q?.message ?? Q?.Message ?? A.message ?? A.Message ?? "Unknown"
      }
    },
    HI8 = class extends gjQ {
      constructor(A) {
        super(A);
        this.options = A;
        let Q = {
          capitalizeKeys: !0,
          flattenLists: !0,
          serializeEmptyLists: !1
        };
        Object.assign(this.serializer.settings, Q)
      }
      static {
        W3(this, "AwsEc2QueryProtocol")
      }
      useNestedResult() {
        return !1
      }
    },
    iT1 = w5(),
    qCA = b4(),
    CI8 = oK(),
    EI8 = o6(),
    zI8 = wS(),
    ujQ = W3((A, Q) => bjQ(A, Q).then((B) => {
      if (B.length) {
        let G = new zI8.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: !0,
          ignoreAttributes: !1,
          ignoreDeclaration: !0,
          parseTagValue: !1,
          trimValues: !1,
          tagValueProcessor: W3((W, X) => X.trim() === "" && X.includes(`
`) ? "" : void 0, "tagValueProcessor")
        });
        G.addEntity("#xD", "\r"), G.addEntity("#10", `
`);
        let Z;
        try {
          Z = G.parse(B, !0)
        } catch (W) {
          if (W && typeof W === "object") Object.defineProperty(W, "$responseBodyText", {
            value: B
          });
          throw W
        }
        let I = "#text",
          Y = Object.keys(Z)[0],
          J = Z[Y];
        if (J[I]) J[Y] = J[I], delete J[I];
        return (0, EI8.getValueFromTextNode)(J)
      }
      return {}
    }), "parseXmlBody"),
    UI8 = W3(async (A, Q) => {
      let B = await ujQ(A, Q);
      if (B.Error) B.Error.message = B.Error.message ?? B.Error.Message;
      return B
    }, "parseXmlErrorBody"),
    mjQ = W3((A, Q) => {
      if (Q?.Error?.Code !== void 0) return Q.Error.Code;
      if (Q?.Code !== void 0) return Q.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadRestXmlErrorCode"),
    dS = rDA(),
    zo = b4(),
    $I8 = s6(),
    kjQ = o6(),
    yjQ = ld(),
    djQ = class extends Uo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        W3(this, "XmlShapeSerializer")
      }
      stringBuffer;
      byteBuffer;
      buffer;
      write(A, Q) {
        let B = zo.NormalizedSchema.of(A);
        if (B.isStringSchema() && typeof Q === "string") this.stringBuffer = Q;
        else if (B.isBlobSchema()) this.byteBuffer = "byteLength" in Q ? Q : (this.serdeContext?.base64Decoder ?? yjQ.fromBase64)(Q);
        else {
          this.buffer = this.writeStruct(B, Q, void 0);
          let G = B.getMergedTraits();
          if (G.httpPayload && !G.xmlName) this.buffer.withName(B.getName())
        }
      }
      flush() {
        if (this.byteBuffer !== void 0) {
          let Q = this.byteBuffer;
          return delete this.byteBuffer, Q
        }
        if (this.stringBuffer !== void 0) {
          let Q = this.stringBuffer;
          return delete this.stringBuffer, Q
        }
        let A = this.buffer;
        if (this.settings.xmlNamespace) {
          if (!A?.attributes?.xmlns) A.addAttribute("xmlns", this.settings.xmlNamespace)
        }
        return delete this.buffer, A.toString()
      }
      writeStruct(A, Q, B) {
        let G = A.getMergedTraits(),
          Z = A.isMemberSchema() && !G.httpPayload ? A.getMemberTraits().xmlName ?? A.getMemberName() : G.xmlName ?? A.getName();
        if (!Z || !A.isStructSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${A.getName(!0)}.`);
        let I = dS.XmlNode.of(Z),
          [Y, J] = this.getXmlnsAttribute(A, B);
        if (J) I.addAttribute(Y, J);
        for (let [W, X] of A.structIterator()) {
          let V = Q[W];
          if (V != null) {
            if (X.getMergedTraits().xmlAttribute) {
              I.addAttribute(X.getMergedTraits().xmlName ?? W, this.writeSimple(X, V));
              continue
            }
            if (X.isListSchema()) this.writeList(X, V, I, J);
            else if (X.isMapSchema()) this.writeMap(X, V, I, J);
            else if (X.isStructSchema()) I.addChildNode(this.writeStruct(X, V, J));
            else {
              let F = dS.XmlNode.of(X.getMergedTraits().xmlName ?? X.getMemberName());
              this.writeSimpleInto(X, V, F, J), I.addChildNode(F)
            }
          }
        }
        return I
      }
      writeList(A, Q, B, G) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${A.getName(!0)}`);
        let Z = A.getMergedTraits(),
          I = A.getValueSchema(),
          Y = I.getMergedTraits(),
          J = !!Y.sparse,
          W = !!Z.xmlFlattened,
          [X, V] = this.getXmlnsAttribute(A, G),
          F = W3((K, D) => {
            if (I.isListSchema()) this.writeList(I, Array.isArray(D) ? D : [D], K, V);
            else if (I.isMapSchema()) this.writeMap(I, D, K, V);
            else if (I.isStructSchema()) {
              let H = this.writeStruct(I, D, V);
              K.addChildNode(H.withName(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member"))
            } else {
              let H = dS.XmlNode.of(W ? Z.xmlName ?? A.getMemberName() : Y.xmlName ?? "member");
              this.writeSimpleInto(I, D, H, V), K.addChildNode(H)
            }
          }, "writeItem");
        if (W) {
          for (let K of Q)
            if (J || K != null) F(B, K)
        } else {
          let K = dS.XmlNode.of(Z.xmlName ?? A.getMemberName());
          if (V) K.addAttribute(X, V);
          for (let D of Q)
            if (J || D != null) F(K, D);
          B.addChildNode(K)
        }
      }
      writeMap(A, Q, B, G, Z = !1) {
        if (!A.isMemberSchema()) throw Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${A.getName(!0)}`);
        let I = A.getMergedTraits(),
          Y = A.getKeySchema(),
          W = Y.getMergedTraits().xmlName ?? "key",
          X = A.getValueSchema(),
          V = X.getMergedTraits(),
          F = V.xmlName ?? "value",
          K = !!V.sparse,
          D = !!I.xmlFlattened,
          [H, C] = this.getXmlnsAttribute(A, G),
          E = W3((U, q, w) => {
            let N = dS.XmlNode.of(W, q),
              [R, T] = this.getXmlnsAttribute(Y, C);
            if (T) N.addAttribute(R, T);
            U.addChildNode(N);
            let y = dS.XmlNode.of(F);
            if (X.isListSchema()) this.writeList(X, w, y, C);
            else if (X.isMapSchema()) this.writeMap(X, w, y, C, !0);
            else if (X.isStructSchema()) y = this.writeStruct(X, w, C);
            else this.writeSimpleInto(X, w, y, C);
            U.addChildNode(y)
          }, "addKeyValue");
        if (D) {
          for (let [U, q] of Object.entries(Q))
            if (K || q != null) {
              let w = dS.XmlNode.of(I.xmlName ?? A.getMemberName());
              E(w, U, q), B.addChildNode(w)
            }
        } else {
          let U;
          if (!Z) {
            if (U = dS.XmlNode.of(I.xmlName ?? A.getMemberName()), C) U.addAttribute(H, C);
            B.addChildNode(U)
          }
          for (let [q, w] of Object.entries(Q))
            if (K || w != null) {
              let N = dS.XmlNode.of("entry");
              E(N, q, w), (Z ? B : U).addChildNode(N)
            }
        }
      }
      writeSimple(A, Q) {
        if (Q === null) throw Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
        let B = zo.NormalizedSchema.of(A),
          G = null;
        if (Q && typeof Q === "object")
          if (B.isBlobSchema()) G = (this.serdeContext?.base64Encoder ?? yjQ.toBase64)(Q);
          else if (B.isTimestampSchema() && Q instanceof Date) {
          let Z = this.settings.timestampFormat;
          switch (Z.useTrait ? B.getSchema() === zo.SCHEMA.TIMESTAMP_DEFAULT ? Z.default : B.getSchema() ?? Z.default : Z.default) {
            case zo.SCHEMA.TIMESTAMP_DATE_TIME:
              G = Q.toISOString().replace(".000Z", "Z");
              break;
            case zo.SCHEMA.TIMESTAMP_HTTP_DATE:
              G = (0, kjQ.dateToUtcString)(Q);
              break;
            case zo.SCHEMA.TIMESTAMP_EPOCH_SECONDS:
              G = String(Q.getTime() / 1000);
              break;
            default:
              console.warn("Missing timestamp format, using http date", Q), G = (0, kjQ.dateToUtcString)(Q);
              break
          }
        } else if (B.isBigDecimalSchema() && Q) {
          if (Q instanceof $I8.NumericValue) return Q.string;
          return String(Q)
        } else if (B.isMapSchema() || B.isListSchema()) throw Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
        else throw Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${B.getName(!0)}`);
        if (B.isStringSchema() || B.isBooleanSchema() || B.isNumericSchema() || B.isBigIntegerSchema() || B.isBigDecimalSchema()) G = String(Q);
        if (G === null) throw Error(`Unhandled schema-value pair ${B.getName(!0)}=${Q}`);
        return G
      }
      writeSimpleInto(A, Q, B, G) {
        let Z = this.writeSimple(A, Q),
          I = zo.NormalizedSchema.of(A),
          Y = new dS.XmlText(Z),
          [J, W] = this.getXmlnsAttribute(I, G);
        if (W) B.addAttribute(J, W);
        B.addChildNode(Y)
      }
      getXmlnsAttribute(A, Q) {
        let B = A.getMergedTraits(),
          [G, Z] = B.xmlNamespace ?? [];
        if (Z && Z !== Q) return [G ? `xmlns:${G}` : "xmlns", Z];
        return [void 0, void 0]
      }
    },
    cjQ = class extends Uo {
      constructor(A) {
        super();
        this.settings = A
      }
      static {
        W3(this, "XmlCodec")
      }
      createSerializer() {
        let A = new djQ(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
      createDeserializer() {
        let A = new oT1(this.settings);
        return A.setSerdeContext(this.serdeContext), A
      }
    },
    wI8 = class extends iT1.HttpBindingProtocol {
      static {
        W3(this, "AwsRestXmlProtocol")
      }
      codec;
      serializer;
      deserializer;
      constructor(A) {
        super(A);
        let Q = {
          timestampFormat: {
            useTrait: !0,
            default: qCA.SCHEMA.TIMESTAMP_DATE_TIME
          },
          httpBindings: !0,
          xmlNamespace: A.xmlNamespace,
          serviceNamespace: A.defaultNamespace
        };
        this.codec = new cjQ(Q), this.serializer = new iT1.HttpInterceptingShapeSerializer(this.codec.createSerializer(), Q), this.deserializer = new iT1.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), Q)
      }
      getPayloadCodec() {
        return this.codec
      }
      getShapeId() {
        return "aws.protocols#restXml"
      }
      async serializeRequest(A, Q, B) {
        let G = await super.serializeRequest(A, Q, B),
          Z = qCA.NormalizedSchema.of(A.input),
          I = Z.getMemberSchemas();
        if (G.path = String(G.path).split("/").filter((Y) => {
            return Y !== "{Bucket}"
          }).join("/") || "/", !G.headers["content-type"]) {
          let Y = Object.values(I).find((J) => {
            return !!J.getMergedTraits().httpPayload
          });
          if (Y) {
            let J = Y.getMergedTraits().mediaType;
            if (J) G.headers["content-type"] = J;
            else if (Y.isStringSchema()) G.headers["content-type"] = "text/plain";
            else if (Y.isBlobSchema()) G.headers["content-type"] = "application/octet-stream";
            else G.headers["content-type"] = "application/xml"
          } else if (!Z.isUnitSchema()) {
            if (Object.values(I).find((W) => {
                let {
                  httpQuery: X,
                  httpQueryParams: V,
                  httpHeader: F,
                  httpLabel: K,
                  httpPrefixHeaders: D
                } = W.getMergedTraits();
                return !X && !V && !F && !K && D === void 0
              })) G.headers["content-type"] = "application/xml"
          }
        }
        if (G.headers["content-type"] === "application/xml") {
          if (typeof G.body === "string") G.body = '<?xml version="1.0" encoding="UTF-8"?>' + G.body
        }
        if (G.body) try {
          G.headers["content-length"] = String((0, CI8.calculateBodyLength)(G.body))
        } catch (Y) {}
        return G
      }
      async deserializeResponse(A, Q, B) {
        return super.deserializeResponse(A, Q, B)
      }
      async handleError(A, Q, B, G, Z) {
        let I = mjQ(B, G) ?? "Unknown",
          Y = this.options.defaultNamespace,
          J = I;
        if (I.includes("#"))[Y, J] = I.split("#");
        let W = qCA.TypeRegistry.for(Y),
          X;
        try {
          X = W.getSchema(I)
        } catch (H) {
          let C = qCA.TypeRegistry.for("smithy.ts.sdk.synthetic." + Y).getBaseException();
          if (C) {
            let E = C.ctor;
            throw Object.assign(new E(J), G)
          }
          throw Error(J)
        }
        let V = qCA.NormalizedSchema.of(X),
          F = G.Error?.message ?? G.Error?.Message ?? G.message ?? G.Message ?? "Unknown",
          K = new X.ctor(F);
        await this.deserializeHttpMessage(X, Q, B, G);
        let D = {};
        for (let [H, C] of V.structIterator()) {
          let E = C.getMergedTraits().xmlName ?? H,
            U = G.Error?.[E] ?? G[E];
          D[H] = this.codec.createDeserializer().readSchema(C, U)
        }
        throw Object.assign(K, {
          $metadata: Z,
          $response: B,
          $fault: V.getMergedTraits().error,
          message: F,
          ...D
        }), K
      }
    }
})
// @from(Start 3735734, End 3735931)
PF = z((NCA) => {
  Object.defineProperty(NCA, "__esModule", {
    value: !0
  });
  var tT1 = Co();
  tT1.__exportStar(aR(), NCA);
  tT1.__exportStar(yT1(), NCA);
  tT1.__exportStar(ljQ(), NCA)
})
// @from(Start 3735937, End 3741591)
y6A = z((cM7, GSQ) => {
  var {
    defineProperty: UdA,
    getOwnPropertyDescriptor: qI8,
    getOwnPropertyNames: NI8
  } = Object, LI8 = Object.prototype.hasOwnProperty, Wb = (A, Q) => UdA(A, "name", {
    value: Q,
    configurable: !0
  }), MI8 = (A, Q) => {
    for (var B in Q) UdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, OI8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of NI8(Q))
        if (!LI8.call(A, Z) && Z !== B) UdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qI8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, RI8 = (A) => OI8(UdA({}, "__esModule", {
    value: !0
  }), A), sjQ = {};
  MI8(sjQ, {
    DEFAULT_UA_APP_ID: () => rjQ,
    getUserAgentMiddlewareOptions: () => BSQ,
    getUserAgentPlugin: () => xI8,
    resolveUserAgentConfig: () => tjQ,
    userAgentMiddleware: () => QSQ
  });
  GSQ.exports = RI8(sjQ);
  var TI8 = iB(),
    rjQ = void 0;

  function ojQ(A) {
    if (A === void 0) return !0;
    return typeof A === "string" && A.length <= 50
  }
  Wb(ojQ, "isValidUserAgentAppId");

  function tjQ(A) {
    let Q = (0, TI8.normalizeProvider)(A.userAgentAppId ?? rjQ),
      {
        customUserAgent: B
      } = A;
    return Object.assign(A, {
      customUserAgent: typeof B === "string" ? [
        [B]
      ] : B,
      userAgentAppId: Wb(async () => {
        let G = await Q();
        if (!ojQ(G)) {
          let Z = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console : A.logger;
          if (typeof G !== "string") Z?.warn("userAgentAppId must be a string or undefined.");
          else if (G.length > 50) Z?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.")
        }
        return G
      }, "userAgentAppId")
    })
  }
  Wb(tjQ, "resolveUserAgentConfig");
  var PI8 = T6A(),
    jI8 = az(),
    cS = PF(),
    SI8 = /\d{12}\.ddb/;
  async function ejQ(A, Q, B) {
    if (B.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor")(0, cS.setFeature)(A, "PROTOCOL_RPC_V2_CBOR", "M");
    if (typeof Q.retryStrategy === "function") {
      let I = await Q.retryStrategy();
      if (typeof I.acquireInitialRetryToken === "function")
        if (I.constructor?.name?.includes("Adaptive"))(0, cS.setFeature)(A, "RETRY_MODE_ADAPTIVE", "F");
        else(0, cS.setFeature)(A, "RETRY_MODE_STANDARD", "E");
      else(0, cS.setFeature)(A, "RETRY_MODE_LEGACY", "D")
    }
    if (typeof Q.accountIdEndpointMode === "function") {
      let I = A.endpointV2;
      if (String(I?.url?.hostname).match(SI8))(0, cS.setFeature)(A, "ACCOUNT_ID_ENDPOINT", "O");
      switch (await Q.accountIdEndpointMode?.()) {
        case "disabled":
          (0, cS.setFeature)(A, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, cS.setFeature)(A, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, cS.setFeature)(A, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break
      }
    }
    let Z = A.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (Z?.$source) {
      let I = Z;
      if (I.accountId)(0, cS.setFeature)(A, "RESOLVED_ACCOUNT_ID", "T");
      for (let [Y, J] of Object.entries(I.$source ?? {}))(0, cS.setFeature)(A, Y, J)
    }
  }
  Wb(ejQ, "checkFeatures");
  var ijQ = "user-agent",
    eT1 = "x-amz-user-agent",
    njQ = " ",
    AP1 = "/",
    _I8 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
    kI8 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
    ajQ = "-",
    yI8 = 1024;

  function ASQ(A) {
    let Q = "";
    for (let B in A) {
      let G = A[B];
      if (Q.length + G.length + 1 <= yI8) {
        if (Q.length) Q += "," + G;
        else Q += G;
        continue
      }
      break
    }
    return Q
  }
  Wb(ASQ, "encodeFeatures");
  var QSQ = Wb((A) => (Q, B) => async (G) => {
      let {
        request: Z
      } = G;
      if (!jI8.HttpRequest.isInstance(Z)) return Q(G);
      let {
        headers: I
      } = Z, Y = B?.userAgent?.map(zdA) || [], J = (await A.defaultUserAgentProvider()).map(zdA);
      await ejQ(B, A, G);
      let W = B;
      J.push(`m/${ASQ(Object.assign({},B.__smithy_context?.features,W.__aws_sdk_context?.features))}`);
      let X = A?.customUserAgent?.map(zdA) || [],
        V = await A.userAgentAppId();
      if (V) J.push(zdA([`app/${V}`]));
      let F = (0, PI8.getUserAgentPrefix)(),
        K = (F ? [F] : []).concat([...J, ...Y, ...X]).join(njQ),
        D = [...J.filter((H) => H.startsWith("aws-sdk-")), ...X].join(njQ);
      if (A.runtime !== "browser") {
        if (D) I[eT1] = I[eT1] ? `${I[ijQ]} ${D}` : D;
        I[ijQ] = K
      } else I[eT1] = K;
      return Q({
        ...G,
        request: Z
      })
    }, "userAgentMiddleware"),
    zdA = Wb((A) => {
      let Q = A[0].split(AP1).map((Y) => Y.replace(_I8, ajQ)).join(AP1),
        B = A[1]?.replace(kI8, ajQ),
        G = Q.indexOf(AP1),
        Z = Q.substring(0, G),
        I = Q.substring(G + 1);
      if (Z === "api") I = I.toLowerCase();
      return [Z, I, B].filter((Y) => Y && Y.length > 0).reduce((Y, J, W) => {
        switch (W) {
          case 0:
            return J;
          case 1:
            return `${Y}/${J}`;
          default:
            return `${Y}#${J}`
        }
      }, "")
    }, "escapeUserAgent"),
    BSQ = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: !0
    },
    xI8 = Wb((A) => ({
      applyToStack: Wb((Q) => {
        Q.add(QSQ(A), BSQ)
      }, "applyToStack")
    }), "getUserAgentPlugin")
})
// @from(Start 3741597, End 3743444)
GP1 = z((ZSQ) => {
  Object.defineProperty(ZSQ, "__esModule", {
    value: !0
  });
  ZSQ.resolveHttpAuthSchemeConfig = ZSQ.defaultBedrockHttpAuthSchemeProvider = ZSQ.defaultBedrockHttpAuthSchemeParametersProvider = void 0;
  var vI8 = PF(),
    QP1 = iB(),
    BP1 = w7(),
    bI8 = async (A, Q, B) => {
      return {
        operation: (0, BP1.getSmithyContext)(Q).operation,
        region: await (0, BP1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  ZSQ.defaultBedrockHttpAuthSchemeParametersProvider = bI8;

  function fI8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "bedrock",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function hI8(A) {
    return {
      schemeId: "smithy.api#httpBearerAuth",
      propertiesExtractor: ({
        profile: Q,
        filepath: B,
        configFilepath: G,
        ignoreCache: Z
      }, I) => ({
        identityProperties: {
          profile: Q,
          filepath: B,
          configFilepath: G,
          ignoreCache: Z
        }
      })
    }
  }
  var gI8 = (A) => {
    let Q = [];
    switch (A.operation) {
      default:
        Q.push(fI8(A)), Q.push(hI8(A))
    }
    return Q
  };
  ZSQ.defaultBedrockHttpAuthSchemeProvider = gI8;
  var uI8 = (A) => {
    let Q = (0, QP1.memoizeIdentityProvider)(A.token, QP1.isIdentityExpired, QP1.doesIdentityRequireRefresh),
      B = (0, vI8.resolveAwsSdkSigV4Config)(A);
    return Object.assign(B, {
      authSchemePreference: (0, BP1.normalizeProvider)(A.authSchemePreference ?? []),
      token: Q
    })
  };
  ZSQ.resolveHttpAuthSchemeConfig = uI8
})
// @from(Start 3743450, End 3747214)
YSQ = z((lM7, cI8) => {
  cI8.exports = {
    name: "@aws-sdk/client-bedrock",
    description: "AWS SDK for JavaScript Bedrock Client for Node.js, Browser and React Native",
    version: "3.840.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-bedrock",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo bedrock"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/credential-provider-node": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/token-providers": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      "@types/uuid": "^9.0.1",
      tslib: "^2.6.2",
      uuid: "^9.0.1"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-bedrock",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-bedrock"
    }
  }
})
// @from(Start 3747220, End 3749293)
ZP1 = z((iM7, HSQ) => {
  var {
    defineProperty: $dA,
    getOwnPropertyDescriptor: pI8,
    getOwnPropertyNames: lI8
  } = Object, iI8 = Object.prototype.hasOwnProperty, nI8 = (A, Q) => $dA(A, "name", {
    value: Q,
    configurable: !0
  }), aI8 = (A, Q) => {
    for (var B in Q) $dA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, sI8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of lI8(Q))
        if (!iI8.call(A, Z) && Z !== B) $dA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = pI8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, rI8 = (A) => sI8($dA({}, "__esModule", {
    value: !0
  }), A), JSQ = {};
  aI8(JSQ, {
    ENV_ACCOUNT_ID: () => DSQ,
    ENV_CREDENTIAL_SCOPE: () => KSQ,
    ENV_EXPIRATION: () => FSQ,
    ENV_KEY: () => WSQ,
    ENV_SECRET: () => XSQ,
    ENV_SESSION: () => VSQ,
    fromEnv: () => eI8
  });
  HSQ.exports = rI8(JSQ);
  var oI8 = aR(),
    tI8 = j2(),
    WSQ = "AWS_ACCESS_KEY_ID",
    XSQ = "AWS_SECRET_ACCESS_KEY",
    VSQ = "AWS_SESSION_TOKEN",
    FSQ = "AWS_CREDENTIAL_EXPIRATION",
    KSQ = "AWS_CREDENTIAL_SCOPE",
    DSQ = "AWS_ACCOUNT_ID",
    eI8 = nI8((A) => async () => {
      A?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
      let Q = process.env[WSQ],
        B = process.env[XSQ],
        G = process.env[VSQ],
        Z = process.env[FSQ],
        I = process.env[KSQ],
        Y = process.env[DSQ];
      if (Q && B) {
        let J = {
          accessKeyId: Q,
          secretAccessKey: B,
          ...G && {
            sessionToken: G
          },
          ...Z && {
            expiration: new Date(Z)
          },
          ...I && {
            credentialScope: I
          },
          ...Y && {
            accountId: Y
          }
        };
        return (0, oI8.setCredentialFeature)(J, "CREDENTIALS_ENV_VARS", "g"), J
      }
      throw new tI8.CredentialsProviderError("Unable to find environment variable credentials.", {
        logger: A?.logger
      })
    }, "fromEnv")
})
// @from(Start 3749299, End 3750422)
zSQ = z((CSQ) => {
  Object.defineProperty(CSQ, "__esModule", {
    value: !0
  });
  CSQ.checkUrl = void 0;
  var AY8 = j2(),
    QY8 = "169.254.170.2",
    BY8 = "169.254.170.23",
    GY8 = "[fd00:ec2::23]",
    ZY8 = (A, Q) => {
      if (A.protocol === "https:") return;
      if (A.hostname === QY8 || A.hostname === BY8 || A.hostname === GY8) return;
      if (A.hostname.includes("[")) {
        if (A.hostname === "[::1]" || A.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") return
      } else {
        if (A.hostname === "localhost") return;
        let B = A.hostname.split("."),
          G = (Z) => {
            let I = parseInt(Z, 10);
            return 0 <= I && I <= 255
          };
        if (B[0] === "127" && G(B[1]) && G(B[2]) && G(B[3]) && B.length === 4) return
      }
      throw new AY8.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, {
        logger: Q
      })
    };
  CSQ.checkUrl = ZY8
})
// @from(Start 3750428, End 3752169)
$SQ = z((USQ) => {
  Object.defineProperty(USQ, "__esModule", {
    value: !0
  });
  USQ.createGetRequest = WY8;
  USQ.getCredentials = XY8;
  var IP1 = j2(),
    IY8 = az(),
    YY8 = o6(),
    JY8 = Xd();

  function WY8(A) {
    return new IY8.HttpRequest({
      protocol: A.protocol,
      hostname: A.hostname,
      port: Number(A.port),
      path: A.pathname,
      query: Array.from(A.searchParams.entries()).reduce((Q, [B, G]) => {
        return Q[B] = G, Q
      }, {}),
      fragment: A.hash
    })
  }
  async function XY8(A, Q) {
    let G = await (0, JY8.sdkStreamMixin)(A.body).transformToString();
    if (A.statusCode === 200) {
      let Z = JSON.parse(G);
      if (typeof Z.AccessKeyId !== "string" || typeof Z.SecretAccessKey !== "string" || typeof Z.Token !== "string" || typeof Z.Expiration !== "string") throw new IP1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", {
        logger: Q
      });
      return {
        accessKeyId: Z.AccessKeyId,
        secretAccessKey: Z.SecretAccessKey,
        sessionToken: Z.Token,
        expiration: (0, YY8.parseRfc3339DateTime)(Z.Expiration)
      }
    }
    if (A.statusCode >= 400 && A.statusCode < 500) {
      let Z = {};
      try {
        Z = JSON.parse(G)
      } catch (I) {}
      throw Object.assign(new IP1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
        logger: Q
      }), {
        Code: Z.Code,
        Message: Z.Message
      })
    }
    throw new IP1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
      logger: Q
    })
  }
})
// @from(Start 3752175, End 3752545)
NSQ = z((wSQ) => {
  Object.defineProperty(wSQ, "__esModule", {
    value: !0
  });
  wSQ.retryWrapper = void 0;
  var KY8 = (A, Q, B) => {
    return async () => {
      for (let G = 0; G < Q; ++G) try {
        return await A()
      } catch (Z) {
        await new Promise((I) => setTimeout(I, B))
      }
      return await A()
    }
  };
  wSQ.retryWrapper = KY8
})
// @from(Start 3752551, End 3755038)
TSQ = z((OSQ) => {
  Object.defineProperty(OSQ, "__esModule", {
    value: !0
  });
  OSQ.fromHttp = void 0;
  var DY8 = Co(),
    HY8 = aR(),
    CY8 = IZ(),
    LSQ = j2(),
    EY8 = DY8.__importDefault(UA("fs/promises")),
    zY8 = zSQ(),
    MSQ = $SQ(),
    UY8 = NSQ(),
    $Y8 = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    wY8 = "http://169.254.170.2",
    qY8 = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    NY8 = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",
    LY8 = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    MY8 = (A = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let Q, B = A.awsContainerCredentialsRelativeUri ?? process.env[$Y8],
        G = A.awsContainerCredentialsFullUri ?? process.env[qY8],
        Z = A.awsContainerAuthorizationToken ?? process.env[LY8],
        I = A.awsContainerAuthorizationTokenFile ?? process.env[NY8],
        Y = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console.warn : A.logger.warn;
      if (B && G) Y("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."), Y("awsContainerCredentialsFullUri will take precedence.");
      if (Z && I) Y("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."), Y("awsContainerAuthorizationToken will take precedence.");
      if (G) Q = G;
      else if (B) Q = `${wY8}${B}`;
      else throw new LSQ.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, {
        logger: A.logger
      });
      let J = new URL(Q);
      (0, zY8.checkUrl)(J, A.logger);
      let W = new CY8.NodeHttpHandler({
        requestTimeout: A.timeout ?? 1000,
        connectionTimeout: A.timeout ?? 1000
      });
      return (0, UY8.retryWrapper)(async () => {
        let X = (0, MSQ.createGetRequest)(J);
        if (Z) X.headers.Authorization = Z;
        else if (I) X.headers.Authorization = (await EY8.default.readFile(I)).toString();
        try {
          let V = await W.handle(X);
          return (0, MSQ.getCredentials)(V.response).then((F) => (0, HY8.setCredentialFeature)(F, "CREDENTIALS_HTTP", "z"))
        } catch (V) {
          throw new LSQ.CredentialsProviderError(String(V), {
            logger: A.logger
          })
        }
      }, A.maxRetries ?? 3, A.timeout ?? 1000)
    };
  OSQ.fromHttp = MY8
})
// @from(Start 3755044, End 3755296)
JP1 = z((YP1) => {
  Object.defineProperty(YP1, "__esModule", {
    value: !0
  });
  YP1.fromHttp = void 0;
  var OY8 = TSQ();
  Object.defineProperty(YP1, "fromHttp", {
    enumerable: !0,
    get: function() {
      return OY8.fromHttp
    }
  })
})
// @from(Start 3755302, End 3756990)
XP1 = z((PSQ) => {
  Object.defineProperty(PSQ, "__esModule", {
    value: !0
  });
  PSQ.resolveHttpAuthSchemeConfig = PSQ.defaultSSOHttpAuthSchemeProvider = PSQ.defaultSSOHttpAuthSchemeParametersProvider = void 0;
  var TY8 = PF(),
    WP1 = w7(),
    PY8 = async (A, Q, B) => {
      return {
        operation: (0, WP1.getSmithyContext)(Q).operation,
        region: await (0, WP1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  PSQ.defaultSSOHttpAuthSchemeParametersProvider = PY8;

  function jY8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "awsssoportal",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function wdA(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var SY8 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "GetRoleCredentials": {
        Q.push(wdA(A));
        break
      }
      case "ListAccountRoles": {
        Q.push(wdA(A));
        break
      }
      case "ListAccounts": {
        Q.push(wdA(A));
        break
      }
      case "Logout": {
        Q.push(wdA(A));
        break
      }
      default:
        Q.push(jY8(A))
    }
    return Q
  };
  PSQ.defaultSSOHttpAuthSchemeProvider = SY8;
  var _Y8 = (A) => {
    let Q = (0, TY8.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, WP1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  PSQ.resolveHttpAuthSchemeConfig = _Y8
})
// @from(Start 3756996, End 3760584)
SSQ = z((eM7, xY8) => {
  xY8.exports = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.840.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  }
})
// @from(Start 3760590, End 3762766)
LCA = z((AO7, fSQ) => {
  var {
    defineProperty: NdA,
    getOwnPropertyDescriptor: vY8,
    getOwnPropertyNames: bY8
  } = Object, fY8 = Object.prototype.hasOwnProperty, qdA = (A, Q) => NdA(A, "name", {
    value: Q,
    configurable: !0
  }), hY8 = (A, Q) => {
    for (var B in Q) NdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, gY8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of bY8(Q))
        if (!fY8.call(A, Z) && Z !== B) NdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = vY8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, uY8 = (A) => gY8(NdA({}, "__esModule", {
    value: !0
  }), A), kSQ = {};
  hY8(kSQ, {
    NODE_APP_ID_CONFIG_OPTIONS: () => lY8,
    UA_APP_ID_ENV_NAME: () => vSQ,
    UA_APP_ID_INI_NAME: () => bSQ,
    createDefaultUserAgentProvider: () => xSQ,
    crtAvailability: () => ySQ,
    defaultUserAgent: () => dY8
  });
  fSQ.exports = uY8(kSQ);
  var _SQ = UA("os"),
    VP1 = UA("process"),
    ySQ = {
      isCrtAvailable: !1
    },
    mY8 = qdA(() => {
      if (ySQ.isCrtAvailable) return ["md/crt-avail"];
      return null
    }, "isCrtAvailable"),
    xSQ = qdA(({
      serviceId: A,
      clientVersion: Q
    }) => {
      return async (B) => {
        let G = [
            ["aws-sdk-js", Q],
            ["ua", "2.1"],
            [`os/${(0,_SQ.platform)()}`, (0, _SQ.release)()],
            ["lang/js"],
            ["md/nodejs", `${VP1.versions.node}`]
          ],
          Z = mY8();
        if (Z) G.push(Z);
        if (A) G.push([`api/${A}`, Q]);
        if (VP1.env.AWS_EXECUTION_ENV) G.push([`exec-env/${VP1.env.AWS_EXECUTION_ENV}`]);
        let I = await B?.userAgentAppId?.();
        return I ? [...G, [`app/${I}`]] : [...G]
      }
    }, "createDefaultUserAgentProvider"),
    dY8 = xSQ,
    cY8 = y6A(),
    vSQ = "AWS_SDK_UA_APP_ID",
    bSQ = "sdk_ua_app_id",
    pY8 = "sdk-ua-app-id",
    lY8 = {
      environmentVariableSelector: qdA((A) => A[vSQ], "environmentVariableSelector"),
      configFileSelector: qdA((A) => A[bSQ] ?? A[pY8], "configFileSelector"),
      default: cY8.DEFAULT_UA_APP_ID
    }
})
// @from(Start 3762772, End 3767469)
A_Q = z((tSQ) => {
  Object.defineProperty(tSQ, "__esModule", {
    value: !0
  });
  tSQ.ruleSet = void 0;
  var aSQ = "required",
    kL = "fn",
    yL = "argv",
    b6A = "ref",
    hSQ = !0,
    gSQ = "isSet",
    MCA = "booleanEquals",
    x6A = "error",
    v6A = "endpoint",
    Xb = "tree",
    FP1 = "PartitionResult",
    KP1 = "getAttr",
    uSQ = {
      [aSQ]: !1,
      type: "String"
    },
    mSQ = {
      [aSQ]: !0,
      default: !1,
      type: "Boolean"
    },
    dSQ = {
      [b6A]: "Endpoint"
    },
    sSQ = {
      [kL]: MCA,
      [yL]: [{
        [b6A]: "UseFIPS"
      }, !0]
    },
    rSQ = {
      [kL]: MCA,
      [yL]: [{
        [b6A]: "UseDualStack"
      }, !0]
    },
    _L = {},
    cSQ = {
      [kL]: KP1,
      [yL]: [{
        [b6A]: FP1
      }, "supportsFIPS"]
    },
    oSQ = {
      [b6A]: FP1
    },
    pSQ = {
      [kL]: MCA,
      [yL]: [!0, {
        [kL]: KP1,
        [yL]: [oSQ, "supportsDualStack"]
      }]
    },
    lSQ = [sSQ],
    iSQ = [rSQ],
    nSQ = [{
      [b6A]: "Region"
    }],
    iY8 = {
      version: "1.0",
      parameters: {
        Region: uSQ,
        UseDualStack: mSQ,
        UseFIPS: mSQ,
        Endpoint: uSQ
      },
      rules: [{
        conditions: [{
          [kL]: gSQ,
          [yL]: [dSQ]
        }],
        rules: [{
          conditions: lSQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: x6A
        }, {
          conditions: iSQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: x6A
        }, {
          endpoint: {
            url: dSQ,
            properties: _L,
            headers: _L
          },
          type: v6A
        }],
        type: Xb
      }, {
        conditions: [{
          [kL]: gSQ,
          [yL]: nSQ
        }],
        rules: [{
          conditions: [{
            [kL]: "aws.partition",
            [yL]: nSQ,
            assign: FP1
          }],
          rules: [{
            conditions: [sSQ, rSQ],
            rules: [{
              conditions: [{
                [kL]: MCA,
                [yL]: [hSQ, cSQ]
              }, pSQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: _L,
                  headers: _L
                },
                type: v6A
              }],
              type: Xb
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: x6A
            }],
            type: Xb
          }, {
            conditions: lSQ,
            rules: [{
              conditions: [{
                [kL]: MCA,
                [yL]: [cSQ, hSQ]
              }],
              rules: [{
                conditions: [{
                  [kL]: "stringEquals",
                  [yL]: [{
                    [kL]: KP1,
                    [yL]: [oSQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://portal.sso.{Region}.amazonaws.com",
                  properties: _L,
                  headers: _L
                },
                type: v6A
              }, {
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: _L,
                  headers: _L
                },
                type: v6A
              }],
              type: Xb
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: x6A
            }],
            type: Xb
          }, {
            conditions: iSQ,
            rules: [{
              conditions: [pSQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: _L,
                  headers: _L
                },
                type: v6A
              }],
              type: Xb
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: x6A
            }],
            type: Xb
          }, {
            endpoint: {
              url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
              properties: _L,
              headers: _L
            },
            type: v6A
          }],
          type: Xb
        }],
        type: Xb
      }, {
        error: "Invalid Configuration: Missing Region",
        type: x6A
      }]
    };
  tSQ.ruleSet = iY8
})
// @from(Start 3767475, End 3768039)
G_Q = z((Q_Q) => {
  Object.defineProperty(Q_Q, "__esModule", {
    value: !0
  });
  Q_Q.defaultEndpointResolver = void 0;
  var nY8 = T6A(),
    DP1 = FI(),
    aY8 = A_Q(),
    sY8 = new DP1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    rY8 = (A, Q = {}) => {
      return sY8.get(A, () => (0, DP1.resolveEndpoint)(aY8.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  Q_Q.defaultEndpointResolver = rY8;
  DP1.customEndpointFunctions.aws = nY8.awsEndpointFunctions
})
// @from(Start 3768045, End 3769454)
W_Q = z((Y_Q) => {
  Object.defineProperty(Y_Q, "__esModule", {
    value: !0
  });
  Y_Q.getRuntimeConfig = void 0;
  var oY8 = PF(),
    tY8 = iB(),
    eY8 = o6(),
    AJ8 = NJ(),
    Z_Q = ld(),
    I_Q = O2(),
    QJ8 = XP1(),
    BJ8 = G_Q(),
    GJ8 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? Z_Q.fromBase64,
        base64Encoder: A?.base64Encoder ?? Z_Q.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? BJ8.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? QJ8.defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new oY8.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new tY8.NoAuthSigner
        }],
        logger: A?.logger ?? new eY8.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO",
        urlParser: A?.urlParser ?? AJ8.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? I_Q.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? I_Q.toUtf8
      }
    };
  Y_Q.getRuntimeConfig = GJ8
})
// @from(Start 3769460, End 3771759)
C_Q = z((D_Q) => {
  Object.defineProperty(D_Q, "__esModule", {
    value: !0
  });
  D_Q.getRuntimeConfig = void 0;
  var ZJ8 = Co(),
    IJ8 = ZJ8.__importDefault(SSQ()),
    X_Q = PF(),
    V_Q = LCA(),
    LdA = f8(),
    YJ8 = RX(),
    F_Q = D6(),
    $o = uI(),
    K_Q = IZ(),
    JJ8 = TX(),
    WJ8 = KW(),
    XJ8 = W_Q(),
    VJ8 = o6(),
    FJ8 = PX(),
    KJ8 = o6(),
    DJ8 = (A) => {
      (0, KJ8.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, FJ8.resolveDefaultsModeConfig)(A),
        B = () => Q().then(VJ8.loadConfigsForDefaultMode),
        G = (0, XJ8.getRuntimeConfig)(A);
      (0, X_Q.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, $o.loadConfig)(X_Q.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? JJ8.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, V_Q.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: IJ8.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, $o.loadConfig)(F_Q.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, $o.loadConfig)(LdA.NODE_REGION_CONFIG_OPTIONS, {
          ...LdA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: K_Q.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, $o.loadConfig)({
          ...F_Q.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || WJ8.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? YJ8.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? K_Q.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, $o.loadConfig)(LdA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, $o.loadConfig)(LdA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, $o.loadConfig)(V_Q.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  D_Q.getRuntimeConfig = DJ8
})
// @from(Start 3771765, End 3774368)
OCA = z((IO7, q_Q) => {
  var {
    defineProperty: MdA,
    getOwnPropertyDescriptor: HJ8,
    getOwnPropertyNames: CJ8
  } = Object, EJ8 = Object.prototype.hasOwnProperty, pS = (A, Q) => MdA(A, "name", {
    value: Q,
    configurable: !0
  }), zJ8 = (A, Q) => {
    for (var B in Q) MdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, UJ8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of CJ8(Q))
        if (!EJ8.call(A, Z) && Z !== B) MdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = HJ8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, $J8 = (A) => UJ8(MdA({}, "__esModule", {
    value: !0
  }), A), z_Q = {};
  zJ8(z_Q, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => LJ8,
    NODE_REGION_CONFIG_OPTIONS: () => NJ8,
    REGION_ENV_NAME: () => U_Q,
    REGION_INI_NAME: () => $_Q,
    getAwsRegionExtensionConfiguration: () => wJ8,
    resolveAwsRegionExtensionConfiguration: () => qJ8,
    resolveRegionConfig: () => MJ8
  });
  q_Q.exports = $J8(z_Q);
  var wJ8 = pS((A) => {
      return {
        setRegion(Q) {
          A.region = Q
        },
        region() {
          return A.region
        }
      }
    }, "getAwsRegionExtensionConfiguration"),
    qJ8 = pS((A) => {
      return {
        region: A.region()
      }
    }, "resolveAwsRegionExtensionConfiguration"),
    U_Q = "AWS_REGION",
    $_Q = "region",
    NJ8 = {
      environmentVariableSelector: pS((A) => A[U_Q], "environmentVariableSelector"),
      configFileSelector: pS((A) => A[$_Q], "configFileSelector"),
      default: pS(() => {
        throw Error("Region is missing")
      }, "default")
    },
    LJ8 = {
      preferredFile: "credentials"
    },
    w_Q = pS((A) => typeof A === "string" && (A.startsWith("fips-") || A.endsWith("-fips")), "isFipsRegion"),
    E_Q = pS((A) => w_Q(A) ? ["fips-aws-global", "aws-fips"].includes(A) ? "us-east-1" : A.replace(/fips-(dkr-|prod-)?|-fips/, "") : A, "getRealRegion"),
    MJ8 = pS((A) => {
      let {
        region: Q,
        useFipsEndpoint: B
      } = A;
      if (!Q) throw Error("Region is missing");
      return Object.assign(A, {
        region: pS(async () => {
          if (typeof Q === "string") return E_Q(Q);
          let G = await Q();
          return E_Q(G)
        }, "region"),
        useFipsEndpoint: pS(async () => {
          let G = typeof Q === "string" ? Q : await Q();
          if (w_Q(G)) return !0;
          return typeof B !== "function" ? Promise.resolve(!!B) : B()
        }, "useFipsEndpoint")
      })
    }, "resolveRegionConfig")
})
// @from(Start 3774374, End 3790922)
s_Q = z((YO7, a_Q) => {
  var {
    defineProperty: OdA,
    getOwnPropertyDescriptor: OJ8,
    getOwnPropertyNames: RJ8
  } = Object, TJ8 = Object.prototype.hasOwnProperty, O5 = (A, Q) => OdA(A, "name", {
    value: Q,
    configurable: !0
  }), PJ8 = (A, Q) => {
    for (var B in Q) OdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, jJ8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of RJ8(Q))
        if (!TJ8.call(A, Z) && Z !== B) OdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = OJ8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, SJ8 = (A) => jJ8(OdA({}, "__esModule", {
    value: !0
  }), A), P_Q = {};
  PJ8(P_Q, {
    GetRoleCredentialsCommand: () => l_Q,
    GetRoleCredentialsRequestFilterSensitiveLog: () => y_Q,
    GetRoleCredentialsResponseFilterSensitiveLog: () => v_Q,
    InvalidRequestException: () => j_Q,
    ListAccountRolesCommand: () => HP1,
    ListAccountRolesRequestFilterSensitiveLog: () => b_Q,
    ListAccountsCommand: () => CP1,
    ListAccountsRequestFilterSensitiveLog: () => f_Q,
    LogoutCommand: () => i_Q,
    LogoutRequestFilterSensitiveLog: () => h_Q,
    ResourceNotFoundException: () => S_Q,
    RoleCredentialsFilterSensitiveLog: () => x_Q,
    SSO: () => n_Q,
    SSOClient: () => TdA,
    SSOServiceException: () => f6A,
    TooManyRequestsException: () => __Q,
    UnauthorizedException: () => k_Q,
    __Client: () => K2.Client,
    paginateListAccountRoles: () => BW8,
    paginateListAccounts: () => GW8
  });
  a_Q.exports = SJ8(P_Q);
  var N_Q = CCA(),
    _J8 = ECA(),
    kJ8 = zCA(),
    L_Q = y6A(),
    yJ8 = f8(),
    Vb = iB(),
    xJ8 = LX(),
    TCA = q5(),
    M_Q = D6(),
    O_Q = XP1(),
    vJ8 = O5((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal"
      })
    }, "resolveClientEndpointParameters"),
    RdA = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    bJ8 = C_Q(),
    R_Q = OCA(),
    T_Q = az(),
    K2 = o6(),
    fJ8 = O5((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    hJ8 = O5((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    gJ8 = O5((A, Q) => {
      let B = Object.assign((0, R_Q.getAwsRegionExtensionConfiguration)(A), (0, K2.getDefaultExtensionConfiguration)(A), (0, T_Q.getHttpHandlerExtensionConfiguration)(A), fJ8(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, R_Q.resolveAwsRegionExtensionConfiguration)(B), (0, K2.resolveDefaultRuntimeConfig)(B), (0, T_Q.resolveHttpHandlerRuntimeConfig)(B), hJ8(B))
    }, "resolveRuntimeExtensions"),
    TdA = class extends K2.Client {
      static {
        O5(this, "SSOClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, bJ8.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = vJ8(Q),
          G = (0, L_Q.resolveUserAgentConfig)(B),
          Z = (0, M_Q.resolveRetryConfig)(G),
          I = (0, yJ8.resolveRegionConfig)(Z),
          Y = (0, N_Q.resolveHostHeaderConfig)(I),
          J = (0, TCA.resolveEndpointConfig)(Y),
          W = (0, O_Q.resolveHttpAuthSchemeConfig)(J),
          X = gJ8(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, L_Q.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, M_Q.getRetryPlugin)(this.config)), this.middlewareStack.use((0, xJ8.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, N_Q.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, _J8.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, kJ8.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, Vb.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: O_Q.defaultSSOHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: O5(async (V) => new Vb.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, Vb.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    PdA = GZ(),
    f6A = class A extends K2.ServiceException {
      static {
        O5(this, "SSOServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    j_Q = class A extends f6A {
      static {
        O5(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    S_Q = class A extends f6A {
      static {
        O5(this, "ResourceNotFoundException")
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    __Q = class A extends f6A {
      static {
        O5(this, "TooManyRequestsException")
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    k_Q = class A extends f6A {
      static {
        O5(this, "UnauthorizedException")
      }
      name = "UnauthorizedException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    y_Q = O5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: K2.SENSITIVE_STRING
      }
    }), "GetRoleCredentialsRequestFilterSensitiveLog"),
    x_Q = O5((A) => ({
      ...A,
      ...A.secretAccessKey && {
        secretAccessKey: K2.SENSITIVE_STRING
      },
      ...A.sessionToken && {
        sessionToken: K2.SENSITIVE_STRING
      }
    }), "RoleCredentialsFilterSensitiveLog"),
    v_Q = O5((A) => ({
      ...A,
      ...A.roleCredentials && {
        roleCredentials: x_Q(A.roleCredentials)
      }
    }), "GetRoleCredentialsResponseFilterSensitiveLog"),
    b_Q = O5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: K2.SENSITIVE_STRING
      }
    }), "ListAccountRolesRequestFilterSensitiveLog"),
    f_Q = O5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: K2.SENSITIVE_STRING
      }
    }), "ListAccountsRequestFilterSensitiveLog"),
    h_Q = O5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: K2.SENSITIVE_STRING
      }
    }), "LogoutRequestFilterSensitiveLog"),
    RCA = PF(),
    uJ8 = O5(async (A, Q) => {
      let B = (0, Vb.requestBuilder)(A, Q),
        G = (0, K2.map)({}, K2.isSerializableHeaderValue, {
          [_dA]: A[SdA]
        });
      B.bp("/federation/credentials");
      let Z = (0, K2.map)({
          [AW8]: [, (0, K2.expectNonNull)(A[eJ8], "roleName")],
          [u_Q]: [, (0, K2.expectNonNull)(A[g_Q], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_GetRoleCredentialsCommand"),
    mJ8 = O5(async (A, Q) => {
      let B = (0, Vb.requestBuilder)(A, Q),
        G = (0, K2.map)({}, K2.isSerializableHeaderValue, {
          [_dA]: A[SdA]
        });
      B.bp("/assignment/roles");
      let Z = (0, K2.map)({
          [p_Q]: [, A[c_Q]],
          [d_Q]: [() => A.maxResults !== void 0, () => A[m_Q].toString()],
          [u_Q]: [, (0, K2.expectNonNull)(A[g_Q], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountRolesCommand"),
    dJ8 = O5(async (A, Q) => {
      let B = (0, Vb.requestBuilder)(A, Q),
        G = (0, K2.map)({}, K2.isSerializableHeaderValue, {
          [_dA]: A[SdA]
        });
      B.bp("/assignment/accounts");
      let Z = (0, K2.map)({
          [p_Q]: [, A[c_Q]],
          [d_Q]: [() => A.maxResults !== void 0, () => A[m_Q].toString()]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountsCommand"),
    cJ8 = O5(async (A, Q) => {
      let B = (0, Vb.requestBuilder)(A, Q),
        G = (0, K2.map)({}, K2.isSerializableHeaderValue, {
          [_dA]: A[SdA]
        });
      B.bp("/logout");
      let Z;
      return B.m("POST").h(G).b(Z), B.build()
    }, "se_LogoutCommand"),
    pJ8 = O5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jdA(A, Q);
      let B = (0, K2.map)({
          $metadata: nd(A)
        }),
        G = (0, K2.expectNonNull)((0, K2.expectObject)(await (0, RCA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, K2.take)(G, {
          roleCredentials: K2._json
        });
      return Object.assign(B, Z), B
    }, "de_GetRoleCredentialsCommand"),
    lJ8 = O5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jdA(A, Q);
      let B = (0, K2.map)({
          $metadata: nd(A)
        }),
        G = (0, K2.expectNonNull)((0, K2.expectObject)(await (0, RCA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, K2.take)(G, {
          nextToken: K2.expectString,
          roleList: K2._json
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountRolesCommand"),
    iJ8 = O5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jdA(A, Q);
      let B = (0, K2.map)({
          $metadata: nd(A)
        }),
        G = (0, K2.expectNonNull)((0, K2.expectObject)(await (0, RCA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, K2.take)(G, {
          accountList: K2._json,
          nextToken: K2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountsCommand"),
    nJ8 = O5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return jdA(A, Q);
      let B = (0, K2.map)({
        $metadata: nd(A)
      });
      return await (0, K2.collectBody)(A.body, Q), B
    }, "de_LogoutCommand"),
    jdA = O5(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, RCA.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, RCA.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await sJ8(B, Q);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await rJ8(B, Q);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await oJ8(B, Q);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await tJ8(B, Q);
        default:
          let Z = B.body;
          return aJ8({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    aJ8 = (0, K2.withBaseException)(f6A),
    sJ8 = O5(async (A, Q) => {
      let B = (0, K2.map)({}),
        G = A.body,
        Z = (0, K2.take)(G, {
          message: K2.expectString
        });
      Object.assign(B, Z);
      let I = new j_Q({
        $metadata: nd(A),
        ...B
      });
      return (0, K2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    rJ8 = O5(async (A, Q) => {
      let B = (0, K2.map)({}),
        G = A.body,
        Z = (0, K2.take)(G, {
          message: K2.expectString
        });
      Object.assign(B, Z);
      let I = new S_Q({
        $metadata: nd(A),
        ...B
      });
      return (0, K2.decorateServiceException)(I, A.body)
    }, "de_ResourceNotFoundExceptionRes"),
    oJ8 = O5(async (A, Q) => {
      let B = (0, K2.map)({}),
        G = A.body,
        Z = (0, K2.take)(G, {
          message: K2.expectString
        });
      Object.assign(B, Z);
      let I = new __Q({
        $metadata: nd(A),
        ...B
      });
      return (0, K2.decorateServiceException)(I, A.body)
    }, "de_TooManyRequestsExceptionRes"),
    tJ8 = O5(async (A, Q) => {
      let B = (0, K2.map)({}),
        G = A.body,
        Z = (0, K2.take)(G, {
          message: K2.expectString
        });
      Object.assign(B, Z);
      let I = new k_Q({
        $metadata: nd(A),
        ...B
      });
      return (0, K2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedExceptionRes"),
    nd = O5((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    g_Q = "accountId",
    SdA = "accessToken",
    u_Q = "account_id",
    m_Q = "maxResults",
    d_Q = "max_result",
    c_Q = "nextToken",
    p_Q = "next_token",
    eJ8 = "roleName",
    AW8 = "role_name",
    _dA = "x-amz-sso_bearer_token",
    l_Q = class extends K2.Command.classBuilder().ep(RdA).m(function(A, Q, B, G) {
      return [(0, PdA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, TCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(y_Q, v_Q).ser(uJ8).de(pJ8).build() {
      static {
        O5(this, "GetRoleCredentialsCommand")
      }
    },
    HP1 = class extends K2.Command.classBuilder().ep(RdA).m(function(A, Q, B, G) {
      return [(0, PdA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, TCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(b_Q, void 0).ser(mJ8).de(lJ8).build() {
      static {
        O5(this, "ListAccountRolesCommand")
      }
    },
    CP1 = class extends K2.Command.classBuilder().ep(RdA).m(function(A, Q, B, G) {
      return [(0, PdA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, TCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(f_Q, void 0).ser(dJ8).de(iJ8).build() {
      static {
        O5(this, "ListAccountsCommand")
      }
    },
    i_Q = class extends K2.Command.classBuilder().ep(RdA).m(function(A, Q, B, G) {
      return [(0, PdA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, TCA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(h_Q, void 0).ser(cJ8).de(nJ8).build() {
      static {
        O5(this, "LogoutCommand")
      }
    },
    QW8 = {
      GetRoleCredentialsCommand: l_Q,
      ListAccountRolesCommand: HP1,
      ListAccountsCommand: CP1,
      LogoutCommand: i_Q
    },
    n_Q = class extends TdA {
      static {
        O5(this, "SSO")
      }
    };
  (0, K2.createAggregatedClient)(QW8, n_Q);
  var BW8 = (0, Vb.createPaginator)(TdA, HP1, "nextToken", "nextToken", "maxResults"),
    GW8 = (0, Vb.createPaginator)(TdA, CP1, "nextToken", "nextToken", "maxResults")
})
// @from(Start 3790928, End 3792399)
zP1 = z((r_Q) => {
  Object.defineProperty(r_Q, "__esModule", {
    value: !0
  });
  r_Q.resolveHttpAuthSchemeConfig = r_Q.defaultSSOOIDCHttpAuthSchemeProvider = r_Q.defaultSSOOIDCHttpAuthSchemeParametersProvider = void 0;
  var ZW8 = PF(),
    EP1 = w7(),
    IW8 = async (A, Q, B) => {
      return {
        operation: (0, EP1.getSmithyContext)(Q).operation,
        region: await (0, EP1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  r_Q.defaultSSOOIDCHttpAuthSchemeParametersProvider = IW8;

  function YW8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function JW8(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var WW8 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "CreateToken": {
        Q.push(JW8(A));
        break
      }
      default:
        Q.push(YW8(A))
    }
    return Q
  };
  r_Q.defaultSSOOIDCHttpAuthSchemeProvider = WW8;
  var XW8 = (A) => {
    let Q = (0, ZW8.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, EP1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  r_Q.resolveHttpAuthSchemeConfig = XW8
})
// @from(Start 3792405, End 3796690)
UP1 = z((HO7, KW8) => {
  KW8.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.840.0",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=18.0.0"
    },
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.840.0",
      "@aws-sdk/middleware-host-header": "3.840.0",
      "@aws-sdk/middleware-logger": "3.840.0",
      "@aws-sdk/middleware-recursion-detection": "3.840.0",
      "@aws-sdk/middleware-user-agent": "3.840.0",
      "@aws-sdk/region-config-resolver": "3.840.0",
      "@aws-sdk/types": "3.840.0",
      "@aws-sdk/util-endpoints": "3.840.0",
      "@aws-sdk/util-user-agent-browser": "3.840.0",
      "@aws-sdk/util-user-agent-node": "3.840.0",
      "@smithy/config-resolver": "^4.1.4",
      "@smithy/core": "^3.6.0",
      "@smithy/fetch-http-handler": "^5.0.4",
      "@smithy/hash-node": "^4.0.4",
      "@smithy/invalid-dependency": "^4.0.4",
      "@smithy/middleware-content-length": "^4.0.4",
      "@smithy/middleware-endpoint": "^4.1.13",
      "@smithy/middleware-retry": "^4.1.14",
      "@smithy/middleware-serde": "^4.0.8",
      "@smithy/middleware-stack": "^4.0.4",
      "@smithy/node-config-provider": "^4.1.3",
      "@smithy/node-http-handler": "^4.0.6",
      "@smithy/protocol-http": "^5.1.2",
      "@smithy/smithy-client": "^4.4.5",
      "@smithy/types": "^4.3.1",
      "@smithy/url-parser": "^4.0.4",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.21",
      "@smithy/util-defaults-mode-node": "^4.0.21",
      "@smithy/util-endpoints": "^3.0.6",
      "@smithy/util-middleware": "^4.0.4",
      "@smithy/util-retry": "^4.0.6",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["./sso-oidc.d.ts", "./sso-oidc.js", "./sts.d.ts", "./sts.js", "dist-*/**"],
    browser: {
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./sso-oidc": {
        types: "./dist-types/submodules/sso-oidc/index.d.ts",
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js"
      },
      "./sts": {
        types: "./dist-types/submodules/sts/index.d.ts",
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js"
      }
    }
  }
})
// @from(Start 3796696, End 3801363)
HkQ = z((KkQ) => {
  Object.defineProperty(KkQ, "__esModule", {
    value: !0
  });
  KkQ.ruleSet = void 0;
  var WkQ = "required",
    vL = "fn",
    bL = "argv",
    u6A = "ref",
    t_Q = !0,
    e_Q = "isSet",
    PCA = "booleanEquals",
    h6A = "error",
    g6A = "endpoint",
    Fb = "tree",
    $P1 = "PartitionResult",
    wP1 = "getAttr",
    AkQ = {
      [WkQ]: !1,
      type: "String"
    },
    QkQ = {
      [WkQ]: !0,
      default: !1,
      type: "Boolean"
    },
    BkQ = {
      [u6A]: "Endpoint"
    },
    XkQ = {
      [vL]: PCA,
      [bL]: [{
        [u6A]: "UseFIPS"
      }, !0]
    },
    VkQ = {
      [vL]: PCA,
      [bL]: [{
        [u6A]: "UseDualStack"
      }, !0]
    },
    xL = {},
    GkQ = {
      [vL]: wP1,
      [bL]: [{
        [u6A]: $P1
      }, "supportsFIPS"]
    },
    FkQ = {
      [u6A]: $P1
    },
    ZkQ = {
      [vL]: PCA,
      [bL]: [!0, {
        [vL]: wP1,
        [bL]: [FkQ, "supportsDualStack"]
      }]
    },
    IkQ = [XkQ],
    YkQ = [VkQ],
    JkQ = [{
      [u6A]: "Region"
    }],
    DW8 = {
      version: "1.0",
      parameters: {
        Region: AkQ,
        UseDualStack: QkQ,
        UseFIPS: QkQ,
        Endpoint: AkQ
      },
      rules: [{
        conditions: [{
          [vL]: e_Q,
          [bL]: [BkQ]
        }],
        rules: [{
          conditions: IkQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: h6A
        }, {
          conditions: YkQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: h6A
        }, {
          endpoint: {
            url: BkQ,
            properties: xL,
            headers: xL
          },
          type: g6A
        }],
        type: Fb
      }, {
        conditions: [{
          [vL]: e_Q,
          [bL]: JkQ
        }],
        rules: [{
          conditions: [{
            [vL]: "aws.partition",
            [bL]: JkQ,
            assign: $P1
          }],
          rules: [{
            conditions: [XkQ, VkQ],
            rules: [{
              conditions: [{
                [vL]: PCA,
                [bL]: [t_Q, GkQ]
              }, ZkQ],
              rules: [{
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: xL,
                  headers: xL
                },
                type: g6A
              }],
              type: Fb
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: h6A
            }],
            type: Fb
          }, {
            conditions: IkQ,
            rules: [{
              conditions: [{
                [vL]: PCA,
                [bL]: [GkQ, t_Q]
              }],
              rules: [{
                conditions: [{
                  [vL]: "stringEquals",
                  [bL]: [{
                    [vL]: wP1,
                    [bL]: [FkQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://oidc.{Region}.amazonaws.com",
                  properties: xL,
                  headers: xL
                },
                type: g6A
              }, {
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: xL,
                  headers: xL
                },
                type: g6A
              }],
              type: Fb
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: h6A
            }],
            type: Fb
          }, {
            conditions: YkQ,
            rules: [{
              conditions: [ZkQ],
              rules: [{
                endpoint: {
                  url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: xL,
                  headers: xL
                },
                type: g6A
              }],
              type: Fb
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: h6A
            }],
            type: Fb
          }, {
            endpoint: {
              url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
              properties: xL,
              headers: xL
            },
            type: g6A
          }],
          type: Fb
        }],
        type: Fb
      }, {
        error: "Invalid Configuration: Missing Region",
        type: h6A
      }]
    };
  KkQ.ruleSet = DW8
})
// @from(Start 3801369, End 3801933)
zkQ = z((CkQ) => {
  Object.defineProperty(CkQ, "__esModule", {
    value: !0
  });
  CkQ.defaultEndpointResolver = void 0;
  var HW8 = T6A(),
    qP1 = FI(),
    CW8 = HkQ(),
    EW8 = new qP1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    zW8 = (A, Q = {}) => {
      return EW8.get(A, () => (0, qP1.resolveEndpoint)(CW8.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  CkQ.defaultEndpointResolver = zW8;
  qP1.customEndpointFunctions.aws = HW8.awsEndpointFunctions
})
// @from(Start 3801939, End 3803357)
NkQ = z((wkQ) => {
  Object.defineProperty(wkQ, "__esModule", {
    value: !0
  });
  wkQ.getRuntimeConfig = void 0;
  var UW8 = PF(),
    $W8 = iB(),
    wW8 = o6(),
    qW8 = NJ(),
    UkQ = ld(),
    $kQ = O2(),
    NW8 = zP1(),
    LW8 = zkQ(),
    MW8 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? UkQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? UkQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? LW8.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? NW8.defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new UW8.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new $W8.NoAuthSigner
        }],
        logger: A?.logger ?? new wW8.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO OIDC",
        urlParser: A?.urlParser ?? qW8.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? $kQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? $kQ.toUtf8
      }
    };
  wkQ.getRuntimeConfig = MW8
})
// @from(Start 3803363, End 3805662)
jkQ = z((TkQ) => {
  Object.defineProperty(TkQ, "__esModule", {
    value: !0
  });
  TkQ.getRuntimeConfig = void 0;
  var OW8 = Co(),
    RW8 = OW8.__importDefault(UP1()),
    LkQ = PF(),
    MkQ = LCA(),
    kdA = f8(),
    TW8 = RX(),
    OkQ = D6(),
    wo = uI(),
    RkQ = IZ(),
    PW8 = TX(),
    jW8 = KW(),
    SW8 = NkQ(),
    _W8 = o6(),
    kW8 = PX(),
    yW8 = o6(),
    xW8 = (A) => {
      (0, yW8.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, kW8.resolveDefaultsModeConfig)(A),
        B = () => Q().then(_W8.loadConfigsForDefaultMode),
        G = (0, SW8.getRuntimeConfig)(A);
      (0, LkQ.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, wo.loadConfig)(LkQ.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? PW8.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, MkQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: RW8.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, wo.loadConfig)(OkQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, wo.loadConfig)(kdA.NODE_REGION_CONFIG_OPTIONS, {
          ...kdA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: RkQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, wo.loadConfig)({
          ...OkQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || jW8.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? TW8.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? RkQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, wo.loadConfig)(kdA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, wo.loadConfig)(kdA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, wo.loadConfig)(MkQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  TkQ.getRuntimeConfig = xW8
})
// @from(Start 3805668, End 3825495)
MP1 = z(($O7, ByQ) => {
  var {
    defineProperty: ydA,
    getOwnPropertyDescriptor: vW8,
    getOwnPropertyNames: bW8
  } = Object, fW8 = Object.prototype.hasOwnProperty, P6 = (A, Q) => ydA(A, "name", {
    value: Q,
    configurable: !0
  }), hW8 = (A, Q) => {
    for (var B in Q) ydA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, gW8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of bW8(Q))
        if (!fW8.call(A, Z) && Z !== B) ydA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = vW8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, uW8 = (A) => gW8(ydA({}, "__esModule", {
    value: !0
  }), A), fkQ = {};
  hW8(fkQ, {
    $Command: () => ukQ.Command,
    AccessDeniedException: () => mkQ,
    AuthorizationPendingException: () => dkQ,
    CreateTokenCommand: () => AyQ,
    CreateTokenRequestFilterSensitiveLog: () => ckQ,
    CreateTokenResponseFilterSensitiveLog: () => pkQ,
    ExpiredTokenException: () => lkQ,
    InternalServerException: () => ikQ,
    InvalidClientException: () => nkQ,
    InvalidGrantException: () => akQ,
    InvalidRequestException: () => skQ,
    InvalidScopeException: () => rkQ,
    SSOOIDC: () => QyQ,
    SSOOIDCClient: () => gkQ,
    SSOOIDCServiceException: () => Pw,
    SlowDownException: () => okQ,
    UnauthorizedClientException: () => tkQ,
    UnsupportedGrantTypeException: () => ekQ,
    __Client: () => hkQ.Client
  });
  ByQ.exports = uW8(fkQ);
  var SkQ = CCA(),
    mW8 = ECA(),
    dW8 = zCA(),
    _kQ = y6A(),
    cW8 = f8(),
    NP1 = iB(),
    pW8 = LX(),
    lW8 = q5(),
    kkQ = D6(),
    hkQ = o6(),
    ykQ = zP1(),
    iW8 = P6((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth"
      })
    }, "resolveClientEndpointParameters"),
    nW8 = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    aW8 = jkQ(),
    xkQ = OCA(),
    vkQ = az(),
    bkQ = o6(),
    sW8 = P6((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    rW8 = P6((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    oW8 = P6((A, Q) => {
      let B = Object.assign((0, xkQ.getAwsRegionExtensionConfiguration)(A), (0, bkQ.getDefaultExtensionConfiguration)(A), (0, vkQ.getHttpHandlerExtensionConfiguration)(A), sW8(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, xkQ.resolveAwsRegionExtensionConfiguration)(B), (0, bkQ.resolveDefaultRuntimeConfig)(B), (0, vkQ.resolveHttpHandlerRuntimeConfig)(B), rW8(B))
    }, "resolveRuntimeExtensions"),
    gkQ = class extends hkQ.Client {
      static {
        P6(this, "SSOOIDCClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, aW8.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = iW8(Q),
          G = (0, _kQ.resolveUserAgentConfig)(B),
          Z = (0, kkQ.resolveRetryConfig)(G),
          I = (0, cW8.resolveRegionConfig)(Z),
          Y = (0, SkQ.resolveHostHeaderConfig)(I),
          J = (0, lW8.resolveEndpointConfig)(Y),
          W = (0, ykQ.resolveHttpAuthSchemeConfig)(J),
          X = oW8(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, _kQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, kkQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, pW8.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, SkQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, mW8.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, dW8.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, NP1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: ykQ.defaultSSOOIDCHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: P6(async (V) => new NP1.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, NP1.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    tW8 = o6(),
    eW8 = q5(),
    AX8 = GZ(),
    ukQ = o6(),
    m6A = o6(),
    QX8 = o6(),
    Pw = class A extends QX8.ServiceException {
      static {
        P6(this, "SSOOIDCServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    mkQ = class A extends Pw {
      static {
        P6(this, "AccessDeniedException")
      }
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    dkQ = class A extends Pw {
      static {
        P6(this, "AuthorizationPendingException")
      }
      name = "AuthorizationPendingException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    ckQ = P6((A) => ({
      ...A,
      ...A.clientSecret && {
        clientSecret: m6A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: m6A.SENSITIVE_STRING
      },
      ...A.codeVerifier && {
        codeVerifier: m6A.SENSITIVE_STRING
      }
    }), "CreateTokenRequestFilterSensitiveLog"),
    pkQ = P6((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: m6A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: m6A.SENSITIVE_STRING
      },
      ...A.idToken && {
        idToken: m6A.SENSITIVE_STRING
      }
    }), "CreateTokenResponseFilterSensitiveLog"),
    lkQ = class A extends Pw {
      static {
        P6(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    ikQ = class A extends Pw {
      static {
        P6(this, "InternalServerException")
      }
      name = "InternalServerException";
      $fault = "server";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    nkQ = class A extends Pw {
      static {
        P6(this, "InvalidClientException")
      }
      name = "InvalidClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    akQ = class A extends Pw {
      static {
        P6(this, "InvalidGrantException")
      }
      name = "InvalidGrantException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    skQ = class A extends Pw {
      static {
        P6(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    rkQ = class A extends Pw {
      static {
        P6(this, "InvalidScopeException")
      }
      name = "InvalidScopeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    okQ = class A extends Pw {
      static {
        P6(this, "SlowDownException")
      }
      name = "SlowDownException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    tkQ = class A extends Pw {
      static {
        P6(this, "UnauthorizedClientException")
      }
      name = "UnauthorizedClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    ekQ = class A extends Pw {
      static {
        P6(this, "UnsupportedGrantTypeException")
      }
      name = "UnsupportedGrantTypeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    LP1 = PF(),
    BX8 = iB(),
    I2 = o6(),
    GX8 = P6(async (A, Q) => {
      let B = (0, BX8.requestBuilder)(A, Q),
        G = {
          "content-type": "application/json"
        };
      B.bp("/token");
      let Z;
      return Z = JSON.stringify((0, I2.take)(A, {
        clientId: [],
        clientSecret: [],
        code: [],
        codeVerifier: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: P6((I) => (0, I2._json)(I), "scope")
      })), B.m("POST").h(G).b(Z), B.build()
    }, "se_CreateTokenCommand"),
    ZX8 = P6(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return IX8(A, Q);
      let B = (0, I2.map)({
          $metadata: fL(A)
        }),
        G = (0, I2.expectNonNull)((0, I2.expectObject)(await (0, LP1.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, I2.take)(G, {
          accessToken: I2.expectString,
          expiresIn: I2.expectInt32,
          idToken: I2.expectString,
          refreshToken: I2.expectString,
          tokenType: I2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_CreateTokenCommand"),
    IX8 = P6(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, LP1.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, LP1.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
          throw await JX8(B, Q);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
          throw await WX8(B, Q);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
          throw await XX8(B, Q);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
          throw await VX8(B, Q);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
          throw await FX8(B, Q);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
          throw await KX8(B, Q);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
          throw await DX8(B, Q);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
          throw await HX8(B, Q);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
          throw await CX8(B, Q);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
          throw await EX8(B, Q);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
          throw await zX8(B, Q);
        default:
          let Z = B.body;
          return YX8({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    YX8 = (0, I2.withBaseException)(Pw),
    JX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new mkQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_AccessDeniedExceptionRes"),
    WX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new dkQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_AuthorizationPendingExceptionRes"),
    XX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new lkQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_ExpiredTokenExceptionRes"),
    VX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new ikQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_InternalServerExceptionRes"),
    FX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new nkQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_InvalidClientExceptionRes"),
    KX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new akQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_InvalidGrantExceptionRes"),
    DX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new skQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    HX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new rkQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_InvalidScopeExceptionRes"),
    CX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new okQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_SlowDownExceptionRes"),
    EX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new tkQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedClientExceptionRes"),
    zX8 = P6(async (A, Q) => {
      let B = (0, I2.map)({}),
        G = A.body,
        Z = (0, I2.take)(G, {
          error: I2.expectString,
          error_description: I2.expectString
        });
      Object.assign(B, Z);
      let I = new ekQ({
        $metadata: fL(A),
        ...B
      });
      return (0, I2.decorateServiceException)(I, A.body)
    }, "de_UnsupportedGrantTypeExceptionRes"),
    fL = P6((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    AyQ = class extends ukQ.Command.classBuilder().ep(nW8).m(function(A, Q, B, G) {
      return [(0, AX8.getSerdePlugin)(B, this.serialize, this.deserialize), (0, eW8.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(ckQ, pkQ).ser(GX8).de(ZX8).build() {
      static {
        P6(this, "CreateTokenCommand")
      }
    },
    UX8 = {
      CreateTokenCommand: AyQ
    },
    QyQ = class extends gkQ {
      static {
        P6(this, "SSOOIDC")
      }
    };
  (0, tW8.createAggregatedClient)(UX8, QyQ)
})
// @from(Start 3825501, End 3831670)
RP1 = z((LO7, XyQ) => {
  var {
    create: $X8,
    defineProperty: SCA,
    getOwnPropertyDescriptor: wX8,
    getOwnPropertyNames: qX8,
    getPrototypeOf: NX8
  } = Object, LX8 = Object.prototype.hasOwnProperty, Kb = (A, Q) => SCA(A, "name", {
    value: Q,
    configurable: !0
  }), MX8 = (A, Q) => {
    for (var B in Q) SCA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, IyQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qX8(Q))
        if (!LX8.call(A, Z) && Z !== B) SCA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wX8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, YyQ = (A, Q, B) => (B = A != null ? $X8(NX8(A)) : {}, IyQ(Q || !A || !A.__esModule ? SCA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), OX8 = (A) => IyQ(SCA({}, "__esModule", {
    value: !0
  }), A), JyQ = {};
  MX8(JyQ, {
    fromEnvSigningName: () => PX8,
    fromSso: () => WyQ,
    fromStatic: () => vX8,
    nodeProvider: () => bX8
  });
  XyQ.exports = OX8(JyQ);
  var RX8 = aR(),
    TX8 = yT1(),
    jw = j2(),
    PX8 = Kb(({
      logger: A,
      signingName: Q
    } = {}) => async () => {
      if (A?.debug?.("@aws-sdk/token-providers - fromEnvSigningName"), !Q) throw new jw.TokenProviderError("Please pass 'signingName' to compute environment variable key", {
        logger: A
      });
      let B = (0, TX8.getBearerTokenEnvKey)(Q);
      if (!(B in process.env)) throw new jw.TokenProviderError(`Token not present in '${B}' environment variable`, {
        logger: A
      });
      let G = {
        token: process.env[B]
      };
      return (0, RX8.setTokenFeature)(G, "BEARER_SERVICE_ENV_VARS", "3"), G
    }, "fromEnvSigningName"),
    jX8 = 300000,
    OP1 = "To refresh this SSO session run 'aws sso login' with the corresponding profile.",
    SX8 = Kb(async (A, Q = {}) => {
      let {
        SSOOIDCClient: B
      } = await Promise.resolve().then(() => YyQ(MP1()));
      return new B(Object.assign({}, Q.clientConfig ?? {}, {
        region: A ?? Q.clientConfig?.region,
        logger: Q.clientConfig?.logger ?? Q.parentClientConfig?.logger
      }))
    }, "getSsoOidcClient"),
    _X8 = Kb(async (A, Q, B = {}) => {
      let {
        CreateTokenCommand: G
      } = await Promise.resolve().then(() => YyQ(MP1()));
      return (await SX8(Q, B)).send(new G({
        clientId: A.clientId,
        clientSecret: A.clientSecret,
        refreshToken: A.refreshToken,
        grantType: "refresh_token"
      }))
    }, "getNewSsoOidcToken"),
    GyQ = Kb((A) => {
      if (A.expiration && A.expiration.getTime() < Date.now()) throw new jw.TokenProviderError(`Token is expired. ${OP1}`, !1)
    }, "validateTokenExpiry"),
    qo = Kb((A, Q, B = !1) => {
      if (typeof Q > "u") throw new jw.TokenProviderError(`Value not present for '${A}' in SSO Token${B?". Cannot refresh":""}. ${OP1}`, !1)
    }, "validateTokenKey"),
    jCA = SG(),
    kX8 = UA("fs"),
    {
      writeFile: yX8
    } = kX8.promises,
    xX8 = Kb((A, Q) => {
      let B = (0, jCA.getSSOTokenFilepath)(A),
        G = JSON.stringify(Q, null, 2);
      return yX8(B, G)
    }, "writeSSOTokenToFile"),
    ZyQ = new Date(0),
    WyQ = Kb((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/token-providers - fromSso");
      let G = await (0, jCA.parseKnownFiles)(B),
        Z = (0, jCA.getProfileName)({
          profile: B.profile ?? Q?.profile
        }),
        I = G[Z];
      if (!I) throw new jw.TokenProviderError(`Profile '${Z}' could not be found in shared credentials file.`, !1);
      else if (!I.sso_session) throw new jw.TokenProviderError(`Profile '${Z}' is missing required property 'sso_session'.`);
      let Y = I.sso_session,
        W = (await (0, jCA.loadSsoSessionData)(B))[Y];
      if (!W) throw new jw.TokenProviderError(`Sso session '${Y}' could not be found in shared credentials file.`, !1);
      for (let C of ["sso_start_url", "sso_region"])
        if (!W[C]) throw new jw.TokenProviderError(`Sso session '${Y}' is missing required property '${C}'.`, !1);
      let {
        sso_start_url: X,
        sso_region: V
      } = W, F;
      try {
        F = await (0, jCA.getSSOTokenFromFile)(Y)
      } catch (C) {
        throw new jw.TokenProviderError(`The SSO session token associated with profile=${Z} was not found or is invalid. ${OP1}`, !1)
      }
      qo("accessToken", F.accessToken), qo("expiresAt", F.expiresAt);
      let {
        accessToken: K,
        expiresAt: D
      } = F, H = {
        token: K,
        expiration: new Date(D)
      };
      if (H.expiration.getTime() - Date.now() > jX8) return H;
      if (Date.now() - ZyQ.getTime() < 30000) return GyQ(H), H;
      qo("clientId", F.clientId, !0), qo("clientSecret", F.clientSecret, !0), qo("refreshToken", F.refreshToken, !0);
      try {
        ZyQ.setTime(Date.now());
        let C = await _X8(F, V, B);
        qo("accessToken", C.accessToken), qo("expiresIn", C.expiresIn);
        let E = new Date(Date.now() + C.expiresIn * 1000);
        try {
          await xX8(Y, {
            ...F,
            accessToken: C.accessToken,
            expiresAt: E.toISOString(),
            refreshToken: C.refreshToken
          })
        } catch (U) {}
        return {
          token: C.accessToken,
          expiration: E
        }
      } catch (C) {
        return GyQ(H), H
      }
    }, "fromSso"),
    vX8 = Kb(({
      token: A,
      logger: Q
    }) => async () => {
      if (Q?.debug("@aws-sdk/token-providers - fromStatic"), !A || !A.token) throw new jw.TokenProviderError("Please pass a valid token to fromStatic", !1);
      return A
    }, "fromStatic"),
    bX8 = Kb((A = {}) => (0, jw.memoize)((0, jw.chain)(WyQ(A), async () => {
      throw new jw.TokenProviderError("Could not load token from any providers", !1)
    }), (Q) => Q.expiration !== void 0 && Q.expiration.getTime() - Date.now() < 300000, (Q) => Q.expiration !== void 0), "nodeProvider")
})
// @from(Start 3831676, End 3838918)
PP1 = z((MO7, UyQ) => {
  var {
    defineProperty: vdA,
    getOwnPropertyDescriptor: fX8,
    getOwnPropertyNames: KyQ
  } = Object, hX8 = Object.prototype.hasOwnProperty, bdA = (A, Q) => vdA(A, "name", {
    value: Q,
    configurable: !0
  }), gX8 = (A, Q) => function() {
    return A && (Q = (0, A[KyQ(A)[0]])(A = 0)), Q
  }, DyQ = (A, Q) => {
    for (var B in Q) vdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, uX8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of KyQ(Q))
        if (!hX8.call(A, Z) && Z !== B) vdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = fX8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, mX8 = (A) => uX8(vdA({}, "__esModule", {
    value: !0
  }), A), HyQ = {};
  DyQ(HyQ, {
    GetRoleCredentialsCommand: () => TP1.GetRoleCredentialsCommand,
    SSOClient: () => TP1.SSOClient
  });
  var TP1, dX8 = gX8({
      "src/loadSso.ts"() {
        TP1 = s_Q()
      }
    }),
    CyQ = {};
  DyQ(CyQ, {
    fromSSO: () => pX8,
    isSsoProfile: () => EyQ,
    validateSsoProfile: () => zyQ
  });
  UyQ.exports = mX8(CyQ);
  var EyQ = bdA((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    VyQ = aR(),
    cX8 = RP1(),
    sR = j2(),
    xdA = SG(),
    _CA = !1,
    FyQ = bdA(async ({
      ssoStartUrl: A,
      ssoSession: Q,
      ssoAccountId: B,
      ssoRegion: G,
      ssoRoleName: Z,
      ssoClient: I,
      clientConfig: Y,
      parentClientConfig: J,
      profile: W,
      logger: X
    }) => {
      let V, F = "To refresh this SSO session run aws sso login with the corresponding profile.";
      if (Q) try {
        let v = await (0, cX8.fromSso)({
          profile: W
        })();
        V = {
          accessToken: v.token,
          expiresAt: new Date(v.expiration).toISOString()
        }
      } catch (v) {
        throw new sR.CredentialsProviderError(v.message, {
          tryNextLink: _CA,
          logger: X
        })
      } else try {
        V = await (0, xdA.getSSOTokenFromFile)(A)
      } catch (v) {
        throw new sR.CredentialsProviderError("The SSO session associated with this profile is invalid. To refresh this SSO session run aws sso login with the corresponding profile.", {
          tryNextLink: _CA,
          logger: X
        })
      }
      if (new Date(V.expiresAt).getTime() - Date.now() <= 0) throw new sR.CredentialsProviderError("The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile.", {
        tryNextLink: _CA,
        logger: X
      });
      let {
        accessToken: K
      } = V, {
        SSOClient: D,
        GetRoleCredentialsCommand: H
      } = await Promise.resolve().then(() => (dX8(), HyQ)), C = I || new D(Object.assign({}, Y ?? {}, {
        logger: Y?.logger ?? J?.logger,
        region: Y?.region ?? G
      })), E;
      try {
        E = await C.send(new H({
          accountId: B,
          roleName: Z,
          accessToken: K
        }))
      } catch (v) {
        throw new sR.CredentialsProviderError(v, {
          tryNextLink: _CA,
          logger: X
        })
      }
      let {
        roleCredentials: {
          accessKeyId: U,
          secretAccessKey: q,
          sessionToken: w,
          expiration: N,
          credentialScope: R,
          accountId: T
        } = {}
      } = E;
      if (!U || !q || !w || !N) throw new sR.CredentialsProviderError("SSO returns an invalid temporary credential.", {
        tryNextLink: _CA,
        logger: X
      });
      let y = {
        accessKeyId: U,
        secretAccessKey: q,
        sessionToken: w,
        expiration: new Date(N),
        ...R && {
          credentialScope: R
        },
        ...T && {
          accountId: T
        }
      };
      if (Q)(0, VyQ.setCredentialFeature)(y, "CREDENTIALS_SSO", "s");
      else(0, VyQ.setCredentialFeature)(y, "CREDENTIALS_SSO_LEGACY", "u");
      return y
    }, "resolveSSOCredentials"),
    zyQ = bdA((A, Q) => {
      let {
        sso_start_url: B,
        sso_account_id: G,
        sso_region: Z,
        sso_role_name: I
      } = A;
      if (!B || !G || !Z || !I) throw new sR.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(A).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, {
        tryNextLink: !1,
        logger: Q
      });
      return A
    }, "validateSsoProfile"),
    pX8 = bdA((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
      let {
        ssoStartUrl: B,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoSession: Y
      } = A, {
        ssoClient: J
      } = A, W = (0, xdA.getProfileName)({
        profile: A.profile ?? Q?.profile
      });
      if (!B && !G && !Z && !I && !Y) {
        let V = (await (0, xdA.parseKnownFiles)(A))[W];
        if (!V) throw new sR.CredentialsProviderError(`Profile ${W} was not found.`, {
          logger: A.logger
        });
        if (!EyQ(V)) throw new sR.CredentialsProviderError(`Profile ${W} is not configured with SSO credentials.`, {
          logger: A.logger
        });
        if (V?.sso_session) {
          let U = (await (0, xdA.loadSsoSessionData)(A))[V.sso_session],
            q = ` configurations in profile ${W} and sso-session ${V.sso_session}`;
          if (Z && Z !== U.sso_region) throw new sR.CredentialsProviderError("Conflicting SSO region" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          if (B && B !== U.sso_start_url) throw new sR.CredentialsProviderError("Conflicting SSO start_url" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          V.sso_region = U.sso_region, V.sso_start_url = U.sso_start_url
        }
        let {
          sso_start_url: F,
          sso_account_id: K,
          sso_region: D,
          sso_role_name: H,
          sso_session: C
        } = zyQ(V, A.logger);
        return FyQ({
          ssoStartUrl: F,
          ssoSession: C,
          ssoAccountId: K,
          ssoRegion: D,
          ssoRoleName: H,
          ssoClient: J,
          clientConfig: A.clientConfig,
          parentClientConfig: A.parentClientConfig,
          profile: W
        })
      } else if (!B || !G || !Z || !I) throw new sR.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', {
        tryNextLink: !1,
        logger: A.logger
      });
      else return FyQ({
        ssoStartUrl: B,
        ssoSession: Y,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoClient: J,
        clientConfig: A.clientConfig,
        parentClientConfig: A.parentClientConfig,
        profile: W
      })
    }, "fromSSO")
})
// @from(Start 3838924, End 3840581)
SP1 = z(($yQ) => {
  Object.defineProperty($yQ, "__esModule", {
    value: !0
  });
  $yQ.resolveHttpAuthSchemeConfig = $yQ.resolveStsAuthConfig = $yQ.defaultSTSHttpAuthSchemeProvider = $yQ.defaultSTSHttpAuthSchemeParametersProvider = void 0;
  var lX8 = PF(),
    jP1 = w7(),
    iX8 = kCA(),
    nX8 = async (A, Q, B) => {
      return {
        operation: (0, jP1.getSmithyContext)(Q).operation,
        region: await (0, jP1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  $yQ.defaultSTSHttpAuthSchemeParametersProvider = nX8;

  function aX8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function sX8(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var rX8 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "AssumeRoleWithWebIdentity": {
        Q.push(sX8(A));
        break
      }
      default:
        Q.push(aX8(A))
    }
    return Q
  };
  $yQ.defaultSTSHttpAuthSchemeProvider = rX8;
  var oX8 = (A) => Object.assign(A, {
    stsClientCtor: iX8.STSClient
  });
  $yQ.resolveStsAuthConfig = oX8;
  var tX8 = (A) => {
    let Q = $yQ.resolveStsAuthConfig(A),
      B = (0, lX8.resolveAwsSdkSigV4Config)(Q);
    return Object.assign(B, {
      authSchemePreference: (0, jP1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  $yQ.resolveHttpAuthSchemeConfig = tX8
})
// @from(Start 3840587, End 3841475)
yCA = z((NyQ) => {
  Object.defineProperty(NyQ, "__esModule", {
    value: !0
  });
  NyQ.commonParams = NyQ.resolveClientEndpointParameters = void 0;
  var QV8 = (A) => {
    return Object.assign(A, {
      useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
      useFipsEndpoint: A.useFipsEndpoint ?? !1,
      useGlobalEndpoint: A.useGlobalEndpoint ?? !1,
      defaultSigningName: "sts"
    })
  };
  NyQ.resolveClientEndpointParameters = QV8;
  NyQ.commonParams = {
    UseGlobalEndpoint: {
      type: "builtInParams",
      name: "useGlobalEndpoint"
    },
    UseFIPS: {
      type: "builtInParams",
      name: "useFipsEndpoint"
    },
    Endpoint: {
      type: "builtInParams",
      name: "endpoint"
    },
    Region: {
      type: "builtInParams",
      name: "region"
    },
    UseDualStack: {
      type: "builtInParams",
      name: "useDualstackEndpoint"
    }
  }
})
// @from(Start 3841481, End 3849658)
nyQ = z((lyQ) => {
  Object.defineProperty(lyQ, "__esModule", {
    value: !0
  });
  lyQ.ruleSet = void 0;
  var vyQ = "required",
    d8 = "type",
    G7 = "fn",
    Z7 = "argv",
    sd = "ref",
    MyQ = !1,
    _P1 = !0,
    ad = "booleanEquals",
    FD = "stringEquals",
    byQ = "sigv4",
    fyQ = "sts",
    hyQ = "us-east-1",
    aI = "endpoint",
    OyQ = "https://sts.{Region}.{PartitionResult#dnsSuffix}",
    lS = "tree",
    d6A = "error",
    yP1 = "getAttr",
    RyQ = {
      [vyQ]: !1,
      [d8]: "String"
    },
    kP1 = {
      [vyQ]: !0,
      default: !1,
      [d8]: "Boolean"
    },
    gyQ = {
      [sd]: "Endpoint"
    },
    TyQ = {
      [G7]: "isSet",
      [Z7]: [{
        [sd]: "Region"
      }]
    },
    KD = {
      [sd]: "Region"
    },
    PyQ = {
      [G7]: "aws.partition",
      [Z7]: [KD],
      assign: "PartitionResult"
    },
    uyQ = {
      [sd]: "UseFIPS"
    },
    myQ = {
      [sd]: "UseDualStack"
    },
    RH = {
      url: "https://sts.amazonaws.com",
      properties: {
        authSchemes: [{
          name: byQ,
          signingName: fyQ,
          signingRegion: hyQ
        }]
      },
      headers: {}
    },
    Sw = {},
    jyQ = {
      conditions: [{
        [G7]: FD,
        [Z7]: [KD, "aws-global"]
      }],
      [aI]: RH,
      [d8]: aI
    },
    dyQ = {
      [G7]: ad,
      [Z7]: [uyQ, !0]
    },
    cyQ = {
      [G7]: ad,
      [Z7]: [myQ, !0]
    },
    SyQ = {
      [G7]: yP1,
      [Z7]: [{
        [sd]: "PartitionResult"
      }, "supportsFIPS"]
    },
    pyQ = {
      [sd]: "PartitionResult"
    },
    _yQ = {
      [G7]: ad,
      [Z7]: [!0, {
        [G7]: yP1,
        [Z7]: [pyQ, "supportsDualStack"]
      }]
    },
    kyQ = [{
      [G7]: "isSet",
      [Z7]: [gyQ]
    }],
    yyQ = [dyQ],
    xyQ = [cyQ],
    GV8 = {
      version: "1.0",
      parameters: {
        Region: RyQ,
        UseDualStack: kP1,
        UseFIPS: kP1,
        Endpoint: RyQ,
        UseGlobalEndpoint: kP1
      },
      rules: [{
        conditions: [{
          [G7]: ad,
          [Z7]: [{
            [sd]: "UseGlobalEndpoint"
          }, _P1]
        }, {
          [G7]: "not",
          [Z7]: kyQ
        }, TyQ, PyQ, {
          [G7]: ad,
          [Z7]: [uyQ, MyQ]
        }, {
          [G7]: ad,
          [Z7]: [myQ, MyQ]
        }],
        rules: [{
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "ap-northeast-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "ap-south-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "ap-southeast-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "ap-southeast-2"]
          }],
          endpoint: RH,
          [d8]: aI
        }, jyQ, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "ca-central-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "eu-central-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "eu-north-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "eu-west-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "eu-west-2"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "eu-west-3"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "sa-east-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, hyQ]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "us-east-2"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "us-west-1"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          conditions: [{
            [G7]: FD,
            [Z7]: [KD, "us-west-2"]
          }],
          endpoint: RH,
          [d8]: aI
        }, {
          endpoint: {
            url: OyQ,
            properties: {
              authSchemes: [{
                name: byQ,
                signingName: fyQ,
                signingRegion: "{Region}"
              }]
            },
            headers: Sw
          },
          [d8]: aI
        }],
        [d8]: lS
      }, {
        conditions: kyQ,
        rules: [{
          conditions: yyQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          [d8]: d6A
        }, {
          conditions: xyQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          [d8]: d6A
        }, {
          endpoint: {
            url: gyQ,
            properties: Sw,
            headers: Sw
          },
          [d8]: aI
        }],
        [d8]: lS
      }, {
        conditions: [TyQ],
        rules: [{
          conditions: [PyQ],
          rules: [{
            conditions: [dyQ, cyQ],
            rules: [{
              conditions: [{
                [G7]: ad,
                [Z7]: [_P1, SyQ]
              }, _yQ],
              rules: [{
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: Sw,
                  headers: Sw
                },
                [d8]: aI
              }],
              [d8]: lS
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              [d8]: d6A
            }],
            [d8]: lS
          }, {
            conditions: yyQ,
            rules: [{
              conditions: [{
                [G7]: ad,
                [Z7]: [SyQ, _P1]
              }],
              rules: [{
                conditions: [{
                  [G7]: FD,
                  [Z7]: [{
                    [G7]: yP1,
                    [Z7]: [pyQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://sts.{Region}.amazonaws.com",
                  properties: Sw,
                  headers: Sw
                },
                [d8]: aI
              }, {
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: Sw,
                  headers: Sw
                },
                [d8]: aI
              }],
              [d8]: lS
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              [d8]: d6A
            }],
            [d8]: lS
          }, {
            conditions: xyQ,
            rules: [{
              conditions: [_yQ],
              rules: [{
                endpoint: {
                  url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: Sw,
                  headers: Sw
                },
                [d8]: aI
              }],
              [d8]: lS
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              [d8]: d6A
            }],
            [d8]: lS
          }, jyQ, {
            endpoint: {
              url: OyQ,
              properties: Sw,
              headers: Sw
            },
            [d8]: aI
          }],
          [d8]: lS
        }],
        [d8]: lS
      }, {
        error: "Invalid Configuration: Missing Region",
        [d8]: d6A
      }]
    };
  lyQ.ruleSet = GV8
})
// @from(Start 3849664, End 3850249)
ryQ = z((ayQ) => {
  Object.defineProperty(ayQ, "__esModule", {
    value: !0
  });
  ayQ.defaultEndpointResolver = void 0;
  var ZV8 = T6A(),
    xP1 = FI(),
    IV8 = nyQ(),
    YV8 = new xP1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    }),
    JV8 = (A, Q = {}) => {
      return YV8.get(A, () => (0, xP1.resolveEndpoint)(IV8.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  ayQ.defaultEndpointResolver = JV8;
  xP1.customEndpointFunctions.aws = ZV8.awsEndpointFunctions
})
// @from(Start 3850255, End 3851664)
QxQ = z((eyQ) => {
  Object.defineProperty(eyQ, "__esModule", {
    value: !0
  });
  eyQ.getRuntimeConfig = void 0;
  var WV8 = PF(),
    XV8 = iB(),
    VV8 = o6(),
    FV8 = NJ(),
    oyQ = ld(),
    tyQ = O2(),
    KV8 = SP1(),
    DV8 = ryQ(),
    HV8 = (A) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: A?.base64Decoder ?? oyQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? oyQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? DV8.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? KV8.defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new WV8.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new XV8.NoAuthSigner
        }],
        logger: A?.logger ?? new VV8.NoOpLogger,
        serviceId: A?.serviceId ?? "STS",
        urlParser: A?.urlParser ?? FV8.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? tyQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? tyQ.toUtf8
      }
    };
  eyQ.getRuntimeConfig = HV8
})
// @from(Start 3851670, End 3854472)
JxQ = z((IxQ) => {
  Object.defineProperty(IxQ, "__esModule", {
    value: !0
  });
  IxQ.getRuntimeConfig = void 0;
  var CV8 = Co(),
    EV8 = CV8.__importDefault(UP1()),
    vP1 = PF(),
    BxQ = LCA(),
    fdA = f8(),
    zV8 = iB(),
    UV8 = RX(),
    GxQ = D6(),
    No = uI(),
    ZxQ = IZ(),
    $V8 = TX(),
    wV8 = KW(),
    qV8 = QxQ(),
    NV8 = o6(),
    LV8 = PX(),
    MV8 = o6(),
    OV8 = (A) => {
      (0, MV8.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, LV8.resolveDefaultsModeConfig)(A),
        B = () => Q().then(NV8.loadConfigsForDefaultMode),
        G = (0, qV8.getRuntimeConfig)(A);
      (0, vP1.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, No.loadConfig)(vP1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? $V8.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, BxQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: EV8.default.version
        }),
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (I) => I.getIdentityProvider("aws.auth#sigv4") || (async (Y) => await A.credentialDefaultProvider(Y?.__config || {})()),
          signer: new vP1.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (I) => I.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new zV8.NoAuthSigner
        }],
        maxAttempts: A?.maxAttempts ?? (0, No.loadConfig)(GxQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, No.loadConfig)(fdA.NODE_REGION_CONFIG_OPTIONS, {
          ...fdA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: ZxQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, No.loadConfig)({
          ...GxQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || wV8.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? UV8.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? ZxQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, No.loadConfig)(fdA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, No.loadConfig)(fdA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, No.loadConfig)(BxQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  IxQ.getRuntimeConfig = OV8
})
// @from(Start 3854478, End 3855497)
VxQ = z((WxQ) => {
  Object.defineProperty(WxQ, "__esModule", {
    value: !0
  });
  WxQ.resolveHttpAuthRuntimeConfig = WxQ.getHttpAuthExtensionConfiguration = void 0;
  var RV8 = (A) => {
    let {
      httpAuthSchemes: Q,
      httpAuthSchemeProvider: B,
      credentials: G
    } = A;
    return {
      setHttpAuthScheme(Z) {
        let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
        if (I === -1) Q.push(Z);
        else Q.splice(I, 1, Z)
      },
      httpAuthSchemes() {
        return Q
      },
      setHttpAuthSchemeProvider(Z) {
        B = Z
      },
      httpAuthSchemeProvider() {
        return B
      },
      setCredentials(Z) {
        G = Z
      },
      credentials() {
        return G
      }
    }
  };
  WxQ.getHttpAuthExtensionConfiguration = RV8;
  var TV8 = (A) => {
    return {
      httpAuthSchemes: A.httpAuthSchemes(),
      httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
      credentials: A.credentials()
    }
  };
  WxQ.resolveHttpAuthRuntimeConfig = TV8
})
// @from(Start 3855503, End 3856228)
zxQ = z((CxQ) => {
  Object.defineProperty(CxQ, "__esModule", {
    value: !0
  });
  CxQ.resolveRuntimeExtensions = void 0;
  var FxQ = OCA(),
    KxQ = az(),
    DxQ = o6(),
    HxQ = VxQ(),
    jV8 = (A, Q) => {
      let B = Object.assign((0, FxQ.getAwsRegionExtensionConfiguration)(A), (0, DxQ.getDefaultExtensionConfiguration)(A), (0, KxQ.getHttpHandlerExtensionConfiguration)(A), (0, HxQ.getHttpAuthExtensionConfiguration)(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, FxQ.resolveAwsRegionExtensionConfiguration)(B), (0, DxQ.resolveDefaultRuntimeConfig)(B), (0, KxQ.resolveHttpHandlerRuntimeConfig)(B), (0, HxQ.resolveHttpAuthRuntimeConfig)(B))
    };
  CxQ.resolveRuntimeExtensions = jV8
})
// @from(Start 3856234, End 3858216)
kCA = z((fP1) => {
  Object.defineProperty(fP1, "__esModule", {
    value: !0
  });
  fP1.STSClient = fP1.__Client = void 0;
  var UxQ = CCA(),
    SV8 = ECA(),
    _V8 = zCA(),
    $xQ = y6A(),
    kV8 = f8(),
    bP1 = iB(),
    yV8 = LX(),
    xV8 = q5(),
    wxQ = D6(),
    NxQ = o6();
  Object.defineProperty(fP1, "__Client", {
    enumerable: !0,
    get: function() {
      return NxQ.Client
    }
  });
  var qxQ = SP1(),
    vV8 = yCA(),
    bV8 = JxQ(),
    fV8 = zxQ();
  class LxQ extends NxQ.Client {
    config;
    constructor(...[A]) {
      let Q = (0, bV8.getRuntimeConfig)(A || {});
      super(Q);
      this.initConfig = Q;
      let B = (0, vV8.resolveClientEndpointParameters)(Q),
        G = (0, $xQ.resolveUserAgentConfig)(B),
        Z = (0, wxQ.resolveRetryConfig)(G),
        I = (0, kV8.resolveRegionConfig)(Z),
        Y = (0, UxQ.resolveHostHeaderConfig)(I),
        J = (0, xV8.resolveEndpointConfig)(Y),
        W = (0, qxQ.resolveHttpAuthSchemeConfig)(J),
        X = (0, fV8.resolveRuntimeExtensions)(W, A?.extensions || []);
      this.config = X, this.middlewareStack.use((0, $xQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, wxQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, yV8.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, UxQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, SV8.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, _V8.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, bP1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: qxQ.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (V) => new bP1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": V.credentials
        })
      })), this.middlewareStack.use((0, bP1.getHttpSigningPlugin)(this.config))
    }
    destroy() {
      super.destroy()
    }
  }
  fP1.STSClient = LxQ
})
// @from(Start 3858222, End 3881594)
Hj1 = z((vO7, Dj1) => {
  var {
    defineProperty: hdA,
    getOwnPropertyDescriptor: hV8,
    getOwnPropertyNames: gV8
  } = Object, uV8 = Object.prototype.hasOwnProperty, y2 = (A, Q) => hdA(A, "name", {
    value: Q,
    configurable: !0
  }), mV8 = (A, Q) => {
    for (var B in Q) hdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Yj1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gV8(Q))
        if (!uV8.call(A, Z) && Z !== B) hdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = hV8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, dV8 = (A, Q, B) => (Yj1(A, Q, "default"), B && Yj1(B, Q, "default")), cV8 = (A) => Yj1(hdA({}, "__esModule", {
    value: !0
  }), A), Wj1 = {};
  mV8(Wj1, {
    AssumeRoleCommand: () => Fj1,
    AssumeRoleResponseFilterSensitiveLog: () => TxQ,
    AssumeRoleWithWebIdentityCommand: () => Kj1,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => xxQ,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => vxQ,
    ClientInputEndpointParameters: () => vF8.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => Xj1,
    ExpiredTokenException: () => PxQ,
    IDPCommunicationErrorException: () => bxQ,
    IDPRejectedClaimException: () => kxQ,
    InvalidIdentityTokenException: () => yxQ,
    MalformedPolicyDocumentException: () => jxQ,
    PackedPolicyTooLargeException: () => SxQ,
    RegionDisabledException: () => _xQ,
    STS: () => nxQ,
    STSServiceException: () => Hb,
    decorateDefaultCredentialProvider: () => hF8,
    getDefaultRoleAssumer: () => exQ,
    getDefaultRoleAssumerWithWebIdentity: () => AvQ
  });
  Dj1.exports = cV8(Wj1);
  dV8(Wj1, kCA(), Dj1.exports);
  var pV8 = o6(),
    lV8 = q5(),
    iV8 = GZ(),
    nV8 = o6(),
    aV8 = yCA(),
    RxQ = o6(),
    sV8 = o6(),
    Hb = class A extends sV8.ServiceException {
      static {
        y2(this, "STSServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    Xj1 = y2((A) => ({
      ...A,
      ...A.SecretAccessKey && {
        SecretAccessKey: RxQ.SENSITIVE_STRING
      }
    }), "CredentialsFilterSensitiveLog"),
    TxQ = y2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: Xj1(A.Credentials)
      }
    }), "AssumeRoleResponseFilterSensitiveLog"),
    PxQ = class A extends Hb {
      static {
        y2(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    jxQ = class A extends Hb {
      static {
        y2(this, "MalformedPolicyDocumentException")
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    SxQ = class A extends Hb {
      static {
        y2(this, "PackedPolicyTooLargeException")
      }
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    _xQ = class A extends Hb {
      static {
        y2(this, "RegionDisabledException")
      }
      name = "RegionDisabledException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    kxQ = class A extends Hb {
      static {
        y2(this, "IDPRejectedClaimException")
      }
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    yxQ = class A extends Hb {
      static {
        y2(this, "InvalidIdentityTokenException")
      }
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    xxQ = y2((A) => ({
      ...A,
      ...A.WebIdentityToken && {
        WebIdentityToken: RxQ.SENSITIVE_STRING
      }
    }), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog"),
    vxQ = y2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: Xj1(A.Credentials)
      }
    }), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog"),
    bxQ = class A extends Hb {
      static {
        y2(this, "IDPCommunicationErrorException")
      }
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    Vj1 = PF(),
    rV8 = az(),
    M7 = o6(),
    oV8 = y2(async (A, Q) => {
      let B = dxQ,
        G;
      return G = ixQ({
        ...WF8(A, Q),
        [pxQ]: RF8,
        [lxQ]: cxQ
      }), mxQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleCommand"),
    tV8 = y2(async (A, Q) => {
      let B = dxQ,
        G;
      return G = ixQ({
        ...XF8(A, Q),
        [pxQ]: TF8,
        [lxQ]: cxQ
      }), mxQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleWithWebIdentityCommand"),
    eV8 = y2(async (A, Q) => {
      if (A.statusCode >= 300) return fxQ(A, Q);
      let B = await (0, Vj1.parseXmlBody)(A.body, Q),
        G = {};
      return G = EF8(B.AssumeRoleResult, Q), {
        $metadata: Cb(A),
        ...G
      }
    }, "de_AssumeRoleCommand"),
    AF8 = y2(async (A, Q) => {
      if (A.statusCode >= 300) return fxQ(A, Q);
      let B = await (0, Vj1.parseXmlBody)(A.body, Q),
        G = {};
      return G = zF8(B.AssumeRoleWithWebIdentityResult, Q), {
        $metadata: Cb(A),
        ...G
      }
    }, "de_AssumeRoleWithWebIdentityCommand"),
    fxQ = y2(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, Vj1.parseXmlErrorBody)(A.body, Q)
        },
        G = PF8(A, B.body);
      switch (G) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await QF8(B, Q);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await IF8(B, Q);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await YF8(B, Q);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await JF8(B, Q);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await BF8(B, Q);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await GF8(B, Q);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await ZF8(B, Q);
        default:
          let Z = B.body;
          return OF8({
            output: A,
            parsedBody: Z.Error,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    QF8 = y2(async (A, Q) => {
      let B = A.body,
        G = UF8(B.Error, Q),
        Z = new PxQ({
          $metadata: Cb(A),
          ...G
        });
      return (0, M7.decorateServiceException)(Z, B)
    }, "de_ExpiredTokenExceptionRes"),
    BF8 = y2(async (A, Q) => {
      let B = A.body,
        G = $F8(B.Error, Q),
        Z = new bxQ({
          $metadata: Cb(A),
          ...G
        });
      return (0, M7.decorateServiceException)(Z, B)
    }, "de_IDPCommunicationErrorExceptionRes"),
    GF8 = y2(async (A, Q) => {
      let B = A.body,
        G = wF8(B.Error, Q),
        Z = new kxQ({
          $metadata: Cb(A),
          ...G
        });
      return (0, M7.decorateServiceException)(Z, B)
    }, "de_IDPRejectedClaimExceptionRes"),
    ZF8 = y2(async (A, Q) => {
      let B = A.body,
        G = qF8(B.Error, Q),
        Z = new yxQ({
          $metadata: Cb(A),
          ...G
        });
      return (0, M7.decorateServiceException)(Z, B)
    }, "de_InvalidIdentityTokenExceptionRes"),
    IF8 = y2(async (A, Q) => {
      let B = A.body,
        G = NF8(B.Error, Q),
        Z = new jxQ({
          $metadata: Cb(A),
          ...G
        });
      return (0, M7.decorateServiceException)(Z, B)
    }, "de_MalformedPolicyDocumentExceptionRes"),
    YF8 = y2(async (A, Q) => {
      let B = A.body,
        G = LF8(B.Error, Q),
        Z = new SxQ({
          $metadata: Cb(A),
          ...G
        });
      return (0, M7.decorateServiceException)(Z, B)
    }, "de_PackedPolicyTooLargeExceptionRes"),
    JF8 = y2(async (A, Q) => {
      let B = A.body,
        G = MF8(B.Error, Q),
        Z = new _xQ({
          $metadata: Cb(A),
          ...G
        });
      return (0, M7.decorateServiceException)(Z, B)
    }, "de_RegionDisabledExceptionRes"),
    WF8 = y2((A, Q) => {
      let B = {};
      if (A[s6A] != null) B[s6A] = A[s6A];
      if (A[r6A] != null) B[r6A] = A[r6A];
      if (A[n6A] != null) {
        let G = hxQ(A[n6A], Q);
        if (A[n6A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[i6A] != null) B[i6A] = A[i6A];
      if (A[l6A] != null) B[l6A] = A[l6A];
      if (A[Aj1] != null) {
        let G = CF8(A[Aj1], Q);
        if (A[Aj1]?.length === 0) B.Tags = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `Tags.${Z}`;
          B[Y] = I
        })
      }
      if (A[Bj1] != null) {
        let G = HF8(A[Bj1], Q);
        if (A[Bj1]?.length === 0) B.TransitiveTagKeys = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `TransitiveTagKeys.${Z}`;
          B[Y] = I
        })
      }
      if (A[pP1] != null) B[pP1] = A[pP1];
      if (A[tP1] != null) B[tP1] = A[tP1];
      if (A[Qj1] != null) B[Qj1] = A[Qj1];
      if (A[Db] != null) B[Db] = A[Db];
      if (A[nP1] != null) {
        let G = KF8(A[nP1], Q);
        if (A[nP1]?.length === 0) B.ProvidedContexts = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `ProvidedContexts.${Z}`;
          B[Y] = I
        })
      }
      return B
    }, "se_AssumeRoleRequest"),
    XF8 = y2((A, Q) => {
      let B = {};
      if (A[s6A] != null) B[s6A] = A[s6A];
      if (A[r6A] != null) B[r6A] = A[r6A];
      if (A[Zj1] != null) B[Zj1] = A[Zj1];
      if (A[aP1] != null) B[aP1] = A[aP1];
      if (A[n6A] != null) {
        let G = hxQ(A[n6A], Q);
        if (A[n6A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[i6A] != null) B[i6A] = A[i6A];
      if (A[l6A] != null) B[l6A] = A[l6A];
      return B
    }, "se_AssumeRoleWithWebIdentityRequest"),
    hxQ = y2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = VF8(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_policyDescriptorListType"),
    VF8 = y2((A, Q) => {
      let B = {};
      if (A[Ij1] != null) B[Ij1] = A[Ij1];
      return B
    }, "se_PolicyDescriptorType"),
    FF8 = y2((A, Q) => {
      let B = {};
      if (A[iP1] != null) B[iP1] = A[iP1];
      if (A[dP1] != null) B[dP1] = A[dP1];
      return B
    }, "se_ProvidedContext"),
    KF8 = y2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = FF8(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_ProvidedContextsListType"),
    DF8 = y2((A, Q) => {
      let B = {};
      if (A[lP1] != null) B[lP1] = A[lP1];
      if (A[Gj1] != null) B[Gj1] = A[Gj1];
      return B
    }, "se_Tag"),
    HF8 = y2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        B[`member.${G}`] = Z, G++
      }
      return B
    }, "se_tagKeyListType"),
    CF8 = y2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = DF8(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_tagListType"),
    gxQ = y2((A, Q) => {
      let B = {};
      if (A[gP1] != null) B[gP1] = (0, M7.expectString)(A[gP1]);
      if (A[uP1] != null) B[uP1] = (0, M7.expectString)(A[uP1]);
      return B
    }, "de_AssumedRoleUser"),
    EF8 = y2((A, Q) => {
      let B = {};
      if (A[p6A] != null) B[p6A] = uxQ(A[p6A], Q);
      if (A[c6A] != null) B[c6A] = gxQ(A[c6A], Q);
      if (A[a6A] != null) B[a6A] = (0, M7.strictParseInt32)(A[a6A]);
      if (A[Db] != null) B[Db] = (0, M7.expectString)(A[Db]);
      return B
    }, "de_AssumeRoleResponse"),
    zF8 = y2((A, Q) => {
      let B = {};
      if (A[p6A] != null) B[p6A] = uxQ(A[p6A], Q);
      if (A[oP1] != null) B[oP1] = (0, M7.expectString)(A[oP1]);
      if (A[c6A] != null) B[c6A] = gxQ(A[c6A], Q);
      if (A[a6A] != null) B[a6A] = (0, M7.strictParseInt32)(A[a6A]);
      if (A[sP1] != null) B[sP1] = (0, M7.expectString)(A[sP1]);
      if (A[mP1] != null) B[mP1] = (0, M7.expectString)(A[mP1]);
      if (A[Db] != null) B[Db] = (0, M7.expectString)(A[Db]);
      return B
    }, "de_AssumeRoleWithWebIdentityResponse"),
    uxQ = y2((A, Q) => {
      let B = {};
      if (A[hP1] != null) B[hP1] = (0, M7.expectString)(A[hP1]);
      if (A[rP1] != null) B[rP1] = (0, M7.expectString)(A[rP1]);
      if (A[eP1] != null) B[eP1] = (0, M7.expectString)(A[eP1]);
      if (A[cP1] != null) B[cP1] = (0, M7.expectNonNull)((0, M7.parseRfc3339DateTimeWithOffset)(A[cP1]));
      return B
    }, "de_Credentials"),
    UF8 = y2((A, Q) => {
      let B = {};
      if (A[wW] != null) B[wW] = (0, M7.expectString)(A[wW]);
      return B
    }, "de_ExpiredTokenException"),
    $F8 = y2((A, Q) => {
      let B = {};
      if (A[wW] != null) B[wW] = (0, M7.expectString)(A[wW]);
      return B
    }, "de_IDPCommunicationErrorException"),
    wF8 = y2((A, Q) => {
      let B = {};
      if (A[wW] != null) B[wW] = (0, M7.expectString)(A[wW]);
      return B
    }, "de_IDPRejectedClaimException"),
    qF8 = y2((A, Q) => {
      let B = {};
      if (A[wW] != null) B[wW] = (0, M7.expectString)(A[wW]);
      return B
    }, "de_InvalidIdentityTokenException"),
    NF8 = y2((A, Q) => {
      let B = {};
      if (A[wW] != null) B[wW] = (0, M7.expectString)(A[wW]);
      return B
    }, "de_MalformedPolicyDocumentException"),
    LF8 = y2((A, Q) => {
      let B = {};
      if (A[wW] != null) B[wW] = (0, M7.expectString)(A[wW]);
      return B
    }, "de_PackedPolicyTooLargeException"),
    MF8 = y2((A, Q) => {
      let B = {};
      if (A[wW] != null) B[wW] = (0, M7.expectString)(A[wW]);
      return B
    }, "de_RegionDisabledException"),
    Cb = y2((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    OF8 = (0, M7.withBaseException)(Hb),
    mxQ = y2(async (A, Q, B, G, Z) => {
      let {
        hostname: I,
        protocol: Y = "https",
        port: J,
        path: W
      } = await A.endpoint(), X = {
        protocol: Y,
        hostname: I,
        port: J,
        method: "POST",
        path: W.endsWith("/") ? W.slice(0, -1) + B : W + B,
        headers: Q
      };
      if (G !== void 0) X.hostname = G;
      if (Z !== void 0) X.body = Z;
      return new rV8.HttpRequest(X)
    }, "buildHttpRpcRequest"),
    dxQ = {
      "content-type": "application/x-www-form-urlencoded"
    },
    cxQ = "2011-06-15",
    pxQ = "Action",
    hP1 = "AccessKeyId",
    RF8 = "AssumeRole",
    gP1 = "AssumedRoleId",
    c6A = "AssumedRoleUser",
    TF8 = "AssumeRoleWithWebIdentity",
    uP1 = "Arn",
    mP1 = "Audience",
    p6A = "Credentials",
    dP1 = "ContextAssertion",
    l6A = "DurationSeconds",
    cP1 = "Expiration",
    pP1 = "ExternalId",
    lP1 = "Key",
    i6A = "Policy",
    n6A = "PolicyArns",
    iP1 = "ProviderArn",
    nP1 = "ProvidedContexts",
    aP1 = "ProviderId",
    a6A = "PackedPolicySize",
    sP1 = "Provider",
    s6A = "RoleArn",
    r6A = "RoleSessionName",
    rP1 = "SecretAccessKey",
    oP1 = "SubjectFromWebIdentityToken",
    Db = "SourceIdentity",
    tP1 = "SerialNumber",
    eP1 = "SessionToken",
    Aj1 = "Tags",
    Qj1 = "TokenCode",
    Bj1 = "TransitiveTagKeys",
    lxQ = "Version",
    Gj1 = "Value",
    Zj1 = "WebIdentityToken",
    Ij1 = "arn",
    wW = "message",
    ixQ = y2((A) => Object.entries(A).map(([Q, B]) => (0, M7.extendedEncodeURIComponent)(Q) + "=" + (0, M7.extendedEncodeURIComponent)(B)).join("&"), "buildFormUrlencodedString"),
    PF8 = y2((A, Q) => {
      if (Q.Error?.Code !== void 0) return Q.Error.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadQueryErrorCode"),
    Fj1 = class extends nV8.Command.classBuilder().ep(aV8.commonParams).m(function(A, Q, B, G) {
      return [(0, iV8.getSerdePlugin)(B, this.serialize, this.deserialize), (0, lV8.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(void 0, TxQ).ser(oV8).de(eV8).build() {
      static {
        y2(this, "AssumeRoleCommand")
      }
    },
    jF8 = q5(),
    SF8 = GZ(),
    _F8 = o6(),
    kF8 = yCA(),
    Kj1 = class extends _F8.Command.classBuilder().ep(kF8.commonParams).m(function(A, Q, B, G) {
      return [(0, SF8.getSerdePlugin)(B, this.serialize, this.deserialize), (0, jF8.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(xxQ, vxQ).ser(tV8).de(AF8).build() {
      static {
        y2(this, "AssumeRoleWithWebIdentityCommand")
      }
    },
    yF8 = kCA(),
    xF8 = {
      AssumeRoleCommand: Fj1,
      AssumeRoleWithWebIdentityCommand: Kj1
    },
    nxQ = class extends yF8.STSClient {
      static {
        y2(this, "STS")
      }
    };
  (0, pV8.createAggregatedClient)(xF8, nxQ);
  var vF8 = yCA(),
    Jj1 = aR(),
    OxQ = "us-east-1",
    axQ = y2((A) => {
      if (typeof A?.Arn === "string") {
        let Q = A.Arn.split(":");
        if (Q.length > 4 && Q[4] !== "") return Q[4]
      }
      return
    }, "getAccountIdFromAssumedRoleUser"),
    sxQ = y2(async (A, Q, B) => {
      let G = typeof A === "function" ? await A() : A,
        Z = typeof Q === "function" ? await Q() : Q;
      return B?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${G} (provider)`, `${Z} (parent client)`, `${OxQ} (STS default)`), G ?? Z ?? OxQ
    }, "resolveRegion"),
    bF8 = y2((A, Q) => {
      let B, G;
      return async (Z, I) => {
        if (G = Z, !B) {
          let {
            logger: V = A?.parentClientConfig?.logger,
            region: F,
            requestHandler: K = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: D
          } = A, H = await sxQ(F, A?.parentClientConfig?.region, D), C = !rxQ(K);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            credentialDefaultProvider: y2(() => async () => G, "credentialDefaultProvider"),
            region: H,
            requestHandler: C ? K : void 0,
            logger: V
          })
        }
        let {
          Credentials: Y,
          AssumedRoleUser: J
        } = await B.send(new Fj1(I));
        if (!Y || !Y.AccessKeyId || !Y.SecretAccessKey) throw Error(`Invalid response from STS.assumeRole call with role ${I.RoleArn}`);
        let W = axQ(J),
          X = {
            accessKeyId: Y.AccessKeyId,
            secretAccessKey: Y.SecretAccessKey,
            sessionToken: Y.SessionToken,
            expiration: Y.Expiration,
            ...Y.CredentialScope && {
              credentialScope: Y.CredentialScope
            },
            ...W && {
              accountId: W
            }
          };
        return (0, Jj1.setCredentialFeature)(X, "CREDENTIALS_STS_ASSUME_ROLE", "i"), X
      }
    }, "getDefaultRoleAssumer"),
    fF8 = y2((A, Q) => {
      let B;
      return async (G) => {
        if (!B) {
          let {
            logger: W = A?.parentClientConfig?.logger,
            region: X,
            requestHandler: V = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: F
          } = A, K = await sxQ(X, A?.parentClientConfig?.region, F), D = !rxQ(V);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            region: K,
            requestHandler: D ? V : void 0,
            logger: W
          })
        }
        let {
          Credentials: Z,
          AssumedRoleUser: I
        } = await B.send(new Kj1(G));
        if (!Z || !Z.AccessKeyId || !Z.SecretAccessKey) throw Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${G.RoleArn}`);
        let Y = axQ(I),
          J = {
            accessKeyId: Z.AccessKeyId,
            secretAccessKey: Z.SecretAccessKey,
            sessionToken: Z.SessionToken,
            expiration: Z.Expiration,
            ...Z.CredentialScope && {
              credentialScope: Z.CredentialScope
            },
            ...Y && {
              accountId: Y
            }
          };
        if (Y)(0, Jj1.setCredentialFeature)(J, "RESOLVED_ACCOUNT_ID", "T");
        return (0, Jj1.setCredentialFeature)(J, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"), J
      }
    }, "getDefaultRoleAssumerWithWebIdentity"),
    rxQ = y2((A) => {
      return A?.metadata?.handlerProtocol === "h2"
    }, "isH2"),
    oxQ = kCA(),
    txQ = y2((A, Q) => {
      if (!Q) return A;
      else return class extends A {
        static {
          y2(this, "CustomizableSTSClient")
        }
        constructor(G) {
          super(G);
          for (let Z of Q) this.middlewareStack.use(Z)
        }
      }
    }, "getCustomizableStsClientCtor"),
    exQ = y2((A = {}, Q) => bF8(A, txQ(oxQ.STSClient, Q)), "getDefaultRoleAssumer"),
    AvQ = y2((A = {}, Q) => fF8(A, txQ(oxQ.STSClient, Q)), "getDefaultRoleAssumerWithWebIdentity"),
    hF8 = y2((A) => (Q) => A({
      roleAssumer: exQ(Q),
      roleAssumerWithWebIdentity: AvQ(Q),
      ...Q
    }), "decorateDefaultCredentialProvider")
})
// @from(Start 3881600, End 3884842)
zj1 = z((gO7, GvQ) => {
  var {
    defineProperty: gdA,
    getOwnPropertyDescriptor: gF8,
    getOwnPropertyNames: uF8
  } = Object, mF8 = Object.prototype.hasOwnProperty, Ej1 = (A, Q) => gdA(A, "name", {
    value: Q,
    configurable: !0
  }), dF8 = (A, Q) => {
    for (var B in Q) gdA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, cF8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of uF8(Q))
        if (!mF8.call(A, Z) && Z !== B) gdA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = gF8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, pF8 = (A) => cF8(gdA({}, "__esModule", {
    value: !0
  }), A), BvQ = {};
  dF8(BvQ, {
    fromProcess: () => rF8
  });
  GvQ.exports = pF8(BvQ);
  var QvQ = SG(),
    Cj1 = j2(),
    lF8 = UA("child_process"),
    iF8 = UA("util"),
    nF8 = aR(),
    aF8 = Ej1((A, Q, B) => {
      if (Q.Version !== 1) throw Error(`Profile ${A} credential_process did not return Version 1.`);
      if (Q.AccessKeyId === void 0 || Q.SecretAccessKey === void 0) throw Error(`Profile ${A} credential_process returned invalid credentials.`);
      if (Q.Expiration) {
        let I = new Date;
        if (new Date(Q.Expiration) < I) throw Error(`Profile ${A} credential_process returned expired credentials.`)
      }
      let G = Q.AccountId;
      if (!G && B?.[A]?.aws_account_id) G = B[A].aws_account_id;
      let Z = {
        accessKeyId: Q.AccessKeyId,
        secretAccessKey: Q.SecretAccessKey,
        ...Q.SessionToken && {
          sessionToken: Q.SessionToken
        },
        ...Q.Expiration && {
          expiration: new Date(Q.Expiration)
        },
        ...Q.CredentialScope && {
          credentialScope: Q.CredentialScope
        },
        ...G && {
          accountId: G
        }
      };
      return (0, nF8.setCredentialFeature)(Z, "CREDENTIALS_PROCESS", "w"), Z
    }, "getValidatedProcessCredentials"),
    sF8 = Ej1(async (A, Q, B) => {
      let G = Q[A];
      if (Q[A]) {
        let Z = G.credential_process;
        if (Z !== void 0) {
          let I = (0, iF8.promisify)(lF8.exec);
          try {
            let {
              stdout: Y
            } = await I(Z), J;
            try {
              J = JSON.parse(Y.trim())
            } catch {
              throw Error(`Profile ${A} credential_process returned invalid JSON.`)
            }
            return aF8(A, J, Q)
          } catch (Y) {
            throw new Cj1.CredentialsProviderError(Y.message, {
              logger: B
            })
          }
        } else throw new Cj1.CredentialsProviderError(`Profile ${A} did not contain credential_process.`, {
          logger: B
        })
      } else throw new Cj1.CredentialsProviderError(`Profile ${A} could not be found in shared credentials file.`, {
        logger: B
      })
    }, "resolveProcessCredentials"),
    rF8 = Ej1((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
      let B = await (0, QvQ.parseKnownFiles)(A);
      return sF8((0, QvQ.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), B, A.logger)
    }, "fromProcess")
})
// @from(Start 3884848, End 3887172)
Uj1 = z((iS) => {
  var oF8 = iS && iS.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    tF8 = iS && iS.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    eF8 = iS && iS.__importStar || function() {
      var A = function(Q) {
        return A = Object.getOwnPropertyNames || function(B) {
          var G = [];
          for (var Z in B)
            if (Object.prototype.hasOwnProperty.call(B, Z)) G[G.length] = Z;
          return G
        }, A(Q)
      };
      return function(Q) {
        if (Q && Q.__esModule) return Q;
        var B = {};
        if (Q != null) {
          for (var G = A(Q), Z = 0; Z < G.length; Z++)
            if (G[Z] !== "default") oF8(B, Q, G[Z])
        }
        return tF8(B, Q), B
      }
    }();
  Object.defineProperty(iS, "__esModule", {
    value: !0
  });
  iS.fromWebToken = void 0;
  var AK8 = (A) => async (Q) => {
    A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    let {
      roleArn: B,
      roleSessionName: G,
      webIdentityToken: Z,
      providerId: I,
      policyArns: Y,
      policy: J,
      durationSeconds: W
    } = A, {
      roleAssumerWithWebIdentity: X
    } = A;
    if (!X) {
      let {
        getDefaultRoleAssumerWithWebIdentity: V
      } = await Promise.resolve().then(() => eF8(Hj1()));
      X = V({
        ...A.clientConfig,
        credentialProviderLogger: A.logger,
        parentClientConfig: {
          ...Q?.callerClientConfig,
          ...A.parentClientConfig
        }
      }, A.clientPlugins)
    }
    return X({
      RoleArn: B,
      RoleSessionName: G ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: Z,
      ProviderId: I,
      PolicyArns: Y,
      Policy: J,
      DurationSeconds: W
    })
  };
  iS.fromWebToken = AK8
})
// @from(Start 3887178, End 3888253)
JvQ = z((IvQ) => {
  Object.defineProperty(IvQ, "__esModule", {
    value: !0
  });
  IvQ.fromTokenFile = void 0;
  var QK8 = aR(),
    BK8 = j2(),
    GK8 = UA("fs"),
    ZK8 = Uj1(),
    ZvQ = "AWS_WEB_IDENTITY_TOKEN_FILE",
    IK8 = "AWS_ROLE_ARN",
    YK8 = "AWS_ROLE_SESSION_NAME",
    JK8 = (A = {}) => async () => {
      A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
      let Q = A?.webIdentityTokenFile ?? process.env[ZvQ],
        B = A?.roleArn ?? process.env[IK8],
        G = A?.roleSessionName ?? process.env[YK8];
      if (!Q || !B) throw new BK8.CredentialsProviderError("Web identity configuration not specified", {
        logger: A.logger
      });
      let Z = await (0, ZK8.fromWebToken)({
        ...A,
        webIdentityToken: (0, GK8.readFileSync)(Q, {
          encoding: "ascii"
        }),
        roleArn: B,
        roleSessionName: G
      })();
      if (Q === process.env[ZvQ])(0, QK8.setCredentialFeature)(Z, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
      return Z
    };
  IvQ.fromTokenFile = JK8
})
// @from(Start 3888259, End 3888955)
qj1 = z((dO7, udA) => {
  var {
    defineProperty: WvQ,
    getOwnPropertyDescriptor: WK8,
    getOwnPropertyNames: XK8
  } = Object, VK8 = Object.prototype.hasOwnProperty, $j1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of XK8(Q))
        if (!VK8.call(A, Z) && Z !== B) WvQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = WK8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, XvQ = (A, Q, B) => ($j1(A, Q, "default"), B && $j1(B, Q, "default")), FK8 = (A) => $j1(WvQ({}, "__esModule", {
    value: !0
  }), A), wj1 = {};
  udA.exports = FK8(wj1);
  XvQ(wj1, JvQ(), udA.exports);
  XvQ(wj1, Uj1(), udA.exports)
})
// @from(Start 3888961, End 3898683)
zvQ = z((cO7, EvQ) => {
  var {
    create: KK8,
    defineProperty: vCA,
    getOwnPropertyDescriptor: DK8,
    getOwnPropertyNames: HK8,
    getPrototypeOf: CK8
  } = Object, EK8 = Object.prototype.hasOwnProperty, yX = (A, Q) => vCA(A, "name", {
    value: Q,
    configurable: !0
  }), zK8 = (A, Q) => {
    for (var B in Q) vCA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, DvQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of HK8(Q))
        if (!EK8.call(A, Z) && Z !== B) vCA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = DK8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, rd = (A, Q, B) => (B = A != null ? KK8(CK8(A)) : {}, DvQ(Q || !A || !A.__esModule ? vCA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), UK8 = (A) => DvQ(vCA({}, "__esModule", {
    value: !0
  }), A), HvQ = {};
  zK8(HvQ, {
    fromIni: () => SK8
  });
  EvQ.exports = UK8(HvQ);
  var Lj1 = SG(),
    od = aR(),
    xCA = j2(),
    $K8 = yX((A, Q, B) => {
      let G = {
        EcsContainer: yX(async (Z) => {
          let {
            fromHttp: I
          } = await Promise.resolve().then(() => rd(JP1())), {
            fromContainerMetadata: Y
          } = await Promise.resolve().then(() => rd(OV()));
          return B?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => (0, xCA.chain)(I(Z ?? {}), Y(Z))().then(Nj1)
        }, "EcsContainer"),
        Ec2InstanceMetadata: yX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
          let {
            fromInstanceMetadata: I
          } = await Promise.resolve().then(() => rd(OV()));
          return async () => I(Z)().then(Nj1)
        }, "Ec2InstanceMetadata"),
        Environment: yX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
          let {
            fromEnv: I
          } = await Promise.resolve().then(() => rd(ZP1()));
          return async () => I(Z)().then(Nj1)
        }, "Environment")
      };
      if (A in G) return G[A];
      else throw new xCA.CredentialsProviderError(`Unsupported credential source in profile ${Q}. Got ${A}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, {
        logger: B
      })
    }, "resolveCredentialSource"),
    Nj1 = yX((A) => (0, od.setCredentialFeature)(A, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"), "setNamedProvider"),
    wK8 = yX((A, {
      profile: Q = "default",
      logger: B
    } = {}) => {
      return Boolean(A) && typeof A === "object" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof A.external_id) > -1 && ["undefined", "string"].indexOf(typeof A.mfa_serial) > -1 && (qK8(A, {
        profile: Q,
        logger: B
      }) || NK8(A, {
        profile: Q,
        logger: B
      }))
    }, "isAssumeRoleProfile"),
    qK8 = yX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.source_profile === "string" && typeof A.credential_source > "u";
      if (G) B?.debug?.(`    ${Q} isAssumeRoleWithSourceProfile source_profile=${A.source_profile}`);
      return G
    }, "isAssumeRoleWithSourceProfile"),
    NK8 = yX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.credential_source === "string" && typeof A.source_profile > "u";
      if (G) B?.debug?.(`    ${Q} isCredentialSourceProfile credential_source=${A.credential_source}`);
      return G
    }, "isCredentialSourceProfile"),
    LK8 = yX(async (A, Q, B, G = {}) => {
      B.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
      let Z = Q[A],
        {
          source_profile: I,
          region: Y
        } = Z;
      if (!B.roleAssumer) {
        let {
          getDefaultRoleAssumer: W
        } = await Promise.resolve().then(() => rd(Hj1()));
        B.roleAssumer = W({
          ...B.clientConfig,
          credentialProviderLogger: B.logger,
          parentClientConfig: {
            ...B?.parentClientConfig,
            region: Y ?? B?.parentClientConfig?.region
          }
        }, B.clientPlugins)
      }
      if (I && I in G) throw new xCA.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${(0,Lj1.getProfileName)(B)}. Profiles visited: ` + Object.keys(G).join(", "), {
        logger: B.logger
      });
      B.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${I?`source_profile=[${I}]`:`profile=[${A}]`}`);
      let J = I ? CvQ(I, Q, B, {
        ...G,
        [I]: !0
      }, VvQ(Q[I] ?? {})) : (await $K8(Z.credential_source, A, B.logger)(B))();
      if (VvQ(Z)) return J.then((W) => (0, od.setCredentialFeature)(W, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      else {
        let W = {
            RoleArn: Z.role_arn,
            RoleSessionName: Z.role_session_name || `aws-sdk-js-${Date.now()}`,
            ExternalId: Z.external_id,
            DurationSeconds: parseInt(Z.duration_seconds || "3600", 10)
          },
          {
            mfa_serial: X
          } = Z;
        if (X) {
          if (!B.mfaCodeProvider) throw new xCA.CredentialsProviderError(`Profile ${A} requires multi-factor authentication, but no MFA code callback was provided.`, {
            logger: B.logger,
            tryNextLink: !1
          });
          W.SerialNumber = X, W.TokenCode = await B.mfaCodeProvider(X)
        }
        let V = await J;
        return B.roleAssumer(V, W).then((F) => (0, od.setCredentialFeature)(F, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"))
      }
    }, "resolveAssumeRoleCredentials"),
    VvQ = yX((A) => {
      return !A.role_arn && !!A.credential_source
    }, "isCredentialSourceWithoutRoleArn"),
    MK8 = yX((A) => Boolean(A) && typeof A === "object" && typeof A.credential_process === "string", "isProcessProfile"),
    OK8 = yX(async (A, Q) => Promise.resolve().then(() => rd(zj1())).then(({
      fromProcess: B
    }) => B({
      ...A,
      profile: Q
    })().then((G) => (0, od.setCredentialFeature)(G, "CREDENTIALS_PROFILE_PROCESS", "v"))), "resolveProcessCredentials"),
    RK8 = yX(async (A, Q, B = {}) => {
      let {
        fromSSO: G
      } = await Promise.resolve().then(() => rd(PP1()));
      return G({
        profile: A,
        logger: B.logger,
        parentClientConfig: B.parentClientConfig,
        clientConfig: B.clientConfig
      })().then((Z) => {
        if (Q.sso_session) return (0, od.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO", "r");
        else return (0, od.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      })
    }, "resolveSsoCredentials"),
    TK8 = yX((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    FvQ = yX((A) => Boolean(A) && typeof A === "object" && typeof A.aws_access_key_id === "string" && typeof A.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof A.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof A.aws_account_id) > -1, "isStaticCredsProfile"),
    KvQ = yX(async (A, Q) => {
      Q?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
      let B = {
        accessKeyId: A.aws_access_key_id,
        secretAccessKey: A.aws_secret_access_key,
        sessionToken: A.aws_session_token,
        ...A.aws_credential_scope && {
          credentialScope: A.aws_credential_scope
        },
        ...A.aws_account_id && {
          accountId: A.aws_account_id
        }
      };
      return (0, od.setCredentialFeature)(B, "CREDENTIALS_PROFILE", "n")
    }, "resolveStaticCredentials"),
    PK8 = yX((A) => Boolean(A) && typeof A === "object" && typeof A.web_identity_token_file === "string" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1, "isWebIdentityProfile"),
    jK8 = yX(async (A, Q) => Promise.resolve().then(() => rd(qj1())).then(({
      fromTokenFile: B
    }) => B({
      webIdentityTokenFile: A.web_identity_token_file,
      roleArn: A.role_arn,
      roleSessionName: A.role_session_name,
      roleAssumerWithWebIdentity: Q.roleAssumerWithWebIdentity,
      logger: Q.logger,
      parentClientConfig: Q.parentClientConfig
    })().then((G) => (0, od.setCredentialFeature)(G, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))), "resolveWebIdentityCredentials"),
    CvQ = yX(async (A, Q, B, G = {}, Z = !1) => {
      let I = Q[A];
      if (Object.keys(G).length > 0 && FvQ(I)) return KvQ(I, B);
      if (Z || wK8(I, {
          profile: A,
          logger: B.logger
        })) return LK8(A, Q, B, G);
      if (FvQ(I)) return KvQ(I, B);
      if (PK8(I)) return jK8(I, B);
      if (MK8(I)) return OK8(B, A);
      if (TK8(I)) return await RK8(A, I, B);
      throw new xCA.CredentialsProviderError(`Could not resolve credentials using profile: [${A}] in configuration/credentials file(s).`, {
        logger: B.logger
      })
    }, "resolveProfileData"),
    SK8 = yX((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
      let G = await (0, Lj1.parseKnownFiles)(B);
      return CvQ((0, Lj1.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), G, B)
    }, "fromIni")
})
// @from(Start 3898689, End 3903651)
OvQ = z((pO7, MvQ) => {
  var {
    create: _K8,
    defineProperty: bCA,
    getOwnPropertyDescriptor: kK8,
    getOwnPropertyNames: yK8,
    getPrototypeOf: xK8
  } = Object, vK8 = Object.prototype.hasOwnProperty, mdA = (A, Q) => bCA(A, "name", {
    value: Q,
    configurable: !0
  }), bK8 = (A, Q) => {
    for (var B in Q) bCA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, wvQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of yK8(Q))
        if (!vK8.call(A, Z) && Z !== B) bCA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = kK8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, o6A = (A, Q, B) => (B = A != null ? _K8(xK8(A)) : {}, wvQ(Q || !A || !A.__esModule ? bCA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), fK8 = (A) => wvQ(bCA({}, "__esModule", {
    value: !0
  }), A), qvQ = {};
  bK8(qvQ, {
    credentialsTreatedAsExpired: () => LvQ,
    credentialsWillNeedRefresh: () => NvQ,
    defaultProvider: () => uK8
  });
  MvQ.exports = fK8(qvQ);
  var Mj1 = ZP1(),
    hK8 = SG(),
    Lo = j2(),
    UvQ = "AWS_EC2_METADATA_DISABLED",
    gK8 = mdA(async (A) => {
      let {
        ENV_CMDS_FULL_URI: Q,
        ENV_CMDS_RELATIVE_URI: B,
        fromContainerMetadata: G,
        fromInstanceMetadata: Z
      } = await Promise.resolve().then(() => o6A(OV()));
      if (process.env[B] || process.env[Q]) {
        A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        let {
          fromHttp: I
        } = await Promise.resolve().then(() => o6A(JP1()));
        return (0, Lo.chain)(I(A), G(A))
      }
      if (process.env[UvQ] && process.env[UvQ] !== "false") return async () => {
        throw new Lo.CredentialsProviderError("EC2 Instance Metadata Service access disabled", {
          logger: A.logger
        })
      };
      return A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), Z(A)
    }, "remoteProvider"),
    $vQ = !1,
    uK8 = mdA((A = {}) => (0, Lo.memoize)((0, Lo.chain)(async () => {
      if (A.profile ?? process.env[hK8.ENV_PROFILE]) {
        if (process.env[Mj1.ENV_KEY] && process.env[Mj1.ENV_SECRET]) {
          if (!$vQ)(A.logger?.warn && A.logger?.constructor?.name !== "NoOpLogger" ? A.logger.warn : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), $vQ = !0
        }
        throw new Lo.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
          logger: A.logger,
          tryNextLink: !0
        })
      }
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), (0, Mj1.fromEnv)(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
      let {
        ssoStartUrl: Q,
        ssoAccountId: B,
        ssoRegion: G,
        ssoRoleName: Z,
        ssoSession: I
      } = A;
      if (!Q && !B && !G && !Z && !I) throw new Lo.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", {
        logger: A.logger
      });
      let {
        fromSSO: Y
      } = await Promise.resolve().then(() => o6A(PP1()));
      return Y(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
      let {
        fromIni: Q
      } = await Promise.resolve().then(() => o6A(zvQ()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
      let {
        fromProcess: Q
      } = await Promise.resolve().then(() => o6A(zj1()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
      let {
        fromTokenFile: Q
      } = await Promise.resolve().then(() => o6A(qj1()));
      return Q(A)()
    }, async () => {
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await gK8(A))()
    }, async () => {
      throw new Lo.CredentialsProviderError("Could not load credentials from any providers", {
        tryNextLink: !1,
        logger: A.logger
      })
    }), LvQ, NvQ), "defaultProvider"),
    NvQ = mdA((A) => A?.expiration !== void 0, "credentialsWillNeedRefresh"),
    LvQ = mdA((A) => A?.expiration !== void 0 && A.expiration.getTime() - Date.now() < 300000, "credentialsTreatedAsExpired")
})
// @from(Start 3903657, End 3908510)
mvQ = z((gvQ) => {
  Object.defineProperty(gvQ, "__esModule", {
    value: !0
  });
  gvQ.ruleSet = void 0;
  var bvQ = "required",
    aS = "fn",
    sS = "argv",
    e6A = "ref",
    RvQ = !0,
    TvQ = "isSet",
    hCA = "booleanEquals",
    t6A = "error",
    fCA = "endpoint",
    rC = "tree",
    Oj1 = "PartitionResult",
    PvQ = {
      [bvQ]: !1,
      type: "String"
    },
    jvQ = {
      [bvQ]: !0,
      default: !1,
      type: "Boolean"
    },
    SvQ = {
      [e6A]: "Endpoint"
    },
    fvQ = {
      [aS]: hCA,
      [sS]: [{
        [e6A]: "UseFIPS"
      }, !0]
    },
    hvQ = {
      [aS]: hCA,
      [sS]: [{
        [e6A]: "UseDualStack"
      }, !0]
    },
    nS = {},
    _vQ = {
      [aS]: "getAttr",
      [sS]: [{
        [e6A]: Oj1
      }, "supportsFIPS"]
    },
    kvQ = {
      [aS]: hCA,
      [sS]: [!0, {
        [aS]: "getAttr",
        [sS]: [{
          [e6A]: Oj1
        }, "supportsDualStack"]
      }]
    },
    yvQ = [fvQ],
    xvQ = [hvQ],
    vvQ = [{
      [e6A]: "Region"
    }],
    mK8 = {
      version: "1.0",
      parameters: {
        Region: PvQ,
        UseDualStack: jvQ,
        UseFIPS: jvQ,
        Endpoint: PvQ
      },
      rules: [{
        conditions: [{
          [aS]: TvQ,
          [sS]: [SvQ]
        }],
        rules: [{
          conditions: yvQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: t6A
        }, {
          rules: [{
            conditions: xvQ,
            error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
            type: t6A
          }, {
            endpoint: {
              url: SvQ,
              properties: nS,
              headers: nS
            },
            type: fCA
          }],
          type: rC
        }],
        type: rC
      }, {
        rules: [{
          conditions: [{
            [aS]: TvQ,
            [sS]: vvQ
          }],
          rules: [{
            conditions: [{
              [aS]: "aws.partition",
              [sS]: vvQ,
              assign: Oj1
            }],
            rules: [{
              conditions: [fvQ, hvQ],
              rules: [{
                conditions: [{
                  [aS]: hCA,
                  [sS]: [RvQ, _vQ]
                }, kvQ],
                rules: [{
                  rules: [{
                    endpoint: {
                      url: "https://bedrock-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                      properties: nS,
                      headers: nS
                    },
                    type: fCA
                  }],
                  type: rC
                }],
                type: rC
              }, {
                error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                type: t6A
              }],
              type: rC
            }, {
              conditions: yvQ,
              rules: [{
                conditions: [{
                  [aS]: hCA,
                  [sS]: [_vQ, RvQ]
                }],
                rules: [{
                  rules: [{
                    endpoint: {
                      url: "https://bedrock-fips.{Region}.{PartitionResult#dnsSuffix}",
                      properties: nS,
                      headers: nS
                    },
                    type: fCA
                  }],
                  type: rC
                }],
                type: rC
              }, {
                error: "FIPS is enabled but this partition does not support FIPS",
                type: t6A
              }],
              type: rC
            }, {
              conditions: xvQ,
              rules: [{
                conditions: [kvQ],
                rules: [{
                  rules: [{
                    endpoint: {
                      url: "https://bedrock.{Region}.{PartitionResult#dualStackDnsSuffix}",
                      properties: nS,
                      headers: nS
                    },
                    type: fCA
                  }],
                  type: rC
                }],
                type: rC
              }, {
                error: "DualStack is enabled but this partition does not support DualStack",
                type: t6A
              }],
              type: rC
            }, {
              rules: [{
                endpoint: {
                  url: "https://bedrock.{Region}.{PartitionResult#dnsSuffix}",
                  properties: nS,
                  headers: nS
                },
                type: fCA
              }],
              type: rC
            }],
            type: rC
          }],
          type: rC
        }, {
          error: "Invalid Configuration: Missing Region",
          type: t6A
        }],
        type: rC
      }]
    };
  gvQ.ruleSet = mK8
})
// @from(Start 3908516, End 3909080)
pvQ = z((dvQ) => {
  Object.defineProperty(dvQ, "__esModule", {
    value: !0
  });
  dvQ.defaultEndpointResolver = void 0;
  var dK8 = T6A(),
    Rj1 = FI(),
    cK8 = mvQ(),
    pK8 = new Rj1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    lK8 = (A, Q = {}) => {
      return pK8.get(A, () => (0, Rj1.resolveEndpoint)(cK8.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  dvQ.defaultEndpointResolver = lK8;
  Rj1.customEndpointFunctions.aws = dK8.awsEndpointFunctions
})
// @from(Start 3909086, End 3910505)
svQ = z((nvQ) => {
  Object.defineProperty(nvQ, "__esModule", {
    value: !0
  });
  nvQ.getRuntimeConfig = void 0;
  var iK8 = PF(),
    nK8 = iB(),
    aK8 = o6(),
    sK8 = NJ(),
    lvQ = ld(),
    ivQ = O2(),
    rK8 = GP1(),
    oK8 = pvQ(),
    tK8 = (A) => {
      return {
        apiVersion: "2023-04-20",
        base64Decoder: A?.base64Decoder ?? lvQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? lvQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? oK8.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? rK8.defaultBedrockHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new iK8.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#httpBearerAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#httpBearerAuth"),
          signer: new nK8.HttpBearerAuthSigner
        }],
        logger: A?.logger ?? new aK8.NoOpLogger,
        serviceId: A?.serviceId ?? "Bedrock",
        urlParser: A?.urlParser ?? sK8.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? ivQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? ivQ.toUtf8
      }
    };
  nvQ.getRuntimeConfig = tK8
})
// @from(Start 3910511, End 3913656)
BbQ = z((AbQ) => {
  Object.defineProperty(AbQ, "__esModule", {
    value: !0
  });
  AbQ.getRuntimeConfig = void 0;
  var eK8 = Co(),
    AD8 = eK8.__importDefault(YSQ()),
    Tj1 = PF(),
    QD8 = OvQ(),
    rvQ = RP1(),
    ovQ = LCA(),
    ddA = f8(),
    BD8 = iB(),
    GD8 = RX(),
    tvQ = D6(),
    Mo = uI(),
    evQ = IZ(),
    ZD8 = TX(),
    ID8 = KW(),
    YD8 = svQ(),
    JD8 = o6(),
    WD8 = PX(),
    XD8 = o6(),
    VD8 = (A) => {
      (0, XD8.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, WD8.resolveDefaultsModeConfig)(A),
        B = () => Q().then(JD8.loadConfigsForDefaultMode),
        G = (0, YD8.getRuntimeConfig)(A);
      (0, Tj1.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile,
        logger: G.logger,
        signingName: "bedrock"
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        authSchemePreference: A?.authSchemePreference ?? (0, Mo.loadConfig)(Tj1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, Z),
        bodyLengthChecker: A?.bodyLengthChecker ?? ZD8.calculateBodyLength,
        credentialDefaultProvider: A?.credentialDefaultProvider ?? QD8.defaultProvider,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, ovQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: AD8.default.version
        }),
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (I) => I.getIdentityProvider("aws.auth#sigv4"),
          signer: new Tj1.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#httpBearerAuth",
          identityProvider: (I) => I.getIdentityProvider("smithy.api#httpBearerAuth") || (async (Y) => {
            try {
              return await (0, rvQ.fromEnvSigningName)({
                signingName: "bedrock"
              })()
            } catch (J) {
              return await (0, rvQ.nodeProvider)(Y)(Y)
            }
          }),
          signer: new BD8.HttpBearerAuthSigner
        }],
        maxAttempts: A?.maxAttempts ?? (0, Mo.loadConfig)(tvQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, Mo.loadConfig)(ddA.NODE_REGION_CONFIG_OPTIONS, {
          ...ddA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: evQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, Mo.loadConfig)({
          ...tvQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || ID8.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? GD8.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? evQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, Mo.loadConfig)(ddA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, Mo.loadConfig)(ddA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, Mo.loadConfig)(ovQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  AbQ.getRuntimeConfig = VD8
})
// @from(Start 4112667, End 4114489)
rS = z((VT7, $gQ) => {
  var {
    defineProperty: AcA,
    getOwnPropertyDescriptor: D$8,
    getOwnPropertyNames: H$8
  } = Object, C$8 = Object.prototype.hasOwnProperty, DS1 = (A, Q) => AcA(A, "name", {
    value: Q,
    configurable: !0
  }), E$8 = (A, Q) => {
    for (var B in Q) AcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, z$8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of H$8(Q))
        if (!C$8.call(A, Z) && Z !== B) AcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = D$8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, U$8 = (A) => z$8(AcA({}, "__esModule", {
    value: !0
  }), A), EgQ = {};
  E$8(EgQ, {
    emitWarningIfUnsupportedVersion: () => $$8,
    setCredentialFeature: () => zgQ,
    setFeature: () => UgQ,
    state: () => KS1
  });
  $gQ.exports = U$8(EgQ);
  var KS1 = {
      warningEmitted: !1
    },
    $$8 = DS1((A) => {
      if (A && !KS1.warningEmitted && parseInt(A.substring(1, A.indexOf("."))) < 18) KS1.warningEmitted = !0, process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`)
    }, "emitWarningIfUnsupportedVersion");

  function zgQ(A, Q, B) {
    if (!A.$source) A.$source = {};
    return A.$source[Q] = B, A
  }
  DS1(zgQ, "setCredentialFeature");

  function UgQ(A, Q, B) {
    if (!A.__aws_sdk_context) A.__aws_sdk_context = {
      features: {}
    };
    else if (!A.__aws_sdk_context.features) A.__aws_sdk_context.features = {};
    A.__aws_sdk_context.features[Q] = B
  }
  DS1(UgQ, "setFeature")
})
// @from(Start 4114495, End 4116568)
HS1 = z((FT7, TgQ) => {
  var {
    defineProperty: QcA,
    getOwnPropertyDescriptor: w$8,
    getOwnPropertyNames: q$8
  } = Object, N$8 = Object.prototype.hasOwnProperty, L$8 = (A, Q) => QcA(A, "name", {
    value: Q,
    configurable: !0
  }), M$8 = (A, Q) => {
    for (var B in Q) QcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, O$8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of q$8(Q))
        if (!N$8.call(A, Z) && Z !== B) QcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = w$8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, R$8 = (A) => O$8(QcA({}, "__esModule", {
    value: !0
  }), A), wgQ = {};
  M$8(wgQ, {
    ENV_ACCOUNT_ID: () => RgQ,
    ENV_CREDENTIAL_SCOPE: () => OgQ,
    ENV_EXPIRATION: () => MgQ,
    ENV_KEY: () => qgQ,
    ENV_SECRET: () => NgQ,
    ENV_SESSION: () => LgQ,
    fromEnv: () => j$8
  });
  TgQ.exports = R$8(wgQ);
  var T$8 = rS(),
    P$8 = j2(),
    qgQ = "AWS_ACCESS_KEY_ID",
    NgQ = "AWS_SECRET_ACCESS_KEY",
    LgQ = "AWS_SESSION_TOKEN",
    MgQ = "AWS_CREDENTIAL_EXPIRATION",
    OgQ = "AWS_CREDENTIAL_SCOPE",
    RgQ = "AWS_ACCOUNT_ID",
    j$8 = L$8((A) => async () => {
      A?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
      let Q = process.env[qgQ],
        B = process.env[NgQ],
        G = process.env[LgQ],
        Z = process.env[MgQ],
        I = process.env[OgQ],
        Y = process.env[RgQ];
      if (Q && B) {
        let J = {
          accessKeyId: Q,
          secretAccessKey: B,
          ...G && {
            sessionToken: G
          },
          ...Z && {
            expiration: new Date(Z)
          },
          ...I && {
            credentialScope: I
          },
          ...Y && {
            accountId: Y
          }
        };
        return (0, T$8.setCredentialFeature)(J, "CREDENTIALS_ENV_VARS", "g"), J
      }
      throw new P$8.CredentialsProviderError("Unable to find environment variable credentials.", {
        logger: A?.logger
      })
    }, "fromEnv")
})
// @from(Start 4116574, End 4133830)
BuQ = z((KT7, ZcA) => {
  var PgQ, jgQ, SgQ, _gQ, kgQ, ygQ, xgQ, vgQ, bgQ, fgQ, hgQ, ggQ, ugQ, BcA, CS1, mgQ, dgQ, cgQ, A5A, pgQ, lgQ, igQ, ngQ, agQ, sgQ, rgQ, ogQ, tgQ, GcA, egQ, AuQ, QuQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof ZcA === "object" && typeof KT7 === "object") A(B(Q, B(KT7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    PgQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, jgQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, SgQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, _gQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, kgQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, ygQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, xgQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, vgQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, bgQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, fgQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, hgQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, ggQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, ugQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) GcA(Y, I, J)
    }, GcA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, BcA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, CS1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, mgQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(CS1(arguments[Y]));
      return I
    }, dgQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, cgQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, A5A = function(I) {
      return this instanceof A5A ? (this.v = I, this) : new A5A(I)
    }, pgQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof A5A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, lgQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: A5A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, igQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof BcA === "function" ? BcA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, ngQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    agQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") GcA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, sgQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, rgQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, ogQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, tgQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, egQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    AuQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, QuQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", PgQ), A("__assign", jgQ), A("__rest", SgQ), A("__decorate", _gQ), A("__param", kgQ), A("__esDecorate", ygQ), A("__runInitializers", xgQ), A("__propKey", vgQ), A("__setFunctionName", bgQ), A("__metadata", fgQ), A("__awaiter", hgQ), A("__generator", ggQ), A("__exportStar", ugQ), A("__createBinding", GcA), A("__values", BcA), A("__read", CS1), A("__spread", mgQ), A("__spreadArrays", dgQ), A("__spreadArray", cgQ), A("__await", A5A), A("__asyncGenerator", pgQ), A("__asyncDelegator", lgQ), A("__asyncValues", igQ), A("__makeTemplateObject", ngQ), A("__importStar", agQ), A("__importDefault", sgQ), A("__classPrivateFieldGet", rgQ), A("__classPrivateFieldSet", ogQ), A("__classPrivateFieldIn", tgQ), A("__addDisposableResource", egQ), A("__disposeResources", AuQ), A("__rewriteRelativeImportExtension", QuQ)
  })
})
// @from(Start 4133836, End 4134959)
IuQ = z((GuQ) => {
  Object.defineProperty(GuQ, "__esModule", {
    value: !0
  });
  GuQ.checkUrl = void 0;
  var S$8 = j2(),
    _$8 = "169.254.170.2",
    k$8 = "169.254.170.23",
    y$8 = "[fd00:ec2::23]",
    x$8 = (A, Q) => {
      if (A.protocol === "https:") return;
      if (A.hostname === _$8 || A.hostname === k$8 || A.hostname === y$8) return;
      if (A.hostname.includes("[")) {
        if (A.hostname === "[::1]" || A.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") return
      } else {
        if (A.hostname === "localhost") return;
        let B = A.hostname.split("."),
          G = (Z) => {
            let I = parseInt(Z, 10);
            return 0 <= I && I <= 255
          };
        if (B[0] === "127" && G(B[1]) && G(B[2]) && G(B[3]) && B.length === 4) return
      }
      throw new S$8.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, {
        logger: Q
      })
    };
  GuQ.checkUrl = x$8
})
// @from(Start 4134965, End 4137748)
ES1 = z((HT7, HuQ) => {
  var {
    defineProperty: IcA,
    getOwnPropertyDescriptor: v$8,
    getOwnPropertyNames: b$8
  } = Object, f$8 = Object.prototype.hasOwnProperty, YcA = (A, Q) => IcA(A, "name", {
    value: Q,
    configurable: !0
  }), h$8 = (A, Q) => {
    for (var B in Q) IcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, g$8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of b$8(Q))
        if (!f$8.call(A, Z) && Z !== B) IcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = v$8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, u$8 = (A) => g$8(IcA({}, "__esModule", {
    value: !0
  }), A), YuQ = {};
  h$8(YuQ, {
    AlgorithmId: () => VuQ,
    EndpointURLScheme: () => XuQ,
    FieldPosition: () => FuQ,
    HttpApiKeyAuthLocation: () => WuQ,
    HttpAuthLocation: () => JuQ,
    IniSectionType: () => KuQ,
    RequestHandlerProtocol: () => DuQ,
    SMITHY_CONTEXT_KEY: () => l$8,
    getDefaultClientConfiguration: () => c$8,
    resolveDefaultRuntimeConfig: () => p$8
  });
  HuQ.exports = u$8(YuQ);
  var JuQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(JuQ || {}),
    WuQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(WuQ || {}),
    XuQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(XuQ || {}),
    VuQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(VuQ || {}),
    m$8 = YcA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    d$8 = YcA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    c$8 = YcA((A) => {
      return m$8(A)
    }, "getDefaultClientConfiguration"),
    p$8 = YcA((A) => {
      return d$8(A)
    }, "resolveDefaultRuntimeConfig"),
    FuQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(FuQ || {}),
    l$8 = "__smithy_context",
    KuQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(KuQ || {}),
    DuQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(DuQ || {})
})
// @from(Start 4137754, End 4142261)
wuQ = z((CT7, $uQ) => {
  var {
    defineProperty: JcA,
    getOwnPropertyDescriptor: i$8,
    getOwnPropertyNames: n$8
  } = Object, a$8 = Object.prototype.hasOwnProperty, td = (A, Q) => JcA(A, "name", {
    value: Q,
    configurable: !0
  }), s$8 = (A, Q) => {
    for (var B in Q) JcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, r$8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of n$8(Q))
        if (!a$8.call(A, Z) && Z !== B) JcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = i$8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, o$8 = (A) => r$8(JcA({}, "__esModule", {
    value: !0
  }), A), CuQ = {};
  s$8(CuQ, {
    Field: () => Aw8,
    Fields: () => Qw8,
    HttpRequest: () => Bw8,
    HttpResponse: () => Gw8,
    IHttpRequest: () => EuQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => t$8,
    isValidHostname: () => UuQ,
    resolveHttpHandlerRuntimeConfig: () => e$8
  });
  $uQ.exports = o$8(CuQ);
  var t$8 = td((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    e$8 = td((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    EuQ = ES1(),
    Aw8 = class {
      static {
        td(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = EuQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    Qw8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        td(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    Bw8 = class A {
      static {
        td(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = zuQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function zuQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  td(zuQ, "cloneQuery");
  var Gw8 = class {
    static {
      td(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function UuQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  td(UuQ, "isValidHostname")
})
// @from(Start 4142267, End 4170722)
guQ = z(($T7, huQ) => {
  var {
    defineProperty: VcA,
    getOwnPropertyDescriptor: Zw8,
    getOwnPropertyNames: Iw8
  } = Object, Yw8 = Object.prototype.hasOwnProperty, KB = (A, Q) => VcA(A, "name", {
    value: Q,
    configurable: !0
  }), Jw8 = (A, Q) => {
    for (var B in Q) VcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Ww8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Iw8(Q))
        if (!Yw8.call(A, Z) && Z !== B) VcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Zw8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Xw8 = (A) => Ww8(VcA({}, "__esModule", {
    value: !0
  }), A), NuQ = {};
  Jw8(NuQ, {
    Client: () => Vw8,
    Command: () => MuQ,
    LazyJsonString: () => Oo,
    NoOpLogger: () => Yq8,
    SENSITIVE_STRING: () => Kw8,
    ServiceException: () => nw8,
    _json: () => LS1,
    collectBody: () => zS1.collectBody,
    convertMap: () => Jq8,
    createAggregatedClient: () => Dw8,
    dateToUtcString: () => SuQ,
    decorateServiceException: () => _uQ,
    emitWarningIfUnsupportedVersion: () => ow8,
    expectBoolean: () => Cw8,
    expectByte: () => NS1,
    expectFloat32: () => WcA,
    expectInt: () => zw8,
    expectInt32: () => wS1,
    expectLong: () => mCA,
    expectNonNull: () => $w8,
    expectNumber: () => uCA,
    expectObject: () => OuQ,
    expectShort: () => qS1,
    expectString: () => ww8,
    expectUnion: () => qw8,
    extendedEncodeURIComponent: () => zS1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => Zq8,
    getDefaultClientConfiguration: () => Bq8,
    getDefaultExtensionConfiguration: () => yuQ,
    getValueFromTextNode: () => xuQ,
    handleFloat: () => Mw8,
    isSerializableHeaderValue: () => Iq8,
    limitedParseDouble: () => RS1,
    limitedParseFloat: () => Ow8,
    limitedParseFloat32: () => Rw8,
    loadConfigsForDefaultMode: () => rw8,
    logger: () => dCA,
    map: () => PS1,
    parseBoolean: () => Hw8,
    parseEpochTimestamp: () => hw8,
    parseRfc3339DateTime: () => _w8,
    parseRfc3339DateTimeWithOffset: () => yw8,
    parseRfc7231DateTime: () => fw8,
    quoteHeader: () => buQ,
    resolveDefaultRuntimeConfig: () => Gq8,
    resolvedPath: () => zS1.resolvedPath,
    serializeDateTime: () => Dq8,
    serializeFloat: () => Kq8,
    splitEvery: () => fuQ,
    splitHeader: () => Hq8,
    strictParseByte: () => juQ,
    strictParseDouble: () => OS1,
    strictParseFloat: () => Nw8,
    strictParseFloat32: () => RuQ,
    strictParseInt: () => Tw8,
    strictParseInt32: () => Pw8,
    strictParseLong: () => PuQ,
    strictParseShort: () => Q5A,
    take: () => Wq8,
    throwDefaultError: () => kuQ,
    withBaseException: () => aw8
  });
  huQ.exports = Xw8(NuQ);
  var LuQ = uR(),
    Vw8 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, LuQ.constructStack)()
      }
      static {
        KB(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    zS1 = w5(),
    $S1 = ES1(),
    MuQ = class {
      constructor() {
        this.middlewareStack = (0, LuQ.constructStack)()
      }
      static {
        KB(this, "Command")
      }
      static classBuilder() {
        return new Fw8
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [$S1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    Fw8 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        KB(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends MuQ {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this)
          }
          static {
            KB(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    Kw8 = "***SensitiveInformation***",
    Dw8 = KB((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = KB(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    Hw8 = KB((A) => {
      switch (A) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw Error(`Unable to parse boolean value "${A}"`)
      }
    }, "parseBoolean"),
    Cw8 = KB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "number") {
        if (A === 0 || A === 1) dCA.warn(XcA(`Expected boolean, got ${typeof A}: ${A}`));
        if (A === 0) return !1;
        if (A === 1) return !0
      }
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (Q === "false" || Q === "true") dCA.warn(XcA(`Expected boolean, got ${typeof A}: ${A}`));
        if (Q === "false") return !1;
        if (Q === "true") return !0
      }
      if (typeof A === "boolean") return A;
      throw TypeError(`Expected boolean, got ${typeof A}: ${A}`)
    }, "expectBoolean"),
    uCA = KB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") {
        let Q = parseFloat(A);
        if (!Number.isNaN(Q)) {
          if (String(Q) !== String(A)) dCA.warn(XcA(`Expected number but observed string: ${A}`));
          return Q
        }
      }
      if (typeof A === "number") return A;
      throw TypeError(`Expected number, got ${typeof A}: ${A}`)
    }, "expectNumber"),
    Ew8 = Math.ceil(340282346638528860000000000000000000000),
    WcA = KB((A) => {
      let Q = uCA(A);
      if (Q !== void 0 && !Number.isNaN(Q) && Q !== 1 / 0 && Q !== -1 / 0) {
        if (Math.abs(Q) > Ew8) throw TypeError(`Expected 32-bit float, got ${A}`)
      }
      return Q
    }, "expectFloat32"),
    mCA = KB((A) => {
      if (A === null || A === void 0) return;
      if (Number.isInteger(A) && !Number.isNaN(A)) return A;
      throw TypeError(`Expected integer, got ${typeof A}: ${A}`)
    }, "expectLong"),
    zw8 = mCA,
    wS1 = KB((A) => MS1(A, 32), "expectInt32"),
    qS1 = KB((A) => MS1(A, 16), "expectShort"),
    NS1 = KB((A) => MS1(A, 8), "expectByte"),
    MS1 = KB((A, Q) => {
      let B = mCA(A);
      if (B !== void 0 && Uw8(B, Q) !== B) throw TypeError(`Expected ${Q}-bit integer, got ${A}`);
      return B
    }, "expectSizedInt"),
    Uw8 = KB((A, Q) => {
      switch (Q) {
        case 32:
          return Int32Array.of(A)[0];
        case 16:
          return Int16Array.of(A)[0];
        case 8:
          return Int8Array.of(A)[0]
      }
    }, "castInt"),
    $w8 = KB((A, Q) => {
      if (A === null || A === void 0) {
        if (Q) throw TypeError(`Expected a non-null value for ${Q}`);
        throw TypeError("Expected a non-null value")
      }
      return A
    }, "expectNonNull"),
    OuQ = KB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "object" && !Array.isArray(A)) return A;
      let Q = Array.isArray(A) ? "array" : typeof A;
      throw TypeError(`Expected object, got ${Q}: ${A}`)
    }, "expectObject"),
    ww8 = KB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") return A;
      if (["boolean", "number", "bigint"].includes(typeof A)) return dCA.warn(XcA(`Expected string, got ${typeof A}: ${A}`)), String(A);
      throw TypeError(`Expected string, got ${typeof A}: ${A}`)
    }, "expectString"),
    qw8 = KB((A) => {
      if (A === null || A === void 0) return;
      let Q = OuQ(A),
        B = Object.entries(Q).filter(([, G]) => G != null).map(([G]) => G);
      if (B.length === 0) throw TypeError("Unions must have exactly one non-null member. None were found.");
      if (B.length > 1) throw TypeError(`Unions must have exactly one non-null member. Keys ${B} were not null.`);
      return Q
    }, "expectUnion"),
    OS1 = KB((A) => {
      if (typeof A == "string") return uCA(G5A(A));
      return uCA(A)
    }, "strictParseDouble"),
    Nw8 = OS1,
    RuQ = KB((A) => {
      if (typeof A == "string") return WcA(G5A(A));
      return WcA(A)
    }, "strictParseFloat32"),
    Lw8 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    G5A = KB((A) => {
      let Q = A.match(Lw8);
      if (Q === null || Q[0].length !== A.length) throw TypeError("Expected real number, got implicit NaN");
      return parseFloat(A)
    }, "parseNumber"),
    RS1 = KB((A) => {
      if (typeof A == "string") return TuQ(A);
      return uCA(A)
    }, "limitedParseDouble"),
    Mw8 = RS1,
    Ow8 = RS1,
    Rw8 = KB((A) => {
      if (typeof A == "string") return TuQ(A);
      return WcA(A)
    }, "limitedParseFloat32"),
    TuQ = KB((A) => {
      switch (A) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw Error(`Unable to parse float value: ${A}`)
      }
    }, "parseFloatString"),
    PuQ = KB((A) => {
      if (typeof A === "string") return mCA(G5A(A));
      return mCA(A)
    }, "strictParseLong"),
    Tw8 = PuQ,
    Pw8 = KB((A) => {
      if (typeof A === "string") return wS1(G5A(A));
      return wS1(A)
    }, "strictParseInt32"),
    Q5A = KB((A) => {
      if (typeof A === "string") return qS1(G5A(A));
      return qS1(A)
    }, "strictParseShort"),
    juQ = KB((A) => {
      if (typeof A === "string") return NS1(G5A(A));
      return NS1(A)
    }, "strictParseByte"),
    XcA = KB((A) => {
      return String(TypeError(A).stack || A).split(`
`).slice(0, 5).filter((Q) => !Q.includes("stackTraceWarning")).join(`
`)
    }, "stackTraceWarning"),
    dCA = {
      warn: console.warn
    },
    jw8 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    TS1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  function SuQ(A) {
    let Q = A.getUTCFullYear(),
      B = A.getUTCMonth(),
      G = A.getUTCDay(),
      Z = A.getUTCDate(),
      I = A.getUTCHours(),
      Y = A.getUTCMinutes(),
      J = A.getUTCSeconds(),
      W = Z < 10 ? `0${Z}` : `${Z}`,
      X = I < 10 ? `0${I}` : `${I}`,
      V = Y < 10 ? `0${Y}` : `${Y}`,
      F = J < 10 ? `0${J}` : `${J}`;
    return `${jw8[G]}, ${W} ${TS1[B]} ${Q} ${X}:${V}:${F} GMT`
  }
  KB(SuQ, "dateToUtcString");
  var Sw8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/),
    _w8 = KB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = Sw8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X] = Q, V = Q5A(B5A(G)), F = oS(Z, "month", 1, 12), K = oS(I, "day", 1, 31);
      return gCA(V, F, K, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      })
    }, "parseRfc3339DateTime"),
    kw8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/),
    yw8 = KB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = kw8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X, V] = Q, F = Q5A(B5A(G)), K = oS(Z, "month", 1, 12), D = oS(I, "day", 1, 31), H = gCA(F, K, D, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      });
      if (V.toUpperCase() != "Z") H.setTime(H.getTime() - iw8(V));
      return H
    }, "parseRfc3339DateTimeWithOffset"),
    xw8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    vw8 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    bw8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/),
    fw8 = KB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-7231 date-times must be expressed as strings");
      let Q = xw8.exec(A);
      if (Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return gCA(Q5A(B5A(I)), US1(Z), oS(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        })
      }
      if (Q = vw8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return mw8(gCA(gw8(I), US1(Z), oS(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        }))
      }
      if (Q = bw8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return gCA(Q5A(B5A(X)), US1(G), oS(Z.trimLeft(), "day", 1, 31), {
          hours: I,
          minutes: Y,
          seconds: J,
          fractionalMilliseconds: W
        })
      }
      throw TypeError("Invalid RFC-7231 date-time value")
    }, "parseRfc7231DateTime"),
    hw8 = KB((A) => {
      if (A === null || A === void 0) return;
      let Q;
      if (typeof A === "number") Q = A;
      else if (typeof A === "string") Q = OS1(A);
      else if (typeof A === "object" && A.tag === 1) Q = A.value;
      else throw TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      if (Number.isNaN(Q) || Q === 1 / 0 || Q === -1 / 0) throw TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      return new Date(Math.round(Q * 1000))
    }, "parseEpochTimestamp"),
    gCA = KB((A, Q, B, G) => {
      let Z = Q - 1;
      return cw8(A, Z, B), new Date(Date.UTC(A, Z, B, oS(G.hours, "hour", 0, 23), oS(G.minutes, "minute", 0, 59), oS(G.seconds, "seconds", 0, 60), lw8(G.fractionalMilliseconds)))
    }, "buildDate"),
    gw8 = KB((A) => {
      let Q = new Date().getUTCFullYear(),
        B = Math.floor(Q / 100) * 100 + Q5A(B5A(A));
      if (B < Q) return B + 100;
      return B
    }, "parseTwoDigitYear"),
    uw8 = 1576800000000,
    mw8 = KB((A) => {
      if (A.getTime() - new Date().getTime() > uw8) return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));
      return A
    }, "adjustRfc850Year"),
    US1 = KB((A) => {
      let Q = TS1.indexOf(A);
      if (Q < 0) throw TypeError(`Invalid month: ${A}`);
      return Q + 1
    }, "parseMonthByShortName"),
    dw8 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    cw8 = KB((A, Q, B) => {
      let G = dw8[Q];
      if (Q === 1 && pw8(A)) G = 29;
      if (B > G) throw TypeError(`Invalid day for ${TS1[Q]} in ${A}: ${B}`)
    }, "validateDayOfMonth"),
    pw8 = KB((A) => {
      return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0)
    }, "isLeapYear"),
    oS = KB((A, Q, B, G) => {
      let Z = juQ(B5A(A));
      if (Z < B || Z > G) throw TypeError(`${Q} must be between ${B} and ${G}, inclusive`);
      return Z
    }, "parseDateValue"),
    lw8 = KB((A) => {
      if (A === null || A === void 0) return 0;
      return RuQ("0." + A) * 1000
    }, "parseMilliseconds"),
    iw8 = KB((A) => {
      let Q = A[0],
        B = 1;
      if (Q == "+") B = 1;
      else if (Q == "-") B = -1;
      else throw TypeError(`Offset direction, ${Q}, must be "+" or "-"`);
      let G = Number(A.substring(1, 3)),
        Z = Number(A.substring(4, 6));
      return B * (G * 60 + Z) * 60 * 1000
    }, "parseOffsetToMilliseconds"),
    B5A = KB((A) => {
      let Q = 0;
      while (Q < A.length - 1 && A.charAt(Q) === "0") Q++;
      if (Q === 0) return A;
      return A.slice(Q)
    }, "stripLeadingZeroes"),
    nw8 = class A extends Error {
      static {
        KB(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    _uQ = KB((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    kuQ = KB(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = sw8(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw _uQ(Y, Q)
    }, "throwDefaultError"),
    aw8 = KB((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        kuQ({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    sw8 = KB((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    rw8 = KB((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    quQ = !1,
    ow8 = KB((A) => {
      if (A && !quQ && parseInt(A.substring(1, A.indexOf("."))) < 16) quQ = !0
    }, "emitWarningIfUnsupportedVersion"),
    tw8 = KB((A) => {
      let Q = [];
      for (let B in $S1.AlgorithmId) {
        let G = $S1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    ew8 = KB((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    Aq8 = KB((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    Qq8 = KB((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    yuQ = KB((A) => {
      return Object.assign(tw8(A), Aq8(A))
    }, "getDefaultExtensionConfiguration"),
    Bq8 = yuQ,
    Gq8 = KB((A) => {
      return Object.assign(ew8(A), Qq8(A))
    }, "resolveDefaultRuntimeConfig"),
    Zq8 = KB((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    xuQ = KB((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = xuQ(A[B]);
      return A
    }, "getValueFromTextNode"),
    Iq8 = KB((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    Oo = KB(function(Q) {
      return Object.assign(new String(Q), {
        deserializeJSON() {
          return JSON.parse(String(Q))
        },
        toString() {
          return String(Q)
        },
        toJSON() {
          return String(Q)
        }
      })
    }, "LazyJsonString");
  Oo.from = (A) => {
    if (A && typeof A === "object" && (A instanceof Oo || ("deserializeJSON" in A))) return A;
    else if (typeof A === "string" || Object.getPrototypeOf(A) === String.prototype) return Oo(String(A));
    return Oo(JSON.stringify(A))
  };
  Oo.fromObject = Oo.from;
  var Yq8 = class {
    static {
      KB(this, "NoOpLogger")
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };

  function PS1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, Xq8(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      vuQ(G, null, I, Y)
    }
    return G
  }
  KB(PS1, "map");
  var Jq8 = KB((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    Wq8 = KB((A, Q) => {
      let B = {};
      for (let G in Q) vuQ(B, A, Q, G);
      return B
    }, "take"),
    Xq8 = KB((A, Q, B) => {
      return PS1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    vuQ = KB((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = Vq8, W = Fq8, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    Vq8 = KB((A) => A != null, "nonNullish"),
    Fq8 = KB((A) => A, "pass");

  function buQ(A) {
    if (A.includes(",") || A.includes('"')) A = `"${A.replace(/"/g,"\\\"")}"`;
    return A
  }
  KB(buQ, "quoteHeader");
  var Kq8 = KB((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    Dq8 = KB((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    LS1 = KB((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(LS1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = LS1(A[B])
        }
        return Q
      }
      return A
    }, "_json");

  function fuQ(A, Q, B) {
    if (B <= 0 || !Number.isInteger(B)) throw Error("Invalid number of delimiters (" + B + ") for splitEvery.");
    let G = A.split(Q);
    if (B === 1) return G;
    let Z = [],
      I = "";
    for (let Y = 0; Y < G.length; Y++) {
      if (I === "") I = G[Y];
      else I += Q + G[Y];
      if ((Y + 1) % B === 0) Z.push(I), I = ""
    }
    if (I !== "") Z.push(I);
    return Z
  }
  KB(fuQ, "splitEvery");
  var Hq8 = KB((A) => {
    let Q = A.length,
      B = [],
      G = !1,
      Z = void 0,
      I = 0;
    for (let Y = 0; Y < Q; ++Y) {
      let J = A[Y];
      switch (J) {
        case '"':
          if (Z !== "\\") G = !G;
          break;
        case ",":
          if (!G) B.push(A.slice(I, Y)), I = Y + 1;
          break;
        default:
      }
      Z = J
    }
    return B.push(A.slice(I)), B.map((Y) => {
      Y = Y.trim();
      let J = Y.length;
      if (J < 2) return Y;
      if (Y[0] === '"' && Y[J - 1] === '"') Y = Y.slice(1, J - 1);
      return Y.replace(/\\"/g, '"')
    })
  }, "splitHeader")
})
// @from(Start 4170728, End 4172524)
duQ = z((uuQ) => {
  Object.defineProperty(uuQ, "__esModule", {
    value: !0
  });
  uuQ.getCredentials = uuQ.createGetRequest = void 0;
  var jS1 = j2(),
    Cq8 = wuQ(),
    Eq8 = guQ(),
    zq8 = Xd();

  function Uq8(A) {
    return new Cq8.HttpRequest({
      protocol: A.protocol,
      hostname: A.hostname,
      port: Number(A.port),
      path: A.pathname,
      query: Array.from(A.searchParams.entries()).reduce((Q, [B, G]) => {
        return Q[B] = G, Q
      }, {}),
      fragment: A.hash
    })
  }
  uuQ.createGetRequest = Uq8;
  async function $q8(A, Q) {
    let G = await (0, zq8.sdkStreamMixin)(A.body).transformToString();
    if (A.statusCode === 200) {
      let Z = JSON.parse(G);
      if (typeof Z.AccessKeyId !== "string" || typeof Z.SecretAccessKey !== "string" || typeof Z.Token !== "string" || typeof Z.Expiration !== "string") throw new jS1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", {
        logger: Q
      });
      return {
        accessKeyId: Z.AccessKeyId,
        secretAccessKey: Z.SecretAccessKey,
        sessionToken: Z.Token,
        expiration: (0, Eq8.parseRfc3339DateTime)(Z.Expiration)
      }
    }
    if (A.statusCode >= 400 && A.statusCode < 500) {
      let Z = {};
      try {
        Z = JSON.parse(G)
      } catch (I) {}
      throw Object.assign(new jS1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
        logger: Q
      }), {
        Code: Z.Code,
        Message: Z.Message
      })
    }
    throw new jS1.CredentialsProviderError(`Server responded with status: ${A.statusCode}`, {
      logger: Q
    })
  }
  uuQ.getCredentials = $q8
})
// @from(Start 4172530, End 4172900)
luQ = z((cuQ) => {
  Object.defineProperty(cuQ, "__esModule", {
    value: !0
  });
  cuQ.retryWrapper = void 0;
  var qq8 = (A, Q, B) => {
    return async () => {
      for (let G = 0; G < Q; ++G) try {
        return await A()
      } catch (Z) {
        await new Promise((I) => setTimeout(I, B))
      }
      return await A()
    }
  };
  cuQ.retryWrapper = qq8
})
// @from(Start 4172906, End 4175394)
ruQ = z((auQ) => {
  Object.defineProperty(auQ, "__esModule", {
    value: !0
  });
  auQ.fromHttp = void 0;
  var Nq8 = BuQ(),
    Lq8 = rS(),
    Mq8 = IZ(),
    iuQ = j2(),
    Oq8 = Nq8.__importDefault(UA("fs/promises")),
    Rq8 = IuQ(),
    nuQ = duQ(),
    Tq8 = luQ(),
    Pq8 = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",
    jq8 = "http://169.254.170.2",
    Sq8 = "AWS_CONTAINER_CREDENTIALS_FULL_URI",
    _q8 = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",
    kq8 = "AWS_CONTAINER_AUTHORIZATION_TOKEN",
    yq8 = (A = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let Q, B = A.awsContainerCredentialsRelativeUri ?? process.env[Pq8],
        G = A.awsContainerCredentialsFullUri ?? process.env[Sq8],
        Z = A.awsContainerAuthorizationToken ?? process.env[kq8],
        I = A.awsContainerAuthorizationTokenFile ?? process.env[_q8],
        Y = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console.warn : A.logger.warn;
      if (B && G) Y("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."), Y("awsContainerCredentialsFullUri will take precedence.");
      if (Z && I) Y("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."), Y("awsContainerAuthorizationToken will take precedence.");
      if (G) Q = G;
      else if (B) Q = `${jq8}${B}`;
      else throw new iuQ.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, {
        logger: A.logger
      });
      let J = new URL(Q);
      (0, Rq8.checkUrl)(J, A.logger);
      let W = new Mq8.NodeHttpHandler({
        requestTimeout: A.timeout ?? 1000,
        connectionTimeout: A.timeout ?? 1000
      });
      return (0, Tq8.retryWrapper)(async () => {
        let X = (0, nuQ.createGetRequest)(J);
        if (Z) X.headers.Authorization = Z;
        else if (I) X.headers.Authorization = (await Oq8.default.readFile(I)).toString();
        try {
          let V = await W.handle(X);
          return (0, nuQ.getCredentials)(V.response).then((F) => (0, Lq8.setCredentialFeature)(F, "CREDENTIALS_HTTP", "z"))
        } catch (V) {
          throw new iuQ.CredentialsProviderError(String(V), {
            logger: A.logger
          })
        }
      }, A.maxRetries ?? 3, A.timeout ?? 1000)
    };
  auQ.fromHttp = yq8
})
// @from(Start 4175400, End 4175652)
_S1 = z((SS1) => {
  Object.defineProperty(SS1, "__esModule", {
    value: !0
  });
  SS1.fromHttp = void 0;
  var xq8 = ruQ();
  Object.defineProperty(SS1, "fromHttp", {
    enumerable: !0,
    get: function() {
      return xq8.fromHttp
    }
  })
})
// @from(Start 4175658, End 4178441)
YmQ = z((jT7, ImQ) => {
  var {
    defineProperty: FcA,
    getOwnPropertyDescriptor: bq8,
    getOwnPropertyNames: fq8
  } = Object, hq8 = Object.prototype.hasOwnProperty, KcA = (A, Q) => FcA(A, "name", {
    value: Q,
    configurable: !0
  }), gq8 = (A, Q) => {
    for (var B in Q) FcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, uq8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of fq8(Q))
        if (!hq8.call(A, Z) && Z !== B) FcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = bq8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, mq8 = (A) => uq8(FcA({}, "__esModule", {
    value: !0
  }), A), ouQ = {};
  gq8(ouQ, {
    AlgorithmId: () => QmQ,
    EndpointURLScheme: () => AmQ,
    FieldPosition: () => BmQ,
    HttpApiKeyAuthLocation: () => euQ,
    HttpAuthLocation: () => tuQ,
    IniSectionType: () => GmQ,
    RequestHandlerProtocol: () => ZmQ,
    SMITHY_CONTEXT_KEY: () => iq8,
    getDefaultClientConfiguration: () => pq8,
    resolveDefaultRuntimeConfig: () => lq8
  });
  ImQ.exports = mq8(ouQ);
  var tuQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(tuQ || {}),
    euQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(euQ || {}),
    AmQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(AmQ || {}),
    QmQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(QmQ || {}),
    dq8 = KcA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    cq8 = KcA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    pq8 = KcA((A) => {
      return dq8(A)
    }, "getDefaultClientConfiguration"),
    lq8 = KcA((A) => {
      return cq8(A)
    }, "resolveDefaultRuntimeConfig"),
    BmQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(BmQ || {}),
    iq8 = "__smithy_context",
    GmQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(GmQ || {}),
    ZmQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(ZmQ || {})
})
// @from(Start 4178447, End 4182954)
KmQ = z((ST7, FmQ) => {
  var {
    defineProperty: DcA,
    getOwnPropertyDescriptor: nq8,
    getOwnPropertyNames: aq8
  } = Object, sq8 = Object.prototype.hasOwnProperty, ed = (A, Q) => DcA(A, "name", {
    value: Q,
    configurable: !0
  }), rq8 = (A, Q) => {
    for (var B in Q) DcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, oq8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of aq8(Q))
        if (!sq8.call(A, Z) && Z !== B) DcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = nq8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, tq8 = (A) => oq8(DcA({}, "__esModule", {
    value: !0
  }), A), JmQ = {};
  rq8(JmQ, {
    Field: () => QN8,
    Fields: () => BN8,
    HttpRequest: () => GN8,
    HttpResponse: () => ZN8,
    IHttpRequest: () => WmQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => eq8,
    isValidHostname: () => VmQ,
    resolveHttpHandlerRuntimeConfig: () => AN8
  });
  FmQ.exports = tq8(JmQ);
  var eq8 = ed((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    AN8 = ed((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    WmQ = YmQ(),
    QN8 = class {
      static {
        ed(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = WmQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    BN8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        ed(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    GN8 = class A {
      static {
        ed(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = XmQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function XmQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  ed(XmQ, "cloneQuery");
  var ZN8 = class {
    static {
      ed(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function VmQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  ed(VmQ, "isValidHostname")
})
// @from(Start 4182960, End 4184824)
cCA = z((xT7, zmQ) => {
  var {
    defineProperty: CcA,
    getOwnPropertyDescriptor: IN8,
    getOwnPropertyNames: YN8
  } = Object, JN8 = Object.prototype.hasOwnProperty, HcA = (A, Q) => CcA(A, "name", {
    value: Q,
    configurable: !0
  }), WN8 = (A, Q) => {
    for (var B in Q) CcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, XN8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of YN8(Q))
        if (!JN8.call(A, Z) && Z !== B) CcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = IN8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, VN8 = (A) => XN8(CcA({}, "__esModule", {
    value: !0
  }), A), DmQ = {};
  WN8(DmQ, {
    getHostHeaderPlugin: () => KN8,
    hostHeaderMiddleware: () => CmQ,
    hostHeaderMiddlewareOptions: () => EmQ,
    resolveHostHeaderConfig: () => HmQ
  });
  zmQ.exports = VN8(DmQ);
  var FN8 = KmQ();

  function HmQ(A) {
    return A
  }
  HcA(HmQ, "resolveHostHeaderConfig");
  var CmQ = HcA((A) => (Q) => async (B) => {
      if (!FN8.HttpRequest.isInstance(B.request)) return Q(B);
      let {
        request: G
      } = B, {
        handlerProtocol: Z = ""
      } = A.requestHandler.metadata || {};
      if (Z.indexOf("h2") >= 0 && !G.headers[":authority"]) delete G.headers.host, G.headers[":authority"] = G.hostname + (G.port ? ":" + G.port : "");
      else if (!G.headers.host) {
        let I = G.hostname;
        if (G.port != null) I += `:${G.port}`;
        G.headers.host = I
      }
      return Q(B)
    }, "hostHeaderMiddleware"),
    EmQ = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: !0
    },
    KN8 = HcA((A) => ({
      applyToStack: HcA((Q) => {
        Q.add(CmQ(A), EmQ)
      }, "applyToStack")
    }), "getHostHeaderPlugin")
})
// @from(Start 4184830, End 4187130)
pCA = z((vT7, qmQ) => {
  var {
    defineProperty: EcA,
    getOwnPropertyDescriptor: DN8,
    getOwnPropertyNames: HN8
  } = Object, CN8 = Object.prototype.hasOwnProperty, kS1 = (A, Q) => EcA(A, "name", {
    value: Q,
    configurable: !0
  }), EN8 = (A, Q) => {
    for (var B in Q) EcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, zN8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of HN8(Q))
        if (!CN8.call(A, Z) && Z !== B) EcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = DN8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, UN8 = (A) => zN8(EcA({}, "__esModule", {
    value: !0
  }), A), UmQ = {};
  EN8(UmQ, {
    getLoggerPlugin: () => $N8,
    loggerMiddleware: () => $mQ,
    loggerMiddlewareOptions: () => wmQ
  });
  qmQ.exports = UN8(UmQ);
  var $mQ = kS1(() => (A, Q) => async (B) => {
      try {
        let G = await A(B),
          {
            clientName: Z,
            commandName: I,
            logger: Y,
            dynamoDbDocumentClientOptions: J = {}
          } = Q,
          {
            overrideInputFilterSensitiveLog: W,
            overrideOutputFilterSensitiveLog: X
          } = J,
          V = W ?? Q.inputFilterSensitiveLog,
          F = X ?? Q.outputFilterSensitiveLog,
          {
            $metadata: K,
            ...D
          } = G.output;
        return Y?.info?.({
          clientName: Z,
          commandName: I,
          input: V(B.input),
          output: F(D),
          metadata: K
        }), G
      } catch (G) {
        let {
          clientName: Z,
          commandName: I,
          logger: Y,
          dynamoDbDocumentClientOptions: J = {}
        } = Q, {
          overrideInputFilterSensitiveLog: W
        } = J, X = W ?? Q.inputFilterSensitiveLog;
        throw Y?.error?.({
          clientName: Z,
          commandName: I,
          input: X(B.input),
          error: G,
          metadata: G.$metadata
        }), G
      }
    }, "loggerMiddleware"),
    wmQ = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: !0
    },
    $N8 = kS1((A) => ({
      applyToStack: kS1((Q) => {
        Q.add($mQ(), wmQ)
      }, "applyToStack")
    }), "getLoggerPlugin")
})
// @from(Start 4187136, End 4189919)
_mQ = z((bT7, SmQ) => {
  var {
    defineProperty: zcA,
    getOwnPropertyDescriptor: wN8,
    getOwnPropertyNames: qN8
  } = Object, NN8 = Object.prototype.hasOwnProperty, UcA = (A, Q) => zcA(A, "name", {
    value: Q,
    configurable: !0
  }), LN8 = (A, Q) => {
    for (var B in Q) zcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, MN8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qN8(Q))
        if (!NN8.call(A, Z) && Z !== B) zcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wN8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ON8 = (A) => MN8(zcA({}, "__esModule", {
    value: !0
  }), A), NmQ = {};
  LN8(NmQ, {
    AlgorithmId: () => RmQ,
    EndpointURLScheme: () => OmQ,
    FieldPosition: () => TmQ,
    HttpApiKeyAuthLocation: () => MmQ,
    HttpAuthLocation: () => LmQ,
    IniSectionType: () => PmQ,
    RequestHandlerProtocol: () => jmQ,
    SMITHY_CONTEXT_KEY: () => SN8,
    getDefaultClientConfiguration: () => PN8,
    resolveDefaultRuntimeConfig: () => jN8
  });
  SmQ.exports = ON8(NmQ);
  var LmQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(LmQ || {}),
    MmQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(MmQ || {}),
    OmQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(OmQ || {}),
    RmQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(RmQ || {}),
    RN8 = UcA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    TN8 = UcA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    PN8 = UcA((A) => {
      return RN8(A)
    }, "getDefaultClientConfiguration"),
    jN8 = UcA((A) => {
      return TN8(A)
    }, "resolveDefaultRuntimeConfig"),
    TmQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(TmQ || {}),
    SN8 = "__smithy_context",
    PmQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(PmQ || {}),
    jmQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(jmQ || {})
})
// @from(Start 4189925, End 4194432)
fmQ = z((fT7, bmQ) => {
  var {
    defineProperty: $cA,
    getOwnPropertyDescriptor: _N8,
    getOwnPropertyNames: kN8
  } = Object, yN8 = Object.prototype.hasOwnProperty, Ac = (A, Q) => $cA(A, "name", {
    value: Q,
    configurable: !0
  }), xN8 = (A, Q) => {
    for (var B in Q) $cA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vN8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of kN8(Q))
        if (!yN8.call(A, Z) && Z !== B) $cA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _N8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bN8 = (A) => vN8($cA({}, "__esModule", {
    value: !0
  }), A), kmQ = {};
  xN8(kmQ, {
    Field: () => gN8,
    Fields: () => uN8,
    HttpRequest: () => mN8,
    HttpResponse: () => dN8,
    IHttpRequest: () => ymQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => fN8,
    isValidHostname: () => vmQ,
    resolveHttpHandlerRuntimeConfig: () => hN8
  });
  bmQ.exports = bN8(kmQ);
  var fN8 = Ac((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    hN8 = Ac((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    ymQ = _mQ(),
    gN8 = class {
      static {
        Ac(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = ymQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    uN8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Ac(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    mN8 = class A {
      static {
        Ac(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = xmQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function xmQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Ac(xmQ, "cloneQuery");
  var dN8 = class {
    static {
      Ac(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function vmQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Ac(vmQ, "isValidHostname")
})
// @from(Start 4194438, End 4196371)
lCA = z((mT7, mmQ) => {
  var {
    defineProperty: qcA,
    getOwnPropertyDescriptor: cN8,
    getOwnPropertyNames: pN8
  } = Object, lN8 = Object.prototype.hasOwnProperty, wcA = (A, Q) => qcA(A, "name", {
    value: Q,
    configurable: !0
  }), iN8 = (A, Q) => {
    for (var B in Q) qcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, nN8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of pN8(Q))
        if (!lN8.call(A, Z) && Z !== B) qcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = cN8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, aN8 = (A) => nN8(qcA({}, "__esModule", {
    value: !0
  }), A), hmQ = {};
  iN8(hmQ, {
    addRecursionDetectionMiddlewareOptions: () => umQ,
    getRecursionDetectionPlugin: () => tN8,
    recursionDetectionMiddleware: () => gmQ
  });
  mmQ.exports = aN8(hmQ);
  var sN8 = fmQ(),
    yS1 = "X-Amzn-Trace-Id",
    rN8 = "AWS_LAMBDA_FUNCTION_NAME",
    oN8 = "_X_AMZN_TRACE_ID",
    gmQ = wcA((A) => (Q) => async (B) => {
      let {
        request: G
      } = B;
      if (!sN8.HttpRequest.isInstance(G) || A.runtime !== "node") return Q(B);
      let Z = Object.keys(G.headers ?? {}).find((W) => W.toLowerCase() === yS1.toLowerCase()) ?? yS1;
      if (G.headers.hasOwnProperty(Z)) return Q(B);
      let I = process.env[rN8],
        Y = process.env[oN8],
        J = wcA((W) => typeof W === "string" && W.length > 0, "nonEmptyString");
      if (J(I) && J(Y)) G.headers[yS1] = Y;
      return Q({
        ...B,
        request: G
      })
    }, "recursionDetectionMiddleware"),
    umQ = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: !0,
      priority: "low"
    },
    tN8 = wcA((A) => ({
      applyToStack: wcA((Q) => {
        Q.add(gmQ(A), umQ)
      }, "applyToStack")
    }), "getRecursionDetectionPlugin")
})
// @from(Start 4196377, End 4207748)
I5A = z((dT7, omQ) => {
  var {
    defineProperty: NcA,
    getOwnPropertyDescriptor: eN8,
    getOwnPropertyNames: AL8
  } = Object, QL8 = Object.prototype.hasOwnProperty, Z5A = (A, Q) => NcA(A, "name", {
    value: Q,
    configurable: !0
  }), BL8 = (A, Q) => {
    for (var B in Q) NcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, GL8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of AL8(Q))
        if (!QL8.call(A, Z) && Z !== B) NcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = eN8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ZL8 = (A) => GL8(NcA({}, "__esModule", {
    value: !0
  }), A), cmQ = {};
  BL8(cmQ, {
    ConditionObject: () => kZ.ConditionObject,
    DeprecatedObject: () => kZ.DeprecatedObject,
    EndpointError: () => kZ.EndpointError,
    EndpointObject: () => kZ.EndpointObject,
    EndpointObjectHeaders: () => kZ.EndpointObjectHeaders,
    EndpointObjectProperties: () => kZ.EndpointObjectProperties,
    EndpointParams: () => kZ.EndpointParams,
    EndpointResolverOptions: () => kZ.EndpointResolverOptions,
    EndpointRuleObject: () => kZ.EndpointRuleObject,
    ErrorRuleObject: () => kZ.ErrorRuleObject,
    EvaluateOptions: () => kZ.EvaluateOptions,
    Expression: () => kZ.Expression,
    FunctionArgv: () => kZ.FunctionArgv,
    FunctionObject: () => kZ.FunctionObject,
    FunctionReturn: () => kZ.FunctionReturn,
    ParameterObject: () => kZ.ParameterObject,
    ReferenceObject: () => kZ.ReferenceObject,
    ReferenceRecord: () => kZ.ReferenceRecord,
    RuleSetObject: () => kZ.RuleSetObject,
    RuleSetRules: () => kZ.RuleSetRules,
    TreeRuleObject: () => kZ.TreeRuleObject,
    awsEndpointFunctions: () => rmQ,
    getUserAgentPrefix: () => WL8,
    isIpAddress: () => kZ.isIpAddress,
    partition: () => amQ,
    resolveEndpoint: () => kZ.resolveEndpoint,
    setPartitionInfo: () => smQ,
    useDefaultPartitionInfo: () => JL8
  });
  omQ.exports = ZL8(cmQ);
  var kZ = FI(),
    pmQ = Z5A((A, Q = !1) => {
      if (Q) {
        for (let B of A.split("."))
          if (!pmQ(B)) return !1;
        return !0
      }
      if (!(0, kZ.isValidHostLabel)(A)) return !1;
      if (A.length < 3 || A.length > 63) return !1;
      if (A !== A.toLowerCase()) return !1;
      if ((0, kZ.isIpAddress)(A)) return !1;
      return !0
    }, "isVirtualHostableS3Bucket"),
    dmQ = ":",
    IL8 = "/",
    YL8 = Z5A((A) => {
      let Q = A.split(dmQ);
      if (Q.length < 6) return null;
      let [B, G, Z, I, Y, ...J] = Q;
      if (B !== "arn" || G === "" || Z === "" || J.join(dmQ) === "") return null;
      let W = J.map((X) => X.split(IL8)).flat();
      return {
        partition: G,
        service: Z,
        region: I,
        accountId: Y,
        resourceId: W
      }
    }, "parseArn"),
    lmQ = {
      partitions: [{
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "AWS Standard global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      }, {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "AWS China global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      }, {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: !0,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "AWS GovCloud (US) global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }, {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "c2s.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "AWS ISO (US) global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      }, {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "sc2s.sgov.gov",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "AWS ISOB (US) global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          }
        }
      }, {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "cloud.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-e-global": {
            description: "AWS ISOE (Europe) global region"
          },
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      }, {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "csp.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "AWS ISOF global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      }, {
        id: "aws-eusc",
        outputs: {
          dnsSuffix: "amazonaws.eu",
          dualStackDnsSuffix: "amazonaws.eu",
          implicitGlobalRegion: "eusc-de-east-1",
          name: "aws-eusc",
          supportsDualStack: !1,
          supportsFIPS: !0
        },
        regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
        regions: {
          "eusc-de-east-1": {
            description: "EU (Germany)"
          }
        }
      }],
      version: "1.1"
    },
    imQ = lmQ,
    nmQ = "",
    amQ = Z5A((A) => {
      let {
        partitions: Q
      } = imQ;
      for (let G of Q) {
        let {
          regions: Z,
          outputs: I
        } = G;
        for (let [Y, J] of Object.entries(Z))
          if (Y === A) return {
            ...I,
            ...J
          }
      }
      for (let G of Q) {
        let {
          regionRegex: Z,
          outputs: I
        } = G;
        if (new RegExp(Z).test(A)) return {
          ...I
        }
      }
      let B = Q.find((G) => G.id === "aws");
      if (!B) throw Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      return {
        ...B.outputs
      }
    }, "partition"),
    smQ = Z5A((A, Q = "") => {
      imQ = A, nmQ = Q
    }, "setPartitionInfo"),
    JL8 = Z5A(() => {
      smQ(lmQ, "")
    }, "useDefaultPartitionInfo"),
    WL8 = Z5A(() => nmQ, "getUserAgentPrefix"),
    rmQ = {
      isVirtualHostableS3Bucket: pmQ,
      parseArn: YL8,
      partition: amQ
    };
  kZ.customEndpointFunctions.aws = rmQ
})
// @from(Start 4207754, End 4210537)
JdQ = z((cT7, YdQ) => {
  var {
    defineProperty: LcA,
    getOwnPropertyDescriptor: XL8,
    getOwnPropertyNames: VL8
  } = Object, FL8 = Object.prototype.hasOwnProperty, McA = (A, Q) => LcA(A, "name", {
    value: Q,
    configurable: !0
  }), KL8 = (A, Q) => {
    for (var B in Q) LcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, DL8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of VL8(Q))
        if (!FL8.call(A, Z) && Z !== B) LcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = XL8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, HL8 = (A) => DL8(LcA({}, "__esModule", {
    value: !0
  }), A), tmQ = {};
  KL8(tmQ, {
    AlgorithmId: () => BdQ,
    EndpointURLScheme: () => QdQ,
    FieldPosition: () => GdQ,
    HttpApiKeyAuthLocation: () => AdQ,
    HttpAuthLocation: () => emQ,
    IniSectionType: () => ZdQ,
    RequestHandlerProtocol: () => IdQ,
    SMITHY_CONTEXT_KEY: () => $L8,
    getDefaultClientConfiguration: () => zL8,
    resolveDefaultRuntimeConfig: () => UL8
  });
  YdQ.exports = HL8(tmQ);
  var emQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(emQ || {}),
    AdQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(AdQ || {}),
    QdQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(QdQ || {}),
    BdQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(BdQ || {}),
    CL8 = McA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    EL8 = McA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    zL8 = McA((A) => {
      return CL8(A)
    }, "getDefaultClientConfiguration"),
    UL8 = McA((A) => {
      return EL8(A)
    }, "resolveDefaultRuntimeConfig"),
    GdQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(GdQ || {}),
    $L8 = "__smithy_context",
    ZdQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(ZdQ || {}),
    IdQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(IdQ || {})
})
// @from(Start 4210543, End 4215050)
DdQ = z((pT7, KdQ) => {
  var {
    defineProperty: OcA,
    getOwnPropertyDescriptor: wL8,
    getOwnPropertyNames: qL8
  } = Object, NL8 = Object.prototype.hasOwnProperty, Qc = (A, Q) => OcA(A, "name", {
    value: Q,
    configurable: !0
  }), LL8 = (A, Q) => {
    for (var B in Q) OcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ML8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qL8(Q))
        if (!NL8.call(A, Z) && Z !== B) OcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wL8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, OL8 = (A) => ML8(OcA({}, "__esModule", {
    value: !0
  }), A), WdQ = {};
  LL8(WdQ, {
    Field: () => PL8,
    Fields: () => jL8,
    HttpRequest: () => SL8,
    HttpResponse: () => _L8,
    IHttpRequest: () => XdQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => RL8,
    isValidHostname: () => FdQ,
    resolveHttpHandlerRuntimeConfig: () => TL8
  });
  KdQ.exports = OL8(WdQ);
  var RL8 = Qc((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    TL8 = Qc((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    XdQ = JdQ(),
    PL8 = class {
      static {
        Qc(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = XdQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    jL8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Qc(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    SL8 = class A {
      static {
        Qc(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = VdQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function VdQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Qc(VdQ, "cloneQuery");
  var _L8 = class {
    static {
      Qc(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function FdQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Qc(FdQ, "isValidHostname")
})
// @from(Start 4215056, End 4232312)
ddQ = z((aT7, PcA) => {
  var HdQ, CdQ, EdQ, zdQ, UdQ, $dQ, wdQ, qdQ, NdQ, LdQ, MdQ, OdQ, RdQ, RcA, xS1, TdQ, PdQ, jdQ, Y5A, SdQ, _dQ, kdQ, ydQ, xdQ, vdQ, bdQ, fdQ, hdQ, TcA, gdQ, udQ, mdQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof PcA === "object" && typeof aT7 === "object") A(B(Q, B(aT7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    HdQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, CdQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, EdQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, zdQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, UdQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, $dQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, wdQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, qdQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, NdQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, LdQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, MdQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, OdQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, RdQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) TcA(Y, I, J)
    }, TcA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, RcA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, xS1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, TdQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(xS1(arguments[Y]));
      return I
    }, PdQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, jdQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, Y5A = function(I) {
      return this instanceof Y5A ? (this.v = I, this) : new Y5A(I)
    }, SdQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof Y5A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, _dQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: Y5A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, kdQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof RcA === "function" ? RcA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, ydQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    xdQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") TcA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, vdQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, bdQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, fdQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, hdQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, gdQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    udQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, mdQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", HdQ), A("__assign", CdQ), A("__rest", EdQ), A("__decorate", zdQ), A("__param", UdQ), A("__esDecorate", $dQ), A("__runInitializers", wdQ), A("__propKey", qdQ), A("__setFunctionName", NdQ), A("__metadata", LdQ), A("__awaiter", MdQ), A("__generator", OdQ), A("__exportStar", RdQ), A("__createBinding", TcA), A("__values", RcA), A("__read", xS1), A("__spread", TdQ), A("__spreadArrays", PdQ), A("__spreadArray", jdQ), A("__await", Y5A), A("__asyncGenerator", SdQ), A("__asyncDelegator", _dQ), A("__asyncValues", kdQ), A("__makeTemplateObject", ydQ), A("__importStar", xdQ), A("__importDefault", vdQ), A("__classPrivateFieldGet", bdQ), A("__classPrivateFieldSet", fdQ), A("__classPrivateFieldIn", hdQ), A("__addDisposableResource", gdQ), A("__disposeResources", udQ), A("__rewriteRelativeImportExtension", mdQ)
  })
})
// @from(Start 4232318, End 4235101)
vS1 = z((sT7, odQ) => {
  var {
    defineProperty: jcA,
    getOwnPropertyDescriptor: kL8,
    getOwnPropertyNames: yL8
  } = Object, xL8 = Object.prototype.hasOwnProperty, ScA = (A, Q) => jcA(A, "name", {
    value: Q,
    configurable: !0
  }), vL8 = (A, Q) => {
    for (var B in Q) jcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, bL8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of yL8(Q))
        if (!xL8.call(A, Z) && Z !== B) jcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = kL8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, fL8 = (A) => bL8(jcA({}, "__esModule", {
    value: !0
  }), A), cdQ = {};
  vL8(cdQ, {
    AlgorithmId: () => ndQ,
    EndpointURLScheme: () => idQ,
    FieldPosition: () => adQ,
    HttpApiKeyAuthLocation: () => ldQ,
    HttpAuthLocation: () => pdQ,
    IniSectionType: () => sdQ,
    RequestHandlerProtocol: () => rdQ,
    SMITHY_CONTEXT_KEY: () => dL8,
    getDefaultClientConfiguration: () => uL8,
    resolveDefaultRuntimeConfig: () => mL8
  });
  odQ.exports = fL8(cdQ);
  var pdQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(pdQ || {}),
    ldQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(ldQ || {}),
    idQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(idQ || {}),
    ndQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(ndQ || {}),
    hL8 = ScA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    gL8 = ScA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    uL8 = ScA((A) => {
      return hL8(A)
    }, "getDefaultClientConfiguration"),
    mL8 = ScA((A) => {
      return gL8(A)
    }, "resolveDefaultRuntimeConfig"),
    adQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(adQ || {}),
    dL8 = "__smithy_context",
    sdQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(sdQ || {}),
    rdQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(rdQ || {})
})
// @from(Start 4235107, End 4239614)
iCA = z((rT7, BcQ) => {
  var {
    defineProperty: _cA,
    getOwnPropertyDescriptor: cL8,
    getOwnPropertyNames: pL8
  } = Object, lL8 = Object.prototype.hasOwnProperty, Bc = (A, Q) => _cA(A, "name", {
    value: Q,
    configurable: !0
  }), iL8 = (A, Q) => {
    for (var B in Q) _cA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, nL8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of pL8(Q))
        if (!lL8.call(A, Z) && Z !== B) _cA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = cL8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, aL8 = (A) => nL8(_cA({}, "__esModule", {
    value: !0
  }), A), tdQ = {};
  iL8(tdQ, {
    Field: () => oL8,
    Fields: () => tL8,
    HttpRequest: () => eL8,
    HttpResponse: () => AM8,
    IHttpRequest: () => edQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => sL8,
    isValidHostname: () => QcQ,
    resolveHttpHandlerRuntimeConfig: () => rL8
  });
  BcQ.exports = aL8(tdQ);
  var sL8 = Bc((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    rL8 = Bc((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    edQ = vS1(),
    oL8 = class {
      static {
        Bc(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = edQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    tL8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Bc(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    eL8 = class A {
      static {
        Bc(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = AcQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function AcQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Bc(AcQ, "cloneQuery");
  var AM8 = class {
    static {
      Bc(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function QcQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Bc(QcQ, "isValidHostname")
})
// @from(Start 4239620, End 4240573)
IcQ = z((AP7, ZcQ) => {
  var {
    defineProperty: kcA,
    getOwnPropertyDescriptor: QM8,
    getOwnPropertyNames: BM8
  } = Object, GM8 = Object.prototype.hasOwnProperty, ZM8 = (A, Q) => kcA(A, "name", {
    value: Q,
    configurable: !0
  }), IM8 = (A, Q) => {
    for (var B in Q) kcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, YM8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of BM8(Q))
        if (!GM8.call(A, Z) && Z !== B) kcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = QM8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, JM8 = (A) => YM8(kcA({}, "__esModule", {
    value: !0
  }), A), GcQ = {};
  IM8(GcQ, {
    isArrayBuffer: () => WM8
  });
  ZcQ.exports = JM8(GcQ);
  var WM8 = ZM8((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 4240579, End 4241632)
XcQ = z((QP7, WcQ) => {
  var {
    defineProperty: ycA,
    getOwnPropertyDescriptor: XM8,
    getOwnPropertyNames: VM8
  } = Object, FM8 = Object.prototype.hasOwnProperty, bS1 = (A, Q) => ycA(A, "name", {
    value: Q,
    configurable: !0
  }), KM8 = (A, Q) => {
    for (var B in Q) ycA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, DM8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of VM8(Q))
        if (!FM8.call(A, Z) && Z !== B) ycA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = XM8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, HM8 = (A) => DM8(ycA({}, "__esModule", {
    value: !0
  }), A), YcQ = {};
  KM8(YcQ, {
    escapeUri: () => JcQ,
    escapeUriPath: () => EM8
  });
  WcQ.exports = HM8(YcQ);
  var JcQ = bS1((A) => encodeURIComponent(A).replace(/[!'()*]/g, CM8), "escapeUri"),
    CM8 = bS1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    EM8 = bS1((A) => A.split("/").map(JcQ).join("/"), "escapeUriPath")
})
// @from(Start 4241638, End 4258552)
fcQ = z((BP7, bcQ) => {
  var {
    defineProperty: ucA,
    getOwnPropertyDescriptor: zM8,
    getOwnPropertyNames: UM8
  } = Object, $M8 = Object.prototype.hasOwnProperty, DD = (A, Q) => ucA(A, "name", {
    value: Q,
    configurable: !0
  }), wM8 = (A, Q) => {
    for (var B in Q) ucA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, qM8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of UM8(Q))
        if (!$M8.call(A, Z) && Z !== B) ucA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = zM8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, NM8 = (A) => qM8(ucA({}, "__esModule", {
    value: !0
  }), A), HcQ = {};
  wM8(HcQ, {
    ALGORITHM_IDENTIFIER: () => xcA,
    ALGORITHM_IDENTIFIER_V4A: () => RM8,
    ALGORITHM_QUERY_PARAM: () => CcQ,
    ALWAYS_UNSIGNABLE_HEADERS: () => LcQ,
    AMZ_DATE_HEADER: () => pS1,
    AMZ_DATE_QUERY_PARAM: () => uS1,
    AUTH_HEADER: () => cS1,
    CREDENTIAL_QUERY_PARAM: () => EcQ,
    DATE_HEADER: () => $cQ,
    EVENT_ALGORITHM_IDENTIFIER: () => RcQ,
    EXPIRES_QUERY_PARAM: () => UcQ,
    GENERATED_HEADERS: () => wcQ,
    HOST_HEADER: () => MM8,
    KEY_TYPE_IDENTIFIER: () => lS1,
    MAX_CACHE_SIZE: () => PcQ,
    MAX_PRESIGNED_TTL: () => jcQ,
    PROXY_HEADER_PATTERN: () => McQ,
    REGION_SET_PARAM: () => LM8,
    SEC_HEADER_PATTERN: () => OcQ,
    SHA256_HEADER: () => gcA,
    SIGNATURE_HEADER: () => qcQ,
    SIGNATURE_QUERY_PARAM: () => mS1,
    SIGNED_HEADERS_QUERY_PARAM: () => zcQ,
    SignatureV4: () => fM8,
    SignatureV4Base: () => vcQ,
    TOKEN_HEADER: () => NcQ,
    TOKEN_QUERY_PARAM: () => dS1,
    UNSIGNABLE_PATTERNS: () => OM8,
    UNSIGNED_PAYLOAD: () => TcQ,
    clearCredentialCache: () => PM8,
    createScope: () => bcA,
    getCanonicalHeaders: () => fS1,
    getCanonicalQuery: () => xcQ,
    getPayloadHash: () => fcA,
    getSigningKey: () => ScQ,
    hasHeader: () => _cQ,
    moveHeadersToQuery: () => ycQ,
    prepareRequest: () => gS1,
    signatureV4aContainer: () => hM8
  });
  bcQ.exports = NM8(HcQ);
  var VcQ = O2(),
    CcQ = "X-Amz-Algorithm",
    EcQ = "X-Amz-Credential",
    uS1 = "X-Amz-Date",
    zcQ = "X-Amz-SignedHeaders",
    UcQ = "X-Amz-Expires",
    mS1 = "X-Amz-Signature",
    dS1 = "X-Amz-Security-Token",
    LM8 = "X-Amz-Region-Set",
    cS1 = "authorization",
    pS1 = uS1.toLowerCase(),
    $cQ = "date",
    wcQ = [cS1, pS1, $cQ],
    qcQ = mS1.toLowerCase(),
    gcA = "x-amz-content-sha256",
    NcQ = dS1.toLowerCase(),
    MM8 = "host",
    LcQ = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0
    },
    McQ = /^proxy-/,
    OcQ = /^sec-/,
    OM8 = [/^proxy-/i, /^sec-/i],
    xcA = "AWS4-HMAC-SHA256",
    RM8 = "AWS4-ECDSA-P256-SHA256",
    RcQ = "AWS4-HMAC-SHA256-PAYLOAD",
    TcQ = "UNSIGNED-PAYLOAD",
    PcQ = 50,
    lS1 = "aws4_request",
    jcQ = 604800,
    Gc = Jd(),
    TM8 = O2(),
    J5A = {},
    vcA = [],
    bcA = DD((A, Q, B) => `${A}/${Q}/${B}/${lS1}`, "createScope"),
    ScQ = DD(async (A, Q, B, G, Z) => {
      let I = await FcQ(A, Q.secretAccessKey, Q.accessKeyId),
        Y = `${B}:${G}:${Z}:${(0,Gc.toHex)(I)}:${Q.sessionToken}`;
      if (Y in J5A) return J5A[Y];
      vcA.push(Y);
      while (vcA.length > PcQ) delete J5A[vcA.shift()];
      let J = `AWS4${Q.secretAccessKey}`;
      for (let W of [B, G, Z, lS1]) J = await FcQ(A, J, W);
      return J5A[Y] = J
    }, "getSigningKey"),
    PM8 = DD(() => {
      vcA.length = 0, Object.keys(J5A).forEach((A) => {
        delete J5A[A]
      })
    }, "clearCredentialCache"),
    FcQ = DD((A, Q, B) => {
      let G = new A(Q);
      return G.update((0, TM8.toUint8Array)(B)), G.digest()
    }, "hmac"),
    fS1 = DD(({
      headers: A
    }, Q, B) => {
      let G = {};
      for (let Z of Object.keys(A).sort()) {
        if (A[Z] == null) continue;
        let I = Z.toLowerCase();
        if (I in LcQ || Q?.has(I) || McQ.test(I) || OcQ.test(I)) {
          if (!B || B && !B.has(I)) continue
        }
        G[I] = A[Z].trim().replace(/\s+/g, " ")
      }
      return G
    }, "getCanonicalHeaders"),
    jM8 = IcQ(),
    SM8 = O2(),
    fcA = DD(async ({
      headers: A,
      body: Q
    }, B) => {
      for (let G of Object.keys(A))
        if (G.toLowerCase() === gcA) return A[G];
      if (Q == null) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      else if (typeof Q === "string" || ArrayBuffer.isView(Q) || (0, jM8.isArrayBuffer)(Q)) {
        let G = new B;
        return G.update((0, SM8.toUint8Array)(Q)), (0, Gc.toHex)(await G.digest())
      }
      return TcQ
    }, "getPayloadHash"),
    KcQ = O2(),
    _M8 = class {
      static {
        DD(this, "HeaderFormatter")
      }
      format(A) {
        let Q = [];
        for (let Z of Object.keys(A)) {
          let I = (0, KcQ.fromUtf8)(Z);
          Q.push(Uint8Array.from([I.byteLength]), I, this.formatHeaderValue(A[Z]))
        }
        let B = new Uint8Array(Q.reduce((Z, I) => Z + I.byteLength, 0)),
          G = 0;
        for (let Z of Q) B.set(Z, G), G += Z.byteLength;
        return B
      }
      formatHeaderValue(A) {
        switch (A.type) {
          case "boolean":
            return Uint8Array.from([A.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, A.value]);
          case "short":
            let Q = new DataView(new ArrayBuffer(3));
            return Q.setUint8(0, 3), Q.setInt16(1, A.value, !1), new Uint8Array(Q.buffer);
          case "integer":
            let B = new DataView(new ArrayBuffer(5));
            return B.setUint8(0, 4), B.setInt32(1, A.value, !1), new Uint8Array(B.buffer);
          case "long":
            let G = new Uint8Array(9);
            return G[0] = 5, G.set(A.value.bytes, 1), G;
          case "binary":
            let Z = new DataView(new ArrayBuffer(3 + A.value.byteLength));
            Z.setUint8(0, 6), Z.setUint16(1, A.value.byteLength, !1);
            let I = new Uint8Array(Z.buffer);
            return I.set(A.value, 3), I;
          case "string":
            let Y = (0, KcQ.fromUtf8)(A.value),
              J = new DataView(new ArrayBuffer(3 + Y.byteLength));
            J.setUint8(0, 7), J.setUint16(1, Y.byteLength, !1);
            let W = new Uint8Array(J.buffer);
            return W.set(Y, 3), W;
          case "timestamp":
            let X = new Uint8Array(9);
            return X[0] = 8, X.set(yM8.fromNumber(A.value.valueOf()).bytes, 1), X;
          case "uuid":
            if (!kM8.test(A.value)) throw Error(`Invalid UUID received: ${A.value}`);
            let V = new Uint8Array(17);
            return V[0] = 9, V.set((0, Gc.fromHex)(A.value.replace(/\-/g, "")), 1), V
        }
      }
    },
    kM8 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    yM8 = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static {
        DD(this, "Int64")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) hS1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) hS1(Q);
        return parseInt((0, Gc.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };

  function hS1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  DD(hS1, "negate");
  var _cQ = DD((A, Q) => {
      A = A.toLowerCase();
      for (let B of Object.keys(Q))
        if (A === B.toLowerCase()) return !0;
      return !1
    }, "hasHeader"),
    kcQ = iCA(),
    ycQ = DD((A, Q = {}) => {
      let {
        headers: B,
        query: G = {}
      } = kcQ.HttpRequest.clone(A);
      for (let Z of Object.keys(B)) {
        let I = Z.toLowerCase();
        if (I.slice(0, 6) === "x-amz-" && !Q.unhoistableHeaders?.has(I) || Q.hoistableHeaders?.has(I)) G[Z] = B[Z], delete B[Z]
      }
      return {
        ...A,
        headers: B,
        query: G
      }
    }, "moveHeadersToQuery"),
    gS1 = DD((A) => {
      A = kcQ.HttpRequest.clone(A);
      for (let Q of Object.keys(A.headers))
        if (wcQ.indexOf(Q.toLowerCase()) > -1) delete A.headers[Q];
      return A
    }, "prepareRequest"),
    DcQ = w7(),
    xM8 = O2(),
    hcA = XcQ(),
    xcQ = DD(({
      query: A = {}
    }) => {
      let Q = [],
        B = {};
      for (let G of Object.keys(A)) {
        if (G.toLowerCase() === qcQ) continue;
        let Z = (0, hcA.escapeUri)(G);
        Q.push(Z);
        let I = A[G];
        if (typeof I === "string") B[Z] = `${Z}=${(0,hcA.escapeUri)(I)}`;
        else if (Array.isArray(I)) B[Z] = I.slice(0).reduce((Y, J) => Y.concat([`${Z}=${(0,hcA.escapeUri)(J)}`]), []).sort().join("&")
      }
      return Q.sort().map((G) => B[G]).filter((G) => G).join("&")
    }, "getCanonicalQuery"),
    vM8 = DD((A) => bM8(A).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601"),
    bM8 = DD((A) => {
      if (typeof A === "number") return new Date(A * 1000);
      if (typeof A === "string") {
        if (Number(A)) return new Date(Number(A) * 1000);
        return new Date(A)
      }
      return A
    }, "toDate"),
    vcQ = class {
      static {
        DD(this, "SignatureV4Base")
      }
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        this.service = G, this.sha256 = Z, this.uriEscapePath = I, this.applyChecksum = typeof A === "boolean" ? A : !0, this.regionProvider = (0, DcQ.normalizeProvider)(B), this.credentialProvider = (0, DcQ.normalizeProvider)(Q)
      }
      createCanonicalRequest(A, Q, B) {
        let G = Object.keys(Q).sort();
        return `${A.method}
${this.getCanonicalPath(A)}
${xcQ(A)}
${G.map((Z)=>`${Z}:${Q[Z]}`).join(`
`)}

${G.join(";")}
${B}`
      }
      async createStringToSign(A, Q, B, G) {
        let Z = new this.sha256;
        Z.update((0, xM8.toUint8Array)(B));
        let I = await Z.digest();
        return `${G}
${A}
${Q}
${(0,Gc.toHex)(I)}`
      }
      getCanonicalPath({
        path: A
      }) {
        if (this.uriEscapePath) {
          let Q = [];
          for (let Z of A.split("/")) {
            if (Z?.length === 0) continue;
            if (Z === ".") continue;
            if (Z === "..") Q.pop();
            else Q.push(Z)
          }
          let B = `${A?.startsWith("/")?"/":""}${Q.join("/")}${Q.length>0&&A?.endsWith("/")?"/":""}`;
          return (0, hcA.escapeUri)(B).replace(/%2F/g, "/")
        }
        return A
      }
      validateResolvedCredentials(A) {
        if (typeof A !== "object" || typeof A.accessKeyId !== "string" || typeof A.secretAccessKey !== "string") throw Error("Resolved credential object is not valid")
      }
      formatDate(A) {
        let Q = vM8(A).replace(/[\-:]/g, "");
        return {
          longDate: Q,
          shortDate: Q.slice(0, 8)
        }
      }
      getCanonicalHeaderList(A) {
        return Object.keys(A).sort().join(";")
      }
    },
    fM8 = class extends vcQ {
      constructor({
        applyChecksum: A,
        credentials: Q,
        region: B,
        service: G,
        sha256: Z,
        uriEscapePath: I = !0
      }) {
        super({
          applyChecksum: A,
          credentials: Q,
          region: B,
          service: G,
          sha256: Z,
          uriEscapePath: I
        });
        this.headerFormatter = new _M8
      }
      static {
        DD(this, "SignatureV4")
      }
      async presign(A, Q = {}) {
        let {
          signingDate: B = new Date,
          expiresIn: G = 3600,
          unsignableHeaders: Z,
          unhoistableHeaders: I,
          signableHeaders: Y,
          hoistableHeaders: J,
          signingRegion: W,
          signingService: X
        } = Q, V = await this.credentialProvider();
        this.validateResolvedCredentials(V);
        let F = W ?? await this.regionProvider(),
          {
            longDate: K,
            shortDate: D
          } = this.formatDate(B);
        if (G > jcQ) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        let H = bcA(D, F, X ?? this.service),
          C = ycQ(gS1(A), {
            unhoistableHeaders: I,
            hoistableHeaders: J
          });
        if (V.sessionToken) C.query[dS1] = V.sessionToken;
        C.query[CcQ] = xcA, C.query[EcQ] = `${V.accessKeyId}/${H}`, C.query[uS1] = K, C.query[UcQ] = G.toString(10);
        let E = fS1(C, Z, Y);
        return C.query[zcQ] = this.getCanonicalHeaderList(E), C.query[mS1] = await this.getSignature(K, H, this.getSigningKey(V, F, D, X), this.createCanonicalRequest(C, E, await fcA(A, this.sha256))), C
      }
      async sign(A, Q) {
        if (typeof A === "string") return this.signString(A, Q);
        else if (A.headers && A.payload) return this.signEvent(A, Q);
        else if (A.message) return this.signMessage(A, Q);
        else return this.signRequest(A, Q)
      }
      async signEvent({
        headers: A,
        payload: Q
      }, {
        signingDate: B = new Date,
        priorSignature: G,
        signingRegion: Z,
        signingService: I
      }) {
        let Y = Z ?? await this.regionProvider(),
          {
            shortDate: J,
            longDate: W
          } = this.formatDate(B),
          X = bcA(J, Y, I ?? this.service),
          V = await fcA({
            headers: {},
            body: Q
          }, this.sha256),
          F = new this.sha256;
        F.update(A);
        let K = (0, Gc.toHex)(await F.digest()),
          D = [RcQ, W, X, G, K, V].join(`
`);
        return this.signString(D, {
          signingDate: B,
          signingRegion: Y,
          signingService: I
        })
      }
      async signMessage(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      }) {
        return this.signEvent({
          headers: this.headerFormatter.format(A.message.headers),
          payload: A.message.body
        }, {
          signingDate: Q,
          signingRegion: B,
          signingService: G,
          priorSignature: A.priorSignature
        }).then((I) => {
          return {
            message: A.message,
            signature: I
          }
        })
      }
      async signString(A, {
        signingDate: Q = new Date,
        signingRegion: B,
        signingService: G
      } = {}) {
        let Z = await this.credentialProvider();
        this.validateResolvedCredentials(Z);
        let I = B ?? await this.regionProvider(),
          {
            shortDate: Y
          } = this.formatDate(Q),
          J = new this.sha256(await this.getSigningKey(Z, I, Y, G));
        return J.update((0, VcQ.toUint8Array)(A)), (0, Gc.toHex)(await J.digest())
      }
      async signRequest(A, {
        signingDate: Q = new Date,
        signableHeaders: B,
        unsignableHeaders: G,
        signingRegion: Z,
        signingService: I
      } = {}) {
        let Y = await this.credentialProvider();
        this.validateResolvedCredentials(Y);
        let J = Z ?? await this.regionProvider(),
          W = gS1(A),
          {
            longDate: X,
            shortDate: V
          } = this.formatDate(Q),
          F = bcA(V, J, I ?? this.service);
        if (W.headers[pS1] = X, Y.sessionToken) W.headers[NcQ] = Y.sessionToken;
        let K = await fcA(W, this.sha256);
        if (!_cQ(gcA, W.headers) && this.applyChecksum) W.headers[gcA] = K;
        let D = fS1(W, G, B),
          H = await this.getSignature(X, F, this.getSigningKey(Y, J, V, I), this.createCanonicalRequest(W, D, K));
        return W.headers[cS1] = `${xcA} Credential=${Y.accessKeyId}/${F}, SignedHeaders=${this.getCanonicalHeaderList(D)}, Signature=${H}`, W
      }
      async getSignature(A, Q, B, G) {
        let Z = await this.createStringToSign(A, Q, G, xcA),
          I = new this.sha256(await B);
        return I.update((0, VcQ.toUint8Array)(Z)), (0, Gc.toHex)(await I.digest())
      }
      getSigningKey(A, Q, B, G) {
        return ScQ(this.sha256, A, B, Q, G || this.service)
      }
    },
    hM8 = {
      SignatureV4a: null
    }
})
// @from(Start 4258558, End 4267145)
ncQ = z((YP7, icQ) => {
  var {
    defineProperty: mcA,
    getOwnPropertyDescriptor: gM8,
    getOwnPropertyNames: uM8
  } = Object, mM8 = Object.prototype.hasOwnProperty, HD = (A, Q) => mcA(A, "name", {
    value: Q,
    configurable: !0
  }), dM8 = (A, Q) => {
    for (var B in Q) mcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, cM8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of uM8(Q))
        if (!mM8.call(A, Z) && Z !== B) mcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = gM8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, pM8 = (A) => cM8(mcA({}, "__esModule", {
    value: !0
  }), A), dcQ = {};
  dM8(dcQ, {
    AWSSDKSigV4Signer: () => aM8,
    AwsSdkSigV4ASigner: () => rM8,
    AwsSdkSigV4Signer: () => aS1,
    NODE_SIGV4A_CONFIG_OPTIONS: () => eM8,
    resolveAWSSDKSigV4Config: () => QO8,
    resolveAwsSdkSigV4AConfig: () => tM8,
    resolveAwsSdkSigV4Config: () => ccQ,
    validateSigningProperties: () => nS1
  });
  icQ.exports = pM8(dcQ);
  var lM8 = iCA(),
    iM8 = iCA(),
    hcQ = HD((A) => iM8.HttpResponse.isInstance(A) ? A.headers?.date ?? A.headers?.Date : void 0, "getDateHeader"),
    iS1 = HD((A) => new Date(Date.now() + A), "getSkewCorrectedDate"),
    nM8 = HD((A, Q) => Math.abs(iS1(Q).getTime() - A) >= 300000, "isClockSkewed"),
    gcQ = HD((A, Q) => {
      let B = Date.parse(A);
      if (nM8(B, Q)) return B - Date.now();
      return Q
    }, "getUpdatedSystemClockOffset"),
    nCA = HD((A, Q) => {
      if (!Q) throw Error(`Property \`${A}\` is not resolved for AWS SDK SigV4Auth`);
      return Q
    }, "throwSigningPropertyError"),
    nS1 = HD(async (A) => {
      let Q = nCA("context", A.context),
        B = nCA("config", A.config),
        G = Q.endpointV2?.properties?.authSchemes?.[0],
        I = await nCA("signer", B.signer)(G),
        Y = A?.signingRegion,
        J = A?.signingRegionSet,
        W = A?.signingName;
      return {
        config: B,
        signer: I,
        signingRegion: Y,
        signingRegionSet: J,
        signingName: W
      }
    }, "validateSigningProperties"),
    aS1 = class {
      static {
        HD(this, "AwsSdkSigV4Signer")
      }
      async sign(A, Q, B) {
        if (!lM8.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let G = await nS1(B),
          {
            config: Z,
            signer: I
          } = G,
          {
            signingRegion: Y,
            signingName: J
          } = G,
          W = B.context;
        if (W?.authSchemes?.length ?? !1) {
          let [V, F] = W.authSchemes;
          if (V?.name === "sigv4a" && F?.name === "sigv4") Y = F?.signingRegion ?? Y, J = F?.signingName ?? J
        }
        return await I.sign(A, {
          signingDate: iS1(Z.systemClockOffset),
          signingRegion: Y,
          signingService: J
        })
      }
      errorHandler(A) {
        return (Q) => {
          let B = Q.ServerTime ?? hcQ(Q.$response);
          if (B) {
            let G = nCA("config", A.config),
              Z = G.systemClockOffset;
            if (G.systemClockOffset = gcQ(B, G.systemClockOffset), G.systemClockOffset !== Z && Q.$metadata) Q.$metadata.clockSkewCorrected = !0
          }
          throw Q
        }
      }
      successHandler(A, Q) {
        let B = hcQ(A);
        if (B) {
          let G = nCA("config", Q.config);
          G.systemClockOffset = gcQ(B, G.systemClockOffset)
        }
      }
    },
    aM8 = aS1,
    sM8 = iCA(),
    rM8 = class extends aS1 {
      static {
        HD(this, "AwsSdkSigV4ASigner")
      }
      async sign(A, Q, B) {
        if (!sM8.HttpRequest.isInstance(A)) throw Error("The request is not an instance of `HttpRequest` and cannot be signed");
        let {
          config: G,
          signer: Z,
          signingRegion: I,
          signingRegionSet: Y,
          signingName: J
        } = await nS1(B), X = (await G.sigv4aSigningRegionSet?.() ?? Y ?? [I]).join(",");
        return await Z.sign(A, {
          signingDate: iS1(G.systemClockOffset),
          signingRegion: X,
          signingService: J
        })
      }
    },
    oM8 = iB(),
    ucQ = j2(),
    tM8 = HD((A) => {
      return A.sigv4aSigningRegionSet = (0, oM8.normalizeProvider)(A.sigv4aSigningRegionSet), A
    }, "resolveAwsSdkSigV4AConfig"),
    eM8 = {
      environmentVariableSelector(A) {
        if (A.AWS_SIGV4A_SIGNING_REGION_SET) return A.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((Q) => Q.trim());
        throw new ucQ.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
          tryNextLink: !0
        })
      },
      configFileSelector(A) {
        if (A.sigv4a_signing_region_set) return (A.sigv4a_signing_region_set ?? "").split(",").map((Q) => Q.trim());
        throw new ucQ.ProviderError("sigv4a_signing_region_set not set in profile.", {
          tryNextLink: !0
        })
      },
      default: void 0
    },
    AO8 = rS(),
    Ro = iB(),
    mcQ = fcQ(),
    ccQ = HD((A) => {
      let Q = A.credentials,
        B = !!A.credentials,
        G = void 0;
      Object.defineProperty(A, "credentials", {
        set(X) {
          if (X && X !== Q && X !== G) B = !0;
          Q = X;
          let V = pcQ(A, {
              credentials: Q,
              credentialDefaultProvider: A.credentialDefaultProvider
            }),
            F = lcQ(A, V);
          if (B && !F.attributed) G = HD(async (K) => F(K).then((D) => (0, AO8.setCredentialFeature)(D, "CREDENTIALS_CODE", "e")), "resolvedCredentials"), G.memoized = F.memoized, G.configBound = F.configBound, G.attributed = !0;
          else G = F
        },
        get() {
          return G
        },
        enumerable: !0,
        configurable: !0
      }), A.credentials = Q;
      let {
        signingEscapePath: Z = !0,
        systemClockOffset: I = A.systemClockOffset || 0,
        sha256: Y
      } = A, J;
      if (A.signer) J = (0, Ro.normalizeProvider)(A.signer);
      else if (A.regionInfoProvider) J = HD(() => (0, Ro.normalizeProvider)(A.region)().then(async (X) => [await A.regionInfoProvider(X, {
        useFipsEndpoint: await A.useFipsEndpoint(),
        useDualstackEndpoint: await A.useDualstackEndpoint()
      }) || {}, X]).then(([X, V]) => {
        let {
          signingRegion: F,
          signingService: K
        } = X;
        A.signingRegion = A.signingRegion || F || V, A.signingName = A.signingName || K || A.serviceId;
        let D = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || mcQ.SignatureV4)(D)
      }), "signer");
      else J = HD(async (X) => {
        X = Object.assign({}, {
          name: "sigv4",
          signingName: A.signingName || A.defaultSigningName,
          signingRegion: await (0, Ro.normalizeProvider)(A.region)(),
          properties: {}
        }, X);
        let {
          signingRegion: V,
          signingName: F
        } = X;
        A.signingRegion = A.signingRegion || V, A.signingName = A.signingName || F || A.serviceId;
        let K = {
          ...A,
          credentials: A.credentials,
          region: A.signingRegion,
          service: A.signingName,
          sha256: Y,
          uriEscapePath: Z
        };
        return new(A.signerConstructor || mcQ.SignatureV4)(K)
      }, "signer");
      return Object.assign(A, {
        systemClockOffset: I,
        signingEscapePath: Z,
        signer: J
      })
    }, "resolveAwsSdkSigV4Config"),
    QO8 = ccQ;

  function pcQ(A, {
    credentials: Q,
    credentialDefaultProvider: B
  }) {
    let G;
    if (Q)
      if (!Q?.memoized) G = (0, Ro.memoizeIdentityProvider)(Q, Ro.isIdentityExpired, Ro.doesIdentityRequireRefresh);
      else G = Q;
    else if (B) G = (0, Ro.normalizeProvider)(B(Object.assign({}, A, {
      parentClientConfig: A
    })));
    else G = HD(async () => {
      throw Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.")
    }, "credentialsProvider");
    return G.memoized = !0, G
  }
  HD(pcQ, "normalizeCredentialProvider");

  function lcQ(A, Q) {
    if (Q.configBound) return Q;
    let B = HD(async (G) => Q({
      ...G,
      callerClientConfig: A
    }), "fn");
    return B.memoized = Q.memoized, B.configBound = !0, B
  }
  HD(lcQ, "bindCallerConfig")
})
// @from(Start 4267151, End 4295606)
lcA = z((XP7, FpQ) => {
  var {
    defineProperty: pcA,
    getOwnPropertyDescriptor: BO8,
    getOwnPropertyNames: GO8
  } = Object, ZO8 = Object.prototype.hasOwnProperty, DB = (A, Q) => pcA(A, "name", {
    value: Q,
    configurable: !0
  }), IO8 = (A, Q) => {
    for (var B in Q) pcA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, YO8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of GO8(Q))
        if (!ZO8.call(A, Z) && Z !== B) pcA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = BO8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, JO8 = (A) => YO8(pcA({}, "__esModule", {
    value: !0
  }), A), scQ = {};
  IO8(scQ, {
    Client: () => WO8,
    Command: () => ocQ,
    LazyJsonString: () => To,
    NoOpLogger: () => ZR8,
    SENSITIVE_STRING: () => VO8,
    ServiceException: () => lO8,
    _json: () => Q_1,
    collectBody: () => sS1.collectBody,
    convertMap: () => IR8,
    createAggregatedClient: () => FO8,
    dateToUtcString: () => GpQ,
    decorateServiceException: () => ZpQ,
    emitWarningIfUnsupportedVersion: () => sO8,
    expectBoolean: () => DO8,
    expectByte: () => A_1,
    expectFloat32: () => dcA,
    expectInt: () => CO8,
    expectInt32: () => tS1,
    expectLong: () => rCA,
    expectNonNull: () => zO8,
    expectNumber: () => sCA,
    expectObject: () => tcQ,
    expectShort: () => eS1,
    expectString: () => UO8,
    expectUnion: () => $O8,
    extendedEncodeURIComponent: () => sS1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => BR8,
    getDefaultClientConfiguration: () => AR8,
    getDefaultExtensionConfiguration: () => YpQ,
    getValueFromTextNode: () => JpQ,
    handleFloat: () => NO8,
    isSerializableHeaderValue: () => GR8,
    limitedParseDouble: () => Z_1,
    limitedParseFloat: () => LO8,
    limitedParseFloat32: () => MO8,
    loadConfigsForDefaultMode: () => aO8,
    logger: () => oCA,
    map: () => Y_1,
    parseBoolean: () => KO8,
    parseEpochTimestamp: () => bO8,
    parseRfc3339DateTime: () => jO8,
    parseRfc3339DateTimeWithOffset: () => _O8,
    parseRfc7231DateTime: () => vO8,
    quoteHeader: () => XpQ,
    resolveDefaultRuntimeConfig: () => QR8,
    resolvedPath: () => sS1.resolvedPath,
    serializeDateTime: () => FR8,
    serializeFloat: () => VR8,
    splitEvery: () => VpQ,
    splitHeader: () => KR8,
    strictParseByte: () => BpQ,
    strictParseDouble: () => G_1,
    strictParseFloat: () => wO8,
    strictParseFloat32: () => ecQ,
    strictParseInt: () => OO8,
    strictParseInt32: () => RO8,
    strictParseLong: () => QpQ,
    strictParseShort: () => W5A,
    take: () => YR8,
    throwDefaultError: () => IpQ,
    withBaseException: () => iO8
  });
  FpQ.exports = JO8(scQ);
  var rcQ = uR(),
    WO8 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, rcQ.constructStack)()
      }
      static {
        DB(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    sS1 = w5(),
    oS1 = vS1(),
    ocQ = class {
      constructor() {
        this.middlewareStack = (0, rcQ.constructStack)()
      }
      static {
        DB(this, "Command")
      }
      static classBuilder() {
        return new XO8
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [oS1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    XO8 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        DB(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends ocQ {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this)
          }
          static {
            DB(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    VO8 = "***SensitiveInformation***",
    FO8 = DB((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = DB(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    KO8 = DB((A) => {
      switch (A) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw Error(`Unable to parse boolean value "${A}"`)
      }
    }, "parseBoolean"),
    DO8 = DB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "number") {
        if (A === 0 || A === 1) oCA.warn(ccA(`Expected boolean, got ${typeof A}: ${A}`));
        if (A === 0) return !1;
        if (A === 1) return !0
      }
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (Q === "false" || Q === "true") oCA.warn(ccA(`Expected boolean, got ${typeof A}: ${A}`));
        if (Q === "false") return !1;
        if (Q === "true") return !0
      }
      if (typeof A === "boolean") return A;
      throw TypeError(`Expected boolean, got ${typeof A}: ${A}`)
    }, "expectBoolean"),
    sCA = DB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") {
        let Q = parseFloat(A);
        if (!Number.isNaN(Q)) {
          if (String(Q) !== String(A)) oCA.warn(ccA(`Expected number but observed string: ${A}`));
          return Q
        }
      }
      if (typeof A === "number") return A;
      throw TypeError(`Expected number, got ${typeof A}: ${A}`)
    }, "expectNumber"),
    HO8 = Math.ceil(340282346638528860000000000000000000000),
    dcA = DB((A) => {
      let Q = sCA(A);
      if (Q !== void 0 && !Number.isNaN(Q) && Q !== 1 / 0 && Q !== -1 / 0) {
        if (Math.abs(Q) > HO8) throw TypeError(`Expected 32-bit float, got ${A}`)
      }
      return Q
    }, "expectFloat32"),
    rCA = DB((A) => {
      if (A === null || A === void 0) return;
      if (Number.isInteger(A) && !Number.isNaN(A)) return A;
      throw TypeError(`Expected integer, got ${typeof A}: ${A}`)
    }, "expectLong"),
    CO8 = rCA,
    tS1 = DB((A) => B_1(A, 32), "expectInt32"),
    eS1 = DB((A) => B_1(A, 16), "expectShort"),
    A_1 = DB((A) => B_1(A, 8), "expectByte"),
    B_1 = DB((A, Q) => {
      let B = rCA(A);
      if (B !== void 0 && EO8(B, Q) !== B) throw TypeError(`Expected ${Q}-bit integer, got ${A}`);
      return B
    }, "expectSizedInt"),
    EO8 = DB((A, Q) => {
      switch (Q) {
        case 32:
          return Int32Array.of(A)[0];
        case 16:
          return Int16Array.of(A)[0];
        case 8:
          return Int8Array.of(A)[0]
      }
    }, "castInt"),
    zO8 = DB((A, Q) => {
      if (A === null || A === void 0) {
        if (Q) throw TypeError(`Expected a non-null value for ${Q}`);
        throw TypeError("Expected a non-null value")
      }
      return A
    }, "expectNonNull"),
    tcQ = DB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "object" && !Array.isArray(A)) return A;
      let Q = Array.isArray(A) ? "array" : typeof A;
      throw TypeError(`Expected object, got ${Q}: ${A}`)
    }, "expectObject"),
    UO8 = DB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") return A;
      if (["boolean", "number", "bigint"].includes(typeof A)) return oCA.warn(ccA(`Expected string, got ${typeof A}: ${A}`)), String(A);
      throw TypeError(`Expected string, got ${typeof A}: ${A}`)
    }, "expectString"),
    $O8 = DB((A) => {
      if (A === null || A === void 0) return;
      let Q = tcQ(A),
        B = Object.entries(Q).filter(([, G]) => G != null).map(([G]) => G);
      if (B.length === 0) throw TypeError("Unions must have exactly one non-null member. None were found.");
      if (B.length > 1) throw TypeError(`Unions must have exactly one non-null member. Keys ${B} were not null.`);
      return Q
    }, "expectUnion"),
    G_1 = DB((A) => {
      if (typeof A == "string") return sCA(V5A(A));
      return sCA(A)
    }, "strictParseDouble"),
    wO8 = G_1,
    ecQ = DB((A) => {
      if (typeof A == "string") return dcA(V5A(A));
      return dcA(A)
    }, "strictParseFloat32"),
    qO8 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    V5A = DB((A) => {
      let Q = A.match(qO8);
      if (Q === null || Q[0].length !== A.length) throw TypeError("Expected real number, got implicit NaN");
      return parseFloat(A)
    }, "parseNumber"),
    Z_1 = DB((A) => {
      if (typeof A == "string") return ApQ(A);
      return sCA(A)
    }, "limitedParseDouble"),
    NO8 = Z_1,
    LO8 = Z_1,
    MO8 = DB((A) => {
      if (typeof A == "string") return ApQ(A);
      return dcA(A)
    }, "limitedParseFloat32"),
    ApQ = DB((A) => {
      switch (A) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw Error(`Unable to parse float value: ${A}`)
      }
    }, "parseFloatString"),
    QpQ = DB((A) => {
      if (typeof A === "string") return rCA(V5A(A));
      return rCA(A)
    }, "strictParseLong"),
    OO8 = QpQ,
    RO8 = DB((A) => {
      if (typeof A === "string") return tS1(V5A(A));
      return tS1(A)
    }, "strictParseInt32"),
    W5A = DB((A) => {
      if (typeof A === "string") return eS1(V5A(A));
      return eS1(A)
    }, "strictParseShort"),
    BpQ = DB((A) => {
      if (typeof A === "string") return A_1(V5A(A));
      return A_1(A)
    }, "strictParseByte"),
    ccA = DB((A) => {
      return String(TypeError(A).stack || A).split(`
`).slice(0, 5).filter((Q) => !Q.includes("stackTraceWarning")).join(`
`)
    }, "stackTraceWarning"),
    oCA = {
      warn: console.warn
    },
    TO8 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    I_1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  function GpQ(A) {
    let Q = A.getUTCFullYear(),
      B = A.getUTCMonth(),
      G = A.getUTCDay(),
      Z = A.getUTCDate(),
      I = A.getUTCHours(),
      Y = A.getUTCMinutes(),
      J = A.getUTCSeconds(),
      W = Z < 10 ? `0${Z}` : `${Z}`,
      X = I < 10 ? `0${I}` : `${I}`,
      V = Y < 10 ? `0${Y}` : `${Y}`,
      F = J < 10 ? `0${J}` : `${J}`;
    return `${TO8[G]}, ${W} ${I_1[B]} ${Q} ${X}:${V}:${F} GMT`
  }
  DB(GpQ, "dateToUtcString");
  var PO8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/),
    jO8 = DB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = PO8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X] = Q, V = W5A(X5A(G)), F = tS(Z, "month", 1, 12), K = tS(I, "day", 1, 31);
      return aCA(V, F, K, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      })
    }, "parseRfc3339DateTime"),
    SO8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/),
    _O8 = DB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = SO8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X, V] = Q, F = W5A(X5A(G)), K = tS(Z, "month", 1, 12), D = tS(I, "day", 1, 31), H = aCA(F, K, D, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      });
      if (V.toUpperCase() != "Z") H.setTime(H.getTime() - pO8(V));
      return H
    }, "parseRfc3339DateTimeWithOffset"),
    kO8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    yO8 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    xO8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/),
    vO8 = DB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-7231 date-times must be expressed as strings");
      let Q = kO8.exec(A);
      if (Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return aCA(W5A(X5A(I)), rS1(Z), tS(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        })
      }
      if (Q = yO8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return gO8(aCA(fO8(I), rS1(Z), tS(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        }))
      }
      if (Q = xO8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return aCA(W5A(X5A(X)), rS1(G), tS(Z.trimLeft(), "day", 1, 31), {
          hours: I,
          minutes: Y,
          seconds: J,
          fractionalMilliseconds: W
        })
      }
      throw TypeError("Invalid RFC-7231 date-time value")
    }, "parseRfc7231DateTime"),
    bO8 = DB((A) => {
      if (A === null || A === void 0) return;
      let Q;
      if (typeof A === "number") Q = A;
      else if (typeof A === "string") Q = G_1(A);
      else if (typeof A === "object" && A.tag === 1) Q = A.value;
      else throw TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      if (Number.isNaN(Q) || Q === 1 / 0 || Q === -1 / 0) throw TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      return new Date(Math.round(Q * 1000))
    }, "parseEpochTimestamp"),
    aCA = DB((A, Q, B, G) => {
      let Z = Q - 1;
      return mO8(A, Z, B), new Date(Date.UTC(A, Z, B, tS(G.hours, "hour", 0, 23), tS(G.minutes, "minute", 0, 59), tS(G.seconds, "seconds", 0, 60), cO8(G.fractionalMilliseconds)))
    }, "buildDate"),
    fO8 = DB((A) => {
      let Q = new Date().getUTCFullYear(),
        B = Math.floor(Q / 100) * 100 + W5A(X5A(A));
      if (B < Q) return B + 100;
      return B
    }, "parseTwoDigitYear"),
    hO8 = 1576800000000,
    gO8 = DB((A) => {
      if (A.getTime() - new Date().getTime() > hO8) return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));
      return A
    }, "adjustRfc850Year"),
    rS1 = DB((A) => {
      let Q = I_1.indexOf(A);
      if (Q < 0) throw TypeError(`Invalid month: ${A}`);
      return Q + 1
    }, "parseMonthByShortName"),
    uO8 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    mO8 = DB((A, Q, B) => {
      let G = uO8[Q];
      if (Q === 1 && dO8(A)) G = 29;
      if (B > G) throw TypeError(`Invalid day for ${I_1[Q]} in ${A}: ${B}`)
    }, "validateDayOfMonth"),
    dO8 = DB((A) => {
      return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0)
    }, "isLeapYear"),
    tS = DB((A, Q, B, G) => {
      let Z = BpQ(X5A(A));
      if (Z < B || Z > G) throw TypeError(`${Q} must be between ${B} and ${G}, inclusive`);
      return Z
    }, "parseDateValue"),
    cO8 = DB((A) => {
      if (A === null || A === void 0) return 0;
      return ecQ("0." + A) * 1000
    }, "parseMilliseconds"),
    pO8 = DB((A) => {
      let Q = A[0],
        B = 1;
      if (Q == "+") B = 1;
      else if (Q == "-") B = -1;
      else throw TypeError(`Offset direction, ${Q}, must be "+" or "-"`);
      let G = Number(A.substring(1, 3)),
        Z = Number(A.substring(4, 6));
      return B * (G * 60 + Z) * 60 * 1000
    }, "parseOffsetToMilliseconds"),
    X5A = DB((A) => {
      let Q = 0;
      while (Q < A.length - 1 && A.charAt(Q) === "0") Q++;
      if (Q === 0) return A;
      return A.slice(Q)
    }, "stripLeadingZeroes"),
    lO8 = class A extends Error {
      static {
        DB(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    ZpQ = DB((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    IpQ = DB(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = nO8(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw ZpQ(Y, Q)
    }, "throwDefaultError"),
    iO8 = DB((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        IpQ({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    nO8 = DB((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    aO8 = DB((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    acQ = !1,
    sO8 = DB((A) => {
      if (A && !acQ && parseInt(A.substring(1, A.indexOf("."))) < 16) acQ = !0
    }, "emitWarningIfUnsupportedVersion"),
    rO8 = DB((A) => {
      let Q = [];
      for (let B in oS1.AlgorithmId) {
        let G = oS1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    oO8 = DB((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    tO8 = DB((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    eO8 = DB((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    YpQ = DB((A) => {
      return Object.assign(rO8(A), tO8(A))
    }, "getDefaultExtensionConfiguration"),
    AR8 = YpQ,
    QR8 = DB((A) => {
      return Object.assign(oO8(A), eO8(A))
    }, "resolveDefaultRuntimeConfig"),
    BR8 = DB((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    JpQ = DB((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = JpQ(A[B]);
      return A
    }, "getValueFromTextNode"),
    GR8 = DB((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    To = DB(function(Q) {
      return Object.assign(new String(Q), {
        deserializeJSON() {
          return JSON.parse(String(Q))
        },
        toString() {
          return String(Q)
        },
        toJSON() {
          return String(Q)
        }
      })
    }, "LazyJsonString");
  To.from = (A) => {
    if (A && typeof A === "object" && (A instanceof To || ("deserializeJSON" in A))) return A;
    else if (typeof A === "string" || Object.getPrototypeOf(A) === String.prototype) return To(String(A));
    return To(JSON.stringify(A))
  };
  To.fromObject = To.from;
  var ZR8 = class {
    static {
      DB(this, "NoOpLogger")
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };

  function Y_1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, JR8(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      WpQ(G, null, I, Y)
    }
    return G
  }
  DB(Y_1, "map");
  var IR8 = DB((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    YR8 = DB((A, Q) => {
      let B = {};
      for (let G in Q) WpQ(B, A, Q, G);
      return B
    }, "take"),
    JR8 = DB((A, Q, B) => {
      return Y_1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    WpQ = DB((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = WR8, W = XR8, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    WR8 = DB((A) => A != null, "nonNullish"),
    XR8 = DB((A) => A, "pass");

  function XpQ(A) {
    if (A.includes(",") || A.includes('"')) A = `"${A.replace(/"/g,"\\\"")}"`;
    return A
  }
  DB(XpQ, "quoteHeader");
  var VR8 = DB((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    FR8 = DB((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    Q_1 = DB((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(Q_1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = Q_1(A[B])
        }
        return Q
      }
      return A
    }, "_json");

  function VpQ(A, Q, B) {
    if (B <= 0 || !Number.isInteger(B)) throw Error("Invalid number of delimiters (" + B + ") for splitEvery.");
    let G = A.split(Q);
    if (B === 1) return G;
    let Z = [],
      I = "";
    for (let Y = 0; Y < G.length; Y++) {
      if (I === "") I = G[Y];
      else I += Q + G[Y];
      if ((Y + 1) % B === 0) Z.push(I), I = ""
    }
    if (I !== "") Z.push(I);
    return Z
  }
  DB(VpQ, "splitEvery");
  var KR8 = DB((A) => {
    let Q = A.length,
      B = [],
      G = !1,
      Z = void 0,
      I = 0;
    for (let Y = 0; Y < Q; ++Y) {
      let J = A[Y];
      switch (J) {
        case '"':
          if (Z !== "\\") G = !G;
          break;
        case ",":
          if (!G) B.push(A.slice(I, Y)), I = Y + 1;
          break;
        default:
      }
      Z = J
    }
    return B.push(A.slice(I)), B.map((Y) => {
      Y = Y.trim();
      let J = Y.length;
      if (J < 2) return Y;
      if (Y[0] === '"' && Y[J - 1] === '"') Y = Y.slice(1, J - 1);
      return Y.replace(/\\"/g, '"')
    })
  }, "splitHeader")
})
// @from(Start 4295612, End 4300683)
zpQ = z((CP7, EpQ) => {
  var {
    defineProperty: icA,
    getOwnPropertyDescriptor: DR8,
    getOwnPropertyNames: HR8
  } = Object, CR8 = Object.prototype.hasOwnProperty, ez = (A, Q) => icA(A, "name", {
    value: Q,
    configurable: !0
  }), ER8 = (A, Q) => {
    for (var B in Q) icA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, zR8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of HR8(Q))
        if (!CR8.call(A, Z) && Z !== B) icA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = DR8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, UR8 = (A) => zR8(icA({}, "__esModule", {
    value: !0
  }), A), KpQ = {};
  ER8(KpQ, {
    _toBool: () => wR8,
    _toNum: () => qR8,
    _toStr: () => $R8,
    awsExpectUnion: () => LR8,
    loadRestJsonErrorCode: () => RR8,
    loadRestXmlErrorCode: () => SR8,
    parseJsonBody: () => HpQ,
    parseJsonErrorBody: () => OR8,
    parseXmlBody: () => CpQ,
    parseXmlErrorBody: () => jR8
  });
  EpQ.exports = UR8(KpQ);
  var $R8 = ez((A) => {
      if (A == null) return A;
      if (typeof A === "number" || typeof A === "bigint") {
        let Q = Error(`Received number ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      if (typeof A === "boolean") {
        let Q = Error(`Received boolean ${A} where a string was expected.`);
        return Q.name = "Warning", console.warn(Q), String(A)
      }
      return A
    }, "_toStr"),
    wR8 = ez((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (A !== "" && Q !== "false" && Q !== "true") {
          let B = Error(`Received string "${A}" where a boolean was expected.`);
          B.name = "Warning", console.warn(B)
        }
        return A !== "" && Q !== "false"
      }
      return A
    }, "_toBool"),
    qR8 = ez((A) => {
      if (A == null) return A;
      if (typeof A === "string") {
        let Q = Number(A);
        if (Q.toString() !== A) {
          let B = Error(`Received string "${A}" where a number was expected.`);
          return B.name = "Warning", console.warn(B), A
        }
        return Q
      }
      return A
    }, "_toNum"),
    NR8 = lcA(),
    LR8 = ez((A) => {
      if (A == null) return;
      if (typeof A === "object" && "__type" in A) delete A.__type;
      return (0, NR8.expectUnion)(A)
    }, "awsExpectUnion"),
    MR8 = lcA(),
    DpQ = ez((A, Q) => (0, MR8.collectBody)(A, Q).then((B) => Q.utf8Encoder(B)), "collectBodyString"),
    HpQ = ez((A, Q) => DpQ(A, Q).then((B) => {
      if (B.length) try {
        return JSON.parse(B)
      } catch (G) {
        if (G?.name === "SyntaxError") Object.defineProperty(G, "$responseBodyText", {
          value: B
        });
        throw G
      }
      return {}
    }), "parseJsonBody"),
    OR8 = ez(async (A, Q) => {
      let B = await HpQ(A, Q);
      return B.message = B.message ?? B.Message, B
    }, "parseJsonErrorBody"),
    RR8 = ez((A, Q) => {
      let B = ez((I, Y) => Object.keys(I).find((J) => J.toLowerCase() === Y.toLowerCase()), "findKey"),
        G = ez((I) => {
          let Y = I;
          if (typeof Y === "number") Y = Y.toString();
          if (Y.indexOf(",") >= 0) Y = Y.split(",")[0];
          if (Y.indexOf(":") >= 0) Y = Y.split(":")[0];
          if (Y.indexOf("#") >= 0) Y = Y.split("#")[1];
          return Y
        }, "sanitizeErrorCode"),
        Z = B(A.headers, "x-amzn-errortype");
      if (Z !== void 0) return G(A.headers[Z]);
      if (Q.code !== void 0) return G(Q.code);
      if (Q.__type !== void 0) return G(Q.__type)
    }, "loadRestJsonErrorCode"),
    TR8 = lcA(),
    PR8 = wS(),
    CpQ = ez((A, Q) => DpQ(A, Q).then((B) => {
      if (B.length) {
        let G = new PR8.XMLParser({
          attributeNamePrefix: "",
          htmlEntities: !0,
          ignoreAttributes: !1,
          ignoreDeclaration: !0,
          parseTagValue: !1,
          trimValues: !1,
          tagValueProcessor: ez((W, X) => X.trim() === "" && X.includes(`
`) ? "" : void 0, "tagValueProcessor")
        });
        G.addEntity("#xD", "\r"), G.addEntity("#10", `
`);
        let Z;
        try {
          Z = G.parse(B, !0)
        } catch (W) {
          if (W && typeof W === "object") Object.defineProperty(W, "$responseBodyText", {
            value: B
          });
          throw W
        }
        let I = "#text",
          Y = Object.keys(Z)[0],
          J = Z[Y];
        if (J[I]) J[Y] = J[I], delete J[I];
        return (0, TR8.getValueFromTextNode)(J)
      }
      return {}
    }), "parseXmlBody"),
    jR8 = ez(async (A, Q) => {
      let B = await CpQ(A, Q);
      if (B.Error) B.Error.message = B.Error.message ?? B.Error.Message;
      return B
    }, "parseXmlErrorBody"),
    SR8 = ez((A, Q) => {
      if (Q?.Error?.Code !== void 0) return Q.Error.Code;
      if (Q?.Code !== void 0) return Q.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadRestXmlErrorCode")
})
// @from(Start 4300689, End 4300887)
jF = z((tCA) => {
  Object.defineProperty(tCA, "__esModule", {
    value: !0
  });
  var J_1 = ddQ();
  J_1.__exportStar(rS(), tCA);
  J_1.__exportStar(ncQ(), tCA);
  J_1.__exportStar(zpQ(), tCA)
})
// @from(Start 4300893, End 4306548)
F5A = z((zP7, jpQ) => {
  var {
    defineProperty: acA,
    getOwnPropertyDescriptor: _R8,
    getOwnPropertyNames: kR8
  } = Object, yR8 = Object.prototype.hasOwnProperty, Eb = (A, Q) => acA(A, "name", {
    value: Q,
    configurable: !0
  }), xR8 = (A, Q) => {
    for (var B in Q) acA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vR8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of kR8(Q))
        if (!yR8.call(A, Z) && Z !== B) acA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _R8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bR8 = (A) => vR8(acA({}, "__esModule", {
    value: !0
  }), A), qpQ = {};
  xR8(qpQ, {
    DEFAULT_UA_APP_ID: () => NpQ,
    getUserAgentMiddlewareOptions: () => PpQ,
    getUserAgentPlugin: () => pR8,
    resolveUserAgentConfig: () => MpQ,
    userAgentMiddleware: () => TpQ
  });
  jpQ.exports = bR8(qpQ);
  var fR8 = iB(),
    NpQ = void 0;

  function LpQ(A) {
    if (A === void 0) return !0;
    return typeof A === "string" && A.length <= 50
  }
  Eb(LpQ, "isValidUserAgentAppId");

  function MpQ(A) {
    let Q = (0, fR8.normalizeProvider)(A.userAgentAppId ?? NpQ),
      {
        customUserAgent: B
      } = A;
    return Object.assign(A, {
      customUserAgent: typeof B === "string" ? [
        [B]
      ] : B,
      userAgentAppId: Eb(async () => {
        let G = await Q();
        if (!LpQ(G)) {
          let Z = A.logger?.constructor?.name === "NoOpLogger" || !A.logger ? console : A.logger;
          if (typeof G !== "string") Z?.warn("userAgentAppId must be a string or undefined.");
          else if (G.length > 50) Z?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.")
        }
        return G
      }, "userAgentAppId")
    })
  }
  Eb(MpQ, "resolveUserAgentConfig");
  var hR8 = I5A(),
    gR8 = DdQ(),
    eS = jF(),
    uR8 = /\d{12}\.ddb/;
  async function OpQ(A, Q, B) {
    if (B.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor")(0, eS.setFeature)(A, "PROTOCOL_RPC_V2_CBOR", "M");
    if (typeof Q.retryStrategy === "function") {
      let I = await Q.retryStrategy();
      if (typeof I.acquireInitialRetryToken === "function")
        if (I.constructor?.name?.includes("Adaptive"))(0, eS.setFeature)(A, "RETRY_MODE_ADAPTIVE", "F");
        else(0, eS.setFeature)(A, "RETRY_MODE_STANDARD", "E");
      else(0, eS.setFeature)(A, "RETRY_MODE_LEGACY", "D")
    }
    if (typeof Q.accountIdEndpointMode === "function") {
      let I = A.endpointV2;
      if (String(I?.url?.hostname).match(uR8))(0, eS.setFeature)(A, "ACCOUNT_ID_ENDPOINT", "O");
      switch (await Q.accountIdEndpointMode?.()) {
        case "disabled":
          (0, eS.setFeature)(A, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          (0, eS.setFeature)(A, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          (0, eS.setFeature)(A, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break
      }
    }
    let Z = A.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (Z?.$source) {
      let I = Z;
      if (I.accountId)(0, eS.setFeature)(A, "RESOLVED_ACCOUNT_ID", "T");
      for (let [Y, J] of Object.entries(I.$source ?? {}))(0, eS.setFeature)(A, Y, J)
    }
  }
  Eb(OpQ, "checkFeatures");
  var UpQ = "user-agent",
    W_1 = "x-amz-user-agent",
    $pQ = " ",
    X_1 = "/",
    mR8 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
    dR8 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
    wpQ = "-",
    cR8 = 1024;

  function RpQ(A) {
    let Q = "";
    for (let B in A) {
      let G = A[B];
      if (Q.length + G.length + 1 <= cR8) {
        if (Q.length) Q += "," + G;
        else Q += G;
        continue
      }
      break
    }
    return Q
  }
  Eb(RpQ, "encodeFeatures");
  var TpQ = Eb((A) => (Q, B) => async (G) => {
      let {
        request: Z
      } = G;
      if (!gR8.HttpRequest.isInstance(Z)) return Q(G);
      let {
        headers: I
      } = Z, Y = B?.userAgent?.map(ncA) || [], J = (await A.defaultUserAgentProvider()).map(ncA);
      await OpQ(B, A, G);
      let W = B;
      J.push(`m/${RpQ(Object.assign({},B.__smithy_context?.features,W.__aws_sdk_context?.features))}`);
      let X = A?.customUserAgent?.map(ncA) || [],
        V = await A.userAgentAppId();
      if (V) J.push(ncA([`app/${V}`]));
      let F = (0, hR8.getUserAgentPrefix)(),
        K = (F ? [F] : []).concat([...J, ...Y, ...X]).join($pQ),
        D = [...J.filter((H) => H.startsWith("aws-sdk-")), ...X].join($pQ);
      if (A.runtime !== "browser") {
        if (D) I[W_1] = I[W_1] ? `${I[UpQ]} ${D}` : D;
        I[UpQ] = K
      } else I[W_1] = K;
      return Q({
        ...G,
        request: Z
      })
    }, "userAgentMiddleware"),
    ncA = Eb((A) => {
      let Q = A[0].split(X_1).map((Y) => Y.replace(mR8, wpQ)).join(X_1),
        B = A[1]?.replace(dR8, wpQ),
        G = Q.indexOf(X_1),
        Z = Q.substring(0, G),
        I = Q.substring(G + 1);
      if (Z === "api") I = I.toLowerCase();
      return [Z, I, B].filter((Y) => Y && Y.length > 0).reduce((Y, J, W) => {
        switch (W) {
          case 0:
            return J;
          case 1:
            return `${Y}/${J}`;
          default:
            return `${Y}#${J}`
        }
      }, "")
    }, "escapeUserAgent"),
    PpQ = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: !0
    },
    pR8 = Eb((A) => ({
      applyToStack: Eb((Q) => {
        Q.add(TpQ(A), PpQ)
      }, "applyToStack")
    }), "getUserAgentPlugin")
})
// @from(Start 4306554, End 4308242)
F_1 = z((SpQ) => {
  Object.defineProperty(SpQ, "__esModule", {
    value: !0
  });
  SpQ.resolveHttpAuthSchemeConfig = SpQ.defaultSSOHttpAuthSchemeProvider = SpQ.defaultSSOHttpAuthSchemeParametersProvider = void 0;
  var lR8 = jF(),
    V_1 = w7(),
    iR8 = async (A, Q, B) => {
      return {
        operation: (0, V_1.getSmithyContext)(Q).operation,
        region: await (0, V_1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  SpQ.defaultSSOHttpAuthSchemeParametersProvider = iR8;

  function nR8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "awsssoportal",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function scA(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var aR8 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "GetRoleCredentials": {
        Q.push(scA(A));
        break
      }
      case "ListAccountRoles": {
        Q.push(scA(A));
        break
      }
      case "ListAccounts": {
        Q.push(scA(A));
        break
      }
      case "Logout": {
        Q.push(scA(A));
        break
      }
      default:
        Q.push(nR8(A))
    }
    return Q
  };
  SpQ.defaultSSOHttpAuthSchemeProvider = aR8;
  var sR8 = (A) => {
    let Q = (0, lR8.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, V_1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  SpQ.resolveHttpAuthSchemeConfig = sR8
})
// @from(Start 4308248, End 4325504)
YlQ = z(($P7, tcA) => {
  var kpQ, ypQ, xpQ, vpQ, bpQ, fpQ, hpQ, gpQ, upQ, mpQ, dpQ, cpQ, ppQ, rcA, K_1, lpQ, ipQ, npQ, K5A, apQ, spQ, rpQ, opQ, tpQ, epQ, AlQ, QlQ, BlQ, ocA, GlQ, ZlQ, IlQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof tcA === "object" && typeof $P7 === "object") A(B(Q, B($P7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    kpQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, ypQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, xpQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, vpQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, bpQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, fpQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, hpQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, gpQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, upQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, mpQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, dpQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, cpQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, ppQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) ocA(Y, I, J)
    }, ocA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, rcA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, K_1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, lpQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(K_1(arguments[Y]));
      return I
    }, ipQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, npQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, K5A = function(I) {
      return this instanceof K5A ? (this.v = I, this) : new K5A(I)
    }, apQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof K5A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, spQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: K5A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, rpQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof rcA === "function" ? rcA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, opQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    tpQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") ocA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, epQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, AlQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, QlQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, BlQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, GlQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    ZlQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, IlQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", kpQ), A("__assign", ypQ), A("__rest", xpQ), A("__decorate", vpQ), A("__param", bpQ), A("__esDecorate", fpQ), A("__runInitializers", hpQ), A("__propKey", gpQ), A("__setFunctionName", upQ), A("__metadata", mpQ), A("__awaiter", dpQ), A("__generator", cpQ), A("__exportStar", ppQ), A("__createBinding", ocA), A("__values", rcA), A("__read", K_1), A("__spread", lpQ), A("__spreadArrays", ipQ), A("__spreadArray", npQ), A("__await", K5A), A("__asyncGenerator", apQ), A("__asyncDelegator", spQ), A("__asyncValues", rpQ), A("__makeTemplateObject", opQ), A("__importStar", tpQ), A("__importDefault", epQ), A("__classPrivateFieldGet", AlQ), A("__classPrivateFieldSet", QlQ), A("__classPrivateFieldIn", BlQ), A("__addDisposableResource", GlQ), A("__disposeResources", ZlQ), A("__rewriteRelativeImportExtension", IlQ)
  })
})
// @from(Start 4325510, End 4329094)
JlQ = z((wP7, tR8) => {
  tR8.exports = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.797.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.796.0",
      "@aws-sdk/middleware-host-header": "3.775.0",
      "@aws-sdk/middleware-logger": "3.775.0",
      "@aws-sdk/middleware-recursion-detection": "3.775.0",
      "@aws-sdk/middleware-user-agent": "3.796.0",
      "@aws-sdk/region-config-resolver": "3.775.0",
      "@aws-sdk/types": "3.775.0",
      "@aws-sdk/util-endpoints": "3.787.0",
      "@aws-sdk/util-user-agent-browser": "3.775.0",
      "@aws-sdk/util-user-agent-node": "3.796.0",
      "@smithy/config-resolver": "^4.1.0",
      "@smithy/core": "^3.2.0",
      "@smithy/fetch-http-handler": "^5.0.2",
      "@smithy/hash-node": "^4.0.2",
      "@smithy/invalid-dependency": "^4.0.2",
      "@smithy/middleware-content-length": "^4.0.2",
      "@smithy/middleware-endpoint": "^4.1.0",
      "@smithy/middleware-retry": "^4.1.0",
      "@smithy/middleware-serde": "^4.0.3",
      "@smithy/middleware-stack": "^4.0.2",
      "@smithy/node-config-provider": "^4.0.2",
      "@smithy/node-http-handler": "^4.0.4",
      "@smithy/protocol-http": "^5.1.0",
      "@smithy/smithy-client": "^4.2.0",
      "@smithy/types": "^4.2.0",
      "@smithy/url-parser": "^4.0.2",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.8",
      "@smithy/util-defaults-mode-node": "^4.0.8",
      "@smithy/util-endpoints": "^3.0.2",
      "@smithy/util-middleware": "^4.0.2",
      "@smithy/util-retry": "^4.0.2",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  }
})
// @from(Start 4329100, End 4331276)
eCA = z((qP7, HlQ) => {
  var {
    defineProperty: ApA,
    getOwnPropertyDescriptor: eR8,
    getOwnPropertyNames: AT8
  } = Object, QT8 = Object.prototype.hasOwnProperty, ecA = (A, Q) => ApA(A, "name", {
    value: Q,
    configurable: !0
  }), BT8 = (A, Q) => {
    for (var B in Q) ApA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, GT8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of AT8(Q))
        if (!QT8.call(A, Z) && Z !== B) ApA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = eR8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, ZT8 = (A) => GT8(ApA({}, "__esModule", {
    value: !0
  }), A), XlQ = {};
  BT8(XlQ, {
    NODE_APP_ID_CONFIG_OPTIONS: () => XT8,
    UA_APP_ID_ENV_NAME: () => KlQ,
    UA_APP_ID_INI_NAME: () => DlQ,
    createDefaultUserAgentProvider: () => FlQ,
    crtAvailability: () => VlQ,
    defaultUserAgent: () => YT8
  });
  HlQ.exports = ZT8(XlQ);
  var WlQ = UA("os"),
    D_1 = UA("process"),
    VlQ = {
      isCrtAvailable: !1
    },
    IT8 = ecA(() => {
      if (VlQ.isCrtAvailable) return ["md/crt-avail"];
      return null
    }, "isCrtAvailable"),
    FlQ = ecA(({
      serviceId: A,
      clientVersion: Q
    }) => {
      return async (B) => {
        let G = [
            ["aws-sdk-js", Q],
            ["ua", "2.1"],
            [`os/${(0,WlQ.platform)()}`, (0, WlQ.release)()],
            ["lang/js"],
            ["md/nodejs", `${D_1.versions.node}`]
          ],
          Z = IT8();
        if (Z) G.push(Z);
        if (A) G.push([`api/${A}`, Q]);
        if (D_1.env.AWS_EXECUTION_ENV) G.push([`exec-env/${D_1.env.AWS_EXECUTION_ENV}`]);
        let I = await B?.userAgentAppId?.();
        return I ? [...G, [`app/${I}`]] : [...G]
      }
    }, "createDefaultUserAgentProvider"),
    YT8 = FlQ,
    JT8 = F5A(),
    KlQ = "AWS_SDK_UA_APP_ID",
    DlQ = "sdk_ua_app_id",
    WT8 = "sdk-ua-app-id",
    XT8 = {
      environmentVariableSelector: ecA((A) => A[KlQ], "environmentVariableSelector"),
      configFileSelector: ecA((A) => A[DlQ] ?? A[WT8], "configFileSelector"),
      default: JT8.DEFAULT_UA_APP_ID
    }
})
// @from(Start 4331282, End 4334065)
H_1 = z((NP7, LlQ) => {
  var {
    defineProperty: QpA,
    getOwnPropertyDescriptor: VT8,
    getOwnPropertyNames: FT8
  } = Object, KT8 = Object.prototype.hasOwnProperty, BpA = (A, Q) => QpA(A, "name", {
    value: Q,
    configurable: !0
  }), DT8 = (A, Q) => {
    for (var B in Q) QpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, HT8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of FT8(Q))
        if (!KT8.call(A, Z) && Z !== B) QpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = VT8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, CT8 = (A) => HT8(QpA({}, "__esModule", {
    value: !0
  }), A), ClQ = {};
  DT8(ClQ, {
    AlgorithmId: () => $lQ,
    EndpointURLScheme: () => UlQ,
    FieldPosition: () => wlQ,
    HttpApiKeyAuthLocation: () => zlQ,
    HttpAuthLocation: () => ElQ,
    IniSectionType: () => qlQ,
    RequestHandlerProtocol: () => NlQ,
    SMITHY_CONTEXT_KEY: () => wT8,
    getDefaultClientConfiguration: () => UT8,
    resolveDefaultRuntimeConfig: () => $T8
  });
  LlQ.exports = CT8(ClQ);
  var ElQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(ElQ || {}),
    zlQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(zlQ || {}),
    UlQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(UlQ || {}),
    $lQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })($lQ || {}),
    ET8 = BpA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    zT8 = BpA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    UT8 = BpA((A) => {
      return ET8(A)
    }, "getDefaultClientConfiguration"),
    $T8 = BpA((A) => {
      return zT8(A)
    }, "resolveDefaultRuntimeConfig"),
    wlQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(wlQ || {}),
    wT8 = "__smithy_context",
    qlQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(qlQ || {}),
    NlQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(NlQ || {})
})
// @from(Start 4334071, End 4362526)
ZEA = z((LP7, mlQ) => {
  var {
    defineProperty: IpA,
    getOwnPropertyDescriptor: qT8,
    getOwnPropertyNames: NT8
  } = Object, LT8 = Object.prototype.hasOwnProperty, HB = (A, Q) => IpA(A, "name", {
    value: Q,
    configurable: !0
  }), MT8 = (A, Q) => {
    for (var B in Q) IpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, OT8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of NT8(Q))
        if (!LT8.call(A, Z) && Z !== B) IpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qT8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, RT8 = (A) => OT8(IpA({}, "__esModule", {
    value: !0
  }), A), OlQ = {};
  MT8(OlQ, {
    Client: () => TT8,
    Command: () => TlQ,
    LazyJsonString: () => Po,
    NoOpLogger: () => LP8,
    SENSITIVE_STRING: () => jT8,
    ServiceException: () => VP8,
    _json: () => q_1,
    collectBody: () => C_1.collectBody,
    convertMap: () => MP8,
    createAggregatedClient: () => ST8,
    dateToUtcString: () => ylQ,
    decorateServiceException: () => xlQ,
    emitWarningIfUnsupportedVersion: () => HP8,
    expectBoolean: () => kT8,
    expectByte: () => w_1,
    expectFloat32: () => GpA,
    expectInt: () => xT8,
    expectInt32: () => U_1,
    expectLong: () => BEA,
    expectNonNull: () => bT8,
    expectNumber: () => QEA,
    expectObject: () => PlQ,
    expectShort: () => $_1,
    expectString: () => fT8,
    expectUnion: () => hT8,
    extendedEncodeURIComponent: () => C_1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => qP8,
    getDefaultClientConfiguration: () => $P8,
    getDefaultExtensionConfiguration: () => blQ,
    getValueFromTextNode: () => flQ,
    handleFloat: () => mT8,
    isSerializableHeaderValue: () => NP8,
    limitedParseDouble: () => M_1,
    limitedParseFloat: () => dT8,
    limitedParseFloat32: () => cT8,
    loadConfigsForDefaultMode: () => DP8,
    logger: () => GEA,
    map: () => R_1,
    parseBoolean: () => _T8,
    parseEpochTimestamp: () => QP8,
    parseRfc3339DateTime: () => aT8,
    parseRfc3339DateTimeWithOffset: () => rT8,
    parseRfc7231DateTime: () => AP8,
    quoteHeader: () => glQ,
    resolveDefaultRuntimeConfig: () => wP8,
    resolvedPath: () => C_1.resolvedPath,
    serializeDateTime: () => SP8,
    serializeFloat: () => jP8,
    splitEvery: () => ulQ,
    splitHeader: () => _P8,
    strictParseByte: () => klQ,
    strictParseDouble: () => L_1,
    strictParseFloat: () => gT8,
    strictParseFloat32: () => jlQ,
    strictParseInt: () => pT8,
    strictParseInt32: () => lT8,
    strictParseLong: () => _lQ,
    strictParseShort: () => D5A,
    take: () => OP8,
    throwDefaultError: () => vlQ,
    withBaseException: () => FP8
  });
  mlQ.exports = RT8(OlQ);
  var RlQ = uR(),
    TT8 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, RlQ.constructStack)()
      }
      static {
        HB(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    C_1 = w5(),
    z_1 = H_1(),
    TlQ = class {
      constructor() {
        this.middlewareStack = (0, RlQ.constructStack)()
      }
      static {
        HB(this, "Command")
      }
      static classBuilder() {
        return new PT8
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [z_1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    PT8 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        HB(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends TlQ {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this)
          }
          static {
            HB(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    jT8 = "***SensitiveInformation***",
    ST8 = HB((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = HB(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    _T8 = HB((A) => {
      switch (A) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw Error(`Unable to parse boolean value "${A}"`)
      }
    }, "parseBoolean"),
    kT8 = HB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "number") {
        if (A === 0 || A === 1) GEA.warn(ZpA(`Expected boolean, got ${typeof A}: ${A}`));
        if (A === 0) return !1;
        if (A === 1) return !0
      }
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (Q === "false" || Q === "true") GEA.warn(ZpA(`Expected boolean, got ${typeof A}: ${A}`));
        if (Q === "false") return !1;
        if (Q === "true") return !0
      }
      if (typeof A === "boolean") return A;
      throw TypeError(`Expected boolean, got ${typeof A}: ${A}`)
    }, "expectBoolean"),
    QEA = HB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") {
        let Q = parseFloat(A);
        if (!Number.isNaN(Q)) {
          if (String(Q) !== String(A)) GEA.warn(ZpA(`Expected number but observed string: ${A}`));
          return Q
        }
      }
      if (typeof A === "number") return A;
      throw TypeError(`Expected number, got ${typeof A}: ${A}`)
    }, "expectNumber"),
    yT8 = Math.ceil(340282346638528860000000000000000000000),
    GpA = HB((A) => {
      let Q = QEA(A);
      if (Q !== void 0 && !Number.isNaN(Q) && Q !== 1 / 0 && Q !== -1 / 0) {
        if (Math.abs(Q) > yT8) throw TypeError(`Expected 32-bit float, got ${A}`)
      }
      return Q
    }, "expectFloat32"),
    BEA = HB((A) => {
      if (A === null || A === void 0) return;
      if (Number.isInteger(A) && !Number.isNaN(A)) return A;
      throw TypeError(`Expected integer, got ${typeof A}: ${A}`)
    }, "expectLong"),
    xT8 = BEA,
    U_1 = HB((A) => N_1(A, 32), "expectInt32"),
    $_1 = HB((A) => N_1(A, 16), "expectShort"),
    w_1 = HB((A) => N_1(A, 8), "expectByte"),
    N_1 = HB((A, Q) => {
      let B = BEA(A);
      if (B !== void 0 && vT8(B, Q) !== B) throw TypeError(`Expected ${Q}-bit integer, got ${A}`);
      return B
    }, "expectSizedInt"),
    vT8 = HB((A, Q) => {
      switch (Q) {
        case 32:
          return Int32Array.of(A)[0];
        case 16:
          return Int16Array.of(A)[0];
        case 8:
          return Int8Array.of(A)[0]
      }
    }, "castInt"),
    bT8 = HB((A, Q) => {
      if (A === null || A === void 0) {
        if (Q) throw TypeError(`Expected a non-null value for ${Q}`);
        throw TypeError("Expected a non-null value")
      }
      return A
    }, "expectNonNull"),
    PlQ = HB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "object" && !Array.isArray(A)) return A;
      let Q = Array.isArray(A) ? "array" : typeof A;
      throw TypeError(`Expected object, got ${Q}: ${A}`)
    }, "expectObject"),
    fT8 = HB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") return A;
      if (["boolean", "number", "bigint"].includes(typeof A)) return GEA.warn(ZpA(`Expected string, got ${typeof A}: ${A}`)), String(A);
      throw TypeError(`Expected string, got ${typeof A}: ${A}`)
    }, "expectString"),
    hT8 = HB((A) => {
      if (A === null || A === void 0) return;
      let Q = PlQ(A),
        B = Object.entries(Q).filter(([, G]) => G != null).map(([G]) => G);
      if (B.length === 0) throw TypeError("Unions must have exactly one non-null member. None were found.");
      if (B.length > 1) throw TypeError(`Unions must have exactly one non-null member. Keys ${B} were not null.`);
      return Q
    }, "expectUnion"),
    L_1 = HB((A) => {
      if (typeof A == "string") return QEA(C5A(A));
      return QEA(A)
    }, "strictParseDouble"),
    gT8 = L_1,
    jlQ = HB((A) => {
      if (typeof A == "string") return GpA(C5A(A));
      return GpA(A)
    }, "strictParseFloat32"),
    uT8 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    C5A = HB((A) => {
      let Q = A.match(uT8);
      if (Q === null || Q[0].length !== A.length) throw TypeError("Expected real number, got implicit NaN");
      return parseFloat(A)
    }, "parseNumber"),
    M_1 = HB((A) => {
      if (typeof A == "string") return SlQ(A);
      return QEA(A)
    }, "limitedParseDouble"),
    mT8 = M_1,
    dT8 = M_1,
    cT8 = HB((A) => {
      if (typeof A == "string") return SlQ(A);
      return GpA(A)
    }, "limitedParseFloat32"),
    SlQ = HB((A) => {
      switch (A) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw Error(`Unable to parse float value: ${A}`)
      }
    }, "parseFloatString"),
    _lQ = HB((A) => {
      if (typeof A === "string") return BEA(C5A(A));
      return BEA(A)
    }, "strictParseLong"),
    pT8 = _lQ,
    lT8 = HB((A) => {
      if (typeof A === "string") return U_1(C5A(A));
      return U_1(A)
    }, "strictParseInt32"),
    D5A = HB((A) => {
      if (typeof A === "string") return $_1(C5A(A));
      return $_1(A)
    }, "strictParseShort"),
    klQ = HB((A) => {
      if (typeof A === "string") return w_1(C5A(A));
      return w_1(A)
    }, "strictParseByte"),
    ZpA = HB((A) => {
      return String(TypeError(A).stack || A).split(`
`).slice(0, 5).filter((Q) => !Q.includes("stackTraceWarning")).join(`
`)
    }, "stackTraceWarning"),
    GEA = {
      warn: console.warn
    },
    iT8 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    O_1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  function ylQ(A) {
    let Q = A.getUTCFullYear(),
      B = A.getUTCMonth(),
      G = A.getUTCDay(),
      Z = A.getUTCDate(),
      I = A.getUTCHours(),
      Y = A.getUTCMinutes(),
      J = A.getUTCSeconds(),
      W = Z < 10 ? `0${Z}` : `${Z}`,
      X = I < 10 ? `0${I}` : `${I}`,
      V = Y < 10 ? `0${Y}` : `${Y}`,
      F = J < 10 ? `0${J}` : `${J}`;
    return `${iT8[G]}, ${W} ${O_1[B]} ${Q} ${X}:${V}:${F} GMT`
  }
  HB(ylQ, "dateToUtcString");
  var nT8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/),
    aT8 = HB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = nT8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X] = Q, V = D5A(H5A(G)), F = A_(Z, "month", 1, 12), K = A_(I, "day", 1, 31);
      return AEA(V, F, K, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      })
    }, "parseRfc3339DateTime"),
    sT8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/),
    rT8 = HB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = sT8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X, V] = Q, F = D5A(H5A(G)), K = A_(Z, "month", 1, 12), D = A_(I, "day", 1, 31), H = AEA(F, K, D, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      });
      if (V.toUpperCase() != "Z") H.setTime(H.getTime() - XP8(V));
      return H
    }, "parseRfc3339DateTimeWithOffset"),
    oT8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    tT8 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    eT8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/),
    AP8 = HB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-7231 date-times must be expressed as strings");
      let Q = oT8.exec(A);
      if (Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return AEA(D5A(H5A(I)), E_1(Z), A_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        })
      }
      if (Q = tT8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return ZP8(AEA(BP8(I), E_1(Z), A_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        }))
      }
      if (Q = eT8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return AEA(D5A(H5A(X)), E_1(G), A_(Z.trimLeft(), "day", 1, 31), {
          hours: I,
          minutes: Y,
          seconds: J,
          fractionalMilliseconds: W
        })
      }
      throw TypeError("Invalid RFC-7231 date-time value")
    }, "parseRfc7231DateTime"),
    QP8 = HB((A) => {
      if (A === null || A === void 0) return;
      let Q;
      if (typeof A === "number") Q = A;
      else if (typeof A === "string") Q = L_1(A);
      else if (typeof A === "object" && A.tag === 1) Q = A.value;
      else throw TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      if (Number.isNaN(Q) || Q === 1 / 0 || Q === -1 / 0) throw TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      return new Date(Math.round(Q * 1000))
    }, "parseEpochTimestamp"),
    AEA = HB((A, Q, B, G) => {
      let Z = Q - 1;
      return YP8(A, Z, B), new Date(Date.UTC(A, Z, B, A_(G.hours, "hour", 0, 23), A_(G.minutes, "minute", 0, 59), A_(G.seconds, "seconds", 0, 60), WP8(G.fractionalMilliseconds)))
    }, "buildDate"),
    BP8 = HB((A) => {
      let Q = new Date().getUTCFullYear(),
        B = Math.floor(Q / 100) * 100 + D5A(H5A(A));
      if (B < Q) return B + 100;
      return B
    }, "parseTwoDigitYear"),
    GP8 = 1576800000000,
    ZP8 = HB((A) => {
      if (A.getTime() - new Date().getTime() > GP8) return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));
      return A
    }, "adjustRfc850Year"),
    E_1 = HB((A) => {
      let Q = O_1.indexOf(A);
      if (Q < 0) throw TypeError(`Invalid month: ${A}`);
      return Q + 1
    }, "parseMonthByShortName"),
    IP8 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    YP8 = HB((A, Q, B) => {
      let G = IP8[Q];
      if (Q === 1 && JP8(A)) G = 29;
      if (B > G) throw TypeError(`Invalid day for ${O_1[Q]} in ${A}: ${B}`)
    }, "validateDayOfMonth"),
    JP8 = HB((A) => {
      return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0)
    }, "isLeapYear"),
    A_ = HB((A, Q, B, G) => {
      let Z = klQ(H5A(A));
      if (Z < B || Z > G) throw TypeError(`${Q} must be between ${B} and ${G}, inclusive`);
      return Z
    }, "parseDateValue"),
    WP8 = HB((A) => {
      if (A === null || A === void 0) return 0;
      return jlQ("0." + A) * 1000
    }, "parseMilliseconds"),
    XP8 = HB((A) => {
      let Q = A[0],
        B = 1;
      if (Q == "+") B = 1;
      else if (Q == "-") B = -1;
      else throw TypeError(`Offset direction, ${Q}, must be "+" or "-"`);
      let G = Number(A.substring(1, 3)),
        Z = Number(A.substring(4, 6));
      return B * (G * 60 + Z) * 60 * 1000
    }, "parseOffsetToMilliseconds"),
    H5A = HB((A) => {
      let Q = 0;
      while (Q < A.length - 1 && A.charAt(Q) === "0") Q++;
      if (Q === 0) return A;
      return A.slice(Q)
    }, "stripLeadingZeroes"),
    VP8 = class A extends Error {
      static {
        HB(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    xlQ = HB((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    vlQ = HB(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = KP8(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw xlQ(Y, Q)
    }, "throwDefaultError"),
    FP8 = HB((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        vlQ({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    KP8 = HB((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    DP8 = HB((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    MlQ = !1,
    HP8 = HB((A) => {
      if (A && !MlQ && parseInt(A.substring(1, A.indexOf("."))) < 16) MlQ = !0
    }, "emitWarningIfUnsupportedVersion"),
    CP8 = HB((A) => {
      let Q = [];
      for (let B in z_1.AlgorithmId) {
        let G = z_1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    EP8 = HB((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    zP8 = HB((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    UP8 = HB((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    blQ = HB((A) => {
      return Object.assign(CP8(A), zP8(A))
    }, "getDefaultExtensionConfiguration"),
    $P8 = blQ,
    wP8 = HB((A) => {
      return Object.assign(EP8(A), UP8(A))
    }, "resolveDefaultRuntimeConfig"),
    qP8 = HB((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    flQ = HB((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = flQ(A[B]);
      return A
    }, "getValueFromTextNode"),
    NP8 = HB((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    Po = HB(function(Q) {
      return Object.assign(new String(Q), {
        deserializeJSON() {
          return JSON.parse(String(Q))
        },
        toString() {
          return String(Q)
        },
        toJSON() {
          return String(Q)
        }
      })
    }, "LazyJsonString");
  Po.from = (A) => {
    if (A && typeof A === "object" && (A instanceof Po || ("deserializeJSON" in A))) return A;
    else if (typeof A === "string" || Object.getPrototypeOf(A) === String.prototype) return Po(String(A));
    return Po(JSON.stringify(A))
  };
  Po.fromObject = Po.from;
  var LP8 = class {
    static {
      HB(this, "NoOpLogger")
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };

  function R_1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, RP8(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      hlQ(G, null, I, Y)
    }
    return G
  }
  HB(R_1, "map");
  var MP8 = HB((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    OP8 = HB((A, Q) => {
      let B = {};
      for (let G in Q) hlQ(B, A, Q, G);
      return B
    }, "take"),
    RP8 = HB((A, Q, B) => {
      return R_1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    hlQ = HB((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = TP8, W = PP8, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    TP8 = HB((A) => A != null, "nonNullish"),
    PP8 = HB((A) => A, "pass");

  function glQ(A) {
    if (A.includes(",") || A.includes('"')) A = `"${A.replace(/"/g,"\\\"")}"`;
    return A
  }
  HB(glQ, "quoteHeader");
  var jP8 = HB((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    SP8 = HB((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    q_1 = HB((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(q_1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = q_1(A[B])
        }
        return Q
      }
      return A
    }, "_json");

  function ulQ(A, Q, B) {
    if (B <= 0 || !Number.isInteger(B)) throw Error("Invalid number of delimiters (" + B + ") for splitEvery.");
    let G = A.split(Q);
    if (B === 1) return G;
    let Z = [],
      I = "";
    for (let Y = 0; Y < G.length; Y++) {
      if (I === "") I = G[Y];
      else I += Q + G[Y];
      if ((Y + 1) % B === 0) Z.push(I), I = ""
    }
    if (I !== "") Z.push(I);
    return Z
  }
  HB(ulQ, "splitEvery");
  var _P8 = HB((A) => {
    let Q = A.length,
      B = [],
      G = !1,
      Z = void 0,
      I = 0;
    for (let Y = 0; Y < Q; ++Y) {
      let J = A[Y];
      switch (J) {
        case '"':
          if (Z !== "\\") G = !G;
          break;
        case ",":
          if (!G) B.push(A.slice(I, Y)), I = Y + 1;
          break;
        default:
      }
      Z = J
    }
    return B.push(A.slice(I)), B.map((Y) => {
      Y = Y.trim();
      let J = Y.length;
      if (J < 2) return Y;
      if (Y[0] === '"' && Y[J - 1] === '"') Y = Y.slice(1, J - 1);
      return Y.replace(/\\"/g, '"')
    })
  }, "splitHeader")
})
// @from(Start 4362532, End 4363019)
plQ = z((dlQ) => {
  Object.defineProperty(dlQ, "__esModule", {
    value: !0
  });
  dlQ.fromBase64 = void 0;
  var kP8 = hI(),
    yP8 = /^[A-Za-z0-9+/]*={0,2}$/,
    xP8 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!yP8.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, kP8.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  dlQ.fromBase64 = xP8
})
// @from(Start 4363025, End 4363604)
nlQ = z((llQ) => {
  Object.defineProperty(llQ, "__esModule", {
    value: !0
  });
  llQ.toBase64 = void 0;
  var vP8 = hI(),
    bP8 = O2(),
    fP8 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, bP8.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, vP8.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  llQ.toBase64 = fP8
})
// @from(Start 4363610, End 4364306)
rlQ = z((_P7, YpA) => {
  var {
    defineProperty: alQ,
    getOwnPropertyDescriptor: hP8,
    getOwnPropertyNames: gP8
  } = Object, uP8 = Object.prototype.hasOwnProperty, T_1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gP8(Q))
        if (!uP8.call(A, Z) && Z !== B) alQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = hP8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, slQ = (A, Q, B) => (T_1(A, Q, "default"), B && T_1(B, Q, "default")), mP8 = (A) => T_1(alQ({}, "__esModule", {
    value: !0
  }), A), P_1 = {};
  YpA.exports = mP8(P_1);
  slQ(P_1, plQ(), YpA.exports);
  slQ(P_1, nlQ(), YpA.exports)
})
// @from(Start 4364312, End 4369009)
DiQ = z((FiQ) => {
  Object.defineProperty(FiQ, "__esModule", {
    value: !0
  });
  FiQ.ruleSet = void 0;
  var JiQ = "required",
    mL = "fn",
    dL = "argv",
    U5A = "ref",
    olQ = !0,
    tlQ = "isSet",
    IEA = "booleanEquals",
    E5A = "error",
    z5A = "endpoint",
    zb = "tree",
    j_1 = "PartitionResult",
    S_1 = "getAttr",
    elQ = {
      [JiQ]: !1,
      type: "String"
    },
    AiQ = {
      [JiQ]: !0,
      default: !1,
      type: "Boolean"
    },
    QiQ = {
      [U5A]: "Endpoint"
    },
    WiQ = {
      [mL]: IEA,
      [dL]: [{
        [U5A]: "UseFIPS"
      }, !0]
    },
    XiQ = {
      [mL]: IEA,
      [dL]: [{
        [U5A]: "UseDualStack"
      }, !0]
    },
    uL = {},
    BiQ = {
      [mL]: S_1,
      [dL]: [{
        [U5A]: j_1
      }, "supportsFIPS"]
    },
    ViQ = {
      [U5A]: j_1
    },
    GiQ = {
      [mL]: IEA,
      [dL]: [!0, {
        [mL]: S_1,
        [dL]: [ViQ, "supportsDualStack"]
      }]
    },
    ZiQ = [WiQ],
    IiQ = [XiQ],
    YiQ = [{
      [U5A]: "Region"
    }],
    dP8 = {
      version: "1.0",
      parameters: {
        Region: elQ,
        UseDualStack: AiQ,
        UseFIPS: AiQ,
        Endpoint: elQ
      },
      rules: [{
        conditions: [{
          [mL]: tlQ,
          [dL]: [QiQ]
        }],
        rules: [{
          conditions: ZiQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: E5A
        }, {
          conditions: IiQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: E5A
        }, {
          endpoint: {
            url: QiQ,
            properties: uL,
            headers: uL
          },
          type: z5A
        }],
        type: zb
      }, {
        conditions: [{
          [mL]: tlQ,
          [dL]: YiQ
        }],
        rules: [{
          conditions: [{
            [mL]: "aws.partition",
            [dL]: YiQ,
            assign: j_1
          }],
          rules: [{
            conditions: [WiQ, XiQ],
            rules: [{
              conditions: [{
                [mL]: IEA,
                [dL]: [olQ, BiQ]
              }, GiQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: uL,
                  headers: uL
                },
                type: z5A
              }],
              type: zb
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: E5A
            }],
            type: zb
          }, {
            conditions: ZiQ,
            rules: [{
              conditions: [{
                [mL]: IEA,
                [dL]: [BiQ, olQ]
              }],
              rules: [{
                conditions: [{
                  [mL]: "stringEquals",
                  [dL]: [{
                    [mL]: S_1,
                    [dL]: [ViQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://portal.sso.{Region}.amazonaws.com",
                  properties: uL,
                  headers: uL
                },
                type: z5A
              }, {
                endpoint: {
                  url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: uL,
                  headers: uL
                },
                type: z5A
              }],
              type: zb
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: E5A
            }],
            type: zb
          }, {
            conditions: IiQ,
            rules: [{
              conditions: [GiQ],
              rules: [{
                endpoint: {
                  url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: uL,
                  headers: uL
                },
                type: z5A
              }],
              type: zb
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: E5A
            }],
            type: zb
          }, {
            endpoint: {
              url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
              properties: uL,
              headers: uL
            },
            type: z5A
          }],
          type: zb
        }],
        type: zb
      }, {
        error: "Invalid Configuration: Missing Region",
        type: E5A
      }]
    };
  FiQ.ruleSet = dP8
})
// @from(Start 4369015, End 4369579)
EiQ = z((HiQ) => {
  Object.defineProperty(HiQ, "__esModule", {
    value: !0
  });
  HiQ.defaultEndpointResolver = void 0;
  var cP8 = I5A(),
    __1 = FI(),
    pP8 = DiQ(),
    lP8 = new __1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    iP8 = (A, Q = {}) => {
      return lP8.get(A, () => (0, __1.resolveEndpoint)(pP8.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  HiQ.defaultEndpointResolver = iP8;
  __1.customEndpointFunctions.aws = cP8.awsEndpointFunctions
})
// @from(Start 4369585, End 4370996)
qiQ = z(($iQ) => {
  Object.defineProperty($iQ, "__esModule", {
    value: !0
  });
  $iQ.getRuntimeConfig = void 0;
  var nP8 = jF(),
    aP8 = iB(),
    sP8 = ZEA(),
    rP8 = NJ(),
    ziQ = rlQ(),
    UiQ = O2(),
    oP8 = F_1(),
    tP8 = EiQ(),
    eP8 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? ziQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? ziQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? tP8.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? oP8.defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new nP8.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new aP8.NoAuthSigner
        }],
        logger: A?.logger ?? new sP8.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO",
        urlParser: A?.urlParser ?? rP8.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? UiQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? UiQ.toUtf8
      }
    };
  $iQ.getRuntimeConfig = eP8
})
// @from(Start 4371002, End 4373164)
TiQ = z((OiQ) => {
  Object.defineProperty(OiQ, "__esModule", {
    value: !0
  });
  OiQ.getRuntimeConfig = void 0;
  var Aj8 = YlQ(),
    Qj8 = Aj8.__importDefault(JlQ()),
    Bj8 = jF(),
    NiQ = eCA(),
    JpA = f8(),
    Gj8 = RX(),
    LiQ = D6(),
    $5A = uI(),
    MiQ = IZ(),
    Zj8 = TX(),
    Ij8 = KW(),
    Yj8 = qiQ(),
    Jj8 = ZEA(),
    Wj8 = PX(),
    Xj8 = ZEA(),
    Vj8 = (A) => {
      (0, Xj8.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, Wj8.resolveDefaultsModeConfig)(A),
        B = () => Q().then(Jj8.loadConfigsForDefaultMode),
        G = (0, Yj8.getRuntimeConfig)(A);
      (0, Bj8.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        bodyLengthChecker: A?.bodyLengthChecker ?? Zj8.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, NiQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: Qj8.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, $5A.loadConfig)(LiQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, $5A.loadConfig)(JpA.NODE_REGION_CONFIG_OPTIONS, {
          ...JpA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: MiQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, $5A.loadConfig)({
          ...LiQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || Ij8.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? Gj8.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? MiQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, $5A.loadConfig)(JpA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, $5A.loadConfig)(JpA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, $5A.loadConfig)(NiQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  OiQ.getRuntimeConfig = Vj8
})
// @from(Start 4373170, End 4375773)
YEA = z((bP7, yiQ) => {
  var {
    defineProperty: WpA,
    getOwnPropertyDescriptor: Fj8,
    getOwnPropertyNames: Kj8
  } = Object, Dj8 = Object.prototype.hasOwnProperty, Q_ = (A, Q) => WpA(A, "name", {
    value: Q,
    configurable: !0
  }), Hj8 = (A, Q) => {
    for (var B in Q) WpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Cj8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Kj8(Q))
        if (!Dj8.call(A, Z) && Z !== B) WpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Fj8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Ej8 = (A) => Cj8(WpA({}, "__esModule", {
    value: !0
  }), A), jiQ = {};
  Hj8(jiQ, {
    NODE_REGION_CONFIG_FILE_OPTIONS: () => wj8,
    NODE_REGION_CONFIG_OPTIONS: () => $j8,
    REGION_ENV_NAME: () => SiQ,
    REGION_INI_NAME: () => _iQ,
    getAwsRegionExtensionConfiguration: () => zj8,
    resolveAwsRegionExtensionConfiguration: () => Uj8,
    resolveRegionConfig: () => qj8
  });
  yiQ.exports = Ej8(jiQ);
  var zj8 = Q_((A) => {
      return {
        setRegion(Q) {
          A.region = Q
        },
        region() {
          return A.region
        }
      }
    }, "getAwsRegionExtensionConfiguration"),
    Uj8 = Q_((A) => {
      return {
        region: A.region()
      }
    }, "resolveAwsRegionExtensionConfiguration"),
    SiQ = "AWS_REGION",
    _iQ = "region",
    $j8 = {
      environmentVariableSelector: Q_((A) => A[SiQ], "environmentVariableSelector"),
      configFileSelector: Q_((A) => A[_iQ], "configFileSelector"),
      default: Q_(() => {
        throw Error("Region is missing")
      }, "default")
    },
    wj8 = {
      preferredFile: "credentials"
    },
    kiQ = Q_((A) => typeof A === "string" && (A.startsWith("fips-") || A.endsWith("-fips")), "isFipsRegion"),
    PiQ = Q_((A) => kiQ(A) ? ["fips-aws-global", "aws-fips"].includes(A) ? "us-east-1" : A.replace(/fips-(dkr-|prod-)?|-fips/, "") : A, "getRealRegion"),
    qj8 = Q_((A) => {
      let {
        region: Q,
        useFipsEndpoint: B
      } = A;
      if (!Q) throw Error("Region is missing");
      return Object.assign(A, {
        region: Q_(async () => {
          if (typeof Q === "string") return PiQ(Q);
          let G = await Q();
          return PiQ(G)
        }, "region"),
        useFipsEndpoint: Q_(async () => {
          let G = typeof Q === "string" ? Q : await Q();
          if (kiQ(G)) return !0;
          return typeof B !== "function" ? Promise.resolve(!!B) : B()
        }, "useFipsEndpoint")
      })
    }, "resolveRegionConfig")
})
// @from(Start 4375779, End 4380286)
giQ = z((fP7, hiQ) => {
  var {
    defineProperty: XpA,
    getOwnPropertyDescriptor: Nj8,
    getOwnPropertyNames: Lj8
  } = Object, Mj8 = Object.prototype.hasOwnProperty, Zc = (A, Q) => XpA(A, "name", {
    value: Q,
    configurable: !0
  }), Oj8 = (A, Q) => {
    for (var B in Q) XpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Rj8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Lj8(Q))
        if (!Mj8.call(A, Z) && Z !== B) XpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Nj8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Tj8 = (A) => Rj8(XpA({}, "__esModule", {
    value: !0
  }), A), xiQ = {};
  Oj8(xiQ, {
    Field: () => Sj8,
    Fields: () => _j8,
    HttpRequest: () => kj8,
    HttpResponse: () => yj8,
    IHttpRequest: () => viQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => Pj8,
    isValidHostname: () => fiQ,
    resolveHttpHandlerRuntimeConfig: () => jj8
  });
  hiQ.exports = Tj8(xiQ);
  var Pj8 = Zc((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    jj8 = Zc((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    viQ = H_1(),
    Sj8 = class {
      static {
        Zc(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = viQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    _j8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Zc(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    kj8 = class A {
      static {
        Zc(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = biQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function biQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Zc(biQ, "cloneQuery");
  var yj8 = class {
    static {
      Zc(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function fiQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Zc(fiQ, "isValidHostname")
})
// @from(Start 4380292, End 4396842)
DnQ = z((mP7, KnQ) => {
  var {
    defineProperty: VpA,
    getOwnPropertyDescriptor: xj8,
    getOwnPropertyNames: vj8
  } = Object, bj8 = Object.prototype.hasOwnProperty, R5 = (A, Q) => VpA(A, "name", {
    value: Q,
    configurable: !0
  }), fj8 = (A, Q) => {
    for (var B in Q) VpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, hj8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of vj8(Q))
        if (!bj8.call(A, Z) && Z !== B) VpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = xj8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, gj8 = (A) => hj8(VpA({}, "__esModule", {
    value: !0
  }), A), iiQ = {};
  fj8(iiQ, {
    GetRoleCredentialsCommand: () => XnQ,
    GetRoleCredentialsRequestFilterSensitiveLog: () => oiQ,
    GetRoleCredentialsResponseFilterSensitiveLog: () => eiQ,
    InvalidRequestException: () => niQ,
    ListAccountRolesCommand: () => k_1,
    ListAccountRolesRequestFilterSensitiveLog: () => AnQ,
    ListAccountsCommand: () => y_1,
    ListAccountsRequestFilterSensitiveLog: () => QnQ,
    LogoutCommand: () => VnQ,
    LogoutRequestFilterSensitiveLog: () => BnQ,
    ResourceNotFoundException: () => aiQ,
    RoleCredentialsFilterSensitiveLog: () => tiQ,
    SSO: () => FnQ,
    SSOClient: () => KpA,
    SSOServiceException: () => w5A,
    TooManyRequestsException: () => siQ,
    UnauthorizedException: () => riQ,
    __Client: () => E2.Client,
    paginateListAccountRoles: () => FS8,
    paginateListAccounts: () => KS8
  });
  KnQ.exports = gj8(iiQ);
  var uiQ = cCA(),
    uj8 = pCA(),
    mj8 = lCA(),
    miQ = F5A(),
    dj8 = f8(),
    Ub = iB(),
    cj8 = LX(),
    WEA = q5(),
    diQ = D6(),
    ciQ = F_1(),
    pj8 = R5((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal"
      })
    }, "resolveClientEndpointParameters"),
    FpA = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    lj8 = TiQ(),
    piQ = YEA(),
    liQ = giQ(),
    E2 = ZEA(),
    ij8 = R5((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    nj8 = R5((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    aj8 = R5((A, Q) => {
      let B = Object.assign((0, piQ.getAwsRegionExtensionConfiguration)(A), (0, E2.getDefaultExtensionConfiguration)(A), (0, liQ.getHttpHandlerExtensionConfiguration)(A), ij8(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, piQ.resolveAwsRegionExtensionConfiguration)(B), (0, E2.resolveDefaultRuntimeConfig)(B), (0, liQ.resolveHttpHandlerRuntimeConfig)(B), nj8(B))
    }, "resolveRuntimeExtensions"),
    KpA = class extends E2.Client {
      static {
        R5(this, "SSOClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, lj8.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = pj8(Q),
          G = (0, miQ.resolveUserAgentConfig)(B),
          Z = (0, diQ.resolveRetryConfig)(G),
          I = (0, dj8.resolveRegionConfig)(Z),
          Y = (0, uiQ.resolveHostHeaderConfig)(I),
          J = (0, WEA.resolveEndpointConfig)(Y),
          W = (0, ciQ.resolveHttpAuthSchemeConfig)(J),
          X = aj8(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, miQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, diQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, cj8.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, uiQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, uj8.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, mj8.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, Ub.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: ciQ.defaultSSOHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: R5(async (V) => new Ub.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, Ub.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    DpA = GZ(),
    w5A = class A extends E2.ServiceException {
      static {
        R5(this, "SSOServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    niQ = class A extends w5A {
      static {
        R5(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    aiQ = class A extends w5A {
      static {
        R5(this, "ResourceNotFoundException")
      }
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    siQ = class A extends w5A {
      static {
        R5(this, "TooManyRequestsException")
      }
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    riQ = class A extends w5A {
      static {
        R5(this, "UnauthorizedException")
      }
      name = "UnauthorizedException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    oiQ = R5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: E2.SENSITIVE_STRING
      }
    }), "GetRoleCredentialsRequestFilterSensitiveLog"),
    tiQ = R5((A) => ({
      ...A,
      ...A.secretAccessKey && {
        secretAccessKey: E2.SENSITIVE_STRING
      },
      ...A.sessionToken && {
        sessionToken: E2.SENSITIVE_STRING
      }
    }), "RoleCredentialsFilterSensitiveLog"),
    eiQ = R5((A) => ({
      ...A,
      ...A.roleCredentials && {
        roleCredentials: tiQ(A.roleCredentials)
      }
    }), "GetRoleCredentialsResponseFilterSensitiveLog"),
    AnQ = R5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: E2.SENSITIVE_STRING
      }
    }), "ListAccountRolesRequestFilterSensitiveLog"),
    QnQ = R5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: E2.SENSITIVE_STRING
      }
    }), "ListAccountsRequestFilterSensitiveLog"),
    BnQ = R5((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: E2.SENSITIVE_STRING
      }
    }), "LogoutRequestFilterSensitiveLog"),
    JEA = jF(),
    sj8 = R5(async (A, Q) => {
      let B = (0, Ub.requestBuilder)(A, Q),
        G = (0, E2.map)({}, E2.isSerializableHeaderValue, {
          [EpA]: A[CpA]
        });
      B.bp("/federation/credentials");
      let Z = (0, E2.map)({
          [XS8]: [, (0, E2.expectNonNull)(A[WS8], "roleName")],
          [ZnQ]: [, (0, E2.expectNonNull)(A[GnQ], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_GetRoleCredentialsCommand"),
    rj8 = R5(async (A, Q) => {
      let B = (0, Ub.requestBuilder)(A, Q),
        G = (0, E2.map)({}, E2.isSerializableHeaderValue, {
          [EpA]: A[CpA]
        });
      B.bp("/assignment/roles");
      let Z = (0, E2.map)({
          [WnQ]: [, A[JnQ]],
          [YnQ]: [() => A.maxResults !== void 0, () => A[InQ].toString()],
          [ZnQ]: [, (0, E2.expectNonNull)(A[GnQ], "accountId")]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountRolesCommand"),
    oj8 = R5(async (A, Q) => {
      let B = (0, Ub.requestBuilder)(A, Q),
        G = (0, E2.map)({}, E2.isSerializableHeaderValue, {
          [EpA]: A[CpA]
        });
      B.bp("/assignment/accounts");
      let Z = (0, E2.map)({
          [WnQ]: [, A[JnQ]],
          [YnQ]: [() => A.maxResults !== void 0, () => A[InQ].toString()]
        }),
        I;
      return B.m("GET").h(G).q(Z).b(I), B.build()
    }, "se_ListAccountsCommand"),
    tj8 = R5(async (A, Q) => {
      let B = (0, Ub.requestBuilder)(A, Q),
        G = (0, E2.map)({}, E2.isSerializableHeaderValue, {
          [EpA]: A[CpA]
        });
      B.bp("/logout");
      let Z;
      return B.m("POST").h(G).b(Z), B.build()
    }, "se_LogoutCommand"),
    ej8 = R5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return HpA(A, Q);
      let B = (0, E2.map)({
          $metadata: Ic(A)
        }),
        G = (0, E2.expectNonNull)((0, E2.expectObject)(await (0, JEA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, E2.take)(G, {
          roleCredentials: E2._json
        });
      return Object.assign(B, Z), B
    }, "de_GetRoleCredentialsCommand"),
    AS8 = R5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return HpA(A, Q);
      let B = (0, E2.map)({
          $metadata: Ic(A)
        }),
        G = (0, E2.expectNonNull)((0, E2.expectObject)(await (0, JEA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, E2.take)(G, {
          nextToken: E2.expectString,
          roleList: E2._json
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountRolesCommand"),
    QS8 = R5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return HpA(A, Q);
      let B = (0, E2.map)({
          $metadata: Ic(A)
        }),
        G = (0, E2.expectNonNull)((0, E2.expectObject)(await (0, JEA.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, E2.take)(G, {
          accountList: E2._json,
          nextToken: E2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_ListAccountsCommand"),
    BS8 = R5(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return HpA(A, Q);
      let B = (0, E2.map)({
        $metadata: Ic(A)
      });
      return await (0, E2.collectBody)(A.body, Q), B
    }, "de_LogoutCommand"),
    HpA = R5(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, JEA.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, JEA.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
          throw await ZS8(B, Q);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
          throw await IS8(B, Q);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
          throw await YS8(B, Q);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
          throw await JS8(B, Q);
        default:
          let Z = B.body;
          return GS8({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    GS8 = (0, E2.withBaseException)(w5A),
    ZS8 = R5(async (A, Q) => {
      let B = (0, E2.map)({}),
        G = A.body,
        Z = (0, E2.take)(G, {
          message: E2.expectString
        });
      Object.assign(B, Z);
      let I = new niQ({
        $metadata: Ic(A),
        ...B
      });
      return (0, E2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    IS8 = R5(async (A, Q) => {
      let B = (0, E2.map)({}),
        G = A.body,
        Z = (0, E2.take)(G, {
          message: E2.expectString
        });
      Object.assign(B, Z);
      let I = new aiQ({
        $metadata: Ic(A),
        ...B
      });
      return (0, E2.decorateServiceException)(I, A.body)
    }, "de_ResourceNotFoundExceptionRes"),
    YS8 = R5(async (A, Q) => {
      let B = (0, E2.map)({}),
        G = A.body,
        Z = (0, E2.take)(G, {
          message: E2.expectString
        });
      Object.assign(B, Z);
      let I = new siQ({
        $metadata: Ic(A),
        ...B
      });
      return (0, E2.decorateServiceException)(I, A.body)
    }, "de_TooManyRequestsExceptionRes"),
    JS8 = R5(async (A, Q) => {
      let B = (0, E2.map)({}),
        G = A.body,
        Z = (0, E2.take)(G, {
          message: E2.expectString
        });
      Object.assign(B, Z);
      let I = new riQ({
        $metadata: Ic(A),
        ...B
      });
      return (0, E2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedExceptionRes"),
    Ic = R5((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    GnQ = "accountId",
    CpA = "accessToken",
    ZnQ = "account_id",
    InQ = "maxResults",
    YnQ = "max_result",
    JnQ = "nextToken",
    WnQ = "next_token",
    WS8 = "roleName",
    XS8 = "role_name",
    EpA = "x-amz-sso_bearer_token",
    XnQ = class extends E2.Command.classBuilder().ep(FpA).m(function(A, Q, B, G) {
      return [(0, DpA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, WEA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(oiQ, eiQ).ser(sj8).de(ej8).build() {
      static {
        R5(this, "GetRoleCredentialsCommand")
      }
    },
    k_1 = class extends E2.Command.classBuilder().ep(FpA).m(function(A, Q, B, G) {
      return [(0, DpA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, WEA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(AnQ, void 0).ser(rj8).de(AS8).build() {
      static {
        R5(this, "ListAccountRolesCommand")
      }
    },
    y_1 = class extends E2.Command.classBuilder().ep(FpA).m(function(A, Q, B, G) {
      return [(0, DpA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, WEA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(QnQ, void 0).ser(oj8).de(QS8).build() {
      static {
        R5(this, "ListAccountsCommand")
      }
    },
    VnQ = class extends E2.Command.classBuilder().ep(FpA).m(function(A, Q, B, G) {
      return [(0, DpA.getSerdePlugin)(B, this.serialize, this.deserialize), (0, WEA.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(BnQ, void 0).ser(tj8).de(BS8).build() {
      static {
        R5(this, "LogoutCommand")
      }
    },
    VS8 = {
      GetRoleCredentialsCommand: XnQ,
      ListAccountRolesCommand: k_1,
      ListAccountsCommand: y_1,
      LogoutCommand: VnQ
    },
    FnQ = class extends KpA {
      static {
        R5(this, "SSO")
      }
    };
  (0, E2.createAggregatedClient)(VS8, FnQ);
  var FS8 = (0, Ub.createPaginator)(KpA, k_1, "nextToken", "nextToken", "maxResults"),
    KS8 = (0, Ub.createPaginator)(KpA, y_1, "nextToken", "nextToken", "maxResults")
})
// @from(Start 4396848, End 4399631)
x_1 = z((aP7, NnQ) => {
  var {
    defineProperty: zpA,
    getOwnPropertyDescriptor: DS8,
    getOwnPropertyNames: HS8
  } = Object, CS8 = Object.prototype.hasOwnProperty, UpA = (A, Q) => zpA(A, "name", {
    value: Q,
    configurable: !0
  }), ES8 = (A, Q) => {
    for (var B in Q) zpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, zS8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of HS8(Q))
        if (!CS8.call(A, Z) && Z !== B) zpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = DS8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, US8 = (A) => zS8(zpA({}, "__esModule", {
    value: !0
  }), A), HnQ = {};
  ES8(HnQ, {
    AlgorithmId: () => UnQ,
    EndpointURLScheme: () => znQ,
    FieldPosition: () => $nQ,
    HttpApiKeyAuthLocation: () => EnQ,
    HttpAuthLocation: () => CnQ,
    IniSectionType: () => wnQ,
    RequestHandlerProtocol: () => qnQ,
    SMITHY_CONTEXT_KEY: () => LS8,
    getDefaultClientConfiguration: () => qS8,
    resolveDefaultRuntimeConfig: () => NS8
  });
  NnQ.exports = US8(HnQ);
  var CnQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(CnQ || {}),
    EnQ = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(EnQ || {}),
    znQ = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(znQ || {}),
    UnQ = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(UnQ || {}),
    $S8 = UpA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    wS8 = UpA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    qS8 = UpA((A) => {
      return $S8(A)
    }, "getDefaultClientConfiguration"),
    NS8 = UpA((A) => {
      return wS8(A)
    }, "resolveDefaultRuntimeConfig"),
    $nQ = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })($nQ || {}),
    LS8 = "__smithy_context",
    wnQ = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(wnQ || {}),
    qnQ = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(qnQ || {})
})
// @from(Start 4399637, End 4428091)
LJ = z((sP7, unQ) => {
  var {
    defineProperty: qpA,
    getOwnPropertyDescriptor: MS8,
    getOwnPropertyNames: OS8
  } = Object, RS8 = Object.prototype.hasOwnProperty, CB = (A, Q) => qpA(A, "name", {
    value: Q,
    configurable: !0
  }), TS8 = (A, Q) => {
    for (var B in Q) qpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, PS8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of OS8(Q))
        if (!RS8.call(A, Z) && Z !== B) qpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = MS8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, jS8 = (A) => PS8(qpA({}, "__esModule", {
    value: !0
  }), A), MnQ = {};
  TS8(MnQ, {
    Client: () => SS8,
    Command: () => RnQ,
    LazyJsonString: () => jo,
    NoOpLogger: () => R_8,
    SENSITIVE_STRING: () => kS8,
    ServiceException: () => D_8,
    _json: () => m_1,
    collectBody: () => v_1.collectBody,
    convertMap: () => T_8,
    createAggregatedClient: () => yS8,
    dateToUtcString: () => knQ,
    decorateServiceException: () => ynQ,
    emitWarningIfUnsupportedVersion: () => z_8,
    expectBoolean: () => vS8,
    expectByte: () => u_1,
    expectFloat32: () => $pA,
    expectInt: () => fS8,
    expectInt32: () => h_1,
    expectLong: () => FEA,
    expectNonNull: () => gS8,
    expectNumber: () => VEA,
    expectObject: () => TnQ,
    expectShort: () => g_1,
    expectString: () => uS8,
    expectUnion: () => mS8,
    extendedEncodeURIComponent: () => v_1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => M_8,
    getDefaultClientConfiguration: () => N_8,
    getDefaultExtensionConfiguration: () => vnQ,
    getValueFromTextNode: () => bnQ,
    handleFloat: () => pS8,
    isSerializableHeaderValue: () => O_8,
    limitedParseDouble: () => p_1,
    limitedParseFloat: () => lS8,
    limitedParseFloat32: () => iS8,
    loadConfigsForDefaultMode: () => E_8,
    logger: () => KEA,
    map: () => i_1,
    parseBoolean: () => xS8,
    parseEpochTimestamp: () => Z_8,
    parseRfc3339DateTime: () => oS8,
    parseRfc3339DateTimeWithOffset: () => eS8,
    parseRfc7231DateTime: () => G_8,
    quoteHeader: () => hnQ,
    resolveDefaultRuntimeConfig: () => L_8,
    resolvedPath: () => v_1.resolvedPath,
    serializeDateTime: () => y_8,
    serializeFloat: () => k_8,
    splitEvery: () => gnQ,
    splitHeader: () => x_8,
    strictParseByte: () => _nQ,
    strictParseDouble: () => c_1,
    strictParseFloat: () => dS8,
    strictParseFloat32: () => PnQ,
    strictParseInt: () => nS8,
    strictParseInt32: () => aS8,
    strictParseLong: () => SnQ,
    strictParseShort: () => q5A,
    take: () => P_8,
    throwDefaultError: () => xnQ,
    withBaseException: () => H_8
  });
  unQ.exports = jS8(MnQ);
  var OnQ = uR(),
    SS8 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, OnQ.constructStack)()
      }
      static {
        CB(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    v_1 = w5(),
    f_1 = x_1(),
    RnQ = class {
      constructor() {
        this.middlewareStack = (0, OnQ.constructStack)()
      }
      static {
        CB(this, "Command")
      }
      static classBuilder() {
        return new _S8
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [f_1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    _S8 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        CB(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends RnQ {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this)
          }
          static {
            CB(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    kS8 = "***SensitiveInformation***",
    yS8 = CB((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = CB(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    xS8 = CB((A) => {
      switch (A) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw Error(`Unable to parse boolean value "${A}"`)
      }
    }, "parseBoolean"),
    vS8 = CB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "number") {
        if (A === 0 || A === 1) KEA.warn(wpA(`Expected boolean, got ${typeof A}: ${A}`));
        if (A === 0) return !1;
        if (A === 1) return !0
      }
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (Q === "false" || Q === "true") KEA.warn(wpA(`Expected boolean, got ${typeof A}: ${A}`));
        if (Q === "false") return !1;
        if (Q === "true") return !0
      }
      if (typeof A === "boolean") return A;
      throw TypeError(`Expected boolean, got ${typeof A}: ${A}`)
    }, "expectBoolean"),
    VEA = CB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") {
        let Q = parseFloat(A);
        if (!Number.isNaN(Q)) {
          if (String(Q) !== String(A)) KEA.warn(wpA(`Expected number but observed string: ${A}`));
          return Q
        }
      }
      if (typeof A === "number") return A;
      throw TypeError(`Expected number, got ${typeof A}: ${A}`)
    }, "expectNumber"),
    bS8 = Math.ceil(340282346638528860000000000000000000000),
    $pA = CB((A) => {
      let Q = VEA(A);
      if (Q !== void 0 && !Number.isNaN(Q) && Q !== 1 / 0 && Q !== -1 / 0) {
        if (Math.abs(Q) > bS8) throw TypeError(`Expected 32-bit float, got ${A}`)
      }
      return Q
    }, "expectFloat32"),
    FEA = CB((A) => {
      if (A === null || A === void 0) return;
      if (Number.isInteger(A) && !Number.isNaN(A)) return A;
      throw TypeError(`Expected integer, got ${typeof A}: ${A}`)
    }, "expectLong"),
    fS8 = FEA,
    h_1 = CB((A) => d_1(A, 32), "expectInt32"),
    g_1 = CB((A) => d_1(A, 16), "expectShort"),
    u_1 = CB((A) => d_1(A, 8), "expectByte"),
    d_1 = CB((A, Q) => {
      let B = FEA(A);
      if (B !== void 0 && hS8(B, Q) !== B) throw TypeError(`Expected ${Q}-bit integer, got ${A}`);
      return B
    }, "expectSizedInt"),
    hS8 = CB((A, Q) => {
      switch (Q) {
        case 32:
          return Int32Array.of(A)[0];
        case 16:
          return Int16Array.of(A)[0];
        case 8:
          return Int8Array.of(A)[0]
      }
    }, "castInt"),
    gS8 = CB((A, Q) => {
      if (A === null || A === void 0) {
        if (Q) throw TypeError(`Expected a non-null value for ${Q}`);
        throw TypeError("Expected a non-null value")
      }
      return A
    }, "expectNonNull"),
    TnQ = CB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "object" && !Array.isArray(A)) return A;
      let Q = Array.isArray(A) ? "array" : typeof A;
      throw TypeError(`Expected object, got ${Q}: ${A}`)
    }, "expectObject"),
    uS8 = CB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") return A;
      if (["boolean", "number", "bigint"].includes(typeof A)) return KEA.warn(wpA(`Expected string, got ${typeof A}: ${A}`)), String(A);
      throw TypeError(`Expected string, got ${typeof A}: ${A}`)
    }, "expectString"),
    mS8 = CB((A) => {
      if (A === null || A === void 0) return;
      let Q = TnQ(A),
        B = Object.entries(Q).filter(([, G]) => G != null).map(([G]) => G);
      if (B.length === 0) throw TypeError("Unions must have exactly one non-null member. None were found.");
      if (B.length > 1) throw TypeError(`Unions must have exactly one non-null member. Keys ${B} were not null.`);
      return Q
    }, "expectUnion"),
    c_1 = CB((A) => {
      if (typeof A == "string") return VEA(L5A(A));
      return VEA(A)
    }, "strictParseDouble"),
    dS8 = c_1,
    PnQ = CB((A) => {
      if (typeof A == "string") return $pA(L5A(A));
      return $pA(A)
    }, "strictParseFloat32"),
    cS8 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    L5A = CB((A) => {
      let Q = A.match(cS8);
      if (Q === null || Q[0].length !== A.length) throw TypeError("Expected real number, got implicit NaN");
      return parseFloat(A)
    }, "parseNumber"),
    p_1 = CB((A) => {
      if (typeof A == "string") return jnQ(A);
      return VEA(A)
    }, "limitedParseDouble"),
    pS8 = p_1,
    lS8 = p_1,
    iS8 = CB((A) => {
      if (typeof A == "string") return jnQ(A);
      return $pA(A)
    }, "limitedParseFloat32"),
    jnQ = CB((A) => {
      switch (A) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw Error(`Unable to parse float value: ${A}`)
      }
    }, "parseFloatString"),
    SnQ = CB((A) => {
      if (typeof A === "string") return FEA(L5A(A));
      return FEA(A)
    }, "strictParseLong"),
    nS8 = SnQ,
    aS8 = CB((A) => {
      if (typeof A === "string") return h_1(L5A(A));
      return h_1(A)
    }, "strictParseInt32"),
    q5A = CB((A) => {
      if (typeof A === "string") return g_1(L5A(A));
      return g_1(A)
    }, "strictParseShort"),
    _nQ = CB((A) => {
      if (typeof A === "string") return u_1(L5A(A));
      return u_1(A)
    }, "strictParseByte"),
    wpA = CB((A) => {
      return String(TypeError(A).stack || A).split(`
`).slice(0, 5).filter((Q) => !Q.includes("stackTraceWarning")).join(`
`)
    }, "stackTraceWarning"),
    KEA = {
      warn: console.warn
    },
    sS8 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    l_1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  function knQ(A) {
    let Q = A.getUTCFullYear(),
      B = A.getUTCMonth(),
      G = A.getUTCDay(),
      Z = A.getUTCDate(),
      I = A.getUTCHours(),
      Y = A.getUTCMinutes(),
      J = A.getUTCSeconds(),
      W = Z < 10 ? `0${Z}` : `${Z}`,
      X = I < 10 ? `0${I}` : `${I}`,
      V = Y < 10 ? `0${Y}` : `${Y}`,
      F = J < 10 ? `0${J}` : `${J}`;
    return `${sS8[G]}, ${W} ${l_1[B]} ${Q} ${X}:${V}:${F} GMT`
  }
  CB(knQ, "dateToUtcString");
  var rS8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/),
    oS8 = CB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = rS8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X] = Q, V = q5A(N5A(G)), F = B_(Z, "month", 1, 12), K = B_(I, "day", 1, 31);
      return XEA(V, F, K, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      })
    }, "parseRfc3339DateTime"),
    tS8 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/),
    eS8 = CB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = tS8.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X, V] = Q, F = q5A(N5A(G)), K = B_(Z, "month", 1, 12), D = B_(I, "day", 1, 31), H = XEA(F, K, D, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      });
      if (V.toUpperCase() != "Z") H.setTime(H.getTime() - K_8(V));
      return H
    }, "parseRfc3339DateTimeWithOffset"),
    A_8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    Q_8 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    B_8 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/),
    G_8 = CB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-7231 date-times must be expressed as strings");
      let Q = A_8.exec(A);
      if (Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return XEA(q5A(N5A(I)), b_1(Z), B_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        })
      }
      if (Q = Q_8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return J_8(XEA(I_8(I), b_1(Z), B_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        }))
      }
      if (Q = B_8.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return XEA(q5A(N5A(X)), b_1(G), B_(Z.trimLeft(), "day", 1, 31), {
          hours: I,
          minutes: Y,
          seconds: J,
          fractionalMilliseconds: W
        })
      }
      throw TypeError("Invalid RFC-7231 date-time value")
    }, "parseRfc7231DateTime"),
    Z_8 = CB((A) => {
      if (A === null || A === void 0) return;
      let Q;
      if (typeof A === "number") Q = A;
      else if (typeof A === "string") Q = c_1(A);
      else if (typeof A === "object" && A.tag === 1) Q = A.value;
      else throw TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      if (Number.isNaN(Q) || Q === 1 / 0 || Q === -1 / 0) throw TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      return new Date(Math.round(Q * 1000))
    }, "parseEpochTimestamp"),
    XEA = CB((A, Q, B, G) => {
      let Z = Q - 1;
      return X_8(A, Z, B), new Date(Date.UTC(A, Z, B, B_(G.hours, "hour", 0, 23), B_(G.minutes, "minute", 0, 59), B_(G.seconds, "seconds", 0, 60), F_8(G.fractionalMilliseconds)))
    }, "buildDate"),
    I_8 = CB((A) => {
      let Q = new Date().getUTCFullYear(),
        B = Math.floor(Q / 100) * 100 + q5A(N5A(A));
      if (B < Q) return B + 100;
      return B
    }, "parseTwoDigitYear"),
    Y_8 = 1576800000000,
    J_8 = CB((A) => {
      if (A.getTime() - new Date().getTime() > Y_8) return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));
      return A
    }, "adjustRfc850Year"),
    b_1 = CB((A) => {
      let Q = l_1.indexOf(A);
      if (Q < 0) throw TypeError(`Invalid month: ${A}`);
      return Q + 1
    }, "parseMonthByShortName"),
    W_8 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    X_8 = CB((A, Q, B) => {
      let G = W_8[Q];
      if (Q === 1 && V_8(A)) G = 29;
      if (B > G) throw TypeError(`Invalid day for ${l_1[Q]} in ${A}: ${B}`)
    }, "validateDayOfMonth"),
    V_8 = CB((A) => {
      return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0)
    }, "isLeapYear"),
    B_ = CB((A, Q, B, G) => {
      let Z = _nQ(N5A(A));
      if (Z < B || Z > G) throw TypeError(`${Q} must be between ${B} and ${G}, inclusive`);
      return Z
    }, "parseDateValue"),
    F_8 = CB((A) => {
      if (A === null || A === void 0) return 0;
      return PnQ("0." + A) * 1000
    }, "parseMilliseconds"),
    K_8 = CB((A) => {
      let Q = A[0],
        B = 1;
      if (Q == "+") B = 1;
      else if (Q == "-") B = -1;
      else throw TypeError(`Offset direction, ${Q}, must be "+" or "-"`);
      let G = Number(A.substring(1, 3)),
        Z = Number(A.substring(4, 6));
      return B * (G * 60 + Z) * 60 * 1000
    }, "parseOffsetToMilliseconds"),
    N5A = CB((A) => {
      let Q = 0;
      while (Q < A.length - 1 && A.charAt(Q) === "0") Q++;
      if (Q === 0) return A;
      return A.slice(Q)
    }, "stripLeadingZeroes"),
    D_8 = class A extends Error {
      static {
        CB(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    ynQ = CB((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    xnQ = CB(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = C_8(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw ynQ(Y, Q)
    }, "throwDefaultError"),
    H_8 = CB((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        xnQ({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    C_8 = CB((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    E_8 = CB((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    LnQ = !1,
    z_8 = CB((A) => {
      if (A && !LnQ && parseInt(A.substring(1, A.indexOf("."))) < 16) LnQ = !0
    }, "emitWarningIfUnsupportedVersion"),
    U_8 = CB((A) => {
      let Q = [];
      for (let B in f_1.AlgorithmId) {
        let G = f_1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    $_8 = CB((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    w_8 = CB((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    q_8 = CB((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    vnQ = CB((A) => {
      return Object.assign(U_8(A), w_8(A))
    }, "getDefaultExtensionConfiguration"),
    N_8 = vnQ,
    L_8 = CB((A) => {
      return Object.assign($_8(A), q_8(A))
    }, "resolveDefaultRuntimeConfig"),
    M_8 = CB((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    bnQ = CB((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = bnQ(A[B]);
      return A
    }, "getValueFromTextNode"),
    O_8 = CB((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    jo = CB(function(Q) {
      return Object.assign(new String(Q), {
        deserializeJSON() {
          return JSON.parse(String(Q))
        },
        toString() {
          return String(Q)
        },
        toJSON() {
          return String(Q)
        }
      })
    }, "LazyJsonString");
  jo.from = (A) => {
    if (A && typeof A === "object" && (A instanceof jo || ("deserializeJSON" in A))) return A;
    else if (typeof A === "string" || Object.getPrototypeOf(A) === String.prototype) return jo(String(A));
    return jo(JSON.stringify(A))
  };
  jo.fromObject = jo.from;
  var R_8 = class {
    static {
      CB(this, "NoOpLogger")
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };

  function i_1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, j_8(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      fnQ(G, null, I, Y)
    }
    return G
  }
  CB(i_1, "map");
  var T_8 = CB((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    P_8 = CB((A, Q) => {
      let B = {};
      for (let G in Q) fnQ(B, A, Q, G);
      return B
    }, "take"),
    j_8 = CB((A, Q, B) => {
      return i_1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    fnQ = CB((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = S_8, W = __8, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    S_8 = CB((A) => A != null, "nonNullish"),
    __8 = CB((A) => A, "pass");

  function hnQ(A) {
    if (A.includes(",") || A.includes('"')) A = `"${A.replace(/"/g,"\\\"")}"`;
    return A
  }
  CB(hnQ, "quoteHeader");
  var k_8 = CB((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    y_8 = CB((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    m_1 = CB((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(m_1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = m_1(A[B])
        }
        return Q
      }
      return A
    }, "_json");

  function gnQ(A, Q, B) {
    if (B <= 0 || !Number.isInteger(B)) throw Error("Invalid number of delimiters (" + B + ") for splitEvery.");
    let G = A.split(Q);
    if (B === 1) return G;
    let Z = [],
      I = "";
    for (let Y = 0; Y < G.length; Y++) {
      if (I === "") I = G[Y];
      else I += Q + G[Y];
      if ((Y + 1) % B === 0) Z.push(I), I = ""
    }
    if (I !== "") Z.push(I);
    return Z
  }
  CB(gnQ, "splitEvery");
  var x_8 = CB((A) => {
    let Q = A.length,
      B = [],
      G = !1,
      Z = void 0,
      I = 0;
    for (let Y = 0; Y < Q; ++Y) {
      let J = A[Y];
      switch (J) {
        case '"':
          if (Z !== "\\") G = !G;
          break;
        case ",":
          if (!G) B.push(A.slice(I, Y)), I = Y + 1;
          break;
        default:
      }
      Z = J
    }
    return B.push(A.slice(I)), B.map((Y) => {
      Y = Y.trim();
      let J = Y.length;
      if (J < 2) return Y;
      if (Y[0] === '"' && Y[J - 1] === '"') Y = Y.slice(1, J - 1);
      return Y.replace(/\\"/g, '"')
    })
  }, "splitHeader")
})
// @from(Start 4428097, End 4429568)
a_1 = z((mnQ) => {
  Object.defineProperty(mnQ, "__esModule", {
    value: !0
  });
  mnQ.resolveHttpAuthSchemeConfig = mnQ.defaultSSOOIDCHttpAuthSchemeProvider = mnQ.defaultSSOOIDCHttpAuthSchemeParametersProvider = void 0;
  var v_8 = jF(),
    n_1 = w7(),
    b_8 = async (A, Q, B) => {
      return {
        operation: (0, n_1.getSmithyContext)(Q).operation,
        region: await (0, n_1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  mnQ.defaultSSOOIDCHttpAuthSchemeParametersProvider = b_8;

  function f_8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function h_8(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var g_8 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "CreateToken": {
        Q.push(h_8(A));
        break
      }
      default:
        Q.push(f_8(A))
    }
    return Q
  };
  mnQ.defaultSSOOIDCHttpAuthSchemeProvider = g_8;
  var u_8 = (A) => {
    let Q = (0, v_8.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, n_1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  mnQ.resolveHttpAuthSchemeConfig = u_8
})
// @from(Start 4429574, End 4446830)
r_1 = z((Bj7, MpA) => {
  var cnQ, pnQ, lnQ, inQ, nnQ, anQ, snQ, rnQ, onQ, tnQ, enQ, AaQ, QaQ, NpA, s_1, BaQ, GaQ, ZaQ, M5A, IaQ, YaQ, JaQ, WaQ, XaQ, VaQ, FaQ, KaQ, DaQ, LpA, HaQ, CaQ, EaQ;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof MpA === "object" && typeof Bj7 === "object") A(B(Q, B(Bj7)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    cnQ = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, pnQ = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, lnQ = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, inQ = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, nnQ = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, anQ = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, snQ = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, rnQ = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, onQ = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, tnQ = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, enQ = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, AaQ = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, QaQ = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) LpA(Y, I, J)
    }, LpA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, NpA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, s_1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, BaQ = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(s_1(arguments[Y]));
      return I
    }, GaQ = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, ZaQ = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, M5A = function(I) {
      return this instanceof M5A ? (this.v = I, this) : new M5A(I)
    }, IaQ = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof M5A ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, YaQ = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: M5A(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, JaQ = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof NpA === "function" ? NpA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, WaQ = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    XaQ = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") LpA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, VaQ = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, FaQ = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, KaQ = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, DaQ = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, HaQ = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    CaQ = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, EaQ = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", cnQ), A("__assign", pnQ), A("__rest", lnQ), A("__decorate", inQ), A("__param", nnQ), A("__esDecorate", anQ), A("__runInitializers", snQ), A("__propKey", rnQ), A("__setFunctionName", onQ), A("__metadata", tnQ), A("__awaiter", enQ), A("__generator", AaQ), A("__exportStar", QaQ), A("__createBinding", LpA), A("__values", NpA), A("__read", s_1), A("__spread", BaQ), A("__spreadArrays", GaQ), A("__spreadArray", ZaQ), A("__await", M5A), A("__asyncGenerator", IaQ), A("__asyncDelegator", YaQ), A("__asyncValues", JaQ), A("__makeTemplateObject", WaQ), A("__importStar", XaQ), A("__importDefault", VaQ), A("__classPrivateFieldGet", FaQ), A("__classPrivateFieldSet", KaQ), A("__classPrivateFieldIn", DaQ), A("__addDisposableResource", HaQ), A("__disposeResources", CaQ), A("__rewriteRelativeImportExtension", EaQ)
  })
})
// @from(Start 4446836, End 4451117)
o_1 = z((Gj7, c_8) => {
  c_8.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.797.0",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=18.0.0"
    },
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.796.0",
      "@aws-sdk/middleware-host-header": "3.775.0",
      "@aws-sdk/middleware-logger": "3.775.0",
      "@aws-sdk/middleware-recursion-detection": "3.775.0",
      "@aws-sdk/middleware-user-agent": "3.796.0",
      "@aws-sdk/region-config-resolver": "3.775.0",
      "@aws-sdk/types": "3.775.0",
      "@aws-sdk/util-endpoints": "3.787.0",
      "@aws-sdk/util-user-agent-browser": "3.775.0",
      "@aws-sdk/util-user-agent-node": "3.796.0",
      "@smithy/config-resolver": "^4.1.0",
      "@smithy/core": "^3.2.0",
      "@smithy/fetch-http-handler": "^5.0.2",
      "@smithy/hash-node": "^4.0.2",
      "@smithy/invalid-dependency": "^4.0.2",
      "@smithy/middleware-content-length": "^4.0.2",
      "@smithy/middleware-endpoint": "^4.1.0",
      "@smithy/middleware-retry": "^4.1.0",
      "@smithy/middleware-serde": "^4.0.3",
      "@smithy/middleware-stack": "^4.0.2",
      "@smithy/node-config-provider": "^4.0.2",
      "@smithy/node-http-handler": "^4.0.4",
      "@smithy/protocol-http": "^5.1.0",
      "@smithy/smithy-client": "^4.2.0",
      "@smithy/types": "^4.2.0",
      "@smithy/url-parser": "^4.0.2",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.8",
      "@smithy/util-defaults-mode-node": "^4.0.8",
      "@smithy/util-endpoints": "^3.0.2",
      "@smithy/util-middleware": "^4.0.2",
      "@smithy/util-retry": "^4.0.2",
      "@smithy/util-utf8": "^4.0.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["./sso-oidc.d.ts", "./sso-oidc.js", "./sts.d.ts", "./sts.js", "dist-*/**"],
    browser: {
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./sso-oidc": {
        types: "./dist-types/submodules/sso-oidc/index.d.ts",
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js"
      },
      "./sts": {
        types: "./dist-types/submodules/sts/index.d.ts",
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js"
      }
    }
  }
})
// @from(Start 4451123, End 4451610)
$aQ = z((zaQ) => {
  Object.defineProperty(zaQ, "__esModule", {
    value: !0
  });
  zaQ.fromBase64 = void 0;
  var p_8 = hI(),
    l_8 = /^[A-Za-z0-9+/]*={0,2}$/,
    i_8 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!l_8.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, p_8.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  zaQ.fromBase64 = i_8
})
// @from(Start 4451616, End 4452195)
NaQ = z((waQ) => {
  Object.defineProperty(waQ, "__esModule", {
    value: !0
  });
  waQ.toBase64 = void 0;
  var n_8 = hI(),
    a_8 = O2(),
    s_8 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, a_8.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, n_8.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  waQ.toBase64 = s_8
})
// @from(Start 4452201, End 4452897)
Ak1 = z((Yj7, OpA) => {
  var {
    defineProperty: LaQ,
    getOwnPropertyDescriptor: r_8,
    getOwnPropertyNames: o_8
  } = Object, t_8 = Object.prototype.hasOwnProperty, t_1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of o_8(Q))
        if (!t_8.call(A, Z) && Z !== B) LaQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = r_8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, MaQ = (A, Q, B) => (t_1(A, Q, "default"), B && t_1(B, Q, "default")), e_8 = (A) => t_1(LaQ({}, "__esModule", {
    value: !0
  }), A), e_1 = {};
  OpA.exports = e_8(e_1);
  MaQ(e_1, $aQ(), OpA.exports);
  MaQ(e_1, NaQ(), OpA.exports)
})
// @from(Start 4452903, End 4457570)
maQ = z((gaQ) => {
  Object.defineProperty(gaQ, "__esModule", {
    value: !0
  });
  gaQ.ruleSet = void 0;
  var vaQ = "required",
    pL = "fn",
    lL = "argv",
    T5A = "ref",
    OaQ = !0,
    RaQ = "isSet",
    DEA = "booleanEquals",
    O5A = "error",
    R5A = "endpoint",
    $b = "tree",
    Qk1 = "PartitionResult",
    Bk1 = "getAttr",
    TaQ = {
      [vaQ]: !1,
      type: "String"
    },
    PaQ = {
      [vaQ]: !0,
      default: !1,
      type: "Boolean"
    },
    jaQ = {
      [T5A]: "Endpoint"
    },
    baQ = {
      [pL]: DEA,
      [lL]: [{
        [T5A]: "UseFIPS"
      }, !0]
    },
    faQ = {
      [pL]: DEA,
      [lL]: [{
        [T5A]: "UseDualStack"
      }, !0]
    },
    cL = {},
    SaQ = {
      [pL]: Bk1,
      [lL]: [{
        [T5A]: Qk1
      }, "supportsFIPS"]
    },
    haQ = {
      [T5A]: Qk1
    },
    _aQ = {
      [pL]: DEA,
      [lL]: [!0, {
        [pL]: Bk1,
        [lL]: [haQ, "supportsDualStack"]
      }]
    },
    kaQ = [baQ],
    yaQ = [faQ],
    xaQ = [{
      [T5A]: "Region"
    }],
    Ak8 = {
      version: "1.0",
      parameters: {
        Region: TaQ,
        UseDualStack: PaQ,
        UseFIPS: PaQ,
        Endpoint: TaQ
      },
      rules: [{
        conditions: [{
          [pL]: RaQ,
          [lL]: [jaQ]
        }],
        rules: [{
          conditions: kaQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: O5A
        }, {
          conditions: yaQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          type: O5A
        }, {
          endpoint: {
            url: jaQ,
            properties: cL,
            headers: cL
          },
          type: R5A
        }],
        type: $b
      }, {
        conditions: [{
          [pL]: RaQ,
          [lL]: xaQ
        }],
        rules: [{
          conditions: [{
            [pL]: "aws.partition",
            [lL]: xaQ,
            assign: Qk1
          }],
          rules: [{
            conditions: [baQ, faQ],
            rules: [{
              conditions: [{
                [pL]: DEA,
                [lL]: [OaQ, SaQ]
              }, _aQ],
              rules: [{
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: cL,
                  headers: cL
                },
                type: R5A
              }],
              type: $b
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              type: O5A
            }],
            type: $b
          }, {
            conditions: kaQ,
            rules: [{
              conditions: [{
                [pL]: DEA,
                [lL]: [SaQ, OaQ]
              }],
              rules: [{
                conditions: [{
                  [pL]: "stringEquals",
                  [lL]: [{
                    [pL]: Bk1,
                    [lL]: [haQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://oidc.{Region}.amazonaws.com",
                  properties: cL,
                  headers: cL
                },
                type: R5A
              }, {
                endpoint: {
                  url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: cL,
                  headers: cL
                },
                type: R5A
              }],
              type: $b
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              type: O5A
            }],
            type: $b
          }, {
            conditions: yaQ,
            rules: [{
              conditions: [_aQ],
              rules: [{
                endpoint: {
                  url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: cL,
                  headers: cL
                },
                type: R5A
              }],
              type: $b
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              type: O5A
            }],
            type: $b
          }, {
            endpoint: {
              url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
              properties: cL,
              headers: cL
            },
            type: R5A
          }],
          type: $b
        }],
        type: $b
      }, {
        error: "Invalid Configuration: Missing Region",
        type: O5A
      }]
    };
  gaQ.ruleSet = Ak8
})
// @from(Start 4457576, End 4458140)
paQ = z((daQ) => {
  Object.defineProperty(daQ, "__esModule", {
    value: !0
  });
  daQ.defaultEndpointResolver = void 0;
  var Qk8 = I5A(),
    Gk1 = FI(),
    Bk8 = maQ(),
    Gk8 = new Gk1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    Zk8 = (A, Q = {}) => {
      return Gk8.get(A, () => (0, Gk1.resolveEndpoint)(Bk8.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  daQ.defaultEndpointResolver = Zk8;
  Gk1.customEndpointFunctions.aws = Qk8.awsEndpointFunctions
})
// @from(Start 4458146, End 4459565)
saQ = z((naQ) => {
  Object.defineProperty(naQ, "__esModule", {
    value: !0
  });
  naQ.getRuntimeConfig = void 0;
  var Ik8 = jF(),
    Yk8 = iB(),
    Jk8 = LJ(),
    Wk8 = NJ(),
    laQ = Ak1(),
    iaQ = O2(),
    Xk8 = a_1(),
    Vk8 = paQ(),
    Fk8 = (A) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: A?.base64Decoder ?? laQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? laQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? Vk8.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Xk8.defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Ik8.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Yk8.NoAuthSigner
        }],
        logger: A?.logger ?? new Jk8.NoOpLogger,
        serviceId: A?.serviceId ?? "SSO OIDC",
        urlParser: A?.urlParser ?? Wk8.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? iaQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? iaQ.toUtf8
      }
    };
  naQ.getRuntimeConfig = Fk8
})
// @from(Start 4459571, End 4461731)
QsQ = z((eaQ) => {
  Object.defineProperty(eaQ, "__esModule", {
    value: !0
  });
  eaQ.getRuntimeConfig = void 0;
  var Kk8 = r_1(),
    Dk8 = Kk8.__importDefault(o_1()),
    Hk8 = jF(),
    raQ = eCA(),
    RpA = f8(),
    Ck8 = RX(),
    oaQ = D6(),
    P5A = uI(),
    taQ = IZ(),
    Ek8 = TX(),
    zk8 = KW(),
    Uk8 = saQ(),
    $k8 = LJ(),
    wk8 = PX(),
    qk8 = LJ(),
    Nk8 = (A) => {
      (0, qk8.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, wk8.resolveDefaultsModeConfig)(A),
        B = () => Q().then($k8.loadConfigsForDefaultMode),
        G = (0, Uk8.getRuntimeConfig)(A);
      (0, Hk8.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        bodyLengthChecker: A?.bodyLengthChecker ?? Ek8.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, raQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: Dk8.default.version
        }),
        maxAttempts: A?.maxAttempts ?? (0, P5A.loadConfig)(oaQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, P5A.loadConfig)(RpA.NODE_REGION_CONFIG_OPTIONS, {
          ...RpA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: taQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, P5A.loadConfig)({
          ...oaQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || zk8.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? Ck8.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? taQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, P5A.loadConfig)(RpA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, P5A.loadConfig)(RpA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, P5A.loadConfig)(raQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  eaQ.getRuntimeConfig = Nk8
})
// @from(Start 4461737, End 4466244)
PpA = z((Fj7, YsQ) => {
  var {
    defineProperty: TpA,
    getOwnPropertyDescriptor: Lk8,
    getOwnPropertyNames: Mk8
  } = Object, Ok8 = Object.prototype.hasOwnProperty, Yc = (A, Q) => TpA(A, "name", {
    value: Q,
    configurable: !0
  }), Rk8 = (A, Q) => {
    for (var B in Q) TpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Tk8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Mk8(Q))
        if (!Ok8.call(A, Z) && Z !== B) TpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Lk8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Pk8 = (A) => Tk8(TpA({}, "__esModule", {
    value: !0
  }), A), BsQ = {};
  Rk8(BsQ, {
    Field: () => _k8,
    Fields: () => kk8,
    HttpRequest: () => yk8,
    HttpResponse: () => xk8,
    IHttpRequest: () => GsQ.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => jk8,
    isValidHostname: () => IsQ,
    resolveHttpHandlerRuntimeConfig: () => Sk8
  });
  YsQ.exports = Pk8(BsQ);
  var jk8 = Yc((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    Sk8 = Yc((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    GsQ = x_1(),
    _k8 = class {
      static {
        Yc(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = GsQ.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    kk8 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Yc(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    yk8 = class A {
      static {
        Yc(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = ZsQ(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function ZsQ(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Yc(ZsQ, "cloneQuery");
  var xk8 = class {
    static {
      Yc(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function IsQ(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Yc(IsQ, "isValidHostname")
})
// @from(Start 4466250, End 4486078)
Yk1 = z((Cj7, ysQ) => {
  var {
    defineProperty: jpA,
    getOwnPropertyDescriptor: vk8,
    getOwnPropertyNames: bk8
  } = Object, fk8 = Object.prototype.hasOwnProperty, j6 = (A, Q) => jpA(A, "name", {
    value: Q,
    configurable: !0
  }), hk8 = (A, Q) => {
    for (var B in Q) jpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, gk8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of bk8(Q))
        if (!fk8.call(A, Z) && Z !== B) jpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = vk8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, uk8 = (A) => gk8(jpA({}, "__esModule", {
    value: !0
  }), A), HsQ = {};
  hk8(HsQ, {
    $Command: () => zsQ.Command,
    AccessDeniedException: () => UsQ,
    AuthorizationPendingException: () => $sQ,
    CreateTokenCommand: () => _sQ,
    CreateTokenRequestFilterSensitiveLog: () => wsQ,
    CreateTokenResponseFilterSensitiveLog: () => qsQ,
    ExpiredTokenException: () => NsQ,
    InternalServerException: () => LsQ,
    InvalidClientException: () => MsQ,
    InvalidGrantException: () => OsQ,
    InvalidRequestException: () => RsQ,
    InvalidScopeException: () => TsQ,
    SSOOIDC: () => ksQ,
    SSOOIDCClient: () => EsQ,
    SSOOIDCServiceException: () => _w,
    SlowDownException: () => PsQ,
    UnauthorizedClientException: () => jsQ,
    UnsupportedGrantTypeException: () => SsQ,
    __Client: () => CsQ.Client
  });
  ysQ.exports = uk8(HsQ);
  var JsQ = cCA(),
    mk8 = pCA(),
    dk8 = lCA(),
    WsQ = F5A(),
    ck8 = f8(),
    Zk1 = iB(),
    pk8 = LX(),
    lk8 = q5(),
    XsQ = D6(),
    CsQ = LJ(),
    VsQ = a_1(),
    ik8 = j6((A) => {
      return Object.assign(A, {
        useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
        useFipsEndpoint: A.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth"
      })
    }, "resolveClientEndpointParameters"),
    nk8 = {
      UseFIPS: {
        type: "builtInParams",
        name: "useFipsEndpoint"
      },
      Endpoint: {
        type: "builtInParams",
        name: "endpoint"
      },
      Region: {
        type: "builtInParams",
        name: "region"
      },
      UseDualStack: {
        type: "builtInParams",
        name: "useDualstackEndpoint"
      }
    },
    ak8 = QsQ(),
    FsQ = YEA(),
    KsQ = PpA(),
    DsQ = LJ(),
    sk8 = j6((A) => {
      let {
        httpAuthSchemes: Q,
        httpAuthSchemeProvider: B,
        credentials: G
      } = A;
      return {
        setHttpAuthScheme(Z) {
          let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
          if (I === -1) Q.push(Z);
          else Q.splice(I, 1, Z)
        },
        httpAuthSchemes() {
          return Q
        },
        setHttpAuthSchemeProvider(Z) {
          B = Z
        },
        httpAuthSchemeProvider() {
          return B
        },
        setCredentials(Z) {
          G = Z
        },
        credentials() {
          return G
        }
      }
    }, "getHttpAuthExtensionConfiguration"),
    rk8 = j6((A) => {
      return {
        httpAuthSchemes: A.httpAuthSchemes(),
        httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
        credentials: A.credentials()
      }
    }, "resolveHttpAuthRuntimeConfig"),
    ok8 = j6((A, Q) => {
      let B = Object.assign((0, FsQ.getAwsRegionExtensionConfiguration)(A), (0, DsQ.getDefaultExtensionConfiguration)(A), (0, KsQ.getHttpHandlerExtensionConfiguration)(A), sk8(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, FsQ.resolveAwsRegionExtensionConfiguration)(B), (0, DsQ.resolveDefaultRuntimeConfig)(B), (0, KsQ.resolveHttpHandlerRuntimeConfig)(B), rk8(B))
    }, "resolveRuntimeExtensions"),
    EsQ = class extends CsQ.Client {
      static {
        j6(this, "SSOOIDCClient")
      }
      config;
      constructor(...[A]) {
        let Q = (0, ak8.getRuntimeConfig)(A || {});
        super(Q);
        this.initConfig = Q;
        let B = ik8(Q),
          G = (0, WsQ.resolveUserAgentConfig)(B),
          Z = (0, XsQ.resolveRetryConfig)(G),
          I = (0, ck8.resolveRegionConfig)(Z),
          Y = (0, JsQ.resolveHostHeaderConfig)(I),
          J = (0, lk8.resolveEndpointConfig)(Y),
          W = (0, VsQ.resolveHttpAuthSchemeConfig)(J),
          X = ok8(W, A?.extensions || []);
        this.config = X, this.middlewareStack.use((0, WsQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, XsQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, pk8.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, JsQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, mk8.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, dk8.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, Zk1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
          httpAuthSchemeParametersProvider: VsQ.defaultSSOOIDCHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: j6(async (V) => new Zk1.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": V.credentials
          }), "identityProviderConfigProvider")
        })), this.middlewareStack.use((0, Zk1.getHttpSigningPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    },
    tk8 = LJ(),
    ek8 = q5(),
    Ay8 = GZ(),
    zsQ = LJ(),
    j5A = LJ(),
    Qy8 = LJ(),
    _w = class A extends Qy8.ServiceException {
      static {
        j6(this, "SSOOIDCServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    UsQ = class A extends _w {
      static {
        j6(this, "AccessDeniedException")
      }
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    $sQ = class A extends _w {
      static {
        j6(this, "AuthorizationPendingException")
      }
      name = "AuthorizationPendingException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    wsQ = j6((A) => ({
      ...A,
      ...A.clientSecret && {
        clientSecret: j5A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: j5A.SENSITIVE_STRING
      },
      ...A.codeVerifier && {
        codeVerifier: j5A.SENSITIVE_STRING
      }
    }), "CreateTokenRequestFilterSensitiveLog"),
    qsQ = j6((A) => ({
      ...A,
      ...A.accessToken && {
        accessToken: j5A.SENSITIVE_STRING
      },
      ...A.refreshToken && {
        refreshToken: j5A.SENSITIVE_STRING
      },
      ...A.idToken && {
        idToken: j5A.SENSITIVE_STRING
      }
    }), "CreateTokenResponseFilterSensitiveLog"),
    NsQ = class A extends _w {
      static {
        j6(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    LsQ = class A extends _w {
      static {
        j6(this, "InternalServerException")
      }
      name = "InternalServerException";
      $fault = "server";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    MsQ = class A extends _w {
      static {
        j6(this, "InvalidClientException")
      }
      name = "InvalidClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    OsQ = class A extends _w {
      static {
        j6(this, "InvalidGrantException")
      }
      name = "InvalidGrantException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    RsQ = class A extends _w {
      static {
        j6(this, "InvalidRequestException")
      }
      name = "InvalidRequestException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    TsQ = class A extends _w {
      static {
        j6(this, "InvalidScopeException")
      }
      name = "InvalidScopeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    PsQ = class A extends _w {
      static {
        j6(this, "SlowDownException")
      }
      name = "SlowDownException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    jsQ = class A extends _w {
      static {
        j6(this, "UnauthorizedClientException")
      }
      name = "UnauthorizedClientException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    SsQ = class A extends _w {
      static {
        j6(this, "UnsupportedGrantTypeException")
      }
      name = "UnsupportedGrantTypeException";
      $fault = "client";
      error;
      error_description;
      constructor(Q) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype), this.error = Q.error, this.error_description = Q.error_description
      }
    },
    Ik1 = jF(),
    By8 = iB(),
    J2 = LJ(),
    Gy8 = j6(async (A, Q) => {
      let B = (0, By8.requestBuilder)(A, Q),
        G = {
          "content-type": "application/json"
        };
      B.bp("/token");
      let Z;
      return Z = JSON.stringify((0, J2.take)(A, {
        clientId: [],
        clientSecret: [],
        code: [],
        codeVerifier: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: j6((I) => (0, J2._json)(I), "scope")
      })), B.m("POST").h(G).b(Z), B.build()
    }, "se_CreateTokenCommand"),
    Zy8 = j6(async (A, Q) => {
      if (A.statusCode !== 200 && A.statusCode >= 300) return Iy8(A, Q);
      let B = (0, J2.map)({
          $metadata: iL(A)
        }),
        G = (0, J2.expectNonNull)((0, J2.expectObject)(await (0, Ik1.parseJsonBody)(A.body, Q)), "body"),
        Z = (0, J2.take)(G, {
          accessToken: J2.expectString,
          expiresIn: J2.expectInt32,
          idToken: J2.expectString,
          refreshToken: J2.expectString,
          tokenType: J2.expectString
        });
      return Object.assign(B, Z), B
    }, "de_CreateTokenCommand"),
    Iy8 = j6(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, Ik1.parseJsonErrorBody)(A.body, Q)
        },
        G = (0, Ik1.loadRestJsonErrorCode)(A, B.body);
      switch (G) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
          throw await Jy8(B, Q);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
          throw await Wy8(B, Q);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
          throw await Xy8(B, Q);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
          throw await Vy8(B, Q);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
          throw await Fy8(B, Q);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
          throw await Ky8(B, Q);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
          throw await Dy8(B, Q);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
          throw await Hy8(B, Q);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
          throw await Cy8(B, Q);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
          throw await Ey8(B, Q);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
          throw await zy8(B, Q);
        default:
          let Z = B.body;
          return Yy8({
            output: A,
            parsedBody: Z,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    Yy8 = (0, J2.withBaseException)(_w),
    Jy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new UsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_AccessDeniedExceptionRes"),
    Wy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new $sQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_AuthorizationPendingExceptionRes"),
    Xy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new NsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_ExpiredTokenExceptionRes"),
    Vy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new LsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_InternalServerExceptionRes"),
    Fy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new MsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_InvalidClientExceptionRes"),
    Ky8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new OsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_InvalidGrantExceptionRes"),
    Dy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new RsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_InvalidRequestExceptionRes"),
    Hy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new TsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_InvalidScopeExceptionRes"),
    Cy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new PsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_SlowDownExceptionRes"),
    Ey8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new jsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_UnauthorizedClientExceptionRes"),
    zy8 = j6(async (A, Q) => {
      let B = (0, J2.map)({}),
        G = A.body,
        Z = (0, J2.take)(G, {
          error: J2.expectString,
          error_description: J2.expectString
        });
      Object.assign(B, Z);
      let I = new SsQ({
        $metadata: iL(A),
        ...B
      });
      return (0, J2.decorateServiceException)(I, A.body)
    }, "de_UnsupportedGrantTypeExceptionRes"),
    iL = j6((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    _sQ = class extends zsQ.Command.classBuilder().ep(nk8).m(function(A, Q, B, G) {
      return [(0, Ay8.getSerdePlugin)(B, this.serialize, this.deserialize), (0, ek8.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(wsQ, qsQ).ser(Gy8).de(Zy8).build() {
      static {
        j6(this, "CreateTokenCommand")
      }
    },
    Uy8 = {
      CreateTokenCommand: _sQ
    },
    ksQ = class extends EsQ {
      static {
        j6(this, "SSOOIDC")
      }
    };
  (0, tk8.createAggregatedClient)(Uy8, ksQ)
})
// @from(Start 4486084, End 4491546)
msQ = z(($j7, usQ) => {
  var {
    create: $y8,
    defineProperty: CEA,
    getOwnPropertyDescriptor: wy8,
    getOwnPropertyNames: qy8,
    getPrototypeOf: Ny8
  } = Object, Ly8 = Object.prototype.hasOwnProperty, Jc = (A, Q) => CEA(A, "name", {
    value: Q,
    configurable: !0
  }), My8 = (A, Q) => {
    for (var B in Q) CEA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, bsQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qy8(Q))
        if (!Ly8.call(A, Z) && Z !== B) CEA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wy8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, fsQ = (A, Q, B) => (B = A != null ? $y8(Ny8(A)) : {}, bsQ(Q || !A || !A.__esModule ? CEA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), Oy8 = (A) => bsQ(CEA({}, "__esModule", {
    value: !0
  }), A), hsQ = {};
  My8(hsQ, {
    fromSso: () => gsQ,
    fromStatic: () => ky8,
    nodeProvider: () => yy8
  });
  usQ.exports = Oy8(hsQ);
  var Ry8 = 300000,
    Jk1 = "To refresh this SSO session run 'aws sso login' with the corresponding profile.",
    Ty8 = Jc(async (A, Q = {}) => {
      let {
        SSOOIDCClient: B
      } = await Promise.resolve().then(() => fsQ(Yk1()));
      return new B(Object.assign({}, Q.clientConfig ?? {}, {
        region: A ?? Q.clientConfig?.region,
        logger: Q.clientConfig?.logger ?? Q.parentClientConfig?.logger
      }))
    }, "getSsoOidcClient"),
    Py8 = Jc(async (A, Q, B = {}) => {
      let {
        CreateTokenCommand: G
      } = await Promise.resolve().then(() => fsQ(Yk1()));
      return (await Ty8(Q, B)).send(new G({
        clientId: A.clientId,
        clientSecret: A.clientSecret,
        refreshToken: A.refreshToken,
        grantType: "refresh_token"
      }))
    }, "getNewSsoOidcToken"),
    eR = j2(),
    xsQ = Jc((A) => {
      if (A.expiration && A.expiration.getTime() < Date.now()) throw new eR.TokenProviderError(`Token is expired. ${Jk1}`, !1)
    }, "validateTokenExpiry"),
    So = Jc((A, Q, B = !1) => {
      if (typeof Q > "u") throw new eR.TokenProviderError(`Value not present for '${A}' in SSO Token${B?". Cannot refresh":""}. ${Jk1}`, !1)
    }, "validateTokenKey"),
    HEA = SG(),
    jy8 = UA("fs"),
    {
      writeFile: Sy8
    } = jy8.promises,
    _y8 = Jc((A, Q) => {
      let B = (0, HEA.getSSOTokenFilepath)(A),
        G = JSON.stringify(Q, null, 2);
      return Sy8(B, G)
    }, "writeSSOTokenToFile"),
    vsQ = new Date(0),
    gsQ = Jc((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/token-providers - fromSso");
      let G = await (0, HEA.parseKnownFiles)(B),
        Z = (0, HEA.getProfileName)({
          profile: B.profile ?? Q?.profile
        }),
        I = G[Z];
      if (!I) throw new eR.TokenProviderError(`Profile '${Z}' could not be found in shared credentials file.`, !1);
      else if (!I.sso_session) throw new eR.TokenProviderError(`Profile '${Z}' is missing required property 'sso_session'.`);
      let Y = I.sso_session,
        W = (await (0, HEA.loadSsoSessionData)(B))[Y];
      if (!W) throw new eR.TokenProviderError(`Sso session '${Y}' could not be found in shared credentials file.`, !1);
      for (let C of ["sso_start_url", "sso_region"])
        if (!W[C]) throw new eR.TokenProviderError(`Sso session '${Y}' is missing required property '${C}'.`, !1);
      let {
        sso_start_url: X,
        sso_region: V
      } = W, F;
      try {
        F = await (0, HEA.getSSOTokenFromFile)(Y)
      } catch (C) {
        throw new eR.TokenProviderError(`The SSO session token associated with profile=${Z} was not found or is invalid. ${Jk1}`, !1)
      }
      So("accessToken", F.accessToken), So("expiresAt", F.expiresAt);
      let {
        accessToken: K,
        expiresAt: D
      } = F, H = {
        token: K,
        expiration: new Date(D)
      };
      if (H.expiration.getTime() - Date.now() > Ry8) return H;
      if (Date.now() - vsQ.getTime() < 30000) return xsQ(H), H;
      So("clientId", F.clientId, !0), So("clientSecret", F.clientSecret, !0), So("refreshToken", F.refreshToken, !0);
      try {
        vsQ.setTime(Date.now());
        let C = await Py8(F, V, B);
        So("accessToken", C.accessToken), So("expiresIn", C.expiresIn);
        let E = new Date(Date.now() + C.expiresIn * 1000);
        try {
          await _y8(Y, {
            ...F,
            accessToken: C.accessToken,
            expiresAt: E.toISOString(),
            refreshToken: C.refreshToken
          })
        } catch (U) {}
        return {
          token: C.accessToken,
          expiration: E
        }
      } catch (C) {
        return xsQ(H), H
      }
    }, "fromSso"),
    ky8 = Jc(({
      token: A,
      logger: Q
    }) => async () => {
      if (Q?.debug("@aws-sdk/token-providers - fromStatic"), !A || !A.token) throw new eR.TokenProviderError("Please pass a valid token to fromStatic", !1);
      return A
    }, "fromStatic"),
    yy8 = Jc((A = {}) => (0, eR.memoize)((0, eR.chain)(gsQ(A), async () => {
      throw new eR.TokenProviderError("Could not load token from any providers", !1)
    }), (Q) => Q.expiration !== void 0 && Q.expiration.getTime() - Date.now() < 300000, (Q) => Q.expiration !== void 0), "nodeProvider")
})
// @from(Start 4491552, End 4498794)
Xk1 = z((wj7, rsQ) => {
  var {
    defineProperty: _pA,
    getOwnPropertyDescriptor: xy8,
    getOwnPropertyNames: psQ
  } = Object, vy8 = Object.prototype.hasOwnProperty, kpA = (A, Q) => _pA(A, "name", {
    value: Q,
    configurable: !0
  }), by8 = (A, Q) => function() {
    return A && (Q = (0, A[psQ(A)[0]])(A = 0)), Q
  }, lsQ = (A, Q) => {
    for (var B in Q) _pA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, fy8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of psQ(Q))
        if (!vy8.call(A, Z) && Z !== B) _pA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = xy8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, hy8 = (A) => fy8(_pA({}, "__esModule", {
    value: !0
  }), A), isQ = {};
  lsQ(isQ, {
    GetRoleCredentialsCommand: () => Wk1.GetRoleCredentialsCommand,
    SSOClient: () => Wk1.SSOClient
  });
  var Wk1, gy8 = by8({
      "src/loadSso.ts"() {
        Wk1 = DnQ()
      }
    }),
    nsQ = {};
  lsQ(nsQ, {
    fromSSO: () => my8,
    isSsoProfile: () => asQ,
    validateSsoProfile: () => ssQ
  });
  rsQ.exports = hy8(nsQ);
  var asQ = kpA((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    dsQ = rS(),
    uy8 = msQ(),
    AT = j2(),
    SpA = SG(),
    EEA = !1,
    csQ = kpA(async ({
      ssoStartUrl: A,
      ssoSession: Q,
      ssoAccountId: B,
      ssoRegion: G,
      ssoRoleName: Z,
      ssoClient: I,
      clientConfig: Y,
      parentClientConfig: J,
      profile: W,
      logger: X
    }) => {
      let V, F = "To refresh this SSO session run aws sso login with the corresponding profile.";
      if (Q) try {
        let v = await (0, uy8.fromSso)({
          profile: W
        })();
        V = {
          accessToken: v.token,
          expiresAt: new Date(v.expiration).toISOString()
        }
      } catch (v) {
        throw new AT.CredentialsProviderError(v.message, {
          tryNextLink: EEA,
          logger: X
        })
      } else try {
        V = await (0, SpA.getSSOTokenFromFile)(A)
      } catch (v) {
        throw new AT.CredentialsProviderError("The SSO session associated with this profile is invalid. To refresh this SSO session run aws sso login with the corresponding profile.", {
          tryNextLink: EEA,
          logger: X
        })
      }
      if (new Date(V.expiresAt).getTime() - Date.now() <= 0) throw new AT.CredentialsProviderError("The SSO session associated with this profile has expired. To refresh this SSO session run aws sso login with the corresponding profile.", {
        tryNextLink: EEA,
        logger: X
      });
      let {
        accessToken: K
      } = V, {
        SSOClient: D,
        GetRoleCredentialsCommand: H
      } = await Promise.resolve().then(() => (gy8(), isQ)), C = I || new D(Object.assign({}, Y ?? {}, {
        logger: Y?.logger ?? J?.logger,
        region: Y?.region ?? G
      })), E;
      try {
        E = await C.send(new H({
          accountId: B,
          roleName: Z,
          accessToken: K
        }))
      } catch (v) {
        throw new AT.CredentialsProviderError(v, {
          tryNextLink: EEA,
          logger: X
        })
      }
      let {
        roleCredentials: {
          accessKeyId: U,
          secretAccessKey: q,
          sessionToken: w,
          expiration: N,
          credentialScope: R,
          accountId: T
        } = {}
      } = E;
      if (!U || !q || !w || !N) throw new AT.CredentialsProviderError("SSO returns an invalid temporary credential.", {
        tryNextLink: EEA,
        logger: X
      });
      let y = {
        accessKeyId: U,
        secretAccessKey: q,
        sessionToken: w,
        expiration: new Date(N),
        ...R && {
          credentialScope: R
        },
        ...T && {
          accountId: T
        }
      };
      if (Q)(0, dsQ.setCredentialFeature)(y, "CREDENTIALS_SSO", "s");
      else(0, dsQ.setCredentialFeature)(y, "CREDENTIALS_SSO_LEGACY", "u");
      return y
    }, "resolveSSOCredentials"),
    ssQ = kpA((A, Q) => {
      let {
        sso_start_url: B,
        sso_account_id: G,
        sso_region: Z,
        sso_role_name: I
      } = A;
      if (!B || !G || !Z || !I) throw new AT.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(A).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, {
        tryNextLink: !1,
        logger: Q
      });
      return A
    }, "validateSsoProfile"),
    my8 = kpA((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
      let {
        ssoStartUrl: B,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoSession: Y
      } = A, {
        ssoClient: J
      } = A, W = (0, SpA.getProfileName)({
        profile: A.profile ?? Q?.profile
      });
      if (!B && !G && !Z && !I && !Y) {
        let V = (await (0, SpA.parseKnownFiles)(A))[W];
        if (!V) throw new AT.CredentialsProviderError(`Profile ${W} was not found.`, {
          logger: A.logger
        });
        if (!asQ(V)) throw new AT.CredentialsProviderError(`Profile ${W} is not configured with SSO credentials.`, {
          logger: A.logger
        });
        if (V?.sso_session) {
          let U = (await (0, SpA.loadSsoSessionData)(A))[V.sso_session],
            q = ` configurations in profile ${W} and sso-session ${V.sso_session}`;
          if (Z && Z !== U.sso_region) throw new AT.CredentialsProviderError("Conflicting SSO region" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          if (B && B !== U.sso_start_url) throw new AT.CredentialsProviderError("Conflicting SSO start_url" + q, {
            tryNextLink: !1,
            logger: A.logger
          });
          V.sso_region = U.sso_region, V.sso_start_url = U.sso_start_url
        }
        let {
          sso_start_url: F,
          sso_account_id: K,
          sso_region: D,
          sso_role_name: H,
          sso_session: C
        } = ssQ(V, A.logger);
        return csQ({
          ssoStartUrl: F,
          ssoSession: C,
          ssoAccountId: K,
          ssoRegion: D,
          ssoRoleName: H,
          ssoClient: J,
          clientConfig: A.clientConfig,
          parentClientConfig: A.parentClientConfig,
          profile: W
        })
      } else if (!B || !G || !Z || !I) throw new AT.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', {
        tryNextLink: !1,
        logger: A.logger
      });
      else return csQ({
        ssoStartUrl: B,
        ssoSession: Y,
        ssoAccountId: G,
        ssoRegion: Z,
        ssoRoleName: I,
        ssoClient: J,
        clientConfig: A.clientConfig,
        parentClientConfig: A.parentClientConfig,
        profile: W
      })
    }, "fromSSO")
})
// @from(Start 4498800, End 4500457)
Fk1 = z((osQ) => {
  Object.defineProperty(osQ, "__esModule", {
    value: !0
  });
  osQ.resolveHttpAuthSchemeConfig = osQ.resolveStsAuthConfig = osQ.defaultSTSHttpAuthSchemeProvider = osQ.defaultSTSHttpAuthSchemeParametersProvider = void 0;
  var dy8 = jF(),
    Vk1 = w7(),
    cy8 = zEA(),
    py8 = async (A, Q, B) => {
      return {
        operation: (0, Vk1.getSmithyContext)(Q).operation,
        region: await (0, Vk1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  osQ.defaultSTSHttpAuthSchemeParametersProvider = py8;

  function ly8(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }

  function iy8(A) {
    return {
      schemeId: "smithy.api#noAuth"
    }
  }
  var ny8 = (A) => {
    let Q = [];
    switch (A.operation) {
      case "AssumeRoleWithWebIdentity": {
        Q.push(iy8(A));
        break
      }
      default:
        Q.push(ly8(A))
    }
    return Q
  };
  osQ.defaultSTSHttpAuthSchemeProvider = ny8;
  var ay8 = (A) => Object.assign(A, {
    stsClientCtor: cy8.STSClient
  });
  osQ.resolveStsAuthConfig = ay8;
  var sy8 = (A) => {
    let Q = osQ.resolveStsAuthConfig(A),
      B = (0, dy8.resolveAwsSdkSigV4Config)(Q);
    return Object.assign(B, {
      authSchemePreference: (0, Vk1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  osQ.resolveHttpAuthSchemeConfig = sy8
})
// @from(Start 4500463, End 4501351)
UEA = z((ArQ) => {
  Object.defineProperty(ArQ, "__esModule", {
    value: !0
  });
  ArQ.commonParams = ArQ.resolveClientEndpointParameters = void 0;
  var ty8 = (A) => {
    return Object.assign(A, {
      useDualstackEndpoint: A.useDualstackEndpoint ?? !1,
      useFipsEndpoint: A.useFipsEndpoint ?? !1,
      useGlobalEndpoint: A.useGlobalEndpoint ?? !1,
      defaultSigningName: "sts"
    })
  };
  ArQ.resolveClientEndpointParameters = ty8;
  ArQ.commonParams = {
    UseGlobalEndpoint: {
      type: "builtInParams",
      name: "useGlobalEndpoint"
    },
    UseFIPS: {
      type: "builtInParams",
      name: "useFipsEndpoint"
    },
    Endpoint: {
      type: "builtInParams",
      name: "endpoint"
    },
    Region: {
      type: "builtInParams",
      name: "region"
    },
    UseDualStack: {
      type: "builtInParams",
      name: "useDualstackEndpoint"
    }
  }
})
// @from(Start 4501357, End 4509534)
OrQ = z((LrQ) => {
  Object.defineProperty(LrQ, "__esModule", {
    value: !0
  });
  LrQ.ruleSet = void 0;
  var DrQ = "required",
    c8 = "type",
    I7 = "fn",
    Y7 = "argv",
    Xc = "ref",
    BrQ = !1,
    Kk1 = !0,
    Wc = "booleanEquals",
    CD = "stringEquals",
    HrQ = "sigv4",
    CrQ = "sts",
    ErQ = "us-east-1",
    oI = "endpoint",
    GrQ = "https://sts.{Region}.{PartitionResult#dnsSuffix}",
    G_ = "tree",
    S5A = "error",
    Hk1 = "getAttr",
    ZrQ = {
      [DrQ]: !1,
      [c8]: "String"
    },
    Dk1 = {
      [DrQ]: !0,
      default: !1,
      [c8]: "Boolean"
    },
    zrQ = {
      [Xc]: "Endpoint"
    },
    IrQ = {
      [I7]: "isSet",
      [Y7]: [{
        [Xc]: "Region"
      }]
    },
    ED = {
      [Xc]: "Region"
    },
    YrQ = {
      [I7]: "aws.partition",
      [Y7]: [ED],
      assign: "PartitionResult"
    },
    UrQ = {
      [Xc]: "UseFIPS"
    },
    $rQ = {
      [Xc]: "UseDualStack"
    },
    jH = {
      url: "https://sts.amazonaws.com",
      properties: {
        authSchemes: [{
          name: HrQ,
          signingName: CrQ,
          signingRegion: ErQ
        }]
      },
      headers: {}
    },
    kw = {},
    JrQ = {
      conditions: [{
        [I7]: CD,
        [Y7]: [ED, "aws-global"]
      }],
      [oI]: jH,
      [c8]: oI
    },
    wrQ = {
      [I7]: Wc,
      [Y7]: [UrQ, !0]
    },
    qrQ = {
      [I7]: Wc,
      [Y7]: [$rQ, !0]
    },
    WrQ = {
      [I7]: Hk1,
      [Y7]: [{
        [Xc]: "PartitionResult"
      }, "supportsFIPS"]
    },
    NrQ = {
      [Xc]: "PartitionResult"
    },
    XrQ = {
      [I7]: Wc,
      [Y7]: [!0, {
        [I7]: Hk1,
        [Y7]: [NrQ, "supportsDualStack"]
      }]
    },
    VrQ = [{
      [I7]: "isSet",
      [Y7]: [zrQ]
    }],
    FrQ = [wrQ],
    KrQ = [qrQ],
    Ax8 = {
      version: "1.0",
      parameters: {
        Region: ZrQ,
        UseDualStack: Dk1,
        UseFIPS: Dk1,
        Endpoint: ZrQ,
        UseGlobalEndpoint: Dk1
      },
      rules: [{
        conditions: [{
          [I7]: Wc,
          [Y7]: [{
            [Xc]: "UseGlobalEndpoint"
          }, Kk1]
        }, {
          [I7]: "not",
          [Y7]: VrQ
        }, IrQ, YrQ, {
          [I7]: Wc,
          [Y7]: [UrQ, BrQ]
        }, {
          [I7]: Wc,
          [Y7]: [$rQ, BrQ]
        }],
        rules: [{
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "ap-northeast-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "ap-south-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "ap-southeast-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "ap-southeast-2"]
          }],
          endpoint: jH,
          [c8]: oI
        }, JrQ, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "ca-central-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "eu-central-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "eu-north-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "eu-west-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "eu-west-2"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "eu-west-3"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "sa-east-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, ErQ]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "us-east-2"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "us-west-1"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          conditions: [{
            [I7]: CD,
            [Y7]: [ED, "us-west-2"]
          }],
          endpoint: jH,
          [c8]: oI
        }, {
          endpoint: {
            url: GrQ,
            properties: {
              authSchemes: [{
                name: HrQ,
                signingName: CrQ,
                signingRegion: "{Region}"
              }]
            },
            headers: kw
          },
          [c8]: oI
        }],
        [c8]: G_
      }, {
        conditions: VrQ,
        rules: [{
          conditions: FrQ,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          [c8]: S5A
        }, {
          conditions: KrQ,
          error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
          [c8]: S5A
        }, {
          endpoint: {
            url: zrQ,
            properties: kw,
            headers: kw
          },
          [c8]: oI
        }],
        [c8]: G_
      }, {
        conditions: [IrQ],
        rules: [{
          conditions: [YrQ],
          rules: [{
            conditions: [wrQ, qrQ],
            rules: [{
              conditions: [{
                [I7]: Wc,
                [Y7]: [Kk1, WrQ]
              }, XrQ],
              rules: [{
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: kw,
                  headers: kw
                },
                [c8]: oI
              }],
              [c8]: G_
            }, {
              error: "FIPS and DualStack are enabled, but this partition does not support one or both",
              [c8]: S5A
            }],
            [c8]: G_
          }, {
            conditions: FrQ,
            rules: [{
              conditions: [{
                [I7]: Wc,
                [Y7]: [WrQ, Kk1]
              }],
              rules: [{
                conditions: [{
                  [I7]: CD,
                  [Y7]: [{
                    [I7]: Hk1,
                    [Y7]: [NrQ, "name"]
                  }, "aws-us-gov"]
                }],
                endpoint: {
                  url: "https://sts.{Region}.amazonaws.com",
                  properties: kw,
                  headers: kw
                },
                [c8]: oI
              }, {
                endpoint: {
                  url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                  properties: kw,
                  headers: kw
                },
                [c8]: oI
              }],
              [c8]: G_
            }, {
              error: "FIPS is enabled but this partition does not support FIPS",
              [c8]: S5A
            }],
            [c8]: G_
          }, {
            conditions: KrQ,
            rules: [{
              conditions: [XrQ],
              rules: [{
                endpoint: {
                  url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                  properties: kw,
                  headers: kw
                },
                [c8]: oI
              }],
              [c8]: G_
            }, {
              error: "DualStack is enabled but this partition does not support DualStack",
              [c8]: S5A
            }],
            [c8]: G_
          }, JrQ, {
            endpoint: {
              url: GrQ,
              properties: kw,
              headers: kw
            },
            [c8]: oI
          }],
          [c8]: G_
        }],
        [c8]: G_
      }, {
        error: "Invalid Configuration: Missing Region",
        [c8]: S5A
      }]
    };
  LrQ.ruleSet = Ax8
})
// @from(Start 4509540, End 4510125)
PrQ = z((RrQ) => {
  Object.defineProperty(RrQ, "__esModule", {
    value: !0
  });
  RrQ.defaultEndpointResolver = void 0;
  var Qx8 = I5A(),
    Ck1 = FI(),
    Bx8 = OrQ(),
    Gx8 = new Ck1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    }),
    Zx8 = (A, Q = {}) => {
      return Gx8.get(A, () => (0, Ck1.resolveEndpoint)(Bx8.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  RrQ.defaultEndpointResolver = Zx8;
  Ck1.customEndpointFunctions.aws = Qx8.awsEndpointFunctions
})
// @from(Start 4510131, End 4511541)
yrQ = z((_rQ) => {
  Object.defineProperty(_rQ, "__esModule", {
    value: !0
  });
  _rQ.getRuntimeConfig = void 0;
  var Ix8 = jF(),
    Yx8 = iB(),
    Jx8 = LJ(),
    Wx8 = NJ(),
    jrQ = Ak1(),
    SrQ = O2(),
    Xx8 = Fk1(),
    Vx8 = PrQ(),
    Fx8 = (A) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: A?.base64Decoder ?? jrQ.fromBase64,
        base64Encoder: A?.base64Encoder ?? jrQ.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? Vx8.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? Xx8.defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Ix8.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (Q) => Q.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Yx8.NoAuthSigner
        }],
        logger: A?.logger ?? new Jx8.NoOpLogger,
        serviceId: A?.serviceId ?? "STS",
        urlParser: A?.urlParser ?? Wx8.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? SrQ.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? SrQ.toUtf8
      }
    };
  _rQ.getRuntimeConfig = Fx8
})
// @from(Start 4511547, End 4514210)
urQ = z((hrQ) => {
  Object.defineProperty(hrQ, "__esModule", {
    value: !0
  });
  hrQ.getRuntimeConfig = void 0;
  var Kx8 = r_1(),
    Dx8 = Kx8.__importDefault(o_1()),
    xrQ = jF(),
    vrQ = eCA(),
    ypA = f8(),
    Hx8 = iB(),
    Cx8 = RX(),
    brQ = D6(),
    _5A = uI(),
    frQ = IZ(),
    Ex8 = TX(),
    zx8 = KW(),
    Ux8 = yrQ(),
    $x8 = LJ(),
    wx8 = PX(),
    qx8 = LJ(),
    Nx8 = (A) => {
      (0, qx8.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, wx8.resolveDefaultsModeConfig)(A),
        B = () => Q().then($x8.loadConfigsForDefaultMode),
        G = (0, Ux8.getRuntimeConfig)(A);
      (0, xrQ.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        bodyLengthChecker: A?.bodyLengthChecker ?? Ex8.calculateBodyLength,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, vrQ.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: Dx8.default.version
        }),
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (I) => I.getIdentityProvider("aws.auth#sigv4") || (async (Y) => await A.credentialDefaultProvider(Y?.__config || {})()),
          signer: new xrQ.AwsSdkSigV4Signer
        }, {
          schemeId: "smithy.api#noAuth",
          identityProvider: (I) => I.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new Hx8.NoAuthSigner
        }],
        maxAttempts: A?.maxAttempts ?? (0, _5A.loadConfig)(brQ.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, _5A.loadConfig)(ypA.NODE_REGION_CONFIG_OPTIONS, {
          ...ypA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: frQ.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, _5A.loadConfig)({
          ...brQ.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || zx8.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? Cx8.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? frQ.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, _5A.loadConfig)(ypA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, _5A.loadConfig)(ypA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, _5A.loadConfig)(vrQ.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  hrQ.getRuntimeConfig = Nx8
})
// @from(Start 4514216, End 4515235)
crQ = z((mrQ) => {
  Object.defineProperty(mrQ, "__esModule", {
    value: !0
  });
  mrQ.resolveHttpAuthRuntimeConfig = mrQ.getHttpAuthExtensionConfiguration = void 0;
  var Lx8 = (A) => {
    let {
      httpAuthSchemes: Q,
      httpAuthSchemeProvider: B,
      credentials: G
    } = A;
    return {
      setHttpAuthScheme(Z) {
        let I = Q.findIndex((Y) => Y.schemeId === Z.schemeId);
        if (I === -1) Q.push(Z);
        else Q.splice(I, 1, Z)
      },
      httpAuthSchemes() {
        return Q
      },
      setHttpAuthSchemeProvider(Z) {
        B = Z
      },
      httpAuthSchemeProvider() {
        return B
      },
      setCredentials(Z) {
        G = Z
      },
      credentials() {
        return G
      }
    }
  };
  mrQ.getHttpAuthExtensionConfiguration = Lx8;
  var Mx8 = (A) => {
    return {
      httpAuthSchemes: A.httpAuthSchemes(),
      httpAuthSchemeProvider: A.httpAuthSchemeProvider(),
      credentials: A.credentials()
    }
  };
  mrQ.resolveHttpAuthRuntimeConfig = Mx8
})
// @from(Start 4515241, End 4515967)
rrQ = z((arQ) => {
  Object.defineProperty(arQ, "__esModule", {
    value: !0
  });
  arQ.resolveRuntimeExtensions = void 0;
  var prQ = YEA(),
    lrQ = PpA(),
    irQ = LJ(),
    nrQ = crQ(),
    Rx8 = (A, Q) => {
      let B = Object.assign((0, prQ.getAwsRegionExtensionConfiguration)(A), (0, irQ.getDefaultExtensionConfiguration)(A), (0, lrQ.getHttpHandlerExtensionConfiguration)(A), (0, nrQ.getHttpAuthExtensionConfiguration)(A));
      return Q.forEach((G) => G.configure(B)), Object.assign(A, (0, prQ.resolveAwsRegionExtensionConfiguration)(B), (0, irQ.resolveDefaultRuntimeConfig)(B), (0, lrQ.resolveHttpHandlerRuntimeConfig)(B), (0, nrQ.resolveHttpAuthRuntimeConfig)(B))
    };
  arQ.resolveRuntimeExtensions = Rx8
})
// @from(Start 4515973, End 4517955)
zEA = z((zk1) => {
  Object.defineProperty(zk1, "__esModule", {
    value: !0
  });
  zk1.STSClient = zk1.__Client = void 0;
  var orQ = cCA(),
    Tx8 = pCA(),
    Px8 = lCA(),
    trQ = F5A(),
    jx8 = f8(),
    Ek1 = iB(),
    Sx8 = LX(),
    _x8 = q5(),
    erQ = D6(),
    QoQ = LJ();
  Object.defineProperty(zk1, "__Client", {
    enumerable: !0,
    get: function() {
      return QoQ.Client
    }
  });
  var AoQ = Fk1(),
    kx8 = UEA(),
    yx8 = urQ(),
    xx8 = rrQ();
  class BoQ extends QoQ.Client {
    config;
    constructor(...[A]) {
      let Q = (0, yx8.getRuntimeConfig)(A || {});
      super(Q);
      this.initConfig = Q;
      let B = (0, kx8.resolveClientEndpointParameters)(Q),
        G = (0, trQ.resolveUserAgentConfig)(B),
        Z = (0, erQ.resolveRetryConfig)(G),
        I = (0, jx8.resolveRegionConfig)(Z),
        Y = (0, orQ.resolveHostHeaderConfig)(I),
        J = (0, _x8.resolveEndpointConfig)(Y),
        W = (0, AoQ.resolveHttpAuthSchemeConfig)(J),
        X = (0, xx8.resolveRuntimeExtensions)(W, A?.extensions || []);
      this.config = X, this.middlewareStack.use((0, trQ.getUserAgentPlugin)(this.config)), this.middlewareStack.use((0, erQ.getRetryPlugin)(this.config)), this.middlewareStack.use((0, Sx8.getContentLengthPlugin)(this.config)), this.middlewareStack.use((0, orQ.getHostHeaderPlugin)(this.config)), this.middlewareStack.use((0, Tx8.getLoggerPlugin)(this.config)), this.middlewareStack.use((0, Px8.getRecursionDetectionPlugin)(this.config)), this.middlewareStack.use((0, Ek1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: AoQ.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (V) => new Ek1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": V.credentials
        })
      })), this.middlewareStack.use((0, Ek1.getHttpSigningPlugin)(this.config))
    }
    destroy() {
      super.destroy()
    }
  }
  zk1.STSClient = BoQ
})
// @from(Start 4517961, End 4541334)
ak1 = z((_j7, nk1) => {
  var {
    defineProperty: xpA,
    getOwnPropertyDescriptor: vx8,
    getOwnPropertyNames: bx8
  } = Object, fx8 = Object.prototype.hasOwnProperty, x2 = (A, Q) => xpA(A, "name", {
    value: Q,
    configurable: !0
  }), hx8 = (A, Q) => {
    for (var B in Q) xpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, uk1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of bx8(Q))
        if (!fx8.call(A, Z) && Z !== B) xpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = vx8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, gx8 = (A, Q, B) => (uk1(A, Q, "default"), B && uk1(B, Q, "default")), ux8 = (A) => uk1(xpA({}, "__esModule", {
    value: !0
  }), A), dk1 = {};
  hx8(dk1, {
    AssumeRoleCommand: () => lk1,
    AssumeRoleResponseFilterSensitiveLog: () => YoQ,
    AssumeRoleWithWebIdentityCommand: () => ik1,
    AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => DoQ,
    AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => HoQ,
    ClientInputEndpointParameters: () => kv8.ClientInputEndpointParameters,
    CredentialsFilterSensitiveLog: () => ck1,
    ExpiredTokenException: () => JoQ,
    IDPCommunicationErrorException: () => CoQ,
    IDPRejectedClaimException: () => FoQ,
    InvalidIdentityTokenException: () => KoQ,
    MalformedPolicyDocumentException: () => WoQ,
    PackedPolicyTooLargeException: () => XoQ,
    RegionDisabledException: () => VoQ,
    STS: () => RoQ,
    STSServiceException: () => qb,
    decorateDefaultCredentialProvider: () => vv8,
    getDefaultRoleAssumer: () => koQ,
    getDefaultRoleAssumerWithWebIdentity: () => yoQ
  });
  nk1.exports = ux8(dk1);
  gx8(dk1, zEA(), nk1.exports);
  var mx8 = LJ(),
    dx8 = q5(),
    cx8 = GZ(),
    px8 = LJ(),
    lx8 = UEA(),
    IoQ = LJ(),
    ix8 = LJ(),
    qb = class A extends ix8.ServiceException {
      static {
        x2(this, "STSServiceException")
      }
      constructor(Q) {
        super(Q);
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    ck1 = x2((A) => ({
      ...A,
      ...A.SecretAccessKey && {
        SecretAccessKey: IoQ.SENSITIVE_STRING
      }
    }), "CredentialsFilterSensitiveLog"),
    YoQ = x2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ck1(A.Credentials)
      }
    }), "AssumeRoleResponseFilterSensitiveLog"),
    JoQ = class A extends qb {
      static {
        x2(this, "ExpiredTokenException")
      }
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    WoQ = class A extends qb {
      static {
        x2(this, "MalformedPolicyDocumentException")
      }
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    XoQ = class A extends qb {
      static {
        x2(this, "PackedPolicyTooLargeException")
      }
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    VoQ = class A extends qb {
      static {
        x2(this, "RegionDisabledException")
      }
      name = "RegionDisabledException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    FoQ = class A extends qb {
      static {
        x2(this, "IDPRejectedClaimException")
      }
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    KoQ = class A extends qb {
      static {
        x2(this, "InvalidIdentityTokenException")
      }
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    DoQ = x2((A) => ({
      ...A,
      ...A.WebIdentityToken && {
        WebIdentityToken: IoQ.SENSITIVE_STRING
      }
    }), "AssumeRoleWithWebIdentityRequestFilterSensitiveLog"),
    HoQ = x2((A) => ({
      ...A,
      ...A.Credentials && {
        Credentials: ck1(A.Credentials)
      }
    }), "AssumeRoleWithWebIdentityResponseFilterSensitiveLog"),
    CoQ = class A extends qb {
      static {
        x2(this, "IDPCommunicationErrorException")
      }
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(Q) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...Q
        });
        Object.setPrototypeOf(this, A.prototype)
      }
    },
    pk1 = jF(),
    nx8 = PpA(),
    O7 = LJ(),
    ax8 = x2(async (A, Q) => {
      let B = qoQ,
        G;
      return G = OoQ({
        ...Iv8(A, Q),
        [LoQ]: Lv8,
        [MoQ]: NoQ
      }), woQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleCommand"),
    sx8 = x2(async (A, Q) => {
      let B = qoQ,
        G;
      return G = OoQ({
        ...Yv8(A, Q),
        [LoQ]: Mv8,
        [MoQ]: NoQ
      }), woQ(Q, B, "/", void 0, G)
    }, "se_AssumeRoleWithWebIdentityCommand"),
    rx8 = x2(async (A, Q) => {
      if (A.statusCode >= 300) return EoQ(A, Q);
      let B = await (0, pk1.parseXmlBody)(A.body, Q),
        G = {};
      return G = Dv8(B.AssumeRoleResult, Q), {
        $metadata: Nb(A),
        ...G
      }
    }, "de_AssumeRoleCommand"),
    ox8 = x2(async (A, Q) => {
      if (A.statusCode >= 300) return EoQ(A, Q);
      let B = await (0, pk1.parseXmlBody)(A.body, Q),
        G = {};
      return G = Hv8(B.AssumeRoleWithWebIdentityResult, Q), {
        $metadata: Nb(A),
        ...G
      }
    }, "de_AssumeRoleWithWebIdentityCommand"),
    EoQ = x2(async (A, Q) => {
      let B = {
          ...A,
          body: await (0, pk1.parseXmlErrorBody)(A.body, Q)
        },
        G = Ov8(A, B.body);
      switch (G) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
          throw await tx8(B, Q);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
          throw await Bv8(B, Q);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
          throw await Gv8(B, Q);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
          throw await Zv8(B, Q);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
          throw await ex8(B, Q);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
          throw await Av8(B, Q);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
          throw await Qv8(B, Q);
        default:
          let Z = B.body;
          return Nv8({
            output: A,
            parsedBody: Z.Error,
            errorCode: G
          })
      }
    }, "de_CommandError"),
    tx8 = x2(async (A, Q) => {
      let B = A.body,
        G = Cv8(B.Error, Q),
        Z = new JoQ({
          $metadata: Nb(A),
          ...G
        });
      return (0, O7.decorateServiceException)(Z, B)
    }, "de_ExpiredTokenExceptionRes"),
    ex8 = x2(async (A, Q) => {
      let B = A.body,
        G = Ev8(B.Error, Q),
        Z = new CoQ({
          $metadata: Nb(A),
          ...G
        });
      return (0, O7.decorateServiceException)(Z, B)
    }, "de_IDPCommunicationErrorExceptionRes"),
    Av8 = x2(async (A, Q) => {
      let B = A.body,
        G = zv8(B.Error, Q),
        Z = new FoQ({
          $metadata: Nb(A),
          ...G
        });
      return (0, O7.decorateServiceException)(Z, B)
    }, "de_IDPRejectedClaimExceptionRes"),
    Qv8 = x2(async (A, Q) => {
      let B = A.body,
        G = Uv8(B.Error, Q),
        Z = new KoQ({
          $metadata: Nb(A),
          ...G
        });
      return (0, O7.decorateServiceException)(Z, B)
    }, "de_InvalidIdentityTokenExceptionRes"),
    Bv8 = x2(async (A, Q) => {
      let B = A.body,
        G = $v8(B.Error, Q),
        Z = new WoQ({
          $metadata: Nb(A),
          ...G
        });
      return (0, O7.decorateServiceException)(Z, B)
    }, "de_MalformedPolicyDocumentExceptionRes"),
    Gv8 = x2(async (A, Q) => {
      let B = A.body,
        G = wv8(B.Error, Q),
        Z = new XoQ({
          $metadata: Nb(A),
          ...G
        });
      return (0, O7.decorateServiceException)(Z, B)
    }, "de_PackedPolicyTooLargeExceptionRes"),
    Zv8 = x2(async (A, Q) => {
      let B = A.body,
        G = qv8(B.Error, Q),
        Z = new VoQ({
          $metadata: Nb(A),
          ...G
        });
      return (0, O7.decorateServiceException)(Z, B)
    }, "de_RegionDisabledExceptionRes"),
    Iv8 = x2((A, Q) => {
      let B = {};
      if (A[h5A] != null) B[h5A] = A[h5A];
      if (A[g5A] != null) B[g5A] = A[g5A];
      if (A[b5A] != null) {
        let G = zoQ(A[b5A], Q);
        if (A[b5A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[v5A] != null) B[v5A] = A[v5A];
      if (A[x5A] != null) B[x5A] = A[x5A];
      if (A[xk1] != null) {
        let G = Kv8(A[xk1], Q);
        if (A[xk1]?.length === 0) B.Tags = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `Tags.${Z}`;
          B[Y] = I
        })
      }
      if (A[bk1] != null) {
        let G = Fv8(A[bk1], Q);
        if (A[bk1]?.length === 0) B.TransitiveTagKeys = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `TransitiveTagKeys.${Z}`;
          B[Y] = I
        })
      }
      if (A[Mk1] != null) B[Mk1] = A[Mk1];
      if (A[kk1] != null) B[kk1] = A[kk1];
      if (A[vk1] != null) B[vk1] = A[vk1];
      if (A[wb] != null) B[wb] = A[wb];
      if (A[Tk1] != null) {
        let G = Xv8(A[Tk1], Q);
        if (A[Tk1]?.length === 0) B.ProvidedContexts = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `ProvidedContexts.${Z}`;
          B[Y] = I
        })
      }
      return B
    }, "se_AssumeRoleRequest"),
    Yv8 = x2((A, Q) => {
      let B = {};
      if (A[h5A] != null) B[h5A] = A[h5A];
      if (A[g5A] != null) B[g5A] = A[g5A];
      if (A[hk1] != null) B[hk1] = A[hk1];
      if (A[Pk1] != null) B[Pk1] = A[Pk1];
      if (A[b5A] != null) {
        let G = zoQ(A[b5A], Q);
        if (A[b5A]?.length === 0) B.PolicyArns = [];
        Object.entries(G).forEach(([Z, I]) => {
          let Y = `PolicyArns.${Z}`;
          B[Y] = I
        })
      }
      if (A[v5A] != null) B[v5A] = A[v5A];
      if (A[x5A] != null) B[x5A] = A[x5A];
      return B
    }, "se_AssumeRoleWithWebIdentityRequest"),
    zoQ = x2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = Jv8(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_policyDescriptorListType"),
    Jv8 = x2((A, Q) => {
      let B = {};
      if (A[gk1] != null) B[gk1] = A[gk1];
      return B
    }, "se_PolicyDescriptorType"),
    Wv8 = x2((A, Q) => {
      let B = {};
      if (A[Rk1] != null) B[Rk1] = A[Rk1];
      if (A[Nk1] != null) B[Nk1] = A[Nk1];
      return B
    }, "se_ProvidedContext"),
    Xv8 = x2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = Wv8(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_ProvidedContextsListType"),
    Vv8 = x2((A, Q) => {
      let B = {};
      if (A[Ok1] != null) B[Ok1] = A[Ok1];
      if (A[fk1] != null) B[fk1] = A[fk1];
      return B
    }, "se_Tag"),
    Fv8 = x2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        B[`member.${G}`] = Z, G++
      }
      return B
    }, "se_tagKeyListType"),
    Kv8 = x2((A, Q) => {
      let B = {},
        G = 1;
      for (let Z of A) {
        if (Z === null) continue;
        let I = Vv8(Z, Q);
        Object.entries(I).forEach(([Y, J]) => {
          B[`member.${G}.${Y}`] = J
        }), G++
      }
      return B
    }, "se_tagListType"),
    UoQ = x2((A, Q) => {
      let B = {};
      if (A[$k1] != null) B[$k1] = (0, O7.expectString)(A[$k1]);
      if (A[wk1] != null) B[wk1] = (0, O7.expectString)(A[wk1]);
      return B
    }, "de_AssumedRoleUser"),
    Dv8 = x2((A, Q) => {
      let B = {};
      if (A[y5A] != null) B[y5A] = $oQ(A[y5A], Q);
      if (A[k5A] != null) B[k5A] = UoQ(A[k5A], Q);
      if (A[f5A] != null) B[f5A] = (0, O7.strictParseInt32)(A[f5A]);
      if (A[wb] != null) B[wb] = (0, O7.expectString)(A[wb]);
      return B
    }, "de_AssumeRoleResponse"),
    Hv8 = x2((A, Q) => {
      let B = {};
      if (A[y5A] != null) B[y5A] = $oQ(A[y5A], Q);
      if (A[_k1] != null) B[_k1] = (0, O7.expectString)(A[_k1]);
      if (A[k5A] != null) B[k5A] = UoQ(A[k5A], Q);
      if (A[f5A] != null) B[f5A] = (0, O7.strictParseInt32)(A[f5A]);
      if (A[jk1] != null) B[jk1] = (0, O7.expectString)(A[jk1]);
      if (A[qk1] != null) B[qk1] = (0, O7.expectString)(A[qk1]);
      if (A[wb] != null) B[wb] = (0, O7.expectString)(A[wb]);
      return B
    }, "de_AssumeRoleWithWebIdentityResponse"),
    $oQ = x2((A, Q) => {
      let B = {};
      if (A[Uk1] != null) B[Uk1] = (0, O7.expectString)(A[Uk1]);
      if (A[Sk1] != null) B[Sk1] = (0, O7.expectString)(A[Sk1]);
      if (A[yk1] != null) B[yk1] = (0, O7.expectString)(A[yk1]);
      if (A[Lk1] != null) B[Lk1] = (0, O7.expectNonNull)((0, O7.parseRfc3339DateTimeWithOffset)(A[Lk1]));
      return B
    }, "de_Credentials"),
    Cv8 = x2((A, Q) => {
      let B = {};
      if (A[qW] != null) B[qW] = (0, O7.expectString)(A[qW]);
      return B
    }, "de_ExpiredTokenException"),
    Ev8 = x2((A, Q) => {
      let B = {};
      if (A[qW] != null) B[qW] = (0, O7.expectString)(A[qW]);
      return B
    }, "de_IDPCommunicationErrorException"),
    zv8 = x2((A, Q) => {
      let B = {};
      if (A[qW] != null) B[qW] = (0, O7.expectString)(A[qW]);
      return B
    }, "de_IDPRejectedClaimException"),
    Uv8 = x2((A, Q) => {
      let B = {};
      if (A[qW] != null) B[qW] = (0, O7.expectString)(A[qW]);
      return B
    }, "de_InvalidIdentityTokenException"),
    $v8 = x2((A, Q) => {
      let B = {};
      if (A[qW] != null) B[qW] = (0, O7.expectString)(A[qW]);
      return B
    }, "de_MalformedPolicyDocumentException"),
    wv8 = x2((A, Q) => {
      let B = {};
      if (A[qW] != null) B[qW] = (0, O7.expectString)(A[qW]);
      return B
    }, "de_PackedPolicyTooLargeException"),
    qv8 = x2((A, Q) => {
      let B = {};
      if (A[qW] != null) B[qW] = (0, O7.expectString)(A[qW]);
      return B
    }, "de_RegionDisabledException"),
    Nb = x2((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    Nv8 = (0, O7.withBaseException)(qb),
    woQ = x2(async (A, Q, B, G, Z) => {
      let {
        hostname: I,
        protocol: Y = "https",
        port: J,
        path: W
      } = await A.endpoint(), X = {
        protocol: Y,
        hostname: I,
        port: J,
        method: "POST",
        path: W.endsWith("/") ? W.slice(0, -1) + B : W + B,
        headers: Q
      };
      if (G !== void 0) X.hostname = G;
      if (Z !== void 0) X.body = Z;
      return new nx8.HttpRequest(X)
    }, "buildHttpRpcRequest"),
    qoQ = {
      "content-type": "application/x-www-form-urlencoded"
    },
    NoQ = "2011-06-15",
    LoQ = "Action",
    Uk1 = "AccessKeyId",
    Lv8 = "AssumeRole",
    $k1 = "AssumedRoleId",
    k5A = "AssumedRoleUser",
    Mv8 = "AssumeRoleWithWebIdentity",
    wk1 = "Arn",
    qk1 = "Audience",
    y5A = "Credentials",
    Nk1 = "ContextAssertion",
    x5A = "DurationSeconds",
    Lk1 = "Expiration",
    Mk1 = "ExternalId",
    Ok1 = "Key",
    v5A = "Policy",
    b5A = "PolicyArns",
    Rk1 = "ProviderArn",
    Tk1 = "ProvidedContexts",
    Pk1 = "ProviderId",
    f5A = "PackedPolicySize",
    jk1 = "Provider",
    h5A = "RoleArn",
    g5A = "RoleSessionName",
    Sk1 = "SecretAccessKey",
    _k1 = "SubjectFromWebIdentityToken",
    wb = "SourceIdentity",
    kk1 = "SerialNumber",
    yk1 = "SessionToken",
    xk1 = "Tags",
    vk1 = "TokenCode",
    bk1 = "TransitiveTagKeys",
    MoQ = "Version",
    fk1 = "Value",
    hk1 = "WebIdentityToken",
    gk1 = "arn",
    qW = "message",
    OoQ = x2((A) => Object.entries(A).map(([Q, B]) => (0, O7.extendedEncodeURIComponent)(Q) + "=" + (0, O7.extendedEncodeURIComponent)(B)).join("&"), "buildFormUrlencodedString"),
    Ov8 = x2((A, Q) => {
      if (Q.Error?.Code !== void 0) return Q.Error.Code;
      if (A.statusCode == 404) return "NotFound"
    }, "loadQueryErrorCode"),
    lk1 = class extends px8.Command.classBuilder().ep(lx8.commonParams).m(function(A, Q, B, G) {
      return [(0, cx8.getSerdePlugin)(B, this.serialize, this.deserialize), (0, dx8.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(void 0, YoQ).ser(ax8).de(rx8).build() {
      static {
        x2(this, "AssumeRoleCommand")
      }
    },
    Rv8 = q5(),
    Tv8 = GZ(),
    Pv8 = LJ(),
    jv8 = UEA(),
    ik1 = class extends Pv8.Command.classBuilder().ep(jv8.commonParams).m(function(A, Q, B, G) {
      return [(0, Tv8.getSerdePlugin)(B, this.serialize, this.deserialize), (0, Rv8.getEndpointPlugin)(B, A.getEndpointParameterInstructions())]
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(DoQ, HoQ).ser(sx8).de(ox8).build() {
      static {
        x2(this, "AssumeRoleWithWebIdentityCommand")
      }
    },
    Sv8 = zEA(),
    _v8 = {
      AssumeRoleCommand: lk1,
      AssumeRoleWithWebIdentityCommand: ik1
    },
    RoQ = class extends Sv8.STSClient {
      static {
        x2(this, "STS")
      }
    };
  (0, mx8.createAggregatedClient)(_v8, RoQ);
  var kv8 = UEA(),
    mk1 = rS(),
    ZoQ = "us-east-1",
    ToQ = x2((A) => {
      if (typeof A?.Arn === "string") {
        let Q = A.Arn.split(":");
        if (Q.length > 4 && Q[4] !== "") return Q[4]
      }
      return
    }, "getAccountIdFromAssumedRoleUser"),
    PoQ = x2(async (A, Q, B) => {
      let G = typeof A === "function" ? await A() : A,
        Z = typeof Q === "function" ? await Q() : Q;
      return B?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${G} (provider)`, `${Z} (parent client)`, `${ZoQ} (STS default)`), G ?? Z ?? ZoQ
    }, "resolveRegion"),
    yv8 = x2((A, Q) => {
      let B, G;
      return async (Z, I) => {
        if (G = Z, !B) {
          let {
            logger: V = A?.parentClientConfig?.logger,
            region: F,
            requestHandler: K = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: D
          } = A, H = await PoQ(F, A?.parentClientConfig?.region, D), C = !joQ(K);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            credentialDefaultProvider: x2(() => async () => G, "credentialDefaultProvider"),
            region: H,
            requestHandler: C ? K : void 0,
            logger: V
          })
        }
        let {
          Credentials: Y,
          AssumedRoleUser: J
        } = await B.send(new lk1(I));
        if (!Y || !Y.AccessKeyId || !Y.SecretAccessKey) throw Error(`Invalid response from STS.assumeRole call with role ${I.RoleArn}`);
        let W = ToQ(J),
          X = {
            accessKeyId: Y.AccessKeyId,
            secretAccessKey: Y.SecretAccessKey,
            sessionToken: Y.SessionToken,
            expiration: Y.Expiration,
            ...Y.CredentialScope && {
              credentialScope: Y.CredentialScope
            },
            ...W && {
              accountId: W
            }
          };
        return (0, mk1.setCredentialFeature)(X, "CREDENTIALS_STS_ASSUME_ROLE", "i"), X
      }
    }, "getDefaultRoleAssumer"),
    xv8 = x2((A, Q) => {
      let B;
      return async (G) => {
        if (!B) {
          let {
            logger: W = A?.parentClientConfig?.logger,
            region: X,
            requestHandler: V = A?.parentClientConfig?.requestHandler,
            credentialProviderLogger: F
          } = A, K = await PoQ(X, A?.parentClientConfig?.region, F), D = !joQ(V);
          B = new Q({
            profile: A?.parentClientConfig?.profile,
            region: K,
            requestHandler: D ? V : void 0,
            logger: W
          })
        }
        let {
          Credentials: Z,
          AssumedRoleUser: I
        } = await B.send(new ik1(G));
        if (!Z || !Z.AccessKeyId || !Z.SecretAccessKey) throw Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${G.RoleArn}`);
        let Y = ToQ(I),
          J = {
            accessKeyId: Z.AccessKeyId,
            secretAccessKey: Z.SecretAccessKey,
            sessionToken: Z.SessionToken,
            expiration: Z.Expiration,
            ...Z.CredentialScope && {
              credentialScope: Z.CredentialScope
            },
            ...Y && {
              accountId: Y
            }
          };
        if (Y)(0, mk1.setCredentialFeature)(J, "RESOLVED_ACCOUNT_ID", "T");
        return (0, mk1.setCredentialFeature)(J, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"), J
      }
    }, "getDefaultRoleAssumerWithWebIdentity"),
    joQ = x2((A) => {
      return A?.metadata?.handlerProtocol === "h2"
    }, "isH2"),
    SoQ = zEA(),
    _oQ = x2((A, Q) => {
      if (!Q) return A;
      else return class extends A {
        static {
          x2(this, "CustomizableSTSClient")
        }
        constructor(G) {
          super(G);
          for (let Z of Q) this.middlewareStack.use(Z)
        }
      }
    }, "getCustomizableStsClientCtor"),
    koQ = x2((A = {}, Q) => yv8(A, _oQ(SoQ.STSClient, Q)), "getDefaultRoleAssumer"),
    yoQ = x2((A = {}, Q) => xv8(A, _oQ(SoQ.STSClient, Q)), "getDefaultRoleAssumerWithWebIdentity"),
    vv8 = x2((A) => (Q) => A({
      roleAssumer: koQ(Q),
      roleAssumerWithWebIdentity: yoQ(Q),
      ...Q
    }), "decorateDefaultCredentialProvider")
})
// @from(Start 4541340, End 4544582)
ok1 = z((vj7, boQ) => {
  var {
    defineProperty: vpA,
    getOwnPropertyDescriptor: bv8,
    getOwnPropertyNames: fv8
  } = Object, hv8 = Object.prototype.hasOwnProperty, rk1 = (A, Q) => vpA(A, "name", {
    value: Q,
    configurable: !0
  }), gv8 = (A, Q) => {
    for (var B in Q) vpA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, uv8 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of fv8(Q))
        if (!hv8.call(A, Z) && Z !== B) vpA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = bv8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, mv8 = (A) => uv8(vpA({}, "__esModule", {
    value: !0
  }), A), voQ = {};
  gv8(voQ, {
    fromProcess: () => nv8
  });
  boQ.exports = mv8(voQ);
  var xoQ = SG(),
    sk1 = j2(),
    dv8 = UA("child_process"),
    cv8 = UA("util"),
    pv8 = rS(),
    lv8 = rk1((A, Q, B) => {
      if (Q.Version !== 1) throw Error(`Profile ${A} credential_process did not return Version 1.`);
      if (Q.AccessKeyId === void 0 || Q.SecretAccessKey === void 0) throw Error(`Profile ${A} credential_process returned invalid credentials.`);
      if (Q.Expiration) {
        let I = new Date;
        if (new Date(Q.Expiration) < I) throw Error(`Profile ${A} credential_process returned expired credentials.`)
      }
      let G = Q.AccountId;
      if (!G && B?.[A]?.aws_account_id) G = B[A].aws_account_id;
      let Z = {
        accessKeyId: Q.AccessKeyId,
        secretAccessKey: Q.SecretAccessKey,
        ...Q.SessionToken && {
          sessionToken: Q.SessionToken
        },
        ...Q.Expiration && {
          expiration: new Date(Q.Expiration)
        },
        ...Q.CredentialScope && {
          credentialScope: Q.CredentialScope
        },
        ...G && {
          accountId: G
        }
      };
      return (0, pv8.setCredentialFeature)(Z, "CREDENTIALS_PROCESS", "w"), Z
    }, "getValidatedProcessCredentials"),
    iv8 = rk1(async (A, Q, B) => {
      let G = Q[A];
      if (Q[A]) {
        let Z = G.credential_process;
        if (Z !== void 0) {
          let I = (0, cv8.promisify)(dv8.exec);
          try {
            let {
              stdout: Y
            } = await I(Z), J;
            try {
              J = JSON.parse(Y.trim())
            } catch {
              throw Error(`Profile ${A} credential_process returned invalid JSON.`)
            }
            return lv8(A, J, Q)
          } catch (Y) {
            throw new sk1.CredentialsProviderError(Y.message, {
              logger: B
            })
          }
        } else throw new sk1.CredentialsProviderError(`Profile ${A} did not contain credential_process.`, {
          logger: B
        })
      } else throw new sk1.CredentialsProviderError(`Profile ${A} could not be found in shared credentials file.`, {
        logger: B
      })
    }, "resolveProcessCredentials"),
    nv8 = rk1((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      A.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
      let B = await (0, xoQ.parseKnownFiles)(A);
      return iv8((0, xoQ.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), B, A.logger)
    }, "fromProcess")
})
// @from(Start 4544588, End 4546613)
tk1 = z((Z_) => {
  var av8 = Z_ && Z_.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    sv8 = Z_ && Z_.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    rv8 = Z_ && Z_.__importStar || function(A) {
      if (A && A.__esModule) return A;
      var Q = {};
      if (A != null) {
        for (var B in A)
          if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B)) av8(Q, A, B)
      }
      return sv8(Q, A), Q
    };
  Object.defineProperty(Z_, "__esModule", {
    value: !0
  });
  Z_.fromWebToken = void 0;
  var ov8 = (A) => async (Q) => {
    A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
    let {
      roleArn: B,
      roleSessionName: G,
      webIdentityToken: Z,
      providerId: I,
      policyArns: Y,
      policy: J,
      durationSeconds: W
    } = A, {
      roleAssumerWithWebIdentity: X
    } = A;
    if (!X) {
      let {
        getDefaultRoleAssumerWithWebIdentity: V
      } = await Promise.resolve().then(() => rv8(ak1()));
      X = V({
        ...A.clientConfig,
        credentialProviderLogger: A.logger,
        parentClientConfig: {
          ...Q?.callerClientConfig,
          ...A.parentClientConfig
        }
      }, A.clientPlugins)
    }
    return X({
      RoleArn: B,
      RoleSessionName: G ?? `aws-sdk-js-session-${Date.now()}`,
      WebIdentityToken: Z,
      ProviderId: I,
      PolicyArns: Y,
      Policy: J,
      DurationSeconds: W
    })
  };
  Z_.fromWebToken = ov8
})
// @from(Start 4546619, End 4547694)
uoQ = z((hoQ) => {
  Object.defineProperty(hoQ, "__esModule", {
    value: !0
  });
  hoQ.fromTokenFile = void 0;
  var tv8 = rS(),
    ev8 = j2(),
    Ab8 = UA("fs"),
    Qb8 = tk1(),
    foQ = "AWS_WEB_IDENTITY_TOKEN_FILE",
    Bb8 = "AWS_ROLE_ARN",
    Gb8 = "AWS_ROLE_SESSION_NAME",
    Zb8 = (A = {}) => async () => {
      A.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
      let Q = A?.webIdentityTokenFile ?? process.env[foQ],
        B = A?.roleArn ?? process.env[Bb8],
        G = A?.roleSessionName ?? process.env[Gb8];
      if (!Q || !B) throw new ev8.CredentialsProviderError("Web identity configuration not specified", {
        logger: A.logger
      });
      let Z = await (0, Qb8.fromWebToken)({
        ...A,
        webIdentityToken: (0, Ab8.readFileSync)(Q, {
          encoding: "ascii"
        }),
        roleArn: B,
        roleSessionName: G
      })();
      if (Q === process.env[foQ])(0, tv8.setCredentialFeature)(Z, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
      return Z
    };
  hoQ.fromTokenFile = Zb8
})
// @from(Start 4547700, End 4548396)
Qy1 = z((hj7, bpA) => {
  var {
    defineProperty: moQ,
    getOwnPropertyDescriptor: Ib8,
    getOwnPropertyNames: Yb8
  } = Object, Jb8 = Object.prototype.hasOwnProperty, ek1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Yb8(Q))
        if (!Jb8.call(A, Z) && Z !== B) moQ(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Ib8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, doQ = (A, Q, B) => (ek1(A, Q, "default"), B && ek1(B, Q, "default")), Wb8 = (A) => ek1(moQ({}, "__esModule", {
    value: !0
  }), A), Ay1 = {};
  bpA.exports = Wb8(Ay1);
  doQ(Ay1, uoQ(), bpA.exports);
  doQ(Ay1, tk1(), bpA.exports)
})
// @from(Start 4548402, End 4558124)
roQ = z((gj7, soQ) => {
  var {
    create: Xb8,
    defineProperty: wEA,
    getOwnPropertyDescriptor: Vb8,
    getOwnPropertyNames: Fb8,
    getPrototypeOf: Kb8
  } = Object, Db8 = Object.prototype.hasOwnProperty, xX = (A, Q) => wEA(A, "name", {
    value: Q,
    configurable: !0
  }), Hb8 = (A, Q) => {
    for (var B in Q) wEA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ioQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Fb8(Q))
        if (!Db8.call(A, Z) && Z !== B) wEA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Vb8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Vc = (A, Q, B) => (B = A != null ? Xb8(Kb8(A)) : {}, ioQ(Q || !A || !A.__esModule ? wEA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), Cb8 = (A) => ioQ(wEA({}, "__esModule", {
    value: !0
  }), A), noQ = {};
  Hb8(noQ, {
    fromIni: () => Tb8
  });
  soQ.exports = Cb8(noQ);
  var Gy1 = SG(),
    Fc = rS(),
    $EA = j2(),
    Eb8 = xX((A, Q, B) => {
      let G = {
        EcsContainer: xX(async (Z) => {
          let {
            fromHttp: I
          } = await Promise.resolve().then(() => Vc(_S1())), {
            fromContainerMetadata: Y
          } = await Promise.resolve().then(() => Vc(OV()));
          return B?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"), async () => (0, $EA.chain)(I(Z ?? {}), Y(Z))().then(By1)
        }, "EcsContainer"),
        Ec2InstanceMetadata: xX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
          let {
            fromInstanceMetadata: I
          } = await Promise.resolve().then(() => Vc(OV()));
          return async () => I(Z)().then(By1)
        }, "Ec2InstanceMetadata"),
        Environment: xX(async (Z) => {
          B?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
          let {
            fromEnv: I
          } = await Promise.resolve().then(() => Vc(HS1()));
          return async () => I(Z)().then(By1)
        }, "Environment")
      };
      if (A in G) return G[A];
      else throw new $EA.CredentialsProviderError(`Unsupported credential source in profile ${Q}. Got ${A}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, {
        logger: B
      })
    }, "resolveCredentialSource"),
    By1 = xX((A) => (0, Fc.setCredentialFeature)(A, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"), "setNamedProvider"),
    zb8 = xX((A, {
      profile: Q = "default",
      logger: B
    } = {}) => {
      return Boolean(A) && typeof A === "object" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof A.external_id) > -1 && ["undefined", "string"].indexOf(typeof A.mfa_serial) > -1 && (Ub8(A, {
        profile: Q,
        logger: B
      }) || $b8(A, {
        profile: Q,
        logger: B
      }))
    }, "isAssumeRoleProfile"),
    Ub8 = xX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.source_profile === "string" && typeof A.credential_source > "u";
      if (G) B?.debug?.(`    ${Q} isAssumeRoleWithSourceProfile source_profile=${A.source_profile}`);
      return G
    }, "isAssumeRoleWithSourceProfile"),
    $b8 = xX((A, {
      profile: Q,
      logger: B
    }) => {
      let G = typeof A.credential_source === "string" && typeof A.source_profile > "u";
      if (G) B?.debug?.(`    ${Q} isCredentialSourceProfile credential_source=${A.credential_source}`);
      return G
    }, "isCredentialSourceProfile"),
    wb8 = xX(async (A, Q, B, G = {}) => {
      B.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
      let Z = Q[A],
        {
          source_profile: I,
          region: Y
        } = Z;
      if (!B.roleAssumer) {
        let {
          getDefaultRoleAssumer: W
        } = await Promise.resolve().then(() => Vc(ak1()));
        B.roleAssumer = W({
          ...B.clientConfig,
          credentialProviderLogger: B.logger,
          parentClientConfig: {
            ...B?.parentClientConfig,
            region: Y ?? B?.parentClientConfig?.region
          }
        }, B.clientPlugins)
      }
      if (I && I in G) throw new $EA.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${(0,Gy1.getProfileName)(B)}. Profiles visited: ` + Object.keys(G).join(", "), {
        logger: B.logger
      });
      B.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${I?`source_profile=[${I}]`:`profile=[${A}]`}`);
      let J = I ? aoQ(I, Q, B, {
        ...G,
        [I]: !0
      }, coQ(Q[I] ?? {})) : (await Eb8(Z.credential_source, A, B.logger)(B))();
      if (coQ(Z)) return J.then((W) => (0, Fc.setCredentialFeature)(W, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      else {
        let W = {
            RoleArn: Z.role_arn,
            RoleSessionName: Z.role_session_name || `aws-sdk-js-${Date.now()}`,
            ExternalId: Z.external_id,
            DurationSeconds: parseInt(Z.duration_seconds || "3600", 10)
          },
          {
            mfa_serial: X
          } = Z;
        if (X) {
          if (!B.mfaCodeProvider) throw new $EA.CredentialsProviderError(`Profile ${A} requires multi-factor authentication, but no MFA code callback was provided.`, {
            logger: B.logger,
            tryNextLink: !1
          });
          W.SerialNumber = X, W.TokenCode = await B.mfaCodeProvider(X)
        }
        let V = await J;
        return B.roleAssumer(V, W).then((F) => (0, Fc.setCredentialFeature)(F, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"))
      }
    }, "resolveAssumeRoleCredentials"),
    coQ = xX((A) => {
      return !A.role_arn && !!A.credential_source
    }, "isCredentialSourceWithoutRoleArn"),
    qb8 = xX((A) => Boolean(A) && typeof A === "object" && typeof A.credential_process === "string", "isProcessProfile"),
    Nb8 = xX(async (A, Q) => Promise.resolve().then(() => Vc(ok1())).then(({
      fromProcess: B
    }) => B({
      ...A,
      profile: Q
    })().then((G) => (0, Fc.setCredentialFeature)(G, "CREDENTIALS_PROFILE_PROCESS", "v"))), "resolveProcessCredentials"),
    Lb8 = xX(async (A, Q, B = {}) => {
      let {
        fromSSO: G
      } = await Promise.resolve().then(() => Vc(Xk1()));
      return G({
        profile: A,
        logger: B.logger,
        parentClientConfig: B.parentClientConfig,
        clientConfig: B.clientConfig
      })().then((Z) => {
        if (Q.sso_session) return (0, Fc.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO", "r");
        else return (0, Fc.setCredentialFeature)(Z, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      })
    }, "resolveSsoCredentials"),
    Mb8 = xX((A) => A && (typeof A.sso_start_url === "string" || typeof A.sso_account_id === "string" || typeof A.sso_session === "string" || typeof A.sso_region === "string" || typeof A.sso_role_name === "string"), "isSsoProfile"),
    poQ = xX((A) => Boolean(A) && typeof A === "object" && typeof A.aws_access_key_id === "string" && typeof A.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof A.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof A.aws_account_id) > -1, "isStaticCredsProfile"),
    loQ = xX(async (A, Q) => {
      Q?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
      let B = {
        accessKeyId: A.aws_access_key_id,
        secretAccessKey: A.aws_secret_access_key,
        sessionToken: A.aws_session_token,
        ...A.aws_credential_scope && {
          credentialScope: A.aws_credential_scope
        },
        ...A.aws_account_id && {
          accountId: A.aws_account_id
        }
      };
      return (0, Fc.setCredentialFeature)(B, "CREDENTIALS_PROFILE", "n")
    }, "resolveStaticCredentials"),
    Ob8 = xX((A) => Boolean(A) && typeof A === "object" && typeof A.web_identity_token_file === "string" && typeof A.role_arn === "string" && ["undefined", "string"].indexOf(typeof A.role_session_name) > -1, "isWebIdentityProfile"),
    Rb8 = xX(async (A, Q) => Promise.resolve().then(() => Vc(Qy1())).then(({
      fromTokenFile: B
    }) => B({
      webIdentityTokenFile: A.web_identity_token_file,
      roleArn: A.role_arn,
      roleSessionName: A.role_session_name,
      roleAssumerWithWebIdentity: Q.roleAssumerWithWebIdentity,
      logger: Q.logger,
      parentClientConfig: Q.parentClientConfig
    })().then((G) => (0, Fc.setCredentialFeature)(G, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))), "resolveWebIdentityCredentials"),
    aoQ = xX(async (A, Q, B, G = {}, Z = !1) => {
      let I = Q[A];
      if (Object.keys(G).length > 0 && poQ(I)) return loQ(I, B);
      if (Z || zb8(I, {
          profile: A,
          logger: B.logger
        })) return wb8(A, Q, B, G);
      if (poQ(I)) return loQ(I, B);
      if (Ob8(I)) return Rb8(I, B);
      if (qb8(I)) return Nb8(B, A);
      if (Mb8(I)) return await Lb8(A, I, B);
      throw new $EA.CredentialsProviderError(`Could not resolve credentials using profile: [${A}] in configuration/credentials file(s).`, {
        logger: B.logger
      })
    }, "resolveProfileData"),
    Tb8 = xX((A = {}) => async ({
      callerClientConfig: Q
    } = {}) => {
      let B = {
        ...A,
        parentClientConfig: {
          ...Q,
          ...A.parentClientConfig
        }
      };
      B.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
      let G = await (0, Gy1.parseKnownFiles)(B);
      return aoQ((0, Gy1.getProfileName)({
        profile: A.profile ?? Q?.profile
      }), G, B)
    }, "fromIni")
})
// @from(Start 4558130, End 4563092)
Iy1 = z((uj7, GtQ) => {
  var {
    create: Pb8,
    defineProperty: qEA,
    getOwnPropertyDescriptor: jb8,
    getOwnPropertyNames: Sb8,
    getPrototypeOf: _b8
  } = Object, kb8 = Object.prototype.hasOwnProperty, fpA = (A, Q) => qEA(A, "name", {
    value: Q,
    configurable: !0
  }), yb8 = (A, Q) => {
    for (var B in Q) qEA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, eoQ = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Sb8(Q))
        if (!kb8.call(A, Z) && Z !== B) qEA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = jb8(Q, Z)) || G.enumerable
        })
    }
    return A
  }, u5A = (A, Q, B) => (B = A != null ? Pb8(_b8(A)) : {}, eoQ(Q || !A || !A.__esModule ? qEA(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), xb8 = (A) => eoQ(qEA({}, "__esModule", {
    value: !0
  }), A), AtQ = {};
  yb8(AtQ, {
    credentialsTreatedAsExpired: () => BtQ,
    credentialsWillNeedRefresh: () => QtQ,
    defaultProvider: () => fb8
  });
  GtQ.exports = xb8(AtQ);
  var Zy1 = HS1(),
    vb8 = SG(),
    _o = j2(),
    ooQ = "AWS_EC2_METADATA_DISABLED",
    bb8 = fpA(async (A) => {
      let {
        ENV_CMDS_FULL_URI: Q,
        ENV_CMDS_RELATIVE_URI: B,
        fromContainerMetadata: G,
        fromInstanceMetadata: Z
      } = await Promise.resolve().then(() => u5A(OV()));
      if (process.env[B] || process.env[Q]) {
        A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        let {
          fromHttp: I
        } = await Promise.resolve().then(() => u5A(_S1()));
        return (0, _o.chain)(I(A), G(A))
      }
      if (process.env[ooQ] && process.env[ooQ] !== "false") return async () => {
        throw new _o.CredentialsProviderError("EC2 Instance Metadata Service access disabled", {
          logger: A.logger
        })
      };
      return A.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"), Z(A)
    }, "remoteProvider"),
    toQ = !1,
    fb8 = fpA((A = {}) => (0, _o.memoize)((0, _o.chain)(async () => {
      if (A.profile ?? process.env[vb8.ENV_PROFILE]) {
        if (process.env[Zy1.ENV_KEY] && process.env[Zy1.ENV_SECRET]) {
          if (!toQ)(A.logger?.warn && A.logger?.constructor?.name !== "NoOpLogger" ? A.logger.warn : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`), toQ = !0
        }
        throw new _o.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
          logger: A.logger,
          tryNextLink: !0
        })
      }
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv"), (0, Zy1.fromEnv)(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
      let {
        ssoStartUrl: Q,
        ssoAccountId: B,
        ssoRegion: G,
        ssoRoleName: Z,
        ssoSession: I
      } = A;
      if (!Q && !B && !G && !Z && !I) throw new _o.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", {
        logger: A.logger
      });
      let {
        fromSSO: Y
      } = await Promise.resolve().then(() => u5A(Xk1()));
      return Y(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
      let {
        fromIni: Q
      } = await Promise.resolve().then(() => u5A(roQ()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
      let {
        fromProcess: Q
      } = await Promise.resolve().then(() => u5A(ok1()));
      return Q(A)()
    }, async () => {
      A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
      let {
        fromTokenFile: Q
      } = await Promise.resolve().then(() => u5A(Qy1()));
      return Q(A)()
    }, async () => {
      return A.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"), (await bb8(A))()
    }, async () => {
      throw new _o.CredentialsProviderError("Could not load credentials from any providers", {
        tryNextLink: !1,
        logger: A.logger
      })
    }), BtQ, QtQ), "defaultProvider"),
    QtQ = fpA((A) => A?.expiration !== void 0, "credentialsWillNeedRefresh"),
    BtQ = fpA((A) => A?.expiration !== void 0 && A.expiration.getTime() - Date.now() < 300000, "credentialsTreatedAsExpired")
})
// @from(Start 4563098, End 4564913)
YtQ = z((AU) => {
  var hb8 = AU && AU.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    gb8 = AU && AU.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    ZtQ = AU && AU.__importStar || function(A) {
      if (A && A.__esModule) return A;
      var Q = {};
      if (A != null) {
        for (var B in A)
          if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B)) hb8(Q, A, B)
      }
      return gb8(Q, A), Q
    };
  Object.defineProperty(AU, "__esModule", {
    value: !0
  });
  AU.req = AU.json = AU.toBuffer = void 0;
  var ub8 = ZtQ(UA("http")),
    mb8 = ZtQ(UA("https"));
  async function ItQ(A) {
    let Q = 0,
      B = [];
    for await (let G of A) Q += G.length, B.push(G);
    return Buffer.concat(B, Q)
  }
  AU.toBuffer = ItQ;
  async function db8(A) {
    let B = (await ItQ(A)).toString("utf8");
    try {
      return JSON.parse(B)
    } catch (G) {
      let Z = G;
      throw Z.message += ` (input: ${B})`, Z
    }
  }
  AU.json = db8;

  function cb8(A, Q = {}) {
    let G = ((typeof A === "string" ? A : A.href).startsWith("https:") ? mb8 : ub8).request(A, Q),
      Z = new Promise((I, Y) => {
        G.once("response", I).once("error", Y).end()
      });
    return G.then = Z.then.bind(Z), G
  }
  AU.req = cb8
})
// @from(Start 4564919, End 4568697)
Yy1 = z((yw) => {
  var WtQ = yw && yw.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    pb8 = yw && yw.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    XtQ = yw && yw.__importStar || function(A) {
      if (A && A.__esModule) return A;
      var Q = {};
      if (A != null) {
        for (var B in A)
          if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B)) WtQ(Q, A, B)
      }
      return pb8(Q, A), Q
    },
    lb8 = yw && yw.__exportStar || function(A, Q) {
      for (var B in A)
        if (B !== "default" && !Object.prototype.hasOwnProperty.call(Q, B)) WtQ(Q, A, B)
    };
  Object.defineProperty(yw, "__esModule", {
    value: !0
  });
  yw.Agent = void 0;
  var ib8 = XtQ(UA("net")),
    JtQ = XtQ(UA("http")),
    nb8 = UA("https");
  lb8(YtQ(), yw);
  var I_ = Symbol("AgentBaseInternalState");
  class VtQ extends JtQ.Agent {
    constructor(A) {
      super(A);
      this[I_] = {}
    }
    isSecureEndpoint(A) {
      if (A) {
        if (typeof A.secureEndpoint === "boolean") return A.secureEndpoint;
        if (typeof A.protocol === "string") return A.protocol === "https:"
      }
      let {
        stack: Q
      } = Error();
      if (typeof Q !== "string") return !1;
      return Q.split(`
`).some((B) => B.indexOf("(https.js:") !== -1 || B.indexOf("node:https:") !== -1)
    }
    incrementSockets(A) {
      if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0) return null;
      if (!this.sockets[A]) this.sockets[A] = [];
      let Q = new ib8.Socket({
        writable: !1
      });
      return this.sockets[A].push(Q), this.totalSocketCount++, Q
    }
    decrementSockets(A, Q) {
      if (!this.sockets[A] || Q === null) return;
      let B = this.sockets[A],
        G = B.indexOf(Q);
      if (G !== -1) {
        if (B.splice(G, 1), this.totalSocketCount--, B.length === 0) delete this.sockets[A]
      }
    }
    getName(A) {
      if (typeof A.secureEndpoint === "boolean" ? A.secureEndpoint : this.isSecureEndpoint(A)) return nb8.Agent.prototype.getName.call(this, A);
      return super.getName(A)
    }
    createSocket(A, Q, B) {
      let G = {
          ...Q,
          secureEndpoint: this.isSecureEndpoint(Q)
        },
        Z = this.getName(G),
        I = this.incrementSockets(Z);
      Promise.resolve().then(() => this.connect(A, G)).then((Y) => {
        if (this.decrementSockets(Z, I), Y instanceof JtQ.Agent) try {
          return Y.addRequest(A, G)
        } catch (J) {
          return B(J)
        }
        this[I_].currentSocket = Y, super.createSocket(A, Q, B)
      }, (Y) => {
        this.decrementSockets(Z, I), B(Y)
      })
    }
    createConnection() {
      let A = this[I_].currentSocket;
      if (this[I_].currentSocket = void 0, !A) throw Error("No socket was returned in the `connect()` function");
      return A
    }
    get defaultPort() {
      return this[I_].defaultPort ?? (this.protocol === "https:" ? 443 : 80)
    }
    set defaultPort(A) {
      if (this[I_]) this[I_].defaultPort = A
    }
    get protocol() {
      return this[I_].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:")
    }
    set protocol(A) {
      if (this[I_]) this[I_].protocol = A
    }
  }
  yw.Agent = VtQ
})
// @from(Start 4568703, End 4570846)
FtQ = z((m5A) => {
  var ab8 = m5A && m5A.__importDefault || function(A) {
    return A && A.__esModule ? A : {
      default: A
    }
  };
  Object.defineProperty(m5A, "__esModule", {
    value: !0
  });
  m5A.parseProxyResponse = void 0;
  var sb8 = ab8(hs()),
    hpA = (0, sb8.default)("https-proxy-agent:parse-proxy-response");

  function rb8(A) {
    return new Promise((Q, B) => {
      let G = 0,
        Z = [];

      function I() {
        let V = A.read();
        if (V) X(V);
        else A.once("readable", I)
      }

      function Y() {
        A.removeListener("end", J), A.removeListener("error", W), A.removeListener("readable", I)
      }

      function J() {
        Y(), hpA("onend"), B(Error("Proxy connection ended before receiving CONNECT response"))
      }

      function W(V) {
        Y(), hpA("onerror %o", V), B(V)
      }

      function X(V) {
        Z.push(V), G += V.length;
        let F = Buffer.concat(Z, G),
          K = F.indexOf(`\r
\r
`);
        if (K === -1) {
          hpA("have not received end of HTTP headers yet..."), I();
          return
        }
        let D = F.slice(0, K).toString("ascii").split(`\r
`),
          H = D.shift();
        if (!H) return A.destroy(), B(Error("No header received from proxy CONNECT response"));
        let C = H.split(" "),
          E = +C[1],
          U = C.slice(2).join(" "),
          q = {};
        for (let w of D) {
          if (!w) continue;
          let N = w.indexOf(":");
          if (N === -1) return A.destroy(), B(Error(`Invalid header from proxy CONNECT response: "${w}"`));
          let R = w.slice(0, N).toLowerCase(),
            T = w.slice(N + 1).trimStart(),
            y = q[R];
          if (typeof y === "string") q[R] = [y, T];
          else if (Array.isArray(y)) y.push(T);
          else q[R] = T
        }
        hpA("got proxy server response: %o %o", H, q), Y(), Q({
          connect: {
            statusCode: E,
            statusText: U,
            headers: q
          },
          buffered: F
        })
      }
      A.on("error", W), A.on("end", J), I()
    })
  }
  m5A.parseProxyResponse = rb8
})
// @from(Start 4570852, End 4575037)
LEA = z((nL) => {
  var ob8 = nL && nL.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    tb8 = nL && nL.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    CtQ = nL && nL.__importStar || function(A) {
      if (A && A.__esModule) return A;
      var Q = {};
      if (A != null) {
        for (var B in A)
          if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B)) ob8(Q, A, B)
      }
      return tb8(Q, A), Q
    },
    EtQ = nL && nL.__importDefault || function(A) {
      return A && A.__esModule ? A : {
        default: A
      }
    };
  Object.defineProperty(nL, "__esModule", {
    value: !0
  });
  nL.HttpsProxyAgent = void 0;
  var gpA = CtQ(UA("net")),
    KtQ = CtQ(UA("tls")),
    eb8 = EtQ(UA("assert")),
    Af8 = EtQ(hs()),
    Qf8 = Yy1(),
    Bf8 = UA("url"),
    Gf8 = FtQ(),
    NEA = (0, Af8.default)("https-proxy-agent"),
    DtQ = (A) => {
      if (A.servername === void 0 && A.host && !gpA.isIP(A.host)) return {
        ...A,
        servername: A.host
      };
      return A
    };
  class Jy1 extends Qf8.Agent {
    constructor(A, Q) {
      super(Q);
      this.options = {
        path: void 0
      }, this.proxy = typeof A === "string" ? new Bf8.URL(A) : A, this.proxyHeaders = Q?.headers ?? {}, NEA("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      let B = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""),
        G = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...Q ? HtQ(Q, "headers") : null,
        host: B,
        port: G
      }
    }
    async connect(A, Q) {
      let {
        proxy: B
      } = this;
      if (!Q.host) throw TypeError('No "host" provided');
      let G;
      if (B.protocol === "https:") NEA("Creating `tls.Socket`: %o", this.connectOpts), G = KtQ.connect(DtQ(this.connectOpts));
      else NEA("Creating `net.Socket`: %o", this.connectOpts), G = gpA.connect(this.connectOpts);
      let Z = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : {
          ...this.proxyHeaders
        },
        I = gpA.isIPv6(Q.host) ? `[${Q.host}]` : Q.host,
        Y = `CONNECT ${I}:${Q.port} HTTP/1.1\r
`;
      if (B.username || B.password) {
        let F = `${decodeURIComponent(B.username)}:${decodeURIComponent(B.password)}`;
        Z["Proxy-Authorization"] = `Basic ${Buffer.from(F).toString("base64")}`
      }
      if (Z.Host = `${I}:${Q.port}`, !Z["Proxy-Connection"]) Z["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      for (let F of Object.keys(Z)) Y += `${F}: ${Z[F]}\r
`;
      let J = (0, Gf8.parseProxyResponse)(G);
      G.write(`${Y}\r
`);
      let {
        connect: W,
        buffered: X
      } = await J;
      if (A.emit("proxyConnect", W), this.emit("proxyConnect", W, A), W.statusCode === 200) {
        if (A.once("socket", Zf8), Q.secureEndpoint) return NEA("Upgrading socket connection to TLS"), KtQ.connect({
          ...HtQ(DtQ(Q), "host", "path", "port"),
          socket: G
        });
        return G
      }
      G.destroy();
      let V = new gpA.Socket({
        writable: !1
      });
      return V.readable = !0, A.once("socket", (F) => {
        NEA("Replaying proxy buffer for failed request"), (0, eb8.default)(F.listenerCount("data") > 0), F.push(X), F.push(null)
      }), V
    }
  }
  Jy1.protocols = ["http", "https"];
  nL.HttpsProxyAgent = Jy1;

  function Zf8(A) {
    A.resume()
  }

  function HtQ(A, ...Q) {
    let B = {},
      G;
    for (G in A)
      if (!Q.includes(G)) B[G] = A[G];
    return B
  }
})
// @from(Start 4575043, End 4577746)
tI = z((lj7, ztQ) => {
  ztQ.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kBody: Symbol("abstracted request body"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kResume: Symbol("resume"),
    kOnError: Symbol("on error"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable"),
    kListeners: Symbol("listeners"),
    kHTTPContext: Symbol("http context"),
    kMaxConcurrentStreams: Symbol("max concurrent streams"),
    kNoProxyAgent: Symbol("no proxy agent"),
    kHttpProxyAgent: Symbol("http proxy agent"),
    kHttpsProxyAgent: Symbol("https proxy agent")
  }
})
// @from(Start 4577752, End 4583369)
R7 = z((ij7, gtQ) => {
  class MJ extends Error {
    constructor(A) {
      super(A);
      this.name = "UndiciError", this.code = "UND_ERR"
    }
  }
  class UtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "ConnectTimeoutError", this.message = A || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT"
    }
  }
  class $tQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "HeadersTimeoutError", this.message = A || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT"
    }
  }
  class wtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "HeadersOverflowError", this.message = A || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW"
    }
  }
  class qtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "BodyTimeoutError", this.message = A || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT"
    }
  }
  class NtQ extends MJ {
    constructor(A, Q, B, G) {
      super(A);
      this.name = "ResponseStatusCodeError", this.message = A || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = G, this.status = Q, this.statusCode = Q, this.headers = B
    }
  }
  class LtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "InvalidArgumentError", this.message = A || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG"
    }
  }
  class MtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "InvalidReturnValueError", this.message = A || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE"
    }
  }
  class Wy1 extends MJ {
    constructor(A) {
      super(A);
      this.name = "AbortError", this.message = A || "The operation was aborted"
    }
  }
  class OtQ extends Wy1 {
    constructor(A) {
      super(A);
      this.name = "AbortError", this.message = A || "Request aborted", this.code = "UND_ERR_ABORTED"
    }
  }
  class RtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "InformationalError", this.message = A || "Request information", this.code = "UND_ERR_INFO"
    }
  }
  class TtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "RequestContentLengthMismatchError", this.message = A || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH"
    }
  }
  class PtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "ResponseContentLengthMismatchError", this.message = A || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH"
    }
  }
  class jtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "ClientDestroyedError", this.message = A || "The client is destroyed", this.code = "UND_ERR_DESTROYED"
    }
  }
  class StQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "ClientClosedError", this.message = A || "The client is closed", this.code = "UND_ERR_CLOSED"
    }
  }
  class _tQ extends MJ {
    constructor(A, Q) {
      super(A);
      this.name = "SocketError", this.message = A || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = Q
    }
  }
  class ktQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "NotSupportedError", this.message = A || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED"
    }
  }
  class ytQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "MissingUpstreamError", this.message = A || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM"
    }
  }
  class xtQ extends Error {
    constructor(A, Q, B) {
      super(A);
      this.name = "HTTPParserError", this.code = Q ? `HPE_${Q}` : void 0, this.data = B ? B.toString() : void 0
    }
  }
  class vtQ extends MJ {
    constructor(A) {
      super(A);
      this.name = "ResponseExceededMaxSizeError", this.message = A || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE"
    }
  }
  class btQ extends MJ {
    constructor(A, Q, {
      headers: B,
      data: G
    }) {
      super(A);
      this.name = "RequestRetryError", this.message = A || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = Q, this.data = G, this.headers = B
    }
  }
  class ftQ extends MJ {
    constructor(A, Q, {
      headers: B,
      data: G
    }) {
      super(A);
      this.name = "ResponseError", this.message = A || "Response error", this.code = "UND_ERR_RESPONSE", this.statusCode = Q, this.data = G, this.headers = B
    }
  }
  class htQ extends MJ {
    constructor(A, Q, B) {
      super(Q, {
        cause: A,
        ...B ?? {}
      });
      this.name = "SecureProxyConnectionError", this.message = Q || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = A
    }
  }
  gtQ.exports = {
    AbortError: Wy1,
    HTTPParserError: xtQ,
    UndiciError: MJ,
    HeadersTimeoutError: $tQ,
    HeadersOverflowError: wtQ,
    BodyTimeoutError: qtQ,
    RequestContentLengthMismatchError: TtQ,
    ConnectTimeoutError: UtQ,
    ResponseStatusCodeError: NtQ,
    InvalidArgumentError: LtQ,
    InvalidReturnValueError: MtQ,
    RequestAbortedError: OtQ,
    ClientDestroyedError: jtQ,
    ClientClosedError: StQ,
    InformationalError: RtQ,
    SocketError: _tQ,
    NotSupportedError: ktQ,
    ResponseContentLengthMismatchError: PtQ,
    BalancedPoolMissingUpstreamError: ytQ,
    ResponseExceededMaxSizeError: vtQ,
    RequestRetryError: btQ,
    ResponseError: ftQ,
    SecureProxyConnectionError: htQ
  }
})
// @from(Start 4583375, End 4585437)
mpA = z((nj7, utQ) => {
  var upA = {},
    Xy1 = ["Accept", "Accept-Encoding", "Accept-Language", "Accept-Ranges", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Age", "Allow", "Alt-Svc", "Alt-Used", "Authorization", "Cache-Control", "Clear-Site-Data", "Connection", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location", "Content-Range", "Content-Security-Policy", "Content-Security-Policy-Report-Only", "Content-Type", "Cookie", "Cross-Origin-Embedder-Policy", "Cross-Origin-Opener-Policy", "Cross-Origin-Resource-Policy", "Date", "Device-Memory", "Downlink", "ECT", "ETag", "Expect", "Expect-CT", "Expires", "Forwarded", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Keep-Alive", "Last-Modified", "Link", "Location", "Max-Forwards", "Origin", "Permissions-Policy", "Pragma", "Proxy-Authenticate", "Proxy-Authorization", "RTT", "Range", "Referer", "Referrer-Policy", "Refresh", "Retry-After", "Sec-WebSocket-Accept", "Sec-WebSocket-Extensions", "Sec-WebSocket-Key", "Sec-WebSocket-Protocol", "Sec-WebSocket-Version", "Server", "Server-Timing", "Service-Worker-Allowed", "Service-Worker-Navigation-Preload", "Set-Cookie", "SourceMap", "Strict-Transport-Security", "Supports-Loading-Mode", "TE", "Timing-Allow-Origin", "Trailer", "Transfer-Encoding", "Upgrade", "Upgrade-Insecure-Requests", "User-Agent", "Vary", "Via", "WWW-Authenticate", "X-Content-Type-Options", "X-DNS-Prefetch-Control", "X-Frame-Options", "X-Permitted-Cross-Domain-Policies", "X-Powered-By", "X-Requested-With", "X-XSS-Protection"];
  for (let A = 0; A < Xy1.length; ++A) {
    let Q = Xy1[A],
      B = Q.toLowerCase();
    upA[Q] = upA[B] = B
  }
  Object.setPrototypeOf(upA, null);
  utQ.exports = {
    wellknownHeaderNames: Xy1,
    headerNameLowerCasedRecord: upA
  }
})
// @from(Start 4585443, End 4587514)
ptQ = z((aj7, ctQ) => {
  var {
    wellknownHeaderNames: mtQ,
    headerNameLowerCasedRecord: If8
  } = mpA();
  class d5A {
    value = null;
    left = null;
    middle = null;
    right = null;
    code;
    constructor(A, Q, B) {
      if (B === void 0 || B >= A.length) throw TypeError("Unreachable");
      if ((this.code = A.charCodeAt(B)) > 127) throw TypeError("key must be ascii string");
      if (A.length !== ++B) this.middle = new d5A(A, Q, B);
      else this.value = Q
    }
    add(A, Q) {
      let B = A.length;
      if (B === 0) throw TypeError("Unreachable");
      let G = 0,
        Z = this;
      while (!0) {
        let I = A.charCodeAt(G);
        if (I > 127) throw TypeError("key must be ascii string");
        if (Z.code === I)
          if (B === ++G) {
            Z.value = Q;
            break
          } else if (Z.middle !== null) Z = Z.middle;
        else {
          Z.middle = new d5A(A, Q, G);
          break
        } else if (Z.code < I)
          if (Z.left !== null) Z = Z.left;
          else {
            Z.left = new d5A(A, Q, G);
            break
          }
        else if (Z.right !== null) Z = Z.right;
        else {
          Z.right = new d5A(A, Q, G);
          break
        }
      }
    }
    search(A) {
      let Q = A.length,
        B = 0,
        G = this;
      while (G !== null && B < Q) {
        let Z = A[B];
        if (Z <= 90 && Z >= 65) Z |= 32;
        while (G !== null) {
          if (Z === G.code) {
            if (Q === ++B) return G;
            G = G.middle;
            break
          }
          G = G.code < Z ? G.left : G.right
        }
      }
      return null
    }
  }
  class Vy1 {
    node = null;
    insert(A, Q) {
      if (this.node === null) this.node = new d5A(A, Q, 0);
      else this.node.add(A, Q)
    }
    lookup(A) {
      return this.node?.search(A)?.value ?? null
    }
  }
  var dtQ = new Vy1;
  for (let A = 0; A < mtQ.length; ++A) {
    let Q = If8[mtQ[A]];
    dtQ.insert(Q, Q)
  }
  ctQ.exports = {
    TernarySearchTree: Vy1,
    tree: dtQ
  }
})
// @from(Start 6743701, End 6756665)
WRB = L(() => {
  Kv();
  Yr();
  QvA();
  tH1();
  i$A = class i$A {
    constructor() {
      EM.add(this), this.messages = [], this.receivedMessages = [], Tp.set(this, void 0), this.controller = new AbortController, m$A.set(this, void 0), _rA.set(this, () => {}), d$A.set(this, () => {}), c$A.set(this, void 0), krA.set(this, () => {}), p$A.set(this, () => {}), Df.set(this, {}), l$A.set(this, !1), yrA.set(this, !1), xrA.set(this, !1), FGA.set(this, !1), vrA.set(this, void 0), brA.set(this, void 0), Gd1.set(this, (A) => {
        if (fB(this, yrA, !0, "f"), Dv(A)) A = new yY;
        if (A instanceof yY) return fB(this, xrA, !0, "f"), this._emit("abort", A);
        if (A instanceof vB) return this._emit("error", A);
        if (A instanceof Error) {
          let Q = new vB(A.message);
          return Q.cause = A, this._emit("error", Q)
        }
        return this._emit("error", new vB(String(A)))
      }), fB(this, m$A, new Promise((A, Q) => {
        fB(this, _rA, A, "f"), fB(this, d$A, Q, "f")
      }), "f"), fB(this, c$A, new Promise((A, Q) => {
        fB(this, krA, A, "f"), fB(this, p$A, Q, "f")
      }), "f"), N0(this, m$A, "f").catch(() => {}), N0(this, c$A, "f").catch(() => {})
    }
    get response() {
      return N0(this, vrA, "f")
    }
    get request_id() {
      return N0(this, brA, "f")
    }
    async withResponse() {
      let A = await N0(this, m$A, "f");
      if (!A) throw Error("Could not resolve a `Response` object");
      return {
        data: this,
        response: A,
        request_id: A.headers.get("request-id")
      }
    }
    static fromReadableStream(A) {
      let Q = new i$A;
      return Q._run(() => Q._fromReadableStream(A)), Q
    }
    static createMessage(A, Q, B) {
      let G = new i$A;
      for (let Z of Q.messages) G._addMessageParam(Z);
      return G._run(() => G._createMessage(A, {
        ...Q,
        stream: !0
      }, {
        ...B,
        headers: {
          ...B?.headers,
          "X-Stainless-Helper-Method": "stream"
        }
      })), G
    }
    _run(A) {
      A().then(() => {
        this._emitFinal(), this._emit("end")
      }, N0(this, Gd1, "f"))
    }
    _addMessageParam(A) {
      this.messages.push(A)
    }
    _addMessage(A, Q = !0) {
      if (this.receivedMessages.push(A), Q) this._emit("message", A)
    }
    async _createMessage(A, Q, B) {
      let G = B?.signal,
        Z;
      if (G) {
        if (G.aborted) this.controller.abort();
        Z = this.controller.abort.bind(this.controller), G.addEventListener("abort", Z)
      }
      try {
        N0(this, EM, "m", Zd1).call(this);
        let {
          response: I,
          data: Y
        } = await A.create({
          ...Q,
          stream: !0
        }, {
          ...B,
          signal: this.controller.signal
        }).withResponse();
        this._connected(I);
        for await (let J of Y) N0(this, EM, "m", Id1).call(this, J);
        if (Y.controller.signal?.aborted) throw new yY;
        N0(this, EM, "m", Yd1).call(this)
      } finally {
        if (G && Z) G.removeEventListener("abort", Z)
      }
    }
    _connected(A) {
      if (this.ended) return;
      fB(this, vrA, A, "f"), fB(this, brA, A?.headers.get("request-id"), "f"), N0(this, _rA, "f").call(this, A), this._emit("connect")
    }
    get ended() {
      return N0(this, l$A, "f")
    }
    get errored() {
      return N0(this, yrA, "f")
    }
    get aborted() {
      return N0(this, xrA, "f")
    }
    abort() {
      this.controller.abort()
    }
    on(A, Q) {
      return (N0(this, Df, "f")[A] || (N0(this, Df, "f")[A] = [])).push({
        listener: Q
      }), this
    }
    off(A, Q) {
      let B = N0(this, Df, "f")[A];
      if (!B) return this;
      let G = B.findIndex((Z) => Z.listener === Q);
      if (G >= 0) B.splice(G, 1);
      return this
    }
    once(A, Q) {
      return (N0(this, Df, "f")[A] || (N0(this, Df, "f")[A] = [])).push({
        listener: Q,
        once: !0
      }), this
    }
    emitted(A) {
      return new Promise((Q, B) => {
        if (fB(this, FGA, !0, "f"), A !== "error") this.once("error", B);
        this.once(A, Q)
      })
    }
    async done() {
      fB(this, FGA, !0, "f"), await N0(this, c$A, "f")
    }
    get currentMessage() {
      return N0(this, Tp, "f")
    }
    async finalMessage() {
      return await this.done(), N0(this, EM, "m", Bd1).call(this)
    }
    async finalText() {
      return await this.done(), N0(this, EM, "m", GRB).call(this)
    }
    _emit(A, ...Q) {
      if (N0(this, l$A, "f")) return;
      if (A === "end") fB(this, l$A, !0, "f"), N0(this, krA, "f").call(this);
      let B = N0(this, Df, "f")[A];
      if (B) N0(this, Df, "f")[A] = B.filter((G) => !G.once), B.forEach(({
        listener: G
      }) => G(...Q));
      if (A === "abort") {
        let G = Q[0];
        if (!N0(this, FGA, "f") && !B?.length) Promise.reject(G);
        N0(this, d$A, "f").call(this, G), N0(this, p$A, "f").call(this, G), this._emit("end");
        return
      }
      if (A === "error") {
        let G = Q[0];
        if (!N0(this, FGA, "f") && !B?.length) Promise.reject(G);
        N0(this, d$A, "f").call(this, G), N0(this, p$A, "f").call(this, G), this._emit("end")
      }
    }
    _emitFinal() {
      if (this.receivedMessages.at(-1)) this._emit("finalMessage", N0(this, EM, "m", Bd1).call(this))
    }
    async _fromReadableStream(A, Q) {
      let B = Q?.signal,
        G;
      if (B) {
        if (B.aborted) this.controller.abort();
        G = this.controller.abort.bind(this.controller), B.addEventListener("abort", G)
      }
      try {
        N0(this, EM, "m", Zd1).call(this), this._connected(null);
        let Z = lC.fromReadableStream(A, this.controller);
        for await (let I of Z) N0(this, EM, "m", Id1).call(this, I);
        if (Z.controller.signal?.aborted) throw new yY;
        N0(this, EM, "m", Yd1).call(this)
      } finally {
        if (B && G) B.removeEventListener("abort", G)
      }
    } [(Tp = new WeakMap, m$A = new WeakMap, _rA = new WeakMap, d$A = new WeakMap, c$A = new WeakMap, krA = new WeakMap, p$A = new WeakMap, Df = new WeakMap, l$A = new WeakMap, yrA = new WeakMap, xrA = new WeakMap, FGA = new WeakMap, vrA = new WeakMap, brA = new WeakMap, Gd1 = new WeakMap, EM = new WeakSet, Bd1 = function() {
      if (this.receivedMessages.length === 0) throw new vB("stream ended without producing a Message with role=assistant");
      return this.receivedMessages.at(-1)
    }, GRB = function() {
      if (this.receivedMessages.length === 0) throw new vB("stream ended without producing a Message with role=assistant");
      let Q = this.receivedMessages.at(-1).content.filter((B) => B.type === "text").map((B) => B.text);
      if (Q.length === 0) throw new vB("stream ended without producing a content block with type=text");
      return Q.join(" ")
    }, Zd1 = function() {
      if (this.ended) return;
      fB(this, Tp, void 0, "f")
    }, Id1 = function(Q) {
      if (this.ended) return;
      let B = N0(this, EM, "m", ZRB).call(this, Q);
      switch (this._emit("streamEvent", Q, B), Q.type) {
        case "content_block_delta": {
          let G = B.content.at(-1);
          switch (Q.delta.type) {
            case "text_delta": {
              if (G.type === "text") this._emit("text", Q.delta.text, G.text || "");
              break
            }
            case "citations_delta": {
              if (G.type === "text") this._emit("citation", Q.delta.citation, G.citations ?? []);
              break
            }
            case "input_json_delta": {
              if (YRB(G) && G.input) this._emit("inputJson", Q.delta.partial_json, G.input);
              break
            }
            case "thinking_delta": {
              if (G.type === "thinking") this._emit("thinking", Q.delta.thinking, G.thinking);
              break
            }
            case "signature_delta": {
              if (G.type === "thinking") this._emit("signature", G.signature);
              break
            }
            default:
              JRB(Q.delta)
          }
          break
        }
        case "message_stop": {
          this._addMessageParam(B), this._addMessage(B, !0);
          break
        }
        case "content_block_stop": {
          this._emit("contentBlock", B.content.at(-1));
          break
        }
        case "message_start": {
          fB(this, Tp, B, "f");
          break
        }
        case "content_block_start":
        case "message_delta":
          break
      }
    }, Yd1 = function() {
      if (this.ended) throw new vB("stream has ended, this shouldn't happen");
      let Q = N0(this, Tp, "f");
      if (!Q) throw new vB("request ended without sending any chunks");
      return fB(this, Tp, void 0, "f"), Q
    }, ZRB = function(Q) {
      let B = N0(this, Tp, "f");
      if (Q.type === "message_start") {
        if (B) throw new vB(`Unexpected event order, got ${Q.type} before receiving "message_stop"`);
        return Q.message
      }
      if (!B) throw new vB(`Unexpected event order, got ${Q.type} before "message_start"`);
      switch (Q.type) {
        case "message_stop":
          return B;
        case "message_delta":
          if (B.stop_reason = Q.delta.stop_reason, B.stop_sequence = Q.delta.stop_sequence, B.usage.output_tokens = Q.usage.output_tokens, Q.usage.input_tokens != null) B.usage.input_tokens = Q.usage.input_tokens;
          if (Q.usage.cache_creation_input_tokens != null) B.usage.cache_creation_input_tokens = Q.usage.cache_creation_input_tokens;
          if (Q.usage.cache_read_input_tokens != null) B.usage.cache_read_input_tokens = Q.usage.cache_read_input_tokens;
          if (Q.usage.server_tool_use != null) B.usage.server_tool_use = Q.usage.server_tool_use;
          return B;
        case "content_block_start":
          return B.content.push({
            ...Q.content_block
          }), B;
        case "content_block_delta": {
          let G = B.content.at(Q.index);
          switch (Q.delta.type) {
            case "text_delta": {
              if (G?.type === "text") B.content[Q.index] = {
                ...G,
                text: (G.text || "") + Q.delta.text
              };
              break
            }
            case "citations_delta": {
              if (G?.type === "text") B.content[Q.index] = {
                ...G,
                citations: [...G.citations ?? [], Q.delta.citation]
              };
              break
            }
            case "input_json_delta": {
              if (G && YRB(G)) {
                let Z = G[IRB] || "";
                Z += Q.delta.partial_json;
                let I = {
                  ...G
                };
                if (Object.defineProperty(I, IRB, {
                    value: Z,
                    enumerable: !1,
                    writable: !0
                  }), Z) I.input = axA(Z);
                B.content[Q.index] = I
              }
              break
            }
            case "thinking_delta": {
              if (G?.type === "thinking") B.content[Q.index] = {
                ...G,
                thinking: G.thinking + Q.delta.thinking
              };
              break
            }
            case "signature_delta": {
              if (G?.type === "thinking") B.content[Q.index] = {
                ...G,
                signature: Q.delta.signature
              };
              break
            }
            default:
              JRB(Q.delta)
          }
          return B
        }
        case "content_block_stop":
          return B
      }
    }, Symbol.asyncIterator)]() {
      let A = [],
        Q = [],
        B = !1;
      return this.on("streamEvent", (G) => {
        let Z = Q.shift();
        if (Z) Z.resolve(G);
        else A.push(G)
      }), this.on("end", () => {
        B = !0;
        for (let G of Q) G.resolve(void 0);
        Q.length = 0
      }), this.on("abort", (G) => {
        B = !0;
        for (let Z of Q) Z.reject(G);
        Q.length = 0
      }), this.on("error", (G) => {
        B = !0;
        for (let Z of Q) Z.reject(G);
        Q.length = 0
      }), {
        next: async () => {
          if (!A.length) {
            if (B) return {
              value: void 0,
              done: !0
            };
            return new Promise((Z, I) => Q.push({
              resolve: Z,
              reject: I
            })).then((Z) => Z ? {
              value: Z,
              done: !1
            } : {
              value: void 0,
              done: !0
            })
          }
          return {
            value: A.shift(),
            done: !1
          }
        },
        return: async () => {
          return this.abort(), {
            value: void 0,
            done: !0
          }
        }
      }
    }
    toReadableStream() {
      return new lC(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream()
    }
  }
})
// @from(Start 6756671, End 6756674)
n$A
// @from(Start 6756680, End 6757782)
Jd1 = L(() => {
  d_();
  CM();
  sm1();
  Yr();
  Mp();
  n$A = class n$A extends pY {
    create(A, Q) {
      return this._client.post("/v1/messages/batches", {
        body: A,
        ...Q
      })
    }
    retrieve(A, Q) {
      return this._client.get(IY`/v1/messages/batches/${A}`, Q)
    }
    list(A = {}, Q) {
      return this._client.getAPIList("/v1/messages/batches", NT, {
        query: A,
        ...Q
      })
    }
    delete(A, Q) {
      return this._client.delete(IY`/v1/messages/batches/${A}`, Q)
    }
    cancel(A, Q) {
      return this._client.post(IY`/v1/messages/batches/${A}/cancel`, Q)
    }
    async results(A, Q) {
      let B = await this.retrieve(A);
      if (!B.results_url) throw new vB(`No batch \`results_url\`; Has it finished processing? ${B.processing_status} - ${B.id}`);
      return this._client.get(B.results_url, {
        ...Q,
        headers: r4([{
          Accept: "application/binary"
        }, Q?.headers]),
        stream: !0,
        __binaryResponse: !0
      })._thenUnwrap((G, Z) => XGA.fromResponse(Z.response, Z.controller))
    }
  }
})
// @from(Start 6757788, End 6757790)
Gq
// @from(Start 6757792, End 6757795)
XRB
// @from(Start 6757801, End 6759365)
Wd1 = L(() => {
  WRB();
  Jd1();
  Jd1();
  im1();
  Gq = class Gq extends pY {
    constructor() {
      super(...arguments);
      this.batches = new n$A(this._client)
    }
    create(A, Q) {
      if (A.model in XRB) console.warn(`The model '${A.model}' is deprecated and will reach end-of-life on ${XRB[A.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
      let B = this._client._options.timeout;
      if (!A.stream && B == null) {
        let G = jrA[A.model] ?? void 0;
        B = this._client.calculateNonstreamingTimeout(A.max_tokens, G)
      }
      return this._client.post("/v1/messages", {
        body: A,
        timeout: B ?? 600000,
        ...Q,
        stream: A.stream ?? !1
      })
    }
    stream(A, Q) {
      return i$A.createMessage(this, A, Q)
    }
    countTokens(A, Q) {
      return this._client.post("/v1/messages/count_tokens", {
        body: A,
        ...Q
      })
    }
  };
  XRB = {
    "claude-1.3": "November 6th, 2024",
    "claude-1.3-100k": "November 6th, 2024",
    "claude-instant-1.1": "November 6th, 2024",
    "claude-instant-1.1-100k": "November 6th, 2024",
    "claude-instant-1.2": "November 6th, 2024",
    "claude-3-sonnet-20240229": "July 21st, 2025",
    "claude-3-opus-20240229": "January 5th, 2026",
    "claude-2.1": "July 21st, 2025",
    "claude-2.0": "July 21st, 2025",
    "claude-3-7-sonnet-latest": "February 19th, 2026",
    "claude-3-7-sonnet-20250219": "February 19th, 2026"
  };
  Gq.Batches = n$A
})
// @from(Start 6759371, End 6759374)
KGA
// @from(Start 6759380, End 6760106)
Xd1 = L(() => {
  d_();
  CM();
  Mp();
  KGA = class KGA extends pY {
    retrieve(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.get(IY`/v1/models/${A}`, {
        ...B,
        headers: r4([{
          ...G?.toString() != null ? {
            "anthropic-beta": G?.toString()
          } : void 0
        }, B?.headers])
      })
    }
    list(A = {}, Q) {
      let {
        betas: B,
        ...G
      } = A ?? {};
      return this._client.getAPIList("/v1/models", NT, {
        query: G,
        ...Q,
        headers: r4([{
          ...B?.toString() != null ? {
            "anthropic-beta": B?.toString()
          } : void 0
        }, Q?.headers])
      })
    }
  }
})
// @from(Start 6760112, End 6760174)
a$A = L(() => {
  Ad1();
  Qd1();
  Wd1();
  Xd1();
  oOB()
})
// @from(Start 6760180, End 6760380)
s$A = (A) => {
  if (typeof globalThis.process < "u") return globalThis.process.env?.[A]?.trim() ?? void 0;
  if (typeof globalThis.Deno < "u") return globalThis.Deno.env?.get?.(A)?.trim();
  return
}
// @from(Start 6760382, End 6773348)
class FG {
  constructor({
    baseURL: A = s$A("ANTHROPIC_BASE_URL"),
    apiKey: Q = s$A("ANTHROPIC_API_KEY") ?? null,
    authToken: B = s$A("ANTHROPIC_AUTH_TOKEN") ?? null,
    ...G
  } = {}) {
    Vd1.add(this), hrA.set(this, void 0);
    let Z = {
      apiKey: Q,
      authToken: B,
      ...G,
      baseURL: A || "https://api.anthropic.com"
    };
    if (!Z.dangerouslyAllowBrowser && lOB()) throw new vB(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Anthropic({ apiKey, dangerouslyAllowBrowser: true });
`);
    this.baseURL = Z.baseURL, this.timeout = Z.timeout ?? Fd1.DEFAULT_TIMEOUT, this.logger = Z.logger ?? console;
    let I = "warn";
    this.logLevel = I, this.logLevel = ZC1(Z.logLevel, "ClientOptions.logLevel", this) ?? ZC1(s$A("ANTHROPIC_LOG"), "process.env['ANTHROPIC_LOG']", this) ?? I, this.fetchOptions = Z.fetchOptions, this.maxRetries = Z.maxRetries ?? 2, this.fetch = Z.fetch ?? Zc0(), fB(this, hrA, nOB, "f"), this._options = Z, this.apiKey = typeof Q === "string" ? Q : null, this.authToken = B
  }
  withOptions(A) {
    return new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      authToken: this.authToken,
      ...A
    })
  }
  defaultQuery() {
    return this._options.defaultQuery
  }
  validateHeaders({
    values: A,
    nulls: Q
  }) {
    if (A.get("x-api-key") || A.get("authorization")) return;
    if (this.apiKey && A.get("x-api-key")) return;
    if (Q.has("x-api-key")) return;
    if (this.authToken && A.get("authorization")) return;
    if (Q.has("authorization")) return;
    throw Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted')
  }
  async authHeaders(A) {
    return r4([await this.apiKeyAuth(A), await this.bearerAuth(A)])
  }
  async apiKeyAuth(A) {
    if (this.apiKey == null) return;
    return r4([{
      "X-Api-Key": this.apiKey
    }])
  }
  async bearerAuth(A) {
    if (this.authToken == null) return;
    return r4([{
      Authorization: `Bearer ${this.authToken}`
    }])
  }
  stringifyQuery(A) {
    return Object.entries(A).filter(([Q, B]) => typeof B < "u").map(([Q, B]) => {
      if (typeof B === "string" || typeof B === "number" || typeof B === "boolean") return `${encodeURIComponent(Q)}=${encodeURIComponent(B)}`;
      if (B === null) return `${encodeURIComponent(Q)}=`;
      throw new vB(`Cannot stringify type ${typeof B}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`)
    }).join("&")
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${Lp}`
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${xm1()}`
  }
  makeStatusError(A, Q, B, G) {
    return n2.generate(A, Q, B, G)
  }
  buildURL(A, Q, B) {
    let G = !N0(this, Vd1, "m", VRB).call(this) && B || this.baseURL,
      Z = Vc0(A) ? new URL(A) : new URL(G + (G.endsWith("/") && A.startsWith("/") ? A.slice(1) : A)),
      I = this.defaultQuery();
    if (!Fc0(I)) Q = {
      ...I,
      ...Q
    };
    if (typeof Q === "object" && Q && !Array.isArray(Q)) Z.search = this.stringifyQuery(Q);
    return Z.toString()
  }
  _calculateNonstreamingTimeout(A) {
    if (3600 * A / 128000 > 600) throw new vB("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details");
    return 600000
  }
  async prepareOptions(A) {}
  async prepareRequest(A, {
    url: Q,
    options: B
  }) {}
  get(A, Q) {
    return this.methodRequest("get", A, Q)
  }
  post(A, Q) {
    return this.methodRequest("post", A, Q)
  }
  patch(A, Q) {
    return this.methodRequest("patch", A, Q)
  }
  put(A, Q) {
    return this.methodRequest("put", A, Q)
  }
  delete(A, Q) {
    return this.methodRequest("delete", A, Q)
  }
  methodRequest(A, Q, B) {
    return this.request(Promise.resolve(B).then((G) => {
      return {
        method: A,
        path: Q,
        ...G
      }
    }))
  }
  request(A, Q = null) {
    return new Ze(this, this.makeRequest(A, Q, void 0))
  }
  async makeRequest(A, Q, B) {
    let G = await A,
      Z = G.maxRetries ?? this.maxRetries;
    if (Q == null) Q = Z;
    await this.prepareOptions(G);
    let {
      req: I,
      url: Y,
      timeout: J
    } = await this.buildRequest(G, {
      retryCount: Z - Q
    });
    await this.prepareRequest(I, {
      url: Y,
      options: G
    });
    let W = "log_" + (Math.random() * 16777216 | 0).toString(16).padStart(6, "0"),
      X = B === void 0 ? "" : `, retryOf: ${B}`,
      V = Date.now();
    if (qF(this).debug(`[${W}] sending request`, Hv({
        retryOfRequestLogID: B,
        method: G.method,
        url: Y,
        options: G,
        headers: I.headers
      })), G.signal?.aborted) throw new yY;
    let F = new AbortController,
      K = await this.fetchWithTimeout(Y, I, J, F).catch(MKA),
      D = Date.now();
    if (K instanceof globalThis.Error) {
      let E = `retrying, ${Q} attempts remaining`;
      if (G.signal?.aborted) throw new yY;
      let U = Dv(K) || /timed? ?out/i.test(String(K) + ("cause" in K ? String(K.cause) : ""));
      if (Q) return qF(this).info(`[${W}] connection ${U?"timed out":"failed"} - ${E}`), qF(this).debug(`[${W}] connection ${U?"timed out":"failed"} (${E})`, Hv({
        retryOfRequestLogID: B,
        url: Y,
        durationMs: D - V,
        message: K.message
      })), this.retryRequest(G, Q, B ?? W);
      if (qF(this).info(`[${W}] connection ${U?"timed out":"failed"} - error; no more retries left`), qF(this).debug(`[${W}] connection ${U?"timed out":"failed"} (error; no more retries left)`, Hv({
          retryOfRequestLogID: B,
          url: Y,
          durationMs: D - V,
          message: K.message
        })), U) throw new IS;
      throw new cC({
        cause: K
      })
    }
    let H = [...K.headers.entries()].filter(([E]) => E === "request-id").map(([E, U]) => ", " + E + ": " + JSON.stringify(U)).join(""),
      C = `[${W}${X}${H}] ${I.method} ${Y} ${K.ok?"succeeded":"failed"} with status ${K.status} in ${D-V}ms`;
    if (!K.ok) {
      let E = await this.shouldRetry(K);
      if (Q && E) {
        let T = `retrying, ${Q} attempts remaining`;
        return await Ic0(K.body), qF(this).info(`${C} - ${T}`), qF(this).debug(`[${W}] response error (${T})`, Hv({
          retryOfRequestLogID: B,
          url: K.url,
          status: K.status,
          headers: K.headers,
          durationMs: D - V
        })), this.retryRequest(G, Q, B ?? W, K.headers)
      }
      let U = E ? "error; no more retries left" : "error; not retryable";
      qF(this).info(`${C} - ${U}`);
      let q = await K.text().catch((T) => MKA(T).message),
        w = oxA(q),
        N = w ? void 0 : q;
      throw qF(this).debug(`[${W}] response error (${U})`, Hv({
        retryOfRequestLogID: B,
        url: K.url,
        status: K.status,
        headers: K.headers,
        message: N,
        durationMs: Date.now() - V
      })), this.makeStatusError(K.status, w, N, K.headers)
    }
    return qF(this).info(C), qF(this).debug(`[${W}] response start`, Hv({
      retryOfRequestLogID: B,
      url: K.url,
      status: K.status,
      headers: K.headers,
      durationMs: D - V
    })), {
      response: K,
      options: G,
      controller: F,
      requestLogID: W,
      retryOfRequestLogID: B,
      startTime: V
    }
  }
  getAPIList(A, Q, B) {
    return this.requestAPIList(Q, {
      method: "get",
      path: A,
      ...B
    })
  }
  requestAPIList(A, Q) {
    let B = this.makeRequest(Q, null, void 0);
    return new TrA(this, B, A)
  }
  async fetchWithTimeout(A, Q, B, G) {
    let {
      signal: Z,
      method: I,
      ...Y
    } = Q || {};
    if (Z) Z.addEventListener("abort", () => G.abort());
    let J = setTimeout(() => G.abort(), B),
      W = globalThis.ReadableStream && Y.body instanceof globalThis.ReadableStream || typeof Y.body === "object" && Y.body !== null && Symbol.asyncIterator in Y.body,
      X = {
        signal: G.signal,
        ...W ? {
          duplex: "half"
        } : {},
        method: "GET",
        ...Y
      };
    if (I) X.method = I.toUpperCase();
    try {
      return await this.fetch.call(void 0, A, X)
    } finally {
      clearTimeout(J)
    }
  }
  async shouldRetry(A) {
    let Q = A.headers.get("x-should-retry");
    if (Q === "true") return !0;
    if (Q === "false") return !1;
    if (A.status === 408) return !0;
    if (A.status === 409) return !0;
    if (A.status === 429) return !0;
    if (A.status >= 500) return !0;
    return !1
  }
  async retryRequest(A, Q, B, G) {
    let Z, I = G?.get("retry-after-ms");
    if (I) {
      let J = parseFloat(I);
      if (!Number.isNaN(J)) Z = J
    }
    let Y = G?.get("retry-after");
    if (Y && !Z) {
      let J = parseFloat(Y);
      if (!Number.isNaN(J)) Z = J * 1000;
      else Z = Date.parse(Y) - Date.now()
    }
    if (!(Z && 0 <= Z && Z < 60000)) {
      let J = A.maxRetries ?? this.maxRetries;
      Z = this.calculateDefaultRetryTimeoutMillis(Q, J)
    }
    return await mOB(Z), this.makeRequest(A, Q - 1, B)
  }
  calculateDefaultRetryTimeoutMillis(A, Q) {
    let Z = Q - A,
      I = Math.min(0.5 * Math.pow(2, Z), 8),
      Y = 1 - Math.random() * 0.25;
    return I * Y * 1000
  }
  calculateNonstreamingTimeout(A, Q) {
    if (3600000 * A / 128000 > 600000 || Q != null && A > Q) throw new vB("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details");
    return 600000
  }
  async buildRequest(A, {
    retryCount: Q = 0
  } = {}) {
    let B = {
        ...A
      },
      {
        method: G,
        path: Z,
        query: I,
        defaultBaseURL: Y
      } = B,
      J = this.buildURL(Z, I, Y);
    if ("timeout" in B) Dc0("timeout", B.timeout);
    B.timeout = B.timeout ?? this.timeout;
    let {
      bodyHeaders: W,
      body: X
    } = this.buildBody({
      options: B
    }), V = await this.buildHeaders({
      options: A,
      method: G,
      bodyHeaders: W,
      retryCount: Q
    });
    return {
      req: {
        method: G,
        headers: V,
        ...B.signal && {
          signal: B.signal
        },
        ...globalThis.ReadableStream && X instanceof globalThis.ReadableStream && {
          duplex: "half"
        },
        ...X && {
          body: X
        },
        ...this.fetchOptions ?? {},
        ...B.fetchOptions ?? {}
      },
      url: J,
      timeout: B.timeout
    }
  }
  async buildHeaders({
    options: A,
    method: Q,
    bodyHeaders: B,
    retryCount: G
  }) {
    let Z = {};
    if (this.idempotencyHeader && Q !== "get") {
      if (!A.idempotencyKey) A.idempotencyKey = this.defaultIdempotencyKey();
      Z[this.idempotencyHeader] = A.idempotencyKey
    }
    let I = r4([Z, {
      Accept: "application/json",
      "User-Agent": this.getUserAgent(),
      "X-Stainless-Retry-Count": String(G),
      ...A.timeout ? {
        "X-Stainless-Timeout": String(Math.trunc(A.timeout / 1000))
      } : {},
      ...iOB(),
      ...this._options.dangerouslyAllowBrowser ? {
        "anthropic-dangerous-direct-browser-access": "true"
      } : void 0,
      "anthropic-version": "2023-06-01"
    }, await this.authHeaders(A), this._options.defaultHeaders, B, A.headers]);
    return this.validateHeaders(I), I.values
  }
  buildBody({
    options: {
      body: A,
      headers: Q
    }
  }) {
    if (!A) return {
      bodyHeaders: void 0,
      body: void 0
    };
    let B = r4([Q]);
    if (ArrayBuffer.isView(A) || A instanceof ArrayBuffer || A instanceof DataView || typeof A === "string" && B.values.has("content-type") || globalThis.Blob && A instanceof globalThis.Blob || A instanceof FormData || A instanceof URLSearchParams || globalThis.ReadableStream && A instanceof globalThis.ReadableStream) return {
      bodyHeaders: void 0,
      body: A
    };
    else if (typeof A === "object" && ((Symbol.asyncIterator in A) || (Symbol.iterator in A) && ("next" in A) && typeof A.next === "function")) return {
      bodyHeaders: void 0,
      body: sxA(A)
    };
    else return N0(this, hrA, "f").call(this, {
      body: A,
      headers: B
    })
  }
}
// @from(Start 6773353, End 6773356)
Vd1
// @from(Start 6773358, End 6773361)
Fd1
// @from(Start 6773363, End 6773366)
hrA
// @from(Start 6773368, End 6773371)
VRB
// @from(Start 6773373, End 6773393)
FRB = "\\n\\nHuman:"
// @from(Start 6773397, End 6773421)
KRB = "\\n\\nAssistant:"
// @from(Start 6773425, End 6773427)
MT
// @from(Start 6773433, End 6774506)
Hf = L(() => {
  Kv();
  Jr();
  vm1();
  pC();
  d_();
  cm1();
  a$A();
  OrA();
  Qd1();
  Xd1();
  Ad1();
  Wd1();
  vm1();
  CM();
  AvA();
  Jr();
  Fd1 = FG, hrA = new WeakMap, Vd1 = new WeakSet, VRB = function() {
    return this.baseURL !== "https://api.anthropic.com"
  };
  FG.Anthropic = Fd1;
  FG.HUMAN_PROMPT = FRB;
  FG.AI_PROMPT = KRB;
  FG.DEFAULT_TIMEOUT = 600000;
  FG.AnthropicError = vB;
  FG.APIError = n2;
  FG.APIConnectionError = cC;
  FG.APIConnectionTimeoutError = IS;
  FG.APIUserAbortError = yY;
  FG.NotFoundError = Ir;
  FG.ConflictError = TKA;
  FG.RateLimitError = jKA;
  FG.BadRequestError = OKA;
  FG.AuthenticationError = Zr;
  FG.InternalServerError = SKA;
  FG.PermissionDeniedError = RKA;
  FG.UnprocessableEntityError = PKA;
  FG.toFile = PrA;
  MT = class MT extends FG {
    constructor() {
      super(...arguments);
      this.completions = new Rp(this), this.messages = new Gq(this), this.models = new KGA(this), this.beta = new pH(this)
    }
  };
  MT.Completions = Rp;
  MT.Messages = Gq;
  MT.Models = KGA;
  MT.Beta = pH
})
// @from(Start 6774512, End 6785858)
Dd1 = z((e0G, urA) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var DRB, HRB, CRB, ERB, zRB, URB, $RB, wRB, qRB, grA, Kd1, NRB, LRB, DGA, MRB, ORB, RRB, TRB, PRB, jRB, SRB, _RB, kRB;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof urA === "object" && typeof e0G === "object") A(B(Q, B(e0G)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(B, G) {
      B.__proto__ = G
    } || function(B, G) {
      for (var Z in G)
        if (G.hasOwnProperty(Z)) B[Z] = G[Z]
    };
    DRB = function(B, G) {
      Q(B, G);

      function Z() {
        this.constructor = B
      }
      B.prototype = G === null ? Object.create(G) : (Z.prototype = G.prototype, new Z)
    }, HRB = Object.assign || function(B) {
      for (var G, Z = 1, I = arguments.length; Z < I; Z++) {
        G = arguments[Z];
        for (var Y in G)
          if (Object.prototype.hasOwnProperty.call(G, Y)) B[Y] = G[Y]
      }
      return B
    }, CRB = function(B, G) {
      var Z = {};
      for (var I in B)
        if (Object.prototype.hasOwnProperty.call(B, I) && G.indexOf(I) < 0) Z[I] = B[I];
      if (B != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var Y = 0, I = Object.getOwnPropertySymbols(B); Y < I.length; Y++)
          if (G.indexOf(I[Y]) < 0 && Object.prototype.propertyIsEnumerable.call(B, I[Y])) Z[I[Y]] = B[I[Y]]
      }
      return Z
    }, ERB = function(B, G, Z, I) {
      var Y = arguments.length,
        J = Y < 3 ? G : I === null ? I = Object.getOwnPropertyDescriptor(G, Z) : I,
        W;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") J = Reflect.decorate(B, G, Z, I);
      else
        for (var X = B.length - 1; X >= 0; X--)
          if (W = B[X]) J = (Y < 3 ? W(J) : Y > 3 ? W(G, Z, J) : W(G, Z)) || J;
      return Y > 3 && J && Object.defineProperty(G, Z, J), J
    }, zRB = function(B, G) {
      return function(Z, I) {
        G(Z, I, B)
      }
    }, URB = function(B, G) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(B, G)
    }, $RB = function(B, G, Z, I) {
      function Y(J) {
        return J instanceof Z ? J : new Z(function(W) {
          W(J)
        })
      }
      return new(Z || (Z = Promise))(function(J, W) {
        function X(K) {
          try {
            F(I.next(K))
          } catch (D) {
            W(D)
          }
        }

        function V(K) {
          try {
            F(I.throw(K))
          } catch (D) {
            W(D)
          }
        }

        function F(K) {
          K.done ? J(K.value) : Y(K.value).then(X, V)
        }
        F((I = I.apply(B, G || [])).next())
      })
    }, wRB = function(B, G) {
      var Z = {
          label: 0,
          sent: function() {
            if (J[0] & 1) throw J[1];
            return J[1]
          },
          trys: [],
          ops: []
        },
        I, Y, J, W;
      return W = {
        next: X(0),
        throw: X(1),
        return: X(2)
      }, typeof Symbol === "function" && (W[Symbol.iterator] = function() {
        return this
      }), W;

      function X(F) {
        return function(K) {
          return V([F, K])
        }
      }

      function V(F) {
        if (I) throw TypeError("Generator is already executing.");
        while (Z) try {
          if (I = 1, Y && (J = F[0] & 2 ? Y.return : F[0] ? Y.throw || ((J = Y.return) && J.call(Y), 0) : Y.next) && !(J = J.call(Y, F[1])).done) return J;
          if (Y = 0, J) F = [F[0] & 2, J.value];
          switch (F[0]) {
            case 0:
            case 1:
              J = F;
              break;
            case 4:
              return Z.label++, {
                value: F[1],
                done: !1
              };
            case 5:
              Z.label++, Y = F[1], F = [0];
              continue;
            case 7:
              F = Z.ops.pop(), Z.trys.pop();
              continue;
            default:
              if ((J = Z.trys, !(J = J.length > 0 && J[J.length - 1])) && (F[0] === 6 || F[0] === 2)) {
                Z = 0;
                continue
              }
              if (F[0] === 3 && (!J || F[1] > J[0] && F[1] < J[3])) {
                Z.label = F[1];
                break
              }
              if (F[0] === 6 && Z.label < J[1]) {
                Z.label = J[1], J = F;
                break
              }
              if (J && Z.label < J[2]) {
                Z.label = J[2], Z.ops.push(F);
                break
              }
              if (J[2]) Z.ops.pop();
              Z.trys.pop();
              continue
          }
          F = G.call(B, Z)
        } catch (K) {
          F = [6, K], Y = 0
        } finally {
          I = J = 0
        }
        if (F[0] & 5) throw F[1];
        return {
          value: F[0] ? F[1] : void 0,
          done: !0
        }
      }
    }, kRB = function(B, G, Z, I) {
      if (I === void 0) I = Z;
      B[I] = G[Z]
    }, qRB = function(B, G) {
      for (var Z in B)
        if (Z !== "default" && !G.hasOwnProperty(Z)) G[Z] = B[Z]
    }, grA = function(B) {
      var G = typeof Symbol === "function" && Symbol.iterator,
        Z = G && B[G],
        I = 0;
      if (Z) return Z.call(B);
      if (B && typeof B.length === "number") return {
        next: function() {
          if (B && I >= B.length) B = void 0;
          return {
            value: B && B[I++],
            done: !B
          }
        }
      };
      throw TypeError(G ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, Kd1 = function(B, G) {
      var Z = typeof Symbol === "function" && B[Symbol.iterator];
      if (!Z) return B;
      var I = Z.call(B),
        Y, J = [],
        W;
      try {
        while ((G === void 0 || G-- > 0) && !(Y = I.next()).done) J.push(Y.value)
      } catch (X) {
        W = {
          error: X
        }
      } finally {
        try {
          if (Y && !Y.done && (Z = I.return)) Z.call(I)
        } finally {
          if (W) throw W.error
        }
      }
      return J
    }, NRB = function() {
      for (var B = [], G = 0; G < arguments.length; G++) B = B.concat(Kd1(arguments[G]));
      return B
    }, LRB = function() {
      for (var B = 0, G = 0, Z = arguments.length; G < Z; G++) B += arguments[G].length;
      for (var I = Array(B), Y = 0, G = 0; G < Z; G++)
        for (var J = arguments[G], W = 0, X = J.length; W < X; W++, Y++) I[Y] = J[W];
      return I
    }, DGA = function(B) {
      return this instanceof DGA ? (this.v = B, this) : new DGA(B)
    }, MRB = function(B, G, Z) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var I = Z.apply(B, G || []),
        Y, J = [];
      return Y = {}, W("next"), W("throw"), W("return"), Y[Symbol.asyncIterator] = function() {
        return this
      }, Y;

      function W(H) {
        if (I[H]) Y[H] = function(C) {
          return new Promise(function(E, U) {
            J.push([H, C, E, U]) > 1 || X(H, C)
          })
        }
      }

      function X(H, C) {
        try {
          V(I[H](C))
        } catch (E) {
          D(J[0][3], E)
        }
      }

      function V(H) {
        H.value instanceof DGA ? Promise.resolve(H.value.v).then(F, K) : D(J[0][2], H)
      }

      function F(H) {
        X("next", H)
      }

      function K(H) {
        X("throw", H)
      }

      function D(H, C) {
        if (H(C), J.shift(), J.length) X(J[0][0], J[0][1])
      }
    }, ORB = function(B) {
      var G, Z;
      return G = {}, I("next"), I("throw", function(Y) {
        throw Y
      }), I("return"), G[Symbol.iterator] = function() {
        return this
      }, G;

      function I(Y, J) {
        G[Y] = B[Y] ? function(W) {
          return (Z = !Z) ? {
            value: DGA(B[Y](W)),
            done: Y === "return"
          } : J ? J(W) : W
        } : J
      }
    }, RRB = function(B) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var G = B[Symbol.asyncIterator],
        Z;
      return G ? G.call(B) : (B = typeof grA === "function" ? grA(B) : B[Symbol.iterator](), Z = {}, I("next"), I("throw"), I("return"), Z[Symbol.asyncIterator] = function() {
        return this
      }, Z);

      function I(J) {
        Z[J] = B[J] && function(W) {
          return new Promise(function(X, V) {
            W = B[J](W), Y(X, V, W.done, W.value)
          })
        }
      }

      function Y(J, W, X, V) {
        Promise.resolve(V).then(function(F) {
          J({
            value: F,
            done: X
          })
        }, W)
      }
    }, TRB = function(B, G) {
      if (Object.defineProperty) Object.defineProperty(B, "raw", {
        value: G
      });
      else B.raw = G;
      return B
    }, PRB = function(B) {
      if (B && B.__esModule) return B;
      var G = {};
      if (B != null) {
        for (var Z in B)
          if (Object.hasOwnProperty.call(B, Z)) G[Z] = B[Z]
      }
      return G.default = B, G
    }, jRB = function(B) {
      return B && B.__esModule ? B : {
        default: B
      }
    }, SRB = function(B, G) {
      if (!G.has(B)) throw TypeError("attempted to get private field on non-instance");
      return G.get(B)
    }, _RB = function(B, G, Z) {
      if (!G.has(B)) throw TypeError("attempted to set private field on non-instance");
      return G.set(B, Z), Z
    }, A("__extends", DRB), A("__assign", HRB), A("__rest", CRB), A("__decorate", ERB), A("__param", zRB), A("__metadata", URB), A("__awaiter", $RB), A("__generator", wRB), A("__exportStar", qRB), A("__createBinding", kRB), A("__values", grA), A("__read", Kd1), A("__spread", NRB), A("__spreadArrays", LRB), A("__await", DGA), A("__asyncGenerator", MRB), A("__asyncDelegator", ORB), A("__asyncValues", RRB), A("__makeTemplateObject", TRB), A("__importStar", PRB), A("__importDefault", jRB), A("__classPrivateFieldGet", SRB), A("__classPrivateFieldSet", _RB)
  })
})
// @from(Start 6785864, End 6787034)
Hd1 = z((yRB) => {
  Object.defineProperty(yRB, "__esModule", {
    value: !0
  });
  yRB.MAX_HASHABLE_LENGTH = yRB.INIT = yRB.KEY = yRB.DIGEST_LENGTH = yRB.BLOCK_SIZE = void 0;
  yRB.BLOCK_SIZE = 64;
  yRB.DIGEST_LENGTH = 32;
  yRB.KEY = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
  yRB.INIT = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
  yRB.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1
})
// @from(Start 6787040, End 6790184)
fRB = z((vRB) => {
  Object.defineProperty(vRB, "__esModule", {
    value: !0
  });
  vRB.RawSha256 = void 0;
  var zM = Hd1(),
    Gw6 = function() {
      function A() {
        this.state = Int32Array.from(zM.INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1
      }
      return A.prototype.update = function(Q) {
        if (this.finished) throw Error("Attempted to update an already finished hash.");
        var B = 0,
          G = Q.byteLength;
        if (this.bytesHashed += G, this.bytesHashed * 8 > zM.MAX_HASHABLE_LENGTH) throw Error("Cannot hash more than 2^53 - 1 bits");
        while (G > 0)
          if (this.buffer[this.bufferLength++] = Q[B++], G--, this.bufferLength === zM.BLOCK_SIZE) this.hashBuffer(), this.bufferLength = 0
      }, A.prototype.digest = function() {
        if (!this.finished) {
          var Q = this.bytesHashed * 8,
            B = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength),
            G = this.bufferLength;
          if (B.setUint8(this.bufferLength++, 128), G % zM.BLOCK_SIZE >= zM.BLOCK_SIZE - 8) {
            for (var Z = this.bufferLength; Z < zM.BLOCK_SIZE; Z++) B.setUint8(Z, 0);
            this.hashBuffer(), this.bufferLength = 0
          }
          for (var Z = this.bufferLength; Z < zM.BLOCK_SIZE - 8; Z++) B.setUint8(Z, 0);
          B.setUint32(zM.BLOCK_SIZE - 8, Math.floor(Q / 4294967296), !0), B.setUint32(zM.BLOCK_SIZE - 4, Q), this.hashBuffer(), this.finished = !0
        }
        var I = new Uint8Array(zM.DIGEST_LENGTH);
        for (var Z = 0; Z < 8; Z++) I[Z * 4] = this.state[Z] >>> 24 & 255, I[Z * 4 + 1] = this.state[Z] >>> 16 & 255, I[Z * 4 + 2] = this.state[Z] >>> 8 & 255, I[Z * 4 + 3] = this.state[Z] >>> 0 & 255;
        return I
      }, A.prototype.hashBuffer = function() {
        var Q = this,
          B = Q.buffer,
          G = Q.state,
          Z = G[0],
          I = G[1],
          Y = G[2],
          J = G[3],
          W = G[4],
          X = G[5],
          V = G[6],
          F = G[7];
        for (var K = 0; K < zM.BLOCK_SIZE; K++) {
          if (K < 16) this.temp[K] = (B[K * 4] & 255) << 24 | (B[K * 4 + 1] & 255) << 16 | (B[K * 4 + 2] & 255) << 8 | B[K * 4 + 3] & 255;
          else {
            var D = this.temp[K - 2],
              H = (D >>> 17 | D << 15) ^ (D >>> 19 | D << 13) ^ D >>> 10;
            D = this.temp[K - 15];
            var C = (D >>> 7 | D << 25) ^ (D >>> 18 | D << 14) ^ D >>> 3;
            this.temp[K] = (H + this.temp[K - 7] | 0) + (C + this.temp[K - 16] | 0)
          }
          var E = (((W >>> 6 | W << 26) ^ (W >>> 11 | W << 21) ^ (W >>> 25 | W << 7)) + (W & X ^ ~W & V) | 0) + (F + (zM.KEY[K] + this.temp[K] | 0) | 0) | 0,
            U = ((Z >>> 2 | Z << 30) ^ (Z >>> 13 | Z << 19) ^ (Z >>> 22 | Z << 10)) + (Z & I ^ Z & Y ^ I & Y) | 0;
          F = V, V = X, X = W, W = J + E | 0, J = Y, Y = I, I = Z, Z = E + U | 0
        }
        G[0] += Z, G[1] += I, G[2] += Y, G[3] += J, G[4] += W, G[5] += X, G[6] += V, G[7] += F
      }, A
    }();
  vRB.RawSha256 = Gw6
})
// @from(Start 6790190, End 6791478)
uRB = z((hRB) => {
  Object.defineProperty(hRB, "__esModule", {
    value: !0
  });
  hRB.toUtf8 = hRB.fromUtf8 = void 0;
  var Zw6 = (A) => {
    let Q = [];
    for (let B = 0, G = A.length; B < G; B++) {
      let Z = A.charCodeAt(B);
      if (Z < 128) Q.push(Z);
      else if (Z < 2048) Q.push(Z >> 6 | 192, Z & 63 | 128);
      else if (B + 1 < A.length && (Z & 64512) === 55296 && (A.charCodeAt(B + 1) & 64512) === 56320) {
        let I = 65536 + ((Z & 1023) << 10) + (A.charCodeAt(++B) & 1023);
        Q.push(I >> 18 | 240, I >> 12 & 63 | 128, I >> 6 & 63 | 128, I & 63 | 128)
      } else Q.push(Z >> 12 | 224, Z >> 6 & 63 | 128, Z & 63 | 128)
    }
    return Uint8Array.from(Q)
  };
  hRB.fromUtf8 = Zw6;
  var Iw6 = (A) => {
    let Q = "";
    for (let B = 0, G = A.length; B < G; B++) {
      let Z = A[B];
      if (Z < 128) Q += String.fromCharCode(Z);
      else if (192 <= Z && Z < 224) {
        let I = A[++B];
        Q += String.fromCharCode((Z & 31) << 6 | I & 63)
      } else if (240 <= Z && Z < 365) {
        let Y = "%" + [Z, A[++B], A[++B], A[++B]].map((J) => J.toString(16)).join("%");
        Q += decodeURIComponent(Y)
      } else Q += String.fromCharCode((Z & 15) << 12 | (A[++B] & 63) << 6 | A[++B] & 63)
    }
    return Q
  };
  hRB.toUtf8 = Iw6
})
// @from(Start 6791484, End 6791784)
cRB = z((mRB) => {
  Object.defineProperty(mRB, "__esModule", {
    value: !0
  });
  mRB.toUtf8 = mRB.fromUtf8 = void 0;

  function Jw6(A) {
    return new TextEncoder().encode(A)
  }
  mRB.fromUtf8 = Jw6;

  function Ww6(A) {
    return new TextDecoder("utf-8").decode(A)
  }
  mRB.toUtf8 = Ww6
})
// @from(Start 6791790, End 6792185)
Cd1 = z((iRB) => {
  Object.defineProperty(iRB, "__esModule", {
    value: !0
  });
  iRB.toUtf8 = iRB.fromUtf8 = void 0;
  var pRB = uRB(),
    lRB = cRB(),
    Vw6 = (A) => typeof TextEncoder === "function" ? (0, lRB.fromUtf8)(A) : (0, pRB.fromUtf8)(A);
  iRB.fromUtf8 = Vw6;
  var Fw6 = (A) => typeof TextDecoder === "function" ? (0, lRB.toUtf8)(A) : (0, pRB.toUtf8)(A);
  iRB.toUtf8 = Fw6
})
// @from(Start 6792191, End 6792741)
rRB = z((aRB) => {
  Object.defineProperty(aRB, "__esModule", {
    value: !0
  });
  aRB.convertToBuffer = void 0;
  var Dw6 = Cd1(),
    Hw6 = typeof Buffer < "u" && Buffer.from ? function(A) {
      return Buffer.from(A, "utf8")
    } : Dw6.fromUtf8;

  function Cw6(A) {
    if (A instanceof Uint8Array) return A;
    if (typeof A === "string") return Hw6(A);
    if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    return new Uint8Array(A)
  }
  aRB.convertToBuffer = Cw6
})
// @from(Start 6792747, End 6792994)
eRB = z((oRB) => {
  Object.defineProperty(oRB, "__esModule", {
    value: !0
  });
  oRB.isEmptyData = void 0;

  function Ew6(A) {
    if (typeof A === "string") return A.length === 0;
    return A.byteLength === 0
  }
  oRB.isEmptyData = Ew6
})
// @from(Start 6793000, End 6793262)
BTB = z((ATB) => {
  Object.defineProperty(ATB, "__esModule", {
    value: !0
  });
  ATB.numToUint8 = void 0;

  function zw6(A) {
    return new Uint8Array([(A & 4278190080) >> 24, (A & 16711680) >> 16, (A & 65280) >> 8, A & 255])
  }
  ATB.numToUint8 = zw6
})
// @from(Start 6793268, End 6793624)
ITB = z((GTB) => {
  Object.defineProperty(GTB, "__esModule", {
    value: !0
  });
  GTB.uint32ArrayFrom = void 0;

  function Uw6(A) {
    if (!Uint32Array.from) {
      var Q = new Uint32Array(A.length),
        B = 0;
      while (B < A.length) Q[B] = A[B], B += 1;
      return Q
    }
    return Uint32Array.from(A)
  }
  GTB.uint32ArrayFrom = Uw6
})
// @from(Start 6793630, End 6794410)
YTB = z((HGA) => {
  Object.defineProperty(HGA, "__esModule", {
    value: !0
  });
  HGA.uint32ArrayFrom = HGA.numToUint8 = HGA.isEmptyData = HGA.convertToBuffer = void 0;
  var $w6 = rRB();
  Object.defineProperty(HGA, "convertToBuffer", {
    enumerable: !0,
    get: function() {
      return $w6.convertToBuffer
    }
  });
  var ww6 = eRB();
  Object.defineProperty(HGA, "isEmptyData", {
    enumerable: !0,
    get: function() {
      return ww6.isEmptyData
    }
  });
  var qw6 = BTB();
  Object.defineProperty(HGA, "numToUint8", {
    enumerable: !0,
    get: function() {
      return qw6.numToUint8
    }
  });
  var Nw6 = ITB();
  Object.defineProperty(HGA, "uint32ArrayFrom", {
    enumerable: !0,
    get: function() {
      return Nw6.uint32ArrayFrom
    }
  })
})
// @from(Start 6794416, End 6796177)
VTB = z((WTB) => {
  Object.defineProperty(WTB, "__esModule", {
    value: !0
  });
  WTB.Sha256 = void 0;
  var JTB = Dd1(),
    drA = Hd1(),
    mrA = fRB(),
    Ed1 = YTB(),
    Mw6 = function() {
      function A(Q) {
        this.secret = Q, this.hash = new mrA.RawSha256, this.reset()
      }
      return A.prototype.update = function(Q) {
        if ((0, Ed1.isEmptyData)(Q) || this.error) return;
        try {
          this.hash.update((0, Ed1.convertToBuffer)(Q))
        } catch (B) {
          this.error = B
        }
      }, A.prototype.digestSync = function() {
        if (this.error) throw this.error;
        if (this.outer) {
          if (!this.outer.finished) this.outer.update(this.hash.digest());
          return this.outer.digest()
        }
        return this.hash.digest()
      }, A.prototype.digest = function() {
        return JTB.__awaiter(this, void 0, void 0, function() {
          return JTB.__generator(this, function(Q) {
            return [2, this.digestSync()]
          })
        })
      }, A.prototype.reset = function() {
        if (this.hash = new mrA.RawSha256, this.secret) {
          this.outer = new mrA.RawSha256;
          var Q = Ow6(this.secret),
            B = new Uint8Array(drA.BLOCK_SIZE);
          B.set(Q);
          for (var G = 0; G < drA.BLOCK_SIZE; G++) Q[G] ^= 54, B[G] ^= 92;
          this.hash.update(Q), this.outer.update(B);
          for (var G = 0; G < Q.byteLength; G++) Q[G] = 0
        }
      }, A
    }();
  WTB.Sha256 = Mw6;

  function Ow6(A) {
    var Q = (0, Ed1.convertToBuffer)(A);
    if (Q.byteLength > drA.BLOCK_SIZE) {
      var B = new mrA.RawSha256;
      B.update(Q), Q = B.digest()
    }
    var G = new Uint8Array(drA.BLOCK_SIZE);
    return G.set(Q), G
  }
})
// @from(Start 6796183, End 6796319)
FTB = z((zd1) => {
  Object.defineProperty(zd1, "__esModule", {
    value: !0
  });
  var Rw6 = Dd1();
  Rw6.__exportStar(VTB(), zd1)
})
// @from(Start 6796325, End 6799108)
qTB = z((CQG, wTB) => {
  var {
    defineProperty: crA,
    getOwnPropertyDescriptor: Tw6,
    getOwnPropertyNames: Pw6
  } = Object, jw6 = Object.prototype.hasOwnProperty, prA = (A, Q) => crA(A, "name", {
    value: Q,
    configurable: !0
  }), Sw6 = (A, Q) => {
    for (var B in Q) crA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, _w6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Pw6(Q))
        if (!jw6.call(A, Z) && Z !== B) crA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Tw6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, kw6 = (A) => _w6(crA({}, "__esModule", {
    value: !0
  }), A), KTB = {};
  Sw6(KTB, {
    AlgorithmId: () => ETB,
    EndpointURLScheme: () => CTB,
    FieldPosition: () => zTB,
    HttpApiKeyAuthLocation: () => HTB,
    HttpAuthLocation: () => DTB,
    IniSectionType: () => UTB,
    RequestHandlerProtocol: () => $TB,
    SMITHY_CONTEXT_KEY: () => fw6,
    getDefaultClientConfiguration: () => vw6,
    resolveDefaultRuntimeConfig: () => bw6
  });
  wTB.exports = kw6(KTB);
  var DTB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(DTB || {}),
    HTB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(HTB || {}),
    CTB = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(CTB || {}),
    ETB = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(ETB || {}),
    yw6 = prA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    xw6 = prA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    vw6 = prA((A) => {
      return yw6(A)
    }, "getDefaultClientConfiguration"),
    bw6 = prA((A) => {
      return xw6(A)
    }, "resolveDefaultRuntimeConfig"),
    zTB = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(zTB || {}),
    fw6 = "__smithy_context",
    UTB = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(UTB || {}),
    $TB = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })($TB || {})
})
// @from(Start 6799114, End 6803621)
TTB = z((EQG, RTB) => {
  var {
    defineProperty: lrA,
    getOwnPropertyDescriptor: hw6,
    getOwnPropertyNames: gw6
  } = Object, uw6 = Object.prototype.hasOwnProperty, Pp = (A, Q) => lrA(A, "name", {
    value: Q,
    configurable: !0
  }), mw6 = (A, Q) => {
    for (var B in Q) lrA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, dw6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gw6(Q))
        if (!uw6.call(A, Z) && Z !== B) lrA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = hw6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, cw6 = (A) => dw6(lrA({}, "__esModule", {
    value: !0
  }), A), NTB = {};
  mw6(NTB, {
    Field: () => iw6,
    Fields: () => nw6,
    HttpRequest: () => aw6,
    HttpResponse: () => sw6,
    IHttpRequest: () => LTB.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => pw6,
    isValidHostname: () => OTB,
    resolveHttpHandlerRuntimeConfig: () => lw6
  });
  RTB.exports = cw6(NTB);
  var pw6 = Pp((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    lw6 = Pp((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    LTB = qTB(),
    iw6 = class {
      static {
        Pp(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = LTB.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    nw6 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        Pp(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    aw6 = class A {
      static {
        Pp(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = MTB(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function MTB(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  Pp(MTB, "cloneQuery");
  var sw6 = class {
    static {
      Pp(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function OTB(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  Pp(OTB, "isValidHostname")
})
// @from(Start 6803627, End 6804680)
_TB = z((wQG, STB) => {
  var {
    defineProperty: irA,
    getOwnPropertyDescriptor: rw6,
    getOwnPropertyNames: ow6
  } = Object, tw6 = Object.prototype.hasOwnProperty, Ud1 = (A, Q) => irA(A, "name", {
    value: Q,
    configurable: !0
  }), ew6 = (A, Q) => {
    for (var B in Q) irA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Aq6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ow6(Q))
        if (!tw6.call(A, Z) && Z !== B) irA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = rw6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Qq6 = (A) => Aq6(irA({}, "__esModule", {
    value: !0
  }), A), PTB = {};
  ew6(PTB, {
    escapeUri: () => jTB,
    escapeUriPath: () => Gq6
  });
  STB.exports = Qq6(PTB);
  var jTB = Ud1((A) => encodeURIComponent(A).replace(/[!'()*]/g, Bq6), "escapeUri"),
    Bq6 = Ud1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    Gq6 = Ud1((A) => A.split("/").map(jTB).join("/"), "escapeUriPath")
})
// @from(Start 6804686, End 6805937)
vTB = z((qQG, xTB) => {
  var {
    defineProperty: nrA,
    getOwnPropertyDescriptor: Zq6,
    getOwnPropertyNames: Iq6
  } = Object, Yq6 = Object.prototype.hasOwnProperty, Jq6 = (A, Q) => nrA(A, "name", {
    value: Q,
    configurable: !0
  }), Wq6 = (A, Q) => {
    for (var B in Q) nrA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Xq6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Iq6(Q))
        if (!Yq6.call(A, Z) && Z !== B) nrA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Zq6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Vq6 = (A) => Xq6(nrA({}, "__esModule", {
    value: !0
  }), A), kTB = {};
  Wq6(kTB, {
    buildQueryString: () => yTB
  });
  xTB.exports = Vq6(kTB);
  var $d1 = _TB();

  function yTB(A) {
    let Q = [];
    for (let B of Object.keys(A).sort()) {
      let G = A[B];
      if (B = (0, $d1.escapeUri)(B), Array.isArray(G))
        for (let Z = 0, I = G.length; Z < I; Z++) Q.push(`${B}=${(0,$d1.escapeUri)(G[Z])}`);
      else {
        let Z = B;
        if (G || typeof G === "string") Z += `=${(0,$d1.escapeUri)(G)}`;
        Q.push(Z)
      }
    }
    return Q.join("&")
  }
  Jq6(yTB, "buildQueryString")
})
// @from(Start 6805943, End 6806430)
hTB = z((bTB) => {
  Object.defineProperty(bTB, "__esModule", {
    value: !0
  });
  bTB.fromBase64 = void 0;
  var Fq6 = hI(),
    Kq6 = /^[A-Za-z0-9+/]*={0,2}$/,
    Dq6 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!Kq6.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, Fq6.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  bTB.fromBase64 = Dq6
})
// @from(Start 6806436, End 6807015)
mTB = z((gTB) => {
  Object.defineProperty(gTB, "__esModule", {
    value: !0
  });
  gTB.toBase64 = void 0;
  var Hq6 = hI(),
    Cq6 = O2(),
    Eq6 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, Cq6.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, Hq6.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  gTB.toBase64 = Eq6
})
// @from(Start 6807021, End 6807717)
pTB = z((MQG, arA) => {
  var {
    defineProperty: dTB,
    getOwnPropertyDescriptor: zq6,
    getOwnPropertyNames: Uq6
  } = Object, $q6 = Object.prototype.hasOwnProperty, wd1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Uq6(Q))
        if (!$q6.call(A, Z) && Z !== B) dTB(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = zq6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, cTB = (A, Q, B) => (wd1(A, Q, "default"), B && wd1(B, Q, "default")), wq6 = (A) => wd1(dTB({}, "__esModule", {
    value: !0
  }), A), qd1 = {};
  arA.exports = wq6(qd1);
  cTB(qd1, hTB(), arA.exports);
  cTB(qd1, mTB(), arA.exports)
})
// @from(Start 6807723, End 6813688)
Ld1 = z((OQG, oTB) => {
  var {
    defineProperty: rrA,
    getOwnPropertyDescriptor: qq6,
    getOwnPropertyNames: Nq6
  } = Object, Lq6 = Object.prototype.hasOwnProperty, c_ = (A, Q) => rrA(A, "name", {
    value: Q,
    configurable: !0
  }), Mq6 = (A, Q) => {
    for (var B in Q) rrA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Oq6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Nq6(Q))
        if (!Lq6.call(A, Z) && Z !== B) rrA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qq6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Rq6 = (A) => Oq6(rrA({}, "__esModule", {
    value: !0
  }), A), iTB = {};
  Mq6(iTB, {
    FetchHttpHandler: () => Pq6,
    keepAliveSupport: () => srA,
    streamCollector: () => Sq6
  });
  oTB.exports = Rq6(iTB);
  var lTB = TTB(),
    Tq6 = vTB();

  function Nd1(A, Q) {
    return new Request(A, Q)
  }
  c_(Nd1, "createRequest");

  function nTB(A = 0) {
    return new Promise((Q, B) => {
      if (A) setTimeout(() => {
        let G = Error(`Request did not complete within ${A} ms`);
        G.name = "TimeoutError", B(G)
      }, A)
    })
  }
  c_(nTB, "requestTimeout");
  var srA = {
      supported: void 0
    },
    Pq6 = class A {
      static {
        c_(this, "FetchHttpHandler")
      }
      static create(Q) {
        if (typeof Q?.handle === "function") return Q;
        return new A(Q)
      }
      constructor(Q) {
        if (typeof Q === "function") this.configProvider = Q().then((B) => B || {});
        else this.config = Q ?? {}, this.configProvider = Promise.resolve(this.config);
        if (srA.supported === void 0) srA.supported = Boolean(typeof Request < "u" && "keepalive" in Nd1("https://[::1]"))
      }
      destroy() {}
      async handle(Q, {
        abortSignal: B
      } = {}) {
        if (!this.config) this.config = await this.configProvider;
        let G = this.config.requestTimeout,
          Z = this.config.keepAlive === !0,
          I = this.config.credentials;
        if (B?.aborted) {
          let U = Error("Request aborted");
          return U.name = "AbortError", Promise.reject(U)
        }
        let Y = Q.path,
          J = (0, Tq6.buildQueryString)(Q.query || {});
        if (J) Y += `?${J}`;
        if (Q.fragment) Y += `#${Q.fragment}`;
        let W = "";
        if (Q.username != null || Q.password != null) {
          let U = Q.username ?? "",
            q = Q.password ?? "";
          W = `${U}:${q}@`
        }
        let {
          port: X,
          method: V
        } = Q, F = `${Q.protocol}//${W}${Q.hostname}${X?`:${X}`:""}${Y}`, K = V === "GET" || V === "HEAD" ? void 0 : Q.body, D = {
          body: K,
          headers: new Headers(Q.headers),
          method: V,
          credentials: I
        };
        if (this.config?.cache) D.cache = this.config.cache;
        if (K) D.duplex = "half";
        if (typeof AbortController < "u") D.signal = B;
        if (srA.supported) D.keepalive = Z;
        if (typeof this.config.requestInit === "function") Object.assign(D, this.config.requestInit(Q));
        let H = c_(() => {}, "removeSignalEventListener"),
          C = Nd1(F, D),
          E = [fetch(C).then((U) => {
            let q = U.headers,
              w = {};
            for (let R of q.entries()) w[R[0]] = R[1];
            if (U.body == null) return U.blob().then((R) => ({
              response: new lTB.HttpResponse({
                headers: w,
                reason: U.statusText,
                statusCode: U.status,
                body: R
              })
            }));
            return {
              response: new lTB.HttpResponse({
                headers: w,
                reason: U.statusText,
                statusCode: U.status,
                body: U.body
              })
            }
          }), nTB(G)];
        if (B) E.push(new Promise((U, q) => {
          let w = c_(() => {
            let N = Error("Request aborted");
            N.name = "AbortError", q(N)
          }, "onAbort");
          if (typeof B.addEventListener === "function") {
            let N = B;
            N.addEventListener("abort", w, {
              once: !0
            }), H = c_(() => N.removeEventListener("abort", w), "removeSignalEventListener")
          } else B.onabort = w
        }));
        return Promise.race(E).finally(H)
      }
      updateHttpClientConfig(Q, B) {
        this.config = void 0, this.configProvider = this.configProvider.then((G) => {
          return G[Q] = B, G
        })
      }
      httpHandlerConfigs() {
        return this.config ?? {}
      }
    },
    jq6 = pTB(),
    Sq6 = c_(async (A) => {
      if (typeof Blob === "function" && A instanceof Blob || A.constructor?.name === "Blob") {
        if (Blob.prototype.arrayBuffer !== void 0) return new Uint8Array(await A.arrayBuffer());
        return aTB(A)
      }
      return sTB(A)
    }, "streamCollector");
  async function aTB(A) {
    let Q = await rTB(A),
      B = (0, jq6.fromBase64)(Q);
    return new Uint8Array(B)
  }
  c_(aTB, "collectBlob");
  async function sTB(A) {
    let Q = [],
      B = A.getReader(),
      G = !1,
      Z = 0;
    while (!G) {
      let {
        done: J,
        value: W
      } = await B.read();
      if (W) Q.push(W), Z += W.length;
      G = J
    }
    let I = new Uint8Array(Z),
      Y = 0;
    for (let J of Q) I.set(J, Y), Y += J.length;
    return I
  }
  c_(sTB, "collectStream");

  function rTB(A) {
    return new Promise((Q, B) => {
      let G = new FileReader;
      G.onloadend = () => {
        if (G.readyState !== 2) return B(Error("Reader aborted too early"));
        let Z = G.result ?? "",
          I = Z.indexOf(","),
          Y = I > -1 ? I + 1 : Z.length;
        Q(Z.substring(Y))
      }, G.onabort = () => B(Error("Read aborted")), G.onerror = () => B(G.error), G.readAsDataURL(A)
    })
  }
  c_(rTB, "readToBase64")
})
// @from(Start 6813694, End 6816597)
Md1 = z((RQG, YPB) => {
  var {
    defineProperty: orA,
    getOwnPropertyDescriptor: _q6,
    getOwnPropertyNames: kq6
  } = Object, yq6 = Object.prototype.hasOwnProperty, trA = (A, Q) => orA(A, "name", {
    value: Q,
    configurable: !0
  }), xq6 = (A, Q) => {
    for (var B in Q) orA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vq6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of kq6(Q))
        if (!yq6.call(A, Z) && Z !== B) orA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _q6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bq6 = (A) => vq6(orA({}, "__esModule", {
    value: !0
  }), A), tTB = {};
  xq6(tTB, {
    AlgorithmId: () => BPB,
    EndpointURLScheme: () => QPB,
    FieldPosition: () => GPB,
    HttpApiKeyAuthLocation: () => APB,
    HttpAuthLocation: () => eTB,
    IniSectionType: () => ZPB,
    RequestHandlerProtocol: () => IPB,
    SMITHY_CONTEXT_KEY: () => mq6,
    getDefaultClientConfiguration: () => gq6,
    resolveDefaultRuntimeConfig: () => uq6
  });
  YPB.exports = bq6(tTB);
  var eTB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(eTB || {}),
    APB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(APB || {}),
    QPB = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(QPB || {}),
    BPB = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(BPB || {}),
    fq6 = trA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        _checksumAlgorithms: Q,
        addChecksumAlgorithm(B) {
          this._checksumAlgorithms.push(B)
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms
        }
      }
    }, "getChecksumConfiguration"),
    hq6 = trA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    gq6 = trA((A) => {
      return {
        ...fq6(A)
      }
    }, "getDefaultClientConfiguration"),
    uq6 = trA((A) => {
      return {
        ...hq6(A)
      }
    }, "resolveDefaultRuntimeConfig"),
    GPB = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(GPB || {}),
    mq6 = "__smithy_context",
    ZPB = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(ZPB || {}),
    IPB = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(IPB || {})
})
// @from(Start 6816603, End 6820952)
Od1 = z((TQG, HPB) => {
  var {
    defineProperty: erA,
    getOwnPropertyDescriptor: dq6,
    getOwnPropertyNames: cq6
  } = Object, pq6 = Object.prototype.hasOwnProperty, jp = (A, Q) => erA(A, "name", {
    value: Q,
    configurable: !0
  }), lq6 = (A, Q) => {
    for (var B in Q) erA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, iq6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of cq6(Q))
        if (!pq6.call(A, Z) && Z !== B) erA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = dq6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, nq6 = (A) => iq6(erA({}, "__esModule", {
    value: !0
  }), A), JPB = {};
  lq6(JPB, {
    Field: () => oq6,
    Fields: () => tq6,
    HttpRequest: () => eq6,
    HttpResponse: () => AN6,
    getHttpHandlerExtensionConfiguration: () => aq6,
    isValidHostname: () => DPB,
    resolveHttpHandlerRuntimeConfig: () => sq6
  });
  HPB.exports = nq6(JPB);
  var aq6 = jp((A) => {
      let Q = A.httpHandler;
      return {
        setHttpHandler(B) {
          Q = B
        },
        httpHandler() {
          return Q
        },
        updateHttpClientConfig(B, G) {
          Q.updateHttpClientConfig(B, G)
        },
        httpHandlerConfigs() {
          return Q.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    sq6 = jp((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    rq6 = Md1(),
    WPB = class {
      constructor({
        name: Q,
        kind: B = rq6.FieldPosition.HEADER,
        values: G = []
      }) {
        this.name = Q, this.kind = B, this.values = G
      }
      add(Q) {
        this.values.push(Q)
      }
      set(Q) {
        this.values = Q
      }
      remove(Q) {
        this.values = this.values.filter((B) => B !== Q)
      }
      toString() {
        return this.values.map((Q) => Q.includes(",") || Q.includes(" ") ? `"${Q}"` : Q).join(", ")
      }
      get() {
        return this.values
      }
    };
  jp(WPB, "Field");
  var oq6 = WPB,
    XPB = class {
      constructor({
        fields: Q = [],
        encoding: B = "utf-8"
      }) {
        this.entries = {}, Q.forEach(this.setField.bind(this)), this.encoding = B
      }
      setField(Q) {
        this.entries[Q.name.toLowerCase()] = Q
      }
      getField(Q) {
        return this.entries[Q.toLowerCase()]
      }
      removeField(Q) {
        delete this.entries[Q.toLowerCase()]
      }
      getByType(Q) {
        return Object.values(this.entries).filter((B) => B.kind === Q)
      }
    };
  jp(XPB, "Fields");
  var tq6 = XPB,
    VPB = class A {
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        let Q = new A({
          ...this,
          headers: {
            ...this.headers
          }
        });
        if (Q.query) Q.query = FPB(Q.query);
        return Q
      }
    };
  jp(VPB, "HttpRequest");
  var eq6 = VPB;

  function FPB(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  jp(FPB, "cloneQuery");
  var KPB = class {
    constructor(Q) {
      this.statusCode = Q.statusCode, this.reason = Q.reason, this.headers = Q.headers || {}, this.body = Q.body
    }
    static isInstance(Q) {
      if (!Q) return !1;
      let B = Q;
      return typeof B.statusCode === "number" && typeof B.headers === "object"
    }
  };
  jp(KPB, "HttpResponse");
  var AN6 = KPB;

  function DPB(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  jp(DPB, "isValidHostname")
})
// @from(Start 6820958, End 6823861)
MPB = z((PQG, LPB) => {
  var {
    defineProperty: AoA,
    getOwnPropertyDescriptor: QN6,
    getOwnPropertyNames: BN6
  } = Object, GN6 = Object.prototype.hasOwnProperty, QoA = (A, Q) => AoA(A, "name", {
    value: Q,
    configurable: !0
  }), ZN6 = (A, Q) => {
    for (var B in Q) AoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, IN6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of BN6(Q))
        if (!GN6.call(A, Z) && Z !== B) AoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = QN6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, YN6 = (A) => IN6(AoA({}, "__esModule", {
    value: !0
  }), A), CPB = {};
  ZN6(CPB, {
    AlgorithmId: () => $PB,
    EndpointURLScheme: () => UPB,
    FieldPosition: () => wPB,
    HttpApiKeyAuthLocation: () => zPB,
    HttpAuthLocation: () => EPB,
    IniSectionType: () => qPB,
    RequestHandlerProtocol: () => NPB,
    SMITHY_CONTEXT_KEY: () => FN6,
    getDefaultClientConfiguration: () => XN6,
    resolveDefaultRuntimeConfig: () => VN6
  });
  LPB.exports = YN6(CPB);
  var EPB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(EPB || {}),
    zPB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(zPB || {}),
    UPB = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(UPB || {}),
    $PB = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })($PB || {}),
    JN6 = QoA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        _checksumAlgorithms: Q,
        addChecksumAlgorithm(B) {
          this._checksumAlgorithms.push(B)
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms
        }
      }
    }, "getChecksumConfiguration"),
    WN6 = QoA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    XN6 = QoA((A) => {
      return {
        ...JN6(A)
      }
    }, "getDefaultClientConfiguration"),
    VN6 = QoA((A) => {
      return {
        ...WN6(A)
      }
    }, "resolveDefaultRuntimeConfig"),
    wPB = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(wPB || {}),
    FN6 = "__smithy_context",
    qPB = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(qPB || {}),
    NPB = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(NPB || {})
})
// @from(Start 6823867, End 6824965)
jPB = z((jQG, PPB) => {
  var {
    defineProperty: BoA,
    getOwnPropertyDescriptor: KN6,
    getOwnPropertyNames: DN6
  } = Object, HN6 = Object.prototype.hasOwnProperty, RPB = (A, Q) => BoA(A, "name", {
    value: Q,
    configurable: !0
  }), CN6 = (A, Q) => {
    for (var B in Q) BoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, EN6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of DN6(Q))
        if (!HN6.call(A, Z) && Z !== B) BoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = KN6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, zN6 = (A) => EN6(BoA({}, "__esModule", {
    value: !0
  }), A), TPB = {};
  CN6(TPB, {
    getSmithyContext: () => UN6,
    normalizeProvider: () => $N6
  });
  PPB.exports = zN6(TPB);
  var OPB = MPB(),
    UN6 = RPB((A) => A[OPB.SMITHY_CONTEXT_KEY] || (A[OPB.SMITHY_CONTEXT_KEY] = {}), "getSmithyContext"),
    $N6 = RPB((A) => {
      if (typeof A === "function") return A;
      let Q = Promise.resolve(A);
      return () => Q
    }, "normalizeProvider")
})
// @from(Start 6824971, End 6825924)
Rd1 = z((SQG, _PB) => {
  var {
    defineProperty: GoA,
    getOwnPropertyDescriptor: wN6,
    getOwnPropertyNames: qN6
  } = Object, NN6 = Object.prototype.hasOwnProperty, LN6 = (A, Q) => GoA(A, "name", {
    value: Q,
    configurable: !0
  }), MN6 = (A, Q) => {
    for (var B in Q) GoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ON6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of qN6(Q))
        if (!NN6.call(A, Z) && Z !== B) GoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = wN6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, RN6 = (A) => ON6(GoA({}, "__esModule", {
    value: !0
  }), A), SPB = {};
  MN6(SPB, {
    isArrayBuffer: () => TN6
  });
  _PB.exports = RN6(SPB);
  var TN6 = LN6((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 6825930, End 6827276)
vPB = z((_QG, xPB) => {
  var {
    defineProperty: ZoA,
    getOwnPropertyDescriptor: PN6,
    getOwnPropertyNames: jN6
  } = Object, SN6 = Object.prototype.hasOwnProperty, kPB = (A, Q) => ZoA(A, "name", {
    value: Q,
    configurable: !0
  }), _N6 = (A, Q) => {
    for (var B in Q) ZoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, kN6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of jN6(Q))
        if (!SN6.call(A, Z) && Z !== B) ZoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = PN6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, yN6 = (A) => kN6(ZoA({}, "__esModule", {
    value: !0
  }), A), yPB = {};
  _N6(yPB, {
    fromArrayBuffer: () => vN6,
    fromString: () => bN6
  });
  xPB.exports = yN6(yPB);
  var xN6 = Rd1(),
    Td1 = UA("buffer"),
    vN6 = kPB((A, Q = 0, B = A.byteLength - Q) => {
      if (!(0, xN6.isArrayBuffer)(A)) throw TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof A} (${A})`);
      return Td1.Buffer.from(A, Q, B)
    }, "fromArrayBuffer"),
    bN6 = kPB((A, Q) => {
      if (typeof A !== "string") throw TypeError(`The "input" argument must be of type string. Received type ${typeof A} (${A})`);
      return Q ? Td1.Buffer.from(A, Q) : Td1.Buffer.from(A)
    }, "fromString")
})
// @from(Start 6827282, End 6828945)
r$A = z((kQG, gPB) => {
  var {
    defineProperty: IoA,
    getOwnPropertyDescriptor: fN6,
    getOwnPropertyNames: hN6
  } = Object, gN6 = Object.prototype.hasOwnProperty, Pd1 = (A, Q) => IoA(A, "name", {
    value: Q,
    configurable: !0
  }), uN6 = (A, Q) => {
    for (var B in Q) IoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, mN6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of hN6(Q))
        if (!gN6.call(A, Z) && Z !== B) IoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = fN6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, dN6 = (A) => mN6(IoA({}, "__esModule", {
    value: !0
  }), A), bPB = {};
  uN6(bPB, {
    fromUtf8: () => hPB,
    toUint8Array: () => cN6,
    toUtf8: () => pN6
  });
  gPB.exports = dN6(bPB);
  var fPB = vPB(),
    hPB = Pd1((A) => {
      let Q = (0, fPB.fromString)(A, "utf8");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength / Uint8Array.BYTES_PER_ELEMENT)
    }, "fromUtf8"),
    cN6 = Pd1((A) => {
      if (typeof A === "string") return hPB(A);
      if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      return new Uint8Array(A)
    }, "toUint8Array"),
    pN6 = Pd1((A) => {
      if (typeof A === "string") return A;
      if (typeof A !== "object" || typeof A.byteOffset !== "number" || typeof A.byteLength !== "number") throw Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      return (0, fPB.fromArrayBuffer)(A.buffer, A.byteOffset, A.byteLength).toString("utf8")
    }, "toUtf8")
})
// @from(Start 6828951, End 6830477)
iPB = z((yQG, lPB) => {
  var {
    defineProperty: YoA,
    getOwnPropertyDescriptor: lN6,
    getOwnPropertyNames: iN6
  } = Object, nN6 = Object.prototype.hasOwnProperty, uPB = (A, Q) => YoA(A, "name", {
    value: Q,
    configurable: !0
  }), aN6 = (A, Q) => {
    for (var B in Q) YoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, sN6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of iN6(Q))
        if (!nN6.call(A, Z) && Z !== B) YoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = lN6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, rN6 = (A) => sN6(YoA({}, "__esModule", {
    value: !0
  }), A), mPB = {};
  aN6(mPB, {
    fromHex: () => cPB,
    toHex: () => pPB
  });
  lPB.exports = rN6(mPB);
  var dPB = {},
    jd1 = {};
  for (let A = 0; A < 256; A++) {
    let Q = A.toString(16).toLowerCase();
    if (Q.length === 1) Q = `0${Q}`;
    dPB[A] = Q, jd1[Q] = A
  }

  function cPB(A) {
    if (A.length % 2 !== 0) throw Error("Hex encoded strings must have an even number length");
    let Q = new Uint8Array(A.length / 2);
    for (let B = 0; B < A.length; B += 2) {
      let G = A.slice(B, B + 2).toLowerCase();
      if (G in jd1) Q[B / 2] = jd1[G];
      else throw Error(`Cannot decode unrecognized sequence ${G} as hexadecimal`)
    }
    return Q
  }
  uPB(cPB, "fromHex");

  function pPB(A) {
    let Q = "";
    for (let B = 0; B < A.byteLength; B++) Q += dPB[A[B]];
    return Q
  }
  uPB(pPB, "toHex")
})
// @from(Start 6830483, End 6831536)
rPB = z((xQG, sPB) => {
  var {
    defineProperty: JoA,
    getOwnPropertyDescriptor: oN6,
    getOwnPropertyNames: tN6
  } = Object, eN6 = Object.prototype.hasOwnProperty, Sd1 = (A, Q) => JoA(A, "name", {
    value: Q,
    configurable: !0
  }), AL6 = (A, Q) => {
    for (var B in Q) JoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, QL6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of tN6(Q))
        if (!eN6.call(A, Z) && Z !== B) JoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = oN6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, BL6 = (A) => QL6(JoA({}, "__esModule", {
    value: !0
  }), A), nPB = {};
  AL6(nPB, {
    escapeUri: () => aPB,
    escapeUriPath: () => ZL6
  });
  sPB.exports = BL6(nPB);
  var aPB = Sd1((A) => encodeURIComponent(A).replace(/[!'()*]/g, GL6), "escapeUri"),
    GL6 = Sd1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    ZL6 = Sd1((A) => A.split("/").map(aPB).join("/"), "escapeUriPath")
})
// @from(Start 6831542, End 6847068)
EjB = z((vQG, CjB) => {
  var {
    defineProperty: KoA,
    getOwnPropertyDescriptor: IL6,
    getOwnPropertyNames: YL6
  } = Object, JL6 = Object.prototype.hasOwnProperty, mX = (A, Q) => KoA(A, "name", {
    value: Q,
    configurable: !0
  }), WL6 = (A, Q) => {
    for (var B in Q) KoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, XL6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of YL6(Q))
        if (!JL6.call(A, Z) && Z !== B) KoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = IL6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, VL6 = (A) => XL6(KoA({}, "__esModule", {
    value: !0
  }), A), QjB = {};
  WL6(QjB, {
    SignatureV4: () => fL6,
    clearCredentialCache: () => TL6,
    createScope: () => VoA,
    getCanonicalHeaders: () => xd1,
    getCanonicalQuery: () => XjB,
    getPayloadHash: () => FoA,
    getSigningKey: () => WjB,
    moveHeadersToQuery: () => DjB,
    prepareRequest: () => bd1
  });
  CjB.exports = VL6(QjB);
  var oPB = jPB(),
    _d1 = r$A(),
    FL6 = "X-Amz-Algorithm",
    KL6 = "X-Amz-Credential",
    BjB = "X-Amz-Date",
    DL6 = "X-Amz-SignedHeaders",
    HL6 = "X-Amz-Expires",
    GjB = "X-Amz-Signature",
    ZjB = "X-Amz-Security-Token",
    IjB = "authorization",
    YjB = BjB.toLowerCase(),
    CL6 = "date",
    EL6 = [IjB, YjB, CL6],
    zL6 = GjB.toLowerCase(),
    yd1 = "x-amz-content-sha256",
    UL6 = ZjB.toLowerCase(),
    $L6 = {
      authorization: !0,
      "cache-control": !0,
      connection: !0,
      expect: !0,
      from: !0,
      "keep-alive": !0,
      "max-forwards": !0,
      pragma: !0,
      referer: !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0,
      "user-agent": !0,
      "x-amzn-trace-id": !0
    },
    wL6 = /^proxy-/,
    qL6 = /^sec-/,
    kd1 = "AWS4-HMAC-SHA256",
    NL6 = "AWS4-HMAC-SHA256-PAYLOAD",
    LL6 = "UNSIGNED-PAYLOAD",
    ML6 = 50,
    JjB = "aws4_request",
    OL6 = 604800,
    Sp = iPB(),
    RL6 = r$A(),
    CGA = {},
    XoA = [],
    VoA = mX((A, Q, B) => `${A}/${Q}/${B}/${JjB}`, "createScope"),
    WjB = mX(async (A, Q, B, G, Z) => {
      let I = await tPB(A, Q.secretAccessKey, Q.accessKeyId),
        Y = `${B}:${G}:${Z}:${(0,Sp.toHex)(I)}:${Q.sessionToken}`;
      if (Y in CGA) return CGA[Y];
      XoA.push(Y);
      while (XoA.length > ML6) delete CGA[XoA.shift()];
      let J = `AWS4${Q.secretAccessKey}`;
      for (let W of [B, G, Z, JjB]) J = await tPB(A, J, W);
      return CGA[Y] = J
    }, "getSigningKey"),
    TL6 = mX(() => {
      XoA.length = 0, Object.keys(CGA).forEach((A) => {
        delete CGA[A]
      })
    }, "clearCredentialCache"),
    tPB = mX((A, Q, B) => {
      let G = new A(Q);
      return G.update((0, RL6.toUint8Array)(B)), G.digest()
    }, "hmac"),
    xd1 = mX(({
      headers: A
    }, Q, B) => {
      let G = {};
      for (let Z of Object.keys(A).sort()) {
        if (A[Z] == null) continue;
        let I = Z.toLowerCase();
        if (I in $L6 || (Q == null ? void 0 : Q.has(I)) || wL6.test(I) || qL6.test(I)) {
          if (!B || B && !B.has(I)) continue
        }
        G[I] = A[Z].trim().replace(/\s+/g, " ")
      }
      return G
    }, "getCanonicalHeaders"),
    o$A = rPB(),
    XjB = mX(({
      query: A = {}
    }) => {
      let Q = [],
        B = {};
      for (let G of Object.keys(A).sort()) {
        if (G.toLowerCase() === zL6) continue;
        Q.push(G);
        let Z = A[G];
        if (typeof Z === "string") B[G] = `${(0,o$A.escapeUri)(G)}=${(0,o$A.escapeUri)(Z)}`;
        else if (Array.isArray(Z)) B[G] = Z.slice(0).reduce((I, Y) => I.concat([`${(0,o$A.escapeUri)(G)}=${(0,o$A.escapeUri)(Y)}`]), []).sort().join("&")
      }
      return Q.map((G) => B[G]).filter((G) => G).join("&")
    }, "getCanonicalQuery"),
    PL6 = Rd1(),
    jL6 = r$A(),
    FoA = mX(async ({
      headers: A,
      body: Q
    }, B) => {
      for (let G of Object.keys(A))
        if (G.toLowerCase() === yd1) return A[G];
      if (Q == null) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      else if (typeof Q === "string" || ArrayBuffer.isView(Q) || (0, PL6.isArrayBuffer)(Q)) {
        let G = new B;
        return G.update((0, jL6.toUint8Array)(Q)), (0, Sp.toHex)(await G.digest())
      }
      return LL6
    }, "getPayloadHash"),
    ePB = r$A(),
    VjB = class {
      format(Q) {
        let B = [];
        for (let I of Object.keys(Q)) {
          let Y = (0, ePB.fromUtf8)(I);
          B.push(Uint8Array.from([Y.byteLength]), Y, this.formatHeaderValue(Q[I]))
        }
        let G = new Uint8Array(B.reduce((I, Y) => I + Y.byteLength, 0)),
          Z = 0;
        for (let I of B) G.set(I, Z), Z += I.byteLength;
        return G
      }
      formatHeaderValue(Q) {
        switch (Q.type) {
          case "boolean":
            return Uint8Array.from([Q.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, Q.value]);
          case "short":
            let B = new DataView(new ArrayBuffer(3));
            return B.setUint8(0, 3), B.setInt16(1, Q.value, !1), new Uint8Array(B.buffer);
          case "integer":
            let G = new DataView(new ArrayBuffer(5));
            return G.setUint8(0, 4), G.setInt32(1, Q.value, !1), new Uint8Array(G.buffer);
          case "long":
            let Z = new Uint8Array(9);
            return Z[0] = 5, Z.set(Q.value.bytes, 1), Z;
          case "binary":
            let I = new DataView(new ArrayBuffer(3 + Q.value.byteLength));
            I.setUint8(0, 6), I.setUint16(1, Q.value.byteLength, !1);
            let Y = new Uint8Array(I.buffer);
            return Y.set(Q.value, 3), Y;
          case "string":
            let J = (0, ePB.fromUtf8)(Q.value),
              W = new DataView(new ArrayBuffer(3 + J.byteLength));
            W.setUint8(0, 7), W.setUint16(1, J.byteLength, !1);
            let X = new Uint8Array(W.buffer);
            return X.set(J, 3), X;
          case "timestamp":
            let V = new Uint8Array(9);
            return V[0] = 8, V.set(kL6.fromNumber(Q.value.valueOf()).bytes, 1), V;
          case "uuid":
            if (!_L6.test(Q.value)) throw Error(`Invalid UUID received: ${Q.value}`);
            let F = new Uint8Array(17);
            return F[0] = 9, F.set((0, Sp.fromHex)(Q.value.replace(/\-/g, "")), 1), F
        }
      }
    };
  mX(VjB, "HeaderFormatter");
  var SL6 = VjB,
    _L6 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    FjB = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) vd1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) vd1(Q);
        return parseInt((0, Sp.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };
  mX(FjB, "Int64");
  var kL6 = FjB;

  function vd1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  mX(vd1, "negate");
  var yL6 = mX((A, Q) => {
      A = A.toLowerCase();
      for (let B of Object.keys(Q))
        if (A === B.toLowerCase()) return !0;
      return !1
    }, "hasHeader"),
    KjB = mX(({
      headers: A,
      query: Q,
      ...B
    }) => ({
      ...B,
      headers: {
        ...A
      },
      query: Q ? xL6(Q) : void 0
    }), "cloneRequest"),
    xL6 = mX((A) => Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {}), "cloneQuery"),
    DjB = mX((A, Q = {}) => {
      var B;
      let {
        headers: G,
        query: Z = {}
      } = typeof A.clone === "function" ? A.clone() : KjB(A);
      for (let I of Object.keys(G)) {
        let Y = I.toLowerCase();
        if (Y.slice(0, 6) === "x-amz-" && !((B = Q.unhoistableHeaders) == null ? void 0 : B.has(Y))) Z[I] = G[I], delete G[I]
      }
      return {
        ...A,
        headers: G,
        query: Z
      }
    }, "moveHeadersToQuery"),
    bd1 = mX((A) => {
      A = typeof A.clone === "function" ? A.clone() : KjB(A);
      for (let Q of Object.keys(A.headers))
        if (EL6.indexOf(Q.toLowerCase()) > -1) delete A.headers[Q];
      return A
    }, "prepareRequest"),
    vL6 = mX((A) => bL6(A).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601"),
    bL6 = mX((A) => {
      if (typeof A === "number") return new Date(A * 1000);
      if (typeof A === "string") {
        if (Number(A)) return new Date(Number(A) * 1000);
        return new Date(A)
      }
      return A
    }, "toDate"),
    HjB = class {
      constructor({
        applyChecksum: Q,
        credentials: B,
        region: G,
        service: Z,
        sha256: I,
        uriEscapePath: Y = !0
      }) {
        this.headerFormatter = new SL6, this.service = Z, this.sha256 = I, this.uriEscapePath = Y, this.applyChecksum = typeof Q === "boolean" ? Q : !0, this.regionProvider = (0, oPB.normalizeProvider)(G), this.credentialProvider = (0, oPB.normalizeProvider)(B)
      }
      async presign(Q, B = {}) {
        let {
          signingDate: G = new Date,
          expiresIn: Z = 3600,
          unsignableHeaders: I,
          unhoistableHeaders: Y,
          signableHeaders: J,
          signingRegion: W,
          signingService: X
        } = B, V = await this.credentialProvider();
        this.validateResolvedCredentials(V);
        let F = W ?? await this.regionProvider(),
          {
            longDate: K,
            shortDate: D
          } = WoA(G);
        if (Z > OL6) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        let H = VoA(D, F, X ?? this.service),
          C = DjB(bd1(Q), {
            unhoistableHeaders: Y
          });
        if (V.sessionToken) C.query[ZjB] = V.sessionToken;
        C.query[FL6] = kd1, C.query[KL6] = `${V.accessKeyId}/${H}`, C.query[BjB] = K, C.query[HL6] = Z.toString(10);
        let E = xd1(C, I, J);
        return C.query[DL6] = AjB(E), C.query[GjB] = await this.getSignature(K, H, this.getSigningKey(V, F, D, X), this.createCanonicalRequest(C, E, await FoA(Q, this.sha256))), C
      }
      async sign(Q, B) {
        if (typeof Q === "string") return this.signString(Q, B);
        else if (Q.headers && Q.payload) return this.signEvent(Q, B);
        else if (Q.message) return this.signMessage(Q, B);
        else return this.signRequest(Q, B)
      }
      async signEvent({
        headers: Q,
        payload: B
      }, {
        signingDate: G = new Date,
        priorSignature: Z,
        signingRegion: I,
        signingService: Y
      }) {
        let J = I ?? await this.regionProvider(),
          {
            shortDate: W,
            longDate: X
          } = WoA(G),
          V = VoA(W, J, Y ?? this.service),
          F = await FoA({
            headers: {},
            body: B
          }, this.sha256),
          K = new this.sha256;
        K.update(Q);
        let D = (0, Sp.toHex)(await K.digest()),
          H = [NL6, X, V, Z, D, F].join(`
`);
        return this.signString(H, {
          signingDate: G,
          signingRegion: J,
          signingService: Y
        })
      }
      async signMessage(Q, {
        signingDate: B = new Date,
        signingRegion: G,
        signingService: Z
      }) {
        return this.signEvent({
          headers: this.headerFormatter.format(Q.message.headers),
          payload: Q.message.body
        }, {
          signingDate: B,
          signingRegion: G,
          signingService: Z,
          priorSignature: Q.priorSignature
        }).then((Y) => {
          return {
            message: Q.message,
            signature: Y
          }
        })
      }
      async signString(Q, {
        signingDate: B = new Date,
        signingRegion: G,
        signingService: Z
      } = {}) {
        let I = await this.credentialProvider();
        this.validateResolvedCredentials(I);
        let Y = G ?? await this.regionProvider(),
          {
            shortDate: J
          } = WoA(B),
          W = new this.sha256(await this.getSigningKey(I, Y, J, Z));
        return W.update((0, _d1.toUint8Array)(Q)), (0, Sp.toHex)(await W.digest())
      }
      async signRequest(Q, {
        signingDate: B = new Date,
        signableHeaders: G,
        unsignableHeaders: Z,
        signingRegion: I,
        signingService: Y
      } = {}) {
        let J = await this.credentialProvider();
        this.validateResolvedCredentials(J);
        let W = I ?? await this.regionProvider(),
          X = bd1(Q),
          {
            longDate: V,
            shortDate: F
          } = WoA(B),
          K = VoA(F, W, Y ?? this.service);
        if (X.headers[YjB] = V, J.sessionToken) X.headers[UL6] = J.sessionToken;
        let D = await FoA(X, this.sha256);
        if (!yL6(yd1, X.headers) && this.applyChecksum) X.headers[yd1] = D;
        let H = xd1(X, Z, G),
          C = await this.getSignature(V, K, this.getSigningKey(J, W, F, Y), this.createCanonicalRequest(X, H, D));
        return X.headers[IjB] = `${kd1} Credential=${J.accessKeyId}/${K}, SignedHeaders=${AjB(H)}, Signature=${C}`, X
      }
      createCanonicalRequest(Q, B, G) {
        let Z = Object.keys(B).sort();
        return `${Q.method}
${this.getCanonicalPath(Q)}
${XjB(Q)}
${Z.map((I)=>`${I}:${B[I]}`).join(`
`)}

${Z.join(";")}
${G}`
      }
      async createStringToSign(Q, B, G) {
        let Z = new this.sha256;
        Z.update((0, _d1.toUint8Array)(G));
        let I = await Z.digest();
        return `${kd1}
${Q}
${B}
${(0,Sp.toHex)(I)}`
      }
      getCanonicalPath({
        path: Q
      }) {
        if (this.uriEscapePath) {
          let B = [];
          for (let I of Q.split("/")) {
            if ((I == null ? void 0 : I.length) === 0) continue;
            if (I === ".") continue;
            if (I === "..") B.pop();
            else B.push(I)
          }
          let G = `${(Q==null?void 0:Q.startsWith("/"))?"/":""}${B.join("/")}${B.length>0&&(Q==null?void 0:Q.endsWith("/"))?"/":""}`;
          return (0, o$A.escapeUri)(G).replace(/%2F/g, "/")
        }
        return Q
      }
      async getSignature(Q, B, G, Z) {
        let I = await this.createStringToSign(Q, B, Z),
          Y = new this.sha256(await G);
        return Y.update((0, _d1.toUint8Array)(I)), (0, Sp.toHex)(await Y.digest())
      }
      getSigningKey(Q, B, G, Z) {
        return WjB(this.sha256, Q, G, B, Z || this.service)
      }
      validateResolvedCredentials(Q) {
        if (typeof Q !== "object" || typeof Q.accessKeyId !== "string" || typeof Q.secretAccessKey !== "string") throw Error("Resolved credential object is not valid")
      }
    };
  mX(HjB, "SignatureV4");
  var fL6 = HjB,
    WoA = mX((A) => {
      let Q = vL6(A).replace(/[\-:]/g, "");
      return {
        longDate: Q,
        shortDate: Q.slice(0, 8)
      }
    }, "formatDate"),
    AjB = mX((A) => Object.keys(A).sort().join(";"), "getCanonicalHeaderList")
})
// @from(Start 6847100, End 6847103)
zjB
// @from(Start 6847105, End 6847108)
UjB
// @from(Start 6847110, End 6847113)
$jB
// @from(Start 6847115, End 6847118)
wjB
// @from(Start 6847120, End 6847716)
gL6 = () => Promise.resolve().then(() => BA(KT1(), 1)).then(({
    fromNodeProviderChain: A
  }) => A({
    clientConfig: {
      requestHandler: new UjB.FetchHttpHandler({
        requestInit: (Q) => {
          return {
            ...Q
          }
        }
      })
    }
  })).catch((A) => {
    throw Error(`Failed to import '@aws-sdk/credential-providers'.You can provide a custom \`providerChainResolver\` in the client options if your runtime does not have access to '@aws-sdk/credential-providers': \`new AnthropicBedrock({ providerChainResolver })\` Original error: ${A.message}`)
  })
// @from(Start 6847720, End 6848764)
qjB = async (A, Q) => {
    hL6(A.method, "Expected request method property to be set");
    let B = await (Q.providerChainResolver ? Q.providerChainResolver() : gL6()),
      G = await uL6(() => {
        if (Q.awsAccessKey) process.env.AWS_ACCESS_KEY_ID = Q.awsAccessKey;
        if (Q.awsSecretKey) process.env.AWS_SECRET_ACCESS_KEY = Q.awsSecretKey;
        if (Q.awsSessionToken) process.env.AWS_SESSION_TOKEN = Q.awsSessionToken
      }, () => B()),
      Z = new wjB.SignatureV4({
        service: "bedrock",
        region: Q.regionName,
        credentials: G,
        sha256: zjB.Sha256
      }),
      I = new URL(Q.url),
      Y = !A.headers ? {} : (Symbol.iterator in A.headers) ? Object.fromEntries(Array.from(A.headers).map((X) => [...X])) : {
        ...A.headers
      };
    delete Y.connection, Y.host = I.hostname;
    let J = new $jB.HttpRequest({
      method: A.method.toUpperCase(),
      protocol: I.protocol,
      path: I.pathname,
      headers: Y,
      body: A.body
    });
    return (await Z.sign(J)).headers
  }
// @from(Start 6848766, End 6848917)
uL6 = async (A, Q) => {
    let B = {
      ...process.env
    };
    try {
      return A(), await Q()
    } finally {
      process.env = B
    }
  }
// @from(Start 6848923, End 6849022)
NjB = L(() => {
  zjB = BA(FTB(), 1), UjB = BA(Ld1(), 1), $jB = BA(Od1(), 1), wjB = BA(EjB(), 1)
})
// @from(Start 6849028, End 6860374)
hd1 = z((hQG, HoA) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var LjB, MjB, OjB, RjB, TjB, PjB, jjB, SjB, _jB, DoA, fd1, kjB, yjB, EGA, xjB, vjB, bjB, fjB, hjB, gjB, ujB, mjB, djB;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof HoA === "object" && typeof hQG === "object") A(B(Q, B(hQG)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(B, G) {
      B.__proto__ = G
    } || function(B, G) {
      for (var Z in G)
        if (G.hasOwnProperty(Z)) B[Z] = G[Z]
    };
    LjB = function(B, G) {
      Q(B, G);

      function Z() {
        this.constructor = B
      }
      B.prototype = G === null ? Object.create(G) : (Z.prototype = G.prototype, new Z)
    }, MjB = Object.assign || function(B) {
      for (var G, Z = 1, I = arguments.length; Z < I; Z++) {
        G = arguments[Z];
        for (var Y in G)
          if (Object.prototype.hasOwnProperty.call(G, Y)) B[Y] = G[Y]
      }
      return B
    }, OjB = function(B, G) {
      var Z = {};
      for (var I in B)
        if (Object.prototype.hasOwnProperty.call(B, I) && G.indexOf(I) < 0) Z[I] = B[I];
      if (B != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var Y = 0, I = Object.getOwnPropertySymbols(B); Y < I.length; Y++)
          if (G.indexOf(I[Y]) < 0 && Object.prototype.propertyIsEnumerable.call(B, I[Y])) Z[I[Y]] = B[I[Y]]
      }
      return Z
    }, RjB = function(B, G, Z, I) {
      var Y = arguments.length,
        J = Y < 3 ? G : I === null ? I = Object.getOwnPropertyDescriptor(G, Z) : I,
        W;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") J = Reflect.decorate(B, G, Z, I);
      else
        for (var X = B.length - 1; X >= 0; X--)
          if (W = B[X]) J = (Y < 3 ? W(J) : Y > 3 ? W(G, Z, J) : W(G, Z)) || J;
      return Y > 3 && J && Object.defineProperty(G, Z, J), J
    }, TjB = function(B, G) {
      return function(Z, I) {
        G(Z, I, B)
      }
    }, PjB = function(B, G) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(B, G)
    }, jjB = function(B, G, Z, I) {
      function Y(J) {
        return J instanceof Z ? J : new Z(function(W) {
          W(J)
        })
      }
      return new(Z || (Z = Promise))(function(J, W) {
        function X(K) {
          try {
            F(I.next(K))
          } catch (D) {
            W(D)
          }
        }

        function V(K) {
          try {
            F(I.throw(K))
          } catch (D) {
            W(D)
          }
        }

        function F(K) {
          K.done ? J(K.value) : Y(K.value).then(X, V)
        }
        F((I = I.apply(B, G || [])).next())
      })
    }, SjB = function(B, G) {
      var Z = {
          label: 0,
          sent: function() {
            if (J[0] & 1) throw J[1];
            return J[1]
          },
          trys: [],
          ops: []
        },
        I, Y, J, W;
      return W = {
        next: X(0),
        throw: X(1),
        return: X(2)
      }, typeof Symbol === "function" && (W[Symbol.iterator] = function() {
        return this
      }), W;

      function X(F) {
        return function(K) {
          return V([F, K])
        }
      }

      function V(F) {
        if (I) throw TypeError("Generator is already executing.");
        while (Z) try {
          if (I = 1, Y && (J = F[0] & 2 ? Y.return : F[0] ? Y.throw || ((J = Y.return) && J.call(Y), 0) : Y.next) && !(J = J.call(Y, F[1])).done) return J;
          if (Y = 0, J) F = [F[0] & 2, J.value];
          switch (F[0]) {
            case 0:
            case 1:
              J = F;
              break;
            case 4:
              return Z.label++, {
                value: F[1],
                done: !1
              };
            case 5:
              Z.label++, Y = F[1], F = [0];
              continue;
            case 7:
              F = Z.ops.pop(), Z.trys.pop();
              continue;
            default:
              if ((J = Z.trys, !(J = J.length > 0 && J[J.length - 1])) && (F[0] === 6 || F[0] === 2)) {
                Z = 0;
                continue
              }
              if (F[0] === 3 && (!J || F[1] > J[0] && F[1] < J[3])) {
                Z.label = F[1];
                break
              }
              if (F[0] === 6 && Z.label < J[1]) {
                Z.label = J[1], J = F;
                break
              }
              if (J && Z.label < J[2]) {
                Z.label = J[2], Z.ops.push(F);
                break
              }
              if (J[2]) Z.ops.pop();
              Z.trys.pop();
              continue
          }
          F = G.call(B, Z)
        } catch (K) {
          F = [6, K], Y = 0
        } finally {
          I = J = 0
        }
        if (F[0] & 5) throw F[1];
        return {
          value: F[0] ? F[1] : void 0,
          done: !0
        }
      }
    }, djB = function(B, G, Z, I) {
      if (I === void 0) I = Z;
      B[I] = G[Z]
    }, _jB = function(B, G) {
      for (var Z in B)
        if (Z !== "default" && !G.hasOwnProperty(Z)) G[Z] = B[Z]
    }, DoA = function(B) {
      var G = typeof Symbol === "function" && Symbol.iterator,
        Z = G && B[G],
        I = 0;
      if (Z) return Z.call(B);
      if (B && typeof B.length === "number") return {
        next: function() {
          if (B && I >= B.length) B = void 0;
          return {
            value: B && B[I++],
            done: !B
          }
        }
      };
      throw TypeError(G ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, fd1 = function(B, G) {
      var Z = typeof Symbol === "function" && B[Symbol.iterator];
      if (!Z) return B;
      var I = Z.call(B),
        Y, J = [],
        W;
      try {
        while ((G === void 0 || G-- > 0) && !(Y = I.next()).done) J.push(Y.value)
      } catch (X) {
        W = {
          error: X
        }
      } finally {
        try {
          if (Y && !Y.done && (Z = I.return)) Z.call(I)
        } finally {
          if (W) throw W.error
        }
      }
      return J
    }, kjB = function() {
      for (var B = [], G = 0; G < arguments.length; G++) B = B.concat(fd1(arguments[G]));
      return B
    }, yjB = function() {
      for (var B = 0, G = 0, Z = arguments.length; G < Z; G++) B += arguments[G].length;
      for (var I = Array(B), Y = 0, G = 0; G < Z; G++)
        for (var J = arguments[G], W = 0, X = J.length; W < X; W++, Y++) I[Y] = J[W];
      return I
    }, EGA = function(B) {
      return this instanceof EGA ? (this.v = B, this) : new EGA(B)
    }, xjB = function(B, G, Z) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var I = Z.apply(B, G || []),
        Y, J = [];
      return Y = {}, W("next"), W("throw"), W("return"), Y[Symbol.asyncIterator] = function() {
        return this
      }, Y;

      function W(H) {
        if (I[H]) Y[H] = function(C) {
          return new Promise(function(E, U) {
            J.push([H, C, E, U]) > 1 || X(H, C)
          })
        }
      }

      function X(H, C) {
        try {
          V(I[H](C))
        } catch (E) {
          D(J[0][3], E)
        }
      }

      function V(H) {
        H.value instanceof EGA ? Promise.resolve(H.value.v).then(F, K) : D(J[0][2], H)
      }

      function F(H) {
        X("next", H)
      }

      function K(H) {
        X("throw", H)
      }

      function D(H, C) {
        if (H(C), J.shift(), J.length) X(J[0][0], J[0][1])
      }
    }, vjB = function(B) {
      var G, Z;
      return G = {}, I("next"), I("throw", function(Y) {
        throw Y
      }), I("return"), G[Symbol.iterator] = function() {
        return this
      }, G;

      function I(Y, J) {
        G[Y] = B[Y] ? function(W) {
          return (Z = !Z) ? {
            value: EGA(B[Y](W)),
            done: Y === "return"
          } : J ? J(W) : W
        } : J
      }
    }, bjB = function(B) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var G = B[Symbol.asyncIterator],
        Z;
      return G ? G.call(B) : (B = typeof DoA === "function" ? DoA(B) : B[Symbol.iterator](), Z = {}, I("next"), I("throw"), I("return"), Z[Symbol.asyncIterator] = function() {
        return this
      }, Z);

      function I(J) {
        Z[J] = B[J] && function(W) {
          return new Promise(function(X, V) {
            W = B[J](W), Y(X, V, W.done, W.value)
          })
        }
      }

      function Y(J, W, X, V) {
        Promise.resolve(V).then(function(F) {
          J({
            value: F,
            done: X
          })
        }, W)
      }
    }, fjB = function(B, G) {
      if (Object.defineProperty) Object.defineProperty(B, "raw", {
        value: G
      });
      else B.raw = G;
      return B
    }, hjB = function(B) {
      if (B && B.__esModule) return B;
      var G = {};
      if (B != null) {
        for (var Z in B)
          if (Object.hasOwnProperty.call(B, Z)) G[Z] = B[Z]
      }
      return G.default = B, G
    }, gjB = function(B) {
      return B && B.__esModule ? B : {
        default: B
      }
    }, ujB = function(B, G) {
      if (!G.has(B)) throw TypeError("attempted to get private field on non-instance");
      return G.get(B)
    }, mjB = function(B, G, Z) {
      if (!G.has(B)) throw TypeError("attempted to set private field on non-instance");
      return G.set(B, Z), Z
    }, A("__extends", LjB), A("__assign", MjB), A("__rest", OjB), A("__decorate", RjB), A("__param", TjB), A("__metadata", PjB), A("__awaiter", jjB), A("__generator", SjB), A("__exportStar", _jB), A("__createBinding", djB), A("__values", DoA), A("__read", fd1), A("__spread", kjB), A("__spreadArrays", yjB), A("__await", EGA), A("__asyncGenerator", xjB), A("__asyncDelegator", vjB), A("__asyncValues", bjB), A("__makeTemplateObject", fjB), A("__importStar", hjB), A("__importDefault", gjB), A("__classPrivateFieldGet", ujB), A("__classPrivateFieldSet", mjB)
  })
})
// @from(Start 6860380, End 6860930)
ljB = z((cjB) => {
  Object.defineProperty(cjB, "__esModule", {
    value: !0
  });
  cjB.convertToBuffer = void 0;
  var mL6 = Cd1(),
    dL6 = typeof Buffer < "u" && Buffer.from ? function(A) {
      return Buffer.from(A, "utf8")
    } : mL6.fromUtf8;

  function cL6(A) {
    if (A instanceof Uint8Array) return A;
    if (typeof A === "string") return dL6(A);
    if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    return new Uint8Array(A)
  }
  cjB.convertToBuffer = cL6
})
// @from(Start 6860936, End 6861183)
ajB = z((ijB) => {
  Object.defineProperty(ijB, "__esModule", {
    value: !0
  });
  ijB.isEmptyData = void 0;

  function pL6(A) {
    if (typeof A === "string") return A.length === 0;
    return A.byteLength === 0
  }
  ijB.isEmptyData = pL6
})
// @from(Start 6861189, End 6861451)
ojB = z((sjB) => {
  Object.defineProperty(sjB, "__esModule", {
    value: !0
  });
  sjB.numToUint8 = void 0;

  function lL6(A) {
    return new Uint8Array([(A & 4278190080) >> 24, (A & 16711680) >> 16, (A & 65280) >> 8, A & 255])
  }
  sjB.numToUint8 = lL6
})
// @from(Start 6861457, End 6861813)
ASB = z((tjB) => {
  Object.defineProperty(tjB, "__esModule", {
    value: !0
  });
  tjB.uint32ArrayFrom = void 0;

  function iL6(A) {
    if (!Uint32Array.from) {
      var Q = new Uint32Array(A.length),
        B = 0;
      while (B < A.length) Q[B] = A[B], B += 1;
      return Q
    }
    return Uint32Array.from(A)
  }
  tjB.uint32ArrayFrom = iL6
})
// @from(Start 6861819, End 6862599)
gd1 = z((zGA) => {
  Object.defineProperty(zGA, "__esModule", {
    value: !0
  });
  zGA.uint32ArrayFrom = zGA.numToUint8 = zGA.isEmptyData = zGA.convertToBuffer = void 0;
  var nL6 = ljB();
  Object.defineProperty(zGA, "convertToBuffer", {
    enumerable: !0,
    get: function() {
      return nL6.convertToBuffer
    }
  });
  var aL6 = ajB();
  Object.defineProperty(zGA, "isEmptyData", {
    enumerable: !0,
    get: function() {
      return aL6.isEmptyData
    }
  });
  var sL6 = ojB();
  Object.defineProperty(zGA, "numToUint8", {
    enumerable: !0,
    get: function() {
      return sL6.numToUint8
    }
  });
  var rL6 = ASB();
  Object.defineProperty(zGA, "uint32ArrayFrom", {
    enumerable: !0,
    get: function() {
      return rL6.uint32ArrayFrom
    }
  })
})
// @from(Start 6862605, End 6863371)
ISB = z((GSB) => {
  Object.defineProperty(GSB, "__esModule", {
    value: !0
  });
  GSB.AwsCrc32 = void 0;
  var QSB = hd1(),
    ud1 = gd1(),
    BSB = CoA(),
    tL6 = function() {
      function A() {
        this.crc32 = new BSB.Crc32
      }
      return A.prototype.update = function(Q) {
        if ((0, ud1.isEmptyData)(Q)) return;
        this.crc32.update((0, ud1.convertToBuffer)(Q))
      }, A.prototype.digest = function() {
        return QSB.__awaiter(this, void 0, void 0, function() {
          return QSB.__generator(this, function(Q) {
            return [2, (0, ud1.numToUint8)(this.crc32.digest())]
          })
        })
      }, A.prototype.reset = function() {
        this.crc32 = new BSB.Crc32
      }, A
    }();
  GSB.AwsCrc32 = tL6
})
// @from(Start 6863377, End 6867537)
CoA = z((md1) => {
  Object.defineProperty(md1, "__esModule", {
    value: !0
  });
  md1.AwsCrc32 = md1.Crc32 = md1.crc32 = void 0;
  var eL6 = hd1(),
    AM6 = gd1();

  function QM6(A) {
    return new YSB().update(A).digest()
  }
  md1.crc32 = QM6;
  var YSB = function() {
    function A() {
      this.checksum = 4294967295
    }
    return A.prototype.update = function(Q) {
      var B, G;
      try {
        for (var Z = eL6.__values(Q), I = Z.next(); !I.done; I = Z.next()) {
          var Y = I.value;
          this.checksum = this.checksum >>> 8 ^ GM6[(this.checksum ^ Y) & 255]
        }
      } catch (J) {
        B = {
          error: J
        }
      } finally {
        try {
          if (I && !I.done && (G = Z.return)) G.call(Z)
        } finally {
          if (B) throw B.error
        }
      }
      return this
    }, A.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0
    }, A
  }();
  md1.Crc32 = YSB;
  var BM6 = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117],
    GM6 = (0, AM6.uint32ArrayFrom)(BM6),
    ZM6 = ISB();
  Object.defineProperty(md1, "AwsCrc32", {
    enumerable: !0,
    get: function() {
      return ZM6.AwsCrc32
    }
  })
})
// @from(Start 6867543, End 6869069)
DSB = z((sQG, KSB) => {
  var {
    defineProperty: EoA,
    getOwnPropertyDescriptor: WM6,
    getOwnPropertyNames: XM6
  } = Object, VM6 = Object.prototype.hasOwnProperty, JSB = (A, Q) => EoA(A, "name", {
    value: Q,
    configurable: !0
  }), FM6 = (A, Q) => {
    for (var B in Q) EoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, KM6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of XM6(Q))
        if (!VM6.call(A, Z) && Z !== B) EoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = WM6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, DM6 = (A) => KM6(EoA({}, "__esModule", {
    value: !0
  }), A), WSB = {};
  FM6(WSB, {
    fromHex: () => VSB,
    toHex: () => FSB
  });
  KSB.exports = DM6(WSB);
  var XSB = {},
    dd1 = {};
  for (let A = 0; A < 256; A++) {
    let Q = A.toString(16).toLowerCase();
    if (Q.length === 1) Q = `0${Q}`;
    XSB[A] = Q, dd1[Q] = A
  }

  function VSB(A) {
    if (A.length % 2 !== 0) throw Error("Hex encoded strings must have an even number length");
    let Q = new Uint8Array(A.length / 2);
    for (let B = 0; B < A.length; B += 2) {
      let G = A.slice(B, B + 2).toLowerCase();
      if (G in dd1) Q[B / 2] = dd1[G];
      else throw Error(`Cannot decode unrecognized sequence ${G} as hexadecimal`)
    }
    return Q
  }
  JSB(VSB, "fromHex");

  function FSB(A) {
    let Q = "";
    for (let B = 0; B < A.byteLength; B++) Q += XSB[A[B]];
    return Q
  }
  JSB(FSB, "toHex")
})
// @from(Start 6869075, End 6879748)
TSB = z((rQG, RSB) => {
  var {
    defineProperty: UoA,
    getOwnPropertyDescriptor: HM6,
    getOwnPropertyNames: CM6
  } = Object, EM6 = Object.prototype.hasOwnProperty, Cf = (A, Q) => UoA(A, "name", {
    value: Q,
    configurable: !0
  }), zM6 = (A, Q) => {
    for (var B in Q) UoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, UM6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of CM6(Q))
        if (!EM6.call(A, Z) && Z !== B) UoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = HM6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, $M6 = (A) => UM6(UoA({}, "__esModule", {
    value: !0
  }), A), CSB = {};
  zM6(CSB, {
    EventStreamCodec: () => kM6,
    HeaderMarshaller: () => USB,
    Int64: () => zoA,
    MessageDecoderStream: () => yM6,
    MessageEncoderStream: () => xM6,
    SmithyMessageDecoderStream: () => vM6,
    SmithyMessageEncoderStream: () => bM6
  });
  RSB.exports = $M6(CSB);
  var wM6 = CoA(),
    We = DSB(),
    ESB = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) cd1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) cd1(Q);
        return parseInt((0, We.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };
  Cf(ESB, "Int64");
  var zoA = ESB;

  function cd1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  Cf(cd1, "negate");
  var zSB = class {
    constructor(Q, B) {
      this.toUtf8 = Q, this.fromUtf8 = B
    }
    format(Q) {
      let B = [];
      for (let I of Object.keys(Q)) {
        let Y = this.fromUtf8(I);
        B.push(Uint8Array.from([Y.byteLength]), Y, this.formatHeaderValue(Q[I]))
      }
      let G = new Uint8Array(B.reduce((I, Y) => I + Y.byteLength, 0)),
        Z = 0;
      for (let I of B) G.set(I, Z), Z += I.byteLength;
      return G
    }
    formatHeaderValue(Q) {
      switch (Q.type) {
        case "boolean":
          return Uint8Array.from([Q.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, Q.value]);
        case "short":
          let B = new DataView(new ArrayBuffer(3));
          return B.setUint8(0, 3), B.setInt16(1, Q.value, !1), new Uint8Array(B.buffer);
        case "integer":
          let G = new DataView(new ArrayBuffer(5));
          return G.setUint8(0, 4), G.setInt32(1, Q.value, !1), new Uint8Array(G.buffer);
        case "long":
          let Z = new Uint8Array(9);
          return Z[0] = 5, Z.set(Q.value.bytes, 1), Z;
        case "binary":
          let I = new DataView(new ArrayBuffer(3 + Q.value.byteLength));
          I.setUint8(0, 6), I.setUint16(1, Q.value.byteLength, !1);
          let Y = new Uint8Array(I.buffer);
          return Y.set(Q.value, 3), Y;
        case "string":
          let J = this.fromUtf8(Q.value),
            W = new DataView(new ArrayBuffer(3 + J.byteLength));
          W.setUint8(0, 7), W.setUint16(1, J.byteLength, !1);
          let X = new Uint8Array(W.buffer);
          return X.set(J, 3), X;
        case "timestamp":
          let V = new Uint8Array(9);
          return V[0] = 8, V.set(zoA.fromNumber(Q.value.valueOf()).bytes, 1), V;
        case "uuid":
          if (!jM6.test(Q.value)) throw Error(`Invalid UUID received: ${Q.value}`);
          let F = new Uint8Array(17);
          return F[0] = 9, F.set((0, We.fromHex)(Q.value.replace(/\-/g, "")), 1), F
      }
    }
    parse(Q) {
      let B = {},
        G = 0;
      while (G < Q.byteLength) {
        let Z = Q.getUint8(G++),
          I = this.toUtf8(new Uint8Array(Q.buffer, Q.byteOffset + G, Z));
        switch (G += Z, Q.getUint8(G++)) {
          case 0:
            B[I] = {
              type: HSB,
              value: !0
            };
            break;
          case 1:
            B[I] = {
              type: HSB,
              value: !1
            };
            break;
          case 2:
            B[I] = {
              type: qM6,
              value: Q.getInt8(G++)
            };
            break;
          case 3:
            B[I] = {
              type: NM6,
              value: Q.getInt16(G, !1)
            }, G += 2;
            break;
          case 4:
            B[I] = {
              type: LM6,
              value: Q.getInt32(G, !1)
            }, G += 4;
            break;
          case 5:
            B[I] = {
              type: MM6,
              value: new zoA(new Uint8Array(Q.buffer, Q.byteOffset + G, 8))
            }, G += 8;
            break;
          case 6:
            let Y = Q.getUint16(G, !1);
            G += 2, B[I] = {
              type: OM6,
              value: new Uint8Array(Q.buffer, Q.byteOffset + G, Y)
            }, G += Y;
            break;
          case 7:
            let J = Q.getUint16(G, !1);
            G += 2, B[I] = {
              type: RM6,
              value: this.toUtf8(new Uint8Array(Q.buffer, Q.byteOffset + G, J))
            }, G += J;
            break;
          case 8:
            B[I] = {
              type: TM6,
              value: new Date(new zoA(new Uint8Array(Q.buffer, Q.byteOffset + G, 8)).valueOf())
            }, G += 8;
            break;
          case 9:
            let W = new Uint8Array(Q.buffer, Q.byteOffset + G, 16);
            G += 16, B[I] = {
              type: PM6,
              value: `${(0,We.toHex)(W.subarray(0,4))}-${(0,We.toHex)(W.subarray(4,6))}-${(0,We.toHex)(W.subarray(6,8))}-${(0,We.toHex)(W.subarray(8,10))}-${(0,We.toHex)(W.subarray(10))}`
            };
            break;
          default:
            throw Error("Unrecognized header type tag")
        }
      }
      return B
    }
  };
  Cf(zSB, "HeaderMarshaller");
  var USB = zSB,
    HSB = "boolean",
    qM6 = "byte",
    NM6 = "short",
    LM6 = "integer",
    MM6 = "long",
    OM6 = "binary",
    RM6 = "string",
    TM6 = "timestamp",
    PM6 = "uuid",
    jM6 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    SM6 = CoA(),
    $SB = 4,
    _p = $SB * 2,
    Xe = 4,
    _M6 = _p + Xe * 2;

  function wSB({
    byteLength: A,
    byteOffset: Q,
    buffer: B
  }) {
    if (A < _M6) throw Error("Provided message too short to accommodate event stream message overhead");
    let G = new DataView(B, Q, A),
      Z = G.getUint32(0, !1);
    if (A !== Z) throw Error("Reported message length does not match received message length");
    let I = G.getUint32($SB, !1),
      Y = G.getUint32(_p, !1),
      J = G.getUint32(A - Xe, !1),
      W = new SM6.Crc32().update(new Uint8Array(B, Q, _p));
    if (Y !== W.digest()) throw Error(`The prelude checksum specified in the message (${Y}) does not match the calculated CRC32 checksum (${W.digest()})`);
    if (W.update(new Uint8Array(B, Q + _p, A - (_p + Xe))), J !== W.digest()) throw Error(`The message checksum (${W.digest()}) did not match the expected value of ${J}`);
    return {
      headers: new DataView(B, Q + _p + Xe, I),
      body: new Uint8Array(B, Q + _p + Xe + I, Z - I - (_p + Xe + Xe))
    }
  }
  Cf(wSB, "splitMessage");
  var qSB = class {
    constructor(Q, B) {
      this.headerMarshaller = new USB(Q, B), this.messageBuffer = [], this.isEndOfStream = !1
    }
    feed(Q) {
      this.messageBuffer.push(this.decode(Q))
    }
    endOfStream() {
      this.isEndOfStream = !0
    }
    getMessage() {
      let Q = this.messageBuffer.pop(),
        B = this.isEndOfStream;
      return {
        getMessage() {
          return Q
        },
        isEndOfStream() {
          return B
        }
      }
    }
    getAvailableMessages() {
      let Q = this.messageBuffer;
      this.messageBuffer = [];
      let B = this.isEndOfStream;
      return {
        getMessages() {
          return Q
        },
        isEndOfStream() {
          return B
        }
      }
    }
    encode({
      headers: Q,
      body: B
    }) {
      let G = this.headerMarshaller.format(Q),
        Z = G.byteLength + B.byteLength + 16,
        I = new Uint8Array(Z),
        Y = new DataView(I.buffer, I.byteOffset, I.byteLength),
        J = new wM6.Crc32;
      return Y.setUint32(0, Z, !1), Y.setUint32(4, G.byteLength, !1), Y.setUint32(8, J.update(I.subarray(0, 8)).digest(), !1), I.set(G, 12), I.set(B, G.byteLength + 12), Y.setUint32(Z - 4, J.update(I.subarray(8, Z - 4)).digest(), !1), I
    }
    decode(Q) {
      let {
        headers: B,
        body: G
      } = wSB(Q);
      return {
        headers: this.headerMarshaller.parse(B),
        body: G
      }
    }
    formatHeaders(Q) {
      return this.headerMarshaller.format(Q)
    }
  };
  Cf(qSB, "EventStreamCodec");
  var kM6 = qSB,
    NSB = class {
      constructor(Q) {
        this.options = Q
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let Q of this.options.inputStream) yield this.options.decoder.decode(Q)
      }
    };
  Cf(NSB, "MessageDecoderStream");
  var yM6 = NSB,
    LSB = class {
      constructor(Q) {
        this.options = Q
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let Q of this.options.messageStream) yield this.options.encoder.encode(Q);
        if (this.options.includeEndFrame) yield new Uint8Array(0)
      }
    };
  Cf(LSB, "MessageEncoderStream");
  var xM6 = LSB,
    MSB = class {
      constructor(Q) {
        this.options = Q
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let Q of this.options.messageStream) {
          let B = await this.options.deserializer(Q);
          if (B === void 0) continue;
          yield B
        }
      }
    };
  Cf(MSB, "SmithyMessageDecoderStream");
  var vM6 = MSB,
    OSB = class {
      constructor(Q) {
        this.options = Q
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let Q of this.options.inputStream) yield this.options.serializer(Q)
      }
    };
  Cf(OSB, "SmithyMessageEncoderStream");
  var bM6 = OSB
})
// @from(Start 6879754, End 6883725)
xSB = z((oQG, ySB) => {
  var {
    defineProperty: $oA,
    getOwnPropertyDescriptor: fM6,
    getOwnPropertyNames: hM6
  } = Object, gM6 = Object.prototype.hasOwnProperty, UGA = (A, Q) => $oA(A, "name", {
    value: Q,
    configurable: !0
  }), uM6 = (A, Q) => {
    for (var B in Q) $oA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, mM6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of hM6(Q))
        if (!gM6.call(A, Z) && Z !== B) $oA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = fM6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, dM6 = (A) => mM6($oA({}, "__esModule", {
    value: !0
  }), A), PSB = {};
  uM6(PSB, {
    EventStreamMarshaller: () => kSB,
    eventStreamSerdeProvider: () => cM6
  });
  ySB.exports = dM6(PSB);
  var t$A = TSB();

  function jSB(A) {
    let Q = 0,
      B = 0,
      G = null,
      Z = null,
      I = UGA((J) => {
        if (typeof J !== "number") throw Error("Attempted to allocate an event message where size was not a number: " + J);
        Q = J, B = 4, G = new Uint8Array(J), new DataView(G.buffer).setUint32(0, J, !1)
      }, "allocateMessage"),
      Y = UGA(async function*() {
        let J = A[Symbol.asyncIterator]();
        while (!0) {
          let {
            value: W,
            done: X
          } = await J.next();
          if (X) {
            if (!Q) return;
            else if (Q === B) yield G;
            else throw Error("Truncated event message received.");
            return
          }
          let V = W.length,
            F = 0;
          while (F < V) {
            if (!G) {
              let D = V - F;
              if (!Z) Z = new Uint8Array(4);
              let H = Math.min(4 - B, D);
              if (Z.set(W.slice(F, F + H), B), B += H, F += H, B < 4) break;
              I(new DataView(Z.buffer).getUint32(0, !1)), Z = null
            }
            let K = Math.min(Q - B, V - F);
            if (G.set(W.slice(F, F + K), B), B += K, F += K, Q && Q === B) yield G, G = null, Q = 0, B = 0
          }
        }
      }, "iterator");
    return {
      [Symbol.asyncIterator]: Y
    }
  }
  UGA(jSB, "getChunkedStream");

  function SSB(A, Q) {
    return async function(B) {
      let {
        value: G
      } = B.headers[":message-type"];
      if (G === "error") {
        let Z = Error(B.headers[":error-message"].value || "UnknownError");
        throw Z.name = B.headers[":error-code"].value, Z
      } else if (G === "exception") {
        let Z = B.headers[":exception-type"].value,
          I = {
            [Z]: B
          },
          Y = await A(I);
        if (Y.$unknown) {
          let J = Error(Q(B.body));
          throw J.name = Z, J
        }
        throw Y[Z]
      } else if (G === "event") {
        let Z = {
            [B.headers[":event-type"].value]: B
          },
          I = await A(Z);
        if (I.$unknown) return;
        return I
      } else throw Error(`Unrecognizable event type: ${B.headers[":event-type"].value}`)
    }
  }
  UGA(SSB, "getMessageUnmarshaller");
  var _SB = class {
    constructor({
      utf8Encoder: Q,
      utf8Decoder: B
    }) {
      this.eventStreamCodec = new t$A.EventStreamCodec(Q, B), this.utfEncoder = Q
    }
    deserialize(Q, B) {
      let G = jSB(Q);
      return new t$A.SmithyMessageDecoderStream({
        messageStream: new t$A.MessageDecoderStream({
          inputStream: G,
          decoder: this.eventStreamCodec
        }),
        deserializer: SSB(B, this.utfEncoder)
      })
    }
    serialize(Q, B) {
      return new t$A.MessageEncoderStream({
        messageStream: new t$A.SmithyMessageEncoderStream({
          inputStream: Q,
          serializer: B
        }),
        encoder: this.eventStreamCodec,
        includeEndFrame: !0
      })
    }
  };
  UGA(_SB, "EventStreamMarshaller");
  var kSB = _SB,
    cM6 = UGA((A) => new kSB(A), "eventStreamSerdeProvider")
})
// @from(Start 6883731, End 6885631)
uSB = z((tQG, gSB) => {
  var {
    defineProperty: woA,
    getOwnPropertyDescriptor: pM6,
    getOwnPropertyNames: lM6
  } = Object, iM6 = Object.prototype.hasOwnProperty, pd1 = (A, Q) => woA(A, "name", {
    value: Q,
    configurable: !0
  }), nM6 = (A, Q) => {
    for (var B in Q) woA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, aM6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of lM6(Q))
        if (!iM6.call(A, Z) && Z !== B) woA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = pM6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, sM6 = (A) => aM6(woA({}, "__esModule", {
    value: !0
  }), A), vSB = {};
  nM6(vSB, {
    EventStreamMarshaller: () => hSB,
    eventStreamSerdeProvider: () => tM6
  });
  gSB.exports = sM6(vSB);
  var rM6 = xSB(),
    oM6 = UA("stream");
  async function* bSB(A) {
    let Q = !1,
      B = !1,
      G = [];
    A.on("error", (Z) => {
      if (!Q) Q = !0;
      if (Z) throw Z
    }), A.on("data", (Z) => {
      G.push(Z)
    }), A.on("end", () => {
      Q = !0
    });
    while (!B) {
      let Z = await new Promise((I) => setTimeout(() => I(G.shift()), 0));
      if (Z) yield Z;
      B = Q && G.length === 0
    }
  }
  pd1(bSB, "readabletoIterable");
  var fSB = class {
    constructor({
      utf8Encoder: Q,
      utf8Decoder: B
    }) {
      this.universalMarshaller = new rM6.EventStreamMarshaller({
        utf8Decoder: B,
        utf8Encoder: Q
      })
    }
    deserialize(Q, B) {
      let G = typeof Q[Symbol.asyncIterator] === "function" ? Q : bSB(Q);
      return this.universalMarshaller.deserialize(G, B)
    }
    serialize(Q, B) {
      return oM6.Readable.from(this.universalMarshaller.serialize(Q, B))
    }
  };
  pd1(fSB, "EventStreamMarshaller");
  var hSB = fSB,
    tM6 = pd1((A) => new hSB(A), "eventStreamSerdeProvider")
})
// @from(Start 6885637, End 6886590)
cSB = z((eQG, dSB) => {
  var {
    defineProperty: qoA,
    getOwnPropertyDescriptor: eM6,
    getOwnPropertyNames: AO6
  } = Object, QO6 = Object.prototype.hasOwnProperty, BO6 = (A, Q) => qoA(A, "name", {
    value: Q,
    configurable: !0
  }), GO6 = (A, Q) => {
    for (var B in Q) qoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, ZO6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of AO6(Q))
        if (!QO6.call(A, Z) && Z !== B) qoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = eM6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, IO6 = (A) => ZO6(qoA({}, "__esModule", {
    value: !0
  }), A), mSB = {};
  GO6(mSB, {
    isArrayBuffer: () => YO6
  });
  dSB.exports = IO6(mSB);
  var YO6 = BO6((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 6886596, End 6887942)
LoA = z((ABG, iSB) => {
  var {
    defineProperty: NoA,
    getOwnPropertyDescriptor: JO6,
    getOwnPropertyNames: WO6
  } = Object, XO6 = Object.prototype.hasOwnProperty, pSB = (A, Q) => NoA(A, "name", {
    value: Q,
    configurable: !0
  }), VO6 = (A, Q) => {
    for (var B in Q) NoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, FO6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of WO6(Q))
        if (!XO6.call(A, Z) && Z !== B) NoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = JO6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, KO6 = (A) => FO6(NoA({}, "__esModule", {
    value: !0
  }), A), lSB = {};
  VO6(lSB, {
    fromArrayBuffer: () => HO6,
    fromString: () => CO6
  });
  iSB.exports = KO6(lSB);
  var DO6 = cSB(),
    ld1 = UA("buffer"),
    HO6 = pSB((A, Q = 0, B = A.byteLength - Q) => {
      if (!(0, DO6.isArrayBuffer)(A)) throw TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof A} (${A})`);
      return ld1.Buffer.from(A, Q, B)
    }, "fromArrayBuffer"),
    CO6 = pSB((A, Q) => {
      if (typeof A !== "string") throw TypeError(`The "input" argument must be of type string. Received type ${typeof A} (${A})`);
      return Q ? ld1.Buffer.from(A, Q) : ld1.Buffer.from(A)
    }, "fromString")
})
// @from(Start 6887948, End 6888436)
sSB = z((nSB) => {
  Object.defineProperty(nSB, "__esModule", {
    value: !0
  });
  nSB.fromBase64 = void 0;
  var EO6 = LoA(),
    zO6 = /^[A-Za-z0-9+/]*={0,2}$/,
    UO6 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!zO6.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, EO6.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  nSB.fromBase64 = UO6
})
// @from(Start 6888442, End 6890105)
A_B = z((BBG, eSB) => {
  var {
    defineProperty: MoA,
    getOwnPropertyDescriptor: $O6,
    getOwnPropertyNames: wO6
  } = Object, qO6 = Object.prototype.hasOwnProperty, id1 = (A, Q) => MoA(A, "name", {
    value: Q,
    configurable: !0
  }), NO6 = (A, Q) => {
    for (var B in Q) MoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, LO6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of wO6(Q))
        if (!qO6.call(A, Z) && Z !== B) MoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = $O6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, MO6 = (A) => LO6(MoA({}, "__esModule", {
    value: !0
  }), A), rSB = {};
  NO6(rSB, {
    fromUtf8: () => tSB,
    toUint8Array: () => OO6,
    toUtf8: () => RO6
  });
  eSB.exports = MO6(rSB);
  var oSB = LoA(),
    tSB = id1((A) => {
      let Q = (0, oSB.fromString)(A, "utf8");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength / Uint8Array.BYTES_PER_ELEMENT)
    }, "fromUtf8"),
    OO6 = id1((A) => {
      if (typeof A === "string") return tSB(A);
      if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      return new Uint8Array(A)
    }, "toUint8Array"),
    RO6 = id1((A) => {
      if (typeof A === "string") return A;
      if (typeof A !== "object" || typeof A.byteOffset !== "number" || typeof A.byteLength !== "number") throw Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      return (0, oSB.fromArrayBuffer)(A.buffer, A.byteOffset, A.byteLength).toString("utf8")
    }, "toUtf8")
})
// @from(Start 6890111, End 6890692)
G_B = z((Q_B) => {
  Object.defineProperty(Q_B, "__esModule", {
    value: !0
  });
  Q_B.toBase64 = void 0;
  var TO6 = LoA(),
    PO6 = A_B(),
    jO6 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, PO6.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, TO6.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  Q_B.toBase64 = jO6
})
// @from(Start 6890698, End 6891394)
sd1 = z((ZBG, OoA) => {
  var {
    defineProperty: Z_B,
    getOwnPropertyDescriptor: SO6,
    getOwnPropertyNames: _O6
  } = Object, kO6 = Object.prototype.hasOwnProperty, nd1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of _O6(Q))
        if (!kO6.call(A, Z) && Z !== B) Z_B(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = SO6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, I_B = (A, Q, B) => (nd1(A, Q, "default"), B && nd1(B, Q, "default")), yO6 = (A) => nd1(Z_B({}, "__esModule", {
    value: !0
  }), A), ad1 = {};
  OoA.exports = yO6(ad1);
  I_B(ad1, sSB(), OoA.exports);
  I_B(ad1, G_B(), OoA.exports)
})
// @from(Start 6891400, End 6891466)
p_ = L(() => {
  Hf();
  cm1();
  OrA();
  Hf();
  d_();
  pC()
})
// @from(Start 6891472, End 6899571)
V_B = z((KBG, X_B) => {
  var {
    defineProperty: RoA,
    getOwnPropertyDescriptor: xO6,
    getOwnPropertyNames: vO6
  } = Object, bO6 = Object.prototype.hasOwnProperty, UM = (A, Q) => RoA(A, "name", {
    value: Q,
    configurable: !0
  }), fO6 = (A, Q) => {
    for (var B in Q) RoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, hO6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of vO6(Q))
        if (!bO6.call(A, Z) && Z !== B) RoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = xO6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, gO6 = (A) => hO6(RoA({}, "__esModule", {
    value: !0
  }), A), W_B = {};
  fO6(W_B, {
    constructStack: () => rd1
  });
  X_B.exports = gO6(W_B);
  var Ve = UM((A, Q) => {
      let B = [];
      if (A) B.push(A);
      if (Q)
        for (let G of Q) B.push(G);
      return B
    }, "getAllAliases"),
    kp = UM((A, Q) => {
      return `${A||"anonymous"}${Q&&Q.length>0?` (a.k.a. ${Q.join(",")})`:""}`
    }, "getMiddlewareNameWithAliases"),
    rd1 = UM(() => {
      let A = [],
        Q = [],
        B = !1,
        G = new Set,
        Z = UM((F) => F.sort((K, D) => Y_B[D.step] - Y_B[K.step] || J_B[D.priority || "normal"] - J_B[K.priority || "normal"]), "sort"),
        I = UM((F) => {
          let K = !1,
            D = UM((H) => {
              let C = Ve(H.name, H.aliases);
              if (C.includes(F)) {
                K = !0;
                for (let E of C) G.delete(E);
                return !1
              }
              return !0
            }, "filterCb");
          return A = A.filter(D), Q = Q.filter(D), K
        }, "removeByName"),
        Y = UM((F) => {
          let K = !1,
            D = UM((H) => {
              if (H.middleware === F) {
                K = !0;
                for (let C of Ve(H.name, H.aliases)) G.delete(C);
                return !1
              }
              return !0
            }, "filterCb");
          return A = A.filter(D), Q = Q.filter(D), K
        }, "removeByReference"),
        J = UM((F) => {
          var K;
          return A.forEach((D) => {
            F.add(D.middleware, {
              ...D
            })
          }), Q.forEach((D) => {
            F.addRelativeTo(D.middleware, {
              ...D
            })
          }), (K = F.identifyOnResolve) == null || K.call(F, V.identifyOnResolve()), F
        }, "cloneTo"),
        W = UM((F) => {
          let K = [];
          return F.before.forEach((D) => {
            if (D.before.length === 0 && D.after.length === 0) K.push(D);
            else K.push(...W(D))
          }), K.push(F), F.after.reverse().forEach((D) => {
            if (D.before.length === 0 && D.after.length === 0) K.push(D);
            else K.push(...W(D))
          }), K
        }, "expandRelativeMiddlewareList"),
        X = UM((F = !1) => {
          let K = [],
            D = [],
            H = {};
          return A.forEach((E) => {
            let U = {
              ...E,
              before: [],
              after: []
            };
            for (let q of Ve(U.name, U.aliases)) H[q] = U;
            K.push(U)
          }), Q.forEach((E) => {
            let U = {
              ...E,
              before: [],
              after: []
            };
            for (let q of Ve(U.name, U.aliases)) H[q] = U;
            D.push(U)
          }), D.forEach((E) => {
            if (E.toMiddleware) {
              let U = H[E.toMiddleware];
              if (U === void 0) {
                if (F) return;
                throw Error(`${E.toMiddleware} is not found when adding ${kp(E.name,E.aliases)} middleware ${E.relation} ${E.toMiddleware}`)
              }
              if (E.relation === "after") U.after.push(E);
              if (E.relation === "before") U.before.push(E)
            }
          }), Z(K).map(W).reduce((E, U) => {
            return E.push(...U), E
          }, [])
        }, "getMiddlewareList"),
        V = {
          add: (F, K = {}) => {
            let {
              name: D,
              override: H,
              aliases: C
            } = K, E = {
              step: "initialize",
              priority: "normal",
              middleware: F,
              ...K
            }, U = Ve(D, C);
            if (U.length > 0) {
              if (U.some((q) => G.has(q))) {
                if (!H) throw Error(`Duplicate middleware name '${kp(D,C)}'`);
                for (let q of U) {
                  let w = A.findIndex((R) => {
                    var T;
                    return R.name === q || ((T = R.aliases) == null ? void 0 : T.some((y) => y === q))
                  });
                  if (w === -1) continue;
                  let N = A[w];
                  if (N.step !== E.step || E.priority !== N.priority) throw Error(`"${kp(N.name,N.aliases)}" middleware with ${N.priority} priority in ${N.step} step cannot be overridden by "${kp(D,C)}" middleware with ${E.priority} priority in ${E.step} step.`);
                  A.splice(w, 1)
                }
              }
              for (let q of U) G.add(q)
            }
            A.push(E)
          },
          addRelativeTo: (F, K) => {
            let {
              name: D,
              override: H,
              aliases: C
            } = K, E = {
              middleware: F,
              ...K
            }, U = Ve(D, C);
            if (U.length > 0) {
              if (U.some((q) => G.has(q))) {
                if (!H) throw Error(`Duplicate middleware name '${kp(D,C)}'`);
                for (let q of U) {
                  let w = Q.findIndex((R) => {
                    var T;
                    return R.name === q || ((T = R.aliases) == null ? void 0 : T.some((y) => y === q))
                  });
                  if (w === -1) continue;
                  let N = Q[w];
                  if (N.toMiddleware !== E.toMiddleware || N.relation !== E.relation) throw Error(`"${kp(N.name,N.aliases)}" middleware ${N.relation} "${N.toMiddleware}" middleware cannot be overridden by "${kp(D,C)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`);
                  Q.splice(w, 1)
                }
              }
              for (let q of U) G.add(q)
            }
            Q.push(E)
          },
          clone: () => J(rd1()),
          use: (F) => {
            F.applyToStack(V)
          },
          remove: (F) => {
            if (typeof F === "string") return I(F);
            else return Y(F)
          },
          removeByTag: (F) => {
            let K = !1,
              D = UM((H) => {
                let {
                  tags: C,
                  name: E,
                  aliases: U
                } = H;
                if (C && C.includes(F)) {
                  let q = Ve(E, U);
                  for (let w of q) G.delete(w);
                  return K = !0, !1
                }
                return !0
              }, "filterCb");
            return A = A.filter(D), Q = Q.filter(D), K
          },
          concat: (F) => {
            var K;
            let D = J(rd1());
            return D.use(F), D.identifyOnResolve(B || D.identifyOnResolve() || (((K = F.identifyOnResolve) == null ? void 0 : K.call(F)) ?? !1)), D
          },
          applyToStack: J,
          identify: () => {
            return X(!0).map((F) => {
              let K = F.step ?? F.relation + " " + F.toMiddleware;
              return kp(F.name, F.aliases) + " - " + K
            })
          },
          identifyOnResolve(F) {
            if (typeof F === "boolean") B = F;
            return B
          },
          resolve: (F, K) => {
            for (let D of X().map((H) => H.middleware).reverse()) F = D(F, K);
            if (B) console.log(V.identify());
            return F
          }
        };
      return V
    }, "constructStack"),
    Y_B = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1
    },
    J_B = {
      high: 3,
      normal: 2,
      low: 1
    }
})
// @from(Start 6899577, End 6900530)
D_B = z((DBG, K_B) => {
  var {
    defineProperty: ToA,
    getOwnPropertyDescriptor: uO6,
    getOwnPropertyNames: mO6
  } = Object, dO6 = Object.prototype.hasOwnProperty, cO6 = (A, Q) => ToA(A, "name", {
    value: Q,
    configurable: !0
  }), pO6 = (A, Q) => {
    for (var B in Q) ToA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, lO6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of mO6(Q))
        if (!dO6.call(A, Z) && Z !== B) ToA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = uO6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, iO6 = (A) => lO6(ToA({}, "__esModule", {
    value: !0
  }), A), F_B = {};
  pO6(F_B, {
    isArrayBuffer: () => nO6
  });
  K_B.exports = iO6(F_B);
  var nO6 = cO6((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 6900536, End 6901882)
td1 = z((HBG, E_B) => {
  var {
    defineProperty: PoA,
    getOwnPropertyDescriptor: aO6,
    getOwnPropertyNames: sO6
  } = Object, rO6 = Object.prototype.hasOwnProperty, H_B = (A, Q) => PoA(A, "name", {
    value: Q,
    configurable: !0
  }), oO6 = (A, Q) => {
    for (var B in Q) PoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, tO6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of sO6(Q))
        if (!rO6.call(A, Z) && Z !== B) PoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = aO6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, eO6 = (A) => tO6(PoA({}, "__esModule", {
    value: !0
  }), A), C_B = {};
  oO6(C_B, {
    fromArrayBuffer: () => QR6,
    fromString: () => BR6
  });
  E_B.exports = eO6(C_B);
  var AR6 = D_B(),
    od1 = UA("buffer"),
    QR6 = H_B((A, Q = 0, B = A.byteLength - Q) => {
      if (!(0, AR6.isArrayBuffer)(A)) throw TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof A} (${A})`);
      return od1.Buffer.from(A, Q, B)
    }, "fromArrayBuffer"),
    BR6 = H_B((A, Q) => {
      if (typeof A !== "string") throw TypeError(`The "input" argument must be of type string. Received type ${typeof A} (${A})`);
      return Q ? od1.Buffer.from(A, Q) : od1.Buffer.from(A)
    }, "fromString")
})
// @from(Start 6901888, End 6903551)
q_B = z((CBG, w_B) => {
  var {
    defineProperty: joA,
    getOwnPropertyDescriptor: GR6,
    getOwnPropertyNames: ZR6
  } = Object, IR6 = Object.prototype.hasOwnProperty, ed1 = (A, Q) => joA(A, "name", {
    value: Q,
    configurable: !0
  }), YR6 = (A, Q) => {
    for (var B in Q) joA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, JR6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ZR6(Q))
        if (!IR6.call(A, Z) && Z !== B) joA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = GR6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, WR6 = (A) => JR6(joA({}, "__esModule", {
    value: !0
  }), A), z_B = {};
  YR6(z_B, {
    fromUtf8: () => $_B,
    toUint8Array: () => XR6,
    toUtf8: () => VR6
  });
  w_B.exports = WR6(z_B);
  var U_B = td1(),
    $_B = ed1((A) => {
      let Q = (0, U_B.fromString)(A, "utf8");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength / Uint8Array.BYTES_PER_ELEMENT)
    }, "fromUtf8"),
    XR6 = ed1((A) => {
      if (typeof A === "string") return $_B(A);
      if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      return new Uint8Array(A)
    }, "toUint8Array"),
    VR6 = ed1((A) => {
      if (typeof A === "string") return A;
      if (typeof A !== "object" || typeof A.byteOffset !== "number" || typeof A.byteLength !== "number") throw Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      return (0, U_B.fromArrayBuffer)(A.buffer, A.byteOffset, A.byteLength).toString("utf8")
    }, "toUtf8")
})
// @from(Start 6903557, End 6904417)
M_B = z((N_B) => {
  Object.defineProperty(N_B, "__esModule", {
    value: !0
  });
  N_B.getAwsChunkedEncodingStream = void 0;
  var FR6 = UA("stream"),
    KR6 = (A, Q) => {
      let {
        base64Encoder: B,
        bodyLengthChecker: G,
        checksumAlgorithmFn: Z,
        checksumLocationName: I,
        streamHasher: Y
      } = Q, J = B !== void 0 && Z !== void 0 && I !== void 0 && Y !== void 0, W = J ? Y(Z, A) : void 0, X = new FR6.Readable({
        read: () => {}
      });
      return A.on("data", (V) => {
        let F = G(V) || 0;
        X.push(`${F.toString(16)}\r
`), X.push(V), X.push(`\r
`)
      }), A.on("end", async () => {
        if (X.push(`0\r
`), J) {
          let V = B(await W);
          X.push(`${I}:${V}\r
`), X.push(`\r
`)
        }
        X.push(null)
      }), X
    };
  N_B.getAwsChunkedEncodingStream = KR6
})
// @from(Start 6904423, End 6905476)
P_B = z((zBG, T_B) => {
  var {
    defineProperty: SoA,
    getOwnPropertyDescriptor: DR6,
    getOwnPropertyNames: HR6
  } = Object, CR6 = Object.prototype.hasOwnProperty, Ac1 = (A, Q) => SoA(A, "name", {
    value: Q,
    configurable: !0
  }), ER6 = (A, Q) => {
    for (var B in Q) SoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, zR6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of HR6(Q))
        if (!CR6.call(A, Z) && Z !== B) SoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = DR6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, UR6 = (A) => zR6(SoA({}, "__esModule", {
    value: !0
  }), A), O_B = {};
  ER6(O_B, {
    escapeUri: () => R_B,
    escapeUriPath: () => wR6
  });
  T_B.exports = UR6(O_B);
  var R_B = Ac1((A) => encodeURIComponent(A).replace(/[!'()*]/g, $R6), "escapeUri"),
    $R6 = Ac1((A) => `%${A.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode"),
    wR6 = Ac1((A) => A.split("/").map(R_B).join("/"), "escapeUriPath")
})
// @from(Start 6905482, End 6906733)
k_B = z((UBG, __B) => {
  var {
    defineProperty: _oA,
    getOwnPropertyDescriptor: qR6,
    getOwnPropertyNames: NR6
  } = Object, LR6 = Object.prototype.hasOwnProperty, MR6 = (A, Q) => _oA(A, "name", {
    value: Q,
    configurable: !0
  }), OR6 = (A, Q) => {
    for (var B in Q) _oA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, RR6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of NR6(Q))
        if (!LR6.call(A, Z) && Z !== B) _oA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qR6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, TR6 = (A) => RR6(_oA({}, "__esModule", {
    value: !0
  }), A), j_B = {};
  OR6(j_B, {
    buildQueryString: () => S_B
  });
  __B.exports = TR6(j_B);
  var Qc1 = P_B();

  function S_B(A) {
    let Q = [];
    for (let B of Object.keys(A).sort()) {
      let G = A[B];
      if (B = (0, Qc1.escapeUri)(B), Array.isArray(G))
        for (let Z = 0, I = G.length; Z < I; Z++) Q.push(`${B}=${(0,Qc1.escapeUri)(G[Z])}`);
      else {
        let Z = B;
        if (G || typeof G === "string") Z += `=${(0,Qc1.escapeUri)(G)}`;
        Q.push(Z)
      }
    }
    return Q.join("&")
  }
  MR6(S_B, "buildQueryString")
})
// @from(Start 6906739, End 6923358)
a_B = z(($BG, n_B) => {
  var {
    create: PR6,
    defineProperty: e$A,
    getOwnPropertyDescriptor: jR6,
    getOwnPropertyNames: SR6,
    getPrototypeOf: _R6
  } = Object, kR6 = Object.prototype.hasOwnProperty, hF = (A, Q) => e$A(A, "name", {
    value: Q,
    configurable: !0
  }), yR6 = (A, Q) => {
    for (var B in Q) e$A(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, v_B = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of SR6(Q))
        if (!kR6.call(A, Z) && Z !== B) e$A(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = jR6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, xR6 = (A, Q, B) => (B = A != null ? PR6(_R6(A)) : {}, v_B(Q || !A || !A.__esModule ? e$A(B, "default", {
    value: A,
    enumerable: !0
  }) : B, A)), vR6 = (A) => v_B(e$A({}, "__esModule", {
    value: !0
  }), A), b_B = {};
  yR6(b_B, {
    DEFAULT_REQUEST_TIMEOUT: () => uR6,
    NodeHttp2Handler: () => lR6,
    NodeHttpHandler: () => mR6,
    streamCollector: () => nR6
  });
  n_B.exports = vR6(b_B);
  var f_B = Od1(),
    h_B = k_B(),
    Bc1 = UA("http"),
    Gc1 = UA("https"),
    bR6 = ["ECONNRESET", "EPIPE", "ETIMEDOUT"],
    g_B = hF((A) => {
      let Q = {};
      for (let B of Object.keys(A)) {
        let G = A[B];
        Q[B] = Array.isArray(G) ? G.join(",") : G
      }
      return Q
    }, "getTransformedHeaders"),
    fR6 = hF((A, Q, B = 0) => {
      if (!B) return;
      let G = setTimeout(() => {
        A.destroy(), Q(Object.assign(Error(`Socket timed out without establishing a connection within ${B} ms`), {
          name: "TimeoutError"
        }))
      }, B);
      A.on("socket", (Z) => {
        if (Z.connecting) Z.on("connect", () => {
          clearTimeout(G)
        });
        else clearTimeout(G)
      })
    }, "setConnectionTimeout"),
    hR6 = hF((A, {
      keepAlive: Q,
      keepAliveMsecs: B
    }) => {
      if (Q !== !0) return;
      A.on("socket", (G) => {
        G.setKeepAlive(Q, B || 0)
      })
    }, "setSocketKeepAlive"),
    gR6 = hF((A, Q, B = 0) => {
      A.setTimeout(B, () => {
        A.destroy(), Q(Object.assign(Error(`Connection timed out after ${B} ms`), {
          name: "TimeoutError"
        }))
      })
    }, "setSocketTimeout"),
    u_B = UA("stream"),
    y_B = 1000;
  async function Zc1(A, Q, B = y_B) {
    let G = Q.headers ?? {},
      Z = G.Expect || G.expect,
      I = -1,
      Y = !1;
    if (Z === "100-continue") await Promise.race([new Promise((J) => {
      I = Number(setTimeout(J, Math.max(y_B, B)))
    }), new Promise((J) => {
      A.on("continue", () => {
        clearTimeout(I), J()
      }), A.on("error", () => {
        Y = !0, clearTimeout(I), J()
      })
    })]);
    if (!Y) m_B(A, Q.body)
  }
  hF(Zc1, "writeRequestBody");

  function m_B(A, Q) {
    if (Q instanceof u_B.Readable) {
      Q.pipe(A);
      return
    }
    if (Q) {
      if (Buffer.isBuffer(Q) || typeof Q === "string") {
        A.end(Q);
        return
      }
      let B = Q;
      if (typeof B === "object" && B.buffer && typeof B.byteOffset === "number" && typeof B.byteLength === "number") {
        A.end(Buffer.from(B.buffer, B.byteOffset, B.byteLength));
        return
      }
      A.end(Buffer.from(Q));
      return
    }
    A.end()
  }
  hF(m_B, "writeBody");
  var uR6 = 0,
    d_B = class A {
      constructor(Q) {
        this.socketWarningTimestamp = 0, this.metadata = {
          handlerProtocol: "http/1.1"
        }, this.configProvider = new Promise((B, G) => {
          if (typeof Q === "function") Q().then((Z) => {
            B(this.resolveDefaultConfig(Z))
          }).catch(G);
          else B(this.resolveDefaultConfig(Q))
        })
      }
      static create(Q) {
        if (typeof(Q == null ? void 0 : Q.handle) === "function") return Q;
        return new A(Q)
      }
      static checkSocketUsage(Q, B) {
        var G, Z;
        let {
          sockets: I,
          requests: Y,
          maxSockets: J
        } = Q;
        if (typeof J !== "number" || J === 1 / 0) return B;
        let W = 15000;
        if (Date.now() - W < B) return B;
        if (I && Y)
          for (let X in I) {
            let V = ((G = I[X]) == null ? void 0 : G.length) ?? 0,
              F = ((Z = Y[X]) == null ? void 0 : Z.length) ?? 0;
            if (V >= J && F >= 2 * J) return console.warn("@smithy/node-http-handler:WARN", `socket usage at capacity=${V} and ${F} additional requests are enqueued.`, "See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html", "or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config."), Date.now()
          }
        return B
      }
      resolveDefaultConfig(Q) {
        let {
          requestTimeout: B,
          connectionTimeout: G,
          socketTimeout: Z,
          httpAgent: I,
          httpsAgent: Y
        } = Q || {}, J = !0, W = 50;
        return {
          connectionTimeout: G,
          requestTimeout: B ?? Z,
          httpAgent: (() => {
            if (I instanceof Bc1.Agent || typeof(I == null ? void 0 : I.destroy) === "function") return I;
            return new Bc1.Agent({
              keepAlive: !0,
              maxSockets: 50,
              ...I
            })
          })(),
          httpsAgent: (() => {
            if (Y instanceof Gc1.Agent || typeof(Y == null ? void 0 : Y.destroy) === "function") return Y;
            return new Gc1.Agent({
              keepAlive: !0,
              maxSockets: 50,
              ...Y
            })
          })()
        }
      }
      destroy() {
        var Q, B, G, Z;
        (B = (Q = this.config) == null ? void 0 : Q.httpAgent) == null || B.destroy(), (Z = (G = this.config) == null ? void 0 : G.httpsAgent) == null || Z.destroy()
      }
      async handle(Q, {
        abortSignal: B
      } = {}) {
        if (!this.config) this.config = await this.configProvider;
        let G;
        return new Promise((Z, I) => {
          let Y = void 0,
            J = hF(async (q) => {
              await Y, clearTimeout(G), Z(q)
            }, "resolve"),
            W = hF(async (q) => {
              await Y, I(q)
            }, "reject");
          if (!this.config) throw Error("Node HTTP request handler config is not resolved");
          if (B == null ? void 0 : B.aborted) {
            let q = Error("Request aborted");
            q.name = "AbortError", W(q);
            return
          }
          let X = Q.protocol === "https:",
            V = X ? this.config.httpsAgent : this.config.httpAgent;
          G = setTimeout(() => {
            this.socketWarningTimestamp = A.checkSocketUsage(V, this.socketWarningTimestamp)
          }, this.config.socketAcquisitionWarningTimeout ?? (this.config.requestTimeout ?? 2000) + (this.config.connectionTimeout ?? 1000));
          let F = (0, h_B.buildQueryString)(Q.query || {}),
            K = void 0;
          if (Q.username != null || Q.password != null) {
            let q = Q.username ?? "",
              w = Q.password ?? "";
            K = `${q}:${w}`
          }
          let D = Q.path;
          if (F) D += `?${F}`;
          if (Q.fragment) D += `#${Q.fragment}`;
          let H = {
              headers: Q.headers,
              host: Q.hostname,
              method: Q.method,
              path: D,
              port: Q.port,
              agent: V,
              auth: K
            },
            E = (X ? Gc1.request : Bc1.request)(H, (q) => {
              let w = new f_B.HttpResponse({
                statusCode: q.statusCode || -1,
                reason: q.statusMessage,
                headers: g_B(q.headers),
                body: q
              });
              J({
                response: w
              })
            });
          if (E.on("error", (q) => {
              if (bR6.includes(q.code)) W(Object.assign(q, {
                name: "TimeoutError"
              }));
              else W(q)
            }), fR6(E, W, this.config.connectionTimeout), gR6(E, W, this.config.requestTimeout), B) B.onabort = () => {
            E.abort();
            let q = Error("Request aborted");
            q.name = "AbortError", W(q)
          };
          let U = H.agent;
          if (typeof U === "object" && "keepAlive" in U) hR6(E, {
            keepAlive: U.keepAlive,
            keepAliveMsecs: U.keepAliveMsecs
          });
          Y = Zc1(E, Q, this.config.requestTimeout).catch(I)
        })
      }
      updateHttpClientConfig(Q, B) {
        this.config = void 0, this.configProvider = this.configProvider.then((G) => {
          return {
            ...G,
            [Q]: B
          }
        })
      }
      httpHandlerConfigs() {
        return this.config ?? {}
      }
    };
  hF(d_B, "NodeHttpHandler");
  var mR6 = d_B,
    x_B = UA("http2"),
    dR6 = xR6(UA("http2")),
    c_B = class {
      constructor(Q) {
        this.sessions = [], this.sessions = Q ?? []
      }
      poll() {
        if (this.sessions.length > 0) return this.sessions.shift()
      }
      offerLast(Q) {
        this.sessions.push(Q)
      }
      contains(Q) {
        return this.sessions.includes(Q)
      }
      remove(Q) {
        this.sessions = this.sessions.filter((B) => B !== Q)
      } [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]()
      }
      destroy(Q) {
        for (let B of this.sessions)
          if (B === Q) {
            if (!B.destroyed) B.destroy()
          }
      }
    };
  hF(c_B, "NodeHttp2ConnectionPool");
  var cR6 = c_B,
    p_B = class {
      constructor(Q) {
        if (this.sessionCache = new Map, this.config = Q, this.config.maxConcurrency && this.config.maxConcurrency <= 0) throw RangeError("maxConcurrency must be greater than zero.")
      }
      lease(Q, B) {
        let G = this.getUrlString(Q),
          Z = this.sessionCache.get(G);
        if (Z) {
          let W = Z.poll();
          if (W && !this.config.disableConcurrency) return W
        }
        let I = dR6.default.connect(G);
        if (this.config.maxConcurrency) I.settings({
          maxConcurrentStreams: this.config.maxConcurrency
        }, (W) => {
          if (W) throw Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + Q.destination.toString())
        });
        I.unref();
        let Y = hF(() => {
          I.destroy(), this.deleteSession(G, I)
        }, "destroySessionCb");
        if (I.on("goaway", Y), I.on("error", Y), I.on("frameError", Y), I.on("close", () => this.deleteSession(G, I)), B.requestTimeout) I.setTimeout(B.requestTimeout, Y);
        let J = this.sessionCache.get(G) || new cR6;
        return J.offerLast(I), this.sessionCache.set(G, J), I
      }
      deleteSession(Q, B) {
        let G = this.sessionCache.get(Q);
        if (!G) return;
        if (!G.contains(B)) return;
        G.remove(B), this.sessionCache.set(Q, G)
      }
      release(Q, B) {
        var G;
        let Z = this.getUrlString(Q);
        (G = this.sessionCache.get(Z)) == null || G.offerLast(B)
      }
      destroy() {
        for (let [Q, B] of this.sessionCache) {
          for (let G of B) {
            if (!G.destroyed) G.destroy();
            B.remove(G)
          }
          this.sessionCache.delete(Q)
        }
      }
      setMaxConcurrentStreams(Q) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) throw RangeError("maxConcurrentStreams must be greater than zero.");
        this.config.maxConcurrency = Q
      }
      setDisableConcurrentStreams(Q) {
        this.config.disableConcurrency = Q
      }
      getUrlString(Q) {
        return Q.destination.toString()
      }
    };
  hF(p_B, "NodeHttp2ConnectionManager");
  var pR6 = p_B,
    l_B = class A {
      constructor(Q) {
        this.metadata = {
          handlerProtocol: "h2"
        }, this.connectionManager = new pR6({}), this.configProvider = new Promise((B, G) => {
          if (typeof Q === "function") Q().then((Z) => {
            B(Z || {})
          }).catch(G);
          else B(Q || {})
        })
      }
      static create(Q) {
        if (typeof(Q == null ? void 0 : Q.handle) === "function") return Q;
        return new A(Q)
      }
      destroy() {
        this.connectionManager.destroy()
      }
      async handle(Q, {
        abortSignal: B
      } = {}) {
        if (!this.config) {
          if (this.config = await this.configProvider, this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || !1), this.config.maxConcurrentStreams) this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams)
        }
        let {
          requestTimeout: G,
          disableConcurrentStreams: Z
        } = this.config;
        return new Promise((I, Y) => {
          var J;
          let W = !1,
            X = void 0,
            V = hF(async (x) => {
              await X, I(x)
            }, "resolve"),
            F = hF(async (x) => {
              await X, Y(x)
            }, "reject");
          if (B == null ? void 0 : B.aborted) {
            W = !0;
            let x = Error("Request aborted");
            x.name = "AbortError", F(x);
            return
          }
          let {
            hostname: K,
            method: D,
            port: H,
            protocol: C,
            query: E
          } = Q, U = "";
          if (Q.username != null || Q.password != null) {
            let x = Q.username ?? "",
              p = Q.password ?? "";
            U = `${x}:${p}@`
          }
          let q = `${C}//${U}${K}${H?`:${H}`:""}`,
            w = {
              destination: new URL(q)
            },
            N = this.connectionManager.lease(w, {
              requestTimeout: (J = this.config) == null ? void 0 : J.sessionTimeout,
              disableConcurrentStreams: Z || !1
            }),
            R = hF((x) => {
              if (Z) this.destroySession(N);
              W = !0, F(x)
            }, "rejectWithDestroy"),
            T = (0, h_B.buildQueryString)(E || {}),
            y = Q.path;
          if (T) y += `?${T}`;
          if (Q.fragment) y += `#${Q.fragment}`;
          let v = N.request({
            ...Q.headers,
            [x_B.constants.HTTP2_HEADER_PATH]: y,
            [x_B.constants.HTTP2_HEADER_METHOD]: D
          });
          if (N.ref(), v.on("response", (x) => {
              let p = new f_B.HttpResponse({
                statusCode: x[":status"] || -1,
                headers: g_B(x),
                body: v
              });
              if (W = !0, V({
                  response: p
                }), Z) N.close(), this.connectionManager.deleteSession(q, N)
            }), G) v.setTimeout(G, () => {
            v.close();
            let x = Error(`Stream timed out because of no activity for ${G} ms`);
            x.name = "TimeoutError", R(x)
          });
          if (B) B.onabort = () => {
            v.close();
            let x = Error("Request aborted");
            x.name = "AbortError", R(x)
          };
          v.on("frameError", (x, p, u) => {
            R(Error(`Frame type id ${x} in stream id ${u} has failed with code ${p}.`))
          }), v.on("error", R), v.on("aborted", () => {
            R(Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${v.rstCode}.`))
          }), v.on("close", () => {
            if (N.unref(), Z) N.destroy();
            if (!W) R(Error("Unexpected error: http2 request did not get a response"))
          }), X = Zc1(v, Q, G)
        })
      }
      updateHttpClientConfig(Q, B) {
        this.config = void 0, this.configProvider = this.configProvider.then((G) => {
          return {
            ...G,
            [Q]: B
          }
        })
      }
      httpHandlerConfigs() {
        return this.config ?? {}
      }
      destroySession(Q) {
        if (!Q.destroyed) Q.destroy()
      }
    };
  hF(l_B, "NodeHttp2Handler");
  var lR6 = l_B,
    i_B = class extends u_B.Writable {
      constructor() {
        super(...arguments);
        this.bufferedBytes = []
      }
      _write(Q, B, G) {
        this.bufferedBytes.push(Q), G()
      }
    };
  hF(i_B, "Collector");
  var iR6 = i_B,
    nR6 = hF((A) => new Promise((Q, B) => {
      let G = new iR6;
      A.pipe(G), A.on("error", (Z) => {
        G.end(), B(Z)
      }), G.on("error", B), G.on("finish", function() {
        let Z = new Uint8Array(Buffer.concat(this.bufferedBytes));
        Q(Z)
      })
    }), "streamCollector")
})
// @from(Start 6923364, End 6924929)
t_B = z((r_B) => {
  Object.defineProperty(r_B, "__esModule", {
    value: !0
  });
  r_B.sdkStreamMixin = void 0;
  var aR6 = a_B(),
    sR6 = td1(),
    Ic1 = UA("stream"),
    rR6 = UA("util"),
    s_B = "The stream has already been transformed.",
    oR6 = (A) => {
      var Q, B;
      if (!(A instanceof Ic1.Readable)) {
        let I = ((B = (Q = A === null || A === void 0 ? void 0 : A.__proto__) === null || Q === void 0 ? void 0 : Q.constructor) === null || B === void 0 ? void 0 : B.name) || A;
        throw Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${I}`)
      }
      let G = !1,
        Z = async () => {
          if (G) throw Error(s_B);
          return G = !0, await (0, aR6.streamCollector)(A)
        };
      return Object.assign(A, {
        transformToByteArray: Z,
        transformToString: async (I) => {
          let Y = await Z();
          if (I === void 0 || Buffer.isEncoding(I)) return (0, sR6.fromArrayBuffer)(Y.buffer, Y.byteOffset, Y.byteLength).toString(I);
          else return new rR6.TextDecoder(I).decode(Y)
        },
        transformToWebStream: () => {
          if (G) throw Error(s_B);
          if (A.readableFlowing !== null) throw Error("The stream has been consumed by other callbacks.");
          if (typeof Ic1.Readable.toWeb !== "function") throw Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
          return G = !0, Ic1.Readable.toWeb(A)
        }
      })
    };
  r_B.sdkStreamMixin = oR6
})
// @from(Start 6924935, End 6926717)
IkB = z((qBG, xoA) => {
  var {
    defineProperty: koA,
    getOwnPropertyDescriptor: tR6,
    getOwnPropertyNames: eR6
  } = Object, AT6 = Object.prototype.hasOwnProperty, Wc1 = (A, Q) => koA(A, "name", {
    value: Q,
    configurable: !0
  }), QT6 = (A, Q) => {
    for (var B in Q) koA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Yc1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of eR6(Q))
        if (!AT6.call(A, Z) && Z !== B) koA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = tR6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, e_B = (A, Q, B) => (Yc1(A, Q, "default"), B && Yc1(B, Q, "default")), BT6 = (A) => Yc1(koA({}, "__esModule", {
    value: !0
  }), A), yoA = {};
  QT6(yoA, {
    Uint8ArrayBlobAdapter: () => Jc1
  });
  xoA.exports = BT6(yoA);
  var AkB = sd1(),
    QkB = q_B();

  function BkB(A, Q = "utf-8") {
    if (Q === "base64") return (0, AkB.toBase64)(A);
    return (0, QkB.toUtf8)(A)
  }
  Wc1(BkB, "transformToString");

  function GkB(A, Q) {
    if (Q === "base64") return Jc1.mutate((0, AkB.fromBase64)(A));
    return Jc1.mutate((0, QkB.fromUtf8)(A))
  }
  Wc1(GkB, "transformFromString");
  var ZkB = class A extends Uint8Array {
    static fromString(Q, B = "utf-8") {
      switch (typeof Q) {
        case "string":
          return GkB(Q, B);
        default:
          throw Error(`Unsupported conversion from ${typeof Q} to Uint8ArrayBlobAdapter.`)
      }
    }
    static mutate(Q) {
      return Object.setPrototypeOf(Q, A.prototype), Q
    }
    transformToString(Q = "utf-8") {
      return BkB(this, Q)
    }
  };
  Wc1(ZkB, "Uint8ArrayBlobAdapter");
  var Jc1 = ZkB;
  e_B(yoA, M_B(), xoA.exports);
  e_B(yoA, t_B(), xoA.exports)
})
// @from(Start 6926723, End 6954251)
jkB = z((NBG, PkB) => {
  var {
    defineProperty: hoA,
    getOwnPropertyDescriptor: GT6,
    getOwnPropertyNames: ZT6
  } = Object, IT6 = Object.prototype.hasOwnProperty, EB = (A, Q) => hoA(A, "name", {
    value: Q,
    configurable: !0
  }), YT6 = (A, Q) => {
    for (var B in Q) hoA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, JT6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ZT6(Q))
        if (!IT6.call(A, Z) && Z !== B) hoA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = GT6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, WT6 = (A) => JT6(hoA({}, "__esModule", {
    value: !0
  }), A), JkB = {};
  YT6(JkB, {
    Client: () => VT6,
    Command: () => KkB,
    LazyJsonString: () => YP6,
    NoOpLogger: () => XT6,
    SENSITIVE_STRING: () => DT6,
    ServiceException: () => aT6,
    StringWrapper: () => ZwA,
    _json: () => Cc1,
    collectBody: () => FT6,
    convertMap: () => JP6,
    createAggregatedClient: () => HT6,
    dateToUtcString: () => $kB,
    decorateServiceException: () => qkB,
    emitWarningIfUnsupportedVersion: () => tT6,
    expectBoolean: () => ET6,
    expectByte: () => Hc1,
    expectFloat32: () => voA,
    expectInt: () => UT6,
    expectInt32: () => Kc1,
    expectLong: () => BwA,
    expectNonNull: () => wT6,
    expectNumber: () => QwA,
    expectObject: () => HkB,
    expectShort: () => Dc1,
    expectString: () => qT6,
    expectUnion: () => NT6,
    extendedEncodeURIComponent: () => foA,
    getArrayIfSingleItem: () => IP6,
    getDefaultClientConfiguration: () => GP6,
    getDefaultExtensionConfiguration: () => LkB,
    getValueFromTextNode: () => MkB,
    handleFloat: () => OT6,
    limitedParseDouble: () => Uc1,
    limitedParseFloat: () => RT6,
    limitedParseFloat32: () => TT6,
    loadConfigsForDefaultMode: () => oT6,
    logger: () => GwA,
    map: () => wc1,
    parseBoolean: () => CT6,
    parseEpochTimestamp: () => gT6,
    parseRfc3339DateTime: () => kT6,
    parseRfc3339DateTimeWithOffset: () => xT6,
    parseRfc7231DateTime: () => hT6,
    resolveDefaultRuntimeConfig: () => ZP6,
    resolvedPath: () => KP6,
    serializeFloat: () => DP6,
    splitEvery: () => TkB,
    strictParseByte: () => UkB,
    strictParseDouble: () => zc1,
    strictParseFloat: () => LT6,
    strictParseFloat32: () => CkB,
    strictParseInt: () => PT6,
    strictParseInt32: () => jT6,
    strictParseLong: () => zkB,
    strictParseShort: () => $GA,
    take: () => WP6,
    throwDefaultError: () => NkB,
    withBaseException: () => sT6
  });
  PkB.exports = WT6(JkB);
  var WkB = class {
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };
  EB(WkB, "NoOpLogger");
  var XT6 = WkB,
    XkB = V_B(),
    VkB = class {
      constructor(Q) {
        this.middlewareStack = (0, XkB.constructStack)(), this.config = Q
      }
      send(Q, B, G) {
        let Z = typeof B !== "function" ? B : void 0,
          I = typeof B === "function" ? B : G,
          Y = Q.resolveMiddleware(this.middlewareStack, this.config, Z);
        if (I) Y(Q).then((J) => I(null, J.output), (J) => I(J)).catch(() => {});
        else return Y(Q).then((J) => J.output)
      }
      destroy() {
        if (this.config.requestHandler.destroy) this.config.requestHandler.destroy()
      }
    };
  EB(VkB, "Client");
  var VT6 = VkB,
    Xc1 = IkB(),
    FT6 = EB(async (A = new Uint8Array, Q) => {
      if (A instanceof Uint8Array) return Xc1.Uint8ArrayBlobAdapter.mutate(A);
      if (!A) return Xc1.Uint8ArrayBlobAdapter.mutate(new Uint8Array);
      let B = Q.streamCollector(A);
      return Xc1.Uint8ArrayBlobAdapter.mutate(await B)
    }, "collectBody"),
    Fc1 = Md1(),
    FkB = class {
      constructor() {
        this.middlewareStack = (0, XkB.constructStack)()
      }
      static classBuilder() {
        return new KT6
      }
      resolveMiddlewareWithContext(Q, B, G, {
        middlewareFn: Z,
        clientName: I,
        commandName: Y,
        inputFilterSensitiveLog: J,
        outputFilterSensitiveLog: W,
        smithyContext: X,
        additionalContext: V,
        CommandCtor: F
      }) {
        for (let E of Z.bind(this)(F, Q, B, G)) this.middlewareStack.use(E);
        let K = Q.concat(this.middlewareStack),
          {
            logger: D
          } = B,
          H = {
            logger: D,
            clientName: I,
            commandName: Y,
            inputFilterSensitiveLog: J,
            outputFilterSensitiveLog: W,
            [Fc1.SMITHY_CONTEXT_KEY]: {
              ...X
            },
            ...V
          },
          {
            requestHandler: C
          } = B;
        return K.resolve((E) => C.handle(E.request, G || {}), H)
      }
    };
  EB(FkB, "Command");
  var KkB = FkB,
    DkB = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (Q) => Q, this._outputFilterSensitiveLog = (Q) => Q, this._serializer = null, this._deserializer = null
      }
      init(Q) {
        this._init = Q
      }
      ep(Q) {
        return this._ep = Q, this
      }
      m(Q) {
        return this._middlewareFn = Q, this
      }
      s(Q, B, G = {}) {
        return this._smithyContext = {
          service: Q,
          operation: B,
          ...G
        }, this
      }
      c(Q = {}) {
        return this._additionalContext = Q, this
      }
      n(Q, B) {
        return this._clientName = Q, this._commandName = B, this
      }
      f(Q = (G) => G, B = (G) => G) {
        return this._inputFilterSensitiveLog = Q, this._outputFilterSensitiveLog = B, this
      }
      ser(Q) {
        return this._serializer = Q, this
      }
      de(Q) {
        return this._deserializer = Q, this
      }
      build() {
        var Q;
        let B = this,
          G;
        return G = (Q = class extends KkB {
          constructor(...[Z]) {
            super();
            this.serialize = B._serializer, this.deserialize = B._deserializer, this.input = Z ?? {}, B._init(this)
          }
          static getEndpointParameterInstructions() {
            return B._ep
          }
          resolveMiddleware(Z, I, Y) {
            return this.resolveMiddlewareWithContext(Z, I, Y, {
              CommandCtor: G,
              middlewareFn: B._middlewareFn,
              clientName: B._clientName,
              commandName: B._commandName,
              inputFilterSensitiveLog: B._inputFilterSensitiveLog,
              outputFilterSensitiveLog: B._outputFilterSensitiveLog,
              smithyContext: B._smithyContext,
              additionalContext: B._additionalContext
            })
          }
        }, EB(Q, "CommandRef"), Q)
      }
    };
  EB(DkB, "ClassBuilder");
  var KT6 = DkB,
    DT6 = "***SensitiveInformation***",
    HT6 = EB((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = EB(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    CT6 = EB((A) => {
      switch (A) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw Error(`Unable to parse boolean value "${A}"`)
      }
    }, "parseBoolean"),
    ET6 = EB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "number") {
        if (A === 0 || A === 1) GwA.warn(boA(`Expected boolean, got ${typeof A}: ${A}`));
        if (A === 0) return !1;
        if (A === 1) return !0
      }
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (Q === "false" || Q === "true") GwA.warn(boA(`Expected boolean, got ${typeof A}: ${A}`));
        if (Q === "false") return !1;
        if (Q === "true") return !0
      }
      if (typeof A === "boolean") return A;
      throw TypeError(`Expected boolean, got ${typeof A}: ${A}`)
    }, "expectBoolean"),
    QwA = EB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") {
        let Q = parseFloat(A);
        if (!Number.isNaN(Q)) {
          if (String(Q) !== String(A)) GwA.warn(boA(`Expected number but observed string: ${A}`));
          return Q
        }
      }
      if (typeof A === "number") return A;
      throw TypeError(`Expected number, got ${typeof A}: ${A}`)
    }, "expectNumber"),
    zT6 = Math.ceil(340282346638528860000000000000000000000),
    voA = EB((A) => {
      let Q = QwA(A);
      if (Q !== void 0 && !Number.isNaN(Q) && Q !== 1 / 0 && Q !== -1 / 0) {
        if (Math.abs(Q) > zT6) throw TypeError(`Expected 32-bit float, got ${A}`)
      }
      return Q
    }, "expectFloat32"),
    BwA = EB((A) => {
      if (A === null || A === void 0) return;
      if (Number.isInteger(A) && !Number.isNaN(A)) return A;
      throw TypeError(`Expected integer, got ${typeof A}: ${A}`)
    }, "expectLong"),
    UT6 = BwA,
    Kc1 = EB((A) => Ec1(A, 32), "expectInt32"),
    Dc1 = EB((A) => Ec1(A, 16), "expectShort"),
    Hc1 = EB((A) => Ec1(A, 8), "expectByte"),
    Ec1 = EB((A, Q) => {
      let B = BwA(A);
      if (B !== void 0 && $T6(B, Q) !== B) throw TypeError(`Expected ${Q}-bit integer, got ${A}`);
      return B
    }, "expectSizedInt"),
    $T6 = EB((A, Q) => {
      switch (Q) {
        case 32:
          return Int32Array.of(A)[0];
        case 16:
          return Int16Array.of(A)[0];
        case 8:
          return Int8Array.of(A)[0]
      }
    }, "castInt"),
    wT6 = EB((A, Q) => {
      if (A === null || A === void 0) {
        if (Q) throw TypeError(`Expected a non-null value for ${Q}`);
        throw TypeError("Expected a non-null value")
      }
      return A
    }, "expectNonNull"),
    HkB = EB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "object" && !Array.isArray(A)) return A;
      let Q = Array.isArray(A) ? "array" : typeof A;
      throw TypeError(`Expected object, got ${Q}: ${A}`)
    }, "expectObject"),
    qT6 = EB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") return A;
      if (["boolean", "number", "bigint"].includes(typeof A)) return GwA.warn(boA(`Expected string, got ${typeof A}: ${A}`)), String(A);
      throw TypeError(`Expected string, got ${typeof A}: ${A}`)
    }, "expectString"),
    NT6 = EB((A) => {
      if (A === null || A === void 0) return;
      let Q = HkB(A),
        B = Object.entries(Q).filter(([, G]) => G != null).map(([G]) => G);
      if (B.length === 0) throw TypeError("Unions must have exactly one non-null member. None were found.");
      if (B.length > 1) throw TypeError(`Unions must have exactly one non-null member. Keys ${B} were not null.`);
      return Q
    }, "expectUnion"),
    zc1 = EB((A) => {
      if (typeof A == "string") return QwA(qGA(A));
      return QwA(A)
    }, "strictParseDouble"),
    LT6 = zc1,
    CkB = EB((A) => {
      if (typeof A == "string") return voA(qGA(A));
      return voA(A)
    }, "strictParseFloat32"),
    MT6 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    qGA = EB((A) => {
      let Q = A.match(MT6);
      if (Q === null || Q[0].length !== A.length) throw TypeError("Expected real number, got implicit NaN");
      return parseFloat(A)
    }, "parseNumber"),
    Uc1 = EB((A) => {
      if (typeof A == "string") return EkB(A);
      return QwA(A)
    }, "limitedParseDouble"),
    OT6 = Uc1,
    RT6 = Uc1,
    TT6 = EB((A) => {
      if (typeof A == "string") return EkB(A);
      return voA(A)
    }, "limitedParseFloat32"),
    EkB = EB((A) => {
      switch (A) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw Error(`Unable to parse float value: ${A}`)
      }
    }, "parseFloatString"),
    zkB = EB((A) => {
      if (typeof A === "string") return BwA(qGA(A));
      return BwA(A)
    }, "strictParseLong"),
    PT6 = zkB,
    jT6 = EB((A) => {
      if (typeof A === "string") return Kc1(qGA(A));
      return Kc1(A)
    }, "strictParseInt32"),
    $GA = EB((A) => {
      if (typeof A === "string") return Dc1(qGA(A));
      return Dc1(A)
    }, "strictParseShort"),
    UkB = EB((A) => {
      if (typeof A === "string") return Hc1(qGA(A));
      return Hc1(A)
    }, "strictParseByte"),
    boA = EB((A) => {
      return String(TypeError(A).stack || A).split(`
`).slice(0, 5).filter((Q) => !Q.includes("stackTraceWarning")).join(`
`)
    }, "stackTraceWarning"),
    GwA = {
      warn: console.warn
    },
    ST6 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    $c1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  function $kB(A) {
    let Q = A.getUTCFullYear(),
      B = A.getUTCMonth(),
      G = A.getUTCDay(),
      Z = A.getUTCDate(),
      I = A.getUTCHours(),
      Y = A.getUTCMinutes(),
      J = A.getUTCSeconds(),
      W = Z < 10 ? `0${Z}` : `${Z}`,
      X = I < 10 ? `0${I}` : `${I}`,
      V = Y < 10 ? `0${Y}` : `${Y}`,
      F = J < 10 ? `0${J}` : `${J}`;
    return `${ST6[G]}, ${W} ${$c1[B]} ${Q} ${X}:${V}:${F} GMT`
  }
  EB($kB, "dateToUtcString");
  var _T6 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/),
    kT6 = EB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = _T6.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X] = Q, V = $GA(wGA(G)), F = l_(Z, "month", 1, 12), K = l_(I, "day", 1, 31);
      return AwA(V, F, K, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      })
    }, "parseRfc3339DateTime"),
    yT6 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/),
    xT6 = EB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = yT6.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X, V] = Q, F = $GA(wGA(G)), K = l_(Z, "month", 1, 12), D = l_(I, "day", 1, 31), H = AwA(F, K, D, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      });
      if (V.toUpperCase() != "Z") H.setTime(H.getTime() - nT6(V));
      return H
    }, "parseRfc3339DateTimeWithOffset"),
    vT6 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    bT6 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    fT6 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/),
    hT6 = EB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-7231 date-times must be expressed as strings");
      let Q = vT6.exec(A);
      if (Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return AwA($GA(wGA(I)), Vc1(Z), l_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        })
      }
      if (Q = bT6.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return dT6(AwA(uT6(I), Vc1(Z), l_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        }))
      }
      if (Q = fT6.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return AwA($GA(wGA(X)), Vc1(G), l_(Z.trimLeft(), "day", 1, 31), {
          hours: I,
          minutes: Y,
          seconds: J,
          fractionalMilliseconds: W
        })
      }
      throw TypeError("Invalid RFC-7231 date-time value")
    }, "parseRfc7231DateTime"),
    gT6 = EB((A) => {
      if (A === null || A === void 0) return;
      let Q;
      if (typeof A === "number") Q = A;
      else if (typeof A === "string") Q = zc1(A);
      else throw TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      if (Number.isNaN(Q) || Q === 1 / 0 || Q === -1 / 0) throw TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      return new Date(Math.round(Q * 1000))
    }, "parseEpochTimestamp"),
    AwA = EB((A, Q, B, G) => {
      let Z = Q - 1;
      return pT6(A, Z, B), new Date(Date.UTC(A, Z, B, l_(G.hours, "hour", 0, 23), l_(G.minutes, "minute", 0, 59), l_(G.seconds, "seconds", 0, 60), iT6(G.fractionalMilliseconds)))
    }, "buildDate"),
    uT6 = EB((A) => {
      let Q = new Date().getUTCFullYear(),
        B = Math.floor(Q / 100) * 100 + $GA(wGA(A));
      if (B < Q) return B + 100;
      return B
    }, "parseTwoDigitYear"),
    mT6 = 1576800000000,
    dT6 = EB((A) => {
      if (A.getTime() - new Date().getTime() > mT6) return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));
      return A
    }, "adjustRfc850Year"),
    Vc1 = EB((A) => {
      let Q = $c1.indexOf(A);
      if (Q < 0) throw TypeError(`Invalid month: ${A}`);
      return Q + 1
    }, "parseMonthByShortName"),
    cT6 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    pT6 = EB((A, Q, B) => {
      let G = cT6[Q];
      if (Q === 1 && lT6(A)) G = 29;
      if (B > G) throw TypeError(`Invalid day for ${$c1[Q]} in ${A}: ${B}`)
    }, "validateDayOfMonth"),
    lT6 = EB((A) => {
      return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0)
    }, "isLeapYear"),
    l_ = EB((A, Q, B, G) => {
      let Z = UkB(wGA(A));
      if (Z < B || Z > G) throw TypeError(`${Q} must be between ${B} and ${G}, inclusive`);
      return Z
    }, "parseDateValue"),
    iT6 = EB((A) => {
      if (A === null || A === void 0) return 0;
      return CkB("0." + A) * 1000
    }, "parseMilliseconds"),
    nT6 = EB((A) => {
      let Q = A[0],
        B = 1;
      if (Q == "+") B = 1;
      else if (Q == "-") B = -1;
      else throw TypeError(`Offset direction, ${Q}, must be "+" or "-"`);
      let G = Number(A.substring(1, 3)),
        Z = Number(A.substring(4, 6));
      return B * (G * 60 + Z) * 60 * 1000
    }, "parseOffsetToMilliseconds"),
    wGA = EB((A) => {
      let Q = 0;
      while (Q < A.length - 1 && A.charAt(Q) === "0") Q++;
      if (Q === 0) return A;
      return A.slice(Q)
    }, "stripLeadingZeroes"),
    wkB = class A extends Error {
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, A.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
    };
  EB(wkB, "ServiceException");
  var aT6 = wkB,
    qkB = EB((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    NkB = EB(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = rT6(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: (Q == null ? void 0 : Q.code) || (Q == null ? void 0 : Q.Code) || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw qkB(Y, Q)
    }, "throwDefaultError"),
    sT6 = EB((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        NkB({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    rT6 = EB((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    oT6 = EB((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    YkB = !1,
    tT6 = EB((A) => {
      if (A && !YkB && parseInt(A.substring(1, A.indexOf("."))) < 14) YkB = !0
    }, "emitWarningIfUnsupportedVersion"),
    eT6 = EB((A) => {
      let Q = [];
      for (let B in Fc1.AlgorithmId) {
        let G = Fc1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        _checksumAlgorithms: Q,
        addChecksumAlgorithm(B) {
          this._checksumAlgorithms.push(B)
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms
        }
      }
    }, "getChecksumConfiguration"),
    AP6 = EB((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    QP6 = EB((A) => {
      let Q = A.retryStrategy;
      return {
        setRetryStrategy(B) {
          Q = B
        },
        retryStrategy() {
          return Q
        }
      }
    }, "getRetryConfiguration"),
    BP6 = EB((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    LkB = EB((A) => {
      return {
        ...eT6(A),
        ...QP6(A)
      }
    }, "getDefaultExtensionConfiguration"),
    GP6 = LkB,
    ZP6 = EB((A) => {
      return {
        ...AP6(A),
        ...BP6(A)
      }
    }, "resolveDefaultRuntimeConfig");

  function foA(A) {
    return encodeURIComponent(A).replace(/[!'()*]/g, function(Q) {
      return "%" + Q.charCodeAt(0).toString(16).toUpperCase()
    })
  }
  EB(foA, "extendedEncodeURIComponent");
  var IP6 = EB((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    MkB = EB((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = MkB(A[B]);
      return A
    }, "getValueFromTextNode"),
    ZwA = EB(function() {
      let A = Object.getPrototypeOf(this).constructor,
        B = new(Function.bind.apply(String, [null, ...arguments]));
      return Object.setPrototypeOf(B, A.prototype), B
    }, "StringWrapper");
  ZwA.prototype = Object.create(String.prototype, {
    constructor: {
      value: ZwA,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
  Object.setPrototypeOf(ZwA, String);
  var OkB = class A extends ZwA {
    deserializeJSON() {
      return JSON.parse(super.toString())
    }
    toJSON() {
      return super.toString()
    }
    static fromObject(Q) {
      if (Q instanceof A) return Q;
      else if (Q instanceof String || typeof Q === "string") return new A(Q);
      return new A(JSON.stringify(Q))
    }
  };
  EB(OkB, "LazyJsonString");
  var YP6 = OkB;

  function wc1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, XP6(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      RkB(G, null, I, Y)
    }
    return G
  }
  EB(wc1, "map");
  var JP6 = EB((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    WP6 = EB((A, Q) => {
      let B = {};
      for (let G in Q) RkB(B, A, Q, G);
      return B
    }, "take"),
    XP6 = EB((A, Q, B) => {
      return wc1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    RkB = EB((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = VP6, W = FP6, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    VP6 = EB((A) => A != null, "nonNullish"),
    FP6 = EB((A) => A, "pass"),
    KP6 = EB((A, Q, B, G, Z, I) => {
      if (Q != null && Q[B] !== void 0) {
        let Y = G();
        if (Y.length <= 0) throw Error("Empty value provided for input HTTP label: " + B + ".");
        A = A.replace(Z, I ? Y.split("/").map((J) => foA(J)).join("/") : foA(Y))
      } else throw Error("No value provided for input HTTP label: " + B + ".");
      return A
    }, "resolvedPath"),
    DP6 = EB((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    Cc1 = EB((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(Cc1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = Cc1(A[B])
        }
        return Q
      }
      return A
    }, "_json");

  function TkB(A, Q, B) {
    if (B <= 0 || !Number.isInteger(B)) throw Error("Invalid number of delimiters (" + B + ") for splitEvery.");
    let G = A.split(Q);
    if (B === 1) return G;
    let Z = [],
      I = "";
    for (let Y = 0; Y < G.length; Y++) {
      if (I === "") I = G[Y];
      else I += Q + G[Y];
      if ((Y + 1) % B === 0) Z.push(I), I = ""
    }
    if (I !== "") Z.push(I);
    return Z
  }
  EB(TkB, "splitEvery")
})
// @from(Start 6954257, End 6957040)
gkB = z((MBG, hkB) => {
  var {
    defineProperty: goA,
    getOwnPropertyDescriptor: HP6,
    getOwnPropertyNames: CP6
  } = Object, EP6 = Object.prototype.hasOwnProperty, uoA = (A, Q) => goA(A, "name", {
    value: Q,
    configurable: !0
  }), zP6 = (A, Q) => {
    for (var B in Q) goA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, UP6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of CP6(Q))
        if (!EP6.call(A, Z) && Z !== B) goA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = HP6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, $P6 = (A) => UP6(goA({}, "__esModule", {
    value: !0
  }), A), SkB = {};
  zP6(SkB, {
    AlgorithmId: () => xkB,
    EndpointURLScheme: () => ykB,
    FieldPosition: () => vkB,
    HttpApiKeyAuthLocation: () => kkB,
    HttpAuthLocation: () => _kB,
    IniSectionType: () => bkB,
    RequestHandlerProtocol: () => fkB,
    SMITHY_CONTEXT_KEY: () => MP6,
    getDefaultClientConfiguration: () => NP6,
    resolveDefaultRuntimeConfig: () => LP6
  });
  hkB.exports = $P6(SkB);
  var _kB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(_kB || {}),
    kkB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(kkB || {}),
    ykB = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(ykB || {}),
    xkB = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(xkB || {}),
    wP6 = uoA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    qP6 = uoA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    NP6 = uoA((A) => {
      return wP6(A)
    }, "getDefaultClientConfiguration"),
    LP6 = uoA((A) => {
      return qP6(A)
    }, "resolveDefaultRuntimeConfig"),
    vkB = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(vkB || {}),
    MP6 = "__smithy_context",
    bkB = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(bkB || {}),
    fkB = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(fkB || {})
})
// @from(Start 6957046, End 6961553)
lkB = z((OBG, pkB) => {
  var {
    defineProperty: moA,
    getOwnPropertyDescriptor: OP6,
    getOwnPropertyNames: RP6
  } = Object, TP6 = Object.prototype.hasOwnProperty, yp = (A, Q) => moA(A, "name", {
    value: Q,
    configurable: !0
  }), PP6 = (A, Q) => {
    for (var B in Q) moA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, jP6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of RP6(Q))
        if (!TP6.call(A, Z) && Z !== B) moA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = OP6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, SP6 = (A) => jP6(moA({}, "__esModule", {
    value: !0
  }), A), ukB = {};
  PP6(ukB, {
    Field: () => yP6,
    Fields: () => xP6,
    HttpRequest: () => vP6,
    HttpResponse: () => bP6,
    IHttpRequest: () => mkB.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => _P6,
    isValidHostname: () => ckB,
    resolveHttpHandlerRuntimeConfig: () => kP6
  });
  pkB.exports = SP6(ukB);
  var _P6 = yp((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    kP6 = yp((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    mkB = gkB(),
    yP6 = class {
      static {
        yp(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = mkB.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    xP6 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        yp(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    vP6 = class A {
      static {
        yp(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = dkB(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function dkB(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  yp(dkB, "cloneQuery");
  var bP6 = class {
    static {
      yp(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function ckB(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  yp(ckB, "isValidHostname")
})
// @from(Start 6961559, End 6964114)
AyB = z((jBG, ekB) => {
  var {
    defineProperty: doA,
    getOwnPropertyDescriptor: fP6,
    getOwnPropertyNames: hP6
  } = Object, gP6 = Object.prototype.hasOwnProperty, IwA = (A, Q) => doA(A, "name", {
    value: Q,
    configurable: !0
  }), uP6 = (A, Q) => {
    for (var B in Q) doA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, mP6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of hP6(Q))
        if (!gP6.call(A, Z) && Z !== B) doA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = fP6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, dP6 = (A) => mP6(doA({}, "__esModule", {
    value: !0
  }), A), ikB = {};
  uP6(ikB, {
    eventStreamHandlingMiddleware: () => skB,
    eventStreamHandlingMiddlewareOptions: () => rkB,
    eventStreamHeaderMiddleware: () => okB,
    eventStreamHeaderMiddlewareOptions: () => tkB,
    getEventStreamPlugin: () => cP6,
    resolveEventStreamConfig: () => nkB
  });
  ekB.exports = dP6(ikB);

  function nkB(A) {
    let {
      signer: Q,
      signer: B
    } = A, G = Object.assign(A, {
      eventSigner: Q,
      messageSigner: B
    }), Z = G.eventStreamPayloadHandlerProvider(G);
    return Object.assign(G, {
      eventStreamPayloadHandler: Z
    })
  }
  IwA(nkB, "resolveEventStreamConfig");
  var akB = lkB(),
    skB = IwA((A) => (Q, B) => async (G) => {
      let {
        request: Z
      } = G;
      if (!akB.HttpRequest.isInstance(Z)) return Q(G);
      return A.eventStreamPayloadHandler.handle(Q, G, B)
    }, "eventStreamHandlingMiddleware"),
    rkB = {
      tags: ["EVENT_STREAM", "SIGNATURE", "HANDLE"],
      name: "eventStreamHandlingMiddleware",
      relation: "after",
      toMiddleware: "awsAuthMiddleware",
      override: !0
    },
    okB = IwA((A) => async (Q) => {
      let {
        request: B
      } = Q;
      if (!akB.HttpRequest.isInstance(B)) return A(Q);
      return B.headers = {
        ...B.headers,
        "content-type": "application/vnd.amazon.eventstream",
        "x-amz-content-sha256": "STREAMING-AWS4-HMAC-SHA256-EVENTS"
      }, A({
        ...Q,
        request: B
      })
    }, "eventStreamHeaderMiddleware"),
    tkB = {
      step: "build",
      tags: ["EVENT_STREAM", "HEADER", "CONTENT_TYPE", "CONTENT_SHA256"],
      name: "eventStreamHeaderMiddleware",
      override: !0
    },
    cP6 = IwA((A) => ({
      applyToStack: IwA((Q) => {
        Q.addRelativeTo(skB(A), rkB), Q.add(okB, tkB)
      }, "applyToStack")
    }), "getEventStreamPlugin")
})
// @from(Start 6964120, End 6965060)
GyB = z((SBG, ByB) => {
  var {
    defineProperty: coA,
    getOwnPropertyDescriptor: pP6,
    getOwnPropertyNames: lP6
  } = Object, iP6 = Object.prototype.hasOwnProperty, nP6 = (A, Q) => coA(A, "name", {
    value: Q,
    configurable: !0
  }), aP6 = (A, Q) => {
    for (var B in Q) coA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, sP6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of lP6(Q))
        if (!iP6.call(A, Z) && Z !== B) coA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = pP6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, rP6 = (A) => sP6(coA({}, "__esModule", {
    value: !0
  }), A), QyB = {};
  aP6(QyB, {
    resolveEventStreamSerdeConfig: () => oP6
  });
  ByB.exports = rP6(QyB);
  var oP6 = nP6((A) => Object.assign(A, {
    eventStreamMarshaller: A.eventStreamSerdeProvider(A)
  }), "resolveEventStreamSerdeConfig")
})
// @from(Start 6965066, End 6966409)
Nc1 = z((ZyB) => {
  Object.defineProperty(ZyB, "__esModule", {
    value: !0
  });
  ZyB.resolveHttpAuthSchemeConfig = ZyB.defaultBedrockRuntimeHttpAuthSchemeProvider = ZyB.defaultBedrockRuntimeHttpAuthSchemeParametersProvider = void 0;
  var tP6 = jF(),
    qc1 = w7(),
    eP6 = async (A, Q, B) => {
      return {
        operation: (0, qc1.getSmithyContext)(Q).operation,
        region: await (0, qc1.normalizeProvider)(A.region)() || (() => {
          throw Error("expected `region` to be configured for `aws.auth#sigv4`")
        })()
      }
    };
  ZyB.defaultBedrockRuntimeHttpAuthSchemeParametersProvider = eP6;

  function Aj6(A) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "bedrock",
        region: A.region
      },
      propertiesExtractor: (Q, B) => ({
        signingProperties: {
          config: Q,
          context: B
        }
      })
    }
  }
  var Qj6 = (A) => {
    let Q = [];
    switch (A.operation) {
      default:
        Q.push(Aj6(A))
    }
    return Q
  };
  ZyB.defaultBedrockRuntimeHttpAuthSchemeProvider = Qj6;
  var Bj6 = (A) => {
    let Q = (0, tP6.resolveAwsSdkSigV4Config)(A);
    return Object.assign(Q, {
      authSchemePreference: (0, qc1.normalizeProvider)(A.authSchemePreference ?? [])
    })
  };
  ZyB.resolveHttpAuthSchemeConfig = Bj6
})
// @from(Start 6966415, End 6983671)
xyB = z((kBG, ioA) => {
  var YyB, JyB, WyB, XyB, VyB, FyB, KyB, DyB, HyB, CyB, EyB, zyB, UyB, poA, Lc1, $yB, wyB, qyB, NGA, NyB, LyB, MyB, OyB, RyB, TyB, PyB, jyB, SyB, loA, _yB, kyB, yyB;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof ioA === "object" && typeof kBG === "object") A(B(Q, B(kBG)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    YyB = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, JyB = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, WyB = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, XyB = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, VyB = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, FyB = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, KyB = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, DyB = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, HyB = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, CyB = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, EyB = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, zyB = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, UyB = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) loA(Y, I, J)
    }, loA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, poA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, Lc1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, $yB = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(Lc1(arguments[Y]));
      return I
    }, wyB = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, qyB = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, NGA = function(I) {
      return this instanceof NGA ? (this.v = I, this) : new NGA(I)
    }, NyB = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof NGA ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, LyB = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: NGA(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, MyB = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof poA === "function" ? poA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, OyB = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    RyB = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") loA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, TyB = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, PyB = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, jyB = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, SyB = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, _yB = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    kyB = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, yyB = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", YyB), A("__assign", JyB), A("__rest", WyB), A("__decorate", XyB), A("__param", VyB), A("__esDecorate", FyB), A("__runInitializers", KyB), A("__propKey", DyB), A("__setFunctionName", HyB), A("__metadata", CyB), A("__awaiter", EyB), A("__generator", zyB), A("__exportStar", UyB), A("__createBinding", loA), A("__values", poA), A("__read", Lc1), A("__spread", $yB), A("__spreadArrays", wyB), A("__spreadArray", qyB), A("__await", NGA), A("__asyncGenerator", NyB), A("__asyncDelegator", LyB), A("__asyncValues", MyB), A("__makeTemplateObject", OyB), A("__importStar", RyB), A("__importDefault", TyB), A("__classPrivateFieldGet", PyB), A("__classPrivateFieldSet", jyB), A("__classPrivateFieldIn", SyB), A("__addDisposableResource", _yB), A("__disposeResources", kyB), A("__rewriteRelativeImportExtension", yyB)
  })
})
// @from(Start 6983677, End 6987749)
vyB = z((yBG, Ij6) => {
  Ij6.exports = {
    name: "@aws-sdk/client-bedrock-runtime",
    description: "AWS SDK for JavaScript Bedrock Runtime Client for Node.js, Browser and React Native",
    version: "3.797.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-bedrock-runtime",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo bedrock-runtime"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: !1,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.796.0",
      "@aws-sdk/credential-provider-node": "3.797.0",
      "@aws-sdk/eventstream-handler-node": "3.775.0",
      "@aws-sdk/middleware-eventstream": "3.775.0",
      "@aws-sdk/middleware-host-header": "3.775.0",
      "@aws-sdk/middleware-logger": "3.775.0",
      "@aws-sdk/middleware-recursion-detection": "3.775.0",
      "@aws-sdk/middleware-user-agent": "3.796.0",
      "@aws-sdk/region-config-resolver": "3.775.0",
      "@aws-sdk/types": "3.775.0",
      "@aws-sdk/util-endpoints": "3.787.0",
      "@aws-sdk/util-user-agent-browser": "3.775.0",
      "@aws-sdk/util-user-agent-node": "3.796.0",
      "@smithy/config-resolver": "^4.1.0",
      "@smithy/core": "^3.2.0",
      "@smithy/eventstream-serde-browser": "^4.0.2",
      "@smithy/eventstream-serde-config-resolver": "^4.1.0",
      "@smithy/eventstream-serde-node": "^4.0.2",
      "@smithy/fetch-http-handler": "^5.0.2",
      "@smithy/hash-node": "^4.0.2",
      "@smithy/invalid-dependency": "^4.0.2",
      "@smithy/middleware-content-length": "^4.0.2",
      "@smithy/middleware-endpoint": "^4.1.0",
      "@smithy/middleware-retry": "^4.1.0",
      "@smithy/middleware-serde": "^4.0.3",
      "@smithy/middleware-stack": "^4.0.2",
      "@smithy/node-config-provider": "^4.0.2",
      "@smithy/node-http-handler": "^4.0.4",
      "@smithy/protocol-http": "^5.1.0",
      "@smithy/smithy-client": "^4.2.0",
      "@smithy/types": "^4.2.0",
      "@smithy/url-parser": "^4.0.2",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.8",
      "@smithy/util-defaults-mode-node": "^4.0.8",
      "@smithy/util-endpoints": "^3.0.2",
      "@smithy/util-middleware": "^4.0.2",
      "@smithy/util-retry": "^4.0.2",
      "@smithy/util-stream": "^4.2.0",
      "@smithy/util-utf8": "^4.0.0",
      "@types/uuid": "^9.0.1",
      tslib: "^2.6.2",
      uuid: "^9.0.1"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": ["dist-types/ts3.4/*"]
      }
    },
    files: ["dist-*/**"],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-bedrock-runtime",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-bedrock-runtime"
    }
  }
})
// @from(Start 6987755, End 7005011)
Oc1 = z((xBG, soA) => {
  var byB, fyB, hyB, gyB, uyB, myB, dyB, cyB, pyB, lyB, iyB, nyB, ayB, noA, Mc1, syB, ryB, oyB, LGA, tyB, eyB, AxB, QxB, BxB, GxB, ZxB, IxB, YxB, aoA, JxB, WxB, XxB;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof soA === "object" && typeof xBG === "object") A(B(Q, B(xBG)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    byB = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, fyB = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, hyB = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, gyB = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, uyB = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, myB = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, dyB = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, cyB = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, pyB = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, lyB = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, iyB = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, nyB = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, ayB = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) aoA(Y, I, J)
    }, aoA = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, noA = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, Mc1 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, syB = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(Mc1(arguments[Y]));
      return I
    }, ryB = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, oyB = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, LGA = function(I) {
      return this instanceof LGA ? (this.v = I, this) : new LGA(I)
    }, tyB = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof LGA ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, eyB = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: LGA(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, AxB = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof noA === "function" ? noA(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, QxB = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    BxB = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") aoA(Y, I, J[W])
      }
      return B(Y, I), Y
    }, GxB = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, ZxB = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, IxB = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, YxB = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, JxB = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    WxB = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, XxB = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", byB), A("__assign", fyB), A("__rest", hyB), A("__decorate", gyB), A("__param", uyB), A("__esDecorate", myB), A("__runInitializers", dyB), A("__propKey", cyB), A("__setFunctionName", pyB), A("__metadata", lyB), A("__awaiter", iyB), A("__generator", nyB), A("__exportStar", ayB), A("__createBinding", aoA), A("__values", noA), A("__read", Mc1), A("__spread", syB), A("__spreadArrays", ryB), A("__spreadArray", oyB), A("__await", LGA), A("__asyncGenerator", tyB), A("__asyncDelegator", eyB), A("__asyncValues", AxB), A("__makeTemplateObject", QxB), A("__importStar", BxB), A("__importDefault", GxB), A("__classPrivateFieldGet", ZxB), A("__classPrivateFieldSet", IxB), A("__classPrivateFieldIn", YxB), A("__addDisposableResource", JxB), A("__disposeResources", WxB), A("__rewriteRelativeImportExtension", XxB)
  })
})
// @from(Start 7005017, End 7005970)
KxB = z((vBG, FxB) => {
  var {
    defineProperty: roA,
    getOwnPropertyDescriptor: Yj6,
    getOwnPropertyNames: Jj6
  } = Object, Wj6 = Object.prototype.hasOwnProperty, Xj6 = (A, Q) => roA(A, "name", {
    value: Q,
    configurable: !0
  }), Vj6 = (A, Q) => {
    for (var B in Q) roA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Fj6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Jj6(Q))
        if (!Wj6.call(A, Z) && Z !== B) roA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Yj6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Kj6 = (A) => Fj6(roA({}, "__esModule", {
    value: !0
  }), A), VxB = {};
  Vj6(VxB, {
    isArrayBuffer: () => Dj6
  });
  FxB.exports = Kj6(VxB);
  var Dj6 = Xj6((A) => typeof ArrayBuffer === "function" && A instanceof ArrayBuffer || Object.prototype.toString.call(A) === "[object ArrayBuffer]", "isArrayBuffer")
})
// @from(Start 7005976, End 7007322)
ExB = z((bBG, CxB) => {
  var {
    defineProperty: ooA,
    getOwnPropertyDescriptor: Hj6,
    getOwnPropertyNames: Cj6
  } = Object, Ej6 = Object.prototype.hasOwnProperty, DxB = (A, Q) => ooA(A, "name", {
    value: Q,
    configurable: !0
  }), zj6 = (A, Q) => {
    for (var B in Q) ooA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Uj6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Cj6(Q))
        if (!Ej6.call(A, Z) && Z !== B) ooA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Hj6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, $j6 = (A) => Uj6(ooA({}, "__esModule", {
    value: !0
  }), A), HxB = {};
  zj6(HxB, {
    fromArrayBuffer: () => qj6,
    fromString: () => Nj6
  });
  CxB.exports = $j6(HxB);
  var wj6 = KxB(),
    Rc1 = UA("buffer"),
    qj6 = DxB((A, Q = 0, B = A.byteLength - Q) => {
      if (!(0, wj6.isArrayBuffer)(A)) throw TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof A} (${A})`);
      return Rc1.Buffer.from(A, Q, B)
    }, "fromArrayBuffer"),
    Nj6 = DxB((A, Q) => {
      if (typeof A !== "string") throw TypeError(`The "input" argument must be of type string. Received type ${typeof A} (${A})`);
      return Q ? Rc1.Buffer.from(A, Q) : Rc1.Buffer.from(A)
    }, "fromString")
})
// @from(Start 7007328, End 7008991)
qxB = z((fBG, wxB) => {
  var {
    defineProperty: toA,
    getOwnPropertyDescriptor: Lj6,
    getOwnPropertyNames: Mj6
  } = Object, Oj6 = Object.prototype.hasOwnProperty, Tc1 = (A, Q) => toA(A, "name", {
    value: Q,
    configurable: !0
  }), Rj6 = (A, Q) => {
    for (var B in Q) toA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Tj6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Mj6(Q))
        if (!Oj6.call(A, Z) && Z !== B) toA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Lj6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Pj6 = (A) => Tj6(toA({}, "__esModule", {
    value: !0
  }), A), zxB = {};
  Rj6(zxB, {
    fromUtf8: () => $xB,
    toUint8Array: () => jj6,
    toUtf8: () => Sj6
  });
  wxB.exports = Pj6(zxB);
  var UxB = ExB(),
    $xB = Tc1((A) => {
      let Q = (0, UxB.fromString)(A, "utf8");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength / Uint8Array.BYTES_PER_ELEMENT)
    }, "fromUtf8"),
    jj6 = Tc1((A) => {
      if (typeof A === "string") return $xB(A);
      if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      return new Uint8Array(A)
    }, "toUint8Array"),
    Sj6 = Tc1((A) => {
      if (typeof A === "string") return A;
      if (typeof A !== "object" || typeof A.byteOffset !== "number" || typeof A.byteLength !== "number") throw Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      return (0, UxB.fromArrayBuffer)(A.buffer, A.byteOffset, A.byteLength).toString("utf8")
    }, "toUtf8")
})
// @from(Start 7008997, End 7009547)
MxB = z((NxB) => {
  Object.defineProperty(NxB, "__esModule", {
    value: !0
  });
  NxB.convertToBuffer = void 0;
  var _j6 = qxB(),
    kj6 = typeof Buffer < "u" && Buffer.from ? function(A) {
      return Buffer.from(A, "utf8")
    } : _j6.fromUtf8;

  function yj6(A) {
    if (A instanceof Uint8Array) return A;
    if (typeof A === "string") return kj6(A);
    if (ArrayBuffer.isView(A)) return new Uint8Array(A.buffer, A.byteOffset, A.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    return new Uint8Array(A)
  }
  NxB.convertToBuffer = yj6
})
// @from(Start 7009553, End 7009800)
TxB = z((OxB) => {
  Object.defineProperty(OxB, "__esModule", {
    value: !0
  });
  OxB.isEmptyData = void 0;

  function xj6(A) {
    if (typeof A === "string") return A.length === 0;
    return A.byteLength === 0
  }
  OxB.isEmptyData = xj6
})
// @from(Start 7009806, End 7010068)
SxB = z((PxB) => {
  Object.defineProperty(PxB, "__esModule", {
    value: !0
  });
  PxB.numToUint8 = void 0;

  function vj6(A) {
    return new Uint8Array([(A & 4278190080) >> 24, (A & 16711680) >> 16, (A & 65280) >> 8, A & 255])
  }
  PxB.numToUint8 = vj6
})
// @from(Start 7010074, End 7010430)
yxB = z((_xB) => {
  Object.defineProperty(_xB, "__esModule", {
    value: !0
  });
  _xB.uint32ArrayFrom = void 0;

  function bj6(A) {
    if (!Uint32Array.from) {
      var Q = new Uint32Array(A.length),
        B = 0;
      while (B < A.length) Q[B] = A[B], B += 1;
      return Q
    }
    return Uint32Array.from(A)
  }
  _xB.uint32ArrayFrom = bj6
})
// @from(Start 7010436, End 7011216)
Pc1 = z((MGA) => {
  Object.defineProperty(MGA, "__esModule", {
    value: !0
  });
  MGA.uint32ArrayFrom = MGA.numToUint8 = MGA.isEmptyData = MGA.convertToBuffer = void 0;
  var fj6 = MxB();
  Object.defineProperty(MGA, "convertToBuffer", {
    enumerable: !0,
    get: function() {
      return fj6.convertToBuffer
    }
  });
  var hj6 = TxB();
  Object.defineProperty(MGA, "isEmptyData", {
    enumerable: !0,
    get: function() {
      return hj6.isEmptyData
    }
  });
  var gj6 = SxB();
  Object.defineProperty(MGA, "numToUint8", {
    enumerable: !0,
    get: function() {
      return gj6.numToUint8
    }
  });
  var uj6 = yxB();
  Object.defineProperty(MGA, "uint32ArrayFrom", {
    enumerable: !0,
    get: function() {
      return uj6.uint32ArrayFrom
    }
  })
})
// @from(Start 7011222, End 7011988)
hxB = z((bxB) => {
  Object.defineProperty(bxB, "__esModule", {
    value: !0
  });
  bxB.AwsCrc32 = void 0;
  var xxB = Oc1(),
    jc1 = Pc1(),
    vxB = eoA(),
    dj6 = function() {
      function A() {
        this.crc32 = new vxB.Crc32
      }
      return A.prototype.update = function(Q) {
        if ((0, jc1.isEmptyData)(Q)) return;
        this.crc32.update((0, jc1.convertToBuffer)(Q))
      }, A.prototype.digest = function() {
        return xxB.__awaiter(this, void 0, void 0, function() {
          return xxB.__generator(this, function(Q) {
            return [2, (0, jc1.numToUint8)(this.crc32.digest())]
          })
        })
      }, A.prototype.reset = function() {
        this.crc32 = new vxB.Crc32
      }, A
    }();
  bxB.AwsCrc32 = dj6
})
// @from(Start 7011994, End 7016154)
eoA = z((Sc1) => {
  Object.defineProperty(Sc1, "__esModule", {
    value: !0
  });
  Sc1.AwsCrc32 = Sc1.Crc32 = Sc1.crc32 = void 0;
  var cj6 = Oc1(),
    pj6 = Pc1();

  function lj6(A) {
    return new gxB().update(A).digest()
  }
  Sc1.crc32 = lj6;
  var gxB = function() {
    function A() {
      this.checksum = 4294967295
    }
    return A.prototype.update = function(Q) {
      var B, G;
      try {
        for (var Z = cj6.__values(Q), I = Z.next(); !I.done; I = Z.next()) {
          var Y = I.value;
          this.checksum = this.checksum >>> 8 ^ nj6[(this.checksum ^ Y) & 255]
        }
      } catch (J) {
        B = {
          error: J
        }
      } finally {
        try {
          if (I && !I.done && (G = Z.return)) G.call(Z)
        } finally {
          if (B) throw B.error
        }
      }
      return this
    }, A.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0
    }, A
  }();
  Sc1.Crc32 = gxB;
  var ij6 = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117],
    nj6 = (0, pj6.uint32ArrayFrom)(ij6),
    aj6 = hxB();
  Object.defineProperty(Sc1, "AwsCrc32", {
    enumerable: !0,
    get: function() {
      return aj6.AwsCrc32
    }
  })
})
// @from(Start 7016160, End 7027286)
kc1 = z((aBG, lxB) => {
  var {
    defineProperty: QtA,
    getOwnPropertyDescriptor: tj6,
    getOwnPropertyNames: ej6
  } = Object, AS6 = Object.prototype.hasOwnProperty, Ef = (A, Q) => QtA(A, "name", {
    value: Q,
    configurable: !0
  }), QS6 = (A, Q) => {
    for (var B in Q) QtA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, BS6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ej6(Q))
        if (!AS6.call(A, Z) && Z !== B) QtA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = tj6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, GS6 = (A) => BS6(QtA({}, "__esModule", {
    value: !0
  }), A), mxB = {};
  QS6(mxB, {
    EventStreamCodec: () => ES6,
    HeaderMarshaller: () => dxB,
    Int64: () => AtA,
    MessageDecoderStream: () => zS6,
    MessageEncoderStream: () => US6,
    SmithyMessageDecoderStream: () => $S6,
    SmithyMessageEncoderStream: () => wS6
  });
  lxB.exports = GS6(mxB);
  var ZS6 = eoA(),
    Fe = Jd(),
    AtA = class A {
      constructor(Q) {
        if (this.bytes = Q, Q.byteLength !== 8) throw Error("Int64 buffers must be exactly 8 bytes")
      }
      static {
        Ef(this, "Int64")
      }
      static fromNumber(Q) {
        if (Q > 9223372036854776000 || Q < -9223372036854776000) throw Error(`${Q} is too large (or, if negative, too small) to represent as an Int64`);
        let B = new Uint8Array(8);
        for (let G = 7, Z = Math.abs(Math.round(Q)); G > -1 && Z > 0; G--, Z /= 256) B[G] = Z;
        if (Q < 0) _c1(B);
        return new A(B)
      }
      valueOf() {
        let Q = this.bytes.slice(0),
          B = Q[0] & 128;
        if (B) _c1(Q);
        return parseInt((0, Fe.toHex)(Q), 16) * (B ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    };

  function _c1(A) {
    for (let Q = 0; Q < 8; Q++) A[Q] ^= 255;
    for (let Q = 7; Q > -1; Q--)
      if (A[Q]++, A[Q] !== 0) break
  }
  Ef(_c1, "negate");
  var dxB = class {
      constructor(A, Q) {
        this.toUtf8 = A, this.fromUtf8 = Q
      }
      static {
        Ef(this, "HeaderMarshaller")
      }
      format(A) {
        let Q = [];
        for (let Z of Object.keys(A)) {
          let I = this.fromUtf8(Z);
          Q.push(Uint8Array.from([I.byteLength]), I, this.formatHeaderValue(A[Z]))
        }
        let B = new Uint8Array(Q.reduce((Z, I) => Z + I.byteLength, 0)),
          G = 0;
        for (let Z of Q) B.set(Z, G), G += Z.byteLength;
        return B
      }
      formatHeaderValue(A) {
        switch (A.type) {
          case "boolean":
            return Uint8Array.from([A.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, A.value]);
          case "short":
            let Q = new DataView(new ArrayBuffer(3));
            return Q.setUint8(0, 3), Q.setInt16(1, A.value, !1), new Uint8Array(Q.buffer);
          case "integer":
            let B = new DataView(new ArrayBuffer(5));
            return B.setUint8(0, 4), B.setInt32(1, A.value, !1), new Uint8Array(B.buffer);
          case "long":
            let G = new Uint8Array(9);
            return G[0] = 5, G.set(A.value.bytes, 1), G;
          case "binary":
            let Z = new DataView(new ArrayBuffer(3 + A.value.byteLength));
            Z.setUint8(0, 6), Z.setUint16(1, A.value.byteLength, !1);
            let I = new Uint8Array(Z.buffer);
            return I.set(A.value, 3), I;
          case "string":
            let Y = this.fromUtf8(A.value),
              J = new DataView(new ArrayBuffer(3 + Y.byteLength));
            J.setUint8(0, 7), J.setUint16(1, Y.byteLength, !1);
            let W = new Uint8Array(J.buffer);
            return W.set(Y, 3), W;
          case "timestamp":
            let X = new Uint8Array(9);
            return X[0] = 8, X.set(AtA.fromNumber(A.value.valueOf()).bytes, 1), X;
          case "uuid":
            if (!DS6.test(A.value)) throw Error(`Invalid UUID received: ${A.value}`);
            let V = new Uint8Array(17);
            return V[0] = 9, V.set((0, Fe.fromHex)(A.value.replace(/\-/g, "")), 1), V
        }
      }
      parse(A) {
        let Q = {},
          B = 0;
        while (B < A.byteLength) {
          let G = A.getUint8(B++),
            Z = this.toUtf8(new Uint8Array(A.buffer, A.byteOffset + B, G));
          switch (B += G, A.getUint8(B++)) {
            case 0:
              Q[Z] = {
                type: uxB,
                value: !0
              };
              break;
            case 1:
              Q[Z] = {
                type: uxB,
                value: !1
              };
              break;
            case 2:
              Q[Z] = {
                type: IS6,
                value: A.getInt8(B++)
              };
              break;
            case 3:
              Q[Z] = {
                type: YS6,
                value: A.getInt16(B, !1)
              }, B += 2;
              break;
            case 4:
              Q[Z] = {
                type: JS6,
                value: A.getInt32(B, !1)
              }, B += 4;
              break;
            case 5:
              Q[Z] = {
                type: WS6,
                value: new AtA(new Uint8Array(A.buffer, A.byteOffset + B, 8))
              }, B += 8;
              break;
            case 6:
              let I = A.getUint16(B, !1);
              B += 2, Q[Z] = {
                type: XS6,
                value: new Uint8Array(A.buffer, A.byteOffset + B, I)
              }, B += I;
              break;
            case 7:
              let Y = A.getUint16(B, !1);
              B += 2, Q[Z] = {
                type: VS6,
                value: this.toUtf8(new Uint8Array(A.buffer, A.byteOffset + B, Y))
              }, B += Y;
              break;
            case 8:
              Q[Z] = {
                type: FS6,
                value: new Date(new AtA(new Uint8Array(A.buffer, A.byteOffset + B, 8)).valueOf())
              }, B += 8;
              break;
            case 9:
              let J = new Uint8Array(A.buffer, A.byteOffset + B, 16);
              B += 16, Q[Z] = {
                type: KS6,
                value: `${(0,Fe.toHex)(J.subarray(0,4))}-${(0,Fe.toHex)(J.subarray(4,6))}-${(0,Fe.toHex)(J.subarray(6,8))}-${(0,Fe.toHex)(J.subarray(8,10))}-${(0,Fe.toHex)(J.subarray(10))}`
              };
              break;
            default:
              throw Error("Unrecognized header type tag")
          }
        }
        return Q
      }
    },
    uxB = "boolean",
    IS6 = "byte",
    YS6 = "short",
    JS6 = "integer",
    WS6 = "long",
    XS6 = "binary",
    VS6 = "string",
    FS6 = "timestamp",
    KS6 = "uuid",
    DS6 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
    HS6 = eoA(),
    cxB = 4,
    xp = cxB * 2,
    Ke = 4,
    CS6 = xp + Ke * 2;

  function pxB({
    byteLength: A,
    byteOffset: Q,
    buffer: B
  }) {
    if (A < CS6) throw Error("Provided message too short to accommodate event stream message overhead");
    let G = new DataView(B, Q, A),
      Z = G.getUint32(0, !1);
    if (A !== Z) throw Error("Reported message length does not match received message length");
    let I = G.getUint32(cxB, !1),
      Y = G.getUint32(xp, !1),
      J = G.getUint32(A - Ke, !1),
      W = new HS6.Crc32().update(new Uint8Array(B, Q, xp));
    if (Y !== W.digest()) throw Error(`The prelude checksum specified in the message (${Y}) does not match the calculated CRC32 checksum (${W.digest()})`);
    if (W.update(new Uint8Array(B, Q + xp, A - (xp + Ke))), J !== W.digest()) throw Error(`The message checksum (${W.digest()}) did not match the expected value of ${J}`);
    return {
      headers: new DataView(B, Q + xp + Ke, I),
      body: new Uint8Array(B, Q + xp + Ke + I, Z - I - (xp + Ke + Ke))
    }
  }
  Ef(pxB, "splitMessage");
  var ES6 = class {
      static {
        Ef(this, "EventStreamCodec")
      }
      constructor(A, Q) {
        this.headerMarshaller = new dxB(A, Q), this.messageBuffer = [], this.isEndOfStream = !1
      }
      feed(A) {
        this.messageBuffer.push(this.decode(A))
      }
      endOfStream() {
        this.isEndOfStream = !0
      }
      getMessage() {
        let A = this.messageBuffer.pop(),
          Q = this.isEndOfStream;
        return {
          getMessage() {
            return A
          },
          isEndOfStream() {
            return Q
          }
        }
      }
      getAvailableMessages() {
        let A = this.messageBuffer;
        this.messageBuffer = [];
        let Q = this.isEndOfStream;
        return {
          getMessages() {
            return A
          },
          isEndOfStream() {
            return Q
          }
        }
      }
      encode({
        headers: A,
        body: Q
      }) {
        let B = this.headerMarshaller.format(A),
          G = B.byteLength + Q.byteLength + 16,
          Z = new Uint8Array(G),
          I = new DataView(Z.buffer, Z.byteOffset, Z.byteLength),
          Y = new ZS6.Crc32;
        return I.setUint32(0, G, !1), I.setUint32(4, B.byteLength, !1), I.setUint32(8, Y.update(Z.subarray(0, 8)).digest(), !1), Z.set(B, 12), Z.set(Q, B.byteLength + 12), I.setUint32(G - 4, Y.update(Z.subarray(8, G - 4)).digest(), !1), Z
      }
      decode(A) {
        let {
          headers: Q,
          body: B
        } = pxB(A);
        return {
          headers: this.headerMarshaller.parse(Q),
          body: B
        }
      }
      formatHeaders(A) {
        return this.headerMarshaller.format(A)
      }
    },
    zS6 = class {
      constructor(A) {
        this.options = A
      }
      static {
        Ef(this, "MessageDecoderStream")
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let A of this.options.inputStream) yield this.options.decoder.decode(A)
      }
    },
    US6 = class {
      constructor(A) {
        this.options = A
      }
      static {
        Ef(this, "MessageEncoderStream")
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let A of this.options.messageStream) yield this.options.encoder.encode(A);
        if (this.options.includeEndFrame) yield new Uint8Array(0)
      }
    },
    $S6 = class {
      constructor(A) {
        this.options = A
      }
      static {
        Ef(this, "SmithyMessageDecoderStream")
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let A of this.options.messageStream) {
          let Q = await this.options.deserializer(A);
          if (Q === void 0) continue;
          yield Q
        }
      }
    },
    wS6 = class {
      constructor(A) {
        this.options = A
      }
      static {
        Ef(this, "SmithyMessageEncoderStream")
      } [Symbol.asyncIterator]() {
        return this.asyncIterator()
      }
      async * asyncIterator() {
        for await (let A of this.options.inputStream) yield this.options.serializer(A)
      }
    }
})
// @from(Start 7027292, End 7031206)
sxB = z((Q2G, axB) => {
  var {
    defineProperty: GtA,
    getOwnPropertyDescriptor: qS6,
    getOwnPropertyNames: NS6
  } = Object, LS6 = Object.prototype.hasOwnProperty, ZtA = (A, Q) => GtA(A, "name", {
    value: Q,
    configurable: !0
  }), MS6 = (A, Q) => {
    for (var B in Q) GtA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, OS6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of NS6(Q))
        if (!LS6.call(A, Z) && Z !== B) GtA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qS6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, RS6 = (A) => OS6(GtA({}, "__esModule", {
    value: !0
  }), A), ixB = {};
  MS6(ixB, {
    eventStreamPayloadHandlerProvider: () => SS6
  });
  axB.exports = RS6(ixB);
  var TS6 = kc1(),
    BtA = UA("stream"),
    PS6 = class extends BtA.Transform {
      static {
        ZtA(this, "EventSigningStream")
      }
      priorSignature;
      messageSigner;
      eventStreamCodec;
      systemClockOffsetProvider;
      constructor(A) {
        super({
          autoDestroy: !0,
          readableObjectMode: !0,
          writableObjectMode: !0,
          ...A
        });
        this.priorSignature = A.priorSignature, this.eventStreamCodec = A.eventStreamCodec, this.messageSigner = A.messageSigner, this.systemClockOffsetProvider = A.systemClockOffsetProvider
      }
      async _transform(A, Q, B) {
        try {
          let G = new Date(Date.now() + await this.systemClockOffsetProvider()),
            Z = {
              ":date": {
                type: "timestamp",
                value: G
              }
            },
            I = await this.messageSigner.sign({
              message: {
                body: A,
                headers: Z
              },
              priorSignature: this.priorSignature
            }, {
              signingDate: G
            });
          this.priorSignature = I.signature;
          let Y = this.eventStreamCodec.encode({
            headers: {
              ...Z,
              ":chunk-signature": {
                type: "binary",
                value: nxB(I.signature)
              }
            },
            body: A
          });
          return this.push(Y), B()
        } catch (G) {
          B(G)
        }
      }
    };

  function nxB(A) {
    let Q = Buffer.from(A, "hex");
    return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength / Uint8Array.BYTES_PER_ELEMENT)
  }
  ZtA(nxB, "getSignatureBinary");
  var jS6 = class {
      static {
        ZtA(this, "EventStreamPayloadHandler")
      }
      messageSigner;
      eventStreamCodec;
      systemClockOffsetProvider;
      constructor(A) {
        this.messageSigner = A.messageSigner, this.eventStreamCodec = new TS6.EventStreamCodec(A.utf8Encoder, A.utf8Decoder), this.systemClockOffsetProvider = async () => A.systemClockOffset ?? 0
      }
      async handle(A, Q, B = {}) {
        let G = Q.request,
          {
            body: Z,
            query: I
          } = G;
        if (!(Z instanceof BtA.Readable)) throw Error("Eventstream payload must be a Readable stream.");
        let Y = Z;
        G.body = new BtA.PassThrough({
          objectMode: !0
        });
        let W = G.headers?.authorization?.match(/Signature=([\w]+)$/)?.[1] ?? I?.["X-Amz-Signature"] ?? "",
          X = new PS6({
            priorSignature: W,
            eventStreamCodec: this.eventStreamCodec,
            messageSigner: await this.messageSigner(),
            systemClockOffsetProvider: this.systemClockOffsetProvider
          });
        (0, BtA.pipeline)(Y, X, G.body, (F) => {
          if (F) throw F
        });
        let V;
        try {
          V = await A(Q)
        } catch (F) {
          throw G.body.end(), F
        }
        return V
      }
    },
    SS6 = ZtA((A) => new jS6(A), "eventStreamPayloadHandlerProvider")
})
// @from(Start 7031212, End 7035249)
QvB = z((Z2G, AvB) => {
  var {
    defineProperty: ItA,
    getOwnPropertyDescriptor: _S6,
    getOwnPropertyNames: kS6
  } = Object, yS6 = Object.prototype.hasOwnProperty, OGA = (A, Q) => ItA(A, "name", {
    value: Q,
    configurable: !0
  }), xS6 = (A, Q) => {
    for (var B in Q) ItA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, vS6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of kS6(Q))
        if (!yS6.call(A, Z) && Z !== B) ItA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = _S6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, bS6 = (A) => vS6(ItA({}, "__esModule", {
    value: !0
  }), A), rxB = {};
  xS6(rxB, {
    EventStreamMarshaller: () => exB,
    eventStreamSerdeProvider: () => fS6
  });
  AvB.exports = bS6(rxB);
  var YwA = kc1();

  function oxB(A) {
    let Q = 0,
      B = 0,
      G = null,
      Z = null,
      I = OGA((J) => {
        if (typeof J !== "number") throw Error("Attempted to allocate an event message where size was not a number: " + J);
        Q = J, B = 4, G = new Uint8Array(J), new DataView(G.buffer).setUint32(0, J, !1)
      }, "allocateMessage"),
      Y = OGA(async function*() {
        let J = A[Symbol.asyncIterator]();
        while (!0) {
          let {
            value: W,
            done: X
          } = await J.next();
          if (X) {
            if (!Q) return;
            else if (Q === B) yield G;
            else throw Error("Truncated event message received.");
            return
          }
          let V = W.length,
            F = 0;
          while (F < V) {
            if (!G) {
              let D = V - F;
              if (!Z) Z = new Uint8Array(4);
              let H = Math.min(4 - B, D);
              if (Z.set(W.slice(F, F + H), B), B += H, F += H, B < 4) break;
              I(new DataView(Z.buffer).getUint32(0, !1)), Z = null
            }
            let K = Math.min(Q - B, V - F);
            if (G.set(W.slice(F, F + K), B), B += K, F += K, Q && Q === B) yield G, G = null, Q = 0, B = 0
          }
        }
      }, "iterator");
    return {
      [Symbol.asyncIterator]: Y
    }
  }
  OGA(oxB, "getChunkedStream");

  function txB(A, Q) {
    return async function(B) {
      let {
        value: G
      } = B.headers[":message-type"];
      if (G === "error") {
        let Z = Error(B.headers[":error-message"].value || "UnknownError");
        throw Z.name = B.headers[":error-code"].value, Z
      } else if (G === "exception") {
        let Z = B.headers[":exception-type"].value,
          I = {
            [Z]: B
          },
          Y = await A(I);
        if (Y.$unknown) {
          let J = Error(Q(B.body));
          throw J.name = Z, J
        }
        throw Y[Z]
      } else if (G === "event") {
        let Z = {
            [B.headers[":event-type"].value]: B
          },
          I = await A(Z);
        if (I.$unknown) return;
        return I
      } else throw Error(`Unrecognizable event type: ${B.headers[":event-type"].value}`)
    }
  }
  OGA(txB, "getMessageUnmarshaller");
  var exB = class {
      static {
        OGA(this, "EventStreamMarshaller")
      }
      constructor({
        utf8Encoder: A,
        utf8Decoder: Q
      }) {
        this.eventStreamCodec = new YwA.EventStreamCodec(A, Q), this.utfEncoder = A
      }
      deserialize(A, Q) {
        let B = oxB(A);
        return new YwA.SmithyMessageDecoderStream({
          messageStream: new YwA.MessageDecoderStream({
            inputStream: B,
            decoder: this.eventStreamCodec
          }),
          deserializer: txB(Q, this.utfEncoder)
        })
      }
      serialize(A, Q) {
        return new YwA.MessageEncoderStream({
          messageStream: new YwA.SmithyMessageEncoderStream({
            inputStream: A,
            serializer: Q
          }),
          encoder: this.eventStreamCodec,
          includeEndFrame: !0
        })
      }
    },
    fS6 = OGA((A) => new exB(A), "eventStreamSerdeProvider")
})
// @from(Start 7035255, End 7037201)
YvB = z((Y2G, IvB) => {
  var {
    defineProperty: YtA,
    getOwnPropertyDescriptor: hS6,
    getOwnPropertyNames: gS6
  } = Object, uS6 = Object.prototype.hasOwnProperty, yc1 = (A, Q) => YtA(A, "name", {
    value: Q,
    configurable: !0
  }), mS6 = (A, Q) => {
    for (var B in Q) YtA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, dS6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of gS6(Q))
        if (!uS6.call(A, Z) && Z !== B) YtA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = hS6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, cS6 = (A) => dS6(YtA({}, "__esModule", {
    value: !0
  }), A), BvB = {};
  mS6(BvB, {
    EventStreamMarshaller: () => ZvB,
    eventStreamSerdeProvider: () => iS6
  });
  IvB.exports = cS6(BvB);
  var pS6 = QvB(),
    lS6 = UA("stream");
  async function* GvB(A) {
    let Q = !1,
      B = !1,
      G = [];
    A.on("error", (Z) => {
      if (!Q) Q = !0;
      if (Z) throw Z
    }), A.on("data", (Z) => {
      G.push(Z)
    }), A.on("end", () => {
      Q = !0
    });
    while (!B) {
      let Z = await new Promise((I) => setTimeout(() => I(G.shift()), 0));
      if (Z) yield Z;
      B = Q && G.length === 0
    }
  }
  yc1(GvB, "readabletoIterable");
  var ZvB = class {
      static {
        yc1(this, "EventStreamMarshaller")
      }
      constructor({
        utf8Encoder: A,
        utf8Decoder: Q
      }) {
        this.universalMarshaller = new pS6.EventStreamMarshaller({
          utf8Decoder: Q,
          utf8Encoder: A
        })
      }
      deserialize(A, Q) {
        let B = typeof A[Symbol.asyncIterator] === "function" ? A : GvB(A);
        return this.universalMarshaller.deserialize(B, Q)
      }
      serialize(A, Q) {
        return lS6.Readable.from(this.universalMarshaller.serialize(A, Q))
      }
    },
    iS6 = yc1((A) => new ZvB(A), "eventStreamSerdeProvider")
})
// @from(Start 7037207, End 7039990)
xc1 = z((W2G, CvB) => {
  var {
    defineProperty: JtA,
    getOwnPropertyDescriptor: nS6,
    getOwnPropertyNames: aS6
  } = Object, sS6 = Object.prototype.hasOwnProperty, WtA = (A, Q) => JtA(A, "name", {
    value: Q,
    configurable: !0
  }), rS6 = (A, Q) => {
    for (var B in Q) JtA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, oS6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of aS6(Q))
        if (!sS6.call(A, Z) && Z !== B) JtA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = nS6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, tS6 = (A) => oS6(JtA({}, "__esModule", {
    value: !0
  }), A), JvB = {};
  rS6(JvB, {
    AlgorithmId: () => FvB,
    EndpointURLScheme: () => VvB,
    FieldPosition: () => KvB,
    HttpApiKeyAuthLocation: () => XvB,
    HttpAuthLocation: () => WvB,
    IniSectionType: () => DvB,
    RequestHandlerProtocol: () => HvB,
    SMITHY_CONTEXT_KEY: () => G_6,
    getDefaultClientConfiguration: () => Q_6,
    resolveDefaultRuntimeConfig: () => B_6
  });
  CvB.exports = tS6(JvB);
  var WvB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(WvB || {}),
    XvB = ((A) => {
      return A.HEADER = "header", A.QUERY = "query", A
    })(XvB || {}),
    VvB = ((A) => {
      return A.HTTP = "http", A.HTTPS = "https", A
    })(VvB || {}),
    FvB = ((A) => {
      return A.MD5 = "md5", A.CRC32 = "crc32", A.CRC32C = "crc32c", A.SHA1 = "sha1", A.SHA256 = "sha256", A
    })(FvB || {}),
    eS6 = WtA((A) => {
      let Q = [];
      if (A.sha256 !== void 0) Q.push({
        algorithmId: () => "sha256",
        checksumConstructor: () => A.sha256
      });
      if (A.md5 != null) Q.push({
        algorithmId: () => "md5",
        checksumConstructor: () => A.md5
      });
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    A_6 = WtA((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    Q_6 = WtA((A) => {
      return eS6(A)
    }, "getDefaultClientConfiguration"),
    B_6 = WtA((A) => {
      return A_6(A)
    }, "resolveDefaultRuntimeConfig"),
    KvB = ((A) => {
      return A[A.HEADER = 0] = "HEADER", A[A.TRAILER = 1] = "TRAILER", A
    })(KvB || {}),
    G_6 = "__smithy_context",
    DvB = ((A) => {
      return A.PROFILE = "profile", A.SSO_SESSION = "sso-session", A.SERVICES = "services", A
    })(DvB || {}),
    HvB = ((A) => {
      return A.HTTP_0_9 = "http/0.9", A.HTTP_1_0 = "http/1.0", A.TDS_8_0 = "tds/8.0", A
    })(HvB || {})
})
// @from(Start 7039996, End 7068451)
FwA = z((X2G, yvB) => {
  var {
    defineProperty: FtA,
    getOwnPropertyDescriptor: Z_6,
    getOwnPropertyNames: I_6
  } = Object, Y_6 = Object.prototype.hasOwnProperty, zB = (A, Q) => FtA(A, "name", {
    value: Q,
    configurable: !0
  }), J_6 = (A, Q) => {
    for (var B in Q) FtA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, W_6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of I_6(Q))
        if (!Y_6.call(A, Z) && Z !== B) FtA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = Z_6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, X_6 = (A) => W_6(FtA({}, "__esModule", {
    value: !0
  }), A), zvB = {};
  J_6(zvB, {
    Client: () => V_6,
    Command: () => $vB,
    LazyJsonString: () => De,
    NoOpLogger: () => Yk6,
    SENSITIVE_STRING: () => K_6,
    ServiceException: () => n_6,
    _json: () => mc1,
    collectBody: () => vc1.collectBody,
    convertMap: () => Jk6,
    createAggregatedClient: () => D_6,
    dateToUtcString: () => OvB,
    decorateServiceException: () => RvB,
    emitWarningIfUnsupportedVersion: () => o_6,
    expectBoolean: () => C_6,
    expectByte: () => uc1,
    expectFloat32: () => XtA,
    expectInt: () => z_6,
    expectInt32: () => hc1,
    expectLong: () => XwA,
    expectNonNull: () => $_6,
    expectNumber: () => WwA,
    expectObject: () => wvB,
    expectShort: () => gc1,
    expectString: () => w_6,
    expectUnion: () => q_6,
    extendedEncodeURIComponent: () => vc1.extendedEncodeURIComponent,
    getArrayIfSingleItem: () => Zk6,
    getDefaultClientConfiguration: () => Bk6,
    getDefaultExtensionConfiguration: () => PvB,
    getValueFromTextNode: () => jvB,
    handleFloat: () => M_6,
    isSerializableHeaderValue: () => Ik6,
    limitedParseDouble: () => pc1,
    limitedParseFloat: () => O_6,
    limitedParseFloat32: () => R_6,
    loadConfigsForDefaultMode: () => r_6,
    logger: () => VwA,
    map: () => ic1,
    parseBoolean: () => H_6,
    parseEpochTimestamp: () => h_6,
    parseRfc3339DateTime: () => __6,
    parseRfc3339DateTimeWithOffset: () => y_6,
    parseRfc7231DateTime: () => f_6,
    quoteHeader: () => _vB,
    resolveDefaultRuntimeConfig: () => Gk6,
    resolvedPath: () => vc1.resolvedPath,
    serializeDateTime: () => Dk6,
    serializeFloat: () => Kk6,
    splitEvery: () => kvB,
    splitHeader: () => Hk6,
    strictParseByte: () => MvB,
    strictParseDouble: () => cc1,
    strictParseFloat: () => N_6,
    strictParseFloat32: () => qvB,
    strictParseInt: () => T_6,
    strictParseInt32: () => P_6,
    strictParseLong: () => LvB,
    strictParseShort: () => RGA,
    take: () => Wk6,
    throwDefaultError: () => TvB,
    withBaseException: () => a_6
  });
  yvB.exports = X_6(zvB);
  var UvB = uR(),
    V_6 = class {
      constructor(A) {
        this.config = A, this.middlewareStack = (0, UvB.constructStack)()
      }
      static {
        zB(this, "Client")
      }
      send(A, Q, B) {
        let G = typeof Q !== "function" ? Q : void 0,
          Z = typeof Q === "function" ? Q : B,
          I = G === void 0 && this.config.cacheMiddleware === !0,
          Y;
        if (I) {
          if (!this.handlers) this.handlers = new WeakMap;
          let J = this.handlers;
          if (J.has(A.constructor)) Y = J.get(A.constructor);
          else Y = A.resolveMiddleware(this.middlewareStack, this.config, G), J.set(A.constructor, Y)
        } else delete this.handlers, Y = A.resolveMiddleware(this.middlewareStack, this.config, G);
        if (Z) Y(A).then((J) => Z(null, J.output), (J) => Z(J)).catch(() => {});
        else return Y(A).then((J) => J.output)
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers
      }
    },
    vc1 = w5(),
    fc1 = xc1(),
    $vB = class {
      constructor() {
        this.middlewareStack = (0, UvB.constructStack)()
      }
      static {
        zB(this, "Command")
      }
      static classBuilder() {
        return new F_6
      }
      resolveMiddlewareWithContext(A, Q, B, {
        middlewareFn: G,
        clientName: Z,
        commandName: I,
        inputFilterSensitiveLog: Y,
        outputFilterSensitiveLog: J,
        smithyContext: W,
        additionalContext: X,
        CommandCtor: V
      }) {
        for (let C of G.bind(this)(V, A, Q, B)) this.middlewareStack.use(C);
        let F = A.concat(this.middlewareStack),
          {
            logger: K
          } = Q,
          D = {
            logger: K,
            clientName: Z,
            commandName: I,
            inputFilterSensitiveLog: Y,
            outputFilterSensitiveLog: J,
            [fc1.SMITHY_CONTEXT_KEY]: {
              commandInstance: this,
              ...W
            },
            ...X
          },
          {
            requestHandler: H
          } = Q;
        return F.resolve((C) => H.handle(C.request, B || {}), D)
      }
    },
    F_6 = class {
      constructor() {
        this._init = () => {}, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (A) => A, this._outputFilterSensitiveLog = (A) => A, this._serializer = null, this._deserializer = null
      }
      static {
        zB(this, "ClassBuilder")
      }
      init(A) {
        this._init = A
      }
      ep(A) {
        return this._ep = A, this
      }
      m(A) {
        return this._middlewareFn = A, this
      }
      s(A, Q, B = {}) {
        return this._smithyContext = {
          service: A,
          operation: Q,
          ...B
        }, this
      }
      c(A = {}) {
        return this._additionalContext = A, this
      }
      n(A, Q) {
        return this._clientName = A, this._commandName = Q, this
      }
      f(A = (B) => B, Q = (B) => B) {
        return this._inputFilterSensitiveLog = A, this._outputFilterSensitiveLog = Q, this
      }
      ser(A) {
        return this._serializer = A, this
      }
      de(A) {
        return this._deserializer = A, this
      }
      build() {
        let A = this,
          Q;
        return Q = class extends $vB {
          constructor(...[B]) {
            super();
            this.serialize = A._serializer, this.deserialize = A._deserializer, this.input = B ?? {}, A._init(this)
          }
          static {
            zB(this, "CommandRef")
          }
          static getEndpointParameterInstructions() {
            return A._ep
          }
          resolveMiddleware(B, G, Z) {
            return this.resolveMiddlewareWithContext(B, G, Z, {
              CommandCtor: Q,
              middlewareFn: A._middlewareFn,
              clientName: A._clientName,
              commandName: A._commandName,
              inputFilterSensitiveLog: A._inputFilterSensitiveLog,
              outputFilterSensitiveLog: A._outputFilterSensitiveLog,
              smithyContext: A._smithyContext,
              additionalContext: A._additionalContext
            })
          }
        }
      }
    },
    K_6 = "***SensitiveInformation***",
    D_6 = zB((A, Q) => {
      for (let B of Object.keys(A)) {
        let G = A[B],
          Z = zB(async function(Y, J, W) {
            let X = new G(Y);
            if (typeof J === "function") this.send(X, J);
            else if (typeof W === "function") {
              if (typeof J !== "object") throw Error(`Expected http options but got ${typeof J}`);
              this.send(X, J || {}, W)
            } else return this.send(X, J)
          }, "methodImpl"),
          I = (B[0].toLowerCase() + B.slice(1)).replace(/Command$/, "");
        Q.prototype[I] = Z
      }
    }, "createAggregatedClient"),
    H_6 = zB((A) => {
      switch (A) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw Error(`Unable to parse boolean value "${A}"`)
      }
    }, "parseBoolean"),
    C_6 = zB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "number") {
        if (A === 0 || A === 1) VwA.warn(VtA(`Expected boolean, got ${typeof A}: ${A}`));
        if (A === 0) return !1;
        if (A === 1) return !0
      }
      if (typeof A === "string") {
        let Q = A.toLowerCase();
        if (Q === "false" || Q === "true") VwA.warn(VtA(`Expected boolean, got ${typeof A}: ${A}`));
        if (Q === "false") return !1;
        if (Q === "true") return !0
      }
      if (typeof A === "boolean") return A;
      throw TypeError(`Expected boolean, got ${typeof A}: ${A}`)
    }, "expectBoolean"),
    WwA = zB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") {
        let Q = parseFloat(A);
        if (!Number.isNaN(Q)) {
          if (String(Q) !== String(A)) VwA.warn(VtA(`Expected number but observed string: ${A}`));
          return Q
        }
      }
      if (typeof A === "number") return A;
      throw TypeError(`Expected number, got ${typeof A}: ${A}`)
    }, "expectNumber"),
    E_6 = Math.ceil(340282346638528860000000000000000000000),
    XtA = zB((A) => {
      let Q = WwA(A);
      if (Q !== void 0 && !Number.isNaN(Q) && Q !== 1 / 0 && Q !== -1 / 0) {
        if (Math.abs(Q) > E_6) throw TypeError(`Expected 32-bit float, got ${A}`)
      }
      return Q
    }, "expectFloat32"),
    XwA = zB((A) => {
      if (A === null || A === void 0) return;
      if (Number.isInteger(A) && !Number.isNaN(A)) return A;
      throw TypeError(`Expected integer, got ${typeof A}: ${A}`)
    }, "expectLong"),
    z_6 = XwA,
    hc1 = zB((A) => dc1(A, 32), "expectInt32"),
    gc1 = zB((A) => dc1(A, 16), "expectShort"),
    uc1 = zB((A) => dc1(A, 8), "expectByte"),
    dc1 = zB((A, Q) => {
      let B = XwA(A);
      if (B !== void 0 && U_6(B, Q) !== B) throw TypeError(`Expected ${Q}-bit integer, got ${A}`);
      return B
    }, "expectSizedInt"),
    U_6 = zB((A, Q) => {
      switch (Q) {
        case 32:
          return Int32Array.of(A)[0];
        case 16:
          return Int16Array.of(A)[0];
        case 8:
          return Int8Array.of(A)[0]
      }
    }, "castInt"),
    $_6 = zB((A, Q) => {
      if (A === null || A === void 0) {
        if (Q) throw TypeError(`Expected a non-null value for ${Q}`);
        throw TypeError("Expected a non-null value")
      }
      return A
    }, "expectNonNull"),
    wvB = zB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "object" && !Array.isArray(A)) return A;
      let Q = Array.isArray(A) ? "array" : typeof A;
      throw TypeError(`Expected object, got ${Q}: ${A}`)
    }, "expectObject"),
    w_6 = zB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A === "string") return A;
      if (["boolean", "number", "bigint"].includes(typeof A)) return VwA.warn(VtA(`Expected string, got ${typeof A}: ${A}`)), String(A);
      throw TypeError(`Expected string, got ${typeof A}: ${A}`)
    }, "expectString"),
    q_6 = zB((A) => {
      if (A === null || A === void 0) return;
      let Q = wvB(A),
        B = Object.entries(Q).filter(([, G]) => G != null).map(([G]) => G);
      if (B.length === 0) throw TypeError("Unions must have exactly one non-null member. None were found.");
      if (B.length > 1) throw TypeError(`Unions must have exactly one non-null member. Keys ${B} were not null.`);
      return Q
    }, "expectUnion"),
    cc1 = zB((A) => {
      if (typeof A == "string") return WwA(PGA(A));
      return WwA(A)
    }, "strictParseDouble"),
    N_6 = cc1,
    qvB = zB((A) => {
      if (typeof A == "string") return XtA(PGA(A));
      return XtA(A)
    }, "strictParseFloat32"),
    L_6 = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    PGA = zB((A) => {
      let Q = A.match(L_6);
      if (Q === null || Q[0].length !== A.length) throw TypeError("Expected real number, got implicit NaN");
      return parseFloat(A)
    }, "parseNumber"),
    pc1 = zB((A) => {
      if (typeof A == "string") return NvB(A);
      return WwA(A)
    }, "limitedParseDouble"),
    M_6 = pc1,
    O_6 = pc1,
    R_6 = zB((A) => {
      if (typeof A == "string") return NvB(A);
      return XtA(A)
    }, "limitedParseFloat32"),
    NvB = zB((A) => {
      switch (A) {
        case "NaN":
          return NaN;
        case "Infinity":
          return 1 / 0;
        case "-Infinity":
          return -1 / 0;
        default:
          throw Error(`Unable to parse float value: ${A}`)
      }
    }, "parseFloatString"),
    LvB = zB((A) => {
      if (typeof A === "string") return XwA(PGA(A));
      return XwA(A)
    }, "strictParseLong"),
    T_6 = LvB,
    P_6 = zB((A) => {
      if (typeof A === "string") return hc1(PGA(A));
      return hc1(A)
    }, "strictParseInt32"),
    RGA = zB((A) => {
      if (typeof A === "string") return gc1(PGA(A));
      return gc1(A)
    }, "strictParseShort"),
    MvB = zB((A) => {
      if (typeof A === "string") return uc1(PGA(A));
      return uc1(A)
    }, "strictParseByte"),
    VtA = zB((A) => {
      return String(TypeError(A).stack || A).split(`
`).slice(0, 5).filter((Q) => !Q.includes("stackTraceWarning")).join(`
`)
    }, "stackTraceWarning"),
    VwA = {
      warn: console.warn
    },
    j_6 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    lc1 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

  function OvB(A) {
    let Q = A.getUTCFullYear(),
      B = A.getUTCMonth(),
      G = A.getUTCDay(),
      Z = A.getUTCDate(),
      I = A.getUTCHours(),
      Y = A.getUTCMinutes(),
      J = A.getUTCSeconds(),
      W = Z < 10 ? `0${Z}` : `${Z}`,
      X = I < 10 ? `0${I}` : `${I}`,
      V = Y < 10 ? `0${Y}` : `${Y}`,
      F = J < 10 ? `0${J}` : `${J}`;
    return `${j_6[G]}, ${W} ${lc1[B]} ${Q} ${X}:${V}:${F} GMT`
  }
  zB(OvB, "dateToUtcString");
  var S_6 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/),
    __6 = zB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = S_6.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X] = Q, V = RGA(TGA(G)), F = i_(Z, "month", 1, 12), K = i_(I, "day", 1, 31);
      return JwA(V, F, K, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      })
    }, "parseRfc3339DateTime"),
    k_6 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/),
    y_6 = zB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-3339 date-times must be expressed as strings");
      let Q = k_6.exec(A);
      if (!Q) throw TypeError("Invalid RFC-3339 date-time value");
      let [B, G, Z, I, Y, J, W, X, V] = Q, F = RGA(TGA(G)), K = i_(Z, "month", 1, 12), D = i_(I, "day", 1, 31), H = JwA(F, K, D, {
        hours: Y,
        minutes: J,
        seconds: W,
        fractionalMilliseconds: X
      });
      if (V.toUpperCase() != "Z") H.setTime(H.getTime() - i_6(V));
      return H
    }, "parseRfc3339DateTimeWithOffset"),
    x_6 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    v_6 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/),
    b_6 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/),
    f_6 = zB((A) => {
      if (A === null || A === void 0) return;
      if (typeof A !== "string") throw TypeError("RFC-7231 date-times must be expressed as strings");
      let Q = x_6.exec(A);
      if (Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return JwA(RGA(TGA(I)), bc1(Z), i_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        })
      }
      if (Q = v_6.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return m_6(JwA(g_6(I), bc1(Z), i_(G, "day", 1, 31), {
          hours: Y,
          minutes: J,
          seconds: W,
          fractionalMilliseconds: X
        }))
      }
      if (Q = b_6.exec(A), Q) {
        let [B, G, Z, I, Y, J, W, X] = Q;
        return JwA(RGA(TGA(X)), bc1(G), i_(Z.trimLeft(), "day", 1, 31), {
          hours: I,
          minutes: Y,
          seconds: J,
          fractionalMilliseconds: W
        })
      }
      throw TypeError("Invalid RFC-7231 date-time value")
    }, "parseRfc7231DateTime"),
    h_6 = zB((A) => {
      if (A === null || A === void 0) return;
      let Q;
      if (typeof A === "number") Q = A;
      else if (typeof A === "string") Q = cc1(A);
      else if (typeof A === "object" && A.tag === 1) Q = A.value;
      else throw TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      if (Number.isNaN(Q) || Q === 1 / 0 || Q === -1 / 0) throw TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      return new Date(Math.round(Q * 1000))
    }, "parseEpochTimestamp"),
    JwA = zB((A, Q, B, G) => {
      let Z = Q - 1;
      return c_6(A, Z, B), new Date(Date.UTC(A, Z, B, i_(G.hours, "hour", 0, 23), i_(G.minutes, "minute", 0, 59), i_(G.seconds, "seconds", 0, 60), l_6(G.fractionalMilliseconds)))
    }, "buildDate"),
    g_6 = zB((A) => {
      let Q = new Date().getUTCFullYear(),
        B = Math.floor(Q / 100) * 100 + RGA(TGA(A));
      if (B < Q) return B + 100;
      return B
    }, "parseTwoDigitYear"),
    u_6 = 1576800000000,
    m_6 = zB((A) => {
      if (A.getTime() - new Date().getTime() > u_6) return new Date(Date.UTC(A.getUTCFullYear() - 100, A.getUTCMonth(), A.getUTCDate(), A.getUTCHours(), A.getUTCMinutes(), A.getUTCSeconds(), A.getUTCMilliseconds()));
      return A
    }, "adjustRfc850Year"),
    bc1 = zB((A) => {
      let Q = lc1.indexOf(A);
      if (Q < 0) throw TypeError(`Invalid month: ${A}`);
      return Q + 1
    }, "parseMonthByShortName"),
    d_6 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    c_6 = zB((A, Q, B) => {
      let G = d_6[Q];
      if (Q === 1 && p_6(A)) G = 29;
      if (B > G) throw TypeError(`Invalid day for ${lc1[Q]} in ${A}: ${B}`)
    }, "validateDayOfMonth"),
    p_6 = zB((A) => {
      return A % 4 === 0 && (A % 100 !== 0 || A % 400 === 0)
    }, "isLeapYear"),
    i_ = zB((A, Q, B, G) => {
      let Z = MvB(TGA(A));
      if (Z < B || Z > G) throw TypeError(`${Q} must be between ${B} and ${G}, inclusive`);
      return Z
    }, "parseDateValue"),
    l_6 = zB((A) => {
      if (A === null || A === void 0) return 0;
      return qvB("0." + A) * 1000
    }, "parseMilliseconds"),
    i_6 = zB((A) => {
      let Q = A[0],
        B = 1;
      if (Q == "+") B = 1;
      else if (Q == "-") B = -1;
      else throw TypeError(`Offset direction, ${Q}, must be "+" or "-"`);
      let G = Number(A.substring(1, 3)),
        Z = Number(A.substring(4, 6));
      return B * (G * 60 + Z) * 60 * 1000
    }, "parseOffsetToMilliseconds"),
    TGA = zB((A) => {
      let Q = 0;
      while (Q < A.length - 1 && A.charAt(Q) === "0") Q++;
      if (Q === 0) return A;
      return A.slice(Q)
    }, "stripLeadingZeroes"),
    n_6 = class A extends Error {
      static {
        zB(this, "ServiceException")
      }
      constructor(Q) {
        super(Q.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = Q.name, this.$fault = Q.$fault, this.$metadata = Q.$metadata
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return A.prototype.isPrototypeOf(B) || Boolean(B.$fault) && Boolean(B.$metadata) && (B.$fault === "client" || B.$fault === "server")
      }
      static[Symbol.hasInstance](Q) {
        if (!Q) return !1;
        let B = Q;
        if (this === A) return A.isInstance(Q);
        if (A.isInstance(Q)) {
          if (B.name && this.name) return this.prototype.isPrototypeOf(Q) || B.name === this.name;
          return this.prototype.isPrototypeOf(Q)
        }
        return !1
      }
    },
    RvB = zB((A, Q = {}) => {
      Object.entries(Q).filter(([, G]) => G !== void 0).forEach(([G, Z]) => {
        if (A[G] == null || A[G] === "") A[G] = Z
      });
      let B = A.message || A.Message || "UnknownError";
      return A.message = B, delete A.Message, A
    }, "decorateServiceException"),
    TvB = zB(({
      output: A,
      parsedBody: Q,
      exceptionCtor: B,
      errorCode: G
    }) => {
      let Z = s_6(A),
        I = Z.httpStatusCode ? Z.httpStatusCode + "" : void 0,
        Y = new B({
          name: Q?.code || Q?.Code || G || I || "UnknownError",
          $fault: "client",
          $metadata: Z
        });
      throw RvB(Y, Q)
    }, "throwDefaultError"),
    a_6 = zB((A) => {
      return ({
        output: Q,
        parsedBody: B,
        errorCode: G
      }) => {
        TvB({
          output: Q,
          parsedBody: B,
          exceptionCtor: A,
          errorCode: G
        })
      }
    }, "withBaseException"),
    s_6 = zB((A) => ({
      httpStatusCode: A.statusCode,
      requestId: A.headers["x-amzn-requestid"] ?? A.headers["x-amzn-request-id"] ?? A.headers["x-amz-request-id"],
      extendedRequestId: A.headers["x-amz-id-2"],
      cfId: A.headers["x-amz-cf-id"]
    }), "deserializeMetadata"),
    r_6 = zB((A) => {
      switch (A) {
        case "standard":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard", connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard", connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard", connectionTimeout: 30000
          };
        default:
          return {}
      }
    }, "loadConfigsForDefaultMode"),
    EvB = !1,
    o_6 = zB((A) => {
      if (A && !EvB && parseInt(A.substring(1, A.indexOf("."))) < 16) EvB = !0
    }, "emitWarningIfUnsupportedVersion"),
    t_6 = zB((A) => {
      let Q = [];
      for (let B in fc1.AlgorithmId) {
        let G = fc1.AlgorithmId[B];
        if (A[G] === void 0) continue;
        Q.push({
          algorithmId: () => G,
          checksumConstructor: () => A[G]
        })
      }
      return {
        addChecksumAlgorithm(B) {
          Q.push(B)
        },
        checksumAlgorithms() {
          return Q
        }
      }
    }, "getChecksumConfiguration"),
    e_6 = zB((A) => {
      let Q = {};
      return A.checksumAlgorithms().forEach((B) => {
        Q[B.algorithmId()] = B.checksumConstructor()
      }), Q
    }, "resolveChecksumRuntimeConfig"),
    Ak6 = zB((A) => {
      return {
        setRetryStrategy(Q) {
          A.retryStrategy = Q
        },
        retryStrategy() {
          return A.retryStrategy
        }
      }
    }, "getRetryConfiguration"),
    Qk6 = zB((A) => {
      let Q = {};
      return Q.retryStrategy = A.retryStrategy(), Q
    }, "resolveRetryRuntimeConfig"),
    PvB = zB((A) => {
      return Object.assign(t_6(A), Ak6(A))
    }, "getDefaultExtensionConfiguration"),
    Bk6 = PvB,
    Gk6 = zB((A) => {
      return Object.assign(e_6(A), Qk6(A))
    }, "resolveDefaultRuntimeConfig"),
    Zk6 = zB((A) => Array.isArray(A) ? A : [A], "getArrayIfSingleItem"),
    jvB = zB((A) => {
      for (let B in A)
        if (A.hasOwnProperty(B) && A[B]["#text"] !== void 0) A[B] = A[B]["#text"];
        else if (typeof A[B] === "object" && A[B] !== null) A[B] = jvB(A[B]);
      return A
    }, "getValueFromTextNode"),
    Ik6 = zB((A) => {
      return A != null
    }, "isSerializableHeaderValue"),
    De = zB(function(Q) {
      return Object.assign(new String(Q), {
        deserializeJSON() {
          return JSON.parse(String(Q))
        },
        toString() {
          return String(Q)
        },
        toJSON() {
          return String(Q)
        }
      })
    }, "LazyJsonString");
  De.from = (A) => {
    if (A && typeof A === "object" && (A instanceof De || ("deserializeJSON" in A))) return A;
    else if (typeof A === "string" || Object.getPrototypeOf(A) === String.prototype) return De(String(A));
    return De(JSON.stringify(A))
  };
  De.fromObject = De.from;
  var Yk6 = class {
    static {
      zB(this, "NoOpLogger")
    }
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  };

  function ic1(A, Q, B) {
    let G, Z, I;
    if (typeof Q > "u" && typeof B > "u") G = {}, I = A;
    else if (G = A, typeof Q === "function") return Z = Q, I = B, Xk6(G, Z, I);
    else I = Q;
    for (let Y of Object.keys(I)) {
      if (!Array.isArray(I[Y])) {
        G[Y] = I[Y];
        continue
      }
      SvB(G, null, I, Y)
    }
    return G
  }
  zB(ic1, "map");
  var Jk6 = zB((A) => {
      let Q = {};
      for (let [B, G] of Object.entries(A || {})) Q[B] = [, G];
      return Q
    }, "convertMap"),
    Wk6 = zB((A, Q) => {
      let B = {};
      for (let G in Q) SvB(B, A, Q, G);
      return B
    }, "take"),
    Xk6 = zB((A, Q, B) => {
      return ic1(A, Object.entries(B).reduce((G, [Z, I]) => {
        if (Array.isArray(I)) G[Z] = I;
        else if (typeof I === "function") G[Z] = [Q, I()];
        else G[Z] = [Q, I];
        return G
      }, {}))
    }, "mapWithFilter"),
    SvB = zB((A, Q, B, G) => {
      if (Q !== null) {
        let Y = B[G];
        if (typeof Y === "function") Y = [, Y];
        let [J = Vk6, W = Fk6, X = G] = Y;
        if (typeof J === "function" && J(Q[X]) || typeof J !== "function" && !!J) A[G] = W(Q[X]);
        return
      }
      let [Z, I] = B[G];
      if (typeof I === "function") {
        let Y, J = Z === void 0 && (Y = I()) != null,
          W = typeof Z === "function" && !!Z(void 0) || typeof Z !== "function" && !!Z;
        if (J) A[G] = Y;
        else if (W) A[G] = I()
      } else {
        let Y = Z === void 0 && I != null,
          J = typeof Z === "function" && !!Z(I) || typeof Z !== "function" && !!Z;
        if (Y || J) A[G] = I
      }
    }, "applyInstruction"),
    Vk6 = zB((A) => A != null, "nonNullish"),
    Fk6 = zB((A) => A, "pass");

  function _vB(A) {
    if (A.includes(",") || A.includes('"')) A = `"${A.replace(/"/g,"\\\"")}"`;
    return A
  }
  zB(_vB, "quoteHeader");
  var Kk6 = zB((A) => {
      if (A !== A) return "NaN";
      switch (A) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return A
      }
    }, "serializeFloat"),
    Dk6 = zB((A) => A.toISOString().replace(".000Z", "Z"), "serializeDateTime"),
    mc1 = zB((A) => {
      if (A == null) return {};
      if (Array.isArray(A)) return A.filter((Q) => Q != null).map(mc1);
      if (typeof A === "object") {
        let Q = {};
        for (let B of Object.keys(A)) {
          if (A[B] == null) continue;
          Q[B] = mc1(A[B])
        }
        return Q
      }
      return A
    }, "_json");

  function kvB(A, Q, B) {
    if (B <= 0 || !Number.isInteger(B)) throw Error("Invalid number of delimiters (" + B + ") for splitEvery.");
    let G = A.split(Q);
    if (B === 1) return G;
    let Z = [],
      I = "";
    for (let Y = 0; Y < G.length; Y++) {
      if (I === "") I = G[Y];
      else I += Q + G[Y];
      if ((Y + 1) % B === 0) Z.push(I), I = ""
    }
    if (I !== "") Z.push(I);
    return Z
  }
  zB(kvB, "splitEvery");
  var Hk6 = zB((A) => {
    let Q = A.length,
      B = [],
      G = !1,
      Z = void 0,
      I = 0;
    for (let Y = 0; Y < Q; ++Y) {
      let J = A[Y];
      switch (J) {
        case '"':
          if (Z !== "\\") G = !G;
          break;
        case ",":
          if (!G) B.push(A.slice(I, Y)), I = Y + 1;
          break;
        default:
      }
      Z = J
    }
    return B.push(A.slice(I)), B.map((Y) => {
      Y = Y.trim();
      let J = Y.length;
      if (J < 2) return Y;
      if (Y[0] === '"' && Y[J - 1] === '"') Y = Y.slice(1, J - 1);
      return Y.replace(/\\"/g, '"')
    })
  }, "splitHeader")
})
// @from(Start 7068457, End 7068944)
bvB = z((xvB) => {
  Object.defineProperty(xvB, "__esModule", {
    value: !0
  });
  xvB.fromBase64 = void 0;
  var Ck6 = hI(),
    Ek6 = /^[A-Za-z0-9+/]*={0,2}$/,
    zk6 = (A) => {
      if (A.length * 3 % 4 !== 0) throw TypeError("Incorrect padding on base64 string.");
      if (!Ek6.exec(A)) throw TypeError("Invalid base64 string.");
      let Q = (0, Ck6.fromString)(A, "base64");
      return new Uint8Array(Q.buffer, Q.byteOffset, Q.byteLength)
    };
  xvB.fromBase64 = zk6
})
// @from(Start 7068950, End 7069529)
gvB = z((fvB) => {
  Object.defineProperty(fvB, "__esModule", {
    value: !0
  });
  fvB.toBase64 = void 0;
  var Uk6 = hI(),
    $k6 = O2(),
    wk6 = (A) => {
      let Q;
      if (typeof A === "string") Q = (0, $k6.fromUtf8)(A);
      else Q = A;
      if (typeof Q !== "object" || typeof Q.byteOffset !== "number" || typeof Q.byteLength !== "number") throw Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      return (0, Uk6.fromArrayBuffer)(Q.buffer, Q.byteOffset, Q.byteLength).toString("base64")
    };
  fvB.toBase64 = wk6
})
// @from(Start 7069535, End 7070231)
dvB = z((z2G, KtA) => {
  var {
    defineProperty: uvB,
    getOwnPropertyDescriptor: qk6,
    getOwnPropertyNames: Nk6
  } = Object, Lk6 = Object.prototype.hasOwnProperty, nc1 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of Nk6(Q))
        if (!Lk6.call(A, Z) && Z !== B) uvB(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = qk6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, mvB = (A, Q, B) => (nc1(A, Q, "default"), B && nc1(B, Q, "default")), Mk6 = (A) => nc1(uvB({}, "__esModule", {
    value: !0
  }), A), ac1 = {};
  KtA.exports = Mk6(ac1);
  mvB(ac1, bvB(), KtA.exports);
  mvB(ac1, gvB(), KtA.exports)
})
// @from(Start 7070237, End 7075122)
ZbB = z((BbB) => {
  Object.defineProperty(BbB, "__esModule", {
    value: !0
  });
  BbB.ruleSet = void 0;
  var evB = "required",
    a_ = "fn",
    s_ = "argv",
    SGA = "ref",
    cvB = !0,
    pvB = "isSet",
    DwA = "booleanEquals",
    jGA = "error",
    KwA = "endpoint",
    WE = "tree",
    sc1 = "PartitionResult",
    lvB = {
      [evB]: !1,
      type: "String"
    },
    ivB = {
      [evB]: !0,
      default: !1,
      type: "Boolean"
    },
    nvB = {
      [SGA]: "Endpoint"
    },
    AbB = {
      [a_]: DwA,
      [s_]: [{
        [SGA]: "UseFIPS"
      }, !0]
    },
    QbB = {
      [a_]: DwA,
      [s_]: [{
        [SGA]: "UseDualStack"
      }, !0]
    },
    n_ = {},
    avB = {
      [a_]: "getAttr",
      [s_]: [{
        [SGA]: sc1
      }, "supportsFIPS"]
    },
    svB = {
      [a_]: DwA,
      [s_]: [!0, {
        [a_]: "getAttr",
        [s_]: [{
          [SGA]: sc1
        }, "supportsDualStack"]
      }]
    },
    rvB = [AbB],
    ovB = [QbB],
    tvB = [{
      [SGA]: "Region"
    }],
    Ok6 = {
      version: "1.0",
      parameters: {
        Region: lvB,
        UseDualStack: ivB,
        UseFIPS: ivB,
        Endpoint: lvB
      },
      rules: [{
        conditions: [{
          [a_]: pvB,
          [s_]: [nvB]
        }],
        rules: [{
          conditions: rvB,
          error: "Invalid Configuration: FIPS and custom endpoint are not supported",
          type: jGA
        }, {
          rules: [{
            conditions: ovB,
            error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
            type: jGA
          }, {
            endpoint: {
              url: nvB,
              properties: n_,
              headers: n_
            },
            type: KwA
          }],
          type: WE
        }],
        type: WE
      }, {
        rules: [{
          conditions: [{
            [a_]: pvB,
            [s_]: tvB
          }],
          rules: [{
            conditions: [{
              [a_]: "aws.partition",
              [s_]: tvB,
              assign: sc1
            }],
            rules: [{
              conditions: [AbB, QbB],
              rules: [{
                conditions: [{
                  [a_]: DwA,
                  [s_]: [cvB, avB]
                }, svB],
                rules: [{
                  rules: [{
                    endpoint: {
                      url: "https://bedrock-runtime-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                      properties: n_,
                      headers: n_
                    },
                    type: KwA
                  }],
                  type: WE
                }],
                type: WE
              }, {
                error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                type: jGA
              }],
              type: WE
            }, {
              conditions: rvB,
              rules: [{
                conditions: [{
                  [a_]: DwA,
                  [s_]: [avB, cvB]
                }],
                rules: [{
                  rules: [{
                    endpoint: {
                      url: "https://bedrock-runtime-fips.{Region}.{PartitionResult#dnsSuffix}",
                      properties: n_,
                      headers: n_
                    },
                    type: KwA
                  }],
                  type: WE
                }],
                type: WE
              }, {
                error: "FIPS is enabled but this partition does not support FIPS",
                type: jGA
              }],
              type: WE
            }, {
              conditions: ovB,
              rules: [{
                conditions: [svB],
                rules: [{
                  rules: [{
                    endpoint: {
                      url: "https://bedrock-runtime.{Region}.{PartitionResult#dualStackDnsSuffix}",
                      properties: n_,
                      headers: n_
                    },
                    type: KwA
                  }],
                  type: WE
                }],
                type: WE
              }, {
                error: "DualStack is enabled but this partition does not support DualStack",
                type: jGA
              }],
              type: WE
            }, {
              rules: [{
                endpoint: {
                  url: "https://bedrock-runtime.{Region}.{PartitionResult#dnsSuffix}",
                  properties: n_,
                  headers: n_
                },
                type: KwA
              }],
              type: WE
            }],
            type: WE
          }],
          type: WE
        }, {
          error: "Invalid Configuration: Missing Region",
          type: jGA
        }],
        type: WE
      }]
    };
  BbB.ruleSet = Ok6
})
// @from(Start 7075128, End 7075692)
JbB = z((IbB) => {
  Object.defineProperty(IbB, "__esModule", {
    value: !0
  });
  IbB.defaultEndpointResolver = void 0;
  var Rk6 = I5A(),
    rc1 = FI(),
    Tk6 = ZbB(),
    Pk6 = new rc1.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    }),
    jk6 = (A, Q = {}) => {
      return Pk6.get(A, () => (0, rc1.resolveEndpoint)(Tk6.ruleSet, {
        endpointParams: A,
        logger: Q.logger
      }))
    };
  IbB.defaultEndpointResolver = jk6;
  rc1.customEndpointFunctions.aws = Rk6.awsEndpointFunctions
})
// @from(Start 7075698, End 7076922)
KbB = z((VbB) => {
  Object.defineProperty(VbB, "__esModule", {
    value: !0
  });
  VbB.getRuntimeConfig = void 0;
  var Sk6 = jF(),
    _k6 = FwA(),
    kk6 = NJ(),
    WbB = dvB(),
    XbB = O2(),
    yk6 = Nc1(),
    xk6 = JbB(),
    vk6 = (A) => {
      return {
        apiVersion: "2023-09-30",
        base64Decoder: A?.base64Decoder ?? WbB.fromBase64,
        base64Encoder: A?.base64Encoder ?? WbB.toBase64,
        disableHostPrefix: A?.disableHostPrefix ?? !1,
        endpointProvider: A?.endpointProvider ?? xk6.defaultEndpointResolver,
        extensions: A?.extensions ?? [],
        httpAuthSchemeProvider: A?.httpAuthSchemeProvider ?? yk6.defaultBedrockRuntimeHttpAuthSchemeProvider,
        httpAuthSchemes: A?.httpAuthSchemes ?? [{
          schemeId: "aws.auth#sigv4",
          identityProvider: (Q) => Q.getIdentityProvider("aws.auth#sigv4"),
          signer: new Sk6.AwsSdkSigV4Signer
        }],
        logger: A?.logger ?? new _k6.NoOpLogger,
        serviceId: A?.serviceId ?? "Bedrock Runtime",
        urlParser: A?.urlParser ?? kk6.parseUrl,
        utf8Decoder: A?.utf8Decoder ?? XbB.fromUtf8,
        utf8Encoder: A?.utf8Encoder ?? XbB.toUtf8
      }
    };
  VbB.getRuntimeConfig = vk6
})
// @from(Start 7076928, End 7079446)
UbB = z((EbB) => {
  Object.defineProperty(EbB, "__esModule", {
    value: !0
  });
  EbB.getRuntimeConfig = void 0;
  var bk6 = xyB(),
    fk6 = bk6.__importDefault(vyB()),
    hk6 = jF(),
    gk6 = Iy1(),
    uk6 = sxB(),
    DbB = eCA(),
    DtA = f8(),
    mk6 = YvB(),
    dk6 = RX(),
    HbB = D6(),
    _GA = uI(),
    CbB = IZ(),
    ck6 = TX(),
    pk6 = KW(),
    lk6 = KbB(),
    ik6 = FwA(),
    nk6 = PX(),
    ak6 = FwA(),
    sk6 = (A) => {
      (0, ak6.emitWarningIfUnsupportedVersion)(process.version);
      let Q = (0, nk6.resolveDefaultsModeConfig)(A),
        B = () => Q().then(ik6.loadConfigsForDefaultMode),
        G = (0, lk6.getRuntimeConfig)(A);
      (0, hk6.emitWarningIfUnsupportedVersion)(process.version);
      let Z = {
        profile: A?.profile
      };
      return {
        ...G,
        ...A,
        runtime: "node",
        defaultsMode: Q,
        bodyLengthChecker: A?.bodyLengthChecker ?? ck6.calculateBodyLength,
        credentialDefaultProvider: A?.credentialDefaultProvider ?? gk6.defaultProvider,
        defaultUserAgentProvider: A?.defaultUserAgentProvider ?? (0, DbB.createDefaultUserAgentProvider)({
          serviceId: G.serviceId,
          clientVersion: fk6.default.version
        }),
        eventStreamPayloadHandlerProvider: A?.eventStreamPayloadHandlerProvider ?? uk6.eventStreamPayloadHandlerProvider,
        eventStreamSerdeProvider: A?.eventStreamSerdeProvider ?? mk6.eventStreamSerdeProvider,
        maxAttempts: A?.maxAttempts ?? (0, _GA.loadConfig)(HbB.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, A),
        region: A?.region ?? (0, _GA.loadConfig)(DtA.NODE_REGION_CONFIG_OPTIONS, {
          ...DtA.NODE_REGION_CONFIG_FILE_OPTIONS,
          ...Z
        }),
        requestHandler: CbB.NodeHttpHandler.create(A?.requestHandler ?? B),
        retryMode: A?.retryMode ?? (0, _GA.loadConfig)({
          ...HbB.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await B()).retryMode || pk6.DEFAULT_RETRY_MODE
        }, A),
        sha256: A?.sha256 ?? dk6.Hash.bind(null, "sha256"),
        streamCollector: A?.streamCollector ?? CbB.streamCollector,
        useDualstackEndpoint: A?.useDualstackEndpoint ?? (0, _GA.loadConfig)(DtA.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, Z),
        useFipsEndpoint: A?.useFipsEndpoint ?? (0, _GA.loadConfig)(DtA.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, Z),
        userAgentAppId: A?.userAgentAppId ?? (0, _GA.loadConfig)(DbB.NODE_APP_ID_CONFIG_OPTIONS, Z)
      }
    };
  EbB.getRuntimeConfig = sk6
})
// @from(Start 7079452, End 7083959)
MbB = z((N2G, LbB) => {
  var {
    defineProperty: HtA,
    getOwnPropertyDescriptor: rk6,
    getOwnPropertyNames: ok6
  } = Object, tk6 = Object.prototype.hasOwnProperty, vp = (A, Q) => HtA(A, "name", {
    value: Q,
    configurable: !0
  }), ek6 = (A, Q) => {
    for (var B in Q) HtA(A, B, {
      get: Q[B],
      enumerable: !0
    })
  }, Ay6 = (A, Q, B, G) => {
    if (Q && typeof Q === "object" || typeof Q === "function") {
      for (let Z of ok6(Q))
        if (!tk6.call(A, Z) && Z !== B) HtA(A, Z, {
          get: () => Q[Z],
          enumerable: !(G = rk6(Q, Z)) || G.enumerable
        })
    }
    return A
  }, Qy6 = (A) => Ay6(HtA({}, "__esModule", {
    value: !0
  }), A), $bB = {};
  ek6($bB, {
    Field: () => Zy6,
    Fields: () => Iy6,
    HttpRequest: () => Yy6,
    HttpResponse: () => Jy6,
    IHttpRequest: () => wbB.HttpRequest,
    getHttpHandlerExtensionConfiguration: () => By6,
    isValidHostname: () => NbB,
    resolveHttpHandlerRuntimeConfig: () => Gy6
  });
  LbB.exports = Qy6($bB);
  var By6 = vp((A) => {
      return {
        setHttpHandler(Q) {
          A.httpHandler = Q
        },
        httpHandler() {
          return A.httpHandler
        },
        updateHttpClientConfig(Q, B) {
          A.httpHandler?.updateHttpClientConfig(Q, B)
        },
        httpHandlerConfigs() {
          return A.httpHandler.httpHandlerConfigs()
        }
      }
    }, "getHttpHandlerExtensionConfiguration"),
    Gy6 = vp((A) => {
      return {
        httpHandler: A.httpHandler()
      }
    }, "resolveHttpHandlerRuntimeConfig"),
    wbB = xc1(),
    Zy6 = class {
      static {
        vp(this, "Field")
      }
      constructor({
        name: A,
        kind: Q = wbB.FieldPosition.HEADER,
        values: B = []
      }) {
        this.name = A, this.kind = Q, this.values = B
      }
      add(A) {
        this.values.push(A)
      }
      set(A) {
        this.values = A
      }
      remove(A) {
        this.values = this.values.filter((Q) => Q !== A)
      }
      toString() {
        return this.values.map((A) => A.includes(",") || A.includes(" ") ? `"${A}"` : A).join(", ")
      }
      get() {
        return this.values
      }
    },
    Iy6 = class {
      constructor({
        fields: A = [],
        encoding: Q = "utf-8"
      }) {
        this.entries = {}, A.forEach(this.setField.bind(this)), this.encoding = Q
      }
      static {
        vp(this, "Fields")
      }
      setField(A) {
        this.entries[A.name.toLowerCase()] = A
      }
      getField(A) {
        return this.entries[A.toLowerCase()]
      }
      removeField(A) {
        delete this.entries[A.toLowerCase()]
      }
      getByType(A) {
        return Object.values(this.entries).filter((Q) => Q.kind === A)
      }
    },
    Yy6 = class A {
      static {
        vp(this, "HttpRequest")
      }
      constructor(Q) {
        this.method = Q.method || "GET", this.hostname = Q.hostname || "localhost", this.port = Q.port, this.query = Q.query || {}, this.headers = Q.headers || {}, this.body = Q.body, this.protocol = Q.protocol ? Q.protocol.slice(-1) !== ":" ? `${Q.protocol}:` : Q.protocol : "https:", this.path = Q.path ? Q.path.charAt(0) !== "/" ? `/${Q.path}` : Q.path : "/", this.username = Q.username, this.password = Q.password, this.fragment = Q.fragment
      }
      static clone(Q) {
        let B = new A({
          ...Q,
          headers: {
            ...Q.headers
          }
        });
        if (B.query) B.query = qbB(B.query);
        return B
      }
      static isInstance(Q) {
        if (!Q) return !1;
        let B = Q;
        return "method" in B && "protocol" in B && "hostname" in B && "path" in B && typeof B.query === "object" && typeof B.headers === "object"
      }
      clone() {
        return A.clone(this)
      }
    };

  function qbB(A) {
    return Object.keys(A).reduce((Q, B) => {
      let G = A[B];
      return {
        ...Q,
        [B]: Array.isArray(G) ? [...G] : G
      }
    }, {})
  }
  vp(qbB, "cloneQuery");
  var Jy6 = class {
    static {
      vp(this, "HttpResponse")
    }
    constructor(A) {
      this.statusCode = A.statusCode, this.reason = A.reason, this.headers = A.headers || {}, this.body = A.body
    }
    static isInstance(A) {
      if (!A) return !1;
      let Q = A;
      return typeof Q.statusCode === "number" && typeof Q.headers === "object"
    }
  };

  function NbB(A) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(A)
  }
  vp(NbB, "isValidHostname")
})