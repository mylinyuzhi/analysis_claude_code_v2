
// @from(Start 9980327, End 9981001)
function t00(A) {
  let Q = A.resetsAt ? ` · resets ${g3A(A.resetsAt,!0)}` : "";
  if (A.rateLimitType === "five_hour") return `5-hour limit reached${Q} · now using extra usage`;
  if (A.rateLimitType === "seven_day") return `Weekly limit reached${Q} · now using extra usage`;
  if (A.rateLimitType === "seven_day_opus") return `Opus weekly limit reached${Q} · now using extra usage`;
  if (A.rateLimitType === "seven_day_sonnet") {
    let B = f4();
    if (B === "pro" || B === "enterprise") return `Weekly limit reached${Q} · now using extra usage`;
    return `Sonnet weekly limit reached${Q} · now using extra usage · /model opus`
  }
  return "Now using extra usage"
}
// @from(Start 9981003, End 9982103)
function MYA(A, Q, B) {
  let G = f4(),
    Z = G === "team" || G === "enterprise",
    I = G === "pro",
    Y = G === "max",
    J = A === "Sonnet weekly limit",
    W = t6()?.hasExtraUsageEnabled === !0,
    X = "";
  if (I)
    if (KT(B) && o2("tengu_backstage_only"))
      if (W) X = "add funds to continue with extra usage";
      else X = "turn on /extra-usage";
  else X = `/upgrade to Max or ${W?"add funds to continue with extra usage":"turn on /extra-usage"}`;
  else if (Y)
    if (yc() === "default_claude_max_20x")
      if (J) X = "/model opus or turn on /extra-usage";
      else X = W ? "add funds to continue with extra usage" : "turn on /extra-usage";
  else if (J) X = `/model opus, /upgrade to Max 20x or ${W?"add funds to continue with extra usage":"turn on /extra-usage"}`;
  else X = `/upgrade to Max 20x or ${W?"add funds to continue with extra usage":"turn on /extra-usage"}`;
  else if (Z)
    if (J) X = "/model opus or contact an admin to increase limits";
    else X = "contact an admin to increase limits";
  let V = `${A} reached${Q}`;
  return X ? `${V} · ${X}` : V
}
// @from(Start 9982108, End 9982111)
KD5
// @from(Start 9982117, End 9982451)
e00 = L(() => {
  gB();
  t2();
  u2();
  KD5 = ["Limit reached", "Sonnet weekly limit reached", "Opus weekly limit reached", "Weekly limit reached", "5-hour limit reached", "Usage limit reached", "You've hit your", "Approaching spending cap", "Approaching Opus weekly limit", "Approaching weekly limit", "Approaching usage limit"]
})
// @from(Start 9982454, End 9982576)
function ED5(A, Q) {
  let B = Date.now() / 1000,
    G = A - Q,
    Z = B - G;
  return Math.max(0, Math.min(1, Z / Q))
}
// @from(Start 9982578, End 9982885)
function U91(A) {
  ik = A, AQ0.forEach((B) => B(A));
  let Q = Math.round((A.resetsAt ? A.resetsAt - Date.now() / 1000 : 0) / 3600);
  GA("tengu_claudeai_limits_status_changed", {
    status: A.status,
    unifiedRateLimitFallbackAvailable: A.unifiedRateLimitFallbackAvailable,
    hoursTillReset: Q
  })
}
// @from(Start 9982886, End 9983238)
async function zD5() {
  let A = MW(),
    Q = await Kq({
      maxRetries: 0,
      model: A
    }),
    B = [{
      role: "user",
      content: "quota"
    }],
    G = Dw(A);
  return Q.beta.messages.create({
    model: A,
    max_tokens: 1,
    messages: B,
    metadata: Rl(),
    ...G.length > 0 ? {
      betas: G
    } : {}
  }).asResponse()
}
// @from(Start 9983239, End 9983393)
async function TI2() {
  if (!LYA(BB())) return;
  try {
    let A = await zD5();
    QQ0(A.headers)
  } catch (A) {
    if (A instanceof n2) BQ0(A)
  }
}
// @from(Start 9983395, End 9983619)
function w91() {
  let [A, Q] = $91.useState({
    ...ik
  });
  return $91.useEffect(() => {
    let B = (G) => {
      Q({
        ...G
      })
    };
    return AQ0.add(B), () => {
      AQ0.delete(B)
    }
  }, []), A
}
// @from(Start 9983621, End 9984204)
function UD5(A, Q, B) {
  let {
    rateLimitType: G,
    claimAbbrev: Z,
    windowSeconds: I,
    thresholds: Y
  } = Q, J = A.get(`anthropic-ratelimit-unified-${Z}-utilization`), W = A.get(`anthropic-ratelimit-unified-${Z}-reset`);
  if (J === null || W === null) return null;
  let X = Number(J),
    V = Number(W),
    F = ED5(V, I);
  if (!Y.some((D) => X >= D.utilization && F <= D.timePct)) return null;
  return {
    status: "allowed_warning",
    resetsAt: V,
    rateLimitType: G,
    utilization: X,
    unifiedRateLimitFallbackAvailable: B,
    isUsingOverage: !1
  }
}
// @from(Start 9984206, End 9985153)
function PI2(A) {
  let Q = A.get("anthropic-ratelimit-unified-status") || "allowed",
    B = A.get("anthropic-ratelimit-unified-reset"),
    G = B ? Number(B) : void 0,
    Z = A.get("anthropic-ratelimit-unified-fallback") === "available",
    I = A.get("anthropic-ratelimit-unified-representative-claim"),
    Y = A.get("anthropic-ratelimit-unified-overage-status"),
    J = A.get("anthropic-ratelimit-unified-overage-reset"),
    W = J ? Number(J) : void 0,
    X = Q === "rejected" && (Y === "allowed" || Y === "allowed_warning"),
    V = Q;
  if (Q === "allowed" || Q === "allowed_warning") {
    for (let F of CD5) {
      let K = UD5(A, F, Z);
      if (K) return K
    }
    V = "allowed"
  }
  return {
    status: V,
    resetsAt: G,
    unifiedRateLimitFallbackAvailable: Z,
    ...I && {
      rateLimitType: I
    },
    ...Y && {
      overageStatus: Y
    },
    ...W && {
      overageResetsAt: W
    },
    isUsingOverage: X
  }
}
// @from(Start 9985155, End 9985439)
function QQ0(A) {
  let Q = BB();
  if (!LYA(Q)) {
    if (ik.status !== "allowed" || ik.resetsAt) U91({
      status: "allowed",
      unifiedRateLimitFallbackAvailable: !1,
      isUsingOverage: !1
    });
    return
  }
  let B = s00(A),
    G = PI2(B);
  if (!HH1(ik, G)) U91(G)
}
// @from(Start 9985441, End 9985702)
function BQ0(A) {
  if (!LYA(BB()) || A.status !== 429) return;
  try {
    let Q = {
      ...ik
    };
    if (A.headers) {
      let B = s00(A.headers);
      Q = PI2(B)
    }
    if (Q.status = "rejected", !HH1(ik, Q)) U91(Q)
  } catch (Q) {
    AA(Q)
  }
}
// @from(Start 9985707, End 9985710)
$91
// @from(Start 9985712, End 9985715)
CD5
// @from(Start 9985717, End 9985719)
ik
// @from(Start 9985721, End 9985724)
AQ0
// @from(Start 9985730, End 9986409)
Pi = L(() => {
  oZA();
  g1();
  t2();
  q0();
  gB();
  CS();
  p_();
  fZ();
  yu0();
  mMA();
  e00();
  $91 = BA(VA(), 1), CD5 = [{
    rateLimitType: "five_hour",
    claimAbbrev: "5h",
    windowSeconds: 18000,
    thresholds: [{
      utilization: 0.9,
      timePct: 0.72
    }]
  }, {
    rateLimitType: "seven_day",
    claimAbbrev: "7d",
    windowSeconds: 604800,
    thresholds: [{
      utilization: 0.75,
      timePct: 0.6
    }, {
      utilization: 0.5,
      timePct: 0.35
    }, {
      utilization: 0.25,
      timePct: 0.15
    }]
  }];
  ik = {
    status: "allowed",
    unifiedRateLimitFallbackAvailable: !1,
    isUsingOverage: !1
  }, AQ0 = new Set
})
// @from(Start 9986412, End 9989688)
function LD5(A, Q, B) {
  try {
    let G = -1;
    for (let J = 0; J < B.length; J++) {
      let W = B[J];
      if (!W) continue;
      let X = W.message.content;
      if (Array.isArray(X)) {
        for (let V of X)
          if (V.type === "tool_use" && "id" in V && V.id === A) {
            G = J;
            break
          }
      }
      if (G !== -1) break
    }
    let Z = -1;
    for (let J = 0; J < Q.length; J++) {
      let W = Q[J];
      if (!W) continue;
      if (W.type === "assistant" && "message" in W) {
        let X = W.message.content;
        if (Array.isArray(X)) {
          for (let V of X)
            if (V.type === "tool_use" && "id" in V && V.id === A) {
              Z = J;
              break
            }
        }
      }
      if (Z !== -1) break
    }
    let I = [];
    for (let J = G + 1; J < B.length; J++) {
      let W = B[J];
      if (!W) continue;
      let X = W.message.content;
      if (Array.isArray(X))
        for (let V of X) {
          let F = W.message.role;
          if (V.type === "tool_use" && "id" in V) I.push(`${F}:tool_use:${V.id}`);
          else if (V.type === "tool_result" && "tool_use_id" in V) I.push(`${F}:tool_result:${V.tool_use_id}`);
          else if (V.type === "text") I.push(`${F}:text`);
          else if (V.type === "thinking") I.push(`${F}:thinking`);
          else if (V.type === "image") I.push(`${F}:image`);
          else I.push(`${F}:${V.type}`)
        } else if (typeof X === "string") I.push(`${W.message.role}:string_content`)
    }
    let Y = [];
    for (let J = Z + 1; J < Q.length; J++) {
      let W = Q[J];
      if (!W) continue;
      switch (W.type) {
        case "user":
        case "assistant": {
          if ("message" in W) {
            let X = W.message.content;
            if (Array.isArray(X))
              for (let V of X) {
                let F = W.message.role;
                if (V.type === "tool_use" && "id" in V) Y.push(`${F}:tool_use:${V.id}`);
                else if (V.type === "tool_result" && "tool_use_id" in V) Y.push(`${F}:tool_result:${V.tool_use_id}`);
                else if (V.type === "text") Y.push(`${F}:text`);
                else if (V.type === "thinking") Y.push(`${F}:thinking`);
                else if (V.type === "image") Y.push(`${F}:image`);
                else Y.push(`${F}:${V.type}`)
              } else if (typeof X === "string") Y.push(`${W.message.role}:string_content`)
          }
          break
        }
        case "attachment":
          if ("attachment" in W) Y.push(`attachment:${W.attachment.type}`);
          break;
        case "system":
          if ("subtype" in W) Y.push(`system:${W.subtype}`);
          break;
        case "progress":
          if ("progress" in W && W.progress && typeof W.progress === "object" && "type" in W.progress) Y.push(`progress:${W.progress.type??"unknown"}`);
          else Y.push("progress:unknown");
          break
      }
    }
    GA("tengu_tool_use_tool_result_mismatch_error", {
      toolUseId: A,
      normalizedSequence: I.join(", "),
      preNormalizedSequence: Y.join(", "),
      normalizedMessageCount: B.length,
      originalMessageCount: Q.length,
      normalizedToolUseIndex: G,
      originalToolUseIndex: Z
    })
  } catch (G) {}
}
// @from(Start 9989690, End 9993899)
function ZQ0(A, Q, B) {
  if (A instanceof IS || A instanceof cC && A.message.toLowerCase().includes("timeout")) return KY({
    content: O91,
    error: "unknown"
  });
  if (A instanceof Error && A.message.includes(j1A)) return KY({
    content: j1A,
    error: "rate_limit"
  });
  if (A instanceof n2 && A.status === 429 && LYA(BB())) {
    let G = A.headers?.get?.("anthropic-ratelimit-unified-representative-claim"),
      Z = A.headers?.get?.("anthropic-ratelimit-unified-overage-status");
    if (G || Z) {
      let I = {
          status: "rejected",
          unifiedRateLimitFallbackAvailable: !1,
          isUsingOverage: !1
        },
        Y = A.headers?.get?.("anthropic-ratelimit-unified-reset");
      if (Y) I.resetsAt = Number(Y);
      if (G) I.rateLimitType = G;
      if (Z) I.overageStatus = Z;
      let J = A.headers?.get?.("anthropic-ratelimit-unified-overage-reset");
      if (J) I.overageResetsAt = Number(J);
      let W = r00(I, Q);
      if (W) return KY({
        content: W,
        error: "rate_limit"
      });
      return KY({
        content: S1A,
        error: "rate_limit"
      })
    }
    return KY({
      content: `${uV}: Rate limit reached`,
      error: "rate_limit"
    })
  }
  if (A instanceof Error && A.message.includes("prompt is too long")) return KY({
    content: OYA,
    error: "invalid_request"
  });
  if (A instanceof Error && /maximum of \d+ PDF pages/.test(A.message)) return KY({
    content: $D5,
    error: "invalid_request"
  });
  if (A instanceof Error && A.message.includes("The PDF specified is password protected")) return KY({
    content: wD5,
    error: "invalid_request"
  });
  if (A instanceof n2 && A.status === 400 && A.message.includes("image exceeds") && A.message.includes("maximum")) return KY({
    content: qD5
  });
  if (A instanceof n2 && A.status === 400 && A.message.includes("`tool_use` ids were found without `tool_result` blocks immediately after")) {
    if (B?.messages && B?.messagesForAPI) {
      let G = A.message.match(/toolu_[a-zA-Z0-9]+/),
        Z = G ? G[0] : null;
      if (Z) LD5(Z, B.messages, B.messagesForAPI)
    } {
      let Z = N6() ? "" : " Run /rewind to recover the conversation.";
      return KY({
        content: "API Error: 400 due to tool use concurrency issues." + Z,
        error: "invalid_request"
      })
    }
  }
  if (A instanceof n2 && A.status === 400 && A.message.includes("unexpected `tool_use_id` found in `tool_result`")) GA("tengu_unexpected_tool_result", {});
  if (BB() && A instanceof n2 && A.status === 400 && A.message.toLowerCase().includes("invalid model name") && (W7A(Q) || Q === "opus")) return KY({
    content: "Claude Opus is not available with the Claude Pro plan. If you have updated your subscription plan recently, run /logout and /login for the plan to take effect.",
    error: "invalid_request"
  });
  if (A instanceof Error && A.message.includes("Your credit balance is too low")) return KY({
    content: q91,
    error: "billing_error"
  });
  if (A instanceof Error && A.message.toLowerCase().includes("x-api-key")) {
    let {
      source: G
    } = cw();
    return KY({
      error: "authentication_failed",
      content: G === "ANTHROPIC_API_KEY" || G === "apiKeyHelper" ? L91 : N91
    })
  }
  if (A instanceof n2 && A.status === 403 && A.message.includes("OAuth token has been revoked")) return KY({
    error: "authentication_failed",
    content: M91
  });
  if (A instanceof n2 && (A.status === 401 || A.status === 403) && A.message.includes("OAuth authentication is currently not allowed for this organization")) return KY({
    error: "authentication_failed",
    content: ND5
  });
  if (A instanceof n2 && (A.status === 401 || A.status === 403)) return KY({
    error: "authentication_failed",
    content: `${uV}: ${A.message} · Please run /login`
  });
  if (Y0(process.env.CLAUDE_CODE_USE_BEDROCK) && A instanceof Error && A.message.toLowerCase().includes("model id")) return KY({
    content: `${uV} (${Q}): ${A.message}`,
    error: "invalid_request"
  });
  if (A instanceof Error) return KY({
    content: `${uV}: ${A.message}`,
    error: "unknown"
  });
  return KY({
    content: uV,
    error: "unknown"
  })
}
// @from(Start 9993901, End 9996245)
function jI2(A) {
  if (A instanceof IS || A instanceof cC && A.message.toLowerCase().includes("timeout")) return "api_timeout";
  if (A instanceof Error && A.message.includes(GQ0)) return "repeated_529";
  if (A instanceof Error && A.message.includes(j1A)) return "capacity_off_switch";
  if (A instanceof n2 && A.status === 429) return "rate_limit";
  if (A instanceof n2 && (A.status === 529 || A.message?.includes('"type":"overloaded_error"'))) return "server_overload";
  if (A instanceof Error && A.message.toLowerCase().includes(OYA.toLowerCase())) return "prompt_too_long";
  if (A instanceof Error && /maximum of \d+ PDF pages/.test(A.message)) return "pdf_too_large";
  if (A instanceof Error && A.message.includes("The PDF specified is password protected")) return "pdf_password_protected";
  if (A instanceof n2 && A.status === 400 && A.message.includes("image exceeds") && A.message.includes("maximum")) return "image_too_large";
  if (A instanceof n2 && A.status === 400 && A.message.includes("`tool_use` ids were found without `tool_result` blocks immediately after")) return "tool_use_mismatch";
  if (A instanceof n2 && A.status === 400 && A.message.includes("unexpected `tool_use_id` found in `tool_result`")) return "unexpected_tool_result";
  if (A instanceof n2 && A.status === 400 && A.message.toLowerCase().includes("invalid model name")) return "invalid_model";
  if (A instanceof Error && A.message.toLowerCase().includes(q91.toLowerCase())) return "credit_balance_low";
  if (A instanceof Error && A.message.toLowerCase().includes("x-api-key")) return "invalid_api_key";
  if (A instanceof n2 && A.status === 403 && A.message.includes("OAuth token has been revoked")) return "token_revoked";
  if (A instanceof n2 && (A.status === 401 || A.status === 403) && A.message.includes("OAuth authentication is currently not allowed for this organization")) return "oauth_org_not_allowed";
  if (A instanceof n2 && (A.status === 401 || A.status === 403)) return "auth_error";
  if (Y0(process.env.CLAUDE_CODE_USE_BEDROCK) && A instanceof Error && A.message.toLowerCase().includes("model id")) return "bedrock_model_access";
  if (A instanceof n2) {
    let Q = A.status;
    if (Q >= 500) return "server_error";
    if (Q >= 400) return "client_error"
  }
  if (A instanceof cC) return "connection_error";
  return "unknown"
}
// @from(Start 9996247, End 9996829)
function SI2(A, Q) {
  if (A !== "refusal") return;
  GA("tengu_refusal_api_response", {});
  let B = `${uV}: Claude Code is unable to respond to this request, which appears to violate our Usage Policy (https://www.anthropic.com/legal/aup). Please double press esc to edit your last message or start a new session for Claude Code to assist with a different task.`;
  return KY({
    content: B + (Q !== "claude-sonnet-4-20250514" ? " If you are seeing this refusal repeatedly, try running /model claude-sonnet-4-20250514 to switch models." : ""),
    error: "invalid_request"
  })
}
// @from(Start 9996834, End 9996850)
uV = "API Error"
// @from(Start 9996854, End 9996880)
OYA = "Prompt is too long"
// @from(Start 9996884, End 9996917)
q91 = "Credit balance is too low"
// @from(Start 9996921, End 9996964)
N91 = "Invalid API key · Please run /login"
// @from(Start 9996968, End 9997014)
L91 = "Invalid API key · Fix external API key"
// @from(Start 9997018, End 9997037)
$q = "(no content)"
// @from(Start 9997041, End 9997088)
M91 = "OAuth token revoked · Please run /login"
// @from(Start 9997092, End 9997130)
GQ0 = "Repeated 529 Overloaded errors"
// @from(Start 9997134, End 9997211)
j1A = "Opus is experiencing high load, please use /model to switch to Sonnet"
// @from(Start 9997215, End 9997240)
O91 = "Request timed out"
// @from(Start 9997244, End 9997326)
$D5 = "PDF too large. Please double press esc to edit your message and try again."
// @from(Start 9997330, End 9997424)
wD5 = "PDF is password protected. Please double press esc to edit your message and try again."
// @from(Start 9997428, End 9997520)
qD5 = "Image was too large. Double press esc to go back and try again with a smaller image."
// @from(Start 9997524, End 9997600)
ND5 = "Your account does not have access to Claude Code. Please run /login."
// @from(Start 9997606, End 9997695)
ZO = L(() => {
  p_();
  gB();
  cQ();
  t2();
  q0();
  Pi();
  mMA();
  hQ();
  _0()
})
// @from(Start 9997698, End 10007856)
function R91(A) {
  if (!A || A.trim() === "") return `Your task is to create a detailed summary of the conversation so far, paying close attention to the user's explicit requests and your previous actions.
This summary should be thorough in capturing technical details, code patterns, and architectural decisions that would be essential for continuing development work without losing context.

Before providing your final summary, wrap your analysis in <analysis> tags to organize your thoughts and ensure you've covered all necessary points. In your analysis process:

1. Chronologically analyze each message and section of the conversation. For each section thoroughly identify:
   - The user's explicit requests and intents
   - Your approach to addressing the user's requests
   - Key decisions, technical concepts and code patterns
   - Specific details like:
     - file names
     - full code snippets
     - function signatures
     - file edits
  - Errors that you ran into and how you fixed them
  - Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
2. Double-check for technical accuracy and completeness, addressing each required element thoroughly.

Your summary should include the following sections:

1. Primary Request and Intent: Capture all of the user's explicit requests and intents in detail
2. Key Technical Concepts: List all important technical concepts, technologies, and frameworks discussed.
3. Files and Code Sections: Enumerate specific files and code sections examined, modified, or created. Pay special attention to the most recent messages and include full code snippets where applicable and include a summary of why this file read or edit is important.
4. Errors and fixes: List all errors that you ran into, and how you fixed them. Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
5. Problem Solving: Document problems solved and any ongoing troubleshooting efforts.
6. All user messages: List ALL user messages that are not tool results. These are critical for understanding the users' feedback and changing intent.
6. Pending Tasks: Outline any pending tasks that you have explicitly been asked to work on.
7. Current Work: Describe in detail precisely what was being worked on immediately before this summary request, paying special attention to the most recent messages from both user and assistant. Include file names and code snippets where applicable.
8. Optional Next Step: List the next step that you will take that is related to the most recent work you were doing. IMPORTANT: ensure that this step is DIRECTLY in line with the user's most recent explicit requests, and the task you were working on immediately before this summary request. If your last task was concluded, then only list next steps if they are explicitly in line with the users request. Do not start on tangential requests or really old requests that were already completed without confirming with the user first.
                       If there is a next step, include direct quotes from the most recent conversation showing exactly what task you were working on and where you left off. This should be verbatim to ensure there's no drift in task interpretation.

Here's an example of how your output should be structured:

<example>
<analysis>
[Your thought process, ensuring all points are covered thoroughly and accurately]
</analysis>

<summary>
1. Primary Request and Intent:
   [Detailed description]

2. Key Technical Concepts:
   - [Concept 1]
   - [Concept 2]
   - [...]

3. Files and Code Sections:
   - [File Name 1]
      - [Summary of why this file is important]
      - [Summary of the changes made to this file, if any]
      - [Important Code Snippet]
   - [File Name 2]
      - [Important Code Snippet]
   - [...]

4. Errors and fixes:
    - [Detailed description of error 1]:
      - [How you fixed the error]
      - [User feedback on the error if any]
    - [...]

5. Problem Solving:
   [Description of solved problems and ongoing troubleshooting]

6. All user messages: 
    - [Detailed non tool use user message]
    - [...]

7. Pending Tasks:
   - [Task 1]
   - [Task 2]
   - [...]

8. Current Work:
   [Precise description of current work]

9. Optional Next Step:
   [Optional Next step to take]

</summary>
</example>

Please provide your summary based on the conversation so far, following this structure and ensuring precision and thoroughness in your response. 

There may be additional summarization instructions provided in the included context. If so, remember to follow these instructions when creating the above summary. Examples of instructions include:
<example>
## Compact Instructions
When summarizing the conversation focus on typescript code changes and also remember the mistakes you made and how you fixed them.
</example>

<example>
# Summary instructions
When you are using compact - please focus on test output and code changes. Include file reads verbatim.
</example>
`;
  return `Your task is to create a detailed summary of the conversation so far, paying close attention to the user's explicit requests and your previous actions.
This summary should be thorough in capturing technical details, code patterns, and architectural decisions that would be essential for continuing development work without losing context.

Before providing your final summary, wrap your analysis in <analysis> tags to organize your thoughts and ensure you've covered all necessary points. In your analysis process:

1. Chronologically analyze each message and section of the conversation. For each section thoroughly identify:
   - The user's explicit requests and intents
   - Your approach to addressing the user's requests
   - Key decisions, technical concepts and code patterns
   - Specific details like:
     - file names
     - full code snippets
     - function signatures
     - file edits
  - Errors that you ran into and how you fixed them
  - Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
2. Double-check for technical accuracy and completeness, addressing each required element thoroughly.

Your summary should include the following sections:

1. Primary Request and Intent: Capture all of the user's explicit requests and intents in detail
2. Key Technical Concepts: List all important technical concepts, technologies, and frameworks discussed.
3. Files and Code Sections: Enumerate specific files and code sections examined, modified, or created. Pay special attention to the most recent messages and include full code snippets where applicable and include a summary of why this file read or edit is important.
4. Errors and fixes: List all errors that you ran into, and how you fixed them. Pay special attention to specific user feedback that you received, especially if the user told you to do something differently.
5. Problem Solving: Document problems solved and any ongoing troubleshooting efforts.
6. All user messages: List ALL user messages that are not tool results. These are critical for understanding the users' feedback and changing intent.
6. Pending Tasks: Outline any pending tasks that you have explicitly been asked to work on.
7. Current Work: Describe in detail precisely what was being worked on immediately before this summary request, paying special attention to the most recent messages from both user and assistant. Include file names and code snippets where applicable.
8. Optional Next Step: List the next step that you will take that is related to the most recent work you were doing. IMPORTANT: ensure that this step is DIRECTLY in line with the user's most recent explicit requests, and the task you were working on immediately before this summary request. If your last task was concluded, then only list next steps if they are explicitly in line with the users request. Do not start on tangential requests or really old requests that were already completed without confirming with the user first.
                       If there is a next step, include direct quotes from the most recent conversation showing exactly what task you were working on and where you left off. This should be verbatim to ensure there's no drift in task interpretation.

Here's an example of how your output should be structured:

<example>
<analysis>
[Your thought process, ensuring all points are covered thoroughly and accurately]
</analysis>

<summary>
1. Primary Request and Intent:
   [Detailed description]

2. Key Technical Concepts:
   - [Concept 1]
   - [Concept 2]
   - [...]

3. Files and Code Sections:
   - [File Name 1]
      - [Summary of why this file is important]
      - [Summary of the changes made to this file, if any]
      - [Important Code Snippet]
   - [File Name 2]
      - [Important Code Snippet]
   - [...]

4. Errors and fixes:
    - [Detailed description of error 1]:
      - [How you fixed the error]
      - [User feedback on the error if any]
    - [...]

5. Problem Solving:
   [Description of solved problems and ongoing troubleshooting]

6. All user messages: 
    - [Detailed non tool use user message]
    - [...]

7. Pending Tasks:
   - [Task 1]
   - [Task 2]
   - [...]

8. Current Work:
   [Precise description of current work]

9. Optional Next Step:
   [Optional Next step to take]

</summary>
</example>

Please provide your summary based on the conversation so far, following this structure and ensuring precision and thoroughness in your response. 

There may be additional summarization instructions provided in the included context. If so, remember to follow these instructions when creating the above summary. Examples of instructions include:
<example>
## Compact Instructions
When summarizing the conversation focus on typescript code changes and also remember the mistakes you made and how you fixed them.
</example>

<example>
# Summary instructions
When you are using compact - please focus on test output and code changes. Include file reads verbatim.
</example>


Additional Instructions:
${A}`
}
// @from(Start 10007858, End 10008274)
function MD5(A) {
  let Q = A,
    B = Q.match(/<analysis>([\s\S]*?)<\/analysis>/);
  if (B) {
    let Z = B[1] || "";
    Q = Q.replace(/<analysis>[\s\S]*?<\/analysis>/, `Analysis:
${Z.trim()}`)
  }
  let G = Q.match(/<summary>([\s\S]*?)<\/summary>/);
  if (G) {
    let Z = G[1] || "";
    Q = Q.replace(/<summary>[\s\S]*?<\/summary>/, `Summary:
${Z.trim()}`)
  }
  return Q = Q.replace(/\n\n+/g, `

`), Q.trim()
}
// @from(Start 10008276, End 10008647)
function T91(A, Q) {
  let G = `This session is being continued from a previous conversation that ran out of context. The conversation is summarized below:
${MD5(A)}.`;
  if (Q) return `${G}
Please continue the conversation from where we left it off without asking the user any further questions. Continue with the last task that you were asked to work on.`;
  return G
}
// @from(Start 10008649, End 10008680)
function P91(A, Q) {
  return
}
// @from(Start 10008685, End 10008688)
OD5
// @from(Start 10008690, End 10008693)
RD5
// @from(Start 10008699, End 10008820)
IQ0 = L(() => {
  AQ();
  q0();
  l2();
  OD5 = s1(() => {
    return null
  }), RD5 = s1(() => {
    return null
  })
})
// @from(Start 10008823, End 10008914)
function YQ0(A) {
  if (A === "Local") return "project (local)";
  return A.toLowerCase()
}
// @from(Start 10008919, End 10008922)
_I2
// @from(Start 10008928, End 10009023)
JQ0 = L(() => {
  _I2 = ["User", "Project", "Local", "Managed", "ExperimentalUltraClaudeMd"]
})
// @from(Start 10009026, End 10010108)
function yI2(A) {
  let Q = {
      toolRequests: new Map,
      toolResults: new Map,
      humanMessages: 0,
      assistantMessages: 0,
      localCommandOutputs: 0,
      other: 0,
      attachments: new Map,
      duplicateFileReads: new Map,
      total: 0
    },
    B = new Map,
    G = new Map,
    Z = new Map;
  return A.forEach((Y) => {
    if (Y.type === "attachment") {
      let J = Y.attachment.type || "unknown";
      Q.attachments.set(J, (Q.attachments.get(J) || 0) + 1)
    }
  }), WZ(A).forEach((Y) => {
    let {
      content: J
    } = Y.message;
    if (typeof J === "string") {
      let W = gG(J);
      if (Q.total += W, Y.type === "user" && J.includes("local-command-stdout")) Q.localCommandOutputs += W;
      else Q[Y.type === "user" ? "humanMessages" : "assistantMessages"] += W
    } else J.forEach((W) => TD5(W, Y, Q, B, G, Z))
  }), Z.forEach((Y, J) => {
    if (Y.count > 1) {
      let X = Math.floor(Y.totalTokens / Y.count) * (Y.count - 1);
      Q.duplicateFileReads.set(J, {
        count: Y.count,
        tokens: X
      })
    }
  }), Q
}
// @from(Start 10010110, End 10011747)
function TD5(A, Q, B, G, Z, I) {
  let Y = gG(JSON.stringify(A));
  switch (B.total += Y, A.type) {
    case "text":
      if (Q.type === "user" && "text" in A && A.text.includes("local-command-stdout")) B.localCommandOutputs += Y;
      else B[Q.type === "user" ? "humanMessages" : "assistantMessages"] += Y;
      break;
    case "tool_use": {
      if ("name" in A && "id" in A) {
        let J = A.name || "unknown";
        if (kI2(B.toolRequests, J, Y), G.set(A.id, J), J === "Read" && "input" in A && A.input && typeof A.input === "object" && "file_path" in A.input) {
          let W = String(A.input.file_path);
          Z.set(A.id, W)
        }
      }
      break
    }
    case "tool_result": {
      if ("tool_use_id" in A) {
        let J = G.get(A.tool_use_id) || "unknown";
        if (kI2(B.toolResults, J, Y), J === "Read") {
          let W = Z.get(A.tool_use_id);
          if (W) {
            let X = I.get(W) || {
              count: 0,
              totalTokens: 0
            };
            I.set(W, {
              count: X.count + 1,
              totalTokens: X.totalTokens + Y
            })
          }
        }
      }
      break
    }
    case "image":
    case "server_tool_use":
    case "web_search_tool_result":
    case "search_result":
    case "document":
    case "thinking":
    case "redacted_thinking":
    case "code_execution_tool_result":
    case "mcp_tool_use":
    case "mcp_tool_result":
    case "container_upload":
    case "web_fetch_tool_result":
    case "bash_code_execution_tool_result":
    case "text_editor_code_execution_tool_result":
      B.other += Y;
      break
  }
}
// @from(Start 10011749, End 10011806)
function kI2(A, Q, B) {
  A.set(Q, (A.get(Q) || 0) + B)
}
// @from(Start 10011808, End 10013249)
function xI2(A) {
  let Q = {
    total_tokens: A.total,
    human_message_tokens: A.humanMessages,
    assistant_message_tokens: A.assistantMessages,
    local_command_output_tokens: A.localCommandOutputs,
    other_tokens: A.other
  };
  A.attachments.forEach((G, Z) => {
    Q[`attachment_${Z}_count`] = G
  }), A.toolRequests.forEach((G, Z) => {
    Q[`tool_request_${Z}_tokens`] = G
  }), A.toolResults.forEach((G, Z) => {
    Q[`tool_result_${Z}_tokens`] = G
  });
  let B = [...A.duplicateFileReads.values()].reduce((G, Z) => G + Z.tokens, 0);
  if (Q.duplicate_read_tokens = B, Q.duplicate_read_file_count = A.duplicateFileReads.size, A.total > 0) {
    Q.human_message_percent = Math.round(A.humanMessages / A.total * 100), Q.assistant_message_percent = Math.round(A.assistantMessages / A.total * 100), Q.local_command_output_percent = Math.round(A.localCommandOutputs / A.total * 100), Q.duplicate_read_percent = Math.round(B / A.total * 100);
    let G = [...A.toolRequests.values()].reduce((I, Y) => I + Y, 0),
      Z = [...A.toolResults.values()].reduce((I, Y) => I + Y, 0);
    Q.tool_request_percent = Math.round(G / A.total * 100), Q.tool_result_percent = Math.round(Z / A.total * 100), A.toolRequests.forEach((I, Y) => {
      Q[`tool_request_${Y}_percent`] = Math.round(I / A.total * 100)
    }), A.toolResults.forEach((I, Y) => {
      Q[`tool_result_${Y}_percent`] = Math.round(I / A.total * 100)
    })
  }
  return Q
}
// @from(Start 10013254, End 10013287)
vI2 = L(() => {
  xM();
  cQ()
})
// @from(Start 10013343, End 10015774)
function jD5(A, Q, B) {
  return {
    type: "callback",
    timeout: B,
    callback: async (G, Z, I, Y) => {
      let J = A.replace(/\$\{CLAUDE_PLUGIN_ROOT\}/g, Q),
        W = {
          ...process.env,
          CLAUDE_PLUGIN_ROOT: Q,
          CLAUDE_PROJECT_DIR: uQ()
        };
      if (G.hook_event_name === "SessionStart" && Y !== void 0) W.CLAUDE_ENV_FILE = LsA(Y);
      let X = JSON.stringify(G),
        V = PD5(J, [], {
          env: W,
          shell: !0,
          signal: I
        }),
        F = "",
        K = "";
      V.stdout.on("data", (H) => {
        F += H.toString()
      }), V.stderr.on("data", (H) => {
        K += H.toString()
      }), V.stdin.on("error", (H) => {
        g(`Plugin hook stdin error for "${J}": ${H.message}`)
      }), V.stdin.write(X), V.stdin.end();
      let D;
      try {
        D = await new Promise((H, C) => {
          V.on("close", (E) => {
            H(E ?? 1)
          }), V.on("error", C)
        })
      } catch (H) {
        let C = H instanceof Error ? H.message : String(H);
        return AA(Error(`Plugin hook "${J}" failed to execute: ${C}`)), g(`Plugin hook spawn error: ${C}`), {
          suppressOutput: !1,
          systemMessage: `Plugin hook "${J}" failed to start: ${C}. Check that the command exists and is executable.`
        }
      }
      try {
        let H = F.trim();
        if (H.startsWith("{")) return JSON.parse(H)
      } catch (H) {
        g(`Plugin hook "${J}" produced invalid JSON output: ${H instanceof Error?H.message:String(H)}. Falling back to exit code handling.`)
      }
      if (D === 0) return {
        suppressOutput: !1
      };
      else if (D === 2) {
        let H = K.trim(),
          C = F.trim();
        return {
          decision: "block",
          reason: H ? H : C ? `Hook blocked with message: ${C}` : `Plugin hook "${J}" blocked this action (exit code 2) but provided no reason.`
        }
      } else {
        let H = K.trim(),
          C = F.trim(),
          E = [`Plugin hook "${J}" failed with exit code ${D}`];
        if (H) E.push(`stderr: ${H}`);
        if (C) E.push(`stdout: ${C}`);
        let U = E.join(`
`);
        return AA(Error(U)), g(U), {
          suppressOutput: !1,
          systemMessage: H ? `Plugin hook error: ${H}` : C ? `Plugin hook "${J}" exited with code ${D}: ${C}` : `Plugin hook "${J}" exited with code ${D}. See ${Ps()}`
        }
      }
    }
  }
}
// @from(Start 10015776, End 10016488)
function SD5(A) {
  let Q = {
    PreToolUse: [],
    PostToolUse: [],
    PostToolUseFailure: [],
    Notification: [],
    UserPromptSubmit: [],
    SessionStart: [],
    SessionEnd: [],
    Stop: [],
    SubagentStart: [],
    SubagentStop: [],
    PreCompact: [],
    PermissionRequest: []
  };
  if (!A.hooksConfig) return Q;
  for (let [B, G] of Object.entries(A.hooksConfig)) {
    let Z = B;
    if (!Q[Z]) continue;
    for (let I of G) {
      let Y = [];
      for (let J of I.hooks)
        if (J.type === "command") Y.push(jD5(J.command, A.path, J.timeout));
      if (Y.length > 0) Q[Z].push({
        matcher: I.matcher,
        hooks: Y,
        pluginName: A.name
      })
    }
  }
  return Q
}
// @from(Start 10016490, End 10016531)
function bI2() {
  _1A.cache?.clear?.()
}
// @from(Start 10016536, End 10016539)
_1A
// @from(Start 10016545, End 10017346)
dMA = L(() => {
  l2();
  fV();
  V0();
  _0();
  D$A();
  g1();
  _1A = s1(async () => {
    let {
      enabled: A
    } = await l7(), Q = {
      PreToolUse: [],
      PostToolUse: [],
      PostToolUseFailure: [],
      Notification: [],
      UserPromptSubmit: [],
      SessionStart: [],
      SessionEnd: [],
      Stop: [],
      SubagentStart: [],
      SubagentStop: [],
      PreCompact: [],
      PermissionRequest: []
    };
    for (let G of A) {
      if (!G.hooksConfig) continue;
      g(`Loading hooks from plugin: ${G.name}`);
      let Z = SD5(G);
      for (let I of Object.keys(Z)) Q[I].push(...Z[I])
    }
    LkA(Q);
    let B = Object.values(Q).reduce((G, Z) => G + Z.reduce((I, Y) => I + Y.hooks.length, 0), 0);
    g(`Registered ${B} hooks from ${A.length} plugins`)
  })
})
// @from(Start 10017348, End 10019075)
async function wq(A, Q) {
  let B = [],
    G = [];
  if (t21()) g("Skipping plugin hooks - allowManagedHooksOnly is enabled");
  else try {
    await _1A()
  } catch (Z) {
    let I = Z instanceof Error ? Error(`Failed to load plugin hooks during ${A}: ${Z.message}`) : Error(`Failed to load plugin hooks during ${A}: ${String(Z)}`);
    if (Z instanceof Error && Z.stack) I.stack = Z.stack;
    AA(I);
    let Y = Z instanceof Error ? Z.message : String(Z),
      J = "";
    if (Y.includes("Failed to clone") || Y.includes("network") || Y.includes("ETIMEDOUT") || Y.includes("ENOTFOUND")) J = "This appears to be a network issue. Check your internet connection and try again.";
    else if (Y.includes("Permission denied") || Y.includes("EACCES") || Y.includes("EPERM")) J = "This appears to be a permissions issue. Check file permissions on ~/.claude/plugins/";
    else if (Y.includes("Invalid") || Y.includes("parse") || Y.includes("JSON") || Y.includes("schema")) J = "This appears to be a configuration issue. Check your plugin settings in .claude/settings.json";
    else J = "Please fix the plugin configuration or remove problematic plugins from your settings.";
    g(`Warning: Failed to load plugin hooks. SessionStart hooks from plugins will not execute. Error: ${Y}. ${J}`, {
      level: "warn"
    })
  }
  for await (let Z of WQ0(A, Q)) {
    if (Z.message) B.push(Z.message);
    if (Z.additionalContexts && Z.additionalContexts.length > 0) G.push(...Z.additionalContexts)
  }
  if (G.length > 0) {
    let Z = l9({
      type: "hook_additional_context",
      content: G,
      hookName: "SessionStart",
      toolUseID: "SessionStart",
      hookEvent: "SessionStart"
    });
    B.push(Z)
  }
  return B
}
// @from(Start 10019080, End 10019147)
k1A = L(() => {
  YO();
  dMA();
  g1();
  V0();
  IO();
  CYA()
})
// @from(Start 10019149, End 10023527)
async function j91(A, Q, B, G, Z = !1) {
  try {
    if (A.length === 0) throw Error(cMA);
    let I = ZK(A),
      Y = yI2(A),
      J = {};
    try {
      J = xI2(Y)
    } catch (e) {
      AA(e)
    }
    let W = await Q.getAppState();
    P91(W.toolPermissionContext, "summary"), Q.setSpinnerColor?.("claudeBlue_FOR_SYSTEM_SPINNER"), Q.setSpinnerShimmerColor?.("claudeBlueShimmer_FOR_SYSTEM_SPINNER"), Q.setSpinnerMessage?.("Running PreCompact hooks..."), Q.setSDKStatus?.("compacting");
    let X = await FQ0({
      trigger: Z ? "auto" : "manual",
      customInstructions: G ?? null,
      sessionId: Q.agentId
    }, Q.abortController.signal);
    if (X.newCustomInstructions) G = G ? `${G}

${X.newCustomInstructions}` : X.newCustomInstructions;
    let V = X.userDisplayMessage;
    Q.setStreamMode?.("requesting"), Q.setResponseLength?.(() => 0), Q.setSpinnerMessage?.("Compacting conversation");
    let F = R91(G),
      K = R0({
        content: F
      }),
      H = RYA({
        messages: WZ([...nk(A), K]),
        systemPrompt: ["You are a helpful AI assistant tasked with summarizing conversations."],
        maxThinkingTokens: 0,
        tools: [n8],
        signal: Q.abortController.signal,
        options: {
          async getToolPermissionContext() {
            return (await Q.getAppState()).toolPermissionContext
          },
          model: k3(),
          toolChoice: void 0,
          isNonInteractiveSession: Q.options.isNonInteractiveSession,
          hasAppendSystemPrompt: Q.options.hasAppendSystemPrompt,
          maxOutputTokensOverride: EkA,
          querySource: "compact",
          agents: Q.options.agentDefinitions.activeAgents,
          mcpTools: [],
          agentIdOrSessionId: e1()
        }
      })[Symbol.asyncIterator](),
      C = await H.next(),
      E = !1,
      U;
    while (!C.done) {
      let e = C.value;
      if (!E && e.type === "stream_event" && e.event.type === "content_block_start" && e.event.content_block.type === "text") E = !0, Q.setStreamMode?.("responding");
      if (e.type === "stream_event" && e.event.type === "content_block_delta" && e.event.delta.type === "text_delta") {
        let l = e.event.delta.text.length;
        Q.setResponseLength?.((k) => k + l)
      }
      if (e.type === "assistant") U = e;
      C = await H.next()
    }
    if (!U) throw Error("Failed to get summary response from streaming");
    let q = ji(U);
    if (!q) throw GA("tengu_compact_failed", {
      reason: "no_summary",
      preCompactTokenCount: I
    }), Error("Failed to generate conversation summary - response did not contain valid text content");
    else if (q.startsWith(uV)) throw GA("tengu_compact_failed", {
      reason: "api_error",
      preCompactTokenCount: I
    }), Error(q);
    else if (q.startsWith(OYA)) throw GA("tengu_compact_failed", {
      reason: "prompt_too_long",
      preCompactTokenCount: I
    }), Error(xD5);
    let w = GA2(Q.readFileState);
    Q.readFileState.clear();
    let N = await bD5(w, Q, _D5),
      R = fD5(Q.agentId);
    if (R) N.push(R);
    let T = XQ0(Q.agentId);
    if (T) N.push(T);
    Q.setSpinnerMessage?.("Running SessionStart hooks...");
    let y = await wq("compact"),
      v = ZK([U]),
      x = C91(U);
    GA("tengu_compact", {
      preCompactTokenCount: I,
      postCompactTokenCount: v,
      compactionInputTokens: x?.input_tokens,
      compactionOutputTokens: x?.output_tokens,
      compactionCacheReadTokens: x?.cache_read_input_tokens ?? 0,
      compactionCacheCreationTokens: x?.cache_creation_input_tokens ?? 0,
      compactionTotalTokens: x ? x.input_tokens + (x.cache_creation_input_tokens ?? 0) + (x.cache_read_input_tokens ?? 0) + x.output_tokens : 0,
      ...J
    });
    let p = S91(Z ? "auto" : "manual", I ?? 0),
      u = [R0({
        content: T91(q, B),
        isCompactSummary: !0,
        isVisibleInTranscriptOnly: !0
      })];
    return {
      boundaryMarker: p,
      summaryMessages: u,
      attachments: N,
      hookResults: y,
      userDisplayMessage: V,
      preCompactTokenCount: I,
      postCompactTokenCount: v,
      compactionUsage: x
    }
  } catch (I) {
    throw vD5(I, Q), I
  } finally {
    Q.setStreamMode?.("requesting"), Q.setResponseLength?.(() => 0), Q.setSpinnerMessage?.(null), Q.setSDKStatus?.(null), Q.setSpinnerColor?.(null), Q.setSpinnerShimmerColor?.(null)
  }
}
// @from(Start 10023529, End 10023745)
function vD5(A, Q) {
  if (!GKA(A, pMA) && !GKA(A, cMA)) Q.addNotification?.({
    key: "error-compacting-conversation",
    text: "Error compacting conversation",
    priority: "immediate",
    color: "error"
  })
}
// @from(Start 10023746, End 10024431)
async function bD5(A, Q, B) {
  let G = Object.entries(A).map(([Y, J]) => ({
      filename: Y,
      ...J
    })).filter((Y) => !hD5(Y.filename, Q.agentId)).sort((Y, J) => J.timestamp - Y.timestamp).slice(0, B),
    Z = await Promise.all(G.map(async (Y) => {
      let J = await VQ0(Y.filename, {
        ...Q,
        fileReadingLimits: {
          maxTokens: yD5
        }
      }, "tengu_post_compact_file_restore_success", "tengu_post_compact_file_restore_error", "compact");
      return J ? l9(J) : null
    })),
    I = 0;
  return Z.filter((Y) => {
    if (Y === null) return !1;
    let J = gG(JSON.stringify(Y));
    if (I + J <= kD5) return I += J, !0;
    return !1
  })
}
// @from(Start 10024433, End 10024610)
function fD5(A) {
  let Q = Nh(A);
  if (Q.length === 0) return null;
  return l9({
    type: "todo",
    content: Q,
    itemCount: Q.length,
    context: "post-compact"
  })
}
// @from(Start 10024612, End 10024780)
function XQ0(A) {
  let Q = xU(A);
  if (!Q) return null;
  let B = yU(A);
  return l9({
    type: "plan_file_reference",
    planFilePath: B,
    planContent: Q
  })
}
// @from(Start 10024782, End 10025057)
function hD5(A, Q) {
  let B = Pl(A);
  try {
    let G = Pl(Ri(Q));
    if (B === G) return !0
  } catch {}
  try {
    let G = Pl(yU(Q));
    if (B === G) return !0
  } catch {}
  try {
    if (new Set(_I2.map((Z) => Pl(Gt(Z)))).has(B)) return !0
  } catch {}
  return !1
}
// @from(Start 10025062, End 10025069)
_D5 = 5
// @from(Start 10025073, End 10025084)
kD5 = 50000
// @from(Start 10025088, End 10025098)
yD5 = 5000
// @from(Start 10025102, End 10025141)
cMA = "Not enough messages to compact."
// @from(Start 10025145, End 10025230)
xD5 = "Conversation too long. Press esc twice to go up a few messages and try again."
// @from(Start 10025234, End 10025273)
pMA = "API Error: Request was aborted."
// @from(Start 10025279, End 10025476)
lMA = L(() => {
  fZ();
  ZO();
  cQ();
  q0();
  RZ();
  GO();
  Dq();
  vM();
  IQ0();
  t2();
  IO();
  Ti();
  jQ();
  NE();
  R9();
  JQ0();
  xM();
  vI2();
  g1();
  YO();
  k1A();
  _0()
})
// @from(Start 10025479, End 10025510)
function hI2() {
  return fI2
}
// @from(Start 10025512, End 10025541)
function gI2(A) {
  fI2 = A
}
// @from(Start 10025543, End 10025580)
function uI2() {
  _91 = Date.now()
}
// @from(Start 10025582, End 10025615)
function mI2() {
  _91 = void 0
}
// @from(Start 10025616, End 10025810)
async function dI2() {
  let A = Date.now();
  while (_91) {
    if (Date.now() - _91 > uD5) return;
    if (Date.now() - A > gD5) return;
    await new Promise((B) => setTimeout(B, 1000))
  }
}
// @from(Start 10025812, End 10025954)
function cI2() {
  let A = RA(),
    Q = k91();
  if (!A.existsSync(Q)) return null;
  return A.readFileSync(Q, {
    encoding: "utf-8"
  })
}
// @from(Start 10025959, End 10025970)
gD5 = 15000
// @from(Start 10025974, End 10025985)
uD5 = 60000
// @from(Start 10025989, End 10025992)
fI2
// @from(Start 10025994, End 10025997)
_91
// @from(Start 10026003, End 10026036)
KQ0 = L(() => {
  AQ();
  EJ()
})
// @from(Start 10026039, End 10026213)
function lD5(A, Q) {
  if (!Q.some((G) => G.type === "assistant") && !CQ0.has(A)) {
    if (BZ("cc_microcompact_ext", "mc_disabled", !1)) CQ0.add(A)
  }
  return CQ0.has(A)
}
// @from(Start 10026215, End 10026479)
function iI2(A) {
  if (!A.content) return 0;
  if (typeof A.content === "string") return gG(A.content);
  return A.content.reduce((Q, B) => {
    if (B.type === "text") return Q + gG(B.text);
    else if (B.type === "image") return Q + lI2;
    return Q
  }, 0)
}
// @from(Start 10026481, End 10026583)
function iD5(A, Q) {
  let B = pI2.get(A);
  if (B === void 0) B = iI2(Q), pI2.set(A, B);
  return B
}
// @from(Start 10026585, End 10027017)
function EQ0(A) {
  let Q = 0;
  for (let B of A) {
    if (B.type !== "user" && B.type !== "assistant") continue;
    if (!Array.isArray(B.message.content)) continue;
    for (let G of B.message.content)
      if (G.type === "text") Q += gG(G.text);
      else if (G.type === "tool_result") Q += iI2(G);
    else if (G.type === "image") Q += lI2;
    else Q += gG(JSON.stringify(G))
  }
  return Math.ceil(Q * 1.3333333333333333)
}
// @from(Start 10027019, End 10027109)
function nD5(A) {
  return y91.push(A), () => {
    y91 = y91.filter((Q) => Q !== A)
  }
}
// @from(Start 10027111, End 10027155)
function aD5() {
  y91.forEach((A) => A())
}
// @from(Start 10027156, End 10030129)
async function Si(A, Q, B) {
  if (x91 = !1, Y0(process.env.DISABLE_MICROCOMPACT)) return {
    messages: A
  };
  if (lD5(e1(), A)) return {
    messages: A
  };
  Y0(process.env.USE_API_CONTEXT_MANAGEMENT);
  let G = Q !== void 0,
    Z = G ? Q : dD5,
    I = [],
    Y = new Map;
  for (let D of A)
    if ((D.type === "user" || D.type === "assistant") && Array.isArray(D.message.content)) {
      for (let H of D.message.content)
        if (H.type === "tool_use" && pD5.has(H.name)) {
          if (!DQ0.has(H.id)) I.push(H.id)
        } else if (H.type === "tool_result" && I.includes(H.tool_use_id)) {
        let C = iD5(H.tool_use_id, H);
        Y.set(H.tool_use_id, C)
      }
    } let J = I.slice(-cD5),
    W = Array.from(Y.values()).reduce((D, H) => D + H, 0),
    X = 0,
    V = new Set;
  for (let D of I) {
    if (J.includes(D)) continue;
    if (W - X > Z) V.add(D), X += Y.get(D) || 0
  }
  if (!G) {
    let D = ZK(A);
    if (!x1A(D).isAboveWarningThreshold || X < mD5) V.clear(), X = 0
  }
  let F = (D) => {
    return DQ0.has(D) || V.has(D)
  };
  if (V.size > 0, V.size > 0) A.filter((H) => H && H.type === "attachment" && H.attachment.type === "memory" && !HQ0.has(H.uuid)).map((H) => ({
    uuid: H.uuid
  })).forEach((H) => HQ0.add(H.uuid));
  let K = [];
  for (let D of A) {
    if (D.type === "attachment" && HQ0.has(D.uuid)) continue;
    if (D.type !== "user" && D.type !== "assistant") {
      K.push(D);
      continue
    }
    if (!Array.isArray(D.message.content)) {
      K.push(D);
      continue
    }
    if (D.type === "user") {
      let H = [];
      for (let C of D.message.content)
        if (C.type === "tool_result" && F(C.tool_use_id)) H.push({
          ...C,
          content: "[Old tool result content cleared]"
        });
        else H.push(C);
      if (H.length > 0) K.push({
        ...D,
        message: {
          ...D.message,
          content: H
        }
      })
    } else {
      let H = [];
      for (let C of D.message.content) H.push(C);
      K.push({
        ...D,
        message: {
          ...D.message,
          content: H
        }
      })
    }
  }
  if (B && V.size > 0) {
    let D = new Map,
      H = new Set;
    for (let C of A)
      if ((C.type === "user" || C.type === "assistant") && Array.isArray(C.message.content)) {
        for (let E of C.message.content)
          if (E.type === "tool_use" && E.name === d5) {
            let U = E.input?.file_path;
            if (typeof U === "string")
              if (V.has(E.id)) D.set(U, E.id);
              else H.add(U)
          }
      } for (let [C] of D)
      if (!H.has(C)) B.readFileState.delete(C)
  }
  for (let D of V) DQ0.add(D);
  if (V.size > 0) return GA("tengu_microcompact", {
    toolsCompacted: V.size,
    totalUncompactedTokens: W,
    tokensAfterCompaction: W - X,
    tokensSaved: X,
    triggerType: G ? "manual" : "auto"
  }), x91 = !0, aD5(), {
    messages: K
  };
  return {
    messages: K
  }
}
// @from(Start 10030131, End 10030269)
function nI2() {
  let [A, Q] = v91.useState(x91);
  return v91.useEffect(() => {
    return nD5(() => {
      Q(x91)
    })
  }, []), A
}
// @from(Start 10030274, End 10030277)
v91
// @from(Start 10030279, End 10030290)
mD5 = 20000
// @from(Start 10030294, End 10030305)
dD5 = 40000
// @from(Start 10030309, End 10030316)
cD5 = 3
// @from(Start 10030320, End 10030330)
lI2 = 2000
// @from(Start 10030334, End 10030337)
pD5
// @from(Start 10030339, End 10030342)
DQ0
// @from(Start 10030344, End 10030347)
HQ0
// @from(Start 10030349, End 10030352)
pI2
// @from(Start 10030354, End 10030357)
CQ0
// @from(Start 10030359, End 10030367)
x91 = !1
// @from(Start 10030371, End 10030374)
y91
// @from(Start 10030380, End 10030637)
y1A = L(() => {
  xM();
  u2();
  q0();
  hQ();
  _0();
  cQ();
  GO();
  v1A();
  wF();
  yR();
  c9A();
  YS();
  v91 = BA(VA(), 1), pD5 = new Set([d5, C9, xY, iK, WS, $X, $5, wX]), DQ0 = new Set, HQ0 = new Set, pI2 = new Map, CQ0 = new Set;
  y91 = []
})
// @from(Start 10030639, End 10030675)
async function b91() {
  return !1
}
// @from(Start 10030677, End 10031081)
function sD5(A, Q, B, G) {
  let Z = ZK(A),
    I = S91("auto", Z ?? 0),
    Y = [R0({
      content: T91(Q, !0),
      isCompactSummary: !0,
      isVisibleInTranscriptOnly: !0
    })],
    J = XQ0(G);
  return {
    boundaryMarker: I,
    summaryMessages: Y,
    attachments: J ? [J] : [],
    hookResults: [],
    messagesToKeep: B,
    preCompactTokenCount: Z,
    postCompactTokenCount: EQ0(Y)
  }
}
// @from(Start 10031082, End 10031727)
async function f91(A, Q, B) {
  if (!await b91()) return null;
  await dI2();
  let G = hI2(),
    Z = cI2();
  if (!G || !Z) return null;
  try {
    let I = A.findIndex((V) => V.uuid === G);
    if (I === -1) return null;
    let Y = A.slice(I + 1),
      J = sD5(A, Z, Y, Q),
      W = [J.boundaryMarker, ...J.summaryMessages, ...J.attachments, ...J.hookResults, ...Y],
      X = EQ0(W);
    if (B !== void 0 && X >= B) return GA("tengu_sm_compact_threshold_exceeded", {
      postCompactTokenCount: X,
      autoCompactThreshold: B
    }), null;
    return {
      ...J,
      postCompactTokenCount: X
    }
  } catch {
    return null
  }
}
// @from(Start 10031732, End 10031808)
h91 = L(() => {
  lMA();
  GO();
  cQ();
  KQ0();
  u2();
  q0();
  y1A()
})
// @from(Start 10031811, End 10031880)
function TYA() {
  let A = k3(),
    Q = UQ0(A);
  return su(A) - Q
}
// @from(Start 10031882, End 10032157)
function aI2() {
  let A = TYA(),
    Q = A - zQ0,
    B = process.env.CLAUDE_AUTOCOMPACT_PCT_OVERRIDE;
  if (B) {
    let G = parseFloat(B);
    if (!isNaN(G) && G > 0 && G <= 100) {
      let Z = Math.floor(A * (G / 100));
      return Math.min(Z, Q)
    }
  }
  return Q
}
// @from(Start 10032159, End 10032497)
function x1A(A) {
  let Q = aI2(),
    B = b1A() ? Q : TYA(),
    G = Math.max(0, Math.round((B - A) / B * 100)),
    Z = B - rD5,
    I = B - oD5,
    Y = A >= Z,
    J = A >= I,
    W = b1A() && A >= Q;
  return {
    percentLeft: G,
    isAboveWarningThreshold: Y,
    isAboveErrorThreshold: J,
    isAboveAutoCompactThreshold: W
  }
}
// @from(Start 10032499, End 10032550)
function b1A() {
  return N1().autoCompactEnabled
}
// @from(Start 10032551, End 10032732)
async function tD5(A, Q) {
  if (Q === "session_memory") return !1;
  if (!b1A()) return !1;
  let B = ZK(A),
    {
      isAboveAutoCompactThreshold: G
    } = x1A(B);
  return G
}
// @from(Start 10032733, End 10033246)
async function sI2(A, Q, B) {
  if (Y0(process.env.DISABLE_COMPACT)) return {
    wasCompacted: !1
  };
  if (!await tD5(A, B)) return {
    wasCompacted: !1
  };
  let Z = await f91(A, Q.agentId, aI2());
  if (Z) return {
    wasCompacted: !0,
    compactionResult: Z
  };
  try {
    return {
      wasCompacted: !0,
      compactionResult: await j91(A, Q, !0, void 0, !0)
    }
  } catch (I) {
    if (!GKA(I, pMA)) AA(I instanceof Error ? I : Error(String(I)));
    return {
      wasCompacted: !1
    }
  }
}
// @from(Start 10033251, End 10033262)
zQ0 = 13000
// @from(Start 10033266, End 10033277)
rD5 = 20000
// @from(Start 10033281, End 10033292)
oD5 = 20000
// @from(Start 10033298, End 10033389)
v1A = L(() => {
  GO();
  lMA();
  g1();
  jQ();
  RZ();
  t2();
  fZ();
  hQ();
  h91()
})
// @from(Start 10033539, End 10033608)
function tI2(A) {
  let Q = W0();
  return QH5(Q, BH5, `${A}.json`)
}
// @from(Start 10033610, End 10033860)
function $Q0(A) {
  let Q = tI2(A);
  if (!rI2(Q)) return [];
  try {
    let B = eD5(Q, "utf-8");
    return JSON.parse(B)
  } catch (B) {
    return g(`Failed to read mailbox for ${A}: ${B}`), AA(B instanceof Error ? B : Error(String(B))), []
  }
}
// @from(Start 10033862, End 10033920)
function eI2(A) {
  return $Q0(A).filter((B) => !B.read)
}
// @from(Start 10033922, End 10034463)
function AY2(A) {
  let Q = tI2(A);
  if (!rI2(Q)) return;
  let B = `${Q}.lock`,
    G;
  try {
    G = oI2.lockSync(Q, {
      lockfilePath: B
    });
    let Z = $Q0(A);
    if (Z.length === 0) return;
    let I = Z.map((Y) => ({
      ...Y,
      read: !0
    }));
    AH5(Q, JSON.stringify(I, null, 2), "utf-8"), g(`[TeammateMailbox] Marked ${Z.length} message(s) as read for ${A}`)
  } catch (Z) {
    g(`Failed to mark messages as read for ${A}: ${Z}`), AA(Z instanceof Error ? Z : Error(String(Z)))
  } finally {
    if (G) G()
  }
}
// @from(Start 10034465, End 10034593)
function QY2(A) {
  return A.map((Q) => `<teammate-message teammate_id="${Q.from}">
${Q.text}
</teammate-message>`).join(`

`)
}
// @from(Start 10034598, End 10034601)
oI2
// @from(Start 10034603, End 10034626)
BH5 = ".claude/mailbox"
// @from(Start 10034632, End 10034695)
g91 = L(() => {
  U2();
  g1();
  V0();
  oI2 = BA(T4A(), 1)
})
// @from(Start 10034823, End 10036370)
async function JH5(A, Q, B, G, Z, I) {
  if (Y0(process.env.CLAUDE_CODE_DISABLE_ATTACHMENTS)) return [];
  let Y = o9();
  setTimeout(() => {
    Y.abort()
  }, 1000);
  let J = {
      ...Q,
      abortController: Y
    },
    W = Q.agentId === e1(),
    X = A ? [aY("at_mentioned_files", () => zH5(A, J)), aY("mcp_resources", () => $H5(A, J)), aY("agent_mentions", () => Promise.resolve(UH5(A, Q.options.agentDefinitions.activeAgents)))] : [],
    V = await Promise.all(X),
    F = [aY("changed_files", () => wH5(J)), aY("nested_memory", () => qH5(J)), aY("ultra_claude_md", async () => DH5(Z)), aY("plan_mode", () => VH5(Z, Q)), aY("todo_reminders", () => _H5(Z, Q)), aY("teammate_mailbox", async () => vH5(Q)), aY("critical_system_reminder", () => Promise.resolve(FH5(Q)))],
    K = W ? [aY("ide_selection", async () => HH5(B, Q)), aY("ide_opened_file", async () => EH5(B, Q)), aY("output_style", async () => Promise.resolve(KH5())), aY("queued_commands", async () => WH5(G)), aY("diagnostics", async () => PH5()), aY("lsp_diagnostics", async () => jH5()), aY("background_shells", async () => yH5(Q)), aY("background_remote_sessions", async () => kH5(Q)), aY("async_hook_responses", async () => xH5()), aY("memory", async () => EI2(Q, Z, I)), aY("token_usage", async () => Promise.resolve(bH5(Z ?? []))), aY("budget_usd", async () => Promise.resolve(fH5(Q.options.maxBudgetUsd))), aY("async_agents", async () => hH5(Q))] : [],
    [D, H] = await Promise.all([Promise.all(F), Promise.all(K)]);
  return [...V.flat(), ...D.flat(), ...H.flat()]
}
// @from(Start 10036371, End 10036999)
async function aY(A, Q) {
  let B = Date.now();
  try {
    let G = await Q(),
      Z = Date.now() - B,
      I = G.reduce((Y, J) => {
        return Y + JSON.stringify(J).length
      }, 0);
    if (Math.random() < 0.05) GA("tengu_attachment_compute_duration", {
      label: A,
      duration_ms: Z,
      attachment_size_bytes: I,
      attachment_count: G.length
    });
    return G
  } catch (G) {
    let Z = Date.now() - B;
    if (Math.random() < 0.05) GA("tengu_attachment_compute_duration", {
      label: A,
      duration_ms: Z,
      error: !0
    });
    return AA(G), uN(`Attachment error in ${A}`, G), []
  }
}
// @from(Start 10037001, End 10037180)
function WH5(A) {
  if (!A) return [];
  return A.filter((Q) => Q.mode === "prompt").map((Q) => ({
    type: "queued_command",
    prompt: Q.value,
    source_uuid: Q.uuid
  }))
}
// @from(Start 10037182, End 10037588)
function XH5(A) {
  let Q = 0,
    B = !1;
  for (let G = A.length - 1; G >= 0; G--) {
    let Z = A[G];
    if (Z?.type === "assistant") {
      if (NQ0(Z)) continue;
      Q++
    } else if (Z?.type === "attachment" && (Z.attachment.type === "plan_mode" || Z.attachment.type === "plan_mode_reentry")) {
      B = !0;
      break
    }
  }
  return {
    turnCount: Q,
    foundPlanModeAttachment: B
  }
}
// @from(Start 10037589, End 10038153)
async function VH5(A, Q) {
  if ((await Q.getAppState()).toolPermissionContext.mode !== "plan") return [];
  if (A && A.length > 0) {
    let {
      turnCount: J,
      foundPlanModeAttachment: W
    } = XH5(A);
    if (W && J < IH5.TURNS_BETWEEN_ATTACHMENTS) return []
  }
  let Z = yU(Q.agentId),
    I = xU(Q.agentId),
    Y = [];
  if (Jz0() && I !== null) Y.push({
    type: "plan_mode_reentry",
    planFilePath: Z
  }), ou(!1);
  return Y.push({
    type: "plan_mode",
    isSubAgent: Q.isSubAgent,
    planFilePath: Z,
    planExists: I !== null
  }), Y
}
// @from(Start 10038155, End 10038314)
function FH5(A) {
  let Q = A.criticalSystemReminder_EXPERIMENTAL;
  if (!Q) return [];
  return [{
    type: "critical_system_reminder",
    content: Q
  }]
}
// @from(Start 10038316, End 10038466)
function KH5() {
  let Q = l0()?.outputStyle || "default";
  if (Q === "default") return [];
  return [{
    type: "output_style",
    style: Q
  }]
}
// @from(Start 10038468, End 10038499)
function DH5(A) {
  return []
}
// @from(Start 10038500, End 10038917)
async function HH5(A, Q) {
  let B = kQ1(Q.options.mcpClients);
  if (!B || A?.lineStart === void 0 || !A.text || !A.filePath) return [];
  let G = await Q.getAppState();
  if (PYA(A.filePath, G.toolPermissionContext)) return [];
  return [{
    type: "selected_lines_in_ide",
    ideName: B,
    lineStart: A.lineStart,
    lineEnd: A.lineStart + A.lineCount - 1,
    filename: A.filePath,
    content: A.text
  }]
}
// @from(Start 10038919, End 10039239)
function CH5(A, Q) {
  let B = wQ0(GH5(A)),
    G = [],
    Z = B;
  while (Z !== Q && Z !== BY2(Z).root) {
    if (Z.startsWith(Q)) G.push(Z);
    Z = wQ0(Z)
  }
  G.reverse();
  let I = [];
  Z = Q;
  while (Z !== BY2(Z).root) I.push(Z), Z = wQ0(Z);
  return I.reverse(), {
    nestedDirs: G,
    cwdLevelDirs: I
  }
}
// @from(Start 10039241, End 10039563)
function qQ0(A, Q) {
  let B = [];
  for (let G of A)
    if (!Q.readFileState.has(G.path)) B.push({
      type: "nested_memory",
      path: G.path,
      content: G
    }), Q.readFileState.set(G.path, {
      content: G.content,
      timestamp: Date.now(),
      offset: void 0,
      limit: void 0
    });
  return B
}
// @from(Start 10039565, End 10040028)
function ZY2(A, Q, B) {
  let G = [];
  try {
    if (!qT(A, B.toolPermissionContext)) return G;
    let Z = new Set,
      I = uQ(),
      Y = pZ2(A, Z);
    G.push(...qQ0(Y, Q));
    let {
      nestedDirs: J,
      cwdLevelDirs: W
    } = CH5(A, I);
    for (let X of J) {
      let V = lZ2(X, A, Z);
      G.push(...qQ0(V, Q))
    }
    for (let X of W) {
      let V = iZ2(X, A, Z);
      G.push(...qQ0(V, Q))
    }
  } catch (Z) {
    AA(Z)
  }
  return G
}
// @from(Start 10040029, End 10040290)
async function EH5(A, Q) {
  if (!A?.filePath || A.text) return [];
  let B = await Q.getAppState();
  if (PYA(A.filePath, B.toolPermissionContext)) return [];
  return [...ZY2(A.filePath, Q, B), {
    type: "opened_file_in_ide",
    filename: A.filePath
  }]
}
// @from(Start 10040291, End 10041369)
async function zH5(A, Q) {
  let B = NH5(A),
    G = await Q.getAppState();
  return (await Promise.all(B.map(async (I) => {
    try {
      let {
        filename: Y,
        lineStart: J,
        lineEnd: W
      } = OH5(I), X = b9(Y);
      if (PYA(X, G.toolPermissionContext)) return null;
      try {
        if (RA().statSync(X).isDirectory()) try {
          let F = await D9.call({
            command: `ls ${z8([X])}`,
            description: `Lists files in ${X}`
          }, Q);
          GA("tengu_at_mention_extracting_directory_success", {});
          let K = F.data.stdout;
          return {
            type: "directory",
            path: X,
            content: K
          }
        } catch {
          return null
        }
      } catch {}
      return await VQ0(X, Q, "tengu_at_mention_extracting_filename_success", "tengu_at_mention_extracting_filename_error", "at-mention", {
        offset: J,
        limit: W && J ? W - J + 1 : void 0
      })
    } catch {
      GA("tengu_at_mention_extracting_filename_error", {})
    }
  }))).filter(Boolean)
}
// @from(Start 10041371, End 10041768)
function UH5(A, Q) {
  let B = MH5(A);
  if (B.length === 0) return [];
  return B.map((Z) => {
    let I = Z.replace("agent-", ""),
      Y = Q.find((J) => J.agentType === I);
    if (!Y) return GA("tengu_at_mention_agent_not_found", {}), null;
    return GA("tengu_at_mention_agent_success", {}), {
      type: "agent_mention",
      agentType: Y.agentType
    }
  }).filter((Z) => Z !== null)
}
// @from(Start 10041769, End 10042913)
async function $H5(A, Q) {
  let B = LH5(A);
  if (B.length === 0) return [];
  let G = Q.options.mcpClients || [];
  return (await Promise.all(B.map(async (I) => {
    try {
      let [Y, ...J] = I.split(":"), W = J.join(":");
      if (!Y || !W) return GA("tengu_at_mention_mcp_resource_error", {}), null;
      let X = G.find((K) => K.name === Y);
      if (!X || X.type !== "connected") return GA("tengu_at_mention_mcp_resource_error", {}), null;
      let F = (Q.options.mcpResources?.[Y] || []).find((K) => K.uri === W);
      if (!F) return GA("tengu_at_mention_mcp_resource_error", {}), null;
      try {
        let K = await X.client.readResource({
          uri: W
        });
        return GA("tengu_at_mention_mcp_resource_success", {}), {
          type: "mcp_resource",
          server: Y,
          uri: W,
          name: F.name || W,
          description: F.description,
          content: K
        }
      } catch (K) {
        return GA("tengu_at_mention_mcp_resource_error", {}), AA(K), null
      }
    } catch {
      return GA("tengu_at_mention_mcp_resource_error", {}), null
    }
  }))).filter((I) => I !== null)
}
// @from(Start 10042914, End 10044320)
async function wH5(A) {
  let Q = await A.getAppState();
  return (await Promise.all(_l(A.readFileState).map(async (G) => {
    let Z = A.readFileState.get(G);
    if (!Z) return null;
    if (Z.offset !== void 0 || Z.limit !== void 0) return null;
    let I = b9(G);
    if (PYA(I, Q.toolPermissionContext)) return null;
    try {
      if (PD(I) <= Z.timestamp) return null;
      let Y = {
        file_path: I
      };
      if (!(await n8.validateInput(Y, A)).result) return null;
      let W = await n8.call(Y, A);
      if (I === Ri(A.agentId)) {
        let X = Nh(A.agentId);
        return {
          type: "todo",
          content: X,
          itemCount: X.length,
          context: "file-watch"
        }
      }
      if (W.data.type === "text") {
        if (l00(Z.content, W.data.file.content) === "") return null;
        return {
          type: "edited_text_file",
          filename: I,
          snippet: l00(Z.content, W.data.file.content)
        }
      }
      if (W.data.type === "image") try {
        let X = await Vo1(I);
        return {
          type: "edited_image_file",
          filename: I,
          content: X
        }
      } catch (X) {
        return AA(X), GA("tengu_watched_file_compression_failed", {
          file: I
        }), null
      }
    } catch {
      return GA("tengu_watched_file_stat_error", {}), null
    }
  }))).filter((G) => G !== null)
}
// @from(Start 10044321, End 10044645)
async function qH5(A) {
  let Q = await A.getAppState(),
    B = [];
  if (A.nestedMemoryAttachmentTriggers && A.nestedMemoryAttachmentTriggers.size > 0) {
    for (let G of A.nestedMemoryAttachmentTriggers) {
      let Z = ZY2(G, A, Q);
      B.push(...Z)
    }
    A.nestedMemoryAttachmentTriggers.clear()
  }
  return B
}
// @from(Start 10044647, End 10044978)
function NH5(A) {
  let Q = /(^|\s)@"([^"]+)"/g,
    B = /(^|\s)@([^\s]+)\b/g,
    G = [],
    Z = [],
    I;
  while ((I = Q.exec(A)) !== null)
    if (I[2]) G.push(I[2]);
  return (A.match(B) || []).forEach((J) => {
    let W = J.slice(J.indexOf("@") + 1);
    if (!W.startsWith('"')) Z.push(W)
  }), [...new Set([...G, ...Z])]
}
// @from(Start 10044980, End 10045129)
function LH5(A) {
  let Q = /(^|\s)@([^\s]+:[^\s]+)\b/g,
    B = A.match(Q) || [];
  return [...new Set(B.map((G) => G.slice(G.indexOf("@") + 1)))]
}
// @from(Start 10045131, End 10045280)
function MH5(A) {
  let Q = /(^|\s)@(agent-[\w:.@-]+)/g,
    B = A.match(Q) || [];
  return [...new Set(B.map((G) => G.slice(G.indexOf("@") + 1)))]
}
// @from(Start 10045282, End 10045552)
function OH5(A) {
  let Q = A.match(/^([^#]+)(?:#L(\d+)(?:-(\d+))?)?$/);
  if (!Q) return {
    filename: A
  };
  let [, B, G, Z] = Q, I = G ? parseInt(G, 10) : void 0, Y = Z ? parseInt(Z, 10) : I;
  return {
    filename: B ?? A,
    lineStart: I,
    lineEnd: Y
  }
}
// @from(Start 10045554, End 10045838)
function RH5(A) {
  let Q = 0,
    B = !1;
  for (let G = A.length - 1; G >= 0; G--) {
    let Z = A[G];
    if (Z?.type === "attachment" && Z.attachment.type === "ultramemory") {
      B = !0;
      break
    }
    if (Z?.type === "assistant") Q += TeB(Z)
  }
  return B ? Q : null
}
// @from(Start 10045840, End 10045978)
function TH5(A) {
  if (!A || A.length === 0) return !0;
  let Q = RH5(A);
  if (Q === null) return !0;
  return Q >= YH5.TOKEN_COOLDOWN
}
// @from(Start 10045979, End 10046146)
async function PH5() {
  let A = await Oh.getNewDiagnostics();
  if (A.length === 0) return [];
  return [{
    type: "diagnostics",
    files: A,
    isNew: !0
  }]
}
// @from(Start 10046147, End 10046832)
async function jH5() {
  g("LSP Diagnostics: getLSPDiagnosticAttachments called");
  try {
    let A = NI2();
    if (A.length === 0) return [];
    g(`LSP Diagnostics: Found ${A.length} pending diagnostic set(s)`);
    let Q = A.map(({
      files: B
    }) => ({
      type: "diagnostics",
      files: B,
      isNew: !0
    }));
    if (A.length > 0) LI2(), g(`LSP Diagnostics: Cleared ${A.length} delivered diagnostic(s) from registry`);
    return g(`LSP Diagnostics: Returning ${Q.length} diagnostic attachment(s)`), Q
  } catch (A) {
    let Q = A instanceof Error ? A : Error(String(A));
    return AA(Error(`Failed to get LSP diagnostic attachments: ${Q.message}`)), []
  }
}
// @from(Start 10046833, End 10047051)
async function* jYA(A, Q, B, G, Z, I) {
  let Y = await JH5(A, Q, B, G, Z, I);
  if (Y.length === 0) return;
  GA("tengu_attachments", {
    attachment_types: Y.map((J) => J.type)
  });
  for (let J of Y) yield l9(J)
}
// @from(Start 10047052, End 10048956)
async function VQ0(A, Q, B, G, Z, I) {
  let {
    offset: Y,
    limit: J
  } = I ?? {}, W = await Q.getAppState();
  if (PYA(A, W.toolPermissionContext)) return null;
  if (Z === "at-mention" && !Y01(A)) try {
    let V = RA().statSync(A);
    return GA("tengu_attachment_file_too_large", {
      size_bytes: V.size,
      mode: Z
    }), null
  } catch {}
  let X = Q.readFileState.get(A);
  if (X && Z === "at-mention") try {
    let V = PD(A);
    if (X.timestamp <= V && V === X.timestamp) return GA(B, {}), {
      type: "already_read_file",
      filename: A,
      content: {
        type: "text",
        file: {
          filePath: A,
          content: X.content,
          numLines: X.content.split(`
`).length,
          startLine: Y ?? 1,
          totalLines: X.content.split(`
`).length
        }
      }
    }
  } catch {}
  try {
    let V = {
      file_path: A,
      offset: Y,
      limit: J
    };
    async function F() {
      if (Z === "compact") return {
        type: "compact_file_reference",
        filename: A
      };
      let D = await Q.getAppState();
      if (PYA(A, D.toolPermissionContext)) return null;
      try {
        let H = {
            file_path: A,
            offset: Y ?? 1,
            limit: NKA
          },
          C = await n8.call(H, Q);
        return GA(B, {}), {
          type: "file",
          filename: A,
          content: C.data,
          truncated: !0
        }
      } catch {
        return GA(G, {}), null
      }
    }
    let K = await n8.validateInput(V, Q);
    if (!K.result) {
      if (K.meta?.fileSize) return await F();
      return null
    }
    try {
      let D = await n8.call(V, Q);
      return GA(B, {}), {
        type: "file",
        filename: A,
        content: D.data
      }
    } catch (D) {
      if (D instanceof Z01) return await F();
      throw D
    }
  } catch {
    return GA(G, {}), null
  }
}
// @from(Start 10048958, End 10049091)
function l9(A) {
  return {
    attachment: A,
    type: "attachment",
    uuid: ZH5(),
    timestamp: new Date().toISOString()
  }
}
// @from(Start 10049093, End 10049716)
function SH5(A) {
  let Q = -1,
    B = -1,
    G = 0,
    Z = 0;
  for (let I = A.length - 1; I >= 0; I--) {
    let Y = A[I];
    if (Y?.type === "assistant") {
      if (NQ0(Y)) continue;
      if (Q === -1) G++;
      if (B === -1) Z++;
      if (Q === -1 && "message" in Y && Array.isArray(Y.message?.content) && Y.message.content.some((J) => J.type === "tool_use" && J.name === "TodoWrite")) Q = I
    } else if (B === -1 && Y?.type === "attachment" && Y.attachment.type === "todo_reminder") B = I;
    if (Q !== -1 && B !== -1) break
  }
  return {
    turnsSinceLastTodoWrite: G,
    turnsSinceLastReminder: Z
  }
}
// @from(Start 10049717, End 10050077)
async function _H5(A, Q) {
  if (!A || A.length === 0) return [];
  let {
    turnsSinceLastTodoWrite: B,
    turnsSinceLastReminder: G
  } = SH5(A);
  if (B >= GY2.TURNS_SINCE_WRITE && G >= GY2.TURNS_BETWEEN_REMINDERS) {
    let Z = Nh(Q.agentId);
    return [{
      type: "todo_reminder",
      content: Z,
      itemCount: Z.length
    }]
  }
  return []
}
// @from(Start 10050078, End 10050786)
async function kH5(A) {
  if (!o2("tengu_web_tasks")) return [];
  let Q = await A.getAppState(),
    B = Object.values(Q.backgroundTasks).filter((Z) => Z.type === "remote_session" && Z.deltaSummarySinceLastFlushToAttachment !== null),
    G = B.map((Z) => ({
      type: "background_remote_session_status",
      taskId: Z.id,
      title: Z.title,
      status: Z.status,
      deltaSummarySinceLastFlushToAttachment: Z.deltaSummarySinceLastFlushToAttachment
    }));
  return A.setAppState((Z) => ({
    ...Z,
    backgroundTasks: {
      ...Z.backgroundTasks,
      ...Object.fromEntries(B.map((I) => [I.id, {
        ...I,
        deltaSummarySinceLastFlushToAttachment: null
      }]))
    }
  })), G
}
// @from(Start 10050787, End 10051580)
async function yH5(A) {
  let Q = await A.getAppState(),
    B = Object.values(Q.backgroundTasks).filter((I) => I.type === "shell"),
    G = QA2(B).filter((I) => I.hasNewOutput).map((I) => ({
      type: "background_shell_status",
      taskId: I.id,
      command: I.command,
      status: "running",
      hasNewOutput: I.hasNewOutput
    })),
    Z = BA2(B).map((I) => ({
      type: "background_shell_status",
      taskId: I.id,
      command: I.command,
      status: I.status,
      exitCode: I.result?.code,
      hasNewOutput: Ko1(I)
    }));
  return A.setAppState((I) => ({
    ...I,
    backgroundTasks: {
      ...I.backgroundTasks,
      ...Object.fromEntries(B.map((Y) => [Y.id, {
        ...Y,
        completionStatusSentInAttachment: !0
      }]))
    }
  })), [...G, ...Z]
}
// @from(Start 10051581, End 10052403)
async function xH5() {
  let A = await bZ2();
  if (A.length === 0) return [];
  g(`Hooks: getAsyncHookResponseAttachments found ${A.length} responses`);
  let Q = A.map(({
    processId: B,
    response: G,
    hookName: Z,
    hookEvent: I,
    toolName: Y,
    stdout: J,
    stderr: W,
    exitCode: X
  }) => {
    return g(`Hooks: Creating attachment for ${B} (${Z}): ${JSON.stringify(G)}`), {
      type: "async_hook_response",
      processId: B,
      hookName: Z,
      hookEvent: I,
      toolName: Y,
      response: G,
      stdout: J,
      stderr: W,
      exitCode: X
    }
  });
  if (A.length > 0) {
    let B = A.map((G) => G.processId);
    fZ2(B), g(`Hooks: Removed ${B.length} delivered hooks from registry`)
  }
  return g(`Hooks: getAsyncHookResponseAttachments found ${Q.length} attachments`), Q
}
// @from(Start 10052405, End 10052919)
function vH5(A) {
  let Q = e1(),
    B = process.env.CLAUDE_CODE_TEAMMATE_ID || Q;
  g(`[TeammateMailbox] Checking mailbox for teammate=${B} session=${Q}`);
  let G = eI2(B);
  if (g(`[TeammateMailbox] Found ${G.length} message(s) in mailbox`), G.length === 0) return [];
  return g(`[TeammateMailbox] Returning ${G.length} unread message(s) as attachment`), AY2(B), [{
    type: "teammate_mailbox",
    messages: G.map((Z) => ({
      from: Z.from,
      text: Z.text,
      timestamp: Z.timestamp
    }))
  }]
}
// @from(Start 10052921, End 10053139)
function bH5(A) {
  if (!Y0(process.env.CLAUDE_CODE_ENABLE_TOKEN_USAGE_ATTACHMENT)) return [];
  let Q = TYA(),
    B = ZK(A);
  return [{
    type: "token_usage",
    used: B,
    total: Q,
    remaining: Q - B
  }]
}
// @from(Start 10053141, End 10053307)
function fH5(A) {
  if (A === void 0) return [];
  let Q = hK(),
    B = A - Q;
  return [{
    type: "budget_usd",
    used: Q,
    total: A,
    remaining: B
  }]
}
// @from(Start 10053308, End 10053997)
async function hH5(A) {
  let Q = await A.getAppState(),
    G = Object.values(Q.backgroundTasks).filter((Z) => Z.type === "async_agent").filter((Z) => Z.status !== "running" && !Z.notified).map((Z) => ({
      type: "async_agent_status",
      agentId: Z.agentId,
      description: Z.description,
      status: Z.status,
      error: Z.error
    }));
  if (G.length > 0) A.setAppState((Z) => {
    let I = {
      ...Z.backgroundTasks
    };
    for (let {
        agentId: Y
      }
      of G) {
      let J = I[Y];
      if (J?.type === "async_agent") I[Y] = {
        ...J,
        notified: !0
      }
    }
    return {
      ...Z,
      backgroundTasks: I
    }
  });
  return G
}
// @from(Start 10053999, End 10054066)
function u91(A) {
  return A.attachment.type === "queued_command"
}
// @from(Start 10054068, End 10054163)
function IY2(A) {
  return A.type === "async_hook_response" && A.hookEvent === "SessionStart"
}
// @from(Start 10054165, End 10054308)
function m91(A) {
  if (A.type !== "hook_success" && A.type !== "hook_non_blocking_error") return !1;
  return A.hookEvent === "SessionStart"
}
// @from(Start 10054310, End 10054375)
function PYA(A, Q) {
  return jD(A, Q, "read", "deny") !== null
}
// @from(Start 10054380, End 10054383)
GY2
// @from(Start 10054385, End 10054388)
IH5
// @from(Start 10054390, End 10054393)
YH5
// @from(Start 10054399, End 10054843)
IO = L(() => {
  q0();
  u2();
  Dq();
  yI();
  AQ();
  Ti();
  NE();
  nY();
  gE();
  g1();
  xM();
  V0();
  R1A();
  MB();
  P1A();
  dK();
  wF();
  vM();
  OZ();
  R9();
  EJ();
  _AA();
  zI2();
  _0();
  pF();
  y00();
  uMA();
  V0();
  cQ();
  hQ();
  GO();
  v1A();
  g91();
  GY2 = {
    TURNS_SINCE_WRITE: 7,
    TURNS_BETWEEN_REMINDERS: 3
  }, IH5 = {
    TURNS_BETWEEN_ATTACHMENTS: 5
  }, YH5 = {
    TOKEN_COOLDOWN: 5000
  }
})
// @from(Start 10054845, End 10054938)
async function YY2(A) {
  let Q;
  do Q = await A.next(); while (!Q.done);
  return Q.value
}
// @from(Start 10054939, End 10055587)
async function* SYA(A, Q = 1 / 0) {
  let B = (I) => {
      let Y = I.next().then(({
        done: J,
        value: W
      }) => ({
        done: J,
        value: W,
        generator: I,
        promise: Y
      }));
      return Y
    },
    G = [...A],
    Z = new Set;
  while (Z.size < Q && G.length > 0) {
    let I = G.shift();
    Z.add(B(I))
  }
  while (Z.size > 0) {
    let {
      done: I,
      value: Y,
      generator: J,
      promise: W
    } = await Promise.race(Z);
    if (Z.delete(W), !I) {
      if (Z.add(B(J)), Y !== void 0) yield Y
    } else if (G.length > 0) {
      let X = G.shift();
      Z.add(B(X))
    }
  }
}
// @from(Start 10055588, End 10055674)
async function d91(A) {
  let Q = [];
  for await (let B of A) Q.push(B);
  return Q
}
// @from(Start 10055675, End 10055728)
async function* LQ0(A) {
  for (let Q of A) yield Q
}
// @from(Start 10055733, End 10055736)
zgG
// @from(Start 10055742, End 10055786)
_i = L(() => {
  zgG = Symbol("NO_VALUE")
})
// @from(Start 10055789, End 10056164)
function f1A({
  param: {
    text: A
  },
  addMargin: Q
}) {
  let B = B9(A, "background-task-input");
  if (!B) return null;
  return Th.createElement(S, {
    flexDirection: "column",
    marginTop: Q ? 1 : 0,
    width: "100%"
  }, Th.createElement(S, null, Th.createElement($, {
    color: "background"
  }, "&"), Th.createElement($, {
    dimColor: !0
  }, " ", B)))
}
// @from(Start 10056169, End 10056171)
Th
// @from(Start 10056177, End 10056230)
MQ0 = L(() => {
  hA();
  cQ();
  Th = BA(VA(), 1)
})
// @from(Start 10056457, End 10056605)
function EG() {
  if (N6()) return dH5();
  return N1().fileCheckpointingEnabled !== !1 && !Y0(process.env.CLAUDE_CODE_DISABLE_FILE_CHECKPOINTING)
}
// @from(Start 10056607, End 10056751)
function dH5() {
  return Y0(process.env.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING) && !Y0(process.env.CLAUDE_CODE_DISABLE_FILE_CHECKPOINTING)
}
// @from(Start 10056752, End 10057774)
async function kYA(A, Q, B) {
  if (!EG()) return;
  A((G) => {
    try {
      let Z = G.snapshots.at(-1);
      if (!Z) return AA(Error("FileHistory: Missing most recent snapshot")), GA("tengu_file_history_track_edit_failed", {}), G;
      let I = DY2(Q);
      if (Z.trackedFileBackups[I]) return G;
      let Y = G.trackedFiles.has(I) ? G.trackedFiles : new Set(G.trackedFiles).add(I),
        W = !RA().existsSync(Q),
        X = W ? OQ0(null, 1) : OQ0(Q, 1),
        V = Yv(Z);
      V.trackedFileBackups[I] = X;
      let F = {
        ...G,
        snapshots: [...G.snapshots.slice(0, -1), V],
        trackedFiles: Y
      };
      return CY2(F), l91(B, V, !0).catch((K) => {
        AA(Error(`FileHistory: Failed to record snapshot: ${K}`))
      }), GA("tengu_file_history_track_edit_success", {
        isNewFile: W,
        version: X.version
      }), g(`FileHistory: Tracked file modification for ${Q}`), F
    } catch (Z) {
      return AA(Z), GA("tengu_file_history_track_edit_failed", {}), G
    }
  })
}
// @from(Start 10057775, End 10059522)
async function yYA(A, Q) {
  if (!EG()) return;
  A((B) => {
    try {
      let G = RA(),
        Z = new Date,
        I = {},
        Y = B.snapshots.at(-1);
      if (Y) {
        g(`FileHistory: Making snapshot for message ${Q}`);
        for (let X of B.trackedFiles) try {
          let V = HY2(X);
          if (!G.existsSync(V)) {
            let F = Y.trackedFileBackups[X],
              K = F ? F.version + 1 : 1;
            I[X] = {
              backupFileName: null,
              version: K,
              backupTime: new Date
            }, GA("tengu_file_history_backup_deleted_file", {
              version: K
            }), g(`FileHistory: Missing tracked file: ${X}`)
          } else {
            let F = Y.trackedFileBackups[X];
            if (F && F.backupFileName !== null && !KY2(V, F.backupFileName)) {
              I[X] = F;
              continue
            }
            let K = F ? F.version + 1 : 1,
              D = OQ0(V, K);
            I[X] = D
          }
        } catch (V) {
          AA(V), GA("tengu_file_history_backup_file_failed", {})
        }
      }
      let J = {
          messageId: Q,
          trackedFileBackups: I,
          timestamp: Z
        },
        W = {
          ...B,
          snapshots: [...B.snapshots, J]
        };
      return CY2(W), l91(Q, J, !1).catch((X) => {
        AA(Error(`FileHistory: Failed to record snapshot: ${X}`))
      }), g(`FileHistory: Added snapshot for ${Q}, tracking ${B.trackedFiles.size} files`), GA("tengu_file_history_snapshot_success", {
        trackedFilesCount: B.trackedFiles.size,
        snapshotCount: W.snapshots.length
      }), W
    } catch (G) {
      return AA(G), GA("tengu_file_history_snapshot_failed", {}), B
    }
  })
}
// @from(Start 10059523, End 10060491)
async function iMA(A, Q) {
  if (!EG()) return;
  let B = null;
  if (A((G) => {
      let Z = G;
      try {
        let I = G.snapshots.findLast((J) => J.messageId === Q);
        if (!I) return AA(Error(`FileHistory: Snapshot for ${Q} not found`)), GA("tengu_file_history_rewind_failed", {
          trackedFilesCount: Z.trackedFiles.size,
          snapshotFound: !1
        }), B = Error("The selected snapshot was not found"), Z;
        g(`FileHistory: [Rewind] Rewinding to snapshot for ${Q}`);
        let Y = FY2(Z, I, !1);
        g(`FileHistory: [Rewind] Finished rewinding to ${Q}`), GA("tengu_file_history_rewind_success", {
          trackedFilesCount: Z.trackedFiles.size,
          filesChangedCount: Y?.filesChanged?.length
        })
      } catch (I) {
        B = I, AA(I), GA("tengu_file_history_rewind_failed", {
          trackedFilesCount: Z.trackedFiles.size,
          snapshotFound: !0
        })
      }
      return Z
    }), B) throw B
}
// @from(Start 10060493, End 10060591)
function c91(A, Q) {
  if (!EG()) return !1;
  return A.snapshots.some((B) => B.messageId === Q)
}
// @from(Start 10060593, End 10060731)
function TQ0(A, Q) {
  if (!EG()) return;
  let B = A.snapshots.find((G) => G.messageId === Q);
  if (!B) return;
  return FY2(A, B, !0)
}
// @from(Start 10060733, End 10061799)
function FY2(A, Q, B) {
  let G = RA(),
    Z = [],
    I = 0,
    Y = 0;
  for (let J of A.trackedFiles) try {
    let W = HY2(J),
      X = Q.trackedFileBackups[J],
      V = X ? X.backupFileName : lH5(J, A);
    if (V === void 0) AA(Error("FileHistory: Error finding the backup file to apply")), GA("tengu_file_history_rewind_restore_file_failed", {
      dryRun: B
    });
    else if (V === null) {
      if (G.existsSync(W)) {
        if (B) {
          let F = JY2(W, void 0);
          I += F?.insertions || 0, Y += F?.deletions || 0
        } else G.unlinkSync(W), g(`FileHistory: [Rewind] Deleted ${W}`);
        Z.push(W)
      }
    } else if (B) {
      let F = JY2(W, V);
      if (I += F?.insertions || 0, Y += F?.deletions || 0, F?.insertions || F?.deletions) Z.push(W)
    } else if (KY2(W, V)) pH5(W, V), g(`FileHistory: [Rewind] Restored ${W} from ${V}`), Z.push(W)
  } catch (W) {
    AA(W), GA("tengu_file_history_rewind_restore_file_failed", {
      dryRun: B
    })
  }
  return {
    filesChanged: Z,
    insertions: I,
    deletions: Y
  }
}
// @from(Start 10061801, End 10062311)
function KY2(A, Q) {
  let B = RA(),
    G = _YA(Q);
  try {
    let Z = B.existsSync(A),
      I = B.existsSync(G);
    if (Z !== I) return !0;
    else if (!Z) return !1;
    let Y = B.statSync(A),
      J = B.statSync(G);
    if (Y.mode !== J.mode || Y.size !== J.size) return !0;
    if (Y.mtimeMs < J.mtimeMs) return !1;
    let W = B.readFileSync(A, {
        encoding: "utf-8"
      }),
      X = B.readFileSync(G, {
        encoding: "utf-8"
      });
    return W !== X
  } catch {
    return !0
  }
}
// @from(Start 10062313, End 10063013)
function JY2(A, Q) {
  let B = [],
    G = 0,
    Z = 0;
  try {
    let I = RA(),
      Y = Q && _YA(Q),
      J = I.existsSync(A),
      W = Y && I.existsSync(Y);
    if (!J && !W) return {
      filesChanged: B,
      insertions: G,
      deletions: Z
    };
    B.push(A);
    let X = J ? I.readFileSync(A, {
        encoding: "utf-8"
      }) : "",
      V = W ? I.readFileSync(Y, {
        encoding: "utf-8"
      }) : "";
    X91(X, V).forEach((K) => {
      if (K.added) G += K.count || 0;
      if (K.removed) Z += K.count || 0
    })
  } catch (I) {
    AA(Error(`FileHistory: Error generating diffStats: ${I}`))
  }
  return {
    filesChanged: B,
    insertions: G,
    deletions: Z
  }
}
// @from(Start 10063015, End 10063107)
function cH5(A, Q) {
  return `${gH5("sha256").update(A).digest("hex").slice(0,16)}@v${Q}`
}
// @from(Start 10063109, End 10063193)
function _YA(A, Q) {
  let B = MQ();
  return WY2(B, "file-history", Q || e1(), A)
}
// @from(Start 10063195, End 10063749)
function OQ0(A, Q) {
  let B = A !== null ? cH5(A, Q) : null;
  if (A && B) {
    let G = RA(),
      Z = _YA(B),
      I = RQ0(Z);
    if (!G.existsSync(I)) G.mkdirSync(I);
    let Y = G.readFileSync(A, {
      encoding: "utf-8"
    });
    G.writeFileSync(Z, Y, {
      encoding: "utf-8",
      flush: !0
    });
    let J = G.statSync(A),
      W = J.mode;
    VY2(Z, W), GA("tengu_file_history_backup_file_created", {
      version: Q,
      fileSize: J.size
    })
  }
  return {
    backupFileName: B,
    version: Q,
    backupTime: new Date
  }
}
// @from(Start 10063751, End 10064200)
function pH5(A, Q) {
  let B = RA(),
    G = _YA(Q);
  if (!B.existsSync(G)) {
    GA("tengu_file_history_rewind_restore_file_failed", {}), AA(Error(`FileHistory: [Rewind] Backup file not found: ${G}`));
    return
  }
  let Z = B.readFileSync(G, {
      encoding: "utf-8"
    }),
    I = RQ0(A);
  if (!B.existsSync(I)) B.mkdirSync(I);
  B.writeFileSync(A, Z, {
    encoding: "utf-8",
    flush: !0
  });
  let Y = B.statSync(G).mode;
  VY2(A, Y)
}
// @from(Start 10064202, End 10064370)
function lH5(A, Q) {
  for (let B of Q.snapshots) {
    let G = B.trackedFileBackups[A];
    if (G !== void 0 && G.version === 1) return G.backupFileName
  }
  return
}
// @from(Start 10064372, End 10064484)
function DY2(A) {
  if (!XY2(A)) return A;
  let Q = uQ();
  if (A.startsWith(Q)) return uH5(Q, A);
  return A
}
// @from(Start 10064486, End 10064551)
function HY2(A) {
  if (XY2(A)) return A;
  return WY2(uQ(), A)
}
// @from(Start 10064553, End 10064893)
function xYA(A, Q) {
  if (!EG()) return;
  let B = [],
    G = new Set;
  for (let Z of A) {
    let I = {};
    for (let [Y, J] of Object.entries(Z.trackedFileBackups)) {
      let W = DY2(Y);
      G.add(W), I[W] = J
    }
    B.push({
      ...Z,
      trackedFileBackups: I
    })
  }
  Q({
    snapshots: B,
    trackedFiles: G
  })
}
// @from(Start 10064894, End 10066587)
async function p91(A) {
  if (!EG()) return;
  let Q = A.fileHistorySnapshots;
  if (!Q || A.messages.length === 0) return;
  let G = A.messages[A.messages.length - 1]?.sessionId;
  if (!G) {
    AA(Error("FileHistory: Failed to copy backups on restore (no previous session id)"));
    return
  }
  let Z = e1();
  if (G === Z) {
    g(`FileHistory: No need to copy file history for resuming with same session id: ${Z}`);
    return
  }
  try {
    for (let I of Q) {
      let Y = !1;
      for (let [J, W] of Object.entries(I.trackedFileBackups)) {
        if (!W.backupFileName) continue;
        let X = RA(),
          V = _YA(W.backupFileName, G),
          F = _YA(W.backupFileName, Z);
        if (X.existsSync(F)) continue;
        if (!X.existsSync(V)) {
          AA(Error(`FileHistory: Failed to copy backup ${W.backupFileName} on restore (backup file does not exist in ${G})`)), Y = !0;
          break
        }
        let K = RQ0(F);
        if (!X.existsSync(K)) X.mkdirSync(K);
        try {
          X.linkSync(V, F)
        } catch {
          AA(Error("FileHistory: Error hard linking backup file from previous session"));
          try {
            X.copyFileSync(V, F)
          } catch {
            Y = !0, AA(Error("FileHistory: Error copying over backup from previous session"))
          }
        }
        g(`FileHistory: Copied backup ${W.backupFileName} from session ${G} to ${Z}`)
      }
      if (!Y) l91(I.messageId, I, !1).catch((J) => {
        AA(Error("FileHistory: Failed to record copy backup snapshot"))
      });
      else GA("tengu_file_history_resume_copy_failed", {
        numSnapshots: Q.length
      })
    }
  } catch (I) {
    AA(I)
  }
}
// @from(Start 10066589, End 10066648)
function CY2(A) {
  if (iH5) console.error(mH5(A, !1, 5))
}
// @from(Start 10066653, End 10066661)
iH5 = !1
// @from(Start 10066667, End 10066765)
sU = L(() => {
  AQ();
  V0();
  _0();
  UxA();
  g1();
  S7();
  hQ();
  vMA();
  q0();
  jQ()
})
// @from(Start 10066814, End 10067135)
function nH5(A) {
  if (A.type !== "attachment") return A;
  let Q = A.attachment;
  if (Q.type === "new_file") return {
    ...A,
    attachment: {
      ...Q,
      type: "file"
    }
  };
  if (Q.type === "new_directory") return {
    ...A,
    attachment: {
      ...Q,
      type: "directory"
    }
  };
  return A
}
// @from(Start 10067137, End 10067340)
function nMA(A) {
  try {
    let Q = A.map(nH5),
      B = UY2(Q);
    if (B[B.length - 1]?.type === "user") B.push(uD({
      content: S1A
    }));
    return B
  } catch (Q) {
    throw AA(Q), Q
  }
}
// @from(Start 10067341, End 10067819)
async function zY2(A, Q) {
  try {
    let B = await YQ.get(A, {
      headers: Q,
      timeout: 30000
    });
    if (!B.data || !Array.isArray(B.data.log)) throw Error("Invalid response format: missing or invalid log array");
    return B.data
  } catch (B) {
    if (YQ.isAxiosError(B)) {
      let G = B.response ? `HTTP ${B.response.status}: ${B.response.statusText}` : B.message;
      throw Error(`Failed to fetch conversation from remote: ${G}`)
    }
    throw B
  }
}
// @from(Start 10067820, End 10068573)
async function ki(A, Q) {
  try {
    let B = null,
      G = null,
      Z;
    if (A === void 0) B = await wY2(0);
    else if (Q) {
      G = [];
      for (let Y of await Or(Q)) {
        if (Y.type === "assistant" || Y.type === "user") {
          let J = aH5(Y);
          if (J) G.push(J)
        }
        Z = Y.session_id
      }
    } else if (typeof A === "string") B = await $Y2(A), Z = A;
    else B = A;
    if (!B && !G) return null;
    if (B) {
      if (Z91(B), A01(B), p91(B), !Z) Z = VP(B);
      G = B.messages
    }
    G = nMA(G);
    let I = await wq("resume", Z);
    return G.push(...I), {
      messages: G,
      fileHistorySnapshots: B?.fileHistorySnapshots,
      sessionId: Z
    }
  } catch (B) {
    throw AA(B), B
  }
}
// @from(Start 10068575, End 10068912)
function aH5(A) {
  if (A.type === "assistant") return {
    type: A.type,
    message: A.message,
    uuid: EY2(),
    timestamp: new Date().toISOString(),
    requestId: void 0
  };
  else if (A.type === "user") return {
    type: A.type,
    message: A.message,
    uuid: EY2(),
    timestamp: new Date().toISOString()
  };
  return
}
// @from(Start 10068917, End 10069007)
vYA = L(() => {
  g1();
  S7();
  cQ();
  Ti();
  NE();
  LF();
  O3();
  k1A();
  sU()
})
// @from(Start 10069010, End 10071875)
function qY2({
  isDisabled: A = !1,
  visibleOptionCount: Q = 5,
  options: B,
  defaultValue: G = [],
  onChange: Z,
  onCancel: I,
  onFocus: Y,
  focusValue: J,
  submitButtonText: W,
  onSubmit: X
}) {
  let [V, F] = h1A.useState(G), [K, D] = h1A.useState(!1), [H, C] = h1A.useState(() => {
    let w = new Map;
    return B.forEach((N) => {
      if (N.type === "input" && N.initialValue) w.set(N.value, N.initialValue)
    }), w
  }), E = h1A.useCallback((w) => {
    let N = typeof w === "function" ? w(V) : w;
    F(N), Z?.(N)
  }, [V, Z]), U = RsA({
    visibleOptionCount: Q,
    options: B,
    initialFocusValue: void 0,
    onFocus: Y,
    focusValue: J
  }), q = h1A.useCallback((w, N) => {
    C((T) => {
      let y = new Map(T);
      return y.set(w, N), y
    });
    let R = B.find((T) => T.value === w);
    if (R && R.type === "input") R.onChange(N);
    E((T) => {
      if (N) {
        if (!T.includes(w)) return [...T, w];
        return T
      } else return T.filter((y) => y !== w)
    })
  }, [B, E]);
  return f1((w, N) => {
    let T = B.find((v) => v.value === U.focusedValue)?.type === "input";
    if (T) {
      if (!(N.upArrow || N.downArrow || N.escape || N.tab || N.return || N.ctrl && (w === "n" || w === "p" || N.return))) return
    }
    let y = B[B.length - 1]?.value;
    if (N.tab && !N.shift) {
      if (W && X && U.focusedValue === y && !K) D(!0);
      else if (!K) U.focusNextOption();
      return
    }
    if (N.tab && N.shift) {
      if (W && X && K) D(!1), U.focusOption(y);
      else U.focusPreviousOption();
      return
    }
    if (N.downArrow || N.ctrl && w === "n" || !N.ctrl && !N.shift && w === "j") {
      if (W && X && U.focusedValue === y && !K) D(!0);
      else if (!K) U.focusNextOption();
      return
    }
    if (N.upArrow || N.ctrl && w === "p" || !N.ctrl && !N.shift && w === "k") {
      if (W && X && K) D(!1), U.focusOption(y);
      else U.focusPreviousOption();
      return
    }
    if (N.pageDown) {
      U.focusNextPage();
      return
    }
    if (N.pageUp) {
      U.focusPreviousPage();
      return
    }
    if (N.return || w === " ") {
      if (N.ctrl && N.return && T && X) {
        X();
        return
      }
      if (K && X) {
        X();
        return
      }
      if (U.focusedValue !== void 0) {
        let v = V.includes(U.focusedValue) ? V.filter((x) => x !== U.focusedValue) : [...V, U.focusedValue];
        E(v)
      }
      return
    }
    if (/^[0-9]+$/.test(w)) {
      let v = parseInt(w) - 1;
      if (v >= 0 && v < B.length) {
        let x = B[v].value,
          p = V.includes(x) ? V.filter((u) => u !== x) : [...V, x];
        E(p)
      }
      return
    }
    if (N.escape) I()
  }, {
    isActive: !A
  }), {
    ...U,
    selectedValues: V,
    inputValues: H,
    isSubmitFocused: K,
    updateInputValue: q,
    onCancel: I
  }
}
// @from(Start 10071880, End 10071883)
h1A
// @from(Start 10071889, End 10071944)
NY2 = L(() => {
  hA();
  uu1();
  h1A = BA(VA(), 1)
})
// @from(Start 11181052, End 11184687)
class W80 {
  endpoint;
  timeout;
  pendingExports = [];
  isShutdown = !1;
  constructor(A = {}) {
    this.endpoint = "https://api.anthropic.com/api/claude_code/metrics", this.timeout = A.timeout || 5000
  }
  async export (A, Q) {
    if (this.isShutdown) {
      Q({
        code: _JA.ExportResultCode.FAILED,
        error: Error("Exporter has been shutdown")
      });
      return
    }
    let B = this.doExport(A, Q);
    this.pendingExports.push(B), B.finally(() => {
      let G = this.pendingExports.indexOf(B);
      if (G > -1) this.pendingExports.splice(G, 1)
    })
  }
  async doExport(A, Q) {
    try {
      if (!(await J61()).enabled) {
        g("Metrics export disabled by organization setting"), Q({
          code: _JA.ExportResultCode.SUCCESS
        });
        return
      }
      let G = this.transformMetricsForInternal(A),
        Z = DI();
      if (Z.error) {
        g(`Metrics export failed: ${Z.error}`), Q({
          code: _JA.ExportResultCode.FAILED,
          error: Error(Z.error)
        });
        return
      }
      let I = {
          "Content-Type": "application/json",
          "User-Agent": TV(),
          ...Z.headers
        },
        Y = await YQ.post(this.endpoint, G, {
          timeout: this.timeout,
          headers: I
        });
      g("BigQuery metrics exported successfully"), g(`BigQuery API Response: ${JSON.stringify(Y.data,null,2)}`), Q({
        code: _JA.ExportResultCode.SUCCESS
      })
    } catch (B) {
      g(`BigQuery metrics export failed: ${B instanceof Error?B.message:String(B)}`), AA(B), Q({
        code: _JA.ExportResultCode.FAILED,
        error: B instanceof Error ? B : Error("Unknown export error")
      })
    }
  }
  transformMetricsForInternal(A) {
    let Q = A.resource.attributes,
      B = {
        "service.name": Q["service.name"] || "claude-code",
        "service.version": Q["service.version"] || "unknown",
        "os.type": Q["os.type"] || "unknown",
        "os.version": Q["os.version"] || "unknown",
        "host.arch": Q["host.arch"] || "unknown",
        "aggregation.temporality": this.selectAggregationTemporality() === J80.AggregationTemporality.DELTA ? "delta" : "cumulative"
      };
    if (Q["wsl.version"]) B["wsl.version"] = Q["wsl.version"];
    if (BB()) {
      B["user.customer_type"] = "claude_ai";
      let Z = f4();
      if (Z) B["user.subscription_type"] = Z
    } else B["user.customer_type"] = "api";
    return {
      resource_attributes: B,
      metrics: A.scopeMetrics.flatMap((Z) => Z.metrics.map((I) => ({
        name: I.descriptor.name,
        description: I.descriptor.description,
        unit: I.descriptor.unit,
        data_points: this.extractDataPoints(I)
      })))
    }
  }
  extractDataPoints(A) {
    return (A.dataPoints || []).filter((B) => typeof B.value === "number").map((B) => ({
      attributes: this.convertAttributes(B.attributes),
      value: B.value,
      timestamp: this.hrTimeToISOString(B.endTime || B.startTime || [Date.now() / 1000, 0])
    }))
  }
  async shutdown() {
    this.isShutdown = !0, await this.forceFlush(), g("BigQuery metrics exporter shutdown complete")
  }
  async forceFlush() {
    await Promise.all(this.pendingExports), g("BigQuery metrics exporter flush complete")
  }
  convertAttributes(A) {
    let Q = {};
    if (A) {
      for (let [B, G] of Object.entries(A))
        if (G !== void 0 && G !== null) Q[B] = String(G)
    }
    return Q
  }
  hrTimeToISOString(A) {
    let [Q, B] = A;
    return new Date(Q * 1000 + B / 1e6).toISOString()
  }
  selectAggregationTemporality() {
    return J80.AggregationTemporality.DELTA
  }
}
// @from(Start 11184692, End 11184695)
J80
// @from(Start 11184697, End 11184700)
_JA
// @from(Start 11184706, End 11184812)
pM2 = L(() => {
  O3();
  V0();
  g1();
  AE();
  Y80();
  gB();
  J80 = BA(vi(), 1), _JA = BA(e6(), 1)
})
// @from(Start 11184815, End 11184928)
function X80(A) {
  let Q = iv5[A],
    B = process.env[A];
  if (B === void 0) return Q;
  return B === "true"
}
// @from(Start 11184930, End 11185792)
function kJA() {
  let A = hb(),
    Q = e1(),
    B = {
      "user.id": A
    };
  if (X80("OTEL_METRICS_INCLUDE_SESSION_ID")) B["session.id"] = Q;
  if (X80("OTEL_METRICS_INCLUDE_VERSION")) B["app.version"] = {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION;
  let G = t6();
  if (G) {
    let {
      organizationUuid: Z,
      emailAddress: I,
      accountUuid: Y
    } = G;
    if (Z) B["organization.id"] = Z;
    if (I) B["user.email"] = I;
    if (Y && X80("OTEL_METRICS_INCLUDE_ACCOUNT_UUID")) B["user.account_uuid"] = Y
  }
  if (WU.terminal) B["terminal.type"] = WU.terminal;
  return B
}
// @from(Start 11185797, End 11185800)
iv5
// @from(Start 11185806, End 11185991)
W61 = L(() => {
  _0();
  jQ();
  It();
  gB();
  iv5 = {
    OTEL_METRICS_INCLUDE_SESSION_ID: !0,
    OTEL_METRICS_INCLUDE_VERSION: !1,
    OTEL_METRICS_INCLUDE_ACCOUNT_UUID: !0
  }
})
// @from(Start 11186052, End 11186108)
function Cy(A) {
  return A.spanContext().spanId || ""
}
// @from(Start 11186110, End 11186183)
function NP() {
  return Y0(process.env.ENABLE_ENHANCED_TELEMETRY_BETA)
}
// @from(Start 11186185, End 11186276)
function Hy() {
  return eX.trace.getTracer("com.anthropic.claude_code.tracing", "1.0.0")
}
// @from(Start 11186278, End 11186363)
function FRA(A, Q = {}) {
  return {
    ...kJA(),
    "span.type": A,
    ...Q
  }
}
// @from(Start 11186365, End 11186876)
function nM2(A) {
  if (!NP()) return eX.trace.getActiveSpan() || Hy().startSpan("dummy");
  let Q = Hy(),
    G = Y0(process.env.OTEL_LOG_USER_PROMPTS) ? A : "<REDACTED>";
  lM2++;
  let Z = FRA("interaction", {
      user_prompt: G,
      user_prompt_length: A.length,
      "interaction.sequence": lM2
    }),
    I = Q.startSpan("claude_code.interaction", {
      attributes: Z
    }),
    Y = Cy(I);
  return dE.set(Y, {
    span: I,
    startTime: Date.now(),
    attributes: Z
  }), XRA.enterWith(I), I
}
// @from(Start 11186878, End 11187199)
function X61() {
  if (!NP()) return;
  let A = XRA.getStore();
  if (!A) return;
  let Q = Cy(A),
    B = dE.get(Q);
  if (!B) return;
  if (B.ended) return;
  let G = Date.now() - B.startTime;
  B.span.setAttributes({
    "interaction.duration_ms": G
  }), B.span.end(), B.ended = !0, dE.delete(Q), XRA.exit(() => {})
}
// @from(Start 11187201, End 11187706)
function aM2(A) {
  if (!NP()) return eX.trace.getActiveSpan() || Hy().startSpan("dummy");
  let Q = Hy(),
    B = XRA.getStore(),
    G = FRA("llm_request", {
      model: A,
      "llm_request.context": B ? "interaction" : "standalone"
    }),
    Z = B ? eX.trace.setSpan(eX.context.active(), B) : eX.context.active(),
    I = Q.startSpan("claude_code.llm_request", {
      attributes: G
    }, Z),
    Y = Cy(I);
  return dE.set(Y, {
    span: I,
    startTime: Date.now(),
    attributes: G
  }), I
}
// @from(Start 11187708, End 11188752)
function V80(A) {
  if (!NP()) return;
  let Q;
  for (let [, I] of Array.from(dE.entries()).reverse())
    if (I.attributes["span.type"] === "llm_request") {
      Q = I;
      break
    } if (!Q) return;
  let G = {
    duration_ms: Date.now() - Q.startTime
  };
  if (A) {
    if (A.inputTokens !== void 0) G.input_tokens = A.inputTokens;
    if (A.outputTokens !== void 0) G.output_tokens = A.outputTokens;
    if (A.cacheReadTokens !== void 0) G.cache_read_tokens = A.cacheReadTokens;
    if (A.cacheCreationTokens !== void 0) G.cache_creation_tokens = A.cacheCreationTokens;
    if (A.success !== void 0) G.success = A.success;
    if (A.statusCode !== void 0) G.status_code = A.statusCode;
    if (A.error !== void 0) G.error = A.error;
    if (A.attempt !== void 0) G.attempt = A.attempt;
    if (A.modelResponse !== void 0) {
      let I = Boolean(process.env.OTEL_LOG_MODEL_RESPONSE);
      G.model_response = I ? A.modelResponse : "<REDACTED>"
    }
  }
  Q.span.setAttributes(G), Q.span.end();
  let Z = Cy(Q.span);
  dE.delete(Z)
}
// @from(Start 11188754, End 11189219)
function sM2(A, Q) {
  if (!NP()) return eX.trace.getActiveSpan() || Hy().startSpan("dummy");
  let B = Hy(),
    G = XRA.getStore(),
    Z = FRA("tool", {
      tool_name: A,
      ...Q
    }),
    I = G ? eX.trace.setSpan(eX.context.active(), G) : eX.context.active(),
    Y = B.startSpan("claude_code.tool", {
      attributes: Z
    }, I),
    J = Cy(Y);
  return dE.set(J, {
    span: Y,
    startTime: Date.now(),
    attributes: Z
  }), VRA.enterWith(Y), Y
}
// @from(Start 11189221, End 11189656)
function rM2() {
  if (!NP()) return eX.trace.getActiveSpan() || Hy().startSpan("dummy");
  let A = Hy(),
    Q = VRA.getStore(),
    B = FRA("tool.blocked_on_user"),
    G = Q ? eX.trace.setSpan(eX.context.active(), Q) : eX.context.active(),
    Z = A.startSpan("claude_code.tool.blocked_on_user", {
      attributes: B
    }, G),
    I = Cy(Z);
  return dE.set(I, {
    span: Z,
    startTime: Date.now(),
    attributes: B
  }), Z
}
// @from(Start 11189658, End 11190062)
function F80(A, Q) {
  if (!NP()) return;
  let B;
  for (let [, Y] of Array.from(dE.entries()).reverse())
    if (Y.attributes["span.type"] === "tool.blocked_on_user") {
      B = Y;
      break
    } if (!B) return;
  let Z = {
    duration_ms: Date.now() - B.startTime
  };
  if (A) Z.decision = A;
  if (Q) Z.source = Q;
  B.span.setAttributes(Z), B.span.end();
  let I = Cy(B.span);
  dE.delete(I)
}
// @from(Start 11190064, End 11190487)
function oM2() {
  if (!NP()) return eX.trace.getActiveSpan() || Hy().startSpan("dummy");
  let A = Hy(),
    Q = VRA.getStore(),
    B = FRA("tool.execution"),
    G = Q ? eX.trace.setSpan(eX.context.active(), Q) : eX.context.active(),
    Z = A.startSpan("claude_code.tool.execution", {
      attributes: B
    }, G),
    I = Cy(Z);
  return dE.set(I, {
    span: Z,
    startTime: Date.now(),
    attributes: B
  }), Z
}
// @from(Start 11190489, End 11190950)
function K80(A) {
  if (!NP()) return;
  let Q;
  for (let [, I] of Array.from(dE.entries()).reverse())
    if (I.attributes["span.type"] === "tool.execution") {
      Q = I;
      break
    } if (!Q) return;
  let G = {
    duration_ms: Date.now() - Q.startTime
  };
  if (A) {
    if (A.success !== void 0) G.success = A.success;
    if (A.error !== void 0) G.error = A.error
  }
  Q.span.setAttributes(G), Q.span.end();
  let Z = Cy(Q.span);
  dE.delete(Z)
}
// @from(Start 11190952, End 11191308)
function V61() {
  if (!NP()) return;
  let A;
  for (let [, G] of Array.from(dE.entries()).reverse())
    if (G.attributes["span.type"] === "tool") {
      A = G;
      break
    } if (!A) return;
  let Q = Date.now() - A.startTime;
  A.span.setAttributes({
    duration_ms: Q
  }), A.span.end();
  let B = Cy(A.span);
  dE.delete(B), VRA.exit(() => {})
}
// @from(Start 11191310, End 11191515)
function av5(A, Q = nv5) {
  if (A.length <= Q) return {
    content: A,
    truncated: !1
  };
  return {
    content: A.slice(0, Q) + `

[TRUNCATED - Content exceeds 60KB limit]`,
    truncated: !0
  }
}
// @from(Start 11191517, End 11191582)
function sv5() {
  return Y0(process.env.OTEL_LOG_TOOL_CONTENT)
}
// @from(Start 11191584, End 11191965)
function tM2(A, Q) {
  if (!NP() || !sv5()) return;
  let B = VRA.getStore();
  if (!B) return;
  let G = {};
  for (let [Z, I] of Object.entries(Q))
    if (typeof I === "string") {
      let {
        content: Y,
        truncated: J
      } = av5(I);
      if (G[Z] = Y, J) G[`${Z}_truncated`] = !0, G[`${Z}_original_length`] = I.length
    } else G[Z] = I;
  B.addEvent(A, G)
}
// @from(Start 11191970, End 11191972)
eX
// @from(Start 11191974, End 11191977)
XRA
// @from(Start 11191979, End 11191982)
VRA
// @from(Start 11191984, End 11191986)
dE
// @from(Start 11191988, End 11191995)
lM2 = 0
// @from(Start 11191999, End 11192010)
nv5 = 61440
// @from(Start 11192016, End 11192114)
F0A = L(() => {
  W61();
  hQ();
  eX = BA(K9(), 1), XRA = new iM2, VRA = new iM2, dE = new Map
})
// @from(Start 11192117, End 11192411)
function ev5() {
  if (l0()?.otelHeadersHelper) process.env.OTEL_EXPORTER_OTLP_HEADERS = Object.entries(r4B()).map(([Q, B]) => `${Q}=${B}`).join(",");
  if (!process.env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE) process.env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE = "delta"
}
// @from(Start 11192413, End 11193919)
function Ab5() {
  let A = (process.env.OTEL_METRICS_EXPORTER || "").trim().split(",").filter(Boolean),
    Q = parseInt(process.env.OTEL_METRIC_EXPORT_INTERVAL || rv5.toString()),
    B = [];
  for (let G of A)
    if (G === "console") {
      let Z = new F61.ConsoleMetricExporter,
        I = Z.export.bind(Z);
      Z.export = (Y, J) => {
        if (Y.resource && Y.resource.attributes) g(`
=== Resource Attributes ===`), g(JSON.stringify(Y.resource.attributes)), g(`===========================
`);
        return I(Y, J)
      }, B.push(Z)
    } else if (G === "otlp") {
    let Z = process.env.OTEL_EXPORTER_OTLP_METRICS_PROTOCOL?.trim() || process.env.OTEL_EXPORTER_OTLP_PROTOCOL?.trim(),
      I = z80();
    switch (Z) {
      case "grpc":
        B.push(new AO2.OTLPMetricExporter);
        break;
      case "http/json":
        B.push(new QO2.OTLPMetricExporter(I));
        break;
      case "http/protobuf":
        B.push(new eM2.OTLPMetricExporter(I));
        break;
      default:
        throw Error(`Unknown protocol set in OTEL_EXPORTER_OTLP_METRICS_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${Z}`)
    }
  } else if (G === "prometheus") B.push(new BO2.PrometheusExporter);
  else throw Error(`Unknown exporter type set in OTEL_EXPORTER_OTLP_METRICS_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${G}`);
  return B.map((G) => {
    if ("export" in G) return new E80.PeriodicExportingMetricReader({
      exporter: G,
      exportIntervalMillis: Q
    });
    return G
  })
}
// @from(Start 11193921, End 11194790)
function Qb5() {
  let A = (process.env.OTEL_LOGS_EXPORTER || "").trim().split(",").filter(Boolean),
    Q = [];
  for (let B of A)
    if (B === "console") Q.push(new xJA.ConsoleLogRecordExporter);
    else if (B === "otlp") {
    let G = process.env.OTEL_EXPORTER_OTLP_LOGS_PROTOCOL?.trim() || process.env.OTEL_EXPORTER_OTLP_PROTOCOL?.trim(),
      Z = z80();
    switch (G) {
      case "grpc":
        Q.push(new ZO2.OTLPLogExporter);
        break;
      case "http/json":
        Q.push(new IO2.OTLPLogExporter(Z));
        break;
      case "http/protobuf":
        Q.push(new GO2.OTLPLogExporter(Z));
        break;
      default:
        throw Error(`Unknown protocol set in OTEL_EXPORTER_OTLP_LOGS_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${G}`)
    }
  } else throw Error(`Unknown exporter type set in OTEL_LOGS_EXPORTER env var: ${B}`);
  return Q
}
// @from(Start 11194792, End 11195670)
function Bb5() {
  let A = (process.env.OTEL_TRACES_EXPORTER || "").trim().split(",").filter(Boolean),
    Q = [];
  for (let B of A)
    if (B === "console") Q.push(new vJA.ConsoleSpanExporter);
    else if (B === "otlp") {
    let G = process.env.OTEL_EXPORTER_OTLP_TRACES_PROTOCOL?.trim() || process.env.OTEL_EXPORTER_OTLP_PROTOCOL?.trim(),
      Z = z80();
    switch (G) {
      case "grpc":
        Q.push(new JO2.OTLPTraceExporter);
        break;
      case "http/json":
        Q.push(new WO2.OTLPTraceExporter(Z));
        break;
      case "http/protobuf":
        Q.push(new YO2.OTLPTraceExporter(Z));
        break;
      default:
        throw Error(`Unknown protocol set in OTEL_EXPORTER_OTLP_TRACES_PROTOCOL or OTEL_EXPORTER_OTLP_PROTOCOL env var: ${G}`)
    }
  } else throw Error(`Unknown exporter type set in OTEL_TRACES_EXPORTER env var: ${B}`);
  return Q
}
// @from(Start 11195672, End 11195744)
function D80() {
  return Y0(process.env.CLAUDE_CODE_ENABLE_TELEMETRY)
}
// @from(Start 11195746, End 11195887)
function Gb5() {
  let A = new W80;
  return new E80.PeriodicExportingMetricReader({
    exporter: A,
    exportIntervalMillis: 300000
  })
}
// @from(Start 11195889, End 11195997)
function Zb5() {
  let A = f4(),
    Q = BB() && (A === "enterprise" || A === "team");
  return a4B() || Q
}
// @from(Start 11195999, End 11199920)
function XO2() {
  M9("telemetry_init_start"), ev5(), yJA.diag.setLogger(new I80, yJA.DiagLogLevel.ERROR);
  let A = [];
  if (D80()) A.push(...Ab5());
  if (Zb5()) A.push(Gb5());
  let Q = dQ(),
    B = {
      [In.ATTR_SERVICE_NAME]: "claude-code",
      [In.ATTR_SERVICE_VERSION]: {
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.VERSION
    };
  if (Q === "wsl") {
    let K = ds();
    if (K) B["wsl.version"] = K
  }
  let G = LP.resourceFromAttributes(B),
    Z = LP.resourceFromAttributes(LP.osDetector.detect().attributes || {}),
    I = LP.hostDetector.detect(),
    Y = I.attributes?.[In.SEMRESATTRS_HOST_ARCH] ? {
      [In.SEMRESATTRS_HOST_ARCH]: I.attributes[In.SEMRESATTRS_HOST_ARCH]
    } : {},
    J = LP.resourceFromAttributes(Y),
    W = LP.resourceFromAttributes(LP.envDetector.detect().attributes || {}),
    X = G.merge(Z).merge(J).merge(W),
    V = new F61.MeterProvider({
      resource: X,
      views: [],
      readers: A
    });
  if (cE0(V), D80()) {
    let K = Qb5();
    if (K.length > 0) {
      let D = new xJA.LoggerProvider({
        resource: X,
        processors: K.map((C) => new xJA.BatchLogRecordProcessor(C, {
          scheduledDelayMillis: parseInt(process.env.OTEL_LOGS_EXPORT_INTERVAL || ov5.toString())
        }))
      });
      H80.logs.setGlobalLoggerProvider(D), gE0(D);
      let H = H80.logs.getLogger("com.anthropic.claude_code.events", {
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.VERSION);
      mE0(H), process.on("beforeExit", async () => {
        await D?.forceFlush()
      }), process.on("exit", () => {
        D?.forceFlush()
      })
    }
  }
  if (D80()) {
    if (Y0(process.env.ENABLE_ENHANCED_TELEMETRY_BETA)) {
      let K = Bb5();
      if (K.length > 0) {
        let D = K.map((C) => new vJA.BatchSpanProcessor(C, {
            scheduledDelayMillis: parseInt(process.env.OTEL_TRACES_EXPORT_INTERVAL || tv5.toString())
          })),
          H = new vJA.BasicTracerProvider({
            resource: X,
            spanProcessors: D
          });
        yJA.trace.setGlobalTracerProvider(H), pE0(H)
      }
    }
  }
  return PG(async () => {
    let K = parseInt(process.env.CLAUDE_CODE_OTEL_SHUTDOWN_TIMEOUT_MS || "2000");
    try {
      X61();
      let D = [V.shutdown()],
        H = SX1();
      if (H) D.push(H.shutdown());
      let C = _X1();
      if (C) D.push(C.shutdown());
      await Promise.race([Promise.all(D), new Promise((E, U) => setTimeout(() => U(Error("OpenTelemetry shutdown timeout")), K))])
    } catch (D) {
      if (D instanceof Error && D.message.includes("timeout")) g(`
OpenTelemetry telemetry flush timed out after ${K}ms

To resolve this issue, you can:
1. Increase the timeout by setting CLAUDE_CODE_OTEL_SHUTDOWN_TIMEOUT_MS env var (e.g., 5000 for 5 seconds)
2. Check if your OpenTelemetry backend is experiencing scalability issues
3. Disable OpenTelemetry by unsetting CLAUDE_CODE_ENABLE_TELEMETRY env var

Current timeout: ${K}ms
`, {
        level: "error"
      });
      throw D
    }
  }), V.getMeter("com.anthropic.claude_code", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION)
}
// @from(Start 11199921, End 11200664)
async function VO2() {
  let A = dE0();
  if (!A) return;
  let Q = parseInt(process.env.CLAUDE_CODE_OTEL_FLUSH_TIMEOUT_MS || "5000");
  try {
    let B = [A.forceFlush()],
      G = SX1();
    if (G) B.push(G.forceFlush());
    let Z = _X1();
    if (Z) B.push(Z.forceFlush());
    await Promise.race([Promise.all(B), new Promise((I, Y) => setTimeout(() => Y(Error("OpenTelemetry flush timeout")), Q))]), g("Telemetry flushed successfully")
  } catch (B) {
    if (B instanceof Error && B.message.includes("timeout")) g(`Telemetry flush timed out after ${Q}ms. Some metrics may not be exported.`, {
      level: "warn"
    });
    else g(`Telemetry flush failed: ${B instanceof Error?B.message:String(B)}`, {
      level: "error"
    })
  }
}
// @from(Start 11200666, End 11201046)
function z80() {
  let A = Sc(),
    Q = XT(),
    B = process.env.OTEL_EXPORTER_OTLP_ENDPOINT;
  if (!A || B && qiA(B)) return Q ? {
    httpAgentOptions: Q
  } : {};
  return {
    httpAgentOptions: (Z) => {
      return Q ? new C80.HttpsProxyAgent(A, {
        cert: Q.cert,
        key: Q.key,
        passphrase: Q.passphrase
      }) : new C80.HttpsProxyAgent(A)
    }
  }
}
// @from(Start 11201051, End 11201054)
yJA
// @from(Start 11201056, End 11201059)
H80
// @from(Start 11201061, End 11201064)
F61
// @from(Start 11201066, End 11201069)
eM2
// @from(Start 11201071, End 11201074)
AO2
// @from(Start 11201076, End 11201079)
QO2
// @from(Start 11201081, End 11201084)
BO2
// @from(Start 11201086, End 11201089)
E80
// @from(Start 11201091, End 11201094)
xJA
// @from(Start 11201096, End 11201099)
GO2
// @from(Start 11201101, End 11201104)
ZO2
// @from(Start 11201106, End 11201109)
IO2
// @from(Start 11201111, End 11201114)
vJA
// @from(Start 11201116, End 11201119)
YO2
// @from(Start 11201121, End 11201124)
JO2
// @from(Start 11201126, End 11201129)
WO2
// @from(Start 11201131, End 11201133)
LP
// @from(Start 11201135, End 11201137)
In
// @from(Start 11201139, End 11201142)
C80
// @from(Start 11201144, End 11201155)
rv5 = 60000
// @from(Start 11201159, End 11201169)
ov5 = 5000
// @from(Start 11201173, End 11201183)
tv5 = 5000
// @from(Start 11201189, End 11201698)
U80 = L(() => {
  cM2();
  pM2();
  HH();
  _c();
  gB();
  _0();
  F0A();
  Q3();
  gB();
  MB();
  V0();
  js();
  v3A();
  hQ();
  yJA = BA(K9(), 1), H80 = BA(Ef1(), 1), F61 = BA(vi(), 1), eM2 = BA(lD2(), 1), AO2 = BA(ZN2(), 1), QO2 = BA(w41(), 1), BO2 = BA(DN2(), 1), E80 = BA(vi(), 1), xJA = BA(sf1(), 1), GO2 = BA(MN2(), 1), ZO2 = BA(SN2(), 1), IO2 = BA(mN2(), 1), vJA = BA(HM2(), 1), YO2 = BA(OM2(), 1), JO2 = BA(_M2(), 1), WO2 = BA(dM2(), 1), LP = BA(t3A(), 1), In = BA(qt(), 1), C80 = BA(LEA(), 1)
})
// @from(Start 11201700, End 11202037)
async function w80({
  clearOnboarding: A = !1
}) {
  await VO2(), i4B(), Fw().delete(), K61();
  let B = N1();
  if (A) {
    if (B.hasCompletedOnboarding = !1, B.subscriptionNoticeCount = 0, B.hasAvailableSubscription = !1, B.customApiKeyResponses?.approved) B.customApiKeyResponses.approved = []
  }
  B.oauthAccount = void 0, c0(B)
}
// @from(Start 11202042, End 11202045)
$80
// @from(Start 11202047, End 11202151)
K61 = () => {
    M6.cache?.clear?.(), x4A(), TCB(), KCB(), Zt.cache?.clear?.(), yi.cache?.clear?.()
  }
// @from(Start 11202155, End 11202158)
FO2
// @from(Start 11202164, End 11202834)
D61 = L(() => {
  jQ();
  Bh();
  nt();
  hA();
  gB();
  mbA();
  CS();
  u2();
  gb();
  kW();
  hYA();
  U80();
  unA();
  $80 = BA(VA(), 1);
  FO2 = {
    type: "local-jsx",
    name: "logout",
    description: "Sign out from your Anthropic account",
    isEnabled: () => !process.env.DISABLE_LOGOUT_COMMAND,
    isHidden: !1,
    async call() {
      if (!gH()) await kJ();
      await w80({
        clearOnboarding: !0
      });
      let A = $80.createElement($, null, "Successfully logged out from your Anthropic account.");
      return setTimeout(() => {
        l5(0, "logout")
      }, 200), A
    },
    userFacingName() {
      return "logout"
    }
  }
})
// @from(Start 11202836, End 11205367)
class KRA {
  codeVerifier;
  authCodeListener = null;
  port = null;
  manualAuthCodeResolver = null;
  constructor() {
    this.codeVerifier = RY2()
  }
  async startOAuthFlow(A, Q) {
    this.authCodeListener = new jQ0, this.port = await this.authCodeListener.start();
    let B = TY2(this.codeVerifier),
      G = PY2(),
      Z = {
        codeChallenge: B,
        state: G,
        port: this.port,
        loginWithClaudeAi: Q?.loginWithClaudeAi,
        inferenceOnly: Q?.inferenceOnly,
        orgUUID: Q?.orgUUID
      },
      I = oz1({
        ...Z,
        isManual: !0
      }),
      Y = oz1({
        ...Z,
        isManual: !1
      }),
      J = await this.waitForAuthorizationCode(G, async () => {
        await A(I), await cZ(Y)
      }),
      W = this.authCodeListener?.hasPendingResponse() ?? !1;
    GA("tengu_oauth_auth_code_received", {
      automatic: W
    });
    try {
      let X = await Lo0(J, G, this.codeVerifier, this.port, !W, Q?.expiresIn);
      await w80({
        clearOnboarding: !1
      });
      let V = await tz1(X.access_token);
      if (X.account) ez1({
        accountUuid: X.account.uuid,
        emailAddress: X.account.email_address,
        organizationUuid: X.organization?.uuid,
        displayName: V.displayName,
        hasExtraUsageEnabled: V.hasExtraUsageEnabled ?? void 0
      });
      if (W) {
        let F = cbA(X.scope);
        this.authCodeListener?.handleSuccessRedirect(F)
      }
      return this.formatTokens(X, V.subscriptionType, V.rateLimitTier)
    } catch (X) {
      if (W) this.authCodeListener?.handleErrorRedirect();
      throw X
    } finally {
      this.authCodeListener?.close()
    }
  }
  async waitForAuthorizationCode(A, Q) {
    return new Promise((B, G) => {
      this.manualAuthCodeResolver = B, this.authCodeListener?.waitForAuthorization(A, Q).then((Z) => {
        this.manualAuthCodeResolver = null, B(Z)
      }).catch((Z) => {
        this.manualAuthCodeResolver = null, G(Z)
      })
    })
  }
  handleManualAuthCodeInput(A) {
    if (this.manualAuthCodeResolver) this.manualAuthCodeResolver(A.authorizationCode), this.manualAuthCodeResolver = null, this.authCodeListener?.close()
  }
  formatTokens(A, Q, B) {
    return {
      accessToken: A.access_token,
      refreshToken: A.refresh_token,
      expiresAt: Date.now() + A.expires_in * 1000,
      scopes: cbA(A.scope),
      subscriptionType: Q,
      rateLimitTier: B
    }
  }
  cleanup() {
    this.authCodeListener?.close(), this.manualAuthCodeResolver = null
  }
}
// @from(Start 11205372, End 11205440)
q80 = L(() => {
  gM();
  OY2();
  jY2();
  AL();
  D61();
  q0()
})
// @from(Start 11205443, End 11205514)
function dV(A, Q) {
  return A.flatMap((B, G) => G ? [Q(G), B] : [B])
}
// @from(Start 11205515, End 11205947)
async function Ib5() {
  try {
    if (Y0(process.env.CLAUDE_CODE_USE_BEDROCK) || Y0(process.env.CLAUDE_CODE_USE_VERTEX) || Y0(process.env.CLAUDE_CODE_USE_FOUNDRY)) return !0;
    return await YQ.get("https://api.anthropic.com/api/hello", {
      timeout: 5000,
      headers: {
        "Cache-Control": "no-cache"
      }
    }), !0
  } catch (A) {
    if (!(A instanceof Nn0)) return !0;
    return A.code !== "EHOSTUNREACH"
  }
}
// @from(Start 11205949, End 11206352)
function N80() {
  let [A, Q] = H61.useState(null);
  return H61.useEffect(() => {
    let B = !0;
    if (process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC) return;
    let G = async () => {
      if (!B) return;
      let I = await Ib5();
      if (B) Q(I)
    };
    G();
    let Z = setInterval(G, Yb5);
    return () => {
      B = !1, clearInterval(Z)
    }
  }, []), {
    isConnected: A
  }
}
// @from(Start 11206357, End 11206360)
H61
// @from(Start 11206362, End 11206373)
Yb5 = 30000
// @from(Start 11206379, End 11206433)
KO2 = L(() => {
  O3();
  hQ();
  H61 = BA(VA(), 1)
})
// @from(Start 11206435, End 11208118)
class bJA {
  activeOperations = new Set;
  lastUserActivityTime = 0;
  lastCLIRecordedTime = Date.now();
  isCLIActive = !1;
  USER_ACTIVITY_TIMEOUT_MS = 5000;
  static instance = null;
  static getInstance() {
    if (!bJA.instance) bJA.instance = new bJA;
    return bJA.instance
  }
  recordUserActivity() {
    if (!this.isCLIActive && this.lastUserActivityTime !== 0) {
      let Q = (Date.now() - this.lastUserActivityTime) / 1000;
      if (Q > 0) {
        let B = jX1();
        if (B) {
          let G = this.USER_ACTIVITY_TIMEOUT_MS / 1000;
          if (Q < G) B.add(Q, {
            type: "user"
          })
        }
      }
    }
    this.lastUserActivityTime = Date.now()
  }
  startCLIActivity(A) {
    if (this.activeOperations.has(A)) this.endCLIActivity(A);
    let Q = this.activeOperations.size === 0;
    if (this.activeOperations.add(A), Q) this.isCLIActive = !0, this.lastCLIRecordedTime = Date.now()
  }
  endCLIActivity(A) {
    if (this.activeOperations.delete(A), this.activeOperations.size === 0) {
      let Q = Date.now(),
        B = (Q - this.lastCLIRecordedTime) / 1000;
      if (B > 0) {
        let G = jX1();
        if (G) G.add(B, {
          type: "cli"
        })
      }
      this.lastCLIRecordedTime = Q, this.isCLIActive = !1
    }
  }
  async trackOperation(A, Q) {
    this.startCLIActivity(A);
    try {
      return await Q()
    } finally {
      this.endCLIActivity(A)
    }
  }
  getActivityStates() {
    return {
      isUserActive: (Date.now() - this.lastUserActivityTime) / 1000 < this.USER_ACTIVITY_TIMEOUT_MS / 1000,
      isCLIActive: this.isCLIActive,
      activeOperationCount: this.activeOperations.size
    }
  }
}
// @from(Start 11208123, End 11208126)
DRA
// @from(Start 11208132, End 11208184)
L80 = L(() => {
  _0();
  DRA = bJA.getInstance()
})
// @from(Start 11208187, End 11208967)
function Yn({
  todos: A,
  isStandalone: Q = !1
}) {
  if (A.length === 0) return null;
  let B = FK.createElement(FK.Fragment, null, A.map((G, Z) => {
    let I = G.status === "completed" ? H1.checkboxOn : H1.checkboxOff;
    return FK.createElement(S, {
      key: Z
    }, FK.createElement($, {
      dimColor: G.status === "completed"
    }, I, " "), FK.createElement($, {
      bold: G.status === "in_progress",
      dimColor: G.status === "completed",
      strikethrough: G.status === "completed"
    }, G.content))
  }));
  if (Q) return FK.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    marginLeft: 2
  }, FK.createElement($, {
    bold: !0,
    dimColor: !0
  }, "Todos"), B);
  return FK.createElement(S, {
    flexDirection: "column"
  }, B)
}
// @from(Start 11208972, End 11208974)
FK
// @from(Start 11208980, End 11209033)
HRA = L(() => {
  hA();
  V9();
  FK = BA(VA(), 1)
})
// @from(Start 11209036, End 11209726)
function DO2({
  streamMode: A
}) {
  let [Q, B] = CRA.useState(null), [G, Z] = CRA.useState(null);
  if (CRA.useEffect(() => {
      if (A === "thinking" && Q === null) B(Date.now());
      else if (A !== "thinking" && Q !== null) Z(Date.now() - Q), B(null)
    }, [A, Q]), A === "thinking") return MP.createElement(S, {
    marginTop: 1
  }, MP.createElement($, {
    dimColor: !0
  }, "∴ Thinking…"));
  if (G !== null) return MP.createElement(S, {
    marginTop: 1
  }, MP.createElement($, {
    dimColor: !0
  }, "∴ Thought for ", Math.max(1, Math.round(G / 1000)), "s (", MP.createElement($, {
    dimColor: !0,
    bold: !0
  }, "ctrl+o"), " ", "to show thinking)"));
  return null
}
// @from(Start 11209731, End 11209733)
MP
// @from(Start 11209735, End 11209738)
CRA
// @from(Start 11209744, End 11209808)
HO2 = L(() => {
  hA();
  MP = BA(VA(), 1), CRA = BA(VA(), 1)
})
// @from(Start 11209811, End 11210017)
function ERA() {
  if (process.env.TERM === "xterm-ghostty") return ["·", "✢", "✳", "✶", "✻", "*"];
  return process.platform === "darwin" ? ["·", "✢", "✳", "✶", "✻", "✽"] : ["·", "✢", "*", "✶", "✻", "✽"]
}
// @from(Start 11210019, End 11210184)
function K0A(A, Q, B) {
  return {
    r: Math.round(A.r + (Q.r - A.r) * B),
    g: Math.round(A.g + (Q.g - A.g) * B),
    b: Math.round(A.b + (Q.b - A.b) * B)
  }
}
// @from(Start 11210186, End 11210242)
function fJA(A) {
  return `rgb(${A.r},${A.g},${A.b})`
}
// @from(Start 11210244, End 11210453)
function O80({
  char: A,
  flashOpacity: Q
}) {
  let Z = K0A({
    r: 215,
    g: 119,
    b: 87
  }, {
    r: 245,
    g: 149,
    b: 117
  }, Q);
  return M80.createElement($, {
    color: fJA(Z)
  }, A)
}
// @from(Start 11210458, End 11210461)
M80
// @from(Start 11210467, End 11210513)
R80 = L(() => {
  hA();
  M80 = BA(VA(), 1)
})
// @from(Start 11210516, End 11211493)
function T80({
  message: A,
  mode: Q,
  isConnected: B,
  messageColor: G,
  glimmerIndex: Z,
  flashOpacity: I,
  shimmerColor: Y,
  stalledIntensity: J = 0
}) {
  if (!A) return null;
  if (B === !1) return hJ.createElement($, {
    color: G
  }, A, " ");
  if (J > 0) {
    let V = K0A({
        r: 215,
        g: 119,
        b: 87
      }, {
        r: 171,
        g: 43,
        b: 63
      }, J),
      F = fJA(V);
    return hJ.createElement(hJ.Fragment, null, hJ.createElement($, {
      color: F
    }, A), hJ.createElement($, {
      color: F
    }, " "))
  }
  return hJ.createElement(hJ.Fragment, null, A.split("").map((W, X) => {
    if (Q === "tool-use") return hJ.createElement(O80, {
      key: X,
      char: W,
      flashOpacity: I
    });
    else return hJ.createElement(AGA, {
      key: X,
      char: W,
      index: X,
      glimmerIndex: Z,
      messageColor: G,
      shimmerColor: Y
    })
  }), hJ.createElement($, {
    color: G
  }, " "))
}
// @from(Start 11211498, End 11211500)
hJ
// @from(Start 11211506, End 11211569)
CO2 = L(() => {
  hA();
  R80();
  KrA();
  hJ = BA(VA(), 1)
})
// @from(Start 11211572, End 11212259)
function P80({
  frame: A,
  messageColor: Q,
  stalledIntensity: B = 0,
  isConnected: G
}) {
  let Z = zO2[A % zO2.length];
  if (G === !1) return Rq.createElement(S, {
    flexWrap: "wrap",
    height: 1,
    width: 2
  }, Rq.createElement($, {
    color: Q
  }, Z));
  if (B > 0) {
    let J = K0A({
      r: 215,
      g: 119,
      b: 87
    }, {
      r: 171,
      g: 43,
      b: 63
    }, B);
    return Rq.createElement(S, {
      flexWrap: "wrap",
      height: 1,
      width: 2
    }, Rq.createElement($, {
      color: fJA(J)
    }, Z))
  }
  return Rq.createElement(S, {
    flexWrap: "wrap",
    height: 1,
    width: 2
  }, Rq.createElement($, {
    color: Q
  }, Z))
}
// @from(Start 11212264, End 11212266)
Rq
// @from(Start 11212268, End 11212271)
EO2
// @from(Start 11212273, End 11212276)
zO2
// @from(Start 11212282, End 11212379)
UO2 = L(() => {
  hA();
  Rq = BA(VA(), 1), EO2 = ERA(), zO2 = [...EO2, ...[...EO2].reverse()]
})
// @from(Start 11212382, End 11212601)
function j80(A) {
  let [Q, B] = $O2.useState(0);
  return CI(() => {
    if (A === "tool-use") B(() => {
      let G = Date.now() / 1000;
      return (Math.sin(G * Math.PI) + 1) / 2
    });
    else B(0)
  }, 50), Q
}
// @from(Start 11212606, End 11212609)
$O2
// @from(Start 11212615, End 11212661)
wO2 = L(() => {
  JE();
  $O2 = BA(VA(), 1)
})
// @from(Start 11212664, End 11213240)
function S80(A, Q = !1) {
  let [B, G] = D0A.useState(0), [Z, I] = D0A.useState(0), Y = D0A.useRef(A);
  D0A.useEffect(() => {
    if (A > Y.current) G(0), I(0), Y.current = A
  }, [A]), CI(() => {
    if (A > 0 && A === Y.current && !Q) G((X) => X + 100);
    else if (A === 0 || Q) G(0)
  }, 100);
  let J = B > 3000 && !Q,
    W = J ? Math.min((B - 3000) / 2000, 1) : 0;
  return CI(() => {
    I((X) => {
      let V = W,
        F = V - X;
      if (Math.abs(F) < 0.01) return V;
      return X + F * 0.1
    })
  }, 50), {
    isStalled: J,
    stalledIntensity: Z
  }
}
// @from(Start 11213245, End 11213248)
D0A
// @from(Start 11213254, End 11213300)
qO2 = L(() => {
  JE();
  D0A = BA(VA(), 1)
})
// @from(Start 11213306, End 11213386)
NO2 = L(() => {
  R80();
  KrA();
  CO2();
  UO2();
  Lm1();
  wO2();
  qO2()
})
// @from(Start 11213389, End 11217108)
function OO2({
  mode: A,
  elapsedTimeMs: Q,
  spinnerTip: B,
  currentResponseLength: G,
  overrideColor: Z,
  overrideShimmerColor: I,
  overrideMessage: Y,
  spinnerSuffix: J,
  verbose: W,
  todos: X,
  hasActiveTools: V = !1
}) {
  let F = Vb5(),
    [K, D] = OP.useState(0),
    [H, C] = OP.useState(0),
    [E] = OQ(),
    {
      isConnected: U
    } = N80(),
    {
      columns: q
    } = WB(),
    w = X?.find((OA) => OA.status === "in_progress"),
    N = X?.find((OA) => OA.status === "pending"),
    R = OP.useMemo(() => as(F), [F]),
    T = (Y ?? w?.activeForm ?? R) + "…",
    {
      isStalled: y,
      stalledIntensity: v
    } = S80(G, V),
    x = T$A(A, T, U, y),
    p = j80(A),
    u = OP.useRef(G);
  OP.useEffect(() => {
    let OA = "spinner-" + A;
    return DRA.startCLIActivity(OA), () => {
      DRA.endCLIActivity(OA)
    }
  }, [A]), OP.useEffect(() => {
    u.current = G
  }, [G]), CI(() => {
    if (!U) {
      D(4);
      return
    }
    D((OA) => OA + 1)
  }, 120), CI(() => {
    C((OA) => {
      let mA = u.current - OA;
      if (mA <= 0) return OA;
      let wA;
      if (mA < 70) wA = 1;
      else if (mA < 200) wA = Math.max(2, Math.ceil(mA * 0.08));
      else wA = 18;
      return Math.min(OA + wA, u.current)
    })
  }, 10);
  let e = T.length + 2,
    l = 16,
    k = q > e + 20,
    m = X && X.length > 0 && k && q > e + l + 25,
    o = (W || Q > Wb5) && k && q > e + l + (m ? 25 : 0) + 25,
    IA = [...k ? [sB.createElement($, {
      dimColor: !0,
      key: "esc"
    }, sB.createElement(E4, {
      shortcut: "esc",
      action: "interrupt",
      bold: !0
    }))] : [], ...J ? [sB.createElement($, {
      dimColor: !0,
      key: "suffix"
    }, J)] : [], ...m ? [sB.createElement($, {
      dimColor: !0,
      key: "todo"
    }, sB.createElement(E4, {
      shortcut: "ctrl+t",
      action: `${E.showExpandedTodos?"hide":"show"} todos`,
      bold: !0
    }))] : [], ...o ? [sB.createElement($, {
      dimColor: !0,
      key: "elapsedTime"
    }, eC(Q)), sB.createElement(S, {
      flexDirection: "row",
      key: "tokens"
    }, sB.createElement(Xb5, {
      mode: A,
      key: "spinnerMode"
    }), sB.createElement($, {
      dimColor: !0
    }, JZ(Math.round(H / 4)), " tokens"))] : []];
  if (U === !1) IA.push(sB.createElement(S, {
    key: "offline"
  }, sB.createElement($, {
    color: "error",
    bold: !0
  }, "offline")));
  let FA = Z ?? (U === !1 ? "inactive" : "claude"),
    zA = I ?? "claudeShimmer",
    NA = IA.length > 0 ? sB.createElement(sB.Fragment, null, sB.createElement($, {
      dimColor: !0
    }, "("), dV(IA, (OA) => sB.createElement($, {
      dimColor: !0,
      key: `separator-${OA}`
    }, " ", "·", " ")), sB.createElement($, {
      dimColor: !0
    }, ")")) : null;
  return sB.createElement(S, {
    flexDirection: "column",
    width: "100%",
    alignItems: "flex-start"
  }, sB.createElement(DO2, {
    streamMode: A
  }), sB.createElement(S, {
    flexDirection: "row",
    flexWrap: "wrap",
    marginTop: 1,
    width: "100%"
  }, sB.createElement(P80, {
    frame: K,
    messageColor: FA,
    stalledIntensity: v,
    isConnected: U
  }), sB.createElement(T80, {
    message: T,
    mode: A,
    isConnected: U,
    messageColor: FA,
    glimmerIndex: x,
    flashOpacity: p,
    shimmerColor: zA,
    stalledIntensity: v
  }), NA), E.showExpandedTodos && X && X.length > 0 ? sB.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, sB.createElement(S0, null, sB.createElement(Yn, {
    todos: X
  }))) : N || B ? sB.createElement(S, {
    width: "100%"
  }, sB.createElement(S0, null, sB.createElement($, {
    dimColor: !0
  }, N ? `Next: ${N.content}` : `Tip: ${B}`))) : null)
}
// @from(Start 11217110, End 11217526)
function Xb5({
  mode: A
}) {
  switch (A) {
    case "tool-input":
    case "tool-use":
    case "responding":
    case "thinking":
      return sB.createElement(S, {
        width: 2
      }, sB.createElement($, {
        dimColor: !0
      }, H1.arrowDown));
    case "requesting":
      return sB.createElement(S, {
        width: 2
      }, sB.createElement($, {
        dimColor: !0
      }, H1.arrowUp))
  }
}
// @from(Start 11217528, End 11217831)
function g4() {
  let [A, Q] = OP.useState(0), {
    isConnected: B
  } = N80();
  return CI(() => {
    Q((Z) => (Z + 1) % MO2.length)
  }, 120), sB.createElement(S, {
    flexWrap: "wrap",
    height: 1,
    width: 2
  }, sB.createElement($, {
    color: B === !1 ? "inactive" : "text"
  }, MO2[A]))
}
// @from(Start 11217833, End 11217898)
function Vb5() {
  return snA("tengu_spinner_words", Jb5).words
}
// @from(Start 11217903, End 11217905)
sB
// @from(Start 11217907, End 11217909)
OP
// @from(Start 11217911, End 11217914)
LO2
// @from(Start 11217916, End 11217919)
MO2
// @from(Start 11217921, End 11217924)
Jb5
// @from(Start 11217926, End 11217937)
Wb5 = 30000
// @from(Start 11217943, End 11219321)
DY = L(() => {
  hA();
  LxA();
  JE();
  V9();
  KO2();
  L80();
  u2();
  q8();
  HRA();
  z9();
  i8();
  HO2();
  dF();
  NO2();
  sB = BA(VA(), 1), OP = BA(VA(), 1), LO2 = ERA(), MO2 = [...LO2, ...[...LO2].reverse()], Jb5 = {
    words: ["Accomplishing", "Actioning", "Actualizing", "Baking", "Booping", "Brewing", "Calculating", "Cerebrating", "Channelling", "Churning", "Clauding", "Coalescing", "Cogitating", "Computing", "Combobulating", "Concocting", "Considering", "Contemplating", "Cooking", "Crafting", "Creating", "Crunching", "Deciphering", "Deliberating", "Determining", "Discombobulating", "Doing", "Effecting", "Elucidating", "Enchanting", "Envisioning", "Finagling", "Flibbertigibbeting", "Forging", "Forming", "Frolicking", "Generating", "Germinating", "Hatching", "Herding", "Honking", "Ideating", "Imagining", "Incubating", "Inferring", "Manifesting", "Marinating", "Meandering", "Moseying", "Mulling", "Mustering", "Musing", "Noodling", "Percolating", "Perusing", "Philosophising", "Pontificating", "Pondering", "Processing", "Puttering", "Puzzling", "Reticulating", "Ruminating", "Scheming", "Schlepping", "Shimmying", "Simmering", "Smooshing", "Spelunking", "Spinning", "Stewing", "Sussing", "Synthesizing", "Thinking", "Tinkering", "Transmuting", "Unfurling", "Unravelling", "Vibing", "Wandering", "Whirring", "Wibbling", "Working", "Wrangling"]
  }
})
// @from(Start 11219327, End 11220660)
zRA = z((Db5) => {
  function Fb5(A, Q, B) {
    if (B === void 0) B = Array.prototype;
    if (A && typeof B.find === "function") return B.find.call(A, Q);
    for (var G = 0; G < A.length; G++)
      if (Object.prototype.hasOwnProperty.call(A, G)) {
        var Z = A[G];
        if (Q.call(void 0, Z, G, A)) return Z
      }
  }

  function _80(A, Q) {
    if (Q === void 0) Q = Object;
    return Q && typeof Q.freeze === "function" ? Q.freeze(A) : A
  }

  function Kb5(A, Q) {
    if (A === null || typeof A !== "object") throw TypeError("target is not an object");
    for (var B in Q)
      if (Object.prototype.hasOwnProperty.call(Q, B)) A[B] = Q[B];
    return A
  }
  var RO2 = _80({
      HTML: "text/html",
      isHTML: function(A) {
        return A === RO2.HTML
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml"
    }),
    TO2 = _80({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function(A) {
        return A === TO2.HTML
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
  Db5.assign = Kb5;
  Db5.find = Fb5;
  Db5.freeze = _80;
  Db5.MIME_TYPE = RO2;
  Db5.NAMESPACE = TO2
})
// @from(Start 11220666, End 11248690)
d80 = z((kb5) => {
  var vO2 = zRA(),
    Ey = vO2.find,
    URA = vO2.NAMESPACE;

  function $b5(A) {
    return A !== ""
  }

  function wb5(A) {
    return A ? A.split(/[\t\n\f\r ]+/).filter($b5) : []
  }

  function qb5(A, Q) {
    if (!A.hasOwnProperty(Q)) A[Q] = !0;
    return A
  }

  function PO2(A) {
    if (!A) return [];
    var Q = wb5(A);
    return Object.keys(Q.reduce(qb5, {}))
  }

  function Nb5(A) {
    return function(Q) {
      return A && A.indexOf(Q) !== -1
    }
  }

  function wRA(A, Q) {
    for (var B in A)
      if (Object.prototype.hasOwnProperty.call(A, B)) Q[B] = A[B]
  }

  function Z$(A, Q) {
    var B = A.prototype;
    if (!(B instanceof Q)) {
      let Z = function() {};
      var G = Z;
      Z.prototype = Q.prototype, Z = new Z, wRA(B, Z), A.prototype = B = Z
    }
    if (B.constructor != A) {
      if (typeof A != "function") console.error("unknown Class:" + A);
      B.constructor = A
    }
  }
  var I$ = {},
    RP = I$.ELEMENT_NODE = 1,
    gJA = I$.ATTRIBUTE_NODE = 2,
    C61 = I$.TEXT_NODE = 3,
    bO2 = I$.CDATA_SECTION_NODE = 4,
    fO2 = I$.ENTITY_REFERENCE_NODE = 5,
    Lb5 = I$.ENTITY_NODE = 6,
    hO2 = I$.PROCESSING_INSTRUCTION_NODE = 7,
    gO2 = I$.COMMENT_NODE = 8,
    uO2 = I$.DOCUMENT_NODE = 9,
    mO2 = I$.DOCUMENT_TYPE_NODE = 10,
    gh = I$.DOCUMENT_FRAGMENT_NODE = 11,
    Mb5 = I$.NOTATION_NODE = 12,
    ZC = {},
    KK = {},
    bsG = ZC.INDEX_SIZE_ERR = (KK[1] = "Index size error", 1),
    fsG = ZC.DOMSTRING_SIZE_ERR = (KK[2] = "DOMString size error", 2),
    G$ = ZC.HIERARCHY_REQUEST_ERR = (KK[3] = "Hierarchy request error", 3),
    hsG = ZC.WRONG_DOCUMENT_ERR = (KK[4] = "Wrong document", 4),
    gsG = ZC.INVALID_CHARACTER_ERR = (KK[5] = "Invalid character", 5),
    usG = ZC.NO_DATA_ALLOWED_ERR = (KK[6] = "No data allowed", 6),
    msG = ZC.NO_MODIFICATION_ALLOWED_ERR = (KK[7] = "No modification allowed", 7),
    dO2 = ZC.NOT_FOUND_ERR = (KK[8] = "Not found", 8),
    dsG = ZC.NOT_SUPPORTED_ERR = (KK[9] = "Not supported", 9),
    jO2 = ZC.INUSE_ATTRIBUTE_ERR = (KK[10] = "Attribute in use", 10),
    csG = ZC.INVALID_STATE_ERR = (KK[11] = "Invalid state", 11),
    psG = ZC.SYNTAX_ERR = (KK[12] = "Syntax error", 12),
    lsG = ZC.INVALID_MODIFICATION_ERR = (KK[13] = "Invalid modification", 13),
    isG = ZC.NAMESPACE_ERR = (KK[14] = "Invalid namespace", 14),
    nsG = ZC.INVALID_ACCESS_ERR = (KK[15] = "Invalid access", 15);

  function fW(A, Q) {
    if (Q instanceof Error) var B = Q;
    else if (B = this, Error.call(this, KK[A]), this.message = KK[A], Error.captureStackTrace) Error.captureStackTrace(this, fW);
    if (B.code = A, Q) this.message = this.message + ": " + Q;
    return B
  }
  fW.prototype = Error.prototype;
  wRA(ZC, fW);

  function hh() {}
  hh.prototype = {
    length: 0,
    item: function(A) {
      return A >= 0 && A < this.length ? this[A] : null
    },
    toString: function(A, Q) {
      for (var B = [], G = 0; G < this.length; G++) hJA(this[G], B, A, Q);
      return B.join("")
    },
    filter: function(A) {
      return Array.prototype.filter.call(this, A)
    },
    indexOf: function(A) {
      return Array.prototype.indexOf.call(this, A)
    }
  };

  function uJA(A, Q) {
    this._node = A, this._refresh = Q, x80(this)
  }

  function x80(A) {
    var Q = A._node._inc || A._node.ownerDocument._inc;
    if (A._inc !== Q) {
      var B = A._refresh(A._node);
      if (AR2(A, "length", B.length), !A.$$length || B.length < A.$$length) {
        for (var G = B.length; G in A; G++)
          if (Object.prototype.hasOwnProperty.call(A, G)) delete A[G]
      }
      wRA(B, A), A._inc = Q
    }
  }
  uJA.prototype.item = function(A) {
    return x80(this), this[A] || null
  };
  Z$(uJA, hh);

  function E61() {}

  function cO2(A, Q) {
    var B = A.length;
    while (B--)
      if (A[B] === Q) return B
  }

  function SO2(A, Q, B, G) {
    if (G) Q[cO2(Q, G)] = B;
    else Q[Q.length++] = B;
    if (A) {
      B.ownerElement = A;
      var Z = A.ownerDocument;
      if (Z) G && iO2(Z, A, G), Ob5(Z, A, B)
    }
  }

  function _O2(A, Q, B) {
    var G = cO2(Q, B);
    if (G >= 0) {
      var Z = Q.length - 1;
      while (G < Z) Q[G] = Q[++G];
      if (Q.length = Z, A) {
        var I = A.ownerDocument;
        if (I) iO2(I, A, B), B.ownerElement = null
      }
    } else throw new fW(dO2, Error(A.tagName + "@" + B))
  }
  E61.prototype = {
    length: 0,
    item: hh.prototype.item,
    getNamedItem: function(A) {
      var Q = this.length;
      while (Q--) {
        var B = this[Q];
        if (B.nodeName == A) return B
      }
    },
    setNamedItem: function(A) {
      var Q = A.ownerElement;
      if (Q && Q != this._ownerElement) throw new fW(jO2);
      var B = this.getNamedItem(A.nodeName);
      return SO2(this._ownerElement, this, A, B), B
    },
    setNamedItemNS: function(A) {
      var Q = A.ownerElement,
        B;
      if (Q && Q != this._ownerElement) throw new fW(jO2);
      return B = this.getNamedItemNS(A.namespaceURI, A.localName), SO2(this._ownerElement, this, A, B), B
    },
    removeNamedItem: function(A) {
      var Q = this.getNamedItem(A);
      return _O2(this._ownerElement, this, Q), Q
    },
    removeNamedItemNS: function(A, Q) {
      var B = this.getNamedItemNS(A, Q);
      return _O2(this._ownerElement, this, B), B
    },
    getNamedItemNS: function(A, Q) {
      var B = this.length;
      while (B--) {
        var G = this[B];
        if (G.localName == Q && G.namespaceURI == A) return G
      }
      return null
    }
  };

  function pO2() {}
  pO2.prototype = {
    hasFeature: function(A, Q) {
      return !0
    },
    createDocument: function(A, Q, B) {
      var G = new qRA;
      if (G.implementation = this, G.childNodes = new hh, G.doctype = B || null, B) G.appendChild(B);
      if (Q) {
        var Z = G.createElementNS(A, Q);
        G.appendChild(Z)
      }
      return G
    },
    createDocumentType: function(A, Q, B) {
      var G = new $61;
      return G.name = A, G.nodeName = A, G.publicId = Q || "", G.systemId = B || "", G
    }
  };

  function UG() {}
  UG.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    insertBefore: function(A, Q) {
      return z61(this, A, Q)
    },
    replaceChild: function(A, Q) {
      if (z61(this, A, Q, aO2), Q) this.removeChild(Q)
    },
    removeChild: function(A) {
      return nO2(this, A)
    },
    appendChild: function(A) {
      return this.insertBefore(A, null)
    },
    hasChildNodes: function() {
      return this.firstChild != null
    },
    cloneNode: function(A) {
      return y80(this.ownerDocument || this, this, A)
    },
    normalize: function() {
      var A = this.firstChild;
      while (A) {
        var Q = A.nextSibling;
        if (Q && Q.nodeType == C61 && A.nodeType == C61) this.removeChild(Q), A.appendData(Q.data);
        else A.normalize(), A = Q
      }
    },
    isSupported: function(A, Q) {
      return this.ownerDocument.implementation.hasFeature(A, Q)
    },
    hasAttributes: function() {
      return this.attributes.length > 0
    },
    lookupPrefix: function(A) {
      var Q = this;
      while (Q) {
        var B = Q._nsMap;
        if (B) {
          for (var G in B)
            if (Object.prototype.hasOwnProperty.call(B, G) && B[G] === A) return G
        }
        Q = Q.nodeType == gJA ? Q.ownerDocument : Q.parentNode
      }
      return null
    },
    lookupNamespaceURI: function(A) {
      var Q = this;
      while (Q) {
        var B = Q._nsMap;
        if (B) {
          if (Object.prototype.hasOwnProperty.call(B, A)) return B[A]
        }
        Q = Q.nodeType == gJA ? Q.ownerDocument : Q.parentNode
      }
      return null
    },
    isDefaultNamespace: function(A) {
      var Q = this.lookupPrefix(A);
      return Q == null
    }
  };

  function lO2(A) {
    return A == "<" && "&lt;" || A == ">" && "&gt;" || A == "&" && "&amp;" || A == '"' && "&quot;" || "&#" + A.charCodeAt() + ";"
  }
  wRA(I$, UG);
  wRA(I$, UG.prototype);

  function $RA(A, Q) {
    if (Q(A)) return !0;
    if (A = A.firstChild)
      do
        if ($RA(A, Q)) return !0; while (A = A.nextSibling)
  }

  function qRA() {
    this.ownerDocument = this
  }

  function Ob5(A, Q, B) {
    A && A._inc++;
    var G = B.namespaceURI;
    if (G === URA.XMLNS) Q._nsMap[B.prefix ? B.localName : ""] = B.value
  }

  function iO2(A, Q, B, G) {
    A && A._inc++;
    var Z = B.namespaceURI;
    if (Z === URA.XMLNS) delete Q._nsMap[B.prefix ? B.localName : ""]
  }

  function v80(A, Q, B) {
    if (A && A._inc) {
      A._inc++;
      var G = Q.childNodes;
      if (B) G[G.length++] = B;
      else {
        var Z = Q.firstChild,
          I = 0;
        while (Z) G[I++] = Z, Z = Z.nextSibling;
        G.length = I, delete G[G.length]
      }
    }
  }

  function nO2(A, Q) {
    var {
      previousSibling: B,
      nextSibling: G
    } = Q;
    if (B) B.nextSibling = G;
    else A.firstChild = G;
    if (G) G.previousSibling = B;
    else A.lastChild = B;
    return Q.parentNode = null, Q.previousSibling = null, Q.nextSibling = null, v80(A.ownerDocument, A), Q
  }

  function Rb5(A) {
    return A && (A.nodeType === UG.DOCUMENT_NODE || A.nodeType === UG.DOCUMENT_FRAGMENT_NODE || A.nodeType === UG.ELEMENT_NODE)
  }

  function Tb5(A) {
    return A && (zy(A) || b80(A) || uh(A) || A.nodeType === UG.DOCUMENT_FRAGMENT_NODE || A.nodeType === UG.COMMENT_NODE || A.nodeType === UG.PROCESSING_INSTRUCTION_NODE)
  }

  function uh(A) {
    return A && A.nodeType === UG.DOCUMENT_TYPE_NODE
  }

  function zy(A) {
    return A && A.nodeType === UG.ELEMENT_NODE
  }

  function b80(A) {
    return A && A.nodeType === UG.TEXT_NODE
  }

  function kO2(A, Q) {
    var B = A.childNodes || [];
    if (Ey(B, zy) || uh(Q)) return !1;
    var G = Ey(B, uh);
    return !(Q && G && B.indexOf(G) > B.indexOf(Q))
  }

  function yO2(A, Q) {
    var B = A.childNodes || [];

    function G(I) {
      return zy(I) && I !== Q
    }
    if (Ey(B, G)) return !1;
    var Z = Ey(B, uh);
    return !(Q && Z && B.indexOf(Z) > B.indexOf(Q))
  }

  function Pb5(A, Q, B) {
    if (!Rb5(A)) throw new fW(G$, "Unexpected parent node type " + A.nodeType);
    if (B && B.parentNode !== A) throw new fW(dO2, "child not in parent");
    if (!Tb5(Q) || uh(Q) && A.nodeType !== UG.DOCUMENT_NODE) throw new fW(G$, "Unexpected node type " + Q.nodeType + " for parent node type " + A.nodeType)
  }

  function jb5(A, Q, B) {
    var G = A.childNodes || [],
      Z = Q.childNodes || [];
    if (Q.nodeType === UG.DOCUMENT_FRAGMENT_NODE) {
      var I = Z.filter(zy);
      if (I.length > 1 || Ey(Z, b80)) throw new fW(G$, "More than one element or text in fragment");
      if (I.length === 1 && !kO2(A, B)) throw new fW(G$, "Element in fragment can not be inserted before doctype")
    }
    if (zy(Q)) {
      if (!kO2(A, B)) throw new fW(G$, "Only one element can be added and only after doctype")
    }
    if (uh(Q)) {
      if (Ey(G, uh)) throw new fW(G$, "Only one doctype is allowed");
      var Y = Ey(G, zy);
      if (B && G.indexOf(Y) < G.indexOf(B)) throw new fW(G$, "Doctype can only be inserted before an element");
      if (!B && Y) throw new fW(G$, "Doctype can not be appended since element is present")
    }
  }

  function aO2(A, Q, B) {
    var G = A.childNodes || [],
      Z = Q.childNodes || [];
    if (Q.nodeType === UG.DOCUMENT_FRAGMENT_NODE) {
      var I = Z.filter(zy);
      if (I.length > 1 || Ey(Z, b80)) throw new fW(G$, "More than one element or text in fragment");
      if (I.length === 1 && !yO2(A, B)) throw new fW(G$, "Element in fragment can not be inserted before doctype")
    }
    if (zy(Q)) {
      if (!yO2(A, B)) throw new fW(G$, "Only one element can be added and only after doctype")
    }
    if (uh(Q)) {
      let W = function(X) {
        return uh(X) && X !== B
      };
      var J = W;
      if (Ey(G, W)) throw new fW(G$, "Only one doctype is allowed");
      var Y = Ey(G, zy);
      if (B && G.indexOf(Y) < G.indexOf(B)) throw new fW(G$, "Doctype can only be inserted before an element")
    }
  }

  function z61(A, Q, B, G) {
    if (Pb5(A, Q, B), A.nodeType === UG.DOCUMENT_NODE)(G || jb5)(A, Q, B);
    var Z = Q.parentNode;
    if (Z) Z.removeChild(Q);
    if (Q.nodeType === gh) {
      var I = Q.firstChild;
      if (I == null) return Q;
      var Y = Q.lastChild
    } else I = Y = Q;
    var J = B ? B.previousSibling : A.lastChild;
    if (I.previousSibling = J, Y.nextSibling = B, J) J.nextSibling = I;
    else A.firstChild = I;
    if (B == null) A.lastChild = Y;
    else B.previousSibling = Y;
    do I.parentNode = A; while (I !== Y && (I = I.nextSibling));
    if (v80(A.ownerDocument || A, A), Q.nodeType == gh) Q.firstChild = Q.lastChild = null;
    return Q
  }

  function Sb5(A, Q) {
    if (Q.parentNode) Q.parentNode.removeChild(Q);
    if (Q.parentNode = A, Q.previousSibling = A.lastChild, Q.nextSibling = null, Q.previousSibling) Q.previousSibling.nextSibling = Q;
    else A.firstChild = Q;
    return A.lastChild = Q, v80(A.ownerDocument, A, Q), Q
  }
  qRA.prototype = {
    nodeName: "#document",
    nodeType: uO2,
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(A, Q) {
      if (A.nodeType == gh) {
        var B = A.firstChild;
        while (B) {
          var G = B.nextSibling;
          this.insertBefore(B, Q), B = G
        }
        return A
      }
      if (z61(this, A, Q), A.ownerDocument = this, this.documentElement === null && A.nodeType === RP) this.documentElement = A;
      return A
    },
    removeChild: function(A) {
      if (this.documentElement == A) this.documentElement = null;
      return nO2(this, A)
    },
    replaceChild: function(A, Q) {
      if (z61(this, A, Q, aO2), A.ownerDocument = this, Q) this.removeChild(Q);
      if (zy(A)) this.documentElement = A
    },
    importNode: function(A, Q) {
      return eO2(this, A, Q)
    },
    getElementById: function(A) {
      var Q = null;
      return $RA(this.documentElement, function(B) {
        if (B.nodeType == RP) {
          if (B.getAttribute("id") == A) return Q = B, !0
        }
      }), Q
    },
    getElementsByClassName: function(A) {
      var Q = PO2(A);
      return new uJA(this, function(B) {
        var G = [];
        if (Q.length > 0) $RA(B.documentElement, function(Z) {
          if (Z !== B && Z.nodeType === RP) {
            var I = Z.getAttribute("class");
            if (I) {
              var Y = A === I;
              if (!Y) {
                var J = PO2(I);
                Y = Q.every(Nb5(J))
              }
              if (Y) G.push(Z)
            }
          }
        });
        return G
      })
    },
    createElement: function(A) {
      var Q = new H0A;
      Q.ownerDocument = this, Q.nodeName = A, Q.tagName = A, Q.localName = A, Q.childNodes = new hh;
      var B = Q.attributes = new E61;
      return B._ownerElement = Q, Q
    },
    createDocumentFragment: function() {
      var A = new w61;
      return A.ownerDocument = this, A.childNodes = new hh, A
    },
    createTextNode: function(A) {
      var Q = new f80;
      return Q.ownerDocument = this, Q.appendData(A), Q
    },
    createComment: function(A) {
      var Q = new h80;
      return Q.ownerDocument = this, Q.appendData(A), Q
    },
    createCDATASection: function(A) {
      var Q = new g80;
      return Q.ownerDocument = this, Q.appendData(A), Q
    },
    createProcessingInstruction: function(A, Q) {
      var B = new m80;
      return B.ownerDocument = this, B.tagName = B.nodeName = B.target = A, B.nodeValue = B.data = Q, B
    },
    createAttribute: function(A) {
      var Q = new U61;
      return Q.ownerDocument = this, Q.name = A, Q.nodeName = A, Q.localName = A, Q.specified = !0, Q
    },
    createEntityReference: function(A) {
      var Q = new u80;
      return Q.ownerDocument = this, Q.nodeName = A, Q
    },
    createElementNS: function(A, Q) {
      var B = new H0A,
        G = Q.split(":"),
        Z = B.attributes = new E61;
      if (B.childNodes = new hh, B.ownerDocument = this, B.nodeName = Q, B.tagName = Q, B.namespaceURI = A, G.length == 2) B.prefix = G[0], B.localName = G[1];
      else B.localName = Q;
      return Z._ownerElement = B, B
    },
    createAttributeNS: function(A, Q) {
      var B = new U61,
        G = Q.split(":");
      if (B.ownerDocument = this, B.nodeName = Q, B.name = Q, B.namespaceURI = A, B.specified = !0, G.length == 2) B.prefix = G[0], B.localName = G[1];
      else B.localName = Q;
      return B
    }
  };
  Z$(qRA, UG);

  function H0A() {
    this._nsMap = {}
  }
  H0A.prototype = {
    nodeType: RP,
    hasAttribute: function(A) {
      return this.getAttributeNode(A) != null
    },
    getAttribute: function(A) {
      var Q = this.getAttributeNode(A);
      return Q && Q.value || ""
    },
    getAttributeNode: function(A) {
      return this.attributes.getNamedItem(A)
    },
    setAttribute: function(A, Q) {
      var B = this.ownerDocument.createAttribute(A);
      B.value = B.nodeValue = "" + Q, this.setAttributeNode(B)
    },
    removeAttribute: function(A) {
      var Q = this.getAttributeNode(A);
      Q && this.removeAttributeNode(Q)
    },
    appendChild: function(A) {
      if (A.nodeType === gh) return this.insertBefore(A, null);
      else return Sb5(this, A)
    },
    setAttributeNode: function(A) {
      return this.attributes.setNamedItem(A)
    },
    setAttributeNodeNS: function(A) {
      return this.attributes.setNamedItemNS(A)
    },
    removeAttributeNode: function(A) {
      return this.attributes.removeNamedItem(A.nodeName)
    },
    removeAttributeNS: function(A, Q) {
      var B = this.getAttributeNodeNS(A, Q);
      B && this.removeAttributeNode(B)
    },
    hasAttributeNS: function(A, Q) {
      return this.getAttributeNodeNS(A, Q) != null
    },
    getAttributeNS: function(A, Q) {
      var B = this.getAttributeNodeNS(A, Q);
      return B && B.value || ""
    },
    setAttributeNS: function(A, Q, B) {
      var G = this.ownerDocument.createAttributeNS(A, Q);
      G.value = G.nodeValue = "" + B, this.setAttributeNode(G)
    },
    getAttributeNodeNS: function(A, Q) {
      return this.attributes.getNamedItemNS(A, Q)
    },
    getElementsByTagName: function(A) {
      return new uJA(this, function(Q) {
        var B = [];
        return $RA(Q, function(G) {
          if (G !== Q && G.nodeType == RP && (A === "*" || G.tagName == A)) B.push(G)
        }), B
      })
    },
    getElementsByTagNameNS: function(A, Q) {
      return new uJA(this, function(B) {
        var G = [];
        return $RA(B, function(Z) {
          if (Z !== B && Z.nodeType === RP && (A === "*" || Z.namespaceURI === A) && (Q === "*" || Z.localName == Q)) G.push(Z)
        }), G
      })
    }
  };
  qRA.prototype.getElementsByTagName = H0A.prototype.getElementsByTagName;
  qRA.prototype.getElementsByTagNameNS = H0A.prototype.getElementsByTagNameNS;
  Z$(H0A, UG);

  function U61() {}
  U61.prototype.nodeType = gJA;
  Z$(U61, UG);

  function NRA() {}
  NRA.prototype = {
    data: "",
    substringData: function(A, Q) {
      return this.data.substring(A, A + Q)
    },
    appendData: function(A) {
      A = this.data + A, this.nodeValue = this.data = A, this.length = A.length
    },
    insertData: function(A, Q) {
      this.replaceData(A, 0, Q)
    },
    appendChild: function(A) {
      throw Error(KK[G$])
    },
    deleteData: function(A, Q) {
      this.replaceData(A, Q, "")
    },
    replaceData: function(A, Q, B) {
      var G = this.data.substring(0, A),
        Z = this.data.substring(A + Q);
      B = G + B + Z, this.nodeValue = this.data = B, this.length = B.length
    }
  };
  Z$(NRA, UG);

  function f80() {}
  f80.prototype = {
    nodeName: "#text",
    nodeType: C61,
    splitText: function(A) {
      var Q = this.data,
        B = Q.substring(A);
      Q = Q.substring(0, A), this.data = this.nodeValue = Q, this.length = Q.length;
      var G = this.ownerDocument.createTextNode(B);
      if (this.parentNode) this.parentNode.insertBefore(G, this.nextSibling);
      return G
    }
  };
  Z$(f80, NRA);

  function h80() {}
  h80.prototype = {
    nodeName: "#comment",
    nodeType: gO2
  };
  Z$(h80, NRA);

  function g80() {}
  g80.prototype = {
    nodeName: "#cdata-section",
    nodeType: bO2
  };
  Z$(g80, NRA);

  function $61() {}
  $61.prototype.nodeType = mO2;
  Z$($61, UG);

  function sO2() {}
  sO2.prototype.nodeType = Mb5;
  Z$(sO2, UG);

  function rO2() {}
  rO2.prototype.nodeType = Lb5;
  Z$(rO2, UG);

  function u80() {}
  u80.prototype.nodeType = fO2;
  Z$(u80, UG);

  function w61() {}
  w61.prototype.nodeName = "#document-fragment";
  w61.prototype.nodeType = gh;
  Z$(w61, UG);

  function m80() {}
  m80.prototype.nodeType = hO2;
  Z$(m80, UG);

  function oO2() {}
  oO2.prototype.serializeToString = function(A, Q, B) {
    return tO2.call(A, Q, B)
  };
  UG.prototype.toString = tO2;

  function tO2(A, Q) {
    var B = [],
      G = this.nodeType == 9 && this.documentElement || this,
      Z = G.prefix,
      I = G.namespaceURI;
    if (I && Z == null) {
      var Z = G.lookupPrefix(I);
      if (Z == null) var Y = [{
        namespace: I,
        prefix: null
      }]
    }
    return hJA(this, B, A, Q, Y), B.join("")
  }

  function xO2(A, Q, B) {
    var G = A.prefix || "",
      Z = A.namespaceURI;
    if (!Z) return !1;
    if (G === "xml" && Z === URA.XML || Z === URA.XMLNS) return !1;
    var I = B.length;
    while (I--) {
      var Y = B[I];
      if (Y.prefix === G) return Y.namespace !== Z
    }
    return !0
  }

  function k80(A, Q, B) {
    A.push(" ", Q, '="', B.replace(/[<>&"\t\n\r]/g, lO2), '"')
  }

  function hJA(A, Q, B, G, Z) {
    if (!Z) Z = [];
    if (G)
      if (A = G(A), A) {
        if (typeof A == "string") {
          Q.push(A);
          return
        }
      } else return;
    switch (A.nodeType) {
      case RP:
        var I = A.attributes,
          Y = I.length,
          U = A.firstChild,
          J = A.tagName;
        B = URA.isHTML(A.namespaceURI) || B;
        var W = J;
        if (!B && !A.prefix && A.namespaceURI) {
          var X;
          for (var V = 0; V < I.length; V++)
            if (I.item(V).name === "xmlns") {
              X = I.item(V).value;
              break
            } if (!X)
            for (var F = Z.length - 1; F >= 0; F--) {
              var K = Z[F];
              if (K.prefix === "" && K.namespace === A.namespaceURI) {
                X = K.namespace;
                break
              }
            }
          if (X !== A.namespaceURI)
            for (var F = Z.length - 1; F >= 0; F--) {
              var K = Z[F];
              if (K.namespace === A.namespaceURI) {
                if (K.prefix) W = K.prefix + ":" + J;
                break
              }
            }
        }
        Q.push("<", W);
        for (var D = 0; D < Y; D++) {
          var H = I.item(D);
          if (H.prefix == "xmlns") Z.push({
            prefix: H.localName,
            namespace: H.value
          });
          else if (H.nodeName == "xmlns") Z.push({
            prefix: "",
            namespace: H.value
          })
        }
        for (var D = 0; D < Y; D++) {
          var H = I.item(D);
          if (xO2(H, B, Z)) {
            var C = H.prefix || "",
              E = H.namespaceURI;
            k80(Q, C ? "xmlns:" + C : "xmlns", E), Z.push({
              prefix: C,
              namespace: E
            })
          }
          hJA(H, Q, B, G, Z)
        }
        if (J === W && xO2(A, B, Z)) {
          var C = A.prefix || "",
            E = A.namespaceURI;
          k80(Q, C ? "xmlns:" + C : "xmlns", E), Z.push({
            prefix: C,
            namespace: E
          })
        }
        if (U || B && !/^(?:meta|link|img|br|hr|input)$/i.test(J)) {
          if (Q.push(">"), B && /^script$/i.test(J))
            while (U) {
              if (U.data) Q.push(U.data);
              else hJA(U, Q, B, G, Z.slice());
              U = U.nextSibling
            } else
              while (U) hJA(U, Q, B, G, Z.slice()), U = U.nextSibling;
          Q.push("</", W, ">")
        } else Q.push("/>");
        return;
      case uO2:
      case gh:
        var U = A.firstChild;
        while (U) hJA(U, Q, B, G, Z.slice()), U = U.nextSibling;
        return;
      case gJA:
        return k80(Q, A.name, A.value);
      case C61:
        return Q.push(A.data.replace(/[<&>]/g, lO2));
      case bO2:
        return Q.push("<![CDATA[", A.data, "]]>");
      case gO2:
        return Q.push("<!--", A.data, "-->");
      case mO2:
        var {
          publicId: q, systemId: w
        } = A;
        if (Q.push("<!DOCTYPE ", A.name), q) {
          if (Q.push(" PUBLIC ", q), w && w != ".") Q.push(" ", w);
          Q.push(">")
        } else if (w && w != ".") Q.push(" SYSTEM ", w, ">");
        else {
          var N = A.internalSubset;
          if (N) Q.push(" [", N, "]");
          Q.push(">")
        }
        return;
      case hO2:
        return Q.push("<?", A.target, " ", A.data, "?>");
      case fO2:
        return Q.push("&", A.nodeName, ";");
      default:
        Q.push("??", A.nodeName)
    }
  }

  function eO2(A, Q, B) {
    var G;
    switch (Q.nodeType) {
      case RP:
        G = Q.cloneNode(!1), G.ownerDocument = A;
      case gh:
        break;
      case gJA:
        B = !0;
        break
    }
    if (!G) G = Q.cloneNode(!1);
    if (G.ownerDocument = A, G.parentNode = null, B) {
      var Z = Q.firstChild;
      while (Z) G.appendChild(eO2(A, Z, B)), Z = Z.nextSibling
    }
    return G
  }

  function y80(A, Q, B) {
    var G = new Q.constructor;
    for (var Z in Q)
      if (Object.prototype.hasOwnProperty.call(Q, Z)) {
        var I = Q[Z];
        if (typeof I != "object") {
          if (I != G[Z]) G[Z] = I
        }
      } if (Q.childNodes) G.childNodes = new hh;
    switch (G.ownerDocument = A, G.nodeType) {
      case RP:
        var Y = Q.attributes,
          J = G.attributes = new E61,
          W = Y.length;
        J._ownerElement = G;
        for (var X = 0; X < W; X++) G.setAttributeNode(y80(A, Y.item(X), !0));
        break;
      case gJA:
        B = !0
    }
    if (B) {
      var V = Q.firstChild;
      while (V) G.appendChild(y80(A, V, B)), V = V.nextSibling
    }
    return G
  }

  function AR2(A, Q, B) {
    A[Q] = B
  }
  try {
    if (Object.defineProperty) {
      let A = function(Q) {
        switch (Q.nodeType) {
          case RP:
          case gh:
            var B = [];
            Q = Q.firstChild;
            while (Q) {
              if (Q.nodeType !== 7 && Q.nodeType !== 8) B.push(A(Q));
              Q = Q.nextSibling
            }
            return B.join("");
          default:
            return Q.nodeValue
        }
      };
      _b5 = A, Object.defineProperty(uJA.prototype, "length", {
        get: function() {
          return x80(this), this.$$length
        }
      }), Object.defineProperty(UG.prototype, "textContent", {
        get: function() {
          return A(this)
        },
        set: function(Q) {
          switch (this.nodeType) {
            case RP:
            case gh:
              while (this.firstChild) this.removeChild(this.firstChild);
              if (Q || String(Q)) this.appendChild(this.ownerDocument.createTextNode(Q));
              break;
            default:
              this.data = Q, this.value = Q, this.nodeValue = Q
          }
        }
      }), AR2 = function(Q, B, G) {
        Q["$$" + B] = G
      }
    }
  } catch (A) {}
  var _b5;
  kb5.DocumentType = $61;
  kb5.DOMException = fW;
  kb5.DOMImplementation = pO2;
  kb5.Element = H0A;
  kb5.Node = UG;
  kb5.NodeList = hh;
  kb5.XMLSerializer = oO2
})
// @from(Start 11338984, End 11356541)
Tq = z((qT2, NT2) => {
  (function() {
    var A, Q, B, G, Z, I, Y, J, W, X, V, F, K, D, H, C, E, U, q = {}.hasOwnProperty,
      w = [].splice;
    ({
      isObject: U,
      isFunction: E,
      isEmpty: C,
      getValue: H
    } = Uy()), J = null, B = null, G = null, Z = null, I = null, K = null, D = null, F = null, Y = null, Q = null, V = null, W = null, A = null, NT2.exports = X = function() {
      class N {
        constructor(R) {
          if (this.parent = R, this.parent) this.options = this.parent.options, this.stringify = this.parent.stringify;
          if (this.value = null, this.children = [], this.baseURI = null, !J) J = O61(), B = R61(), G = T61(), Z = P61(), I = y61(), K = x61(), D = v61(), F = b61(), Y = a80(), Q = hW(), V = zT2(), W = M61(), A = wT2()
        }
        setParent(R) {
          var T, y, v, x, p;
          if (this.parent = R, R) this.options = R.options, this.stringify = R.stringify;
          x = this.children, p = [];
          for (y = 0, v = x.length; y < v; y++) T = x[y], p.push(T.setParent(this));
          return p
        }
        element(R, T, y) {
          var v, x, p, u, e, l, k, m, o;
          if (l = null, T === null && y == null)[T, y] = [{}, null];
          if (T == null) T = {};
          if (T = H(T), !U(T))[y, T] = [T, y];
          if (R != null) R = H(R);
          if (Array.isArray(R))
            for (p = 0, k = R.length; p < k; p++) x = R[p], l = this.element(x);
          else if (E(R)) l = this.element(R.apply());
          else if (U(R))
            for (e in R) {
              if (!q.call(R, e)) continue;
              if (o = R[e], E(o)) o = o.apply();
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && e.indexOf(this.stringify.convertAttKey) === 0) l = this.attribute(e.substr(this.stringify.convertAttKey.length), o);
              else if (!this.options.separateArrayItems && Array.isArray(o) && C(o)) l = this.dummy();
              else if (U(o) && C(o)) l = this.element(e);
              else if (!this.options.keepNullNodes && o == null) l = this.dummy();
              else if (!this.options.separateArrayItems && Array.isArray(o))
                for (u = 0, m = o.length; u < m; u++) x = o[u], v = {}, v[e] = x, l = this.element(v);
              else if (U(o))
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && e.indexOf(this.stringify.convertTextKey) === 0) l = this.element(o);
                else l = this.element(e), l.element(o);
              else l = this.element(e, o)
            } else if (!this.options.keepNullNodes && y === null) l = this.dummy();
            else if (!this.options.ignoreDecorators && this.stringify.convertTextKey && R.indexOf(this.stringify.convertTextKey) === 0) l = this.text(y);
          else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && R.indexOf(this.stringify.convertCDataKey) === 0) l = this.cdata(y);
          else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && R.indexOf(this.stringify.convertCommentKey) === 0) l = this.comment(y);
          else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && R.indexOf(this.stringify.convertRawKey) === 0) l = this.raw(y);
          else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && R.indexOf(this.stringify.convertPIKey) === 0) l = this.instruction(R.substr(this.stringify.convertPIKey.length), y);
          else l = this.node(R, T, y);
          if (l == null) throw Error("Could not create any elements with: " + R + ". " + this.debugInfo());
          return l
        }
        insertBefore(R, T, y) {
          var v, x, p, u, e;
          if (R != null ? R.type : void 0) {
            if (p = R, u = T, p.setParent(this), u) x = children.indexOf(u), e = children.splice(x), children.push(p), Array.prototype.push.apply(children, e);
            else children.push(p);
            return p
          } else {
            if (this.isRoot) throw Error("Cannot insert elements at root level. " + this.debugInfo(R));
            return x = this.parent.children.indexOf(this), e = this.parent.children.splice(x), v = this.parent.element(R, T, y), Array.prototype.push.apply(this.parent.children, e), v
          }
        }
        insertAfter(R, T, y) {
          var v, x, p;
          if (this.isRoot) throw Error("Cannot insert elements at root level. " + this.debugInfo(R));
          return x = this.parent.children.indexOf(this), p = this.parent.children.splice(x + 1), v = this.parent.element(R, T, y), Array.prototype.push.apply(this.parent.children, p), v
        }
        remove() {
          var R, T;
          if (this.isRoot) throw Error("Cannot remove the root element. " + this.debugInfo());
          return R = this.parent.children.indexOf(this), w.apply(this.parent.children, [R, R - R + 1].concat(T = [])), this.parent
        }
        node(R, T, y) {
          var v;
          if (R != null) R = H(R);
          if (T || (T = {}), T = H(T), !U(T))[y, T] = [T, y];
          if (v = new J(this, R, T), y != null) v.text(y);
          return this.children.push(v), v
        }
        text(R) {
          var T;
          if (U(R)) this.element(R);
          return T = new D(this, R), this.children.push(T), this
        }
        cdata(R) {
          var T = new B(this, R);
          return this.children.push(T), this
        }
        comment(R) {
          var T = new G(this, R);
          return this.children.push(T), this
        }
        commentBefore(R) {
          var T, y, v;
          return y = this.parent.children.indexOf(this), v = this.parent.children.splice(y), T = this.parent.comment(R), Array.prototype.push.apply(this.parent.children, v), this
        }
        commentAfter(R) {
          var T, y, v;
          return y = this.parent.children.indexOf(this), v = this.parent.children.splice(y + 1), T = this.parent.comment(R), Array.prototype.push.apply(this.parent.children, v), this
        }
        raw(R) {
          var T = new K(this, R);
          return this.children.push(T), this
        }
        dummy() {
          var R = new Y(this);
          return R
        }
        instruction(R, T) {
          var y, v, x, p, u;
          if (R != null) R = H(R);
          if (T != null) T = H(T);
          if (Array.isArray(R))
            for (p = 0, u = R.length; p < u; p++) y = R[p], this.instruction(y);
          else if (U(R))
            for (y in R) {
              if (!q.call(R, y)) continue;
              v = R[y], this.instruction(y, v)
            } else {
              if (E(T)) T = T.apply();
              x = new F(this, R, T), this.children.push(x)
            }
          return this
        }
        instructionBefore(R, T) {
          var y, v, x;
          return v = this.parent.children.indexOf(this), x = this.parent.children.splice(v), y = this.parent.instruction(R, T), Array.prototype.push.apply(this.parent.children, x), this
        }
        instructionAfter(R, T) {
          var y, v, x;
          return v = this.parent.children.indexOf(this), x = this.parent.children.splice(v + 1), y = this.parent.instruction(R, T), Array.prototype.push.apply(this.parent.children, x), this
        }
        declaration(R, T, y) {
          var v, x;
          if (v = this.document(), x = new Z(v, R, T, y), v.children.length === 0) v.children.unshift(x);
          else if (v.children[0].type === Q.Declaration) v.children[0] = x;
          else v.children.unshift(x);
          return v.root() || v
        }
        dtd(R, T) {
          var y, v, x, p, u, e, l, k, m, o;
          v = this.document(), x = new I(v, R, T), m = v.children;
          for (p = u = 0, l = m.length; u < l; p = ++u)
            if (y = m[p], y.type === Q.DocType) return v.children[p] = x, x;
          o = v.children;
          for (p = e = 0, k = o.length; e < k; p = ++e)
            if (y = o[p], y.isRoot) return v.children.splice(p, 0, x), x;
          return v.children.push(x), x
        }
        up() {
          if (this.isRoot) throw Error("The root node has no parent. Use doc() if you need to get the document object.");
          return this.parent
        }
        root() {
          var R = this;
          while (R)
            if (R.type === Q.Document) return R.rootObject;
            else if (R.isRoot) return R;
          else R = R.parent
        }
        document() {
          var R = this;
          while (R)
            if (R.type === Q.Document) return R;
            else R = R.parent
        }
        end(R) {
          return this.document().end(R)
        }
        prev() {
          var R = this.parent.children.indexOf(this);
          if (R < 1) throw Error("Already at the first node. " + this.debugInfo());
          return this.parent.children[R - 1]
        }
        next() {
          var R = this.parent.children.indexOf(this);
          if (R === -1 || R === this.parent.children.length - 1) throw Error("Already at the last node. " + this.debugInfo());
          return this.parent.children[R + 1]
        }
        importDocument(R) {
          var T, y, v, x, p;
          if (y = R.root().clone(), y.parent = this, y.isRoot = !1, this.children.push(y), this.type === Q.Document) {
            if (y.isRoot = !0, y.documentObject = this, this.rootObject = y, this.children) {
              p = this.children;
              for (v = 0, x = p.length; v < x; v++)
                if (T = p[v], T.type === Q.DocType) {
                  T.name = y.name;
                  break
                }
            }
          }
          return this
        }
        debugInfo(R) {
          var T, y;
          if (R = R || this.name, R == null && !((T = this.parent) != null ? T.name : void 0)) return "";
          else if (R == null) return "parent: <" + this.parent.name + ">";
          else if (!((y = this.parent) != null ? y.name : void 0)) return "node: <" + R + ">";
          else return "node: <" + R + ">, parent: <" + this.parent.name + ">"
        }
        ele(R, T, y) {
          return this.element(R, T, y)
        }
        nod(R, T, y) {
          return this.node(R, T, y)
        }
        txt(R) {
          return this.text(R)
        }
        dat(R) {
          return this.cdata(R)
        }
        com(R) {
          return this.comment(R)
        }
        ins(R, T) {
          return this.instruction(R, T)
        }
        doc() {
          return this.document()
        }
        dec(R, T, y) {
          return this.declaration(R, T, y)
        }
        e(R, T, y) {
          return this.element(R, T, y)
        }
        n(R, T, y) {
          return this.node(R, T, y)
        }
        t(R) {
          return this.text(R)
        }
        d(R) {
          return this.cdata(R)
        }
        c(R) {
          return this.comment(R)
        }
        r(R) {
          return this.raw(R)
        }
        i(R, T) {
          return this.instruction(R, T)
        }
        u() {
          return this.up()
        }
        importXMLBuilder(R) {
          return this.importDocument(R)
        }
        attribute(R, T) {
          throw Error("attribute() applies to element nodes only.")
        }
        att(R, T) {
          return this.attribute(R, T)
        }
        a(R, T) {
          return this.attribute(R, T)
        }
        removeAttribute(R) {
          throw Error("attribute() applies to element nodes only.")
        }
        replaceChild(R, T) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        removeChild(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        appendChild(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        hasChildNodes() {
          return this.children.length !== 0
        }
        cloneNode(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        normalize() {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        isSupported(R, T) {
          return !0
        }
        hasAttributes() {
          return this.attribs.length !== 0
        }
        compareDocumentPosition(R) {
          var T, y;
          if (T = this, T === R) return 0;
          else if (this.document() !== R.document()) {
            if (y = A.Disconnected | A.ImplementationSpecific, Math.random() < 0.5) y |= A.Preceding;
            else y |= A.Following;
            return y
          } else if (T.isAncestor(R)) return A.Contains | A.Preceding;
          else if (T.isDescendant(R)) return A.Contains | A.Following;
          else if (T.isPreceding(R)) return A.Preceding;
          else return A.Following
        }
        isSameNode(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        lookupPrefix(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        isDefaultNamespace(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        lookupNamespaceURI(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        isEqualNode(R) {
          var T, y, v;
          if (R.nodeType !== this.nodeType) return !1;
          if (R.children.length !== this.children.length) return !1;
          for (T = y = 0, v = this.children.length - 1; 0 <= v ? y <= v : y >= v; T = 0 <= v ? ++y : --y)
            if (!this.children[T].isEqualNode(R.children[T])) return !1;
          return !0
        }
        getFeature(R, T) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        setUserData(R, T, y) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        getUserData(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        contains(R) {
          if (!R) return !1;
          return R === this || this.isDescendant(R)
        }
        isDescendant(R) {
          var T, y, v, x, p;
          p = this.children;
          for (v = 0, x = p.length; v < x; v++) {
            if (T = p[v], R === T) return !0;
            if (y = T.isDescendant(R), y) return !0
          }
          return !1
        }
        isAncestor(R) {
          return R.isDescendant(this)
        }
        isPreceding(R) {
          var T, y;
          if (T = this.treePosition(R), y = this.treePosition(this), T === -1 || y === -1) return !1;
          else return T < y
        }
        isFollowing(R) {
          var T, y;
          if (T = this.treePosition(R), y = this.treePosition(this), T === -1 || y === -1) return !1;
          else return T > y
        }
        treePosition(R) {
          var T, y;
          if (y = 0, T = !1, this.foreachTreeNode(this.document(), function(v) {
              if (y++, !T && v === R) return T = !0
            }), T) return y;
          else return -1
        }
        foreachTreeNode(R, T) {
          var y, v, x, p, u;
          R || (R = this.document()), p = R.children;
          for (v = 0, x = p.length; v < x; v++)
            if (y = p[v], u = T(y)) return u;
            else if (u = this.foreachTreeNode(y, T), u) return u
        }
      }
      return Object.defineProperty(N.prototype, "nodeName", {
        get: function() {
          return this.name
        }
      }), Object.defineProperty(N.prototype, "nodeType", {
        get: function() {
          return this.type
        }
      }), Object.defineProperty(N.prototype, "nodeValue", {
        get: function() {
          return this.value
        }
      }), Object.defineProperty(N.prototype, "parentNode", {
        get: function() {
          return this.parent
        }
      }), Object.defineProperty(N.prototype, "childNodes", {
        get: function() {
          if (!this.childNodeList || !this.childNodeList.nodes) this.childNodeList = new V(this.children);
          return this.childNodeList
        }
      }), Object.defineProperty(N.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null
        }
      }), Object.defineProperty(N.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null
        }
      }), Object.defineProperty(N.prototype, "previousSibling", {
        get: function() {
          var R = this.parent.children.indexOf(this);
          return this.parent.children[R - 1] || null
        }
      }), Object.defineProperty(N.prototype, "nextSibling", {
        get: function() {
          var R = this.parent.children.indexOf(this);
          return this.parent.children[R + 1] || null
        }
      }), Object.defineProperty(N.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null
        }
      }), Object.defineProperty(N.prototype, "textContent", {
        get: function() {
          var R, T, y, v, x;
          if (this.nodeType === Q.Element || this.nodeType === Q.DocumentFragment) {
            x = "", v = this.children;
            for (T = 0, y = v.length; T < y; T++)
              if (R = v[T], R.textContent) x += R.textContent;
            return x
          } else return null
        },
        set: function(R) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
      }), N
    }.call(this)
  }).call(qT2)
})
// @from(Start 11356547, End 11362376)
s80 = z((LT2, MT2) => {
  (function() {
    var A, Q = {}.hasOwnProperty;
    MT2.exports = A = function() {
      class B {
        constructor(G) {
          var Z, I, Y;
          if (this.assertLegalChar = this.assertLegalChar.bind(this), this.assertLegalName = this.assertLegalName.bind(this), G || (G = {}), this.options = G, !this.options.version) this.options.version = "1.0";
          I = G.stringify || {};
          for (Z in I) {
            if (!Q.call(I, Z)) continue;
            Y = I[Z], this[Z] = Y
          }
        }
        name(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalName("" + G || "")
        }
        text(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar(this.textEscape("" + G || ""))
        }
        cdata(G) {
          if (this.options.noValidation) return G;
          return G = "" + G || "", G = G.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(G)
        }
        comment(G) {
          if (this.options.noValidation) return G;
          if (G = "" + G || "", G.match(/--/)) throw Error("Comment text cannot contain double-hypen: " + G);
          return this.assertLegalChar(G)
        }
        raw(G) {
          if (this.options.noValidation) return G;
          return "" + G || ""
        }
        attValue(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar(this.attEscape(G = "" + G || ""))
        }
        insTarget(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        insValue(G) {
          if (this.options.noValidation) return G;
          if (G = "" + G || "", G.match(/\?>/)) throw Error("Invalid processing instruction value: " + G);
          return this.assertLegalChar(G)
        }
        xmlVersion(G) {
          if (this.options.noValidation) return G;
          if (G = "" + G || "", !G.match(/1\.[0-9]+/)) throw Error("Invalid version number: " + G);
          return G
        }
        xmlEncoding(G) {
          if (this.options.noValidation) return G;
          if (G = "" + G || "", !G.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw Error("Invalid encoding: " + G);
          return this.assertLegalChar(G)
        }
        xmlStandalone(G) {
          if (this.options.noValidation) return G;
          if (G) return "yes";
          else return "no"
        }
        dtdPubID(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        dtdSysID(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        dtdElementValue(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        dtdAttType(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        dtdAttDefault(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        dtdEntityValue(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        dtdNData(G) {
          if (this.options.noValidation) return G;
          return this.assertLegalChar("" + G || "")
        }
        assertLegalChar(G) {
          var Z, I;
          if (this.options.noValidation) return G;
          if (this.options.version === "1.0") {
            if (Z = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, this.options.invalidCharReplacement !== void 0) G = G.replace(Z, this.options.invalidCharReplacement);
            else if (I = G.match(Z)) throw Error(`Invalid character in string: ${G} at index ${I.index}`)
          } else if (this.options.version === "1.1") {
            if (Z = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g, this.options.invalidCharReplacement !== void 0) G = G.replace(Z, this.options.invalidCharReplacement);
            else if (I = G.match(Z)) throw Error(`Invalid character in string: ${G} at index ${I.index}`)
          }
          return G
        }
        assertLegalName(G) {
          var Z;
          if (this.options.noValidation) return G;
          if (G = this.assertLegalChar(G), Z = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, !G.match(Z)) throw Error(`Invalid character in name: ${G}`);
          return G
        }
        textEscape(G) {
          var Z;
          if (this.options.noValidation) return G;
          return Z = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g, G.replace(Z, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;")
        }
        attEscape(G) {
          var Z;
          if (this.options.noValidation) return G;
          return Z = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g, G.replace(Z, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;")
        }
      }
      return B.prototype.convertAttKey = "@", B.prototype.convertPIKey = "?", B.prototype.convertTextKey = "#text", B.prototype.convertCDataKey = "#cdata", B.prototype.convertCommentKey = "#comment", B.prototype.convertRawKey = "#raw", B
    }.call(this)
  }).call(LT2)
})
// @from(Start 11362382, End 11362536)
jRA = z((OT2, RT2) => {
  (function() {
    RT2.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    }
  }).call(OT2)
})
// @from(Start 11362542, End 11372731)
r80 = z((TT2, PT2) => {
  (function() {
    var A, Q, B, G, Z, I, Y, J, W, X, V, F, K, D, H, C, E, U = {}.hasOwnProperty;
    ({
      assign: E
    } = Uy()), A = hW(), W = P61(), X = y61(), B = R61(), G = T61(), F = O61(), D = x61(), H = v61(), K = b61(), V = a80(), Z = j61(), I = _61(), Y = S61(), J = k61(), Q = jRA(), PT2.exports = C = class {
      constructor(w) {
        var N, R, T;
        w || (w = {}), this.options = w, R = w.writer || {};
        for (N in R) {
          if (!U.call(R, N)) continue;
          T = R[N], this["_" + N] = this[N], this[N] = T
        }
      }
      filterOptions(w) {
        var N, R, T, y, v, x, p, u, e;
        if (w || (w = {}), w = E({}, this.options, w), N = {
            writer: this
          }, N.pretty = w.pretty || !1, N.allowEmpty = w.allowEmpty || !1, N.indent = (R = w.indent) != null ? R : "  ", N.newline = (T = w.newline) != null ? T : `
`, N.offset = (y = w.offset) != null ? y : 0, N.width = (v = w.width) != null ? v : 0, N.dontPrettyTextNodes = (x = (p = w.dontPrettyTextNodes) != null ? p : w.dontprettytextnodes) != null ? x : 0, N.spaceBeforeSlash = (u = (e = w.spaceBeforeSlash) != null ? e : w.spacebeforeslash) != null ? u : "", N.spaceBeforeSlash === !0) N.spaceBeforeSlash = " ";
        return N.suppressPrettyCount = 0, N.user = {}, N.state = Q.None, N
      }
      indent(w, N, R) {
        var T;
        if (!N.pretty || N.suppressPrettyCount) return "";
        else if (N.pretty) {
          if (T = (R || 0) + N.offset + 1, T > 0) return Array(T).join(N.indent)
        }
        return ""
      }
      endline(w, N, R) {
        if (!N.pretty || N.suppressPrettyCount) return "";
        else return N.newline
      }
      attribute(w, N, R) {
        var T;
        if (this.openAttribute(w, N, R), N.pretty && N.width > 0) T = w.name + '="' + w.value + '"';
        else T = " " + w.name + '="' + w.value + '"';
        return this.closeAttribute(w, N, R), T
      }
      cdata(w, N, R) {
        var T;
        return this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<![CDATA[", N.state = Q.InsideTag, T += w.value, N.state = Q.CloseTag, T += "]]>" + this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      comment(w, N, R) {
        var T;
        return this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<!-- ", N.state = Q.InsideTag, T += w.value, N.state = Q.CloseTag, T += " -->" + this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      declaration(w, N, R) {
        var T;
        if (this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<?xml", N.state = Q.InsideTag, T += ' version="' + w.version + '"', w.encoding != null) T += ' encoding="' + w.encoding + '"';
        if (w.standalone != null) T += ' standalone="' + w.standalone + '"';
        return N.state = Q.CloseTag, T += N.spaceBeforeSlash + "?>", T += this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      docType(w, N, R) {
        var T, y, v, x, p;
        if (R || (R = 0), this.openNode(w, N, R), N.state = Q.OpenTag, x = this.indent(w, N, R), x += "<!DOCTYPE " + w.root().name, w.pubID && w.sysID) x += ' PUBLIC "' + w.pubID + '" "' + w.sysID + '"';
        else if (w.sysID) x += ' SYSTEM "' + w.sysID + '"';
        if (w.children.length > 0) {
          x += " [", x += this.endline(w, N, R), N.state = Q.InsideTag, p = w.children;
          for (y = 0, v = p.length; y < v; y++) T = p[y], x += this.writeChildNode(T, N, R + 1);
          N.state = Q.CloseTag, x += "]"
        }
        return N.state = Q.CloseTag, x += N.spaceBeforeSlash + ">", x += this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), x
      }
      element(w, N, R) {
        var T, y, v, x, p, u, e, l, k, m, o, IA, FA, zA, NA, OA, mA, wA, qA;
        if (R || (R = 0), IA = !1, this.openNode(w, N, R), N.state = Q.OpenTag, FA = this.indent(w, N, R) + "<" + w.name, N.pretty && N.width > 0) {
          l = FA.length, NA = w.attribs;
          for (o in NA) {
            if (!U.call(NA, o)) continue;
            if (T = NA[o], zA = this.attribute(T, N, R), y = zA.length, l + y > N.width) qA = this.indent(w, N, R + 1) + zA, FA += this.endline(w, N, R) + qA, l = qA.length;
            else qA = " " + zA, FA += qA, l += qA.length
          }
        } else {
          OA = w.attribs;
          for (o in OA) {
            if (!U.call(OA, o)) continue;
            T = OA[o], FA += this.attribute(T, N, R)
          }
        }
        if (x = w.children.length, p = x === 0 ? null : w.children[0], x === 0 || w.children.every(function(KA) {
            return (KA.type === A.Text || KA.type === A.Raw || KA.type === A.CData) && KA.value === ""
          }))
          if (N.allowEmpty) FA += ">", N.state = Q.CloseTag, FA += "</" + w.name + ">" + this.endline(w, N, R);
          else N.state = Q.CloseTag, FA += N.spaceBeforeSlash + "/>" + this.endline(w, N, R);
        else if (N.pretty && x === 1 && (p.type === A.Text || p.type === A.Raw || p.type === A.CData) && p.value != null) FA += ">", N.state = Q.InsideTag, N.suppressPrettyCount++, IA = !0, FA += this.writeChildNode(p, N, R + 1), N.suppressPrettyCount--, IA = !1, N.state = Q.CloseTag, FA += "</" + w.name + ">" + this.endline(w, N, R);
        else {
          if (N.dontPrettyTextNodes) {
            mA = w.children;
            for (u = 0, k = mA.length; u < k; u++)
              if (v = mA[u], (v.type === A.Text || v.type === A.Raw || v.type === A.CData) && v.value != null) {
                N.suppressPrettyCount++, IA = !0;
                break
              }
          }
          FA += ">" + this.endline(w, N, R), N.state = Q.InsideTag, wA = w.children;
          for (e = 0, m = wA.length; e < m; e++) v = wA[e], FA += this.writeChildNode(v, N, R + 1);
          if (N.state = Q.CloseTag, FA += this.indent(w, N, R) + "</" + w.name + ">", IA) N.suppressPrettyCount--;
          FA += this.endline(w, N, R), N.state = Q.None
        }
        return this.closeNode(w, N, R), FA
      }
      writeChildNode(w, N, R) {
        switch (w.type) {
          case A.CData:
            return this.cdata(w, N, R);
          case A.Comment:
            return this.comment(w, N, R);
          case A.Element:
            return this.element(w, N, R);
          case A.Raw:
            return this.raw(w, N, R);
          case A.Text:
            return this.text(w, N, R);
          case A.ProcessingInstruction:
            return this.processingInstruction(w, N, R);
          case A.Dummy:
            return "";
          case A.Declaration:
            return this.declaration(w, N, R);
          case A.DocType:
            return this.docType(w, N, R);
          case A.AttributeDeclaration:
            return this.dtdAttList(w, N, R);
          case A.ElementDeclaration:
            return this.dtdElement(w, N, R);
          case A.EntityDeclaration:
            return this.dtdEntity(w, N, R);
          case A.NotationDeclaration:
            return this.dtdNotation(w, N, R);
          default:
            throw Error("Unknown XML node type: " + w.constructor.name)
        }
      }
      processingInstruction(w, N, R) {
        var T;
        if (this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<?", N.state = Q.InsideTag, T += w.target, w.value) T += " " + w.value;
        return N.state = Q.CloseTag, T += N.spaceBeforeSlash + "?>", T += this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      raw(w, N, R) {
        var T;
        return this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R), N.state = Q.InsideTag, T += w.value, N.state = Q.CloseTag, T += this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      text(w, N, R) {
        var T;
        return this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R), N.state = Q.InsideTag, T += w.value, N.state = Q.CloseTag, T += this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      dtdAttList(w, N, R) {
        var T;
        if (this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<!ATTLIST", N.state = Q.InsideTag, T += " " + w.elementName + " " + w.attributeName + " " + w.attributeType, w.defaultValueType !== "#DEFAULT") T += " " + w.defaultValueType;
        if (w.defaultValue) T += ' "' + w.defaultValue + '"';
        return N.state = Q.CloseTag, T += N.spaceBeforeSlash + ">" + this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      dtdElement(w, N, R) {
        var T;
        return this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<!ELEMENT", N.state = Q.InsideTag, T += " " + w.name + " " + w.value, N.state = Q.CloseTag, T += N.spaceBeforeSlash + ">" + this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      dtdEntity(w, N, R) {
        var T;
        if (this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<!ENTITY", N.state = Q.InsideTag, w.pe) T += " %";
        if (T += " " + w.name, w.value) T += ' "' + w.value + '"';
        else {
          if (w.pubID && w.sysID) T += ' PUBLIC "' + w.pubID + '" "' + w.sysID + '"';
          else if (w.sysID) T += ' SYSTEM "' + w.sysID + '"';
          if (w.nData) T += " NDATA " + w.nData
        }
        return N.state = Q.CloseTag, T += N.spaceBeforeSlash + ">" + this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      dtdNotation(w, N, R) {
        var T;
        if (this.openNode(w, N, R), N.state = Q.OpenTag, T = this.indent(w, N, R) + "<!NOTATION", N.state = Q.InsideTag, T += " " + w.name, w.pubID && w.sysID) T += ' PUBLIC "' + w.pubID + '" "' + w.sysID + '"';
        else if (w.pubID) T += ' PUBLIC "' + w.pubID + '"';
        else if (w.sysID) T += ' SYSTEM "' + w.sysID + '"';
        return N.state = Q.CloseTag, T += N.spaceBeforeSlash + ">" + this.endline(w, N, R), N.state = Q.None, this.closeNode(w, N, R), T
      }
      openNode(w, N, R) {}
      closeNode(w, N, R) {}
      openAttribute(w, N, R) {}
      closeAttribute(w, N, R) {}
    }
  }).call(TT2)
})
// @from(Start 11372737, End 11373239)
f61 = z((jT2, ST2) => {
  (function() {
    var A, Q;
    Q = r80(), ST2.exports = A = class extends Q {
      constructor(G) {
        super(G)
      }
      document(G, Z) {
        var I, Y, J, W, X;
        Z = this.filterOptions(Z), W = "", X = G.children;
        for (Y = 0, J = X.length; Y < J; Y++) I = X[Y], W += this.writeChildNode(I, Z, 0);
        if (Z.pretty && W.slice(-Z.newline.length) === Z.newline) W = W.slice(0, -Z.newline.length);
        return W
      }
    }
  }).call(jT2)
})
// @from(Start 11373245, End 11378902)
o80 = z((_T2, kT2) => {
  (function() {
    var A, Q, B, G, Z, I, Y, J;
    ({
      isPlainObject: J
    } = Uy()), B = i80(), Q = xR2(), Z = Tq(), A = hW(), Y = s80(), I = f61(), kT2.exports = G = function() {
      class W extends Z {
        constructor(X) {
          super(null);
          if (this.name = "#document", this.type = A.Document, this.documentURI = null, this.domConfig = new Q, X || (X = {}), !X.writer) X.writer = new I;
          this.options = X, this.stringify = new Y(X)
        }
        end(X) {
          var V = {};
          if (!X) X = this.options.writer;
          else if (J(X)) V = X, X = this.options.writer;
          return X.document(this, X.filterOptions(V))
        }
        toString(X) {
          return this.options.writer.document(this, this.options.writer.filterOptions(X))
        }
        createElement(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createDocumentFragment() {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createTextNode(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createComment(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createCDATASection(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createProcessingInstruction(X, V) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createAttribute(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createEntityReference(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        getElementsByTagName(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        importNode(X, V) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createElementNS(X, V) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createAttributeNS(X, V) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        getElementsByTagNameNS(X, V) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        getElementById(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        adoptNode(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        normalizeDocument() {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        renameNode(X, V, F) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        getElementsByClassName(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createEvent(X) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createRange() {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createNodeIterator(X, V, F) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
        createTreeWalker(X, V, F) {
          throw Error("This DOM method is not implemented." + this.debugInfo())
        }
      }
      return Object.defineProperty(W.prototype, "implementation", {
        value: new B
      }), Object.defineProperty(W.prototype, "doctype", {
        get: function() {
          var X, V, F, K;
          K = this.children;
          for (V = 0, F = K.length; V < F; V++)
            if (X = K[V], X.type === A.DocType) return X;
          return null
        }
      }), Object.defineProperty(W.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null
        }
      }), Object.defineProperty(W.prototype, "inputEncoding", {
        get: function() {
          return null
        }
      }), Object.defineProperty(W.prototype, "strictErrorChecking", {
        get: function() {
          return !1
        }
      }), Object.defineProperty(W.prototype, "xmlEncoding", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === A.Declaration) return this.children[0].encoding;
          else return null
        }
      }), Object.defineProperty(W.prototype, "xmlStandalone", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === A.Declaration) return this.children[0].standalone === "yes";
          else return !1
        }
      }), Object.defineProperty(W.prototype, "xmlVersion", {
        get: function() {
          if (this.children.length !== 0 && this.children[0].type === A.Declaration) return this.children[0].version;
          else return "1.0"
        }
      }), Object.defineProperty(W.prototype, "URL", {
        get: function() {
          return this.documentURI
        }
      }), Object.defineProperty(W.prototype, "origin", {
        get: function() {
          return null
        }
      }), Object.defineProperty(W.prototype, "compatMode", {
        get: function() {
          return null
        }
      }), Object.defineProperty(W.prototype, "characterSet", {
        get: function() {
          return null
        }
      }), Object.defineProperty(W.prototype, "contentType", {
        get: function() {
          return null
        }
      }), W
    }.call(this)
  }).call(_T2)
})
// @from(Start 11378908, End 11390376)
vT2 = z((yT2, xT2) => {
  (function() {
    var A, Q, B, G, Z, I, Y, J, W, X, V, F, K, D, H, C, E, U, q, w, N, R, T, y = {}.hasOwnProperty;
    ({
      isObject: R,
      isFunction: N,
      isPlainObject: T,
      getValue: w
    } = Uy()), A = hW(), F = o80(), D = O61(), G = R61(), Z = T61(), C = x61(), q = v61(), H = b61(), X = P61(), V = y61(), I = j61(), J = S61(), Y = _61(), W = k61(), B = n80(), U = s80(), E = f61(), Q = jRA(), xT2.exports = K = class {
      constructor(x, p, u) {
        var e;
        if (this.name = "?xml", this.type = A.Document, x || (x = {}), e = {}, !x.writer) x.writer = new E;
        else if (T(x.writer)) e = x.writer, x.writer = new E;
        this.options = x, this.writer = x.writer, this.writerOptions = this.writer.filterOptions(e), this.stringify = new U(x), this.onDataCallback = p || function() {}, this.onEndCallback = u || function() {}, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null
      }
      createChildNode(x) {
        var p, u, e, l, k, m, o, IA;
        switch (x.type) {
          case A.CData:
            this.cdata(x.value);
            break;
          case A.Comment:
            this.comment(x.value);
            break;
          case A.Element:
            e = {}, o = x.attribs;
            for (u in o) {
              if (!y.call(o, u)) continue;
              p = o[u], e[u] = p.value
            }
            this.node(x.name, e);
            break;
          case A.Dummy:
            this.dummy();
            break;
          case A.Raw:
            this.raw(x.value);
            break;
          case A.Text:
            this.text(x.value);
            break;
          case A.ProcessingInstruction:
            this.instruction(x.target, x.value);
            break;
          default:
            throw Error("This XML node type is not supported in a JS object: " + x.constructor.name)
        }
        IA = x.children;
        for (k = 0, m = IA.length; k < m; k++)
          if (l = IA[k], this.createChildNode(l), l.type === A.Element) this.up();
        return this
      }
      dummy() {
        return this
      }
      node(x, p, u) {
        if (x == null) throw Error("Missing node name.");
        if (this.root && this.currentLevel === -1) throw Error("Document can only have one root node. " + this.debugInfo(x));
        if (this.openCurrent(), x = w(x), p == null) p = {};
        if (p = w(p), !R(p))[u, p] = [p, u];
        if (this.currentNode = new D(this, x, p), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, u != null) this.text(u);
        return this
      }
      element(x, p, u) {
        var e, l, k, m, o, IA;
        if (this.currentNode && this.currentNode.type === A.DocType) this.dtdElement(...arguments);
        else if (Array.isArray(x) || R(x) || N(x)) {
          m = this.options.noValidation, this.options.noValidation = !0, IA = new F(this.options).element("TEMP_ROOT"), IA.element(x), this.options.noValidation = m, o = IA.children;
          for (l = 0, k = o.length; l < k; l++)
            if (e = o[l], this.createChildNode(e), e.type === A.Element) this.up()
        } else this.node(x, p, u);
        return this
      }
      attribute(x, p) {
        var u, e;
        if (!this.currentNode || this.currentNode.children) throw Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(x));
        if (x != null) x = w(x);
        if (R(x))
          for (u in x) {
            if (!y.call(x, u)) continue;
            e = x[u], this.attribute(u, e)
          } else {
            if (N(p)) p = p.apply();
            if (this.options.keepNullAttributes && p == null) this.currentNode.attribs[x] = new B(this, x, "");
            else if (p != null) this.currentNode.attribs[x] = new B(this, x, p)
          }
        return this
      }
      text(x) {
        var p;
        return this.openCurrent(), p = new q(this, x), this.onData(this.writer.text(p, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      cdata(x) {
        var p;
        return this.openCurrent(), p = new G(this, x), this.onData(this.writer.cdata(p, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      comment(x) {
        var p;
        return this.openCurrent(), p = new Z(this, x), this.onData(this.writer.comment(p, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      raw(x) {
        var p;
        return this.openCurrent(), p = new C(this, x), this.onData(this.writer.raw(p, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      instruction(x, p) {
        var u, e, l, k, m;
        if (this.openCurrent(), x != null) x = w(x);
        if (p != null) p = w(p);
        if (Array.isArray(x))
          for (u = 0, k = x.length; u < k; u++) e = x[u], this.instruction(e);
        else if (R(x))
          for (e in x) {
            if (!y.call(x, e)) continue;
            l = x[e], this.instruction(e, l)
          } else {
            if (N(p)) p = p.apply();
            m = new H(this, x, p), this.onData(this.writer.processingInstruction(m, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1)
          }
        return this
      }
      declaration(x, p, u) {
        var e;
        if (this.openCurrent(), this.documentStarted) throw Error("declaration() must be the first node.");
        return e = new X(this, x, p, u), this.onData(this.writer.declaration(e, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      doctype(x, p, u) {
        if (this.openCurrent(), x == null) throw Error("Missing root node name.");
        if (this.root) throw Error("dtd() must come before the root node.");
        return this.currentNode = new V(this, p, u), this.currentNode.rootNodeName = x, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this
      }
      dtdElement(x, p) {
        var u;
        return this.openCurrent(), u = new Y(this, x, p), this.onData(this.writer.dtdElement(u, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      attList(x, p, u, e, l) {
        var k;
        return this.openCurrent(), k = new I(this, x, p, u, e, l), this.onData(this.writer.dtdAttList(k, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      entity(x, p) {
        var u;
        return this.openCurrent(), u = new J(this, !1, x, p), this.onData(this.writer.dtdEntity(u, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      pEntity(x, p) {
        var u;
        return this.openCurrent(), u = new J(this, !0, x, p), this.onData(this.writer.dtdEntity(u, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      notation(x, p) {
        var u;
        return this.openCurrent(), u = new W(this, x, p), this.onData(this.writer.dtdNotation(u, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this
      }
      up() {
        if (this.currentLevel < 0) throw Error("The document node has no parent.");
        if (this.currentNode) {
          if (this.currentNode.children) this.closeNode(this.currentNode);
          else this.openNode(this.currentNode);
          this.currentNode = null
        } else this.closeNode(this.openTags[this.currentLevel]);
        return delete this.openTags[this.currentLevel], this.currentLevel--, this
      }
      end() {
        while (this.currentLevel >= 0) this.up();
        return this.onEnd()
      }
      openCurrent() {
        if (this.currentNode) return this.currentNode.children = !0, this.openNode(this.currentNode)
      }
      openNode(x) {
        var p, u, e, l;
        if (!x.isOpen) {
          if (!this.root && this.currentLevel === 0 && x.type === A.Element) this.root = x;
          if (u = "", x.type === A.Element) {
            this.writerOptions.state = Q.OpenTag, u = this.writer.indent(x, this.writerOptions, this.currentLevel) + "<" + x.name, l = x.attribs;
            for (e in l) {
              if (!y.call(l, e)) continue;
              p = l[e], u += this.writer.attribute(p, this.writerOptions, this.currentLevel)
            }
            u += (x.children ? ">" : "/>") + this.writer.endline(x, this.writerOptions, this.currentLevel), this.writerOptions.state = Q.InsideTag
          } else {
            if (this.writerOptions.state = Q.OpenTag, u = this.writer.indent(x, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + x.rootNodeName, x.pubID && x.sysID) u += ' PUBLIC "' + x.pubID + '" "' + x.sysID + '"';
            else if (x.sysID) u += ' SYSTEM "' + x.sysID + '"';
            if (x.children) u += " [", this.writerOptions.state = Q.InsideTag;
            else this.writerOptions.state = Q.CloseTag, u += ">";
            u += this.writer.endline(x, this.writerOptions, this.currentLevel)
          }
          return this.onData(u, this.currentLevel), x.isOpen = !0
        }
      }
      closeNode(x) {
        var p;
        if (!x.isClosed) {
          if (p = "", this.writerOptions.state = Q.CloseTag, x.type === A.Element) p = this.writer.indent(x, this.writerOptions, this.currentLevel) + "</" + x.name + ">" + this.writer.endline(x, this.writerOptions, this.currentLevel);
          else p = this.writer.indent(x, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(x, this.writerOptions, this.currentLevel);
          return this.writerOptions.state = Q.None, this.onData(p, this.currentLevel), x.isClosed = !0
        }
      }
      onData(x, p) {
        return this.documentStarted = !0, this.onDataCallback(x, p + 1)
      }
      onEnd() {
        return this.documentCompleted = !0, this.onEndCallback()
      }
      debugInfo(x) {
        if (x == null) return "";
        else return "node: <" + x + ">"
      }
      ele() {
        return this.element(...arguments)
      }
      nod(x, p, u) {
        return this.node(x, p, u)
      }
      txt(x) {
        return this.text(x)
      }
      dat(x) {
        return this.cdata(x)
      }
      com(x) {
        return this.comment(x)
      }
      ins(x, p) {
        return this.instruction(x, p)
      }
      dec(x, p, u) {
        return this.declaration(x, p, u)
      }
      dtd(x, p, u) {
        return this.doctype(x, p, u)
      }
      e(x, p, u) {
        return this.element(x, p, u)
      }
      n(x, p, u) {
        return this.node(x, p, u)
      }
      t(x) {
        return this.text(x)
      }
      d(x) {
        return this.cdata(x)
      }
      c(x) {
        return this.comment(x)
      }
      r(x) {
        return this.raw(x)
      }
      i(x, p) {
        return this.instruction(x, p)
      }
      att() {
        if (this.currentNode && this.currentNode.type === A.DocType) return this.attList(...arguments);
        else return this.attribute(...arguments)
      }
      a() {
        if (this.currentNode && this.currentNode.type === A.DocType) return this.attList(...arguments);
        else return this.attribute(...arguments)
      }
      ent(x, p) {
        return this.entity(x, p)
      }
      pent(x, p) {
        return this.pEntity(x, p)
      }
      not(x, p) {
        return this.notation(x, p)
      }
    }
  }).call(yT2)
})
// @from(Start 11390382, End 11394882)
hT2 = z((bT2, fT2) => {
  (function() {
    var A, Q, B, G, Z = {}.hasOwnProperty;
    A = hW(), G = r80(), Q = jRA(), fT2.exports = B = class extends G {
      constructor(Y, J) {
        super(J);
        this.stream = Y
      }
      endline(Y, J, W) {
        if (Y.isLastRootNode && J.state === Q.CloseTag) return "";
        else return super.endline(Y, J, W)
      }
      document(Y, J) {
        var W, X, V, F, K, D, H, C, E;
        H = Y.children;
        for (X = V = 0, K = H.length; V < K; X = ++V) W = H[X], W.isLastRootNode = X === Y.children.length - 1;
        J = this.filterOptions(J), C = Y.children, E = [];
        for (F = 0, D = C.length; F < D; F++) W = C[F], E.push(this.writeChildNode(W, J, 0));
        return E
      }
      cdata(Y, J, W) {
        return this.stream.write(super.cdata(Y, J, W))
      }
      comment(Y, J, W) {
        return this.stream.write(super.comment(Y, J, W))
      }
      declaration(Y, J, W) {
        return this.stream.write(super.declaration(Y, J, W))
      }
      docType(Y, J, W) {
        var X, V, F, K;
        if (W || (W = 0), this.openNode(Y, J, W), J.state = Q.OpenTag, this.stream.write(this.indent(Y, J, W)), this.stream.write("<!DOCTYPE " + Y.root().name), Y.pubID && Y.sysID) this.stream.write(' PUBLIC "' + Y.pubID + '" "' + Y.sysID + '"');
        else if (Y.sysID) this.stream.write(' SYSTEM "' + Y.sysID + '"');
        if (Y.children.length > 0) {
          this.stream.write(" ["), this.stream.write(this.endline(Y, J, W)), J.state = Q.InsideTag, K = Y.children;
          for (V = 0, F = K.length; V < F; V++) X = K[V], this.writeChildNode(X, J, W + 1);
          J.state = Q.CloseTag, this.stream.write("]")
        }
        return J.state = Q.CloseTag, this.stream.write(J.spaceBeforeSlash + ">"), this.stream.write(this.endline(Y, J, W)), J.state = Q.None, this.closeNode(Y, J, W)
      }
      element(Y, J, W) {
        var X, V, F, K, D, H, C, E, U, q, w, N, R, T, y, v;
        if (W || (W = 0), this.openNode(Y, J, W), J.state = Q.OpenTag, w = this.indent(Y, J, W) + "<" + Y.name, J.pretty && J.width > 0) {
          C = w.length, R = Y.attribs;
          for (U in R) {
            if (!Z.call(R, U)) continue;
            if (X = R[U], N = this.attribute(X, J, W), V = N.length, C + V > J.width) v = this.indent(Y, J, W + 1) + N, w += this.endline(Y, J, W) + v, C = v.length;
            else v = " " + N, w += v, C += v.length
          }
        } else {
          T = Y.attribs;
          for (U in T) {
            if (!Z.call(T, U)) continue;
            X = T[U], w += this.attribute(X, J, W)
          }
        }
        if (this.stream.write(w), K = Y.children.length, D = K === 0 ? null : Y.children[0], K === 0 || Y.children.every(function(x) {
            return (x.type === A.Text || x.type === A.Raw || x.type === A.CData) && x.value === ""
          }))
          if (J.allowEmpty) this.stream.write(">"), J.state = Q.CloseTag, this.stream.write("</" + Y.name + ">");
          else J.state = Q.CloseTag, this.stream.write(J.spaceBeforeSlash + "/>");
        else if (J.pretty && K === 1 && (D.type === A.Text || D.type === A.Raw || D.type === A.CData) && D.value != null) this.stream.write(">"), J.state = Q.InsideTag, J.suppressPrettyCount++, q = !0, this.writeChildNode(D, J, W + 1), J.suppressPrettyCount--, q = !1, J.state = Q.CloseTag, this.stream.write("</" + Y.name + ">");
        else {
          this.stream.write(">" + this.endline(Y, J, W)), J.state = Q.InsideTag, y = Y.children;
          for (H = 0, E = y.length; H < E; H++) F = y[H], this.writeChildNode(F, J, W + 1);
          J.state = Q.CloseTag, this.stream.write(this.indent(Y, J, W) + "</" + Y.name + ">")
        }
        return this.stream.write(this.endline(Y, J, W)), J.state = Q.None, this.closeNode(Y, J, W)
      }
      processingInstruction(Y, J, W) {
        return this.stream.write(super.processingInstruction(Y, J, W))
      }
      raw(Y, J, W) {
        return this.stream.write(super.raw(Y, J, W))
      }
      text(Y, J, W) {
        return this.stream.write(super.text(Y, J, W))
      }
      dtdAttList(Y, J, W) {
        return this.stream.write(super.dtdAttList(Y, J, W))
      }
      dtdElement(Y, J, W) {
        return this.stream.write(super.dtdElement(Y, J, W))
      }
      dtdEntity(Y, J, W) {
        return this.stream.write(super.dtdEntity(Y, J, W))
      }
      dtdNotation(Y, J, W) {
        return this.stream.write(super.dtdNotation(Y, J, W))
      }
    }
  }).call(bT2)
})
// @from(Start 11394888, End 11395750)
uT2 = z((gT2, Xn) => {
  (function() {
    var A, Q, B, G, Z, I, Y, J, W;
    ({
      assign: J,
      isFunction: W
    } = Uy()), B = i80(), G = o80(), Z = vT2(), Y = f61(), I = hT2(), A = hW(), Q = jRA(), gT2.create = function(X, V, F, K) {
      var D, H;
      if (X == null) throw Error("Root element needs a name.");
      if (K = J({}, V, F, K), D = new G(K), H = D.element(X), !K.headless) {
        if (D.declaration(K), K.pubID != null || K.sysID != null) D.dtd(K)
      }
      return H
    }, gT2.begin = function(X, V, F) {
      if (W(X))[V, F] = [X, V], X = {};
      if (V) return new Z(X, V, F);
      else return new G(X)
    }, gT2.stringWriter = function(X) {
      return new Y(X)
    }, gT2.streamWriter = function(X, V) {
      return new I(X, V)
    }, gT2.implementation = new B, gT2.nodeType = A, gT2.writerState = Q
  }).call(gT2)
})
// @from(Start 11395756, End 11397660)
cT2 = z((Nf5) => {
  var mT2 = Nl1(),
    Uf5 = uT2();
  Nf5.build = qf5;

  function $f5(A) {
    function Q(B) {
      return B < 10 ? "0" + B : B
    }
    return A.getUTCFullYear() + "-" + Q(A.getUTCMonth() + 1) + "-" + Q(A.getUTCDate()) + "T" + Q(A.getUTCHours()) + ":" + Q(A.getUTCMinutes()) + ":" + Q(A.getUTCSeconds()) + "Z"
  }
  var wf5 = Object.prototype.toString;

  function dT2(A) {
    var Q = wf5.call(A).match(/\[object (.*)\]/);
    return Q ? Q[1] : Q
  }

  function qf5(A, Q) {
    var B = {
        version: "1.0",
        encoding: "UTF-8"
      },
      G = {
        pubid: "-//Apple//DTD PLIST 1.0//EN",
        sysid: "http://www.apple.com/DTDs/PropertyList-1.0.dtd"
      },
      Z = Uf5.create("plist");
    if (Z.dec(B.version, B.encoding, B.standalone), Z.dtd(G.pubid, G.sysid), Z.att("version", "1.0"), t80(A, Z), !Q) Q = {};
    return Q.pretty = Q.pretty !== !1, Z.end(Q)
  }

  function t80(A, Q) {
    var B, G, Z, I = dT2(A);
    if (I == "Undefined") return;
    else if (Array.isArray(A)) {
      Q = Q.ele("array");
      for (G = 0; G < A.length; G++) t80(A[G], Q)
    } else if (Buffer.isBuffer(A)) Q.ele("data").raw(A.toString("base64"));
    else if (I == "Object") {
      Q = Q.ele("dict");
      for (Z in A)
        if (A.hasOwnProperty(Z)) Q.ele("key").txt(Z), t80(A[Z], Q)
    } else if (I == "Number") B = A % 1 === 0 ? "integer" : "real", Q.ele(B).txt(A.toString());
    else if (I == "BigInt") Q.ele("integer").txt(A);
    else if (I == "Date") Q.ele("date").txt($f5(new Date(A)));
    else if (I == "Boolean") Q.ele(A ? "true" : "false");
    else if (I == "String") Q.ele("string").txt(A);
    else if (I == "ArrayBuffer") Q.ele("data").raw(mT2.fromByteArray(A));
    else if (A && A.buffer && dT2(A.buffer) == "ArrayBuffer") Q.ele("data").raw(mT2.fromByteArray(new Uint8Array(A.buffer), Q));
    else if (I === "Null") Q.ele("null").txt("")
  }
})
// @from(Start 11397666, End 11397858)
iT2 = z((e80) => {
  var pT2 = NR2();
  Object.keys(pT2).forEach(function(A) {
    e80[A] = pT2[A]
  });
  var lT2 = cT2();
  Object.keys(lT2).forEach(function(A) {
    e80[A] = lT2[A]
  })
})
// @from(Start 11397861, End 11398006)
function A60({
  message: A,
  title: Q
}) {
  let B = Q ? `${Q}:
${A}` : A;
  try {
    process.stdout.write(`\x1B]9;

${B}\x07`)
  } catch {}
}
// @from(Start 11398008, End 11398318)
function nT2({
  message: A,
  title: Q
}) {
  try {
    let B = Math.floor(Math.random() * 1e4);
    process.stdout.write(`\x1B]99;i=${B}:d=0:p=title;${Q||"Claude Code"}\x1B\\`), process.stdout.write(`\x1B]99;i=${B}:p=body;${A}\x1B\\`), process.stdout.write(`\x1B]99;i=${B}:d=1:a=focus;\x1B\\`)
  } catch {}
}
// @from(Start 11398320, End 11398477)
function Mf5({
  message: A,
  title: Q
}) {
  try {
    let B = Q || "Claude Code";
    process.stdout.write(`\x1B]777;notify;${B};${A}\x07`)
  } catch {}
}
// @from(Start 11398479, End 11398528)
function Q60() {
  process.stdout.write("\x07")
}
// @from(Start 11398529, End 11399073)
async function Of5() {
  try {
    if (d0.terminal !== "Apple_Terminal") return !1;
    let Q = (await QQ("osascript", ["-e", 'tell application "Terminal" to name of current settings of front window'])).stdout.trim();
    if (!Q) return !1;
    let B = await QQ("defaults", ["export", "com.apple.Terminal", "-"]);
    if (B.code !== 0) return !1;
    let I = aT2.default.parse(B.stdout)?.["Window Settings"]?.[Q];
    if (!I) return !1;
    return I.Bell === !1
  } catch (A) {
    return AA(A instanceof Error ? A : Error(String(A))), !1
  }
}
// @from(Start 11399074, End 11400045)
async function E0A(A) {
  let B = N1().preferredNotifChannel,
    G = "none";
  switch (await B60(A), B) {
    case "auto":
      if (d0.terminal === "Apple_Terminal")
        if (await Of5()) Q60(), G = "terminal_bell";
        else G = "no_method_available";
      else if (d0.terminal === "iTerm.app") A60(A), G = "iterm2";
      else if (d0.terminal === "kitty") nT2(A), G = "kitty";
      else if (d0.terminal === "ghostty") Mf5(A), G = "ghostty";
      else G = "no_method_available";
      break;
    case "iterm2":
      A60(A), G = "iterm2";
      break;
    case "terminal_bell":
      Q60(), G = "terminal_bell";
      break;
    case "iterm2_with_bell":
      A60(A), Q60(), G = "iterm2_with_bell";
      break;
    case "kitty":
      nT2(A), G = "kitty";
      break;
    case "notifications_disabled":
      G = "disabled";
      break
  }
  GA("tengu_notification_method_used", {
    configured_channel: B,
    method_used: G,
    term: d0.terminal
  })
}
// @from(Start 11400050, End 11400053)
aT2
// @from(Start 11400059, End 11400146)
h61 = L(() => {
  jQ();
  _8();
  q0();
  c5();
  g1();
  YO();
  aT2 = BA(iT2(), 1)
})
// @from(Start 11400148, End 11400627)
async function sT2(A, Q, B) {
  try {
    let G = DI();
    if (G.error) return;
    let Z = {
        "Content-Type": "application/json",
        "User-Agent": TV(),
        ...G.headers
      },
      I = {
        vcs_type: "github",
        vcs_host: Q,
        vcs_username: A,
        git_user_email: B
      },
      Y = "https://api.anthropic.com/api/claude_code/link_vcs_account";
    await YQ.post(Y, I, {
      headers: Z,
      timeout: 5000
    })
  } catch (G) {}
}
// @from(Start 11400632, End 11400665)
rT2 = L(() => {
  O3();
  AE()
})
// @from(Start 11400667, End 11401234)
async function Rf5() {
  try {
    let A = await QQ("gh", ["auth", "status", "--active", "--json", "hosts"], {
      useCwd: !1,
      timeout: 5000
    });
    if (A.code !== 0 || !A.stdout.trim()) return null;
    let B = JSON.parse(A.stdout)?.hosts;
    if (!B || typeof B !== "object") return null;
    for (let [G, Z] of Object.entries(B)) {
      if (!Array.isArray(Z) || Z.length === 0) continue;
      let I = Z[0];
      if (I?.login) return {
        username: I.login,
        hostname: G
      }
    }
    return null
  } catch (A) {
    return null
  }
}
// @from(Start 11401235, End 11401495)
async function Tf5() {
  try {
    let A = await QQ("git", ["config", "--get", "user.email"], {
      useCwd: !1,
      timeout: 5000
    });
    if (A.code === 0 && A.stdout.trim()) return A.stdout.trim();
    return null
  } catch (A) {
    return null
  }
}
// @from(Start 11401496, End 11401754)
async function G60() {
  if (N_()) return;
  if (!0) {
    let G = await J61();
    if (G.hasError || !G.vcsAccountLinkingEnabled) return
  }
  let [Q, B] = await Promise.all([Rf5(), Tf5()]);
  if (Q || B) sT2(Q?.username ?? "", Q?.hostname ?? "", B ?? "")
}
// @from(Start 11401759, End 11401810)
oT2 = L(() => {
  _8();
  rT2();
  gB();
  Y80()
})
// @from(Start 11401813, End 11412157)
function Vn({
  onDone: A,
  startingMessage: Q,
  mode: B = "login",
  forceLoginMethod: G
}) {
  let Z = l0() || {},
    I = G ?? Z.forceLoginMethod,
    Y = Z.forceLoginOrgUUID,
    J = I === "claudeai" ? "Login method pre-selected: Subscription Plan (Claude Pro/Max)" : I === "console" ? "Login method pre-selected: API Usage Billing (Anthropic Console)" : null,
    [W, X] = q2.useState(() => {
      if (B === "setup-token") return {
        state: "ready_to_start"
      };
      if (I === "claudeai" || I === "console") return {
        state: "ready_to_start"
      };
      return {
        state: "idle"
      }
    }),
    [V, F] = q2.useState(""),
    [K, D] = q2.useState(0),
    [H] = q2.useState(() => new KRA),
    [C, E] = q2.useState(() => {
      return B === "setup-token" || I === "claudeai"
    }),
    [U, q] = q2.useState(!1),
    w = WB().columns - tT2.length - 1;
  q2.useEffect(() => {
    if (I === "claudeai") GA("tengu_oauth_claudeai_forced", {});
    else if (I === "console") GA("tengu_oauth_console_forced", {})
  }, [I]), q2.useEffect(() => {
    if (W.state === "about_to_retry") setTimeout(() => {
      X(W.nextState)
    }, 1000)
  }, [W]), f1(async (v, x) => {
    if (x.return) {
      if (W.state === "success" && B !== "setup-token") GA("tengu_oauth_success", {
        loginWithClaudeAi: C
      }), A();
      else if (W.state === "error" && W.toRetry) F(""), X({
        state: "about_to_retry",
        nextState: W.toRetry
      })
    }
  });
  async function N(v, x) {
    try {
      let [p, u] = v.split("#");
      if (!p || !u) {
        X({
          state: "error",
          message: "Invalid code. Please make sure the full code was copied",
          toRetry: {
            state: "waiting_for_login",
            url: x
          }
        });
        return
      }
      GA("tengu_oauth_manual_entry", {}), H.handleManualAuthCodeInput({
        authorizationCode: p,
        state: u
      })
    } catch (p) {
      AA(p instanceof Error ? p : Error(String(p))), X({
        state: "error",
        message: p.message,
        toRetry: {
          state: "waiting_for_login",
          url: x
        }
      })
    }
  }
  let R = q2.useCallback(async () => {
      try {
        GA("tengu_oauth_flow_start", {
          loginWithClaudeAi: C
        });
        let v = await H.startOAuthFlow(async (p) => {
            X({
              state: "waiting_for_login",
              url: p
            }), setTimeout(() => q(!0), 3000)
          }, {
            loginWithClaudeAi: C,
            inferenceOnly: B === "setup-token",
            expiresIn: B === "setup-token" ? 31536000 : void 0,
            orgUUID: Y
          }).catch((p) => {
            let u = p.message.includes("Token exchange failed");
            throw X({
              state: "error",
              message: u ? "Failed to exchange authorization code for access token. Please try again." : p.message,
              toRetry: B === "setup-token" ? {
                state: "ready_to_start"
              } : {
                state: "idle"
              }
            }), GA("tengu_oauth_token_exchange_error", {
              error: p.message
            }), p
          }),
          x = gzA(v);
        if (x.warning) GA("tengu_oauth_storage_warning", {
          warning: x.warning
        });
        if (B === "setup-token") X({
          state: "success",
          token: v.accessToken
        });
        else if (await Oo0(v.accessToken).catch((p) => {
            throw X({
              state: "error",
              message: "Failed to fetch user roles: " + p.message,
              toRetry: {
                state: "idle"
              }
            }), GA("tengu_oauth_user_roles_error", {
              error: p.message
            }), p
          }), wv(v.scopes)) await ECB(), K61(), X({
          state: "success"
        }), E0A({
          message: "Claude Code login successful",
          notificationType: "auth_success"
        }), G60();
        else if (X({
            state: "creating_api_key"
          }), await Ro0(v.accessToken).catch((u) => {
            throw X({
              state: "error",
              message: "Failed to create API key: " + u.message,
              toRetry: {
                state: "idle"
              }
            }), GA("tengu_oauth_api_key_error", {
              error: u.message
            }), u
          })) K61(), X({
          state: "success"
        }), E0A({
          message: "Claude Code login successful",
          notificationType: "auth_success"
        }), G60();
        else X({
          state: "error",
          message: "Unable to create API key. The server accepted the request but didn't return a key.",
          toRetry: {
            state: "idle"
          }
        }), GA("tengu_oauth_api_key_error", {
          error: "server_returned_no_key"
        })
      } catch (v) {
        let x = v.message;
        GA("tengu_oauth_error", {
          error: x
        })
      }
    }, [H, q, C, B, Y]),
    T = q2.useRef(!1);
  q2.useEffect(() => {
    if (W.state === "ready_to_start" && !T.current) T.current = !0, process.nextTick(() => {
      R(), T.current = !1
    })
  }, [W.state, R]), q2.useEffect(() => {
    if (B === "setup-token" && W.state === "success") {
      let v = setTimeout(async () => {
        GA("tengu_oauth_success", {
          loginWithClaudeAi: C
        }), A()
      }, 500);
      return () => clearTimeout(v)
    }
  }, [B, W, C, A]), q2.useEffect(() => {
    return () => {
      H.cleanup()
    }
  }, [H]);

  function y() {
    switch (W.state) {
      case "idle":
        return q2.default.createElement(S, {
          flexDirection: "column",
          gap: 1,
          marginTop: 1
        }, q2.default.createElement($, {
          bold: !0
        }, Q ? Q : "Claude Code can be used with your Claude subscription or billed based on API usage through your Console account."), q2.default.createElement($, null, "Select login method:"), q2.default.createElement(S, null, q2.default.createElement(M0, {
          options: [{
            label: `Claude account with subscription · ${tA.dim("Pro, Max, Team, or Enterprise")}
`,
            value: "claudeai"
          }, {
            label: `Anthropic Console account · ${tA.dim("API usage billing")}
`,
            value: "console"
          }],
          onCancel: () => {},
          onChange: (v) => {
            if (X({
                state: "ready_to_start"
              }), v === "claudeai") GA("tengu_oauth_claudeai_selected", {}), E(!0);
            else GA("tengu_oauth_console_selected", {}), E(!1)
          }
        })));
      case "waiting_for_login":
        return q2.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, J && q2.default.createElement(S, null, q2.default.createElement($, {
          dimColor: !0
        }, J)), !U && q2.default.createElement(S, null, q2.default.createElement(g4, null), q2.default.createElement($, null, "Opening browser to sign in…")), U && q2.default.createElement(S, null, q2.default.createElement($, null, tT2), q2.default.createElement(s4, {
          value: V,
          onChange: F,
          onSubmit: (v) => N(v, W.url),
          cursorOffset: K,
          onChangeCursorOffset: D,
          columns: w
        })));
      case "creating_api_key":
        return q2.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, q2.default.createElement(S, null, q2.default.createElement(g4, null), q2.default.createElement($, null, "Creating API key for Claude Code…")));
      case "about_to_retry":
        return q2.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, q2.default.createElement($, {
          color: "permission"
        }, "Retrying…"));
      case "success":
        return q2.default.createElement(S, {
          flexDirection: "column"
        }, B === "setup-token" && W.token ? null : q2.default.createElement(q2.default.Fragment, null, t6()?.emailAddress ? q2.default.createElement($, {
          dimColor: !0
        }, "Logged in as", " ", q2.default.createElement($, null, t6()?.emailAddress)) : null, q2.default.createElement($, {
          color: "success"
        }, "Login successful. Press ", q2.default.createElement($, {
          bold: !0
        }, "Enter"), " to continue…")));
      case "error":
        return q2.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, q2.default.createElement($, {
          color: "error"
        }, "OAuth error: ", W.message), W.toRetry && q2.default.createElement(S, {
          marginTop: 1
        }, q2.default.createElement($, {
          color: "permission"
        }, "Press ", q2.default.createElement($, {
          bold: !0
        }, "Enter"), " to retry.")));
      default:
        return null
    }
  }
  return q2.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, W.state === "waiting_for_login" && U && q2.default.createElement(S, {
    flexDirection: "column",
    key: "urlToCopy",
    gap: 1,
    paddingBottom: 1
  }, q2.default.createElement(S, {
    paddingX: 1
  }, q2.default.createElement($, {
    dimColor: !0
  }, "Browser didn't open? Use the url below to sign in:")), q2.default.createElement(S, {
    width: 1000
  }, q2.default.createElement($, {
    dimColor: !0
  }, W.url))), B === "setup-token" && W.state === "success" && W.token && q2.default.createElement(S, {
    key: "tokenOutput",
    flexDirection: "column",
    gap: 1,
    paddingTop: 1
  }, q2.default.createElement($, {
    color: "success"
  }, "✓ Long-lived authentication token created successfully!"), q2.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, q2.default.createElement($, null, "Your OAuth token (valid for 1 year):"), q2.default.createElement(S, {
    width: 1000
  }, q2.default.createElement($, {
    color: "warning"
  }, W.token)), q2.default.createElement($, {
    dimColor: !0
  }, "Store this token securely. You won't be able to see it again."), q2.default.createElement($, {
    dimColor: !0
  }, "Use this token by setting: export CLAUDE_CODE_OAUTH_TOKEN=<token>"))), q2.default.createElement(S, {
    paddingLeft: 1,
    flexDirection: "column",
    gap: 1
  }, y()))
}
// @from(Start 11412162, End 11412164)
q2
// @from(Start 11412166, End 11412204)
tT2 = "Paste code here if prompted > "
// @from(Start 11412210, End 11412379)
SRA = L(() => {
  hA();
  ZY();
  q80();
  AL();
  gB();
  q0();
  i8();
  g1();
  DY();
  h61();
  S5();
  D61();
  F9();
  MB();
  t2();
  oT2();
  q2 = BA(VA(), 1)
})
// @from(Start 11412382, End 11415160)
function eT2({
  onStashAndContinue: A,
  onCancel: Q
}) {
  let [B, G] = $G.useState(null), Z = B !== null ? [...B.tracked, ...B.untracked] : [], [I, Y] = $G.useState(!0), [J, W] = $G.useState(!1), [X, V] = $G.useState(null);
  $G.useEffect(() => {
    (async () => {
      try {
        let C = await $h1();
        G(C)
      } catch (C) {
        let E = C instanceof Error ? C.message : String(C);
        g(`Error getting changed files: ${E}`, {
          level: "error"
        }), V("Failed to get changed files")
      } finally {
        Y(!1)
      }
    })()
  }, []);
  let F = async () => {
    W(!0);
    try {
      if (g("Stashing changes before teleport..."), await lCB("Teleport auto-stash")) g("Successfully stashed changes"), A();
      else V("Failed to stash changes")
    } catch (H) {
      let C = H instanceof Error ? H.message : String(H);
      g(`Error stashing changes: ${C}`, {
        level: "error"
      }), V("Failed to stash changes")
    } finally {
      W(!1)
    }
  }, K = (H) => {
    if (H === "stash") F();
    else Q()
  };
  if (I) return $G.default.createElement(S, {
    flexDirection: "column",
    padding: 1
  }, $G.default.createElement(S, {
    marginBottom: 1
  }, $G.default.createElement(g4, null), $G.default.createElement($, null, " Checking git status", H1.ellipsis)));
  if (X) return $G.default.createElement(S, {
    flexDirection: "column",
    padding: 1
  }, $G.default.createElement($, {
    bold: !0,
    color: "error"
  }, "Error: ", X), $G.default.createElement(S, {
    marginTop: 1
  }, $G.default.createElement($, {
    dimColor: !0
  }, "Press "), $G.default.createElement($, {
    bold: !0
  }, "Escape"), $G.default.createElement($, {
    dimColor: !0
  }, " to cancel")));
  let D = Z.length > 8;
  return $G.default.createElement(hD, {
    title: "Working Directory Has Changes",
    onCancel: Q,
    borderDimColor: !0
  }, $G.default.createElement($, null, "Teleport will switch git branches. The following changes were found:"), $G.default.createElement(S, {
    flexDirection: "column",
    paddingLeft: 2
  }, Z.length > 0 ? D ? $G.default.createElement($, null, Z.length, " files changed") : Z.map((H, C) => $G.default.createElement($, {
    key: C
  }, H)) : $G.default.createElement($, {
    dimColor: !0
  }, "No changes detected")), $G.default.createElement($, null, "Would you like to stash these changes and continue with teleport?"), J ? $G.default.createElement(S, null, $G.default.createElement(g4, null), $G.default.createElement($, null, " Stashing changes...")) : $G.default.createElement(M0, {
    options: [{
      label: "Stash changes and continue",
      value: "stash"
    }, {
      label: "Exit",
      value: "exit"
    }],
    onChange: K,
    onCancel: () => Q()
  }))
}
// @from(Start 11415165, End 11415167)
$G
// @from(Start 11415173, End 11415266)
AP2 = L(() => {
  hA();
  PV();
  V0();
  DY();
  J5();
  V9();
  Mi();
  $G = BA(VA(), 1)
})
// @from(Start 11415268, End 11415670)
async function DO() {
  let A = W0();
  if (_RA.has(A)) return _RA.get(A) ?? null;
  try {
    let Q = await onA();
    if (g(`Git remote URL: ${Q}`), !Q) return g("No git remote URL found"), _RA.set(A, null), null;
    let B = dh(Q);
    return g(`Parsed repository: ${B} from URL: ${Q}`), _RA.set(A, B), B
  } catch (Q) {
    return g(`Error detecting repository: ${Q}`), _RA.set(A, null), null
  }
}
// @from(Start 11415672, End 11416195)
function dh(A) {
  let Q = A.trim(),
    B = [/github\.com[:/]([^/]+\/[^/.]+?)(\.git)?$/, /github\.com[:/]([^/]+\/[^/.]+)$/];
  for (let G of B) {
    let Z = Q.match(G);
    if (Z && Z[1]) return g(`Parsed repository: ${Z[1]} from ${Q}`), Z[1]
  }
  if (!Q.includes("://") && !Q.includes("@") && Q.includes("/")) {
    let G = Q.split("/");
    if (G.length === 2 && G[0] && G[1]) {
      let Z = G[1].replace(/\.git$/, "");
      return `${G[0]}/${Z}`
    }
  }
  return g(`Could not parse repository from: ${Q}`), null
}
// @from(Start 11416200, End 11416203)
_RA
// @from(Start 11416209, End 11416267)
z0A = L(() => {
  PV();
  V0();
  U2();
  _RA = new Map
})
// @from(Start 11416315, End 11416735)
async function U0A() {
  let A = M6()?.accessToken;
  if (A === void 0) throw Error("Claude Code web sessions require authentication with a Claude.ai account. API key authentication is not sufficient. Please run /login to authenticate, or check your authentication status with /status.");
  let Q = await HS();
  if (!Q) throw Error("Unable to get organization UUID");
  return {
    accessToken: A,
    orgUUID: Q
  }
}
// @from(Start 11416736, End 11417856)
async function QP2() {
  let {
    accessToken: A,
    orgUUID: Q
  } = await U0A(), B = `${e9().BASE_API_URL}/v1/sessions`;
  try {
    let G = {
        ...IC(A),
        "x-organization-uuid": Q
      },
      Z = await YQ.get(B, {
        headers: G
      });
    if (Z.status !== 200) throw Error(`Failed to fetch code sessions: ${Z.statusText}`);
    return Z.data.data.map((Y) => {
      let J = Y.session_context.sources.find((X) => X.type === "git_repository"),
        W = null;
      if (J?.url) {
        let X = dh(J.url);
        if (X) {
          let [V, F] = X.split("/");
          if (V && F) W = {
            name: F,
            owner: {
              login: V
            },
            default_branch: J.revision || void 0
          }
        }
      }
      return {
        id: Y.id,
        title: Y.title || "Untitled",
        description: "",
        status: Y.session_status,
        repo: W,
        turns: [],
        created_at: Y.created_at,
        updated_at: Y.updated_at
      }
    })
  } catch (G) {
    let Z = G instanceof Error ? G : Error(String(G));
    throw AA(Z), G
  }
}
// @from(Start 11417858, End 11418003)
function IC(A) {
  return {
    Authorization: `Bearer ${A}`,
    "Content-Type": "application/json",
    "anthropic-version": "2023-06-01"
  }
}
// @from(Start 11418004, End 11418625)
async function BP2(A, Q) {
  try {
    let {
      accessToken: B,
      orgUUID: G
    } = await U0A(), Z = `${e9().BASE_API_URL}/v1/sessions/${A}/events`, I = {
      ...IC(B),
      "x-organization-uuid": G
    }, J = {
      events: [{
        uuid: Pf5(),
        session_id: A,
        type: "user",
        parent_tool_use_id: null,
        message: {
          role: "user",
          content: Q
        }
      }]
    }, W = await YQ.post(Z, J, {
      headers: I,
      validateStatus: (X) => X < 500
    });
    if (W.status === 200 || W.status === 201) return !0;
    return !1
  } catch {
    return !1
  }
}
// @from(Start 11418630, End 11418633)
jf5
// @from(Start 11418635, End 11418638)
HoG
// @from(Start 11418644, End 11419206)
Fn = L(() => {
  NX();
  gB();
  O3();
  AL();
  g1();
  z0A();
  Q2();
  jf5 = W2.object({
    id: W2.string(),
    title: W2.string(),
    description: W2.string(),
    status: W2.enum(["idle", "working", "waiting", "completed", "archived", "cancelled", "rejected"]),
    repo: W2.object({
      name: W2.string(),
      owner: W2.object({
        login: W2.string()
      }),
      default_branch: W2.string().optional()
    }).nullable(),
    turns: W2.array(W2.string()),
    created_at: W2.string(),
    updated_at: W2.string()
  }), HoG = W2.array(jf5)
})
// @from(Start 11419208, End 11420065)
async function nJA() {
  let A = M6()?.accessToken;
  if (!A) throw Error("Claude Code web sessions require authentication with a Claude.ai account. API key authentication is not sufficient. Please run /login to authenticate, or check your authentication status with /status.");
  let Q = await HS();
  if (!Q) throw Error("Unable to get organization UUID");
  let B = `${e9().BASE_API_URL}/v1/environment_providers`;
  try {
    let G = {
        ...IC(A),
        "x-organization-uuid": Q
      },
      Z = await YQ.get(B, {
        headers: G,
        timeout: 15000
      });
    if (Z.status !== 200) throw Error(`Failed to fetch environments: ${Z.status} ${Z.statusText}`);
    return Z.data.environments
  } catch (G) {
    let Z = G instanceof Error ? G : Error(String(G));
    throw AA(Z), Error(`Failed to fetch environments: ${Z.message}`)
  }
}
// @from(Start 11420070, End 11420135)
g61 = L(() => {
  O3();
  NX();
  gB();
  AL();
  g1();
  Fn()
})
// @from(Start 11420137, End 11420199)
async function u61() {
  if (!BB()) return !1;
  return Qt()
}
// @from(Start 11420200, End 11420244)
async function GP2() {
  return await _t()
}
// @from(Start 11420245, End 11420429)
async function ZP2() {
  try {
    return (await nJA()).length > 0
  } catch (A) {
    return g(`checkHasRemoteEnvironment failed: ${A instanceof Error?A.message:String(A)}`), !1
  }
}
// @from(Start 11420430, End 11420483)
async function IP2() {
  return await DO() !== null
}
// @from(Start 11420484, End 11421637)
async function YP2(A, Q) {
  try {
    let B = M6()?.accessToken;
    if (!B) return g("checkGithubAppInstalled: No access token found, assuming app not installed"), !1;
    let G = await HS();
    if (!G) return g("checkGithubAppInstalled: No org UUID found, assuming app not installed"), !1;
    let Z = `${e9().BASE_API_URL}/api/oauth/organizations/${G}/code/repos/${A}/${Q}`,
      I = {
        ...IC(B),
        "x-organization-uuid": G
      };
    g(`Checking GitHub app installation for ${A}/${Q}`);
    let Y = await YQ.get(Z, {
      headers: I,
      timeout: 15000
    });
    if (Y.status === 200 && Y.data.status) {
      let J = Y.data.status.app_installed;
      return g(`GitHub app ${J?"is":"is not"} installed on ${A}/${Q}`), J
    }
    return g(`checkGithubAppInstalled: Unexpected response status ${Y.status}`), !1
  } catch (B) {
    if (YQ.isAxiosError(B)) {
      let G = B.response?.status;
      if (G && G >= 400 && G < 500) return g(`checkGithubAppInstalled: Got ${G} error, app likely not installed on ${A}/${Q}`), !1
    }
    return g(`checkGithubAppInstalled error: ${B instanceof Error?B.message:String(B)}`), !1
  }
}
// @from(Start 11421642, End 11421733)
Z60 = L(() => {
  PV();
  gB();
  z0A();
  g61();
  AL();
  NX();
  Fn();
  O3();
  V0()
})
// @from(Start 11421736, End 11423543)
function m61({
  onComplete: A,
  errorsToIgnore: Q = new Set
}) {
  let [B, G] = AV.useState(null), [Z, I] = AV.useState(!1), Y = AV.useCallback(async () => {
    let K = await I60(),
      D = new Set(Array.from(K).filter((H) => !Q.has(H)));
    if (D.size === 0) {
      A();
      return
    }
    if (D.has("needsLogin")) G("needsLogin");
    else if (D.has("needsGitStash")) G("needsGitStash")
  }, [A, Q]);
  AV.useEffect(() => {
    Y()
  }, [Y]);
  let J = AV.useCallback(() => {
      l5(0)
    }, []),
    W = AV.useCallback(() => {
      I(!1), Y()
    }, [Y]),
    X = AV.useCallback(() => {
      I(!0)
    }, [I]),
    V = AV.useCallback((K) => {
      if (K === "login") X();
      else J()
    }, [X, J]),
    F = AV.useCallback(() => {
      Y()
    }, [Y]);
  if (!B) return null;
  switch (B) {
    case "needsGitStash":
      return AV.default.createElement(eT2, {
        onStashAndContinue: F,
        onCancel: J
      });
    case "needsLogin": {
      if (Z) return AV.default.createElement(Vn, {
        onDone: W,
        mode: "login",
        forceLoginMethod: "claudeai"
      });
      return AV.default.createElement(hD, {
        title: "Log in to Claude",
        onCancel: J,
        borderDimColor: !0
      }, AV.default.createElement(S, {
        flexDirection: "column"
      }, AV.default.createElement($, {
        dimColor: !0
      }, "Teleport requires a Claude.ai account."), AV.default.createElement($, {
        dimColor: !0
      }, "Your Claude Pro/Max subscription will be used by Claude Code.")), AV.default.createElement(M0, {
        options: [{
          label: "Login with Claude account",
          value: "login"
        }, {
          label: "Exit",
          value: "exit"
        }],
        onChange: V,
        onCancel: J
      }))
    }
  }
}
// @from(Start 11423544, End 11423710)
async function I60() {
  let A = new Set,
    [Q, B] = await Promise.all([u61(), GP2()]);
  if (Q) A.add("needsLogin");
  if (!B) A.add("needsGitStash");
  return A
}
// @from(Start 11423715, End 11423717)
AV
// @from(Start 11423723, End 11423819)
Y60 = L(() => {
  hA();
  Mi();
  J5();
  SRA();
  AP2();
  kW();
  Z60();
  AV = BA(VA(), 1)
})
// @from(Start 11423822, End 11424037)
function JP2(A) {
  if (!A) throw GA("tengu_teleport_error_no_url_or_session_id", {}), new XI("No URL or session ID provided for teleport", tA.red(`Error: No URL or session ID provided for teleport
`));
  return A
}
// @from(Start 11424039, End 11424524)
function WP2(A) {
  if (!A) return {};
  try {
    let Q = JSON.parse(A);
    if (typeof Q !== "object" || Q === null || Array.isArray(Q)) throw Error("TELEPORT_HEADERS must be a JSON object");
    return Q
  } catch (Q) {
    let B = Q instanceof Error ? Q : Error(String(Q));
    throw AA(B), GA("tengu_teleport_error_invalid_teleport_headers_json", {}), new XI(`Invalid JSON in TELEPORT_HEADERS: ${B.message}`, tA.red(`Error: Invalid JSON in TELEPORT_HEADERS: ${B.message}
`))
  }
}
// @from(Start 11424526, End 11424743)
function XP2(A) {
  for (let [Q, B] of Object.entries(A))
    if (typeof B !== "string") {
      let G = Error(`Invalid header value for "${Q}": headers must be strings, got ${typeof B}`);
      throw AA(G), G
    }
}
// @from(Start 11424748, End 11424797)
VP2 = L(() => {
  RZ();
  F9();
  q0();
  g1()
})
// @from(Start 11424846, End 11425050)
function _f5(A) {
  if (A === null) return $y("Session resumed", "suggestion");
  let Q = A instanceof XI ? A.formattedMessage : A.message;
  return $y(`Session resumed without branch: ${Q}`, "warning")
}
// @from(Start 11425052, End 11425251)
function kf5() {
  return R0({
    content: `This session is being continued from another machine. Application state may have changed. The updated working directory is ${uQ()}`,
    isMeta: !0
  })
}
// @from(Start 11425252, End 11426295)
async function xf5(A, Q) {
  let B = A.length > 75 ? A.slice(0, 75) + "…" : A,
    G = "claude/task";
  try {
    let Z = yf5.replace("{description}", A),
      I = "<title>",
      J = (await uX({
        systemPrompt: [],
        userPrompt: Z,
        assistantPrompt: "<title>",
        signal: Q,
        options: {
          querySource: "teleport_generate_title",
          agents: [],
          isNonInteractiveSession: !1,
          hasAppendSystemPrompt: !1,
          mcpTools: [],
          agentIdOrSessionId: e1()
        }
      })).message.content[0];
    if (J?.type === "text") {
      let W = "<title>" + J.text.trim(),
        X = W.match(/<title>(.*?)<\/title>/s),
        V = X ? X[1]?.trim() : B,
        F = W.match(/<branch>(.*?)<\/branch>/s),
        K = F ? F[1]?.trim() : "claude/task";
      return {
        title: V || B,
        branchName: K || "claude/task"
      }
    }
  } catch (Z) {
    AA(Error(`Error generating title and branch: ${Z}`))
  }
  return {
    title: B,
    branchName: "claude/task"
  }
}
// @from(Start 11426296, End 11426614)
async function c61() {
  if (!await _t()) throw GA("tengu_teleport_error_git_not_clean", {}), new XI("Git working directory is not clean. Please commit or stash your changes before using --teleport.", tA.red(`Error: Git working directory is not clean. Please commit or stash your changes before using --teleport.
`))
}
// @from(Start 11426615, End 11427132)
async function vf5(A) {
  let Q = A ? ["fetch", "origin", `${A}:${A}`] : ["fetch", "origin"],
    {
      code: B,
      stderr: G
    } = await QQ("git", Q);
  if (B !== 0)
    if (A && G.includes("refspec")) {
      g(`Specific branch fetch failed, trying to fetch ref: ${A}`);
      let {
        code: Z,
        stderr: I
      } = await QQ("git", ["fetch", "origin", A]);
      if (Z !== 0) AA(Error(`Failed to fetch from remote origin: ${I}`))
    } else AA(Error(`Failed to fetch from remote origin: ${G}`))
}
// @from(Start 11427133, End 11427802)
async function bf5(A) {
  let {
    code: Q
  } = await QQ("git", ["rev-parse", "--abbrev-ref", `${A}@{upstream}`]);
  if (Q === 0) {
    g(`Branch '${A}' already has upstream set`);
    return
  }
  let {
    code: B
  } = await QQ("git", ["rev-parse", "--verify", `origin/${A}`]);
  if (B === 0) {
    g(`Setting upstream for '${A}' to 'origin/${A}'`);
    let {
      code: G,
      stderr: Z
    } = await QQ("git", ["branch", "--set-upstream-to", `origin/${A}`, A]);
    if (G !== 0) g(`Failed to set upstream for '${A}': ${Z}`);
    else g(`Successfully set upstream for '${A}'`)
  } else g(`Remote branch 'origin/${A}' does not exist, skipping upstream setup`)
}
// @from(Start 11427803, End 11428479)
async function ff5(A) {
  let {
    code: Q,
    stderr: B
  } = await QQ("git", ["checkout", A]);
  if (Q !== 0) {
    g(`Local checkout failed, trying to checkout from origin: ${B}`);
    let G = await QQ("git", ["checkout", "-b", A, "--track", `origin/${A}`]);
    if (Q = G.code, B = G.stderr, Q !== 0) {
      g(`Remote checkout with -b failed, trying without -b: ${B}`);
      let Z = await QQ("git", ["checkout", "--track", `origin/${A}`]);
      Q = Z.code, B = Z.stderr
    }
  }
  if (Q !== 0) throw GA("tengu_teleport_error_branch_checkout_failed", {}), new XI(`Failed to checkout branch '${A}': ${B}`, tA.red(`Failed to checkout branch '${A}'
`));
  await bf5(A)
}
// @from(Start 11428480, End 11428597)
async function d61() {
  let {
    stdout: A
  } = await QQ("git", ["branch", "--show-current"]);
  return A.trim()
}
// @from(Start 11428599, End 11428657)
function FP2(A, Q) {
  return [...nMA(A), kf5(), _f5(Q)]
}
// @from(Start 11428658, End 11429284)
async function kRA(A, Q) {
  try {
    let B = await d61();
    if (g(`Current branch before teleport: '${B}'`), Q) {
      g(`Switching to branch '${Q}'...`), await vf5(Q), await ff5(Q);
      let Z = await d61();
      g(`Branch after checkout: '${Z}'`)
    } else g("No branch specified, staying on current branch");
    let G = await d61();
    return {
      messages: FP2(A, null),
      branchName: G,
      branchError: null
    }
  } catch (B) {
    let G = await d61(),
      Z = B instanceof Error ? B : Error(String(B));
    return {
      messages: FP2(A, Z),
      branchName: G,
      branchError: Z
    }
  }
}
// @from(Start 11429285, End 11431812)
async function hf5(A, Q, B) {
  let G = await DO(),
    Z = `${e9().BASE_API_URL}/v1/sessions/${A}`,
    I = {
      ...B,
      "x-organization-uuid": Q
    };
  if (!G) {
    g(`Not in git repo, fetching session metadata to provide guidance: ${Z}`);
    let J;
    try {
      J = await YQ.get(Z, {
        headers: I,
        timeout: 15000
      })
    } catch (W) {
      if (YQ.isAxiosError(W)) g(`Failed to fetch session metadata - Status: ${W.response?.status}, Message: ${W.message}`);
      throw GA("tengu_teleport_error_repo_validation_failed_sessions_api", {
        sessionId: A
      }), new XI(`You must run claude --teleport ${A} from a checkout of the git repo the session was created in.`, tA.red(`You must run claude --teleport ${A} from a checkout of the git repo the session was created in.
`))
    }
    if (J.status === 200) {
      let X = J.data.session_context.sources.find((V) => V.type === "git_repository");
      if (X?.url) {
        let V = dh(X.url);
        if (V) throw GA("tengu_teleport_error_repo_not_in_git_dir_sessions_api", {
          sessionId: A
        }), new XI(`You must run claude --teleport ${A} from a checkout of ${V}.`, tA.red(`You must run claude --teleport ${A} from a checkout of ${tA.bold(V)}.
`))
      } else g("Session has no repo requirement and not in git directory, proceeding")
    }
    return
  }
  g(`Fetching session metadata from: ${Z}`);
  let Y;
  try {
    Y = await YQ.get(Z, {
      headers: I,
      timeout: 15000
    })
  } catch (J) {
    if (YQ.isAxiosError(J)) {
      if (g(`Failed to fetch session metadata - Status: ${J.response?.status}, Message: ${J.message}`), J.response?.data) g(`Error response data: ${JSON.stringify(J.response.data)}`)
    } else g(`Could not fetch session metadata: ${J}`);
    return
  }
  if (Y.status === 200) {
    let W = Y.data.session_context.sources.find((X) => X.type === "git_repository");
    if (W?.url) {
      let X = dh(W.url);
      if (X) {
        if (g(`Session is for repository: ${X}, current repo: ${G}`), G.toLowerCase() !== X.toLowerCase()) throw GA("tengu_teleport_error_repo_mismatch_sessions_api", {
          sessionId: A
        }), new XI(`You must run claude --teleport ${A} from a checkout of ${X}.
This repo is ${G}.`, tA.red(`You must run claude --teleport ${A} from a checkout of ${tA.bold(X)}.
This repo is ${tA.bold(G)}.
`));
        g("Repository matches, proceeding with teleport")
      }
    } else g("Session has no associated repository, proceeding without validation")
  }
}
// @from(Start 11431813, End 11433495)
async function DP2(A) {
  try {
    let Q = M6()?.accessToken;
    if (!Q) return {
      status: "error",
      errorMessage: "OAuth authentication required for teleport"
    };
    let B = await HS();
    if (!B) return {
      status: "error",
      errorMessage: "Unable to get organization UUID"
    };
    let G = IC(Q),
      Z = await DO(),
      I = `${e9().BASE_API_URL}/v1/sessions/${A}`,
      Y = {
        ...G,
        "x-organization-uuid": B
      },
      J;
    try {
      J = await YQ.get(I, {
        headers: Y,
        timeout: 15000
      })
    } catch (F) {
      if (YQ.isAxiosError(F)) g(`Failed to fetch session metadata - Status: ${F.response?.status}, Message: ${F.message}`);
      return {
        status: "error",
        errorMessage: "Failed to fetch session metadata"
      }
    }
    if (J.status !== 200) return {
      status: "error",
      errorMessage: `Unexpected session response status: ${J.status}`
    };
    let X = J.data.session_context.sources.find((F) => F.type === "git_repository");
    if (!X?.url) return {
      status: "no_repo_required"
    };
    let V = dh(X.url);
    if (!V) return {
      status: "no_repo_required"
    };
    if (!Z) return {
      status: "not_in_repo",
      sessionRepo: V,
      currentRepo: null
    };
    if (Z.toLowerCase() === V.toLowerCase()) return {
      status: "match",
      sessionRepo: V,
      currentRepo: Z
    };
    return {
      status: "mismatch",
      sessionRepo: V,
      currentRepo: Z
    }
  } catch (Q) {
    return g(`Error validating session repository: ${Q}`), {
      status: "error",
      errorMessage: Q instanceof Error ? Q.message : String(Q)
    }
  }
}
// @from(Start 11433496, End 11434600)
async function yRA(A) {
  g(`Resuming code session ID: ${A}`);
  try {
    let Q = process.env.TELEPORT_RESUME_URL;
    if (Q) return g("Using TELEPORT_RESUME_URL from environment"), await HP2(Q, void 0);
    let B = M6()?.accessToken;
    if (!B) throw GA("tengu_teleport_resume_error", {
      error_type: "no_access_token"
    }), Error("Claude Code web sessions require authentication with a Claude.ai account. API key authentication is not sufficient. Please run /login to authenticate, or check your authentication status with /status.");
    let G = await HS();
    if (!G) throw GA("tengu_teleport_resume_error", {
      error_type: "no_org_uuid"
    }), Error("Unable to get organization UUID for constructing session URL");
    let Z = IC(B);
    return g("Using Sessions API for resume"), await hf5(A, G, Z), await uf5(A, G, B)
  } catch (Q) {
    if (Q instanceof XI) throw Q;
    let B = Q instanceof Error ? Q : Error(String(Q));
    throw AA(B), GA("tengu_teleport_resume_error", {
      error_type: "resume_session_id_catch"
    }), new XI(B.message, tA.red(`Error: ${B.message}
`))
  }
}
// @from(Start 11434601, End 11435037)
async function HP2(A, Q) {
  g(`Teleporting from URL: ${A}`);
  let B = WP2(process.env.TELEPORT_HEADERS);
  if (Object.keys(B).length > 0) g(`Parsed ${Object.keys(B).length} headers from TELEPORT_HEADERS`);
  else g("No TELEPORT_HEADERS environment variable found");
  if (Q) {
    XP2(Q);
    let G = {
      ...B,
      ...Q
    };
    return g(`Added ${Object.keys(Q).length} additional headers`), KP2(A, G)
  }
  return KP2(A, B)
}
// @from(Start 11435038, End 11436093)
async function KP2(A, Q) {
  try {
    g("Fetching conversation from remote URL...");
    let B = await zY2(A, Q);
    if (!B) throw AA(Error("Remote URL returned empty response")), GA("tengu_teleport_resume_error", {
      error_type: "empty_response",
      url_type: A.startsWith("http") ? "http(s)" : "other"
    }), GA("tengu_teleport_error_failed_to_load_conversation", {}), new XI("Failed to load conversation from remote URL", tA.red(`Error: Failed to load conversation from remote URL
`));
    return g("Successfully loaded conversation from remote URL"), g(`Response contains ${B.log?.length||0} messages`), g(`Response branch: ${B.branch||"none specified"}`), GA("tengu_teleport_resume_success", {
      messages_count: B.log?.length || 0,
      has_branch: !!B.branch
    }), B
  } catch (B) {
    if (B instanceof XI) throw B;
    let G = B instanceof Error ? B : Error(String(B));
    throw AA(G), GA("tengu_teleport_resume_error", {
      error_type: "teleport_from_url_catch"
    }), new XI(G.message, tA.red(`Error: ${G.message}
`))
  }
}
// @from(Start 11436094, End 11436231)
async function xRA(A) {
  let Q = JP2(A);
  if (Q.startsWith("http:") || Q.startsWith("https:")) return HP2(Q, void 0);
  return yRA(Q)
}
// @from(Start 11526551, End 11553839)
hS2 = z((yS2) => {
  Object.defineProperty(yS2, "__esModule", {
    value: !0
  });
  yS2.createMessageConnection = yS2.ConnectionOptions = yS2.MessageStrategy = yS2.CancellationStrategy = yS2.CancellationSenderStrategy = yS2.CancellationReceiverStrategy = yS2.RequestCancellationReceiverStrategy = yS2.IdCancellationReceiverStrategy = yS2.ConnectionStrategy = yS2.ConnectionError = yS2.ConnectionErrors = yS2.LogTraceNotification = yS2.SetTraceNotification = yS2.TraceFormat = yS2.TraceValues = yS2.Trace = yS2.NullLogger = yS2.ProgressType = yS2.ProgressToken = void 0;
  var PS2 = Dn(),
    sY = BWA(),
    z4 = c60(),
    jS2 = l60(),
    mRA = GWA(),
    G50 = Q51(),
    pRA;
  (function(A) {
    A.type = new z4.NotificationType("$/cancelRequest")
  })(pRA || (pRA = {}));
  var Z50;
  (function(A) {
    function Q(B) {
      return typeof B === "string" || typeof B === "number"
    }
    A.is = Q
  })(Z50 || (yS2.ProgressToken = Z50 = {}));
  var dRA;
  (function(A) {
    A.type = new z4.NotificationType("$/progress")
  })(dRA || (dRA = {}));
  class kS2 {
    constructor() {}
  }
  yS2.ProgressType = kS2;
  var I50;
  (function(A) {
    function Q(B) {
      return sY.func(B)
    }
    A.is = Q
  })(I50 || (I50 = {}));
  yS2.NullLogger = Object.freeze({
    error: () => {},
    warn: () => {},
    info: () => {},
    log: () => {}
  });
  var k7;
  (function(A) {
    A[A.Off = 0] = "Off", A[A.Messages = 1] = "Messages", A[A.Compact = 2] = "Compact", A[A.Verbose = 3] = "Verbose"
  })(k7 || (yS2.Trace = k7 = {}));
  var SS2;
  (function(A) {
    A.Off = "off", A.Messages = "messages", A.Compact = "compact", A.Verbose = "verbose"
  })(SS2 || (yS2.TraceValues = SS2 = {}));
  (function(A) {
    function Q(G) {
      if (!sY.string(G)) return A.Off;
      switch (G = G.toLowerCase(), G) {
        case "off":
          return A.Off;
        case "messages":
          return A.Messages;
        case "compact":
          return A.Compact;
        case "verbose":
          return A.Verbose;
        default:
          return A.Off
      }
    }
    A.fromString = Q;

    function B(G) {
      switch (G) {
        case A.Off:
          return "off";
        case A.Messages:
          return "messages";
        case A.Compact:
          return "compact";
        case A.Verbose:
          return "verbose";
        default:
          return "off"
      }
    }
    A.toString = B
  })(k7 || (yS2.Trace = k7 = {}));
  var jq;
  (function(A) {
    A.Text = "text", A.JSON = "json"
  })(jq || (yS2.TraceFormat = jq = {}));
  (function(A) {
    function Q(B) {
      if (!sY.string(B)) return A.Text;
      if (B = B.toLowerCase(), B === "json") return A.JSON;
      else return A.Text
    }
    A.fromString = Q
  })(jq || (yS2.TraceFormat = jq = {}));
  var Y50;
  (function(A) {
    A.type = new z4.NotificationType("$/setTrace")
  })(Y50 || (yS2.SetTraceNotification = Y50 = {}));
  var B51;
  (function(A) {
    A.type = new z4.NotificationType("$/logTrace")
  })(B51 || (yS2.LogTraceNotification = B51 = {}));
  var cRA;
  (function(A) {
    A[A.Closed = 1] = "Closed", A[A.Disposed = 2] = "Disposed", A[A.AlreadyListening = 3] = "AlreadyListening"
  })(cRA || (yS2.ConnectionErrors = cRA = {}));
  class IWA extends Error {
    constructor(A, Q) {
      super(Q);
      this.code = A, Object.setPrototypeOf(this, IWA.prototype)
    }
  }
  yS2.ConnectionError = IWA;
  var J50;
  (function(A) {
    function Q(B) {
      let G = B;
      return G && sY.func(G.cancelUndispatched)
    }
    A.is = Q
  })(J50 || (yS2.ConnectionStrategy = J50 = {}));
  var G51;
  (function(A) {
    function Q(B) {
      let G = B;
      return G && (G.kind === void 0 || G.kind === "id") && sY.func(G.createCancellationTokenSource) && (G.dispose === void 0 || sY.func(G.dispose))
    }
    A.is = Q
  })(G51 || (yS2.IdCancellationReceiverStrategy = G51 = {}));
  var W50;
  (function(A) {
    function Q(B) {
      let G = B;
      return G && G.kind === "request" && sY.func(G.createCancellationTokenSource) && (G.dispose === void 0 || sY.func(G.dispose))
    }
    A.is = Q
  })(W50 || (yS2.RequestCancellationReceiverStrategy = W50 = {}));
  var Z51;
  (function(A) {
    A.Message = Object.freeze({
      createCancellationTokenSource(B) {
        return new G50.CancellationTokenSource
      }
    });

    function Q(B) {
      return G51.is(B) || W50.is(B)
    }
    A.is = Q
  })(Z51 || (yS2.CancellationReceiverStrategy = Z51 = {}));
  var I51;
  (function(A) {
    A.Message = Object.freeze({
      sendCancellation(B, G) {
        return B.sendNotification(pRA.type, {
          id: G
        })
      },
      cleanup(B) {}
    });

    function Q(B) {
      let G = B;
      return G && sY.func(G.sendCancellation) && sY.func(G.cleanup)
    }
    A.is = Q
  })(I51 || (yS2.CancellationSenderStrategy = I51 = {}));
  var Y51;
  (function(A) {
    A.Message = Object.freeze({
      receiver: Z51.Message,
      sender: I51.Message
    });

    function Q(B) {
      let G = B;
      return G && Z51.is(G.receiver) && I51.is(G.sender)
    }
    A.is = Q
  })(Y51 || (yS2.CancellationStrategy = Y51 = {}));
  var J51;
  (function(A) {
    function Q(B) {
      let G = B;
      return G && sY.func(G.handleMessage)
    }
    A.is = Q
  })(J51 || (yS2.MessageStrategy = J51 = {}));
  var _S2;
  (function(A) {
    function Q(B) {
      let G = B;
      return G && (Y51.is(G.cancellationStrategy) || J50.is(G.connectionStrategy) || J51.is(G.messageStrategy))
    }
    A.is = Q
  })(_S2 || (yS2.ConnectionOptions = _S2 = {}));
  var PP;
  (function(A) {
    A[A.New = 1] = "New", A[A.Listening = 2] = "Listening", A[A.Closed = 3] = "Closed", A[A.Disposed = 4] = "Disposed"
  })(PP || (PP = {}));

  function Tg5(A, Q, B, G) {
    let Z = B !== void 0 ? B : yS2.NullLogger,
      I = 0,
      Y = 0,
      J = 0,
      W = "2.0",
      X = void 0,
      V = new Map,
      F = void 0,
      K = new Map,
      D = new Map,
      H, C = new jS2.LinkedMap,
      E = new Map,
      U = new Set,
      q = new Map,
      w = k7.Off,
      N = jq.Text,
      R, T = PP.New,
      y = new mRA.Emitter,
      v = new mRA.Emitter,
      x = new mRA.Emitter,
      p = new mRA.Emitter,
      u = new mRA.Emitter,
      e = G && G.cancellationStrategy ? G.cancellationStrategy : Y51.Message;

    function l(W1) {
      if (W1 === null) throw Error("Can't send requests with id null since the response can't be correlated.");
      return "req-" + W1.toString()
    }

    function k(W1) {
      if (W1 === null) return "res-unknown-" + (++J).toString();
      else return "res-" + W1.toString()
    }

    function m() {
      return "not-" + (++Y).toString()
    }

    function o(W1, O1) {
      if (z4.Message.isRequest(O1)) W1.set(l(O1.id), O1);
      else if (z4.Message.isResponse(O1)) W1.set(k(O1.id), O1);
      else W1.set(m(), O1)
    }

    function IA(W1) {
      return
    }

    function FA() {
      return T === PP.Listening
    }

    function zA() {
      return T === PP.Closed
    }

    function NA() {
      return T === PP.Disposed
    }

    function OA() {
      if (T === PP.New || T === PP.Listening) T = PP.Closed, v.fire(void 0)
    }

    function mA(W1) {
      y.fire([W1, void 0, void 0])
    }

    function wA(W1) {
      y.fire(W1)
    }
    A.onClose(OA), A.onError(mA), Q.onClose(OA), Q.onError(wA);

    function qA() {
      if (H || C.size === 0) return;
      H = (0, PS2.default)().timer.setImmediate(() => {
        H = void 0, yA()
      })
    }

    function KA(W1) {
      if (z4.Message.isRequest(W1)) X1(W1);
      else if (z4.Message.isNotification(W1)) EA(W1);
      else if (z4.Message.isResponse(W1)) WA(W1);
      else MA(W1)
    }

    function yA() {
      if (C.size === 0) return;
      let W1 = C.shift();
      try {
        let O1 = G?.messageStrategy;
        if (J51.is(O1)) O1.handleMessage(W1, KA);
        else KA(W1)
      } finally {
        qA()
      }
    }
    let oA = (W1) => {
      try {
        if (z4.Message.isNotification(W1) && W1.method === pRA.type.method) {
          let O1 = W1.params.id,
            a1 = l(O1),
            C0 = C.get(a1);
          if (z4.Message.isRequest(C0)) {
            let k0 = G?.connectionStrategy,
              f0 = k0 && k0.cancelUndispatched ? k0.cancelUndispatched(C0, IA) : IA(C0);
            if (f0 && (f0.error !== void 0 || f0.result !== void 0)) {
              C.delete(a1), q.delete(O1), f0.id = C0.id, rA(f0, W1.method, Date.now()), Q.write(f0).catch(() => Z.error("Sending response for canceled message failed."));
              return
            }
          }
          let v0 = q.get(O1);
          if (v0 !== void 0) {
            v0.cancel(), J1(W1);
            return
          } else U.add(O1)
        }
        o(C, W1)
      } finally {
        qA()
      }
    };

    function X1(W1) {
      if (NA()) return;

      function O1(yQ, aQ, sQ) {
        let K0 = {
          jsonrpc: W,
          id: W1.id
        };
        if (yQ instanceof z4.ResponseError) K0.error = yQ.toJson();
        else K0.result = yQ === void 0 ? null : yQ;
        rA(K0, aQ, sQ), Q.write(K0).catch(() => Z.error("Sending response failed."))
      }

      function a1(yQ, aQ, sQ) {
        let K0 = {
          jsonrpc: W,
          id: W1.id,
          error: yQ.toJson()
        };
        rA(K0, aQ, sQ), Q.write(K0).catch(() => Z.error("Sending response failed."))
      }

      function C0(yQ, aQ, sQ) {
        if (yQ === void 0) yQ = null;
        let K0 = {
          jsonrpc: W,
          id: W1.id,
          result: yQ
        };
        rA(K0, aQ, sQ), Q.write(K0).catch(() => Z.error("Sending response failed."))
      }
      iA(W1);
      let v0 = V.get(W1.method),
        k0, f0;
      if (v0) k0 = v0.type, f0 = v0.handler;
      let G0 = Date.now();
      if (f0 || X) {
        let yQ = W1.id ?? String(Date.now()),
          aQ = G51.is(e.receiver) ? e.receiver.createCancellationTokenSource(yQ) : e.receiver.createCancellationTokenSource(W1);
        if (W1.id !== null && U.has(W1.id)) aQ.cancel();
        if (W1.id !== null) q.set(yQ, aQ);
        try {
          let sQ;
          if (f0)
            if (W1.params === void 0) {
              if (k0 !== void 0 && k0.numberOfParams !== 0) {
                a1(new z4.ResponseError(z4.ErrorCodes.InvalidParams, `Request ${W1.method} defines ${k0.numberOfParams} params but received none.`), W1.method, G0);
                return
              }
              sQ = f0(aQ.token)
            } else if (Array.isArray(W1.params)) {
            if (k0 !== void 0 && k0.parameterStructures === z4.ParameterStructures.byName) {
              a1(new z4.ResponseError(z4.ErrorCodes.InvalidParams, `Request ${W1.method} defines parameters by name but received parameters by position`), W1.method, G0);
              return
            }
            sQ = f0(...W1.params, aQ.token)
          } else {
            if (k0 !== void 0 && k0.parameterStructures === z4.ParameterStructures.byPosition) {
              a1(new z4.ResponseError(z4.ErrorCodes.InvalidParams, `Request ${W1.method} defines parameters by position but received parameters by name`), W1.method, G0);
              return
            }
            sQ = f0(W1.params, aQ.token)
          } else if (X) sQ = X(W1.method, W1.params, aQ.token);
          let K0 = sQ;
          if (!sQ) q.delete(yQ), C0(sQ, W1.method, G0);
          else if (K0.then) K0.then((mB) => {
            q.delete(yQ), O1(mB, W1.method, G0)
          }, (mB) => {
            if (q.delete(yQ), mB instanceof z4.ResponseError) a1(mB, W1.method, G0);
            else if (mB && sY.string(mB.message)) a1(new z4.ResponseError(z4.ErrorCodes.InternalError, `Request ${W1.method} failed with message: ${mB.message}`), W1.method, G0);
            else a1(new z4.ResponseError(z4.ErrorCodes.InternalError, `Request ${W1.method} failed unexpectedly without providing any details.`), W1.method, G0)
          });
          else q.delete(yQ), O1(sQ, W1.method, G0)
        } catch (sQ) {
          if (q.delete(yQ), sQ instanceof z4.ResponseError) O1(sQ, W1.method, G0);
          else if (sQ && sY.string(sQ.message)) a1(new z4.ResponseError(z4.ErrorCodes.InternalError, `Request ${W1.method} failed with message: ${sQ.message}`), W1.method, G0);
          else a1(new z4.ResponseError(z4.ErrorCodes.InternalError, `Request ${W1.method} failed unexpectedly without providing any details.`), W1.method, G0)
        }
      } else a1(new z4.ResponseError(z4.ErrorCodes.MethodNotFound, `Unhandled method ${W1.method}`), W1.method, G0)
    }

    function WA(W1) {
      if (NA()) return;
      if (W1.id === null)
        if (W1.error) Z.error(`Received response message without id: Error is: 
${JSON.stringify(W1.error,void 0,4)}`);
        else Z.error("Received response message without id. No further error information provided.");
      else {
        let O1 = W1.id,
          a1 = E.get(O1);
        if (w1(W1, a1), a1 !== void 0) {
          E.delete(O1);
          try {
            if (W1.error) {
              let C0 = W1.error;
              a1.reject(new z4.ResponseError(C0.code, C0.message, C0.data))
            } else if (W1.result !== void 0) a1.resolve(W1.result);
            else throw Error("Should never happen.")
          } catch (C0) {
            if (C0.message) Z.error(`Response handler '${a1.method}' failed with message: ${C0.message}`);
            else Z.error(`Response handler '${a1.method}' failed unexpectedly.`)
          }
        }
      }
    }

    function EA(W1) {
      if (NA()) return;
      let O1 = void 0,
        a1;
      if (W1.method === pRA.type.method) {
        let C0 = W1.params.id;
        U.delete(C0), J1(W1);
        return
      } else {
        let C0 = K.get(W1.method);
        if (C0) a1 = C0.handler, O1 = C0.type
      }
      if (a1 || F) try {
        if (J1(W1), a1)
          if (W1.params === void 0) {
            if (O1 !== void 0) {
              if (O1.numberOfParams !== 0 && O1.parameterStructures !== z4.ParameterStructures.byName) Z.error(`Notification ${W1.method} defines ${O1.numberOfParams} params but received none.`)
            }
            a1()
          } else if (Array.isArray(W1.params)) {
          let C0 = W1.params;
          if (W1.method === dRA.type.method && C0.length === 2 && Z50.is(C0[0])) a1({
            token: C0[0],
            value: C0[1]
          });
          else {
            if (O1 !== void 0) {
              if (O1.parameterStructures === z4.ParameterStructures.byName) Z.error(`Notification ${W1.method} defines parameters by name but received parameters by position`);
              if (O1.numberOfParams !== W1.params.length) Z.error(`Notification ${W1.method} defines ${O1.numberOfParams} params but received ${C0.length} arguments`)
            }
            a1(...C0)
          }
        } else {
          if (O1 !== void 0 && O1.parameterStructures === z4.ParameterStructures.byPosition) Z.error(`Notification ${W1.method} defines parameters by position but received parameters by name`);
          a1(W1.params)
        } else if (F) F(W1.method, W1.params)
      } catch (C0) {
        if (C0.message) Z.error(`Notification handler '${W1.method}' failed with message: ${C0.message}`);
        else Z.error(`Notification handler '${W1.method}' failed unexpectedly.`)
      } else x.fire(W1)
    }

    function MA(W1) {
      if (!W1) {
        Z.error("Received empty message.");
        return
      }
      Z.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(W1,null,4)}`);
      let O1 = W1;
      if (sY.string(O1.id) || sY.number(O1.id)) {
        let a1 = O1.id,
          C0 = E.get(a1);
        if (C0) C0.reject(Error("The received response has neither a result nor an error property."))
      }
    }

    function DA(W1) {
      if (W1 === void 0 || W1 === null) return;
      switch (w) {
        case k7.Verbose:
          return JSON.stringify(W1, null, 4);
        case k7.Compact:
          return JSON.stringify(W1);
        default:
          return
      }
    }

    function $A(W1) {
      if (w === k7.Off || !R) return;
      if (N === jq.Text) {
        let O1 = void 0;
        if ((w === k7.Verbose || w === k7.Compact) && W1.params) O1 = `Params: ${DA(W1.params)}

`;
        R.log(`Sending request '${W1.method} - (${W1.id})'.`, O1)
      } else jA("send-request", W1)
    }

    function TA(W1) {
      if (w === k7.Off || !R) return;
      if (N === jq.Text) {
        let O1 = void 0;
        if (w === k7.Verbose || w === k7.Compact)
          if (W1.params) O1 = `Params: ${DA(W1.params)}

`;
          else O1 = `No parameters provided.

`;
        R.log(`Sending notification '${W1.method}'.`, O1)
      } else jA("send-notification", W1)
    }

    function rA(W1, O1, a1) {
      if (w === k7.Off || !R) return;
      if (N === jq.Text) {
        let C0 = void 0;
        if (w === k7.Verbose || w === k7.Compact) {
          if (W1.error && W1.error.data) C0 = `Error data: ${DA(W1.error.data)}

`;
          else if (W1.result) C0 = `Result: ${DA(W1.result)}

`;
          else if (W1.error === void 0) C0 = `No result returned.

`
        }
        R.log(`Sending response '${O1} - (${W1.id})'. Processing request took ${Date.now()-a1}ms`, C0)
      } else jA("send-response", W1)
    }

    function iA(W1) {
      if (w === k7.Off || !R) return;
      if (N === jq.Text) {
        let O1 = void 0;
        if ((w === k7.Verbose || w === k7.Compact) && W1.params) O1 = `Params: ${DA(W1.params)}

`;
        R.log(`Received request '${W1.method} - (${W1.id})'.`, O1)
      } else jA("receive-request", W1)
    }

    function J1(W1) {
      if (w === k7.Off || !R || W1.method === B51.type.method) return;
      if (N === jq.Text) {
        let O1 = void 0;
        if (w === k7.Verbose || w === k7.Compact)
          if (W1.params) O1 = `Params: ${DA(W1.params)}

`;
          else O1 = `No parameters provided.

`;
        R.log(`Received notification '${W1.method}'.`, O1)
      } else jA("receive-notification", W1)
    }

    function w1(W1, O1) {
      if (w === k7.Off || !R) return;
      if (N === jq.Text) {
        let a1 = void 0;
        if (w === k7.Verbose || w === k7.Compact) {
          if (W1.error && W1.error.data) a1 = `Error data: ${DA(W1.error.data)}

`;
          else if (W1.result) a1 = `Result: ${DA(W1.result)}

`;
          else if (W1.error === void 0) a1 = `No result returned.

`
        }
        if (O1) {
          let C0 = W1.error ? ` Request failed: ${W1.error.message} (${W1.error.code}).` : "";
          R.log(`Received response '${O1.method} - (${W1.id})' in ${Date.now()-O1.timerStart}ms.${C0}`, a1)
        } else R.log(`Received response ${W1.id} without active response promise.`, a1)
      } else jA("receive-response", W1)
    }

    function jA(W1, O1) {
      if (!R || w === k7.Off) return;
      let a1 = {
        isLSPMessage: !0,
        type: W1,
        message: O1,
        timestamp: Date.now()
      };
      R.log(a1)
    }

    function eA() {
      if (zA()) throw new IWA(cRA.Closed, "Connection is closed.");
      if (NA()) throw new IWA(cRA.Disposed, "Connection is disposed.")
    }

    function t1() {
      if (FA()) throw new IWA(cRA.AlreadyListening, "Connection is already listening")
    }

    function v1() {
      if (!FA()) throw Error("Call listen() first.")
    }

    function F0(W1) {
      if (W1 === void 0) return null;
      else return W1
    }

    function g0(W1) {
      if (W1 === null) return;
      else return W1
    }

    function p0(W1) {
      return W1 !== void 0 && W1 !== null && !Array.isArray(W1) && typeof W1 === "object"
    }

    function n0(W1, O1) {
      switch (W1) {
        case z4.ParameterStructures.auto:
          if (p0(O1)) return g0(O1);
          else return [F0(O1)];
        case z4.ParameterStructures.byName:
          if (!p0(O1)) throw Error("Received parameters by name but param is not an object literal.");
          return g0(O1);
        case z4.ParameterStructures.byPosition:
          return [F0(O1)];
        default:
          throw Error(`Unknown parameter structure ${W1.toString()}`)
      }
    }

    function _1(W1, O1) {
      let a1, C0 = W1.numberOfParams;
      switch (C0) {
        case 0:
          a1 = void 0;
          break;
        case 1:
          a1 = n0(W1.parameterStructures, O1[0]);
          break;
        default:
          a1 = [];
          for (let v0 = 0; v0 < O1.length && v0 < C0; v0++) a1.push(F0(O1[v0]));
          if (O1.length < C0)
            for (let v0 = O1.length; v0 < C0; v0++) a1.push(null);
          break
      }
      return a1
    }
    let zQ = {
      sendNotification: (W1, ...O1) => {
        eA();
        let a1, C0;
        if (sY.string(W1)) {
          a1 = W1;
          let k0 = O1[0],
            f0 = 0,
            G0 = z4.ParameterStructures.auto;
          if (z4.ParameterStructures.is(k0)) f0 = 1, G0 = k0;
          let yQ = O1.length,
            aQ = yQ - f0;
          switch (aQ) {
            case 0:
              C0 = void 0;
              break;
            case 1:
              C0 = n0(G0, O1[f0]);
              break;
            default:
              if (G0 === z4.ParameterStructures.byName) throw Error(`Received ${aQ} parameters for 'by Name' notification parameter structure.`);
              C0 = O1.slice(f0, yQ).map((sQ) => F0(sQ));
              break
          }
        } else {
          let k0 = O1;
          a1 = W1.method, C0 = _1(W1, k0)
        }
        let v0 = {
          jsonrpc: W,
          method: a1,
          params: C0
        };
        return TA(v0), Q.write(v0).catch((k0) => {
          throw Z.error("Sending notification failed."), k0
        })
      },
      onNotification: (W1, O1) => {
        eA();
        let a1;
        if (sY.func(W1)) F = W1;
        else if (O1)
          if (sY.string(W1)) a1 = W1, K.set(W1, {
            type: void 0,
            handler: O1
          });
          else a1 = W1.method, K.set(W1.method, {
            type: W1,
            handler: O1
          });
        return {
          dispose: () => {
            if (a1 !== void 0) K.delete(a1);
            else F = void 0
          }
        }
      },
      onProgress: (W1, O1, a1) => {
        if (D.has(O1)) throw Error(`Progress handler for token ${O1} already registered`);
        return D.set(O1, a1), {
          dispose: () => {
            D.delete(O1)
          }
        }
      },
      sendProgress: (W1, O1, a1) => {
        return zQ.sendNotification(dRA.type, {
          token: O1,
          value: a1
        })
      },
      onUnhandledProgress: p.event,
      sendRequest: (W1, ...O1) => {
        eA(), v1();
        let a1, C0, v0 = void 0;
        if (sY.string(W1)) {
          a1 = W1;
          let yQ = O1[0],
            aQ = O1[O1.length - 1],
            sQ = 0,
            K0 = z4.ParameterStructures.auto;
          if (z4.ParameterStructures.is(yQ)) sQ = 1, K0 = yQ;
          let mB = O1.length;
          if (G50.CancellationToken.is(aQ)) mB = mB - 1, v0 = aQ;
          let e2 = mB - sQ;
          switch (e2) {
            case 0:
              C0 = void 0;
              break;
            case 1:
              C0 = n0(K0, O1[sQ]);
              break;
            default:
              if (K0 === z4.ParameterStructures.byName) throw Error(`Received ${e2} parameters for 'by Name' request parameter structure.`);
              C0 = O1.slice(sQ, mB).map((s8) => F0(s8));
              break
          }
        } else {
          let yQ = O1;
          a1 = W1.method, C0 = _1(W1, yQ);
          let aQ = W1.numberOfParams;
          v0 = G50.CancellationToken.is(yQ[aQ]) ? yQ[aQ] : void 0
        }
        let k0 = I++,
          f0;
        if (v0) f0 = v0.onCancellationRequested(() => {
          let yQ = e.sender.sendCancellation(zQ, k0);
          if (yQ === void 0) return Z.log(`Received no promise from cancellation strategy when cancelling id ${k0}`), Promise.resolve();
          else return yQ.catch(() => {
            Z.log(`Sending cancellation messages for id ${k0} failed`)
          })
        });
        let G0 = {
          jsonrpc: W,
          id: k0,
          method: a1,
          params: C0
        };
        if ($A(G0), typeof e.sender.enableCancellation === "function") e.sender.enableCancellation(G0);
        return new Promise(async (yQ, aQ) => {
          let sQ = (e2) => {
              yQ(e2), e.sender.cleanup(k0), f0?.dispose()
            },
            K0 = (e2) => {
              aQ(e2), e.sender.cleanup(k0), f0?.dispose()
            },
            mB = {
              method: a1,
              timerStart: Date.now(),
              resolve: sQ,
              reject: K0
            };
          try {
            E.set(k0, mB), await Q.write(G0)
          } catch (e2) {
            throw E.delete(k0), mB.reject(new z4.ResponseError(z4.ErrorCodes.MessageWriteError, e2.message ? e2.message : "Unknown reason")), Z.error("Sending request failed."), e2
          }
        })
      },
      onRequest: (W1, O1) => {
        eA();
        let a1 = null;
        if (I50.is(W1)) a1 = void 0, X = W1;
        else if (sY.string(W1)) {
          if (a1 = null, O1 !== void 0) a1 = W1, V.set(W1, {
            handler: O1,
            type: void 0
          })
        } else if (O1 !== void 0) a1 = W1.method, V.set(W1.method, {
          type: W1,
          handler: O1
        });
        return {
          dispose: () => {
            if (a1 === null) return;
            if (a1 !== void 0) V.delete(a1);
            else X = void 0
          }
        }
      },
      hasPendingResponse: () => {
        return E.size > 0
      },
      trace: async (W1, O1, a1) => {
        let C0 = !1,
          v0 = jq.Text;
        if (a1 !== void 0)
          if (sY.boolean(a1)) C0 = a1;
          else C0 = a1.sendNotification || !1, v0 = a1.traceFormat || jq.Text;
        if (w = W1, N = v0, w === k7.Off) R = void 0;
        else R = O1;
        if (C0 && !zA() && !NA()) await zQ.sendNotification(Y50.type, {
          value: k7.toString(W1)
        })
      },
      onError: y.event,
      onClose: v.event,
      onUnhandledNotification: x.event,
      onDispose: u.event,
      end: () => {
        Q.end()
      },
      dispose: () => {
        if (NA()) return;
        T = PP.Disposed, u.fire(void 0);
        let W1 = new z4.ResponseError(z4.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
        for (let O1 of E.values()) O1.reject(W1);
        if (E = new Map, q = new Map, U = new Set, C = new jS2.LinkedMap, sY.func(Q.dispose)) Q.dispose();
        if (sY.func(A.dispose)) A.dispose()
      },
      listen: () => {
        eA(), t1(), T = PP.Listening, A.listen(oA)
      },
      inspect: () => {
        (0, PS2.default)().console.log("inspect")
      }
    };
    return zQ.onNotification(B51.type, (W1) => {
      if (w === k7.Off || !R) return;
      let O1 = w === k7.Verbose || w === k7.Compact;
      R.log(W1.message, O1 ? W1.verbose : void 0)
    }), zQ.onNotification(dRA.type, (W1) => {
      let O1 = D.get(W1.token);
      if (O1) O1(W1.value);
      else p.fire(W1)
    }), zQ
  }
  yS2.createMessageConnection = Tg5
})
// @from(Start 11553845, End 11563642)
W51 = z((v2) => {
  Object.defineProperty(v2, "__esModule", {
    value: !0
  });
  v2.ProgressType = v2.ProgressToken = v2.createMessageConnection = v2.NullLogger = v2.ConnectionOptions = v2.ConnectionStrategy = v2.AbstractMessageBuffer = v2.WriteableStreamMessageWriter = v2.AbstractMessageWriter = v2.MessageWriter = v2.ReadableStreamMessageReader = v2.AbstractMessageReader = v2.MessageReader = v2.SharedArrayReceiverStrategy = v2.SharedArraySenderStrategy = v2.CancellationToken = v2.CancellationTokenSource = v2.Emitter = v2.Event = v2.Disposable = v2.LRUCache = v2.Touch = v2.LinkedMap = v2.ParameterStructures = v2.NotificationType9 = v2.NotificationType8 = v2.NotificationType7 = v2.NotificationType6 = v2.NotificationType5 = v2.NotificationType4 = v2.NotificationType3 = v2.NotificationType2 = v2.NotificationType1 = v2.NotificationType0 = v2.NotificationType = v2.ErrorCodes = v2.ResponseError = v2.RequestType9 = v2.RequestType8 = v2.RequestType7 = v2.RequestType6 = v2.RequestType5 = v2.RequestType4 = v2.RequestType3 = v2.RequestType2 = v2.RequestType1 = v2.RequestType0 = v2.RequestType = v2.Message = v2.RAL = void 0;
  v2.MessageStrategy = v2.CancellationStrategy = v2.CancellationSenderStrategy = v2.CancellationReceiverStrategy = v2.ConnectionError = v2.ConnectionErrors = v2.LogTraceNotification = v2.SetTraceNotification = v2.TraceFormat = v2.TraceValues = v2.Trace = void 0;
  var aZ = c60();
  Object.defineProperty(v2, "Message", {
    enumerable: !0,
    get: function() {
      return aZ.Message
    }
  });
  Object.defineProperty(v2, "RequestType", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType
    }
  });
  Object.defineProperty(v2, "RequestType0", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType0
    }
  });
  Object.defineProperty(v2, "RequestType1", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType1
    }
  });
  Object.defineProperty(v2, "RequestType2", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType2
    }
  });
  Object.defineProperty(v2, "RequestType3", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType3
    }
  });
  Object.defineProperty(v2, "RequestType4", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType4
    }
  });
  Object.defineProperty(v2, "RequestType5", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType5
    }
  });
  Object.defineProperty(v2, "RequestType6", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType6
    }
  });
  Object.defineProperty(v2, "RequestType7", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType7
    }
  });
  Object.defineProperty(v2, "RequestType8", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType8
    }
  });
  Object.defineProperty(v2, "RequestType9", {
    enumerable: !0,
    get: function() {
      return aZ.RequestType9
    }
  });
  Object.defineProperty(v2, "ResponseError", {
    enumerable: !0,
    get: function() {
      return aZ.ResponseError
    }
  });
  Object.defineProperty(v2, "ErrorCodes", {
    enumerable: !0,
    get: function() {
      return aZ.ErrorCodes
    }
  });
  Object.defineProperty(v2, "NotificationType", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType
    }
  });
  Object.defineProperty(v2, "NotificationType0", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType0
    }
  });
  Object.defineProperty(v2, "NotificationType1", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType1
    }
  });
  Object.defineProperty(v2, "NotificationType2", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType2
    }
  });
  Object.defineProperty(v2, "NotificationType3", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType3
    }
  });
  Object.defineProperty(v2, "NotificationType4", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType4
    }
  });
  Object.defineProperty(v2, "NotificationType5", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType5
    }
  });
  Object.defineProperty(v2, "NotificationType6", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType6
    }
  });
  Object.defineProperty(v2, "NotificationType7", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType7
    }
  });
  Object.defineProperty(v2, "NotificationType8", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType8
    }
  });
  Object.defineProperty(v2, "NotificationType9", {
    enumerable: !0,
    get: function() {
      return aZ.NotificationType9
    }
  });
  Object.defineProperty(v2, "ParameterStructures", {
    enumerable: !0,
    get: function() {
      return aZ.ParameterStructures
    }
  });
  var X50 = l60();
  Object.defineProperty(v2, "LinkedMap", {
    enumerable: !0,
    get: function() {
      return X50.LinkedMap
    }
  });
  Object.defineProperty(v2, "LRUCache", {
    enumerable: !0,
    get: function() {
      return X50.LRUCache
    }
  });
  Object.defineProperty(v2, "Touch", {
    enumerable: !0,
    get: function() {
      return X50.Touch
    }
  });
  var cg5 = ij2();
  Object.defineProperty(v2, "Disposable", {
    enumerable: !0,
    get: function() {
      return cg5.Disposable
    }
  });
  var gS2 = GWA();
  Object.defineProperty(v2, "Event", {
    enumerable: !0,
    get: function() {
      return gS2.Event
    }
  });
  Object.defineProperty(v2, "Emitter", {
    enumerable: !0,
    get: function() {
      return gS2.Emitter
    }
  });
  var uS2 = Q51();
  Object.defineProperty(v2, "CancellationTokenSource", {
    enumerable: !0,
    get: function() {
      return uS2.CancellationTokenSource
    }
  });
  Object.defineProperty(v2, "CancellationToken", {
    enumerable: !0,
    get: function() {
      return uS2.CancellationToken
    }
  });
  var mS2 = JS2();
  Object.defineProperty(v2, "SharedArraySenderStrategy", {
    enumerable: !0,
    get: function() {
      return mS2.SharedArraySenderStrategy
    }
  });
  Object.defineProperty(v2, "SharedArrayReceiverStrategy", {
    enumerable: !0,
    get: function() {
      return mS2.SharedArrayReceiverStrategy
    }
  });
  var V50 = CS2();
  Object.defineProperty(v2, "MessageReader", {
    enumerable: !0,
    get: function() {
      return V50.MessageReader
    }
  });
  Object.defineProperty(v2, "AbstractMessageReader", {
    enumerable: !0,
    get: function() {
      return V50.AbstractMessageReader
    }
  });
  Object.defineProperty(v2, "ReadableStreamMessageReader", {
    enumerable: !0,
    get: function() {
      return V50.ReadableStreamMessageReader
    }
  });
  var F50 = LS2();
  Object.defineProperty(v2, "MessageWriter", {
    enumerable: !0,
    get: function() {
      return F50.MessageWriter
    }
  });
  Object.defineProperty(v2, "AbstractMessageWriter", {
    enumerable: !0,
    get: function() {
      return F50.AbstractMessageWriter
    }
  });
  Object.defineProperty(v2, "WriteableStreamMessageWriter", {
    enumerable: !0,
    get: function() {
      return F50.WriteableStreamMessageWriter
    }
  });
  var pg5 = TS2();
  Object.defineProperty(v2, "AbstractMessageBuffer", {
    enumerable: !0,
    get: function() {
      return pg5.AbstractMessageBuffer
    }
  });
  var pD = hS2();
  Object.defineProperty(v2, "ConnectionStrategy", {
    enumerable: !0,
    get: function() {
      return pD.ConnectionStrategy
    }
  });
  Object.defineProperty(v2, "ConnectionOptions", {
    enumerable: !0,
    get: function() {
      return pD.ConnectionOptions
    }
  });
  Object.defineProperty(v2, "NullLogger", {
    enumerable: !0,
    get: function() {
      return pD.NullLogger
    }
  });
  Object.defineProperty(v2, "createMessageConnection", {
    enumerable: !0,
    get: function() {
      return pD.createMessageConnection
    }
  });
  Object.defineProperty(v2, "ProgressToken", {
    enumerable: !0,
    get: function() {
      return pD.ProgressToken
    }
  });
  Object.defineProperty(v2, "ProgressType", {
    enumerable: !0,
    get: function() {
      return pD.ProgressType
    }
  });
  Object.defineProperty(v2, "Trace", {
    enumerable: !0,
    get: function() {
      return pD.Trace
    }
  });
  Object.defineProperty(v2, "TraceValues", {
    enumerable: !0,
    get: function() {
      return pD.TraceValues
    }
  });
  Object.defineProperty(v2, "TraceFormat", {
    enumerable: !0,
    get: function() {
      return pD.TraceFormat
    }
  });
  Object.defineProperty(v2, "SetTraceNotification", {
    enumerable: !0,
    get: function() {
      return pD.SetTraceNotification
    }
  });
  Object.defineProperty(v2, "LogTraceNotification", {
    enumerable: !0,
    get: function() {
      return pD.LogTraceNotification
    }
  });
  Object.defineProperty(v2, "ConnectionErrors", {
    enumerable: !0,
    get: function() {
      return pD.ConnectionErrors
    }
  });
  Object.defineProperty(v2, "ConnectionError", {
    enumerable: !0,
    get: function() {
      return pD.ConnectionError
    }
  });
  Object.defineProperty(v2, "CancellationReceiverStrategy", {
    enumerable: !0,
    get: function() {
      return pD.CancellationReceiverStrategy
    }
  });
  Object.defineProperty(v2, "CancellationSenderStrategy", {
    enumerable: !0,
    get: function() {
      return pD.CancellationSenderStrategy
    }
  });
  Object.defineProperty(v2, "CancellationStrategy", {
    enumerable: !0,
    get: function() {
      return pD.CancellationStrategy
    }
  });
  Object.defineProperty(v2, "MessageStrategy", {
    enumerable: !0,
    get: function() {
      return pD.MessageStrategy
    }
  });
  var lg5 = Dn();
  v2.RAL = lg5.default
})
// @from(Start 11563648, End 11567296)
nS2 = z((iS2) => {
  Object.defineProperty(iS2, "__esModule", {
    value: !0
  });
  var dS2 = UA("util"),
    ih = W51();
  class X51 extends ih.AbstractMessageBuffer {
    constructor(A = "utf-8") {
      super(A)
    }
    emptyBuffer() {
      return X51.emptyBuffer
    }
    fromString(A, Q) {
      return Buffer.from(A, Q)
    }
    toString(A, Q) {
      if (A instanceof Buffer) return A.toString(Q);
      else return new dS2.TextDecoder(Q).decode(A)
    }
    asNative(A, Q) {
      if (Q === void 0) return A instanceof Buffer ? A : Buffer.from(A);
      else return A instanceof Buffer ? A.slice(0, Q) : Buffer.from(A, 0, Q)
    }
    allocNative(A) {
      return Buffer.allocUnsafe(A)
    }
  }
  X51.emptyBuffer = Buffer.allocUnsafe(0);
  class cS2 {
    constructor(A) {
      this.stream = A
    }
    onClose(A) {
      return this.stream.on("close", A), ih.Disposable.create(() => this.stream.off("close", A))
    }
    onError(A) {
      return this.stream.on("error", A), ih.Disposable.create(() => this.stream.off("error", A))
    }
    onEnd(A) {
      return this.stream.on("end", A), ih.Disposable.create(() => this.stream.off("end", A))
    }
    onData(A) {
      return this.stream.on("data", A), ih.Disposable.create(() => this.stream.off("data", A))
    }
  }
  class pS2 {
    constructor(A) {
      this.stream = A
    }
    onClose(A) {
      return this.stream.on("close", A), ih.Disposable.create(() => this.stream.off("close", A))
    }
    onError(A) {
      return this.stream.on("error", A), ih.Disposable.create(() => this.stream.off("error", A))
    }
    onEnd(A) {
      return this.stream.on("end", A), ih.Disposable.create(() => this.stream.off("end", A))
    }
    write(A, Q) {
      return new Promise((B, G) => {
        let Z = (I) => {
          if (I === void 0 || I === null) B();
          else G(I)
        };
        if (typeof A === "string") this.stream.write(A, Q, Z);
        else this.stream.write(A, Z)
      })
    }
    end() {
      this.stream.end()
    }
  }
  var lS2 = Object.freeze({
    messageBuffer: Object.freeze({
      create: (A) => new X51(A)
    }),
    applicationJson: Object.freeze({
      encoder: Object.freeze({
        name: "application/json",
        encode: (A, Q) => {
          try {
            return Promise.resolve(Buffer.from(JSON.stringify(A, void 0, 0), Q.charset))
          } catch (B) {
            return Promise.reject(B)
          }
        }
      }),
      decoder: Object.freeze({
        name: "application/json",
        decode: (A, Q) => {
          try {
            if (A instanceof Buffer) return Promise.resolve(JSON.parse(A.toString(Q.charset)));
            else return Promise.resolve(JSON.parse(new dS2.TextDecoder(Q.charset).decode(A)))
          } catch (B) {
            return Promise.reject(B)
          }
        }
      })
    }),
    stream: Object.freeze({
      asReadableStream: (A) => new cS2(A),
      asWritableStream: (A) => new pS2(A)
    }),
    console,
    timer: Object.freeze({
      setTimeout(A, Q, ...B) {
        let G = setTimeout(A, Q, ...B);
        return {
          dispose: () => clearTimeout(G)
        }
      },
      setImmediate(A, ...Q) {
        let B = setImmediate(A, ...Q);
        return {
          dispose: () => clearImmediate(B)
        }
      },
      setInterval(A, Q, ...B) {
        let G = setInterval(A, Q, ...B);
        return {
          dispose: () => clearInterval(G)
        }
      }
    })
  });

  function K50() {
    return lS2
  }(function(A) {
    function Q() {
      ih.RAL.install(lS2)
    }
    A.install = Q
  })(K50 || (K50 = {}));
  iS2.default = K50
})
// @from(Start 11567302, End 11573785)
A_2 = z((n5) => {
  var rg5 = n5 && n5.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    og5 = n5 && n5.__exportStar || function(A, Q) {
      for (var B in A)
        if (B !== "default" && !Object.prototype.hasOwnProperty.call(Q, B)) rg5(Q, A, B)
    };
  Object.defineProperty(n5, "__esModule", {
    value: !0
  });
  n5.createMessageConnection = n5.createServerSocketTransport = n5.createClientSocketTransport = n5.createServerPipeTransport = n5.createClientPipeTransport = n5.generateRandomPipeName = n5.StreamMessageWriter = n5.StreamMessageReader = n5.SocketMessageWriter = n5.SocketMessageReader = n5.PortMessageWriter = n5.PortMessageReader = n5.IPCMessageWriter = n5.IPCMessageReader = void 0;
  var YWA = nS2();
  YWA.default.install();
  var aS2 = UA("path"),
    tg5 = UA("os"),
    eg5 = UA("crypto"),
    V51 = UA("net"),
    Sq = W51();
  og5(W51(), n5);
  class rS2 extends Sq.AbstractMessageReader {
    constructor(A) {
      super();
      this.process = A;
      let Q = this.process;
      Q.on("error", (B) => this.fireError(B)), Q.on("close", () => this.fireClose())
    }
    listen(A) {
      return this.process.on("message", A), Sq.Disposable.create(() => this.process.off("message", A))
    }
  }
  n5.IPCMessageReader = rS2;
  class oS2 extends Sq.AbstractMessageWriter {
    constructor(A) {
      super();
      this.process = A, this.errorCount = 0;
      let Q = this.process;
      Q.on("error", (B) => this.fireError(B)), Q.on("close", () => this.fireClose)
    }
    write(A) {
      try {
        if (typeof this.process.send === "function") this.process.send(A, void 0, void 0, (Q) => {
          if (Q) this.errorCount++, this.handleError(Q, A);
          else this.errorCount = 0
        });
        return Promise.resolve()
      } catch (Q) {
        return this.handleError(Q, A), Promise.reject(Q)
      }
    }
    handleError(A, Q) {
      this.errorCount++, this.fireError(A, Q, this.errorCount)
    }
    end() {}
  }
  n5.IPCMessageWriter = oS2;
  class tS2 extends Sq.AbstractMessageReader {
    constructor(A) {
      super();
      this.onData = new Sq.Emitter, A.on("close", () => this.fireClose), A.on("error", (Q) => this.fireError(Q)), A.on("message", (Q) => {
        this.onData.fire(Q)
      })
    }
    listen(A) {
      return this.onData.event(A)
    }
  }
  n5.PortMessageReader = tS2;
  class eS2 extends Sq.AbstractMessageWriter {
    constructor(A) {
      super();
      this.port = A, this.errorCount = 0, A.on("close", () => this.fireClose()), A.on("error", (Q) => this.fireError(Q))
    }
    write(A) {
      try {
        return this.port.postMessage(A), Promise.resolve()
      } catch (Q) {
        return this.handleError(Q, A), Promise.reject(Q)
      }
    }
    handleError(A, Q) {
      this.errorCount++, this.fireError(A, Q, this.errorCount)
    }
    end() {}
  }
  n5.PortMessageWriter = eS2;
  class JWA extends Sq.ReadableStreamMessageReader {
    constructor(A, Q = "utf-8") {
      super((0, YWA.default)().stream.asReadableStream(A), Q)
    }
  }
  n5.SocketMessageReader = JWA;
  class WWA extends Sq.WriteableStreamMessageWriter {
    constructor(A, Q) {
      super((0, YWA.default)().stream.asWritableStream(A), Q);
      this.socket = A
    }
    dispose() {
      super.dispose(), this.socket.destroy()
    }
  }
  n5.SocketMessageWriter = WWA;
  class D50 extends Sq.ReadableStreamMessageReader {
    constructor(A, Q) {
      super((0, YWA.default)().stream.asReadableStream(A), Q)
    }
  }
  n5.StreamMessageReader = D50;
  class H50 extends Sq.WriteableStreamMessageWriter {
    constructor(A, Q) {
      super((0, YWA.default)().stream.asWritableStream(A), Q)
    }
  }
  n5.StreamMessageWriter = H50;
  var sS2 = process.env.XDG_RUNTIME_DIR,
    Au5 = new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);

  function Qu5() {
    let A = (0, eg5.randomBytes)(21).toString("hex");
    if (process.platform === "win32") return `\\\\.\\pipe\\vscode-jsonrpc-${A}-sock`;
    let Q;
    if (sS2) Q = aS2.join(sS2, `vscode-ipc-${A}.sock`);
    else Q = aS2.join(tg5.tmpdir(), `vscode-${A}.sock`);
    let B = Au5.get(process.platform);
    if (B !== void 0 && Q.length > B)(0, YWA.default)().console.warn(`WARNING: IPC handle "${Q}" is longer than ${B} characters.`);
    return Q
  }
  n5.generateRandomPipeName = Qu5;

  function Bu5(A, Q = "utf-8") {
    let B, G = new Promise((Z, I) => {
      B = Z
    });
    return new Promise((Z, I) => {
      let Y = (0, V51.createServer)((J) => {
        Y.close(), B([new JWA(J, Q), new WWA(J, Q)])
      });
      Y.on("error", I), Y.listen(A, () => {
        Y.removeListener("error", I), Z({
          onConnected: () => {
            return G
          }
        })
      })
    })
  }
  n5.createClientPipeTransport = Bu5;

  function Gu5(A, Q = "utf-8") {
    let B = (0, V51.createConnection)(A);
    return [new JWA(B, Q), new WWA(B, Q)]
  }
  n5.createServerPipeTransport = Gu5;

  function Zu5(A, Q = "utf-8") {
    let B, G = new Promise((Z, I) => {
      B = Z
    });
    return new Promise((Z, I) => {
      let Y = (0, V51.createServer)((J) => {
        Y.close(), B([new JWA(J, Q), new WWA(J, Q)])
      });
      Y.on("error", I), Y.listen(A, "127.0.0.1", () => {
        Y.removeListener("error", I), Z({
          onConnected: () => {
            return G
          }
        })
      })
    })
  }
  n5.createClientSocketTransport = Zu5;

  function Iu5(A, Q = "utf-8") {
    let B = (0, V51.createConnection)(A, "127.0.0.1");
    return [new JWA(B, Q), new WWA(B, Q)]
  }
  n5.createServerSocketTransport = Iu5;

  function Yu5(A) {
    let Q = A;
    return Q.read !== void 0 && Q.addListener !== void 0
  }

  function Ju5(A) {
    let Q = A;
    return Q.write !== void 0 && Q.addListener !== void 0
  }

  function Wu5(A, Q, B, G) {
    if (!B) B = Sq.NullLogger;
    let Z = Yu5(A) ? new D50(A) : A,
      I = Ju5(Q) ? new H50(Q) : Q;
    if (Sq.ConnectionStrategy.is(G)) G = {
      connectionStrategy: G
    };
    return (0, Sq.createMessageConnection)(Z, I, B, G)
  }
  n5.createMessageConnection = Wu5
})
// @from(Start 11573836, End 11578998)
function Q_2(A) {
  let Q, B, G, Z = !1,
    I = !1,
    Y, J = !1,
    W = [],
    X = [];

  function V() {
    if (I) throw Y || Error(`LSP server ${A} failed to start`)
  }
  return {
    get capabilities() {
      return G
    },
    get isInitialized() {
      return Z
    },
    async start(F, K, D) {
      try {
        if (Q = Xu5(F, K, {
            stdio: ["pipe", "pipe", "pipe"],
            env: D?.env ? {
              ...globalThis.process.env,
              ...D.env
            } : void 0,
            cwd: D?.cwd
          }), !Q.stdout || !Q.stdin) throw Error("LSP server process stdio not available");
        let H = Q;
        if (await new Promise((U, q) => {
            let w = () => {
                R(), U()
              },
              N = (T) => {
                R(), q(T)
              },
              R = () => {
                H.removeListener("spawn", w), H.removeListener("error", N)
              };
            H.once("spawn", w), H.once("error", N)
          }), Q.stderr) Q.stderr.on("data", (U) => {
          let q = U.toString().trim();
          if (q) g(`[LSP SERVER ${A}] ${q}`)
        });
        Q.on("error", (U) => {
          if (!J) I = !0, Y = U, AA(Error(`LSP server ${A} failed to start: ${U.message}`))
        }), Q.on("exit", (U, q) => {
          if (U !== 0 && U !== null && !J) Z = !1, I = !1, Y = void 0, AA(Error(`LSP server ${A} crashed with exit code ${U}`))
        }), Q.stdin.on("error", (U) => {
          if (!J) g(`LSP server ${A} stdin error: ${U.message}`)
        });
        let C = new Hn.StreamMessageReader(Q.stdout),
          E = new Hn.StreamMessageWriter(Q.stdin);
        B = Hn.createMessageConnection(C, E), B.onError(([U, q, w]) => {
          if (!J) I = !0, Y = U, AA(Error(`LSP server ${A} connection error: ${U.message}`))
        }), B.onClose(() => {
          if (!J) Z = !1, g(`LSP server ${A} connection closed`)
        }), B.listen(), B.trace(Hn.Trace.Verbose, {
          log: (U) => {
            g(`[LSP PROTOCOL ${A}] ${U}`)
          }
        }).catch((U) => {
          g(`Failed to enable tracing for ${A}: ${U.message}`)
        });
        for (let {
            method: U,
            handler: q
          }
          of W) B.onNotification(U, q), g(`Applied queued notification handler for ${A}.${U}`);
        W.length = 0;
        for (let {
            method: U,
            handler: q
          }
          of X) B.onRequest(U, q), g(`Applied queued request handler for ${A}.${U}`);
        X.length = 0, g(`LSP client started for ${A}`)
      } catch (H) {
        throw AA(Error(`LSP server ${A} failed to start: ${H.message}`)), H
      }
    },
    async initialize(F) {
      if (!B) throw Error("LSP client not started");
      V();
      try {
        let K = await B.sendRequest("initialize", F);
        return G = K.capabilities, await B.sendNotification("initialized", {}), Z = !0, g(`LSP server ${A} initialized`), K
      } catch (K) {
        throw AA(Error(`LSP server ${A} initialize failed: ${K.message}`)), K
      }
    },
    async sendRequest(F, K) {
      if (!B) throw Error("LSP client not started");
      if (V(), !Z) throw Error("LSP server not initialized");
      try {
        return await B.sendRequest(F, K)
      } catch (D) {
        throw AA(Error(`LSP server ${A} request ${F} failed: ${D.message}`)), D
      }
    },
    async sendNotification(F, K) {
      if (!B) throw Error("LSP client not started");
      V();
      try {
        await B.sendNotification(F, K)
      } catch (D) {
        AA(Error(`LSP server ${A} notification ${F} failed: ${D.message}`)), g(`Notification ${F} failed but continuing`)
      }
    },
    onNotification(F, K) {
      if (!B) {
        W.push({
          method: F,
          handler: K
        }), g(`Queued notification handler for ${A}.${F} (connection not ready)`);
        return
      }
      V(), B.onNotification(F, K)
    },
    onRequest(F, K) {
      if (!B) {
        X.push({
          method: F,
          handler: K
        }), g(`Queued request handler for ${A}.${F} (connection not ready)`);
        return
      }
      V(), B.onRequest(F, K)
    },
    async stop() {
      let F;
      J = !0;
      try {
        if (B) await B.sendRequest("shutdown", null), await B.sendNotification("exit", null)
      } catch (K) {
        let D = K;
        AA(Error(`LSP server ${A} stop failed: ${D.message}`)), F = D
      } finally {
        if (B) {
          try {
            B.dispose()
          } catch (K) {
            g(`Connection disposal failed for ${A}: ${K.message}`)
          }
          B = void 0
        }
        if (Q) {
          if (Q.removeAllListeners("error"), Q.removeAllListeners("exit"), Q.stdin) Q.stdin.removeAllListeners("error");
          if (Q.stderr) Q.stderr.removeAllListeners("data");
          try {
            Q.kill()
          } catch (K) {
            g(`Process kill failed for ${A} (may already be dead): ${K.message}`)
          }
          Q = void 0
        }
        if (Z = !1, G = void 0, J = !1, F) I = !0, Y = F;
        g(`LSP client stopped for ${A}`)
      }
      if (F) throw F
    }
  }
}
// @from(Start 11579003, End 11579005)
Hn
// @from(Start 11579011, End 11579065)
B_2 = L(() => {
  g1();
  V0();
  Hn = BA(A_2(), 1)
})
// @from(Start 11579097, End 11583559)
function Z_2(A, Q) {
  if (Q.restartOnCrash !== void 0) throw Error(`LSP server '${A}': restartOnCrash is not yet implemented. Remove this field from the configuration.`);
  if (Q.startupTimeout !== void 0) throw Error(`LSP server '${A}': startupTimeout is not yet implemented. Remove this field from the configuration.`);
  if (Q.shutdownTimeout !== void 0) throw Error(`LSP server '${A}': shutdownTimeout is not yet implemented. Remove this field from the configuration.`);
  let B = Q_2(A),
    G = "stopped",
    Z, I, Y = 0;
  async function J() {
    if (G === "running" || G === "starting") return;
    try {
      G = "starting", g(`Starting LSP server instance: ${A}`), await B.start(Q.command, Q.args || [], {
        env: Q.env,
        cwd: Q.workspaceFolder
      });
      let C = Q.workspaceFolder || W0(),
        E = `file://${C}`,
        U = {
          processId: process.pid,
          workspaceFolders: [{
            uri: E,
            name: G_2.basename(C)
          }],
          rootPath: C,
          rootUri: E,
          capabilities: {
            workspace: {
              configuration: !1,
              workspaceFolders: !1
            },
            textDocument: {
              synchronization: {
                dynamicRegistration: !1,
                willSave: !1,
                willSaveWaitUntil: !1,
                didSave: !0
              },
              publishDiagnostics: {
                relatedInformation: !0,
                tagSupport: {
                  valueSet: [1, 2]
                },
                versionSupport: !1,
                codeDescriptionSupport: !0,
                dataSupport: !1
              },
              hover: {
                dynamicRegistration: !1,
                contentFormat: ["markdown", "plaintext"]
              },
              definition: {
                dynamicRegistration: !1,
                linkSupport: !0
              },
              references: {
                dynamicRegistration: !1
              },
              documentSymbol: {
                dynamicRegistration: !1,
                hierarchicalDocumentSymbolSupport: !0
              }
            },
            general: {
              positionEncodings: ["utf-16"]
            }
          }
        };
      await B.initialize(U), G = "running", Z = new Date, g(`LSP server instance started: ${A}`)
    } catch (C) {
      throw G = "error", I = C, AA(C), C
    }
  }
  async function W() {
    if (G === "stopped" || G === "stopping") return;
    try {
      G = "stopping", await B.stop(), G = "stopped", g(`LSP server instance stopped: ${A}`)
    } catch (C) {
      throw G = "error", I = C, AA(C), C
    }
  }
  async function X() {
    try {
      await W()
    } catch (E) {
      let U = Error(`Failed to stop LSP server '${A}' during restart: ${E.message}`);
      throw AA(U), U
    }
    Y++;
    let C = Q.maxRestarts ?? 3;
    if (Y > C) {
      let E = Error(`Max restart attempts (${C}) exceeded for server '${A}'`);
      throw AA(E), E
    }
    try {
      await J()
    } catch (E) {
      let U = Error(`Failed to start LSP server '${A}' during restart (attempt ${Y}/${C}): ${E.message}`);
      throw AA(U), U
    }
  }

  function V() {
    return G === "running" && B.isInitialized
  }
  async function F(C, E) {
    if (!V()) {
      let U = Error(`Cannot send request to LSP server '${A}': server is ${G}${I?`, last error: ${I.message}`:""}`);
      throw AA(U), U
    }
    try {
      return await B.sendRequest(C, E)
    } catch (U) {
      let q = Error(`LSP request '${C}' failed for server '${A}': ${U.message}`);
      throw AA(q), q
    }
  }
  async function K(C, E) {
    if (!V()) {
      let U = Error(`Cannot send notification to LSP server '${A}': server is ${G}`);
      throw AA(U), U
    }
    try {
      await B.sendNotification(C, E)
    } catch (U) {
      let q = Error(`LSP notification '${C}' failed for server '${A}': ${U.message}`);
      throw AA(q), q
    }
  }

  function D(C, E) {
    B.onNotification(C, E)
  }

  function H(C, E) {
    B.onRequest(C, E)
  }
  return {
    name: A,
    config: Q,
    get state() {
      return G
    },
    get startTime() {
      return Z
    },
    get lastError() {
      return I
    },
    get restartCount() {
      return Y
    },
    start: J,
    stop: W,
    restart: X,
    isHealthy: V,
    sendRequest: F,
    sendNotification: K,
    onNotification: D,
    onRequest: H
  }
}
// @from(Start 11583564, End 11583614)
I_2 = L(() => {
  B_2();
  g1();
  V0();
  U2()
})
// @from(Start 11583741, End 11583885)
function Ku5(A, Q) {
  let B = C50(A),
    G = C50(A, Q),
    Z = Fu5(B, G);
  if (Z.startsWith("..") || C50(Z) === Z) return null;
  return G
}
// @from(Start 11583886, End 11585139)
async function J_2(A, Q = []) {
  let B = {},
    G = Vu5(A.path, ".lsp.json");
  try {
    let Z = await Y_2(G, "utf-8"),
      I = JSON.parse(Z),
      Y = j.record(j.string(), RIA).safeParse(I);
    if (Y.success) Object.assign(B, Y.data);
    else {
      let J = `LSP config validation failed for .lsp.json in plugin ${A.name}: ${Y.error.message}`;
      AA(Error(J)), Q.push({
        type: "lsp-config-invalid",
        plugin: A.name,
        serverName: ".lsp.json",
        validationError: Y.error.message,
        source: "plugin"
      })
    }
  } catch (Z) {
    if (Z.code !== "ENOENT") {
      let I = Z instanceof Error ? `Failed to read/parse .lsp.json in plugin ${A.name}: ${Z.message}` : `Failed to read/parse .lsp.json file in plugin ${A.name}`;
      AA(Z instanceof Error ? Z : Error(I)), Q.push({
        type: "lsp-config-invalid",
        plugin: A.name,
        serverName: ".lsp.json",
        validationError: Z instanceof Error ? `Failed to parse JSON: ${Z.message}` : "Failed to parse JSON file",
        source: "plugin"
      })
    }
  }
  if (A.manifest.lspServers) {
    let Z = await Du5(A.manifest.lspServers, A.path, A.name, Q);
    if (Z) Object.assign(B, Z)
  }
  return Object.keys(B).length > 0 ? B : void 0
}
// @from(Start 11585140, End 11587247)
async function Du5(A, Q, B, G) {
  let Z = {},
    I = Array.isArray(A) ? A : [A];
  for (let Y of I)
    if (typeof Y === "string") {
      let J = Ku5(Q, Y);
      if (!J) {
        let W = `Security: Path traversal attempt blocked in plugin ${B}: ${Y}`;
        AA(Error(W)), g(W, {
          level: "warn"
        }), G.push({
          type: "lsp-config-invalid",
          plugin: B,
          serverName: Y,
          validationError: "Invalid path: must be relative and within plugin directory",
          source: "plugin"
        });
        continue
      }
      try {
        let W = await Y_2(J, "utf-8"),
          X = JSON.parse(W),
          V = j.record(j.string(), RIA).safeParse(X);
        if (V.success) Object.assign(Z, V.data);
        else {
          let F = `LSP config validation failed for ${Y} in plugin ${B}: ${V.error.message}`;
          AA(Error(F)), G.push({
            type: "lsp-config-invalid",
            plugin: B,
            serverName: Y,
            validationError: V.error.message,
            source: "plugin"
          })
        }
      } catch (W) {
        let X = W instanceof Error ? `Failed to read/parse LSP config from ${Y} in plugin ${B}: ${W.message}` : `Failed to read/parse LSP config file ${Y} in plugin ${B}`;
        AA(W instanceof Error ? W : Error(X)), G.push({
          type: "lsp-config-invalid",
          plugin: B,
          serverName: Y,
          validationError: W instanceof Error ? `Failed to parse JSON: ${W.message}` : "Failed to parse JSON file",
          source: "plugin"
        })
      }
    } else
      for (let [J, W] of Object.entries(Y)) {
        let X = RIA.safeParse(W);
        if (X.success) Z[J] = X.data;
        else {
          let V = `LSP config validation failed for inline server "${J}" in plugin ${B}: ${X.error.message}`;
          AA(Error(V)), G.push({
            type: "lsp-config-invalid",
            plugin: B,
            serverName: J,
            validationError: X.error.message,
            source: "plugin"
          })
        }
      }
  return Object.keys(Z).length > 0 ? Z : void 0
}
// @from(Start 11587249, End 11587445)
function W_2(A, Q) {
  let B = {};
  for (let [G, Z] of Object.entries(A)) {
    let I = `plugin:${Q}:${G}`;
    B[I] = {
      ...Z,
      scope: "dynamic",
      source: Q
    }
  }
  return B
}
// @from(Start 11587450, End 11587500)
X_2 = L(() => {
  aAA();
  Q2();
  V0();
  g1()
})
// @from(Start 11587502, End 11588219)
async function V_2() {
  let A = {};
  try {
    let {
      enabled: Q
    } = await l7();
    for (let B of Q) {
      let G = [],
        Z = await J_2(B, G);
      if (Z && Object.keys(Z).length > 0) {
        let I = W_2(Z, B.name);
        Object.assign(A, I), g(`Loaded ${Object.keys(Z).length} LSP server(s) from plugin: ${B.name}`)
      }
      if (G.length > 0) g(`${G.length} error(s) loading LSP servers from plugin: ${B.name}`)
    }
    g(`Total LSP servers loaded: ${Object.keys(A).length}`)
  } catch (Q) {
    AA(Q instanceof Error ? Q : Error(`Failed to load LSP servers: ${String(Q)}`)), g(`Error loading LSP servers: ${Q instanceof Error?Q.message:String(Q)}`)
  }
  return {
    servers: A
  }
}
// @from(Start 11588224, End 11588274)
F_2 = L(() => {
  fV();
  X_2();
  V0();
  g1()
})
// @from(Start 11588305, End 11593122)
function K_2() {
  let A = new Map,
    Q = new Map,
    B = new Map;
  async function G() {
    g("[LSP SERVER MANAGER] initialize() called");
    let D;
    try {
      g("[LSP SERVER MANAGER] Calling getAllLspServers()"), D = (await V_2()).servers, g(`[LSP SERVER MANAGER] getAllLspServers returned ${Object.keys(D).length} server(s)`)
    } catch (H) {
      throw AA(Error(`Failed to load LSP server configuration: ${H.message}`)), H
    }
    for (let [H, C] of Object.entries(D)) try {
      if (!C.command) throw Error(`Server ${H} missing required 'command' field`);
      if (!C.extensionToLanguage || Object.keys(C.extensionToLanguage).length === 0) throw Error(`Server ${H} missing required 'extensionToLanguage' field`);
      let E = Object.keys(C.extensionToLanguage);
      for (let q of E) {
        let w = q.toLowerCase();
        if (!Q.has(w)) Q.set(w, []);
        let N = Q.get(w);
        if (N) N.push(H)
      }
      let U = Z_2(H, C);
      A.set(H, U), U.onRequest("workspace/configuration", (q) => {
        return g(`LSP: Received workspace/configuration request from ${H}`), q.items.map(() => null)
      }), U.start().catch((q) => {
        AA(Error(`Failed to start LSP server ${H}: ${q.message}`))
      })
    } catch (E) {
      AA(Error(`Failed to initialize LSP server ${H}: ${E.message}`))
    }
    g(`LSP manager initialized with ${A.size} servers`)
  }
  async function Z() {
    let D = [];
    for (let [H, C] of A.entries())
      if (C.state === "running") try {
        await C.stop()
      } catch (E) {
        let U = E;
        AA(Error(`Failed to stop LSP server ${H}: ${U.message}`)), D.push(U)
      }
    if (A.clear(), Q.clear(), B.clear(), D.length > 0) {
      let H = Error(`Failed to stop ${D.length} LSP server(s): ${D.map((C)=>C.message).join("; ")}`);
      throw AA(H), H
    }
  }

  function I(D) {
    let H = Cn.extname(D).toLowerCase(),
      C = Q.get(H);
    if (!C || C.length === 0) return;
    let E = C[0];
    if (!E) return;
    return A.get(E)
  }
  async function Y(D) {
    let H = I(D);
    if (!H) return;
    if (H.state === "stopped") try {
      await H.start()
    } catch (C) {
      throw AA(Error(`Failed to start LSP server for file ${D}: ${C.message}`)), C
    }
    return H
  }
  async function J(D, H, C) {
    let E = await Y(D);
    if (!E) return;
    try {
      return await E.sendRequest(H, C)
    } catch (U) {
      throw AA(Error(`LSP request failed for file ${D}, method '${H}': ${U.message}`)), U
    }
  }

  function W() {
    return A
  }
  async function X(D, H) {
    let C = await Y(D);
    if (!C) return;
    let E = `file://${Cn.resolve(D)}`;
    if (B.get(E) === C.name) {
      g(`LSP: File already open, skipping didOpen for ${D}`);
      return
    }
    let U = Cn.extname(D).toLowerCase(),
      q = C.config.extensionToLanguage[U] || "plaintext";
    try {
      await C.sendNotification("textDocument/didOpen", {
        textDocument: {
          uri: E,
          languageId: q,
          version: 1,
          text: H
        }
      }), B.set(E, C.name), g(`LSP: Sent didOpen for ${D} (languageId: ${q})`)
    } catch (w) {
      let N = Error(`Failed to sync file open ${D}: ${w.message}`);
      throw AA(N), N
    }
  }
  async function V(D, H) {
    let C = I(D);
    if (!C || C.state !== "running") return X(D, H);
    let E = `file://${Cn.resolve(D)}`;
    if (B.get(E) !== C.name) return X(D, H);
    try {
      await C.sendNotification("textDocument/didChange", {
        textDocument: {
          uri: E,
          version: 1
        },
        contentChanges: [{
          text: H
        }]
      }), g(`LSP: Sent didChange for ${D}`)
    } catch (U) {
      let q = Error(`Failed to sync file change ${D}: ${U.message}`);
      throw AA(q), q
    }
  }
  async function F(D) {
    let H = I(D);
    if (!H || H.state !== "running") return;
    try {
      await H.sendNotification("textDocument/didSave", {
        textDocument: {
          uri: `file://${Cn.resolve(D)}`
        }
      }), g(`LSP: Sent didSave for ${D}`)
    } catch (C) {
      let E = Error(`Failed to sync file save ${D}: ${C.message}`);
      throw AA(E), E
    }
  }
  async function K(D) {
    let H = I(D);
    if (!H || H.state !== "running") return;
    let C = `file://${Cn.resolve(D)}`;
    try {
      await H.sendNotification("textDocument/didClose", {
        textDocument: {
          uri: C
        }
      }), B.delete(C), g(`LSP: Sent didClose for ${D}`)
    } catch (E) {
      let U = Error(`Failed to sync file close ${D}: ${E.message}`);
      throw AA(U), U
    }
  }
  return {
    initialize: G,
    shutdown: Z,
    getServerForFile: I,
    ensureServerStarted: Y,
    sendRequest: J,
    getAllServers: W,
    openFile: X,
    changeFile: V,
    saveFile: F,
    closeFile: K
  }
}
// @from(Start 11593127, End 11593178)
D_2 = L(() => {
  I_2();
  F_2();
  V0();
  g1()
})
// @from(Start 11593227, End 11593435)
function Cu5(A) {
  switch (A) {
    case 1:
      return "Error";
    case 2:
      return "Warning";
    case 3:
      return "Info";
    case 4:
      return "Hint";
    default:
      return "Error"
  }
}
// @from(Start 11593437, End 11594189)
function Eu5(A) {
  let Q;
  try {
    Q = A.uri.startsWith("file://") ? Hu5(A.uri) : A.uri
  } catch (G) {
    let Z = G instanceof Error ? G : Error(String(G));
    AA(Z), g(`Failed to convert URI to file path: ${A.uri}. Error: ${Z.message}. Using original URI as fallback.`), Q = A.uri
  }
  let B = A.diagnostics.map((G) => ({
    message: G.message,
    severity: Cu5(G.severity),
    range: {
      start: {
        line: G.range.start.line,
        character: G.range.start.character
      },
      end: {
        line: G.range.end.line,
        character: G.range.end.character
      }
    },
    source: G.source,
    code: G.code !== void 0 && G.code !== null ? String(G.code) : void 0
  }));
  return [{
    uri: Q,
    diagnostics: B
  }]
}
// @from(Start 11594191, End 11597754)
function H_2(A) {
  let Q = A.getAllServers(),
    B = [],
    G = 0,
    Z = new Map;
  for (let [Y, J] of Q.entries()) try {
    if (!J || typeof J.onNotification !== "function") {
      let W = !J ? "Server instance is null/undefined" : "Server instance has no onNotification method";
      B.push({
        serverName: Y,
        error: W
      });
      let X = Error(`${W} for ${Y}`);
      AA(X), g(`Skipping handler registration for ${Y}: ${W}`);
      continue
    }
    J.onNotification("textDocument/publishDiagnostics", async (W) => {
      g(`[PASSIVE DIAGNOSTICS] Handler invoked for ${Y}! Params type: ${typeof W}`);
      try {
        if (!W || typeof W !== "object" || !("uri" in W) || !("diagnostics" in W)) {
          let K = Error(`LSP server ${Y} sent invalid diagnostic params (missing uri or diagnostics)`);
          AA(K), g(`Invalid diagnostic params from ${Y}: ${JSON.stringify(W)}`);
          return
        }
        let X = W;
        g(`Received diagnostics from ${Y}: ${X.diagnostics.length} diagnostic(s) for ${X.uri}`);
        let V = Eu5(X),
          F = V[0];
        if (!F || V.length === 0 || F.diagnostics.length === 0) {
          g(`Skipping empty diagnostics from ${Y} for ${X.uri}`);
          return
        }
        try {
          wI2({
            serverName: Y,
            files: V
          }), g(`LSP Diagnostics: Registered ${V.length} diagnostic file(s) from ${Y} for async delivery`), Z.delete(Y)
        } catch (K) {
          let D = K instanceof Error ? K : Error(`Failed to register LSP diagnostics: ${String(K)}`);
          AA(D), g(`Error registering LSP diagnostics from ${Y}: URI: ${X.uri}, Diagnostic count: ${F.diagnostics.length}, Error: ${D.message}`);
          let H = Z.get(Y) || {
            count: 0,
            lastError: ""
          };
          if (H.count++, H.lastError = D.message, Z.set(Y, H), H.count >= 3) g(`WARNING: LSP diagnostic handler for ${Y} has failed ${H.count} times consecutively. Last error: ${H.lastError}. This may indicate a problem with the LSP server or diagnostic processing. Check logs for details.`)
        }
      } catch (X) {
        let V = X instanceof Error ? X : Error(`Unexpected error in diagnostic handler: ${String(X)}`);
        AA(V), g(`Unexpected error processing diagnostics from ${Y}: ${V.message}`);
        let F = Z.get(Y) || {
          count: 0,
          lastError: ""
        };
        if (F.count++, F.lastError = V.message, Z.set(Y, F), F.count >= 3) g(`WARNING: LSP diagnostic handler for ${Y} has failed ${F.count} times consecutively. Last error: ${F.lastError}. This may indicate a problem with the LSP server or diagnostic processing. Check logs for details.`)
      }
    }), g(`Registered diagnostics handler for ${Y}`), G++
  } catch (W) {
    let X = W instanceof Error ? W : Error(`Handler registration failed: ${String(W)}`);
    B.push({
      serverName: Y,
      error: X.message
    }), AA(X), g(`Failed to register diagnostics handler for ${Y}: Error: ${X.message}`)
  }
  let I = Q.size;
  if (B.length > 0) {
    let Y = B.map((J) => `${J.serverName} (${J.error})`).join(", ");
    AA(Error(`Failed to register diagnostics for ${B.length} LSP server(s): ${Y}`)), g(`LSP notification handler registration: ${G}/${I} succeeded. Failed servers: ${Y}. Diagnostics from failed servers will not be delivered.`)
  } else g(`LSP notification handlers registered successfully for all ${I} server(s)`);
  return {
    totalServers: I,
    successCount: G,
    registrationErrors: B,
    diagnosticFailures: Z
  }
}
// @from(Start 11597759, End 11597801)
C_2 = L(() => {
  uMA();
  V0();
  g1()
})
// @from(Start 11597804, End 11597866)
function XWA() {
  if (N0A === "failed") return;
  return jP
}
// @from(Start 11597868, End 11598621)
function E_2() {
  if (g("[LSP MANAGER] initializeLspServerManager() called"), jP !== void 0 && N0A !== "failed") {
    g("[LSP MANAGER] Already initialized or initializing, skipping");
    return
  }
  if (N0A === "failed") jP = void 0, E50 = void 0;
  jP = K_2(), N0A = "pending", g("[LSP MANAGER] Created manager instance, state=pending");
  let A = ++F51;
  g(`[LSP MANAGER] Starting async initialization (generation ${A})`), jP.initialize().then(() => {
    if (A === F51) {
      if (N0A = "success", g("LSP server manager initialized successfully"), jP) H_2(jP)
    }
  }).catch((Q) => {
    if (A === F51) N0A = "failed", E50 = Q, jP = void 0, AA(Q), g(`Failed to initialize LSP server manager: ${Q instanceof Error?Q.message:String(Q)}`)
  })
}
// @from(Start 11598622, End 11598944)
async function z_2() {
  if (jP === void 0) return;
  try {
    await jP.shutdown(), g("LSP server manager shut down successfully")
  } catch (A) {
    AA(A), g(`Failed to shutdown LSP server manager: ${A instanceof Error?A.message:String(A)}`)
  } finally {
    jP = void 0, N0A = "not-started", E50 = void 0, F51++
  }
}
// @from(Start 11598949, End 11598951)
jP
// @from(Start 11598953, End 11598972)
N0A = "not-started"
// @from(Start 11598976, End 11598979)
E50
// @from(Start 11598981, End 11598988)
F51 = 0
// @from(Start 11598994, End 11599045)
lRA = L(() => {
  D_2();
  C_2();
  V0();
  g1()
})
// @from(Start 11599051, End 11599054)
U_2
// @from(Start 11599056, End 11599059)
z50
// @from(Start 11599061, End 11599064)
$_2
// @from(Start 11599070, End 11600213)
U50 = L(() => {
  Q2();
  U_2 = j.strictObject({
    file_path: j.string().describe("The absolute path to the file to modify"),
    old_string: j.string().describe("The text to replace"),
    new_string: j.string().describe("The text to replace it with (must be different from old_string)"),
    replace_all: j.boolean().default(!1).optional().describe("Replace all occurences of old_string (default false)")
  }), z50 = j.object({
    oldStart: j.number(),
    oldLines: j.number(),
    newStart: j.number(),
    newLines: j.number(),
    lines: j.array(j.string())
  }), $_2 = j.object({
    filePath: j.string().describe("The file path that was edited"),
    oldString: j.string().describe("The original string that was replaced"),
    newString: j.string().describe("The new string that replaced it"),
    originalFile: j.string().describe("The original file contents before editing"),
    structuredPatch: j.array(z50).describe("Diff patch showing the changes"),
    userModified: j.boolean().describe("Whether the user modified the proposed changes"),
    replaceAll: j.boolean().describe("Whether all occurrences were replaced")
  })
})
// @from(Start 11600215, End 11600724)
async function q_2() {
  if (!await rw()) return null;
  let {
    stdout: Q,
    code: B
  } = await QQ("git", ["diff", "HEAD", "--numstat"], {
    timeout: w_2,
    preserveOutputOnError: !1
  });
  if (B !== 0) return null;
  let G = zu5(Q),
    {
      stdout: Z,
      code: I
    } = await QQ("git", ["diff", "HEAD"], {
      timeout: w_2,
      preserveOutputOnError: !1
    });
  if (I !== 0) return {
    stats: G,
    hunks: new Map
  };
  let Y = Uu5(Z);
  return {
    stats: G,
    hunks: Y
  }
}
// @from(Start 11600726, End 11601126)
function zu5(A) {
  let Q = A.trim().split(`
`).filter(Boolean),
    B = 0,
    G = 0,
    Z = 0;
  for (let I of Q) {
    let Y = I.split("\t");
    if (Y.length < 3) continue;
    Z++;
    let J = Y[0],
      W = Y[1];
    if (J && J !== "-") B += parseInt(J, 10) || 0;
    if (W && W !== "-") G += parseInt(W, 10) || 0
  }
  return {
    filesCount: Z,
    linesAdded: B,
    linesRemoved: G
  }
}
// @from(Start 11601128, End 11602276)
function Uu5(A) {
  let Q = new Map;
  if (!A.trim()) return Q;
  let B = A.split(/^diff --git /m).filter(Boolean);
  for (let G of B) {
    let Z = G.split(`
`),
      I = Z[0]?.match(/^a\/(.+?) b\/(.+)$/);
    if (!I) continue;
    let Y = I[2] ?? I[1] ?? "",
      J = [],
      W = null;
    for (let X = 1; X < Z.length; X++) {
      let V = Z[X] ?? "",
        F = V.match(/^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
      if (F) {
        if (W) J.push(W);
        W = {
          oldStart: parseInt(F[1] ?? "0", 10),
          oldLines: parseInt(F[2] ?? "1", 10),
          newStart: parseInt(F[3] ?? "0", 10),
          newLines: parseInt(F[4] ?? "1", 10),
          lines: []
        };
        continue
      }
      if (V.startsWith("index ") || V.startsWith("---") || V.startsWith("+++") || V.startsWith("new file") || V.startsWith("deleted file") || V.startsWith("old mode") || V.startsWith("new mode") || V.startsWith("Binary files")) continue;
      if (W && (V.startsWith("+") || V.startsWith("-") || V.startsWith(" ") || V === "")) W.lines.push(V)
    }
    if (W) J.push(W);
    if (J.length > 0) Q.set(Y, J)
  }
  return Q
}
// @from(Start 11602281, End 11602291)
w_2 = 5000
// @from(Start 11602297, End 11602330)
N_2 = L(() => {
  _8();
  PV()
})
// @from(Start 11602333, End 11602886)
function L_2() {
  let [A, Q] = OQ(), B = nh.useRef(A.gitDiff.version), G = nh.useCallback(async () => {
    return
  }, [Q]);
  nh.useEffect(() => {
    G()
  }, [G]), CI(() => {
    G()
  }, $u5);
  let Z = qp(() => {
    G()
  }, 500);
  return nh.useEffect(() => {
    if (A.gitDiff.version !== B.current) B.current = A.gitDiff.version, Z()
  }, [A.gitDiff.version, Z]), nh.useMemo(() => {
    if (!A.gitDiff.stats) return null;
    return {
      stats: A.gitDiff.stats,
      hunks: A.gitDiff.hunks
    }
  }, [A.gitDiff.stats, A.gitDiff.hunks])
}
// @from(Start 11602888, End 11603015)
function K51(A) {
  A((Q) => ({
    ...Q,
    gitDiff: {
      ...Q.gitDiff,
      version: Q.gitDiff.version + 1
    }
  }))
}
// @from(Start 11603020, End 11603022)
nh
// @from(Start 11603024, End 11603033)
$u5 = 1e4
// @from(Start 11603039, End 11603101)
D51 = L(() => {
  JE();
  z9();
  N_2();
  nh = BA(VA(), 1)
})
// @from(Start 11603104, End 11603406)
function O_2({
  patch: A,
  dim: Q,
  width: B
}) {
  let [G] = qB(), Z = M_2.useMemo(() => Ou5(A.lines, A.oldStart, B, Q, G), [A.lines, A.oldStart, B, Q, G]);
  return z6.createElement(S, {
    flexDirection: "column",
    flexGrow: 1
  }, Z.map((I, Y) => z6.createElement(S, {
    key: Y
  }, I)))
}
// @from(Start 11603408, End 11603821)
function qu5(A) {
  return A.map((Q) => {
    if (Q.startsWith("+")) return {
      code: " " + Q.slice(1),
      i: 0,
      type: "add",
      originalCode: Q.slice(1)
    };
    if (Q.startsWith("-")) return {
      code: " " + Q.slice(1),
      i: 0,
      type: "remove",
      originalCode: Q.slice(1)
    };
    return {
      code: Q,
      i: 0,
      type: "nochange",
      originalCode: Q
    }
  })
}
// @from(Start 11603823, End 11604706)
function Nu5(A) {
  let Q = [],
    B = 0;
  while (B < A.length) {
    let G = A[B];
    if (!G) {
      B++;
      continue
    }
    if (G.type === "remove") {
      let Z = [G],
        I = B + 1;
      while (I < A.length && A[I]?.type === "remove") {
        let J = A[I];
        if (J) Z.push(J);
        I++
      }
      let Y = [];
      while (I < A.length && A[I]?.type === "add") {
        let J = A[I];
        if (J) Y.push(J);
        I++
      }
      if (Z.length > 0 && Y.length > 0) {
        let J = Math.min(Z.length, Y.length);
        for (let W = 0; W < J; W++) {
          let X = Z[W],
            V = Y[W];
          if (X && V) X.wordDiff = !0, V.wordDiff = !0, X.matchedLine = V, V.matchedLine = X
        }
        Q.push(...Z.filter(Boolean)), Q.push(...Y.filter(Boolean)), B = I
      } else Q.push(G), B++
    } else Q.push(G), B++
  }
  return Q
}
// @from(Start 11604708, End 11604775)
function Lu5(A, Q) {
  return GI2(A, Q, {
    ignoreCase: !1
  })
}
// @from(Start 11604777, End 11606464)
function Mu5(A, Q, B, G, Z) {
  let {
    type: I,
    i: Y,
    wordDiff: J,
    matchedLine: W,
    originalCode: X
  } = A;
  if (!J || !W) return null;
  let V = I === "remove" ? X : W.originalCode,
    F = I === "remove" ? W.originalCode : X,
    K = Lu5(V, F),
    D = V.length + F.length;
  if (K.filter((y) => y.added || y.removed).reduce((y, v) => y + v.value.length, 0) / D > wu5 || G) return null;
  let E = I === "add" ? "+" : "-",
    U = "  ",
    q = E.length + U.length,
    w = Q - B - 1 - q,
    N = [],
    R = [],
    T = 0;
  if (K.forEach((y, v) => {
      let x = !1,
        p;
      if (I === "add") {
        if (y.added) x = !0, p = "diffAddedWord";
        else if (!y.removed) x = !0
      } else if (I === "remove") {
        if (y.removed) x = !0, p = "diffRemovedWord";
        else if (!y.added) x = !0
      }
      if (!x) return;
      ob(y.value, w, "wrap").split(`
`).forEach((l, k) => {
        if (!l) return;
        if (k > 0 || T + l.length > w) {
          if (R.length > 0) N.push([...R]), R = [], T = 0
        }
        R.push(z6.createElement($, {
          key: `part-${v}-${k}`,
          backgroundColor: p,
          color: Z ? "text" : void 0,
          dimColor: G
        }, l)), T += l.length
      })
    }), R.length > 0) N.push(R);
  return N.map((y, v) => {
    let x = `${I}-${Y}-${v}`;
    return z6.createElement($, {
      key: x
    }, z6.createElement(H51, {
      i: v === 0 ? Y : void 0,
      width: B
    }), z6.createElement($, {
      backgroundColor: I === "add" ? G ? "diffAddedDimmed" : "diffAdded" : G ? "diffRemovedDimmed" : "diffRemoved"
    }, z6.createElement($, {
      dimColor: G
    }, E, U), y))
  })
}
// @from(Start 11606466, End 11608194)
function Ou5(A, Q, B, G, Z) {
  let I = qu5(A),
    Y = Nu5(I),
    J = Ru5(Y, Q),
    W = Math.max(...J.map(({
      i: V
    }) => V), 0),
    X = Math.max(W.toString().length + 2, 0);
  return J.flatMap((V) => {
    let {
      type: F,
      code: K,
      i: D,
      wordDiff: H,
      matchedLine: C
    } = V;
    if (H && C) {
      let N = Mu5(V, B, X, G, Z);
      if (N !== null) return N
    }
    let E = 2,
      U = B - X - 1 - E;
    return ob(K, U, "wrap").split(`
`).map((N, R) => {
      let T = `${F}-${D}-${R}`;
      switch (F) {
        case "add":
          return z6.createElement($, {
            key: T
          }, z6.createElement(H51, {
            i: R === 0 ? D : void 0,
            width: X
          }), z6.createElement($, {
            color: Z ? "text" : void 0,
            backgroundColor: G ? "diffAddedDimmed" : "diffAdded",
            dimColor: G
          }, z6.createElement($, {
            dimColor: G
          }, "+ "), N));
        case "remove":
          return z6.createElement($, {
            key: T
          }, z6.createElement(H51, {
            i: R === 0 ? D : void 0,
            width: X
          }), z6.createElement($, {
            color: Z ? "text" : void 0,
            backgroundColor: G ? "diffRemovedDimmed" : "diffRemoved",
            dimColor: G
          }, z6.createElement($, {
            dimColor: G
          }, "- "), N));
        case "nochange":
          return z6.createElement($, {
            key: T
          }, z6.createElement(H51, {
            i: R === 0 ? D : void 0,
            width: X
          }), z6.createElement($, {
            color: Z ? "text" : void 0,
            dimColor: G
          }, "  ", N))
      }
    })
  })
}
// @from(Start 11608196, End 11608386)
function H51({
  i: A,
  width: Q,
  hidden: B
}) {
  if (B) return null;
  return z6.createElement($, {
    dimColor: !0
  }, A !== void 0 ? A.toString().padStart(Q) : " ".repeat(Q), " ")
}
// @from(Start 11608388, End 11609490)
function Ru5(A, Q) {
  let B = Q,
    G = [],
    Z = [...A];
  while (Z.length > 0) {
    let I = Z.shift(),
      {
        code: Y,
        type: J,
        originalCode: W,
        wordDiff: X,
        matchedLine: V
      } = I,
      F = {
        code: Y,
        type: J,
        i: B,
        originalCode: W,
        wordDiff: X,
        matchedLine: V
      };
    switch (J) {
      case "nochange":
        B++, G.push(F);
        break;
      case "add":
        B++, G.push(F);
        break;
      case "remove": {
        G.push(F);
        let K = 0;
        while (Z[0]?.type === "remove") {
          B++;
          let D = Z.shift(),
            {
              code: H,
              type: C,
              originalCode: E,
              wordDiff: U,
              matchedLine: q
            } = D,
            w = {
              code: H,
              type: C,
              i: B,
              originalCode: E,
              wordDiff: U,
              matchedLine: q
            };
          G.push(w), K++
        }
        B -= K;
        break
      }
    }
  }
  return G
}
// @from(Start 11609495, End 11609497)
z6
// @from(Start 11609499, End 11609502)
M_2
// @from(Start 11609504, End 11609513)
wu5 = 0.4
// @from(Start 11609519, End 11609592)
R_2 = L(() => {
  hA();
  vMA();
  z6 = BA(VA(), 1), M_2 = BA(VA(), 1)
})
// @from(Start 11609598, End 11609606)
$50 = {}
// @from(Start 11609671, End 11609674)
C51
// @from(Start 11609676, End 11609679)
Tu5
// @from(Start 11609681, End 11609684)
Pu5
// @from(Start 11609690, End 11609899)
w50 = L(() => {
  try {
    C51 = (() => {
      throw new Error("Cannot require module " + "../../color-diff.node");
    })()
  } catch (A) {
    C51 = null
  }
  Tu5 = C51?.ColorDiff, Pu5 = C51?.ColorDiff
})
// @from(Start 11609901, End 11610393)
async function P_2() {
  if (!T_2) {
    return T_2 = !0, null;
    if (_j(process.env.CLAUDE_CODE_SYNTAX_HIGHLIGHT)) return null;
    if (d0.terminal === "Apple_Terminal") return null;
    if (UX()) try {
      q50 = (await Promise.resolve().then(() => (w50(), $50))).ColorDiff
    } catch (A) {
      g(`[ColorDiff] Rust module unavailable, falling back to JS: ${A instanceof Error?A.message:String(A)}`)
    } else g("[ColorDiff] Not in bundled mode, using JS fallback")
  }
  return q50
}
// @from(Start 11610395, End 11610426)
function j_2() {
  return q50
}
// @from(Start 11610431, End 11610441)
q50 = null
// @from(Start 11610445, End 11610453)
T_2 = !1
// @from(Start 11610459, End 11610500)
N50 = L(() => {
  V0();
  hQ();
  c5()
})
// @from(Start 11610503, End 11611323)
function J$({
  patch: A,
  dim: Q,
  filePath: B,
  width: G,
  skipHighlighting: Z = !1
}) {
  let I = sh.useRef(null),
    [Y, J] = sh.useState(G || ju5),
    [W] = qB(),
    X = sh.useMemo(() => {
      if (Z) return null;
      let F = j_2();
      if (F === null) return null;
      return new F(A, B)
    }, [Z, A, B]);
  sh.useEffect(() => {
    if (!G && I.current) {
      let {
        width: F
      } = xu1(I.current);
      if (F > 0) J(F - 2)
    }
  }, [G]);
  let V = sh.useMemo(() => {
    if (X === null) return null;
    return X.render(W, Y, Q)
  }, [W, Y, Q]);
  return ah.createElement(S, {
    ref: I
  }, V ? ah.createElement(S, {
    flexDirection: "column"
  }, V.map((F, K) => ah.createElement($, {
    key: K
  }, F))) : ah.createElement(O_2, {
    patch: A,
    dim: Q,
    width: Y
  }))
}
// @from(Start 11611328, End 11611330)
ah
// @from(Start 11611332, End 11611334)
sh
// @from(Start 11611336, End 11611344)
ju5 = 80
// @from(Start 11611350, End 11611430)
En = L(() => {
  hA();
  R_2();
  N50();
  ah = BA(VA(), 1), sh = BA(VA(), 1)
})
// @from(Start 11611493, End 11612974)
function E51({
  filePath: A,
  structuredPatch: Q,
  style: B,
  verbose: G
}) {
  let {
    columns: Z
  } = WB(), I = Q.reduce((F, K) => F + K.lines.filter((D) => D.startsWith("+")).length, 0), Y = Q.reduce((F, K) => F + K.lines.filter((D) => D.startsWith("-")).length, 0), J = b9(A), W = _u5(uQ(), "CLAUDE.md"), X = J === W, V = Z6.createElement($, null, "Updated", " ", Z6.createElement($, {
    bold: !0
  }, G ? A : Su5(W0(), A)), I > 0 || Y > 0 ? " with " : "", I > 0 ? Z6.createElement(Z6.Fragment, null, Z6.createElement($, {
    bold: !0
  }, I), " ", I > 1 ? "additions" : "addition") : null, I > 0 && Y > 0 ? " and " : null, Y > 0 ? Z6.createElement(Z6.Fragment, null, Z6.createElement($, {
    bold: !0
  }, Y), " ", Y > 1 ? "removals" : "removal") : null);
  if (B === "condensed" && !G) return V;
  return Z6.createElement(S0, null, Z6.createElement(S, {
    flexDirection: "column"
  }, Z6.createElement($, null, V), dV(Q.map((F) => Z6.createElement(S, {
    flexDirection: "column",
    key: F.newStart
  }, Z6.createElement(J$, {
    patch: F,
    dim: !1,
    width: Z - 12,
    filePath: A
  }))), (F) => Z6.createElement(S, {
    key: `ellipsis-${F}`
  }, Z6.createElement($, {
    dimColor: !0
  }, "..."))), X && Z6.createElement(S, {
    marginTop: 1
  }, Z6.createElement($, null, Z6.createElement($, {
    bold: !0
  }, "Tip:"), " Use", " ", Z6.createElement($, {
    color: "remember"
  }, "# to memorize"), " shortcut to quickly add to CLAUDE.md"))))
}
// @from(Start 11612979, End 11612981)
Z6
// @from(Start 11612987, End 11613080)
L50 = L(() => {
  hA();
  En();
  U2();
  i8();
  _0();
  yI();
  q8();
  Z6 = BA(VA(), 1)
})
// @from(Start 11613083, End 11613745)
function CO({
  code: A,
  language: Q
}) {
  let B = z51.useMemo(() => {
    let G = qYA(A);
    try {
      if (VWA.supportsLanguage(Q)) return VWA.highlight(G, {
        language: Q
      });
      else return g(`Language not supported while highlighting code, falling back to markdown: ${Q}`), VWA.highlight(G, {
        language: "markdown"
      })
    } catch (Z) {
      if (Z instanceof Error && Z.message.includes("Unknown language")) return g(`Language not supported while highlighting code, falling back to markdown: ${Z}`), VWA.highlight(G, {
        language: "markdown"
      })
    }
  }, [A, Q]);
  return z51.default.createElement($, null, B)
}
// @from(Start 11613750, End 11613753)
VWA
// @from(Start 11613755, End 11613758)
z51
// @from(Start 11613764, End 11613846)
FWA = L(() => {
  hA();
  V0();
  R9();
  VWA = BA(p21(), 1), z51 = BA(VA(), 1)
})
// @from(Start 11613983, End 11614080)
function k_2(A) {
  if (A?.file_path?.startsWith(kU())) return "Updated plan";
  return "Write"
}
// @from(Start 11614082, End 11614160)
function y_2(A) {
  if (!A?.file_path) return null;
  return Q5(A.file_path)
}
// @from(Start 11614162, End 11614322)
function x_2(A, {
  verbose: Q
}) {
  if (!A.file_path) return null;
  if (A.file_path.startsWith(kU())) return "";
  return Q ? A.file_path : Q5(A.file_path)
}
// @from(Start 11614324, End 11615735)
function v_2({
  file_path: A,
  content: Q
}, {
  columns: B,
  style: G,
  verbose: Z
}) {
  try {
    let I = RA(),
      Y = xu5(A) ? A : vu5(W0(), A),
      J = I.existsSync(Y),
      W = J ? CH(Y) : "utf-8",
      X = J ? I.readFileSync(Y, {
        encoding: W
      }) : null,
      V = X ? "update" : "create",
      F = Uq({
        filePath: A,
        fileContents: X ?? "",
        edits: [{
          old_string: X ?? "",
          new_string: Q,
          replace_all: !1
        }]
      }),
      K = h9.createElement(S, {
        flexDirection: "row"
      }, h9.createElement($, {
        color: "error"
      }, "User rejected ", V === "update" ? "update" : "write", " to", " "), h9.createElement($, {
        bold: !0,
        color: "error"
      }, Z ? A : __2(W0(), A)));
    if (G === "condensed" && !Z) return K;
    return h9.createElement(S0, null, h9.createElement(S, {
      flexDirection: "column"
    }, K, dV(F.map((D) => h9.createElement(S, {
      flexDirection: "column",
      key: D.newStart
    }, h9.createElement(J$, {
      patch: D,
      dim: !0,
      width: B - 12,
      filePath: A
    }))), (D) => h9.createElement(S, {
      key: `ellipsis-${D}`
    }, h9.createElement($, {
      dimColor: !0
    }, "...")))))
  } catch (I) {
    return AA(I), h9.createElement(S, {
      flexDirection: "column"
    }, h9.createElement($, null, "  ", "⎿ (No changes)"))
  }
}
// @from(Start 11615737, End 11616007)
function b_2(A, {
  verbose: Q
}) {
  if (!Q && typeof A === "string" && B9(A, "tool_use_error")) return h9.createElement(S0, null, h9.createElement($, {
    color: "error"
  }, "Error writing file"));
  return h9.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 11616009, End 11616041)
function f_2() {
  return null
}
// @from(Start 11616043, End 11617321)
function h_2({
  filePath: A,
  content: Q,
  structuredPatch: B,
  type: G
}, Z, {
  style: I,
  verbose: Y
}) {
  if (!Y && A.startsWith(kU())) {
    let J = Q5(A);
    return h9.createElement(S0, null, h9.createElement($, {
      dimColor: !0
    }, "/plan to preview · ", J))
  }
  switch (G) {
    case "create": {
      let J = Q || "(No content)",
        W = Q.split(ku5).length,
        X = W - S_2,
        V = h9.createElement($, null, "Wrote ", h9.createElement($, {
          bold: !0
        }, W), " lines to", " ", h9.createElement($, {
          bold: !0
        }, Y ? A : __2(W0(), A)));
      if (I === "condensed" && !Y) return V;
      return h9.createElement(S0, null, h9.createElement(S, {
        flexDirection: "column"
      }, V, h9.createElement(S, {
        flexDirection: "column"
      }, h9.createElement(CO, {
        code: Y ? J : J.split(`
`).slice(0, S_2).filter((F) => F.trim() !== "").join(`
`),
        language: yu5(A).slice(1)
      }), !Y && X > 0 && h9.createElement($, {
        dimColor: !0
      }, "… +", X, " ", X === 1 ? "line" : "lines", " ", W > 0 && h9.createElement(Tl, null)))))
    }
    case "update":
      return h9.createElement(E51, {
        filePath: A,
        structuredPatch: B,
        verbose: Y
      })
  }
}
// @from(Start 11617326, End 11617328)
h9
// @from(Start 11617330, End 11617338)
S_2 = 10
// @from(Start 11617344, End 11617504)
g_2 = L(() => {
  hA();
  L50();
  FWA();
  En();
  q8();
  yJ();
  AIA();
  R9();
  R9();
  U2();
  Rh();
  AQ();
  g1();
  cQ();
  NE();
  h9 = BA(VA(), 1)
})
// @from(Start 11617565, End 11617576)
u_2 = 16000
// @from(Start 11617580, End 11617823)
hu5 = "<response clipped><NOTE>To save on context only part of this file has been shown to you. You should retry this tool after you have searched inside the file with Grep in order to find the line numbers of what you are looking for.</NOTE>"
// @from(Start 11617827, End 11617830)
gu5
// @from(Start 11617832, End 11617835)
uu5
// @from(Start 11617837, End 11617839)
QV
// @from(Start 11617845, End 11623275)
rh = L(() => {
  Q2();
  q0();
  Q01();
  R9();
  YS();
  Rh();
  EJ();
  yI();
  AQ();
  R1A();
  lRA();
  uMA();
  g1();
  V0();
  U50();
  sU();
  D51();
  g_2();
  gu5 = j.strictObject({
    file_path: j.string().describe("The absolute path to the file to write (must be absolute, not relative)"),
    content: j.string().describe("The content to write to the file")
  }), uu5 = j.object({
    type: j.enum(["create", "update"]).describe("Whether a new file was created or an existing file was updated"),
    filePath: j.string().describe("The path to the file that was written"),
    content: j.string().describe("The content that was written to the file"),
    structuredPatch: j.array(z50).describe("Diff patch showing the changes"),
    originalFile: j.string().nullable().describe("The original file content before the write (null for new files)")
  }), QV = {
    name: wX,
    strict: !0,
    input_examples: [{
      file_path: "/Users/username/project/src/newFile.ts",
      content: `export function hello() {
  console.log("Hello, World!");
}`
    }],
    async description() {
      return "Write a file to the local filesystem."
    },
    userFacingName: k_2,
    getToolUseSummary: y_2,
    async prompt() {
      return qc0
    },
    isEnabled() {
      return !0
    },
    renderToolUseMessage: x_2,
    inputSchema: gu5,
    outputSchema: uu5,
    isConcurrencySafe() {
      return !1
    },
    isReadOnly() {
      return !1
    },
    getPath(A) {
      return A.file_path
    },
    async checkPermissions(A, Q) {
      let B = await Q.getAppState();
      return L0A(QV, A, B.toolPermissionContext)
    },
    renderToolUseRejectedMessage: v_2,
    renderToolUseErrorMessage: b_2,
    renderToolUseProgressMessage: f_2,
    renderToolResultMessage: h_2,
    async validateInput({
      file_path: A
    }, Q) {
      let B = b9(A),
        G = await Q.getAppState();
      if (jD(B, G.toolPermissionContext, "edit", "deny") !== null) return {
        result: !1,
        message: "File is in a directory that is denied by your permission settings.",
        errorCode: 1
      };
      if (!RA().existsSync(B)) return {
        result: !0
      };
      let Y = Q.readFileState.get(B);
      if (!Y) return {
        result: !1,
        message: "File has not been read yet. Read it first before writing to it.",
        errorCode: 2
      };
      if (Y) {
        if (PD(B) > Y.timestamp) return {
          result: !1,
          message: "File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.",
          errorCode: 3
        }
      }
      return {
        result: !0
      }
    },
    async call({
      file_path: A,
      content: Q
    }, {
      readFileState: B,
      updateFileHistoryState: G,
      setAppState: Z
    }, I, Y) {
      let J = b9(A),
        W = bu5(J),
        X = RA();
      await Oh.beforeFileEdited(J);
      let V = X.existsSync(J);
      if (V) {
        let E = PD(J),
          U = B.get(J);
        if (!U || E > U.timestamp) throw Error("File has been unexpectedly modified. Read it again before attempting to write it.")
      }
      let F = V ? CH(J) : "utf-8",
        K = V ? X.readFileSync(J, {
          encoding: F
        }) : null;
      if (EG()) await kYA(G, J, Y.uuid);
      let D = V ? M0A(J) : await m_2();
      X.mkdirSync(W), KWA(J, Q, F, D);
      let H = XWA();
      if (H) H91(`file://${J}`), H.changeFile(J, Q).catch((E) => {
        g(`LSP: Failed to notify server of file change for ${J}: ${E.message}`), AA(E)
      }), H.saveFile(J).catch((E) => {
        g(`LSP: Failed to notify server of file save for ${J}: ${E.message}`), AA(E)
      });
      if (B.set(J, {
          content: Q,
          timestamp: PD(J),
          offset: void 0,
          limit: void 0
        }), K51(Z), J.endsWith(`${fu5}CLAUDE.md`)) GA("tengu_write_claudemd", {});
      if (K) {
        let E = Uq({
            filePath: A,
            fileContents: K,
            edits: [{
              old_string: K,
              new_string: Q,
              replace_all: !1
            }]
          }),
          U = {
            type: "update",
            filePath: A,
            content: Q,
            structuredPatch: E,
            originalFile: K
          };
        return fMA(E), Uk({
          operation: "write",
          tool: "FileWriteTool",
          filePath: J,
          type: "update"
        }), {
          data: U
        }
      }
      let C = {
        type: "create",
        filePath: A,
        content: Q,
        structuredPatch: [],
        originalFile: null
      };
      return fMA([], Q), Uk({
        operation: "write",
        tool: "FileWriteTool",
        filePath: J,
        type: "create"
      }), {
        data: C
      }
    },
    mapToolResultToToolResultBlockParam({
      filePath: A,
      content: Q,
      type: B
    }, G) {
      switch (B) {
        case "create":
          return {
            tool_use_id: G, type: "tool_result", content: `File created successfully at: ${A}`
          };
        case "update":
          return {
            tool_use_id: G, type: "tool_result", content: `The file ${A} has been updated. Here's the result of running \`cat -n\` on a snippet of the edited file:
${Sl({content:Q.split(/\r?\n/).length>u_2?Q.split(/\r?\n/).slice(0,u_2).join(`
`)+hu5:Q,startLine:1})}`
          }
      }
    }
  }
})
// @from(Start 11623281, End 11623284)
d_2
// @from(Start 11812743, End 11814027)
K70 = L(() => {
  cE();
  V0();
  g1();
  cE();
  $9A();
  _b2 = s1(async () => {
    let A = await OWA(),
      {
        limitedCommands: Q
      } = Sb2(A),
      B = Q.map((Z) => Z.userFacingName()).join(", ");
    return g(`Skills and commands included in Skill tool: ${B}`), `Execute a skill within the main conversation

<skills_instructions>
When users ask you to perform tasks, check if any of the available skills below can help complete the task more effectively. Skills provide specialized capabilities and domain knowledge.

How to use skills:
- Invoke skills using this tool with the skill name only (no arguments)
- When you invoke a skill, you will see <command-message>The "{name}" skill is loading</command-message>
- The skill's prompt will expand and provide detailed instructions on how to complete the task
- Examples:
  - \`skill: "pdf"\` - invoke the pdf skill
  - \`skill: "xlsx"\` - invoke the xlsx skill
  - \`skill: "ms-office-suite:pdf"\` - invoke using fully qualified name

Important:
- Only use skills listed in <available_skills> below
- Do not invoke a skill that is already running
- Do not use this tool for built-in CLI commands (like /help, /clear, etc.)
</skills_instructions>

<available_skills>
${Pi5(Q,A.length)}
</available_skills>
`
  })
})
// @from(Start 11814033, End 11814045)
kq = "Skill"
// @from(Start 11814047, End 11814155)
async function WTA(A, Q) {
  let B = await bNA(A, Q);
  if (B !== null) return B;
  return await ReB(A, Q)
}
// @from(Start 11814156, End 11814374)
async function a51(A, Q, B, G) {
  let Z = await Promise.all(A.map((I) => r51(I, {
    getToolPermissionContext: Q,
    tools: A,
    agents: B?.activeAgents ?? [],
    model: G
  })));
  return await WTA([], Z) ?? 0
}
// @from(Start 11814375, End 11814674)
async function ji5(A, Q) {
  let [B, G] = await Promise.all([Tn(A, Q), iD()]), Z = [...B, ...Object.values(G)];
  if (Z.length < 1) return 0;
  return (await Promise.all(Z.filter((Y) => Y.length > 0).map((Y) => WTA([{
    role: "user",
    content: Y
  }], [])))).reduce((Y, J) => Y + (J || 0), 0)
}
// @from(Start 11814675, End 11815211)
async function Si5() {
  let A = gV(),
    Q = [],
    B = 0;
  if (A.length < 1) return {
    memoryFileDetails: [],
    claudeMdTokens: 0
  };
  let G = await Promise.all(A.map(async (Z) => {
    let I = await WTA([{
      role: "user",
      content: Z.content
    }], []);
    return {
      file: Z,
      tokens: I || 0
    }
  }));
  for (let {
      file: Z,
      tokens: I
    }
    of G) B += I, Q.push({
    path: Z.path,
    type: Z.type,
    tokens: I
  });
  return {
    claudeMdTokens: B,
    memoryFileDetails: Q
  }
}
// @from(Start 11815212, End 11815344)
async function _i5(A, Q, B, G) {
  let Z = A.filter((I) => !I.isMcp);
  if (Z.length < 1) return 0;
  return await a51(Z, Q, B, G)
}
// @from(Start 11815346, End 11815403)
function ki5(A) {
  return A.find((Q) => Q.name === kq)
}
// @from(Start 11815404, End 11815767)
async function yi5(A, Q, B) {
  let G = await kb2(),
    Z = ki5(A);
  if (!Z) return {
    slashCommandTokens: 0,
    commandInfo: {
      totalCommands: 0,
      includedCommands: 0
    }
  };
  return {
    slashCommandTokens: await a51([Z], Q, B),
    commandInfo: {
      totalCommands: G.totalCommands,
      includedCommands: G.includedCommands
    }
  }
}
// @from(Start 11815768, End 11816150)
async function XTA(A, Q, B, G) {
  let Z = A.filter((W) => W.isMcp),
    I = [],
    Y = await Promise.all(Z.map((W) => a51([W], Q, B, G))),
    J = Y.reduce((W, X) => W + (X || 0), 0);
  for (let [W, X] of Z.entries()) I.push({
    name: X.name,
    serverName: X.name.split("__")[1] || "unknown",
    tokens: Y[W]
  });
  return {
    mcpToolTokens: J,
    mcpToolDetails: I
  }
}
// @from(Start 11816151, End 11816273)
async function yb2(A, Q, B) {
  let G = A.filter((Z) => !Z.isMcp);
  if (G.length === 0) return 0;
  return a51(G, Q, B)
}
// @from(Start 11816274, End 11816746)
async function xi5(A) {
  let Q = A.activeAgents.filter((I) => I.source !== "built-in"),
    B = [],
    G = 0,
    Z = await Promise.all(Q.map((I) => WTA([{
      role: "user",
      content: [I.agentType, I.whenToUse].join(" ")
    }], [])));
  for (let [I, Y] of Q.entries()) {
    let J = Z[I] || 0;
    G += J || 0, B.push({
      agentType: Y.agentType,
      source: Y.source,
      tokens: J || 0
    })
  }
  return {
    agentTokens: G,
    agentDetails: B
  }
}
// @from(Start 11816747, End 11817304)
async function vi5(A) {
  let Q = await Si(A),
    B = {
      totalTokens: 0,
      toolCallTokens: 0,
      toolResultTokens: 0,
      attachmentTokens: 0,
      assistantMessageTokens: 0,
      userMessageTokens: 0,
      toolCallsByType: new Map,
      toolResultsByType: new Map,
      attachmentsByType: new Map
    },
    G = await WTA(WZ(Q.messages).map((Z) => {
      if (Z.type === "assistant") return {
        role: "assistant",
        content: Z.message.content
      };
      return Z.message
    }), []);
  return B.totalTokens = G ?? 0, B
}
// @from(Start 11817305, End 11820841)
async function xb2(A, Q, B, G, Z, I) {
  let Y = Pt({
      permissionMode: (await B()).mode,
      mainLoopModel: Q
    }),
    J = su(Y),
    [W, {
      claudeMdTokens: X,
      memoryFileDetails: V
    }, F, {
      mcpToolTokens: K,
      mcpToolDetails: D
    }, {
      agentTokens: H,
      agentDetails: C
    }, {
      slashCommandTokens: E,
      commandInfo: U
    }, q] = await Promise.all([ji5(G, Y), Si5(), _i5(G, B, Z, Y), XTA(G, B, Z, Y), xi5(Z), yi5(G, B, Z), vi5(A)]),
    w = 0,
    N = {
      totalSkills: 0,
      includedSkills: 0
    },
    R = q.totalTokens,
    T = b1A(),
    y = T ? TYA() - zQ0 : void 0,
    v = [];
  if (W > 0) v.push({
    name: "System prompt",
    tokens: W,
    color: "promptBorder"
  });
  if (F > 0) v.push({
    name: "System tools",
    tokens: F,
    color: "inactive"
  });
  if (K > 0) v.push({
    name: "MCP tools",
    tokens: K,
    color: "cyan_FOR_SUBAGENTS_ONLY"
  });
  if (H > 0) v.push({
    name: "Custom agents",
    tokens: H,
    color: "permission"
  });
  if (X > 0) v.push({
    name: "Memory files",
    tokens: X,
    color: "claude"
  });
  if (R !== null && R > 0) v.push({
    name: "Messages",
    tokens: R,
    color: "purple_FOR_SUBAGENTS_ONLY"
  });
  if (T && y) {
    let yA = J - y;
    v.push({
      name: D70,
      tokens: yA,
      color: "inactive"
    })
  }
  let x = v.reduce((yA, oA) => yA + oA.tokens, 0),
    p = Math.max(0, J - x);
  v.push({
    name: "Free space",
    tokens: p,
    color: "promptBorder"
  });
  let u = x,
    e = I && I < 80,
    l = J >= 1e6 ? e ? 5 : 20 : e ? 5 : 10,
    k = J >= 1e6 ? 10 : e ? 5 : 10,
    m = l * k,
    o = v.map((yA) => ({
      ...yA,
      squares: yA.name === "Free space" ? Math.round(yA.tokens / J * m) : Math.max(1, Math.round(yA.tokens / J * m)),
      percentageOfTotal: Math.round(yA.tokens / J * 100)
    }));

  function IA(yA) {
    let oA = [],
      X1 = yA.tokens / J * m,
      WA = Math.floor(X1),
      EA = X1 - WA;
    for (let MA = 0; MA < yA.squares; MA++) {
      let DA = 1;
      if (MA === WA && EA > 0) DA = EA;
      oA.push({
        color: yA.color,
        isFilled: !0,
        categoryName: yA.name,
        tokens: yA.tokens,
        percentage: yA.percentageOfTotal,
        squareFullness: DA
      })
    }
    return oA
  }
  let FA = [],
    zA = o.find((yA) => yA.name === D70),
    NA = o.filter((yA) => yA.name !== D70 && yA.name !== "Free space");
  for (let yA of NA) {
    let oA = IA(yA);
    for (let X1 of oA)
      if (FA.length < m) FA.push(X1)
  }
  let OA = zA ? zA.squares : 0,
    mA = v.find((yA) => yA.name === "Free space"),
    wA = m - OA;
  while (FA.length < wA) FA.push({
    color: "promptBorder",
    isFilled: !0,
    categoryName: "Free space",
    tokens: mA?.tokens || 0,
    percentage: mA ? Math.round(mA.tokens / J * 100) : 0,
    squareFullness: 1
  });
  if (zA) {
    let yA = IA(zA);
    for (let oA of yA)
      if (FA.length < m) FA.push(oA)
  }
  let qA = [];
  for (let yA = 0; yA < k; yA++) qA.push(FA.slice(yA * l, (yA + 1) * l));
  let KA;
  return {
    categories: v,
    totalTokens: u,
    maxTokens: J,
    rawMaxTokens: J,
    percentage: Math.round(u / J * 100),
    gridRows: qA,
    model: Y,
    memoryFiles: V,
    mcpTools: D,
    agents: C,
    slashCommands: E > 0 ? {
      totalCommands: U.totalCommands,
      includedCommands: U.includedCommands,
      tokens: E
    } : void 0,
    skills: void 0,
    autoCompactThreshold: y,
    isAutoCompactEnabled: T,
    messageBreakdown: KA
  }
}
// @from(Start 11820846, End 11820872)
D70 = "Autocompact buffer"
// @from(Start 11820878, End 11820986)
s51 = L(() => {
  Ty();
  xM();
  Pn();
  gE();
  y1A();
  cQ();
  th();
  t2();
  K70();
  v1A();
  g1()
})
// @from(Start 11820989, End 11821918)
function H70({
  count: A,
  countLabel: Q,
  secondaryCount: B,
  secondaryLabel: G,
  content: Z,
  verbose: I
}) {
  let Y = gJ.default.createElement(gJ.default.Fragment, null, "Found ", gJ.default.createElement($, {
      bold: !0
    }, A, " "), A === 0 || A > 1 ? Q : Q.slice(0, -1)),
    J = B !== void 0 && G ? gJ.default.createElement(gJ.default.Fragment, null, " ", "across ", gJ.default.createElement($, {
      bold: !0
    }, B, " "), B === 0 || B > 1 ? G : G.slice(0, -1)) : null;
  if (I) return gJ.default.createElement(S, {
    flexDirection: "column"
  }, gJ.default.createElement(S, {
    flexDirection: "row"
  }, gJ.default.createElement($, null, "  ⎿  ", Y, J)), gJ.default.createElement(S, {
    marginLeft: 5
  }, gJ.default.createElement($, null, Z)));
  return gJ.default.createElement(S0, {
    height: 1
  }, gJ.default.createElement($, null, Y, J, " ", A > 0 && gJ.default.createElement(Tl, null)))
}
// @from(Start 11821920, End 11822359)
function vb2({
  pattern: A,
  path: Q,
  glob: B,
  type: G,
  output_mode: Z = "files_with_matches",
  head_limit: I
}, {
  verbose: Y
}) {
  if (!A) return null;
  let J = [`pattern: "${A}"`];
  if (Q) J.push(`path: "${Y?Q:Q5(Q)}"`);
  if (B) J.push(`glob: "${B}"`);
  if (G) J.push(`type: "${G}"`);
  if (Z !== "files_with_matches") J.push(`output_mode: "${Z}"`);
  if (I !== void 0) J.push(`head_limit: ${I}`);
  return J.join(", ")
}
// @from(Start 11822361, End 11822423)
function bb2() {
  return gJ.default.createElement(k5, null)
}
// @from(Start 11822425, End 11822722)
function fb2(A, {
  verbose: Q
}) {
  if (!Q && typeof A === "string" && B9(A, "tool_use_error")) return gJ.default.createElement(S0, null, gJ.default.createElement($, {
    color: "error"
  }, "Error searching files"));
  return gJ.default.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 11822724, End 11822756)
function hb2() {
  return null
}
// @from(Start 11822758, End 11823401)
function gb2({
  mode: A = "files_with_matches",
  filenames: Q,
  numFiles: B,
  content: G,
  numLines: Z,
  numMatches: I
}, Y, {
  verbose: J
}) {
  if (A === "content") return gJ.default.createElement(H70, {
    count: Z ?? 0,
    countLabel: "lines",
    content: G,
    verbose: J
  });
  if (A === "count") return gJ.default.createElement(H70, {
    count: I ?? 0,
    countLabel: "matches",
    secondaryCount: B,
    secondaryLabel: "files",
    content: G,
    verbose: J
  });
  let W = Q.map((X) => X).join(`
`);
  return gJ.default.createElement(H70, {
    count: B,
    countLabel: "files",
    content: W,
    verbose: J
  })
}
// @from(Start 11823403, End 11823481)
function ub2(A) {
  if (!A?.pattern) return null;
  return J7(A.pattern, $k)
}
// @from(Start 11823486, End 11823488)
gJ
// @from(Start 11823494, End 11823588)
mb2 = L(() => {
  hA();
  iX();
  yJ();
  q8();
  AIA();
  R9();
  cQ();
  gJ = BA(VA(), 1)
})
// @from(Start 11823633, End 11823800)
function E70(A) {
  if (A.length <= C70) return A;
  let Q = A.slice(0, C70),
    G = A.slice(C70).split(`
`).length;
  return `${Q}

... [${G} lines truncated] ...`
}
// @from(Start 11823802, End 11823897)
function z70(A, Q, B = 0) {
  if (Q === void 0) return A.slice(B);
  return A.slice(B, B + Q)
}
// @from(Start 11823899, End 11823989)
function U70(A) {
  let Q = W0(),
    B = bi5(Q, A);
  return B.startsWith("..") ? A : B
}
// @from(Start 11823991, End 11824080)
function $70(A, Q) {
  if (!A && !Q) return "";
  return `limit: ${A}, offset: ${Q??0}`
}
// @from(Start 11824085, End 11824088)
fi5
// @from(Start 11824090, End 11824101)
C70 = 20000
// @from(Start 11824105, End 11824108)
hi5
// @from(Start 11824110, End 11824113)
gi5
// @from(Start 11824115, End 11824117)
Py
// @from(Start 11824123, End 11833344)
VTA = L(() => {
  Q2();
  U2();
  yI();
  sj();
  yR();
  u2();
  EJ();
  AQ();
  mb2();
  fi5 = j.strictObject({
    pattern: j.string().describe("The regular expression pattern to search for in file contents"),
    path: j.string().optional().describe("File or directory to search in (rg PATH). Defaults to current working directory."),
    glob: j.string().optional().describe('Glob pattern to filter files (e.g. "*.js", "*.{ts,tsx}") - maps to rg --glob'),
    output_mode: j.enum(["content", "files_with_matches", "count"]).optional().describe('Output mode: "content" shows matching lines (supports -A/-B/-C context, -n line numbers, head_limit), "files_with_matches" shows file paths (supports head_limit), "count" shows match counts (supports head_limit). Defaults to "files_with_matches".'),
    "-B": j.number().optional().describe('Number of lines to show before each match (rg -B). Requires output_mode: "content", ignored otherwise.'),
    "-A": j.number().optional().describe('Number of lines to show after each match (rg -A). Requires output_mode: "content", ignored otherwise.'),
    "-C": j.number().optional().describe('Number of lines to show before and after each match (rg -C). Requires output_mode: "content", ignored otherwise.'),
    "-n": j.boolean().optional().describe('Show line numbers in output (rg -n). Requires output_mode: "content", ignored otherwise. Defaults to true.'),
    "-i": j.boolean().optional().describe("Case insensitive search (rg -i)"),
    type: j.string().optional().describe("File type to search (rg --type). Common types: js, py, rust, go, java, etc. More efficient than include for standard file types."),
    head_limit: j.number().optional().describe('Limit output to first N lines/entries, equivalent to "| head -N". Works across all output modes: content (limits output lines), files_with_matches (limits file paths), count (limits count entries). Defaults based on "cap" experiment value: 0 (unlimited), 20, or 100.'),
    offset: j.number().optional().describe('Skip first N lines/entries before applying head_limit, equivalent to "| tail -n +N | head -N". Works across all output modes. Defaults to 0.'),
    multiline: j.boolean().optional().describe("Enable multiline mode where . matches newlines and patterns can span lines (rg -U --multiline-dotall). Default: false.")
  }), hi5 = [".git", ".svn", ".hg", ".bzr"];
  gi5 = j.object({
    mode: j.enum(["content", "files_with_matches", "count"]).optional(),
    numFiles: j.number(),
    filenames: j.array(j.string()),
    content: j.string().optional(),
    numLines: j.number().optional(),
    numMatches: j.number().optional(),
    appliedLimit: j.number().optional(),
    appliedOffset: j.number().optional()
  }), Py = {
    name: xY,
    strict: !0,
    input_examples: [{
      pattern: "TODO",
      output_mode: "files_with_matches"
    }, {
      pattern: "function.*export",
      glob: "*.ts",
      output_mode: "content",
      "-n": !0
    }, {
      pattern: "error",
      "-i": !0,
      type: "js"
    }],
    async description() {
      return CC1()
    },
    userFacingName() {
      return "Search"
    },
    getToolUseSummary: ub2,
    isEnabled() {
      return !0
    },
    inputSchema: fi5,
    outputSchema: gi5,
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    getPath({
      path: A
    }) {
      return A || W0()
    },
    async validateInput({
      path: A
    }) {
      if (A) {
        let Q = RA(),
          B = b9(A);
        if (!Q.existsSync(B)) return {
          result: !1,
          message: `Path does not exist: ${A}`,
          errorCode: 1
        }
      }
      return {
        result: !0
      }
    },
    async checkPermissions(A, Q) {
      let B = await Q.getAppState();
      return jl(Py, A, B.toolPermissionContext)
    },
    async prompt() {
      return CC1()
    },
    renderToolUseMessage: vb2,
    renderToolUseRejectedMessage: bb2,
    renderToolUseErrorMessage: fb2,
    renderToolUseProgressMessage: hb2,
    renderToolResultMessage: gb2,
    mapToolResultToToolResultBlockParam({
      mode: A = "files_with_matches",
      numFiles: Q,
      filenames: B,
      content: G,
      numLines: Z,
      numMatches: I,
      appliedLimit: Y,
      appliedOffset: J
    }, W) {
      if (A === "content") {
        let K = $70(Y, J),
          D = E70(G || "No matches found"),
          H = K ? `${D}

[Showing results with pagination = ${K}]` : D;
        return {
          tool_use_id: W,
          type: "tool_result",
          content: H
        }
      }
      if (A === "count") {
        let K = $70(Y, J),
          H = E70(G || "No matches found"),
          C = I ?? 0,
          E = Q ?? 0,
          U = `

Found ${C} total ${C===1?"occurrence":"occurrences"} across ${E} ${E===1?"file":"files"}.${K?` with pagination = ${K}`:""}`;
        return {
          tool_use_id: W,
          type: "tool_result",
          content: H + U
        }
      }
      let X = $70(Y, J);
      if (Q === 0) return {
        tool_use_id: W,
        type: "tool_result",
        content: "No files found"
      };
      let V = `Found ${Q} file${Q===1?"":"s"}${X?` ${X}`:""}
${B.join(`
`)}`,
        F = E70(V);
      return {
        tool_use_id: W,
        type: "tool_result",
        content: F
      }
    },
    async call({
      pattern: A,
      path: Q,
      glob: B,
      type: G,
      output_mode: Z = "files_with_matches",
      "-B": I,
      "-A": Y,
      "-C": J,
      "-n": W = !0,
      "-i": X = !1,
      head_limit: V,
      offset: F = 0,
      multiline: K = !1
    }, {
      abortController: D,
      getAppState: H
    }) {
      let {
        cap: C
      } = await Ch1("tengu_cap_grep_results", {
        cap: 0
      }), E = V !== void 0 ? V : C > 0 ? C : void 0, U = Q ? b9(Q) : W0(), q = ["--hidden"];
      for (let u of hi5) q.push("--glob", `!${u}`);
      if (q.push("--max-columns", "500"), K) q.push("-U", "--multiline-dotall");
      if (X) q.push("-i");
      if (Z === "files_with_matches") q.push("-l");
      else if (Z === "count") q.push("-c");
      if (W && Z === "content") q.push("-n");
      if (J !== void 0 && Z === "content") q.push("-C", J.toString());
      else if (Z === "content") {
        if (I !== void 0) q.push("-B", I.toString());
        if (Y !== void 0) q.push("-A", Y.toString())
      }
      if (A.startsWith("-")) q.push("-e", A);
      else q.push(A);
      if (G) q.push("--type", G);
      if (B) {
        let u = [],
          e = B.split(/\s+/);
        for (let l of e)
          if (l.includes("{") && l.includes("}")) u.push(l);
          else u.push(...l.split(",").filter(Boolean));
        for (let l of u.filter(Boolean)) q.push("--glob", l)
      }
      let w = await H(),
        N = RWA(TWA(w.toolPermissionContext), W0());
      for (let u of N) {
        let e = u.startsWith("/") ? `!${u}` : `!**/${u}`;
        q.push("--glob", e)
      }
      let R = await aj(q, U, D.signal);
      if (Z === "content") {
        let u = R.map((k) => {
            let m = k.indexOf(":");
            if (m > 0) {
              let o = k.substring(0, m),
                IA = k.substring(m);
              return U70(o) + IA
            }
            return k
          }),
          e = z70(u, E, F);
        return {
          data: {
            mode: "content",
            numFiles: 0,
            filenames: [],
            content: e.join(`
`),
            numLines: e.length,
            ...E !== void 0 && {
              appliedLimit: E
            },
            ...F > 0 && {
              appliedOffset: F
            }
          }
        }
      }
      if (Z === "count") {
        let u = R.map((o) => {
            let IA = o.lastIndexOf(":");
            if (IA > 0) {
              let FA = o.substring(0, IA),
                zA = o.substring(IA);
              return U70(FA) + zA
            }
            return o
          }),
          e = z70(u, E, F),
          l = 0,
          k = 0;
        for (let o of e) {
          let IA = o.lastIndexOf(":");
          if (IA > 0) {
            let FA = o.substring(IA + 1),
              zA = parseInt(FA, 10);
            if (!isNaN(zA)) l += zA, k += 1
          }
        }
        return {
          data: {
            mode: "count",
            numFiles: k,
            filenames: [],
            content: e.join(`
`),
            numMatches: l,
            ...E !== void 0 && {
              appliedLimit: E
            },
            ...F > 0 && {
              appliedOffset: F
            }
          }
        }
      }
      let T = await Promise.all(R.map((u) => RA().stat(u))),
        y = R.map((u, e) => [u, T[e]]).sort((u, e) => {
          let l = (e[1].mtimeMs ?? 0) - (u[1].mtimeMs ?? 0);
          if (l === 0) return u[0].localeCompare(e[0]);
          return l
        }).map((u) => u[0]),
        x = z70(y, E, F).map(U70);
      return {
        data: {
          mode: "files_with_matches",
          filenames: x,
          numFiles: x.length,
          ...E !== void 0 && {
            appliedLimit: E
          },
          ...F > 0 && {
            appliedOffset: F
          }
        }
      }
    }
  }
})
// @from(Start 11833347, End 11833383)
function db2() {
  return "Search"
}
// @from(Start 11833385, End 11833556)
function cb2({
  pattern: A,
  path: Q
}, {
  verbose: B
}) {
  if (!A) return null;
  if (!Q) return `pattern: "${A}"`;
  return `pattern: "${A}", path: "${B?Q:Q5(Q)}"`
}
// @from(Start 11833558, End 11833621)
function pb2() {
  return FTA.default.createElement(k5, null)
}
// @from(Start 11833623, End 11833923)
function lb2(A, {
  verbose: Q
}) {
  if (!Q && typeof A === "string" && B9(A, "tool_use_error")) return FTA.default.createElement(S0, null, FTA.default.createElement($, {
    color: "error"
  }, "Error searching files"));
  return FTA.default.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 11833925, End 11833957)
function ib2() {
  return null
}
// @from(Start 11833959, End 11834037)
function ab2(A) {
  if (!A?.pattern) return null;
  return J7(A.pattern, $k)
}
// @from(Start 11834042, End 11834045)
FTA
// @from(Start 11834047, End 11834050)
nb2
// @from(Start 11834056, End 11834187)
sb2 = L(() => {
  hA();
  iX();
  yJ();
  q8();
  cQ();
  R9();
  VTA();
  FTA = BA(VA(), 1);
  nb2 = Py.renderToolResultMessage
})
// @from(Start 11834193, End 11834196)
ui5
// @from(Start 11834198, End 11834201)
mi5
// @from(Start 11834203, End 11834205)
zO
// @from(Start 11834211, End 11837172)
KTA = L(() => {
  Q2();
  U2();
  R9();
  EJ();
  yI();
  AQ();
  sb2();
  ui5 = j.strictObject({
    pattern: j.string().describe("The glob pattern to match files against"),
    path: j.string().optional().describe('The directory to search in. If not specified, the current working directory will be used. IMPORTANT: Omit this field to use the default directory. DO NOT enter "undefined" or "null" - simply omit it for the default behavior. Must be a valid directory path if provided.')
  }), mi5 = j.object({
    durationMs: j.number().describe("Time taken to execute the search in milliseconds"),
    numFiles: j.number().describe("Total number of files found"),
    filenames: j.array(j.string()).describe("Array of file paths that match the pattern"),
    truncated: j.boolean().describe("Whether results were truncated (limited to 100 files)")
  }), zO = {
    name: iK,
    async description() {
      return HC1
    },
    userFacingName: db2,
    getToolUseSummary: ab2,
    isEnabled() {
      return !0
    },
    inputSchema: ui5,
    outputSchema: mi5,
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    getPath({
      path: A
    }) {
      return A ? b9(A) : W0()
    },
    async validateInput({
      path: A
    }) {
      if (A) {
        let Q = RA(),
          B = b9(A);
        if (!Q.existsSync(B)) return {
          result: !1,
          message: `Directory does not exist: ${A}`,
          errorCode: 1
        };
        if (!Q.statSync(B).isDirectory()) return {
          result: !1,
          message: `Path is not a directory: ${A}`,
          errorCode: 2
        }
      }
      return {
        result: !0
      }
    },
    async checkPermissions(A, Q) {
      let B = await Q.getAppState();
      return jl(zO, A, B.toolPermissionContext)
    },
    async prompt() {
      return HC1
    },
    renderToolUseMessage: cb2,
    renderToolUseRejectedMessage: pb2,
    renderToolUseErrorMessage: lb2,
    renderToolUseProgressMessage: ib2,
    renderToolResultMessage: nb2,
    async call(A, {
      abortController: Q,
      getAppState: B
    }) {
      let G = Date.now(),
        Z = await B(),
        {
          files: I,
          truncated: Y
        } = await rb2(A.pattern, zO.getPath(A), {
          limit: 100,
          offset: 0
        }, Q.signal, Z.toolPermissionContext);
      return {
        data: {
          filenames: I,
          durationMs: Date.now() - G,
          numFiles: I.length,
          truncated: Y
        }
      }
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      if (A.filenames.length === 0) return {
        tool_use_id: Q,
        type: "tool_result",
        content: "No files found"
      };
      return {
        tool_use_id: Q,
        type: "tool_result",
        content: [...A.filenames, ...A.truncated ? ["(Results are truncated. Consider using a more specific path or pattern.)"] : []].join(`
`)
      }
    }
  }
})
// @from(Start 11837174, End 11841558)
async function ob2(A) {
  let Q = A.map((B) => {
    let G = "";
    if (B?.forkContext) G = "Properties: " + (B?.forkContext ? "access to current context; " : "");
    let Z = B.tools ? B.tools.join(", ") : "All tools";
    return `- ${B.agentType}: ${B.whenToUse} (${G}Tools: ${Z})`
  }).join(`
`);
  return `Launch a new agent to handle complex, multi-step tasks autonomously. 

The ${A6} tool launches specialized agents (subprocesses) that autonomously handle complex tasks. Each agent type has specific capabilities and tools available to it.

Available agent types and the tools they have access to:
${Q}

When using the ${A6} tool, you must specify a subagent_type parameter to select which agent type to use.

When NOT to use the ${A6} tool:
- If you want to read a specific file path, use the ${n8.name} or ${zO.name} tool instead of the ${A6} tool, to find the match more quickly
- If you are searching for a specific class definition like "class Foo", use the ${zO.name} tool instead, to find the match more quickly
- If you are searching for code within a specific file or set of 2-3 files, use the ${n8.name} tool instead of the ${A6} tool, to find the match more quickly
- Other tasks that are not related to the agent descriptions above


Usage notes:
- Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple tool uses
- When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, you should send a text message back to the user with a concise summary of the result.
- Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should return back to you in its final and only message to you.
- Agents with "access to current context" can see the full conversation history before the tool call. When using these agents, you can write concise prompts that reference earlier context (e.g., "investigate the error discussed above") instead of repeating information. The agent will receive all prior messages and understand the context.
- The agent's outputs should generally be trusted
- Clearly tell the agent whether you expect it to write code or just to do research (search, file reads, web fetches, etc.), since it is not aware of the user's intent
- If the agent description mentions that it should be used proactively, then you should try your best to use it without the user having to ask for it first. Use your judgement.
- If the user specifies that they want you to run agents "in parallel", you MUST send a single message with multiple ${jn.name} tool use content blocks. For example, if you need to launch both a code-reviewer agent and a test-runner agent in parallel, send a single message with both tool calls.

Example usage:

<example_agent_descriptions>
"code-reviewer": use this agent after you are done writing a signficant piece of code
"greeting-responder": use this agent when to respond to user greetings with a friendly joke
</example_agent_description>

<example>
user: "Please write a function that checks if a number is prime"
assistant: Sure let me write a function that checks if a number is prime
assistant: First let me use the ${QV.name} tool to write a function that checks if a number is prime
assistant: I'm going to use the ${QV.name} tool to write the following code:
<code>
function isPrime(n) {
  if (n <= 1) return false
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) return false
  }
  return true
}
</code>
<commentary>
Since a signficant piece of code was written and the task was completed, now use the code-reviewer agent to review the code
</commentary>
assistant: Now let me use the code-reviewer agent to review the code
assistant: Uses the ${jn.name} tool to launch the code-reviewer agent 
</example>

<example>
user: "Hello"
<commentary>
Since the user is greeting, use the greeting-responder agent to respond with a friendly joke
</commentary>
assistant: "I'm going to use the ${jn.name} tool to launch the greeting-responder agent"
</example>
`
}
// @from(Start 11841563, End 11841614)
tb2 = L(() => {
  Dq();
  rh();
  KTA();
  DTA()
})
// @from(Start 11841617, End 11841751)
function PWA(A) {
  if (A === "general-purpose") return;
  let B = kX1().get(A);
  if (B && j0A.includes(B)) return HTA[B];
  return
}
// @from(Start 11841753, End 11841871)
function jWA(A, Q) {
  let B = kX1();
  if (!Q) {
    B.delete(A);
    return
  }
  if (j0A.includes(Q)) B.set(A, Q)
}
// @from(Start 11841876, End 11841879)
j0A
// @from(Start 11841881, End 11841884)
HTA
// @from(Start 11841890, End 11842314)
jy = L(() => {
  _0();
  j0A = ["red", "blue", "green", "yellow", "purple", "orange", "pink", "cyan"], HTA = {
    red: "red_FOR_SUBAGENTS_ONLY",
    blue: "blue_FOR_SUBAGENTS_ONLY",
    green: "green_FOR_SUBAGENTS_ONLY",
    yellow: "yellow_FOR_SUBAGENTS_ONLY",
    purple: "purple_FOR_SUBAGENTS_ONLY",
    orange: "orange_FOR_SUBAGENTS_ONLY",
    pink: "pink_FOR_SUBAGENTS_ONLY",
    cyan: "cyan_FOR_SUBAGENTS_ONLY"
  }
})
// @from(Start 11842364, End 11842456)
function nE(A) {
  if (typeof A !== "string") return null;
  return ci5.test(A) ? A : null
}
// @from(Start 11842458, End 11842508)
function SWA() {
  return di5(4).toString("hex")
}
// @from(Start 11842513, End 11842516)
ci5
// @from(Start 11842522, End 11842613)
Sy = L(() => {
  ci5 = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
})
// @from(Start 11842662, End 11842999)
function w70({
  tools: A,
  isBuiltIn: Q,
  isAsync: B = !1
}) {
  return A.filter((G) => {
    if (process.env.CLAUDE_CODE_ALLOW_MCP_TOOLS_FOR_SUBAGENTS && G.name.startsWith("mcp__")) return !0;
    if (CTA.has(G.name)) return !1;
    if (!Q && Qf2.has(G.name)) return !1;
    if (B && !Bf2.has(G.name)) return !1;
    return !0
  })
}
// @from(Start 11843001, End 11843905)
function Sn(A, Q, B = !1) {
  let {
    tools: G,
    disallowedTools: Z,
    source: I
  } = A, Y = w70({
    tools: Q,
    isBuiltIn: I === "built-in",
    isAsync: B
  }), J = new Set(Z?.map((C) => {
    let {
      toolName: E
    } = nN(C);
    return E
  }) ?? []), W = Y.filter((C) => !J.has(C.name));
  if (G === void 0 || G.length === 1 && G[0] === "*") return {
    hasWildcard: !0,
    validTools: [],
    invalidTools: [],
    resolvedTools: W
  };
  let V = new Map;
  for (let C of W) V.set(C.name, C);
  let F = [],
    K = [],
    D = [],
    H = new Set;
  for (let C of G) {
    let {
      toolName: E
    } = nN(C);
    if (E === A6) {
      F.push(C);
      continue
    }
    let U = V.get(E);
    if (U) {
      if (F.push(C), !H.has(U)) D.push(U), H.add(U)
    } else K.push(C)
  }
  return {
    hasWildcard: !1,
    validTools: F,
    invalidTools: K,
    resolvedTools: D
  }
}
// @from(Start 11843907, End 11845237)
function Af2(A, Q) {
  let B = R0({
      content: A
    }),
    G = Q.message.content.find((W) => {
      if (W.type !== "tool_use" || W.name !== A6) return !1;
      let X = W.input;
      return "prompt" in X && X.prompt === A
    });
  if (!G) return g(`Could not find matching AgentTool tool use for prompt: ${A.slice(0,50)}...`, {
    level: "error"
  }), [B];
  let Z = {
      ...Q,
      uuid: pi5(),
      message: {
        ...Q.message,
        content: [G]
      }
    },
    I = `### FORKING CONVERSATION CONTEXT ###
### ENTERING SUB-AGENT ROUTINE ###
Entered sub-agent context

PLEASE NOTE: 
- The messages above this point are from the main thread prior to sub-agent execution. They are provided as context only.
- Context messages may include tool_use blocks for tools that are not available in the sub-agent context. You should only use the tools specifically provided to you in the system prompt.
- Only complete the specific sub-agent task you have been assigned below.`,
    Y = {
      status: "sub_agent_entered",
      description: "Entered sub-agent context",
      message: I
    },
    J = R0({
      content: [{
        type: "tool_result",
        tool_use_id: G.id,
        content: [{
          type: "text",
          text: I
        }]
      }],
      toolUseResult: Y
    });
  return [Z, J, B]
}
// @from(Start 11845242, End 11845245)
eb2
// @from(Start 11845251, End 11845430)
S0A = L(() => {
  AZ();
  yq();
  cQ();
  V0();
  Q2();
  eb2 = j.object({
    status: j.literal("sub_agent_entered"),
    description: j.string(),
    message: j.string()
  })
})
// @from(Start 11845436, End 11845439)
o51
// @from(Start 11845445, End 11847289)
q70 = L(() => {
  o51 = {
    agentType: "general-purpose",
    whenToUse: "General-purpose agent for researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries use this agent to perform the search for you.",
    tools: ["*"],
    source: "built-in",
    baseDir: "built-in",
    model: "sonnet",
    getSystemPrompt: () => `You are an agent for Claude Code, Anthropic's official CLI for Claude. Given the user's message, you should use the tools available to complete the task. Do what has been asked; nothing more, nothing less. When you complete the task simply respond with a detailed writeup.

Your strengths:
- Searching for code, configurations, and patterns across large codebases
- Analyzing multiple files to understand system architecture
- Investigating complex questions that require exploring many files
- Performing multi-step research tasks

Guidelines:
- For file searches: Use Grep or Glob when you need to search broadly. Use Read when you know the specific file path.
- For analysis: Start broad and narrow down. Use multiple search strategies if the first doesn't yield results.
- Be thorough: Check multiple locations, consider different naming conventions, look for related files.
- NEVER create files unless they're absolutely necessary for achieving your goal. ALWAYS prefer editing an existing file to creating a new one.
- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested.
- In your final response always share relevant file names and code snippets. Any file paths you return in your response MUST be absolute. Do NOT use relative paths.
- For clear communication, avoid using emojis.`
  }
})
// @from(Start 11847295, End 11847298)
Gf2
// @from(Start 11847304, End 11850839)
Zf2 = L(() => {
  Gf2 = {
    agentType: "statusline-setup",
    whenToUse: "Use this agent to configure the user's Claude Code status line setting.",
    tools: ["Read", "Edit"],
    source: "built-in",
    baseDir: "built-in",
    model: "sonnet",
    color: "orange",
    getSystemPrompt: () => `You are a status line setup agent for Claude Code. Your job is to create or update the statusLine command in the user's Claude Code settings.

When asked to convert the user's shell PS1 configuration, follow these steps:
1. Read the user's shell configuration files in this order of preference:
   - ~/.zshrc
   - ~/.bashrc  
   - ~/.bash_profile
   - ~/.profile

2. Extract the PS1 value using this regex pattern: /(?:^|\\n)\\s*(?:export\\s+)?PS1\\s*=\\s*["']([^"']+)["']/m

3. Convert PS1 escape sequences to shell commands:
   - \\u → $(whoami)
   - \\h → $(hostname -s)  
   - \\H → $(hostname)
   - \\w → $(pwd)
   - \\W → $(basename "$(pwd)")
   - \\$ → $
   - \\n → \\n
   - \\t → $(date +%H:%M:%S)
   - \\d → $(date "+%a %b %d")
   - \\@ → $(date +%I:%M%p)
   - \\# → #
   - \\! → !

4. When using ANSI color codes, be sure to use \`printf\`. Do not remove colors. Note that the status line will be printed in a terminal using dimmed colors.

5. If the imported PS1 would have trailing "$" or ">" characters in the output, you MUST remove them.

6. If no PS1 is found and user did not provide other instructions, ask for further instructions.

How to use the statusLine command:
1. The statusLine command will receive the following JSON input via stdin:
   {
     "session_id": "string", // Unique session ID
     "transcript_path": "string", // Path to the conversation transcript
     "cwd": "string",         // Current working directory
     "model": {
       "id": "string",           // Model ID (e.g., "claude-3-5-sonnet-20241022")
       "display_name": "string"  // Display name (e.g., "Claude 3.5 Sonnet")
     },
     "workspace": {
       "current_dir": "string",  // Current working directory path
       "project_dir": "string"   // Project root directory path
     },
     "version": "string",        // Claude Code app version (e.g., "1.0.71")
     "output_style": {
       "name": "string",         // Output style name (e.g., "default", "Explanatory", "Learning")
     }
   }
   
   You can use this JSON data in your command like:
   - $(cat | jq -r '.model.display_name')
   - $(cat | jq -r '.workspace.current_dir')
   - $(cat | jq -r '.output_style.name')
   
   Or store it in a variable first:
   - input=$(cat); echo "$(echo "$input" | jq -r '.model.display_name') in $(echo "$input" | jq -r '.workspace.current_dir')"

2. For longer commands, you can save a new file in the user's ~/.claude directory, e.g.:
   - ~/.claude/statusline-command.sh and reference that file in the settings.

3. Update the user's ~/.claude/settings.json with:
   {
     "statusLine": {
       "type": "command", 
       "command": "your_command_here"
     }
   }

4. If ~/.claude/settings.json is a symlink, update the target file instead.

Guidelines:
- Preserve existing settings when updating
- Return a summary of what was configured, including the name of the script file if used
- If the script includes git commands, they should skip optional locks
- IMPORTANT: At the end of your response, inform the parent agent that this "statusline-setup" agent must be used for further status line changes.
  Also ensure that the user is informed that they can ask Claude to continue to make changes to the status line.
`
  }
})
// @from(Start 11850845, End 11850848)
li5
// @from(Start 11850850, End 11850852)
xq
// @from(Start 11850858, End 11853778)
_WA = L(() => {
  wF();
  YS();
  yR();
  li5 = `You are a file search specialist for Claude Code, Anthropic's official CLI for Claude. You excel at thoroughly navigating and exploring codebases.

=== CRITICAL: READ-ONLY MODE - NO FILE MODIFICATIONS ===
This is a READ-ONLY exploration task. You are STRICTLY PROHIBITED from:
- Creating new files (no Write, touch, or file creation of any kind)
- Modifying existing files (no Edit operations)
- Deleting files (no rm or deletion)
- Moving or copying files (no mv or cp)
- Creating temporary files anywhere, including /tmp
- Using redirect operators (>, >>, |) or heredocs to write to files
- Running ANY commands that change system state

Your role is EXCLUSIVELY to search and analyze existing code. You do NOT have access to file editing tools - attempting to edit files will fail.

Your strengths:
- Rapidly finding files using glob patterns
- Searching code and text with powerful regex patterns
- Reading and analyzing file contents

Guidelines:
- Use ${iK} for broad file pattern matching
- Use ${xY} for searching file contents with regex
- Use ${d5} when you know the specific file path you need to read
- Use ${C9} ONLY for read-only operations (ls, git status, git log, git diff, find, cat, head, tail)
- NEVER use ${C9} for: mkdir, touch, rm, cp, mv, git add, git commit, npm install, pip install, or any file creation/modification
- Adapt your search approach based on the thoroughness level specified by the caller
- Return file paths as absolute paths in your final response
- For clear communication, avoid using emojis
- Communicate your final report directly as a regular message - do NOT attempt to create files

NOTE: You are meant to be a fast agent that returns output as quickly as possible. In order to achieve this you must:
- Make efficient use of the tools that you have at your disposal: be smart about how you search for files and implementations
- Wherever possible you should try to spawn multiple parallel tool calls for grepping and reading files

Complete the user's search request efficiently and report your findings clearly.`, xq = {
    agentType: "Explore",
    whenToUse: 'Fast agent specialized for exploring codebases. Use this when you need to quickly find files by patterns (eg. "src/components/**/*.tsx"), search code for keywords (eg. "API endpoints"), or answer questions about the codebase (eg. "how do API endpoints work?"). When calling this agent, specify the desired thoroughness level: "quick" for basic searches, "medium" for moderate exploration, or "very thorough" for comprehensive analysis across multiple locations and naming conventions.',
    disallowedTools: [A6, P51, $5, wX, JS],
    source: "built-in",
    baseDir: "built-in",
    model: "haiku",
    getSystemPrompt: () => li5,
    criticalSystemReminder_EXPERIMENTAL: "CRITICAL: This is a READ-ONLY task. You CANNOT edit, write, or create files."
  }
})
// @from(Start 11853784, End 11853787)
ii5
// @from(Start 11853789, End 11853792)
kWA
// @from(Start 11853798, End 11856849)
t51 = L(() => {
  _WA();
  yR();
  wF();
  YS();
  ii5 = `You are a software architect and planning specialist for Claude Code. Your role is to explore the codebase and design implementation plans.

=== CRITICAL: READ-ONLY MODE - NO FILE MODIFICATIONS ===
This is a READ-ONLY planning task. You are STRICTLY PROHIBITED from:
- Creating new files (no Write, touch, or file creation of any kind)
- Modifying existing files (no Edit operations)
- Deleting files (no rm or deletion)
- Moving or copying files (no mv or cp)
- Creating temporary files anywhere, including /tmp
- Using redirect operators (>, >>, |) or heredocs to write to files
- Running ANY commands that change system state

Your role is EXCLUSIVELY to explore the codebase and design implementation plans. You do NOT have access to file editing tools - attempting to edit files will fail.

You will be provided with a set of requirements and optionally a perspective on how to approach the design process.

## Your Process

1. **Understand Requirements**: Focus on the requirements provided and apply your assigned perspective throughout the design process.

2. **Explore Thoroughly**:
   - Read any files provided to you in the initial prompt
   - Find existing patterns and conventions using ${iK}, ${xY}, and ${d5}
   - Understand the current architecture
   - Identify similar features as reference
   - Trace through relevant code paths
   - Use ${C9} ONLY for read-only operations (ls, git status, git log, git diff, find, cat, head, tail)
   - NEVER use ${C9} for: mkdir, touch, rm, cp, mv, git add, git commit, npm install, pip install, or any file creation/modification

3. **Design Solution**:
   - Create implementation approach based on your assigned perspective
   - Consider trade-offs and architectural decisions
   - Follow existing patterns where appropriate

4. **Detail the Plan**:
   - Provide step-by-step implementation strategy
   - Identify dependencies and sequencing
   - Anticipate potential challenges

## Required Output

End your response with:

### Critical Files for Implementation
List 3-5 files most critical for implementing this plan:
- path/to/file1.ts - [Brief reason: e.g., "Core logic to modify"]
- path/to/file2.ts - [Brief reason: e.g., "Interfaces to implement"]
- path/to/file3.ts - [Brief reason: e.g., "Pattern to follow"]

REMEMBER: You can ONLY explore and plan. You CANNOT and MUST NOT write, edit, or modify any files. You do NOT have access to file editing tools.`, kWA = {
    agentType: "Plan",
    whenToUse: "Software architect agent for designing implementation plans. Use this when you need to plan the implementation strategy for a task. Returns step-by-step plans, identifies critical files, and considers architectural trade-offs.",
    disallowedTools: [A6, P51, $5, wX, JS],
    source: "built-in",
    tools: xq.tools,
    baseDir: "built-in",
    model: "inherit",
    getSystemPrompt: () => ii5,
    criticalSystemReminder_EXPERIMENTAL: "CRITICAL: This is a READ-ONLY task. You CANNOT edit, write, or create files."
  }
})
// @from(Start 11856855, End 11856869)
If2 = () => {}
// @from(Start 11856872, End 11857149)
function N70() {
  let A = [o51, Gf2, xq, kWA];
  if (Y0(process.env.ENABLE_CODE_GUIDE_SUBAGENT) || process.env.CLAUDE_CODE_ENTRYPOINT !== "sdk-ts" && process.env.CLAUDE_CODE_ENTRYPOINT !== "sdk-py" && process.env.CLAUDE_CODE_ENTRYPOINT !== "sdk-cli") A.push(iCB);
  return A
}
// @from(Start 11857154, End 11857233)
Yf2 = L(() => {
  q70();
  Zf2();
  _WA();
  t51();
  Nh1();
  If2();
  hQ()
})
// @from(Start 11857293, End 11857793)
function Jf2(A, Q, B) {
  let G = [],
    Z = RA();

  function I(Y, J = []) {
    try {
      let W = Z.readdirSync(Y);
      for (let X of W) {
        let V = ni5(Y, X.name);
        if (X.isDirectory()) I(V, [...J, X.name]);
        else if (X.isFile() && X.name.endsWith(".md")) {
          let F = Wf2(V, Q, J, B);
          if (F) G.push(F)
        }
      }
    } catch (W) {
      g(`Failed to scan agents directory ${Y}: ${W}`, {
        level: "error"
      })
    }
  }
  return I(A), G
}
// @from(Start 11857795, End 11858648)
function Wf2(A, Q, B, G) {
  let Z = RA();
  try {
    let I = Z.readFileSync(A, {
        encoding: "utf-8"
      }),
      {
        frontmatter: Y,
        content: J
      } = NV(I),
      W = Y.name || ai5(A).replace(/\.md$/, ""),
      V = [Q, ...B, W].join(":"),
      F = Y.description || Y["when-to-use"] || `Agent from ${Q} plugin`,
      K = k0A(Y.tools),
      D = UO(Y.skills),
      H = Y.color,
      C = Y.model,
      E = Y.forkContext,
      U = J.trim();
    return {
      agentType: V,
      whenToUse: F,
      tools: K,
      ...D !== void 0 ? {
        skills: D
      } : {},
      getSystemPrompt: () => U,
      source: "plugin",
      color: H,
      model: C,
      filename: W,
      plugin: G,
      ...{}
    }
  } catch (I) {
    return g(`Failed to load agent from ${A}: ${I}`, {
      level: "error"
    }), null
  }
}
// @from(Start 11858650, End 11858691)
function Xf2() {
  _0A.cache?.clear?.()
}
// @from(Start 11858696, End 11858699)
_0A
// @from(Start 11858705, End 11860037)
ETA = L(() => {
  l2();
  AQ();
  fV();
  V0();
  _y();
  _0A = s1(async () => {
    let {
      enabled: A,
      errors: Q
    } = await l7(), B = [];
    if (Q.length > 0) g(`Plugin loading errors: ${Q.map((G)=>oM(G)).join(", ")}`);
    for (let G of A) {
      if (G.agentsPath) try {
        let Z = Jf2(G.agentsPath, G.name, G.source);
        if (B.push(...Z), Z.length > 0) g(`Loaded ${Z.length} agents from plugin ${G.name} default directory`)
      } catch (Z) {
        g(`Failed to load agents from plugin ${G.name} default directory: ${Z}`, {
          level: "error"
        })
      }
      if (G.agentsPaths)
        for (let Z of G.agentsPaths) try {
          let Y = RA().statSync(Z);
          if (Y.isDirectory()) {
            let J = Jf2(Z, G.name, G.source);
            if (B.push(...J), J.length > 0) g(`Loaded ${J.length} agents from plugin ${G.name} custom path: ${Z}`)
          } else if (Y.isFile() && Z.endsWith(".md")) {
            let J = Wf2(Z, G.name, [], G.source);
            if (J) B.push(J), g(`Loaded agent from plugin ${G.name} custom file: ${Z}`)
          }
        } catch (I) {
          g(`Failed to load agents from plugin ${G.name} custom path ${Z}: ${I}`, {
            level: "error"
          })
        }
    }
    return g(`Total plugin agents loaded: ${B.length}`), B
  })
})
// @from(Start 11860082, End 11860133)
function $O(A) {
  return A.source === "built-in"
}
// @from(Start 11860135, End 11860212)
function Ff2(A) {
  return A.source !== "built-in" && A.source !== "plugin"
}
// @from(Start 11860214, End 11860264)
function e51(A) {
  return A.source === "plugin"
}
// @from(Start 11860266, End 11860745)
function ky(A) {
  let Q = A.filter((X) => X.source === "built-in"),
    B = A.filter((X) => X.source === "plugin"),
    G = A.filter((X) => X.source === "userSettings"),
    Z = A.filter((X) => X.source === "projectSettings"),
    I = A.filter((X) => X.source === "policySettings"),
    Y = A.filter((X) => X.source === "flagSettings"),
    J = [Q, B, G, Z, Y, I],
    W = new Map;
  for (let X of J)
    for (let V of X) W.set(V.agentType, V);
  return Array.from(W.values())
}
// @from(Start 11860747, End 11861168)
function oi5(A) {
  let {
    name: Q,
    description: B,
    model: G
  } = A;
  if (!Q || typeof Q !== "string") return 'Missing required "name" field in frontmatter';
  if (!B || typeof B !== "string") return 'Missing required "description" field in frontmatter';
  if (G && typeof G === "string" && !J7A.includes(G)) return `Invalid model "${G}". Valid options: ${J7A.join(", ")}`;
  return "Unknown parsing error"
}
// @from(Start 11861170, End 11861938)
function ti5(A, Q, B = "flagSettings") {
  try {
    let G = Vf2.parse(Q),
      Z = k0A(G.tools),
      I = G.disallowedTools !== void 0 ? k0A(G.disallowedTools) : void 0,
      Y = G.prompt;
    return {
      agentType: A,
      whenToUse: G.description,
      ...Z !== void 0 ? {
        tools: Z
      } : {},
      ...I !== void 0 ? {
        disallowedTools: I
      } : {},
      getSystemPrompt: () => Y,
      source: B,
      ...G.model ? {
        model: G.model
      } : {},
      ...G.permissionMode ? {
        permissionMode: G.permissionMode
      } : {}
    }
  } catch (G) {
    let Z = G instanceof Error ? G.message : String(G);
    return g(`Error parsing agent '${A}' from JSON: ${Z}`), AA(G instanceof Error ? G : Error(String(G))), null
  }
}
// @from(Start 11861940, End 11862278)
function A31(A, Q = "flagSettings") {
  try {
    let B = ri5.parse(A);
    return Object.entries(B).map(([G, Z]) => ti5(G, Z, Q)).filter((G) => G !== null)
  } catch (B) {
    let G = B instanceof Error ? B.message : String(B);
    return g(`Error parsing agents from JSON: ${G}`), AA(B instanceof Error ? B : Error(String(B))), []
  }
}
// @from(Start 11862280, End 11864487)
function ei5(A, Q, B, G, Z) {
  try {
    let {
      name: I,
      description: Y
    } = B;
    if (!I || typeof I !== "string" || !Y || typeof Y !== "string") {
      let T = `Agent file ${A} is missing required '${!I||typeof I!=="string"?"name":"description"}' in frontmatter`;
      return g(T), null
    }
    Y = Y.replace(/\\n/g, `
`);
    let {
      color: J,
      model: W,
      forkContext: X
    } = B;
    if (X !== void 0 && X !== "true" && X !== "false") {
      let R = `Agent file ${A} has invalid forkContext value '${X}'. Must be 'true', 'false', or omitted.`;
      g(R)
    }
    let V = X === "true";
    if (V && W !== "inherit") {
      let R = `Agent file ${A} has forkContext: true but model is not 'inherit'. Overriding to 'inherit'. Agents with forkContext must use model: inherit to avoid context length mismatch.`;
      g(R), W = "inherit"
    }
    let F = W && typeof W === "string" && J7A.includes(W);
    if (W && typeof W === "string" && !F) {
      let R = `Agent file ${A} has invalid model '${W}'. Valid options: ${J7A.join(", ")}`;
      g(R)
    }
    let K = B.permissionMode,
      D = K && kR.includes(K);
    if (K && !D) {
      let R = `Agent file ${A} has invalid permissionMode '${K}'. Valid options: ${kR.join(", ")}`;
      g(R)
    }
    let H = si5(A, ".md"),
      C = k0A(B.tools),
      E = B.disallowedTools,
      U = E !== void 0 ? k0A(E) : void 0,
      q = UO(B.skills),
      w = G.trim();
    return {
      baseDir: Q,
      agentType: I,
      whenToUse: Y,
      ...C !== void 0 ? {
        tools: C
      } : {},
      ...U !== void 0 ? {
        disallowedTools: U
      } : {},
      ...q !== void 0 ? {
        skills: q
      } : {},
      getSystemPrompt: () => w,
      source: Z,
      filename: H,
      ...J && typeof J === "string" && j0A.includes(J) ? {
        color: J
      } : {},
      ...F ? {
        model: W
      } : {},
      ...D ? {
        permissionMode: K
      } : {},
      ...V ? {
        forkContext: V
      } : {}
    }
  } catch (I) {
    let Y = I instanceof Error ? I.message : String(I);
    return g(`Error parsing agent from ${A}: ${Y}`), AA(I instanceof Error ? I : Error(String(I))), null
  }
}
// @from(Start 11864492, End 11864495)
Vf2
// @from(Start 11864497, End 11864500)
ri5
// @from(Start 11864502, End 11864505)
Kf2
// @from(Start 11864511, End 11866224)
fP = L(() => {
  l2();
  Q2();
  q0();
  V0();
  g1();
  _y();
  t2();
  jy();
  Yf2();
  ETA();
  Zw();
  Vf2 = j.object({
    description: j.string().min(1, "Description cannot be empty"),
    tools: j.array(j.string()).optional(),
    disallowedTools: j.array(j.string()).optional(),
    prompt: j.string().min(1, "Prompt cannot be empty"),
    model: j.enum(J7A).optional(),
    permissionMode: j.enum(kR).optional()
  }), ri5 = j.record(j.string(), Vf2);
  Kf2 = s1(async () => {
    try {
      let A = await _n("agents"),
        Q = [],
        B = A.map(({
          filePath: J,
          baseDir: W,
          frontmatter: X,
          content: V,
          source: F
        }) => {
          let K = ei5(J, W, X, V, F);
          if (!K) {
            let D = oi5(X);
            return Q.push({
              path: J,
              error: D
            }), g(`Failed to parse agent from ${J}: ${D}`), GA("tengu_agent_parse_error", {
              error: D,
              location: F
            }), null
          }
          return K
        }).filter((J) => J !== null),
        G = await _0A(),
        I = [...N70(), ...G, ...B],
        Y = ky(I);
      for (let J of Y)
        if (J.color) jWA(J.agentType, J.color);
      return {
        activeAgents: Y,
        allAgents: I,
        failedFiles: Q.length > 0 ? Q : void 0
      }
    } catch (A) {
      let Q = A instanceof Error ? A.message : String(A);
      g(`Error loading agent definitions: ${Q}`), AA(A instanceof Error ? A : Error(String(A)));
      let B = N70();
      return {
        activeAgents: B,
        allAgents: B,
        failedFiles: [{
          path: "unknown",
          error: Q
        }]
      }
    }
  })
})
// @from(Start 11866227, End 11867017)
function Df2({
  onDone: A
}) {
  return f1((Q, B) => {
    if (B.ctrl && (Q === "c" || Q === "d") || B.escape) A()
  }), kn.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    padding: 1,
    borderDimColor: !0
  }, kn.default.createElement(S, {
    marginBottom: 1,
    flexDirection: "column"
  }, kn.default.createElement($, {
    bold: !0
  }, "You've spent $5 on the Anthropic API this session."), kn.default.createElement($, null, "Learn more about how to monitor your spending:"), kn.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/costs"
  })), kn.default.createElement(S, null, kn.default.createElement(M0, {
    options: [{
      value: "ok",
      label: "Got it, thanks!"
    }],
    onChange: A,
    onCancel: A
  })))
}
// @from(Start 11867022, End 11867024)
kn
// @from(Start 11867030, End 11867091)
Hf2 = L(() => {
  hA();
  J5();
  hA();
  kn = BA(VA(), 1)
})
// @from(Start 11867094, End 11867177)
function Ef2(A, Q = !1) {
  Cf2.useEffect(() => {
    if (!Q) y0A(A)
  }, [A, Q])
}
// @from(Start 11867182, End 11867185)
Cf2
// @from(Start 11867191, End 11867237)
zf2 = L(() => {
  S7();
  Cf2 = BA(VA(), 1)
})
// @from(Start 11867315, End 11874170)
function $f2({
  messages: A,
  onPreRestore: Q,
  onRestoreMessage: B,
  onRestoreCode: G,
  onClose: Z
}) {
  let [I] = OQ(), [Y, J] = X$.useState(void 0), W = EG(), X = X$.useMemo(An5, []), V = X$.useMemo(() => [...A.filter(yn), {
    ...R0({
      content: ""
    }),
    uuid: X
  }], [A, X]), [F, K] = X$.useState(V.length - 1), D = Math.max(0, Math.min(F - Math.floor(L70 / 2), V.length - L70)), H = V.length > 1, [C, E] = X$.useState(void 0), [U, q] = X$.useState(void 0), [w, N] = X$.useState(!1), [R, T] = X$.useState("both");
  X$.useEffect(() => {
    GA("tengu_message_selector_opened", {})
  }, []);
  async function y(k) {
    let m = A.indexOf(k),
      o = A.length - 1 - m;
    if (GA("tengu_message_selector_selected", {
        index_from_end: o,
        message_type: k.type,
        is_current_prompt: !1
      }), !A.includes(k)) {
      Z();
      return
    }
    if (W) {
      E(k);
      let IA = TQ0(I.fileHistory, k.uuid);
      q(IA)
    } else {
      Q(), N(!0);
      try {
        await B(k), N(!1), Z()
      } catch (IA) {
        AA(IA), N(!1), J(`Failed to restore the conversation:
${IA}`)
      }
    }
  }
  async function v(k) {
    if (GA("tengu_message_selector_restore_option_selected", {
        option: k
      }), !C) {
      J("Message not found.");
      return
    }
    if (k === "nevermind") {
      E(void 0);
      return
    }
    Q(), N(!0), J(void 0);
    let m = null,
      o = null;
    if (k === "code" || k === "both") try {
      await G(C)
    } catch (IA) {
      m = IA, AA(m)
    }
    if (k === "conversation" || k === "both") try {
      await B(C)
    } catch (IA) {
      o = IA, AA(o)
    }
    if (N(!1), E(void 0), o && m) J(`Failed to restore the conversation and code:
${o}
${m}`);
    else if (o) J(`Failed to restore the conversation:
${o}`);
    else if (m) J(`Failed to restore the code:
${m}`);
    else Z()
  }
  let x = EQ();

  function p() {
    GA("tengu_message_selector_cancelled", {}), Z()
  }
  f1((k, m) => {
    if (m.escape) {
      p();
      return
    }
    if (w || Y || C || !H) return;
    if (m.return) {
      y(V[F]);
      return
    }
    if (m.upArrow)
      if (m.ctrl || m.shift || m.meta) K(0);
      else K((o) => Math.max(0, o - 1));
    if (m.downArrow)
      if (m.ctrl || m.shift || m.meta) K(V.length - 1);
      else K((o) => Math.min(V.length - 1, o + 1))
  });
  let [u, e] = X$.useState({});
  X$.useEffect(() => {
    async function k() {
      if (!W) return;
      Promise.all(V.map(async (m, o) => {
        if (m.uuid !== X) {
          let IA = c91(I.fileHistory, m.uuid),
            FA = V.at(o + 1),
            zA = IA ? Zn5(A, m.uuid, FA?.uuid !== X ? FA?.uuid : void 0) : void 0;
          if (zA !== void 0) e((NA) => ({
            ...NA,
            [o]: zA
          }));
          else e((NA) => ({
            ...NA,
            [o]: void 0
          }))
        }
      }))
    }
    k()
  }, [V, A, X, I.fileHistory, W, e]);
  let l = W && U?.filesChanged && U.filesChanged.length > 0;
  return $0.createElement(S, {
    flexDirection: "column",
    width: "100%"
  }, $0.createElement(D3, {
    dividerColor: "suggestion"
  }), $0.createElement(S, {
    flexDirection: "column",
    marginX: 1,
    gap: 1
  }, $0.createElement($, {
    bold: !0,
    color: "suggestion"
  }, "Rewind"), Y && $0.createElement($0.Fragment, null, $0.createElement($, {
    color: "error"
  }, "Error: ", Y)), !H && $0.createElement($0.Fragment, null, $0.createElement($, null, "Nothing to rewind to yet.")), !Y && C && H && $0.createElement($0.Fragment, null, $0.createElement($, null, "Confirm you want to restore", " ", !U && "the conversation ", "to the point before you sent this message:"), $0.createElement(S, {
    flexDirection: "column",
    paddingLeft: 1,
    borderStyle: "single",
    borderRight: !1,
    borderTop: !1,
    borderBottom: !1,
    borderLeft: !0,
    borderLeftDimColor: !0
  }, $0.createElement(Uf2, {
    userMessage: C,
    color: "text",
    isCurrent: !1
  }), $0.createElement($, {
    dimColor: !0
  }, "(", Yt(new Date(C.timestamp)), ")")), $0.createElement(S, {
    flexDirection: "column"
  }, R === "both" || R === "conversation" ? $0.createElement($, {
    dimColor: !0
  }, "The conversation will be forked.") : $0.createElement($, {
    dimColor: !0
  }, "The conversation will be unchanged."), l && (R === "both" || R === "code") ? $0.createElement(Gn5, {
    diffStatsForRestore: U
  }) : $0.createElement($, {
    dimColor: !0
  }, "The code will be unchanged.")), $0.createElement(M0, {
    isDisabled: w,
    options: l ? Qn5 : Bn5,
    focusValue: l ? "both" : "conversation",
    onFocus: (k) => T(k),
    onChange: (k) => v(k),
    onCancel: () => E(void 0)
  }), l && $0.createElement(S, {
    marginBottom: 1
  }, $0.createElement($, {
    dimColor: !0
  }, H1.warning, " Rewinding does not affect files edited manually or via bash."))), !Y && !C && H && $0.createElement($0.Fragment, null, W ? $0.createElement($, null, "Restore the code and/or conversation to the point before…") : $0.createElement($, null, "Restore and fork the conversation to the point before…"), $0.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, V.slice(D, D + L70).map((k, m) => {
    let o = D + m,
      IA = o === F,
      FA = k.uuid === X,
      zA = o in u,
      NA = u[o],
      OA = NA?.filesChanged && NA.filesChanged.length;
    return $0.createElement(S, {
      key: k.uuid,
      height: W ? 3 : 2,
      overflow: "hidden",
      width: "100%",
      flexDirection: "row"
    }, $0.createElement(S, {
      width: 2,
      minWidth: 2
    }, IA ? $0.createElement($, {
      color: "permission",
      bold: !0
    }, H1.pointer, " ") : $0.createElement($, null, "  ")), $0.createElement(S, {
      flexDirection: "column"
    }, $0.createElement(S, {
      flexShrink: 1,
      height: 1,
      overflow: "hidden"
    }, $0.createElement(Uf2, {
      userMessage: k,
      color: IA ? "suggestion" : void 0,
      isCurrent: FA,
      paddingRight: 10
    })), W && zA && $0.createElement(S, {
      height: 1,
      flexDirection: "row"
    }, NA ? $0.createElement($0.Fragment, null, $0.createElement($, {
      dimColor: !IA,
      color: "inactive"
    }, OA ? $0.createElement($0.Fragment, null, OA === 1 && NA.filesChanged[0] ? `${yWA.basename(NA.filesChanged[0])} ` : `${OA} files changed `, $0.createElement(wf2, {
      diffStats: NA
    })) : $0.createElement($0.Fragment, null, "No code changes"))) : $0.createElement($, {
      dimColor: !0,
      color: "warning"
    }, H1.warning, " No code restore"))))
  }))), $0.createElement($, {
    dimColor: !0,
    italic: !0
  }, x.pending ? $0.createElement($0.Fragment, null, "Press ", x.keyName, " again to exit") : $0.createElement($0.Fragment, null, !Y && H && "Enter to continue · ", "Esc to exit"))))
}
// @from(Start 11874172, End 11874933)
function Gn5({
  diffStatsForRestore: A
}) {
  if (A === void 0) return;
  if (!A.filesChanged || !A.filesChanged[0]) return $0.createElement($, {
    dimColor: !0
  }, "The code has not changed (nothing will be restored).");
  let Q = A.filesChanged.length,
    B = "";
  if (Q === 1) B = yWA.basename(A.filesChanged[0] || "");
  else if (Q === 2) {
    let G = yWA.basename(A.filesChanged[0] || ""),
      Z = yWA.basename(A.filesChanged[1] || "");
    B = `${G} and ${Z}`
  } else B = `${yWA.basename(A.filesChanged[0]||"")} and ${A.filesChanged.length-1} other files`;
  return $0.createElement($0.Fragment, null, $0.createElement($, {
    dimColor: !0
  }, "The code will be restored", " ", $0.createElement(wf2, {
    diffStats: A
  }), " in ", B, "."))
}
// @from(Start 11874935, End 11875207)
function wf2({
  diffStats: A
}) {
  if (!A || !A.filesChanged) return;
  return $0.createElement($0.Fragment, null, $0.createElement($, {
    color: "diffAddedWord"
  }, "+", A.insertions, " "), $0.createElement($, {
    color: "diffRemovedWord"
  }, "-", A.deletions))
}
// @from(Start 11875209, End 11876855)
function Uf2({
  userMessage: A,
  color: Q,
  dimColor: B,
  isCurrent: G,
  paddingRight: Z
}) {
  let {
    columns: I
  } = WB();
  if (G) return $0.createElement(S, {
    width: "100%"
  }, $0.createElement($, {
    italic: !0,
    color: Q,
    dimColor: B
  }, "(current)"));
  let Y = A.message.content,
    J = typeof Y === "string" ? Y.trim() : Y[Y.length - 1]?.type === "text" ? Y[Y.length - 1].text.trim() : "(no prompt)";
  if (B31(J)) return $0.createElement(S, {
    flexDirection: "row",
    width: "100%"
  }, $0.createElement($, {
    italic: !0,
    color: Q,
    dimColor: B
  }, "((empty message))"));
  if (J.includes("<bash-input>")) {
    let W = B9(J, "bash-input");
    if (W) return $0.createElement(S, {
      flexDirection: "row",
      width: "100%"
    }, $0.createElement($, {
      color: "bashBorder"
    }, "!"), $0.createElement($, {
      color: Q,
      dimColor: B
    }, " ", W))
  }
  if (J.includes("<command-message>")) {
    let W = B9(J, "command-message"),
      X = B9(J, "command-args");
    if (W)
      if (W.startsWith("The ")) return $0.createElement(S, {
        flexDirection: "row",
        width: "100%"
      }, $0.createElement($, {
        color: Q,
        dimColor: B
      }, W));
      else return $0.createElement(S, {
        flexDirection: "row",
        width: "100%"
      }, $0.createElement($, {
        color: Q,
        dimColor: B
      }, "/", W, " ", X))
  }
  return $0.createElement(S, {
    flexDirection: "row",
    width: "100%"
  }, $0.createElement($, {
    color: Q,
    dimColor: B
  }, Z ? J7(J, I - Z, !0) : J.slice(0, 500).split(`
`).slice(0, 4).join(`
`)))
}
// @from(Start 11876857, End 11877729)
function Zn5(A, Q, B) {
  let G = A.findIndex((W) => W.uuid === Q);
  if (G === -1) return;
  let Z = B ? A.findIndex((W) => W.uuid === B) : A.length;
  if (Z === -1) Z = A.length;
  let I = [],
    Y = 0,
    J = 0;
  for (let W = G + 1; W < Z; W++) {
    let X = A[W];
    if (!X || !qf2(X)) continue;
    let V = X.toolUseResult;
    if (!V || !V.filePath || !V.structuredPatch) continue;
    if (!I.includes(V.filePath)) I.push(V.filePath);
    try {
      if ("type" in V && V.type === "create") Y += V.content.split(/\r?\n/).length;
      else
        for (let F of V.structuredPatch) {
          let K = F.lines.filter((H) => H.startsWith("+")).length,
            D = F.lines.filter((H) => H.startsWith("-")).length;
          Y += K, J += D
        }
    } catch {
      continue
    }
  }
  return {
    filesChanged: I,
    insertions: Y,
    deletions: J
  }
}
// @from(Start 11877731, End 11878270)
function yn(A) {
  if (A.type !== "user") return !1;
  if (Array.isArray(A.message.content) && A.message.content[0]?.type === "tool_result") return !1;
  if (Q31(A)) return !1;
  if (A.isMeta) return !1;
  let Q = A.message.content,
    B = typeof Q === "string" ? Q.trim() : Q[Q.length - 1]?.type === "text" ? Q[Q.length - 1].text.trim() : "";
  if (B.indexOf("<local-command-stdout>") !== -1 || B.indexOf("<local-command-stderr>") !== -1 || B.indexOf("<bash-stdout>") !== -1 || B.indexOf("<bash-stderr>") !== -1) return !1;
  return !0
}
// @from(Start 11878275, End 11878277)
$0
// @from(Start 11878279, End 11878281)
X$
// @from(Start 11878283, End 11878286)
Qn5
// @from(Start 11878288, End 11878291)
Bn5
// @from(Start 11878293, End 11878300)
L70 = 7
// @from(Start 11878306, End 11878832)
zTA = L(() => {
  hA();
  V9();
  cQ();
  q0();
  Q4();
  S5();
  z9();
  g1();
  sU();
  i8();
  BK();
  $0 = BA(VA(), 1), X$ = BA(VA(), 1), Qn5 = [{
    value: "both",
    label: "Restore code and conversation"
  }, {
    value: "conversation",
    label: "Restore conversation"
  }, {
    value: "code",
    label: "Restore code"
  }, {
    value: "nevermind",
    label: "Never mind"
  }], Bn5 = [{
    value: "conversation",
    label: "Restore conversation"
  }, {
    value: "nevermind",
    label: "Never mind"
  }]
})
// @from(Start 11878835, End 11879109)
function Lf2(A) {
  Nf2.useEffect(() => {
    if (!A.length) return;
    let Q = uU(A);
    if (Q) Q.client.setNotificationHandler(In5, async (B) => {
      let {
        eventName: G,
        eventData: Z
      } = B.params;
      GA(`tengu_ide_${G}`, Z)
    })
  }, [A])
}
// @from(Start 11879114, End 11879117)
Nf2
// @from(Start 11879119, End 11879122)
In5
// @from(Start 11879128, End 11879352)
Mf2 = L(() => {
  Q2();
  q0();
  nY();
  Nf2 = BA(VA(), 1), In5 = j.object({
    method: j.literal("log_event"),
    params: j.object({
      eventName: j.string(),
      eventData: j.object({}).passthrough()
    })
  })
})
// @from(Start 11879355, End 11880199)
function Of2({
  file_path: A,
  edits: Q
}) {
  let B = G31.useMemo(() => RA().existsSync(A) ? _q(A) : "", [A]),
    G = G31.useMemo(() => Q.map((I) => {
      let Y = T1A(B, I.old_string) || I.old_string;
      return {
        ...I,
        old_string: Y
      }
    }), [B, Q]),
    Z = G31.useMemo(() => Uq({
      filePath: A,
      fileContents: B,
      edits: G
    }), [A, B, G]);
  return eh.createElement(S, {
    flexDirection: "column"
  }, eh.createElement(S, {
    borderDimColor: !0,
    borderColor: "subtle",
    borderStyle: "dashed",
    flexDirection: "column",
    borderLeft: !1,
    borderRight: !1,
    paddingX: 1
  }, dV(Z.map((I) => eh.createElement(J$, {
    key: I.newStart,
    patch: I,
    dim: !1,
    filePath: A
  })), (I) => eh.createElement($, {
    dimColor: !0,
    key: `ellipsis-${I}`
  }, "..."))))
}
// @from(Start 11880204, End 11880206)
eh
// @from(Start 11880208, End 11880211)
G31
// @from(Start 11880217, End 11880322)
Rf2 = L(() => {
  En();
  hA();
  Rh();
  R9();
  AQ();
  P1A();
  eh = BA(VA(), 1), G31 = BA(VA(), 1)
})
// @from(Start 11880325, End 11880660)
function xWA({
  title: A,
  subtitle: Q,
  color: B = "permission"
}) {
  return Ag.createElement(S, {
    flexDirection: "column"
  }, Ag.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, Ag.createElement($, {
    bold: !0,
    color: B
  }, A), Q !== void 0 && Ag.createElement($, {
    wrap: "truncate-start"
  }, Q)))
}
// @from(Start 11880665, End 11880667)
Ag
// @from(Start 11880673, End 11880718)
Z31 = L(() => {
  hA();
  Ag = BA(VA(), 1)
})
// @from(Start 11880721, End 11881235)
function uJ({
  title: A,
  subtitle: Q,
  color: B = "permission",
  titleColor: G,
  innerPaddingX: Z = 1,
  children: I
}) {
  return Qg.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: B,
    borderLeft: !1,
    borderRight: !1,
    borderBottom: !1,
    marginTop: 1
  }, Qg.createElement(S, {
    paddingX: 1
  }, Qg.createElement(xWA, {
    title: A,
    subtitle: Q,
    color: G
  })), Qg.createElement(S, {
    flexDirection: "column",
    paddingX: Z
  }, I))
}
// @from(Start 11881240, End 11881242)
Qg
// @from(Start 11881248, End 11881301)
wO = L(() => {
  hA();
  Z31();
  Qg = BA(VA(), 1)
})
// @from(Start 11881304, End 11881628)
function CY(A) {
  GA("tengu_unary_event", {
    event: A.event,
    completion_type: A.completion_type,
    language_name: A.metadata.language_name,
    message_id: A.metadata.message_id,
    platform: A.metadata.platform,
    ...A.metadata.hasFeedback !== void 0 && {
      hasFeedback: A.metadata.hasFeedback
    }
  })
}
// @from(Start 11881633, End 11881657)
xn = L(() => {
  q0()
})
// @from(Start 11881660, End 11882289)
function V$(A, Q) {
  Tf2.useEffect(() => {
    GA("tengu_tool_use_show_permission_request", {
      messageID: A.assistantMessage.message.id,
      toolName: A.tool.name,
      isMcp: A.tool.isMcp ?? !1,
      decisionReasonType: A.permissionResult.decisionReason?.type,
      sandboxEnabled: nQ.isSandboxingEnabled()
    }), Promise.resolve(Q.language_name).then((G) => {
      CY({
        completion_type: Q.completion_type,
        event: "response",
        metadata: {
          language_name: G,
          message_id: A.assistantMessage.message.id,
          platform: d0.platform
        }
      })
    })
  }, [A, Q])
}
// @from(Start 11882294, End 11882297)
Tf2
// @from(Start 11882303, End 11882404)
vn = L(() => {
  q0();
  bU();
  pF();
  AZ();
  cK();
  c5();
  xn();
  $J();
  Tf2 = BA(VA(), 1)
})
// @from(Start 11882449, End 11883604)
function Pf2({
  filePath: A,
  toolPermissionContext: Q,
  operationType: B = "write",
  onRejectFeedbackChange: G
}) {
  let Z = [{
      label: "Yes",
      value: "yes",
      option: {
        type: "accept-once"
      }
    }],
    I = qT(A, Q),
    Y, J = tA.bold(`(${HU.displayText})`);
  if (I)
    if (B === "read") Y = "Yes, during this session";
    else Y = `Yes, allow all edits during this session ${J}`;
  else {
    let W = Zv(A),
      X = Yn5(W) || "this directory";
    if (B === "read") Y = `Yes, allow reading from ${tA.bold(`${X}/`)} during this session`;
    else Y = `Yes, allow all edits in ${tA.bold(`${X}/`)} during this session ${J}`
  }
  if (Z.push({
      label: Y,
      value: "yes-session",
      option: {
        type: "accept-session"
      }
    }), G) Z.push({
    type: "input",
    label: "No",
    value: "no",
    placeholder: "Type here to tell Claude what to do differently",
    onChange: G,
    option: {
      type: "reject"
    }
  });
  else Z.push({
    label: `No, and tell Claude what to do differently ${tA.bold("(esc)")}`,
    value: "no",
    option: {
      type: "reject"
    }
  });
  return Z
}
// @from(Start 11883609, End 11883658)
jf2 = L(() => {
  F9();
  EJ();
  Up();
  yI()
})
// @from(Start 11883661, End 11883865)
function M70(A, Q, B, G, Z) {
  CY({
    completion_type: Q,
    event: A,
    metadata: {
      language_name: B,
      message_id: G,
      platform: d0.platform,
      hasFeedback: Z ?? !1
    }
  })
}
// @from(Start 11883867, End 11884056)
function Jn5(A) {
  let {
    messageId: Q,
    toolUseConfirm: B,
    onDone: G,
    completionType: Z,
    languageName: I
  } = A;
  M70("accept", Z, I, Q), G(), B.onAllow(B.input, [])
}
// @from(Start 11884058, End 11884346)
function Wn5(A) {
  let {
    messageId: Q,
    path: B,
    toolUseConfirm: G,
    toolPermissionContext: Z,
    onDone: I,
    completionType: Y,
    languageName: J,
    operationType: W
  } = A;
  M70("accept", Y, J, Q);
  let X = B ? I31(B, W, Z) : [];
  I(), G.onAllow(G.input, X)
}
// @from(Start 11884348, End 11884579)
function Xn5(A, Q) {
  let {
    messageId: B,
    toolUseConfirm: G,
    onDone: Z,
    onReject: I,
    completionType: Y,
    languageName: J
  } = A;
  M70("reject", Y, J, B, Q?.hasFeedback), Z(), I(), G.onReject(Q?.feedback)
}
// @from(Start 11884584, End 11884587)
Sf2
// @from(Start 11884593, End 11884716)
_f2 = L(() => {
  xn();
  c5();
  EJ();
  Sf2 = {
    "accept-once": Jn5,
    "accept-session": Wn5,
    reject: Xn5
  }
})
// @from(Start 11884719, End 11885843)
function kf2({
  filePath: A,
  completionType: Q,
  languageName: B,
  toolUseConfirm: G,
  onDone: Z,
  onReject: I,
  parseInput: Y,
  operationType: J = "write",
  onRejectFeedbackChange: W
}) {
  let [X] = OQ(), V = X.toolPermissionContext, F = Y31.useMemo(() => Pf2({
    filePath: A,
    toolPermissionContext: V,
    operationType: J,
    onRejectFeedbackChange: W
  }), [A, V, J, W]), K = Y31.useCallback((D, H, C) => {
    let E = {
        messageId: G.assistantMessage.message.id,
        path: A,
        toolUseConfirm: G,
        toolPermissionContext: V,
        onDone: Z,
        onReject: I,
        completionType: Q,
        languageName: B,
        operationType: J
      },
      U = G.onAllow;
    G.onAllow = (w, N) => {
      U(H, N)
    };
    let q = Sf2[D.type];
    q(E, {
      feedback: C,
      hasFeedback: !!C
    })
  }, [A, Q, B, G, V, Z, I, J]);
  return f1((D, H) => {
    if (HU.check(D, H)) {
      let C = F.find((E) => E.option.type === "accept-session");
      if (C) {
        let E = Y(G.input);
        K(C.option, E)
      }
    }
  }), {
    options: F,
    onChange: K
  }
}
// @from(Start 11885848, End 11885851)
Y31
// @from(Start 11885857, End 11885937)
yf2 = L(() => {
  hA();
  Up();
  jf2();
  _f2();
  z9();
  Y31 = BA(VA(), 1)
})
// @from(Start 11886028, End 11887429)
function xf2({
  onChange: A,
  toolUseContext: Q,
  filePath: B,
  edits: G,
  editMode: Z
}) {
  let I = Bg.useRef(!1),
    [Y, J] = Bg.useState(!1),
    W = Bg.useMemo(() => Vn5().slice(0, 6), []),
    X = Bg.useMemo(() => `✻ [Claude Code] ${Fn5(B)} (${W}) ⧉`, [B, W]),
    V = SQ1(Q.options.mcpClients) && N1().diffTool === "auto" && !B.endsWith(".ipynb"),
    F = kQ1(Q.options.mcpClients) ?? "IDE";
  async function K() {
    if (!V) return;
    try {
      GA("tengu_ext_will_show_diff", {});
      let {
        oldContent: D,
        newContent: H
      } = await Dn5(B, G, Q, X);
      if (I.current) return;
      GA("tengu_ext_diff_accepted", {});
      let C = Kn5(B, D, H, Z);
      if (C.length === 0) {
        GA("tengu_ext_diff_rejected", {});
        let E = uU(Q.options.mcpClients);
        if (E) await O70(X, E);
        A({
          type: "reject"
        }, {
          file_path: B,
          edits: G
        });
        return
      }
      A({
        type: "accept-once"
      }, {
        file_path: B,
        edits: C
      })
    } catch (D) {
      AA(D), J(!0)
    }
  }
  return Bg.useEffect(() => {
    return K(), () => {
      I.current = !0
    }
  }, []), {
    closeTabInIDE() {
      let D = uU(Q.options.mcpClients);
      if (!D) return Promise.resolve();
      return O70(X, D)
    },
    showingDiffInIDE: V && !Y,
    ideName: F,
    hasError: Y
  }
}
// @from(Start 11887431, End 11887734)
function Kn5(A, Q, B, G) {
  let Z = G === "single",
    I = WI2({
      filePath: A,
      oldContent: Q,
      newContent: B,
      singleHunk: Z
    });
  if (I.length === 0) return [];
  if (Z && I.length > 1) AA(Error(`Unexpected number of hunks: ${I.length}. Expected 1 hunk.`));
  return KI2(I)
}
// @from(Start 11887735, End 11889079)
async function Dn5(A, Q, B, G) {
  let Z = !1,
    I = RA(),
    Y = b9(A),
    J = I.existsSync(Y) ? _q(Y) : "";
  async function W() {
    if (Z) return;
    Z = !0;
    try {
      await O70(G, X)
    } catch (V) {
      AA(V)
    }
    process.off("beforeExit", W), B.abortController.signal.removeEventListener("abort", W)
  }
  B.abortController.signal.addEventListener("abort", W), process.on("beforeExit", W);
  let X = uU(B.options.mcpClients);
  try {
    let {
      updatedFile: V
    } = hMA({
      filePath: Y,
      fileContents: J,
      edits: Q
    });
    if (!X || X.type !== "connected") throw Error("IDE client not available");
    let F = Y,
      K = X.config.ideRunningInWindows === !0;
    if (dQ() === "wsl" && K && process.env.WSL_DISTRO_NAME) F = new $IA(process.env.WSL_DISTRO_NAME).toIDEPath(Y);
    let D = await Jh("openDiff", {
        old_file_path: F,
        new_file_path: F,
        new_file_contents: V,
        tab_name: G
      }, X),
      H = Array.isArray(D) ? D : [D];
    if (En5(H)) return W(), {
      oldContent: J,
      newContent: H[1].text
    };
    else if (Hn5(H)) return W(), {
      oldContent: J,
      newContent: V
    };
    else if (Cn5(H)) return W(), {
      oldContent: J,
      newContent: J
    };
    throw Error("Not accepted")
  } catch (V) {
    throw AA(V), W(), V
  }
}
// @from(Start 11889080, End 11889281)
async function O70(A, Q) {
  try {
    if (!Q || Q.type !== "connected") throw Error("IDE client not available");
    await Jh("close_tab", {
      tab_name: A
    }, Q)
  } catch (B) {
    AA(B)
  }
}
// @from(Start 11889283, End 11889463)
function Hn5(A) {
  return Array.isArray(A) && typeof A[0] === "object" && A[0] !== null && "type" in A[0] && A[0].type === "text" && "text" in A[0] && A[0].text === "TAB_CLOSED"
}
// @from(Start 11889465, End 11889648)
function Cn5(A) {
  return Array.isArray(A) && typeof A[0] === "object" && A[0] !== null && "type" in A[0] && A[0].type === "text" && "text" in A[0] && A[0].text === "DIFF_REJECTED"
}
// @from(Start 11889650, End 11889783)
function En5(A) {
  return Array.isArray(A) && A[0]?.type === "text" && A[0].text === "FILE_SAVED" && typeof A[1].text === "string"
}
// @from(Start 11889788, End 11889790)
Bg
// @from(Start 11889796, End 11889931)
vf2 = L(() => {
  AQ();
  P1A();
  Rh();
  g1();
  jQ();
  nY();
  q0();
  nY();
  yI();
  De1();
  Q3();
  R9();
  Bg = BA(VA(), 1)
})
// @from(Start 11889976, End 11891390)
function bf2({
  onChange: A,
  options: Q,
  input: B,
  filePath: G,
  ideName: Z,
  onRejectFeedbackChange: I
}) {
  let [Y, J] = vq.useState(""), [W, X] = vq.useState(null), V = (K) => {
    J(K), I?.(K)
  }, F = Q.map((K) => {
    if (K.type === "input" && I) return {
      ...K,
      onChange: V
    };
    return K
  });
  return vq.default.createElement(S, {
    flexDirection: "column"
  }, vq.default.createElement(D3, {
    dividerColor: "permission"
  }), vq.default.createElement(S, {
    marginX: 1,
    flexDirection: "column",
    gap: 1
  }, vq.default.createElement($, {
    bold: !0,
    color: "permission"
  }, "Opened changes in ", Z, " ⧉"), KLA() && vq.default.createElement($, {
    dimColor: !0
  }, "Save file to continue…"), vq.default.createElement(S, {
    flexDirection: "column"
  }, vq.default.createElement($, null, "Do you want to make this edit to", " ", vq.default.createElement($, {
    bold: !0
  }, zn5(G)), "?"), vq.default.createElement(M0, {
    options: F,
    onChange: (K) => {
      let D = Q.find((H) => H.value === K);
      if (D) {
        if (D.option.type === "reject") {
          if (Y.trim() === "") {
            X("no");
            return
          }
          A(D.option, B, Y);
          return
        }
        A(D.option, B)
      }
    },
    onCancel: () => A({
      type: "reject"
    }, B),
    onFocus: X,
    focusValue: W || void 0
  }))))
}
// @from(Start 11891395, End 11891397)
vq
// @from(Start 11891403, End 11891472)
ff2 = L(() => {
  hA();
  J5();
  nY();
  BK();
  vq = BA(VA(), 1)
})
// @from(Start 11891475, End 11893916)
function bn({
  toolUseConfirm: A,
  toolUseContext: Q,
  onDone: B,
  onReject: G,
  title: Z,
  subtitle: I,
  question: Y = "Do you want to proceed?",
  content: J,
  completionType: W = "tool_use_single",
  languageName: X = "none",
  path: V,
  parseInput: F,
  operationType: K = "write",
  ideDiffSupport: D
}) {
  let H = aE.useMemo(() => ({
    completion_type: W,
    language_name: X
  }), [W, X]);
  V$(A, H);
  let [C, E] = aE.useState(""), [U, q] = aE.useState(null), w = kf2({
    filePath: V || "",
    completionType: W,
    languageName: X,
    toolUseConfirm: A,
    onDone: B,
    onReject: G,
    parseInput: F,
    operationType: K,
    onRejectFeedbackChange: E
  }), N = w.options, R = F(A.input), T = D ? D.getConfig(R) : null, y = T ? {
    onChange: (e, l) => {
      let k = D.applyChanges(R, l.edits);
      w.onChange(e, k)
    },
    toolUseContext: Q,
    filePath: T.filePath,
    edits: (T.edits || []).map((e) => ({
      old_string: e.old_string,
      new_string: e.new_string,
      replace_all: e.replace_all || !1
    })),
    editMode: T.editMode || "single"
  } : {
    onChange: () => {},
    toolUseContext: Q,
    filePath: "",
    edits: [],
    editMode: "single"
  }, {
    closeTabInIDE: v,
    showingDiffInIDE: x,
    ideName: p
  } = xf2(y), u = (e, l) => {
    e.type, v?.(), w.onChange(e, R, l?.trim())
  };
  if (x && T && V) return aE.default.createElement(bf2, {
    onChange: (e, l, k) => u(e, k),
    options: N,
    filePath: V,
    input: R,
    ideName: p,
    onRejectFeedbackChange: E
  });
  return aE.default.createElement(aE.default.Fragment, null, aE.default.createElement(uJ, {
    title: Z,
    subtitle: I,
    innerPaddingX: 0
  }, J, aE.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, typeof Y === "string" ? aE.default.createElement($, null, Y) : Y, aE.default.createElement(M0, {
    options: N,
    onChange: (e) => {
      let l = N.find((k) => k.value === e);
      if (l) {
        if (l.option.type === "reject") {
          if (C.trim() === "") {
            q("no");
            return
          }
          u(l.option, C);
          return
        }
        u(l.option)
      }
    },
    onCancel: () => u({
      type: "reject"
    }),
    onFocus: q,
    focusValue: U || void 0
  }))), aE.default.createElement(S, {
    paddingX: 1,
    marginTop: 1
  }, aE.default.createElement($, {
    dimColor: !0
  }, "Esc to exit")))
}
// @from(Start 11893921, End 11893923)
aE
// @from(Start 11893929, End 11894025)
UTA = L(() => {
  hA();
  J5();
  wO();
  vn();
  yf2();
  vf2();
  ff2();
  aE = BA(VA(), 1)
})
// @from(Start 11894028, End 11894196)
function J31(A, Q, B, G) {
  return {
    filePath: A,
    edits: [{
      old_string: Q,
      new_string: B,
      replace_all: G
    }],
    editMode: "single"
  }
}
// @from(Start 11894282, End 11895177)
function hf2(A) {
  let Q = (J) => {
      return lD.inputSchema.parse(J)
    },
    B = Q(A.toolUseConfirm.input),
    {
      file_path: G,
      old_string: Z,
      new_string: I,
      replace_all: Y
    } = B;
  return $TA.default.createElement(bn, {
    toolUseConfirm: A.toolUseConfirm,
    toolUseContext: A.toolUseContext,
    onDone: A.onDone,
    onReject: A.onReject,
    title: "Edit file",
    subtitle: $n5(W0(), G),
    question: $TA.default.createElement($, null, "Do you want to make this edit to", " ", $TA.default.createElement($, {
      bold: !0
    }, Un5(G)), "?"),
    content: $TA.default.createElement(Of2, {
      file_path: G,
      edits: [{
        old_string: Z,
        new_string: I,
        replace_all: Y || !1
      }]
    }),
    path: G,
    completionType: "str_replace_single",
    languageName: vWA(G),
    parseInput: Q,
    ideDiffSupport: wn5
  })
}
// @from(Start 11895182, End 11895185)
$TA
// @from(Start 11895187, End 11895190)
wn5
// @from(Start 11895196, End 11895599)
gf2 = L(() => {
  hA();
  zn();
  Rf2();
  R9();
  UTA();
  U2();
  $TA = BA(VA(), 1), wn5 = {
    getConfig: (A) => J31(A.file_path, A.old_string, A.new_string, A.replace_all),
    applyChanges: (A, Q) => {
      let B = Q[0];
      if (B) return {
        ...A,
        old_string: B.old_string,
        new_string: B.new_string,
        replace_all: B.replace_all
      };
      return A
    }
  }
})
// @from(Start 11895602, End 11895868)
function fn(A, {
  assistantMessage: {
    message: {
      id: Q
    }
  }
}, B, G) {
  CY({
    completion_type: A,
    event: B,
    metadata: {
      language_name: "none",
      message_id: Q,
      platform: d0.platform,
      hasFeedback: G ?? !1
    }
  })
}
// @from(Start 11895873, End 11895906)
R70 = L(() => {
  c5();
  xn()
})
// @from(Start 11895938, End 11896216)
function qn5(A) {
  switch (A.length) {
    case 0:
      return "";
    case 1:
      return tA.bold(A[0]);
    case 2:
      return tA.bold(A[0]) + " and " + tA.bold(A[1]);
    default:
      return tA.bold(A.slice(0, -1).join(", ")) + ", and " + tA.bold(A.slice(-1)[0])
  }
}
// @from(Start 11896218, End 11896310)
function uf2(A) {
  let Q = qn5(A);
  if (Q.length > 50) return "similar";
  else return Q
}
// @from(Start 11896312, End 11896602)
function W31(A) {
  if (A.length === 0) return "";
  let Q = A.map((B) => {
    let G = B.split("/").pop() || B;
    return tA.bold(G) + X31.sep
  });
  if (Q.length === 1) return Q[0];
  if (Q.length === 2) return `${Q[0]} and ${Q[1]}`;
  return `${Q[0]}, ${Q[1]} and ${A.length-2} more`
}
// @from(Start 11896604, End 11898327)
function Nn5(A) {
  let Q = A.filter((V) => V.type === "addRules").flatMap((V) => V.rules || []),
    B = Q.filter((V) => V.toolName === "Read"),
    G = Q.filter((V) => V.toolName === "Bash"),
    Z = A.filter((V) => V.type === "addDirectories").flatMap((V) => V.directories || []),
    I = B.map((V) => V.ruleContent?.replace("/**", "") || "").filter((V) => V),
    Y = G.flatMap((V) => {
      if (!V.ruleContent) return [];
      let F = co1(V.ruleContent) ?? V.ruleContent,
        {
          commandWithoutRedirections: K,
          redirections: D
        } = nT(F);
      return D.length > 0 ? K : F
    }),
    J = Z.length > 0,
    W = I.length > 0,
    X = Y.length > 0;
  if (W && !J && !X) {
    if (I.length === 1) {
      let V = I[0],
        F = V.split("/").pop() || V;
      return `Yes, allow reading from ${tA.bold(F)}${X31.sep} from this project`
    }
    return `Yes, allow reading from ${W31(I)} from this project`
  }
  if (J && !W && !X) {
    if (Z.length === 1) {
      let V = Z[0],
        F = V.split("/").pop() || V;
      return `Yes, and always allow access to ${tA.bold(F)}${X31.sep} from this project`
    }
    return `Yes, and always allow access to ${W31(Z)} from this project`
  }
  if (X && !J && !W) return `Yes, and don't ask again for ${uf2(Y)} commands in ${tA.bold(uQ())}`;
  if ((J || W) && !X) {
    let V = [...Z, ...I];
    if (J && W) return `Yes, and always allow access to ${W31(V)} from this project`
  }
  if ((J || W) && X) {
    let V = [...Z, ...I],
      F = W31(V),
      K = uf2(Y);
    if (V.length === 1 && Y.length === 1) return `Yes, and allow access to ${F} and ${K} commands`;
    return `Yes, and allow ${F} access and ${K} commands`
  }
  return null
}
// @from(Start 11898329, End 11898744)
function mf2({
  suggestions: A = [],
  onRejectFeedbackChange: Q
}) {
  let B = [{
    label: "Yes",
    value: "yes"
  }];
  if (A.length > 0) {
    let G = Nn5(A);
    if (G) B.push({
      label: G,
      value: "yes-apply-suggestions"
    })
  }
  return B.push({
    type: "input",
    label: "No",
    value: "no",
    placeholder: "Type here to tell Claude what to do differently",
    onChange: Q
  }), B
}
// @from(Start 11898749, End 11898799)
df2 = L(() => {
  F9();
  _0();
  ao1();
  bU()
})
// @from(Start 11898802, End 11899289)
function Ln5(A) {
  switch (A) {
    case "cliArg":
      return "CLI argument";
    case "command":
      return "command configuration";
    case "session":
      return "current session";
    case "localSettings":
      return "local settings";
    case "projectSettings":
      return "project settings";
    case "policySettings":
      return "managed settings";
    case "userSettings":
      return "global settings";
    case "flagSettings":
      return "--settings flag"
  }
}
// @from(Start 11899291, End 11900014)
function cf2(A) {
  switch (A.type) {
    case "rule":
      return `${tA.bold(B3(A.rule.ruleValue))} rule from ${Ln5(A.rule.source)}`;
    case "mode":
      return `${Fv(A.mode)} mode`;
    case "sandboxOverride":
      return "Requires permission to bypass sandbox";
    case "workingDir":
      return A.reason;
    case "other":
      return A.reason;
    case "permissionPromptTool":
      return `${tA.bold(A.permissionPromptToolName)} permission prompt tool`;
    case "hook":
      return A.reason ? `${tA.bold(A.hookName)} hook: ${A.reason}` : `${tA.bold(A.hookName)} hook`;
    case "asyncAgent":
      return A.reason;
    case "classifier":
      return `${tA.bold(A.classifier)} classifier: ${A.reason}`
  }
}
// @from(Start 11900016, End 11901175)
function Mn5({
  title: A,
  decisionReason: Q
}) {
  let [B] = qB();

  function G() {
    switch (Q.type) {
      case "subcommandResults":
        return B4.default.createElement(S, {
          flexDirection: "column"
        }, Array.from(Q.reasons.entries()).map(([Z, I]) => {
          let Y = I.behavior === "allow" ? ZB("success", B)(H1.tick) : ZB("error", B)(H1.cross);
          return B4.default.createElement(S, {
            flexDirection: "column",
            key: Z
          }, B4.default.createElement($, null, Y, " ", Z), I.decisionReason !== void 0 && I.decisionReason.type !== "subcommandResults" && B4.default.createElement($, null, "  ", "⎿", "  ", cf2(I.decisionReason)), I.behavior === "ask" && (() => {
            let J = z9A(I.suggestions);
            return J.length > 0 ? B4.default.createElement($, null, "  ", "⎿", "  ", "Suggested rules:", " ", J.map((W) => tA.bold(B3(W))).join(", ")) : null
          })())
        }));
      default:
        return B4.default.createElement($, null, cf2(Q))
    }
  }
  return B4.default.createElement(S, {
    flexDirection: "column"
  }, A && B4.default.createElement($, null, A), G())
}
// @from(Start 11901177, End 11901370)
function On5(A) {
  if (!A) return [];
  return A.flatMap((Q) => {
    switch (Q.type) {
      case "addDirectories":
        return Q.directories;
      default:
        return []
    }
  })
}
// @from(Start 11901372, End 11901529)
function Rn5(A) {
  if (!A) return;
  for (let Q = A.length - 1; Q >= 0; Q--) {
    let B = A[Q];
    if (B?.type === "setMode") return B.mode
  }
  return
}
// @from(Start 11901531, End 11903567)
function Tn5({
  suggestions: A,
  width: Q
}) {
  if (!A || A.length === 0) return B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: Q
  }, B4.default.createElement($, {
    dimColor: !0
  }, "Suggestions ")), B4.default.createElement($, null, "None"));
  let B = z9A(A),
    G = On5(A),
    Z = Rn5(A);
  if (B.length === 0 && G.length === 0 && !Z) return B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: Q
  }, B4.default.createElement($, {
    dimColor: !0
  }, "Suggestion ")), B4.default.createElement($, null, "None"));
  return B4.default.createElement(S, {
    flexDirection: "column"
  }, B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: Q
  }, B4.default.createElement($, {
    dimColor: !0
  }, "Suggestions ")), B4.default.createElement($, null, " ")), B.length > 0 && B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: Q
  }, B4.default.createElement($, {
    dimColor: !0
  }, " Rules ")), B4.default.createElement(S, {
    flexDirection: "column"
  }, B.map((I, Y) => B4.default.createElement($, {
    key: Y
  }, H1.bullet, " ", B3(I))))), G.length > 0 && B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: Q
  }, B4.default.createElement($, {
    dimColor: !0
  }, " Directories ")), B4.default.createElement(S, {
    flexDirection: "column"
  }, G.map((I, Y) => B4.default.createElement($, {
    key: Y
  }, H1.bullet, " ", I)))), Z && B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: Q
  }, B4.default.createElement($, {
    dimColor: !0
  }, " Mode ")), B4.default.createElement($, null, Fv(Z))))
}
// @from(Start 11903569, End 11904725)
function pf2({
  permissionResult: A
}) {
  let Q = A.decisionReason,
    B = "suggestions" in A ? A.suggestions : void 0,
    G = 10;
  return B4.default.createElement(S, {
    flexDirection: "column"
  }, B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: 10
  }, B4.default.createElement($, {
    dimColor: !0
  }, "Behavior ")), B4.default.createElement($, null, A.behavior)), A.behavior !== "allow" && B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: 10
  }, B4.default.createElement($, {
    dimColor: !0
  }, "Message ")), B4.default.createElement($, null, A.message)), B4.default.createElement(S, {
    flexDirection: "row"
  }, B4.default.createElement(S, {
    justifyContent: "flex-end",
    minWidth: 10
  }, B4.default.createElement($, {
    dimColor: !0
  }, "Reason ")), Q === void 0 ? B4.default.createElement($, null, "undefined") : B4.default.createElement(Mn5, {
    decisionReason: Q
  })), B4.default.createElement(Tn5, {
    suggestions: B,
    width: 10
  }))
}
// @from(Start 11904730, End 11904732)
B4
// @from(Start 11904738, End 11904823)
lf2 = L(() => {
  hA();
  AZ();
  F9();
  V9();
  Zw();
  cK();
  B4 = BA(VA(), 1)
})
// @from(Start 11904826, End 11905577)
function Pn5(A, Q) {
  if (!A) return null;
  switch (A.type) {
    case "rule":
      return {
        reasonString: `Permission rule ${tA.bold(B3(A.rule.ruleValue))} requires confirmation for this ${Q}.`, configString: A.rule.source === "policySettings" ? void 0 : "/permissions to update rules"
      };
    case "hook": {
      let B = A.reason ? `:
${A.reason}` : ".";
      return {
        reasonString: `Hook ${tA.bold(A.hookName)} requires confirmation for this ${Q}${B}`,
        configString: "/hooks to update"
      }
    }
    case "classifier":
      return {
        reasonString: `Classifier ${tA.bold(A.classifier)} requires confirmation for this ${Q}.
${A.reason}`, configString: void 0
      };
    default:
      return null
  }
}
// @from(Start 11905579, End 11905930)
function VC({
  permissionResult: A,
  toolType: Q
}) {
  let B = Pn5(A?.decisionReason, Q);
  if (!B) return null;
  return V31.default.createElement(S, {
    marginBottom: 1,
    flexDirection: "column"
  }, V31.default.createElement($, null, B.reasonString), B.configString && V31.default.createElement($, {
    dimColor: !0
  }, B.configString))
}
// @from(Start 11905935, End 11905938)
V31
// @from(Start 11905944, End 11906005)
Gg = L(() => {
  hA();
  AZ();
  F9();
  V31 = BA(VA(), 1)
})
// @from(Start 11906008, End 11908827)
function if2({
  toolUseConfirm: A,
  onDone: Q,
  onReject: B,
  serverName: G,
  toolName: Z,
  args: I
}) {
  let Y = `${G} - ${Z}`,
    J = `mcp__${G}__${Z}`,
    W = F$.useMemo(() => ({
      ...A,
      tool: {
        ...A.tool,
        name: J,
        isMcp: !0
      }
    }), [A, J]),
    X = F$.useMemo(() => ({
      completion_type: "tool_use_single",
      language_name: "none"
    }), []);
  V$(W, X);
  let V = (D) => {
      switch (D) {
        case "yes":
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: W.assistantMessage.message.id,
              platform: d0.platform
            }
          }), W.onAllow(W.input, []), Q();
          break;
        case "yes-dont-ask-again": {
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: W.assistantMessage.message.id,
              platform: d0.platform
            }
          });
          let H = W.permissionResult.behavior === "ask" ? W.permissionResult.suggestions || [] : [];
          if (H.length === 0) AA(Error(`MCPCliPermissionRequest: No MCP suggestions found for ${G}/${Z}`)), W.onAllow(W.input, []);
          else W.onAllow(W.input, H);
          Q();
          break
        }
        case "no":
          CY({
            completion_type: "tool_use_single",
            event: "reject",
            metadata: {
              language_name: "none",
              message_id: W.assistantMessage.message.id,
              platform: d0.platform
            }
          }), W.onReject(), B(), Q();
          break
      }
    },
    F = uQ(),
    K = F$.useMemo(() => {
      return [{
        label: "Yes",
        value: "yes"
      }, {
        label: `Yes, and don't ask again for ${tA.bold(Y)} commands in ${tA.bold(F)}`,
        value: "yes-dont-ask-again"
      }, {
        label: `No, and tell Claude what to do differently ${tA.bold("(esc)")}`,
        value: "no"
      }]
    }, [Y, F]);
  return F$.default.createElement(uJ, {
    title: "Tool use"
  }, F$.default.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, F$.default.createElement($, null, Y, "(", I || "{}", ")", F$.default.createElement($, {
    dimColor: !0
  }, " (MCP)")), F$.default.createElement($, {
    dimColor: !0
  }, W.description)), F$.default.createElement(S, {
    flexDirection: "column"
  }, F$.default.createElement(VC, {
    permissionResult: W.permissionResult,
    toolType: "tool"
  }), F$.default.createElement($, null, "Do you want to proceed?"), F$.default.createElement(M0, {
    options: K,
    onChange: V,
    onCancel: () => V("no")
  })))
}
// @from(Start 11908832, End 11908834)
F$
// @from(Start 11908840, End 11908957)
nf2 = L(() => {
  hA();
  J5();
  wO();
  xn();
  c5();
  _0();
  F9();
  vn();
  Gg();
  g1();
  F$ = BA(VA(), 1)
})
// @from(Start 11908960, End 11909644)
function af2(A) {
  let {
    toolUseConfirm: Q,
    toolUseContext: B,
    onDone: G,
    onReject: Z,
    verbose: I
  } = A, {
    command: Y,
    description: J
  } = D9.inputSchema.parse(Q.input), W = hAA(Y);
  if (W) {
    let {
      server: X,
      toolName: V,
      args: F
    } = W;
    return pG.default.createElement(if2, {
      toolUseConfirm: Q,
      toolUseContext: B,
      onDone: G,
      verbose: I,
      onReject: Z,
      serverName: X,
      toolName: V,
      args: F
    })
  }
  return pG.default.createElement(jn5, {
    toolUseConfirm: Q,
    toolUseContext: B,
    onDone: G,
    onReject: Z,
    verbose: I,
    command: Y,
    description: J
  })
}
// @from(Start 11909646, End 11912406)
function jn5({
  toolUseConfirm: A,
  toolUseContext: Q,
  onDone: B,
  onReject: G,
  verbose: Z,
  command: I,
  description: Y
}) {
  let [J] = qB(), [W, X] = pG.useState(!1), [V, F] = pG.useState(""), [K, D] = pG.useState(null), H = nQ.isSandboxingEnabled(), C = H && WIA(A.input), E = pG.useMemo(() => ({
    completion_type: "tool_use_single",
    language_name: "none"
  }), []);
  V$(A, E);
  let U = pG.useMemo(() => mf2({
    suggestions: A.permissionResult.behavior === "ask" ? A.permissionResult.suggestions : void 0,
    onRejectFeedbackChange: F
  }), [A]);
  f1((N, R) => {
    if (R.ctrl && N === "d") X((T) => !T)
  });

  function q(N) {
    let R = N?.trim();
    if (fn("tool_use_single", A, "reject", !!R), R) A.onReject(R);
    else A.onReject();
    G(), B()
  }

  function w(N) {
    switch (N) {
      case "yes":
        fn("tool_use_single", A, "accept"), A.onAllow(A.input, []), B();
        break;
      case "yes-apply-suggestions": {
        fn("tool_use_single", A, "accept");
        let T = A.permissionResult.behavior === "ask" ? A.permissionResult.suggestions || [] : [];
        A.onAllow(A.input, T), B();
        break
      }
      case "no": {
        if (V.trim() === "") {
          D("no");
          return
        }
        q(V);
        break
      }
    }
  }
  return pG.default.createElement(uJ, {
    title: H && !C ? "Bash command (unsandboxed)" : "Bash command"
  }, pG.default.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, pG.default.createElement($, null, D9.renderToolUseMessage({
    command: I,
    description: Y
  }, {
    theme: J,
    verbose: !0
  })), pG.default.createElement($, {
    dimColor: !0
  }, A.description)), W ? pG.default.createElement(pG.default.Fragment, null, pG.default.createElement(pf2, {
    permissionResult: A.permissionResult
  }), A.toolUseContext.options.debug && pG.default.createElement(S, {
    justifyContent: "flex-end",
    marginTop: 1
  }, pG.default.createElement($, {
    dimColor: !0
  }, "Ctrl-D to hide debug info"))) : pG.default.createElement(pG.default.Fragment, null, pG.default.createElement(S, {
    flexDirection: "column"
  }, pG.default.createElement(VC, {
    permissionResult: A.permissionResult,
    toolType: "command"
  }), pG.default.createElement($, null, "Do you want to proceed?"), pG.default.createElement(M0, {
    options: U,
    onChange: w,
    onCancel: () => q(),
    onFocus: D,
    focusValue: K || void 0
  })), pG.default.createElement(S, {
    justifyContent: "space-between",
    marginTop: 1
  }, pG.default.createElement($, {
    dimColor: !0
  }, "Esc to exit"), A.toolUseContext.options.debug && pG.default.createElement($, {
    dimColor: !0
  }, "Ctrl+d to show debug info"))))
}
// @from(Start 11912411, End 11912413)
pG
// @from(Start 11912419, End 11912556)
sf2 = L(() => {
  hA();
  pF();
  vn();
  wO();
  R70();
  S5();
  df2();
  lf2();
  Gg();
  $J();
  nf2();
  dH();
  pG = BA(VA(), 1)
})
// @from(Start 11912559, End 11915278)
function F31({
  toolUseConfirm: A,
  onDone: Q,
  onReject: B,
  verbose: G
}) {
  let [Z] = qB(), I = A.tool.userFacingName(A.input), Y = I.endsWith(" (MCP)") ? I.slice(0, -6) : I, J = bq.useMemo(() => ({
    completion_type: "tool_use_single",
    language_name: "none"
  }), []);
  V$(A, J);
  let W = (F) => {
      switch (F) {
        case "yes":
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: A.assistantMessage.message.id,
              platform: d0.platform
            }
          }), A.onAllow(A.input, []), Q();
          break;
        case "yes-dont-ask-again": {
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: A.assistantMessage.message.id,
              platform: d0.platform
            }
          }), A.onAllow(A.input, [{
            type: "addRules",
            rules: [{
              toolName: A.tool.name
            }],
            behavior: "allow",
            destination: "localSettings"
          }]), Q();
          break
        }
        case "no":
          CY({
            completion_type: "tool_use_single",
            event: "reject",
            metadata: {
              language_name: "none",
              message_id: A.assistantMessage.message.id,
              platform: d0.platform
            }
          }), A.onReject(), B(), Q();
          break
      }
    },
    X = uQ(),
    V = bq.useMemo(() => {
      return [{
        label: "Yes",
        value: "yes"
      }, {
        label: `Yes, and don't ask again for ${tA.bold(Y)} commands in ${tA.bold(X)}`,
        value: "yes-dont-ask-again"
      }, {
        label: `No, and tell Claude what to do differently ${tA.bold("(esc)")}`,
        value: "no"
      }]
    }, [Y, X]);
  return bq.default.createElement(uJ, {
    title: "Tool use"
  }, bq.default.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, bq.default.createElement($, null, Y, "(", A.tool.renderToolUseMessage(A.input, {
    theme: Z,
    verbose: G
  }), ")", I.endsWith(" (MCP)") ? bq.default.createElement($, {
    dimColor: !0
  }, " (MCP)") : ""), bq.default.createElement($, {
    dimColor: !0
  }, A.description)), bq.default.createElement(S, {
    flexDirection: "column"
  }, bq.default.createElement(VC, {
    permissionResult: A.permissionResult,
    toolType: "tool"
  }), bq.default.createElement($, null, "Do you want to proceed?"), bq.default.createElement(M0, {
    options: V,
    onChange: W,
    onCancel: () => W("no")
  })))
}
// @from(Start 11915283, End 11915285)
bq
// @from(Start 11915291, End 11915400)
T70 = L(() => {
  hA();
  J5();
  wO();
  xn();
  c5();
  _0();
  F9();
  vn();
  Gg();
  bq = BA(VA(), 1)
})
// @from(Start 11915403, End 11915449)
function Sn5() {
  return Date.now() - zkA()
}
// @from(Start 11915451, End 11915489)
function _n5(A) {
  return Sn5() < A
}
// @from(Start 11915491, End 11915527)
function kn5(A) {
  return !_n5(A)
}
// @from(Start 11915529, End 11915836)
function K31(A, Q) {
  P70.useEffect(() => {
    yn5(), UFA()
  }, []), P70.useEffect(() => {
    let B = !1,
      G = setInterval(() => {
        if (kn5(rf2) && !B) B = !0, E0A({
          message: A,
          notificationType: Q
        })
      }, rf2);
    return () => clearTimeout(G)
  }, [A, Q])
}
// @from(Start 11915841, End 11915844)
P70
// @from(Start 11915846, End 11915856)
rf2 = 6000
// @from(Start 11915860, End 11915863)
yn5
// @from(Start 11915869, End 11915989)
j70 = L(() => {
  h61();
  l2();
  _0();
  jQ();
  P70 = BA(VA(), 1);
  yn5 = s1(() => process.stdin.on("data", UFA))
})
// @from(Start 11916052, End 11917114)
function of2({
  file_path: A,
  content: Q,
  verbose: B
}) {
  let G = D31.useMemo(() => RA().existsSync(A), [A]),
    Z = D31.useMemo(() => {
      if (!G) return "";
      let Y = CH(A);
      return RA().readFileSync(A, {
        encoding: Y
      })
    }, [A, G]),
    I = D31.useMemo(() => {
      if (!G) return null;
      return Uq({
        filePath: A,
        fileContents: Z,
        edits: [{
          old_string: Z,
          new_string: Q,
          replace_all: !1
        }]
      })
    }, [G, A, Z, Q]);
  return fq.createElement(S, {
    borderDimColor: !0,
    borderStyle: "round",
    flexDirection: "column",
    paddingX: 1
  }, fq.createElement(S, {
    paddingBottom: 1
  }, fq.createElement($, {
    bold: !0
  }, B ? A : vn5(W0(), A))), I ? dV(I.map((Y) => fq.createElement(J$, {
    key: Y.newStart,
    patch: Y,
    dim: !1,
    filePath: A
  })), (Y) => fq.createElement($, {
    dimColor: !0,
    key: `ellipsis-${Y}`
  }, "...")) : fq.createElement(CO, {
    code: Q || "(No content)",
    language: xn5(A).slice(1)
  }))
}
// @from(Start 11917119, End 11917121)
fq
// @from(Start 11917123, End 11917126)
D31
// @from(Start 11917132, End 11917245)
tf2 = L(() => {
  En();
  hA();
  U2();
  R9();
  FWA();
  Rh();
  AQ();
  fq = BA(VA(), 1), D31 = BA(VA(), 1)
})
// @from(Start 11917290, End 11918152)
function ef2(A) {
  let Q = (J) => {
      return QV.inputSchema.parse(J)
    },
    B = Q(A.toolUseConfirm.input),
    {
      file_path: G,
      content: Z
    } = B,
    I = x0A.useMemo(() => RA().existsSync(G), [G]),
    Y = I ? "overwrite" : "create";
  return x0A.default.createElement(bn, {
    toolUseConfirm: A.toolUseConfirm,
    toolUseContext: A.toolUseContext,
    onDone: A.onDone,
    onReject: A.onReject,
    title: I ? "Overwrite file" : "Create file",
    question: x0A.default.createElement($, null, "Do you want to ", Y, " ", x0A.default.createElement($, {
      bold: !0
    }, bn5(G)), "?"),
    content: x0A.default.createElement(of2, {
      file_path: G,
      content: Z,
      verbose: A.verbose
    }),
    path: G,
    completionType: "write_file_single",
    languageName: vWA(G),
    parseInput: Q,
    ideDiffSupport: fn5
  })
}
// @from(Start 11918157, End 11918160)
x0A
// @from(Start 11918162, End 11918165)
fn5
// @from(Start 11918171, End 11918564)
Ah2 = L(() => {
  hA();
  rh();
  tf2();
  R9();
  AQ();
  UTA();
  x0A = BA(VA(), 1), fn5 = {
    getConfig: (A) => {
      let B = RA().existsSync(A.file_path) ? _q(A.file_path) : "";
      return J31(A.file_path, B, A.content, !1)
    },
    applyChanges: (A, Q) => {
      let B = Q[0];
      if (B) return {
        ...A,
        content: B.new_string
      };
      return A
    }
  }
})
// @from(Start 11918567, End 11918743)
function hn5(A) {
  let Q = A.tool;
  if ("getPath" in Q && typeof Q.getPath === "function") try {
    return Q.getPath(A.input)
  } catch {
    return null
  }
  return null
}
// @from(Start 11918745, End 11919664)
function Qh2({
  toolUseConfirm: A,
  onDone: Q,
  onReject: B,
  verbose: G,
  toolUseContext: Z
}) {
  let [I] = qB(), Y = hn5(A), J = A.tool.userFacingName(A.input), W = A.tool.isReadOnly(A.input), V = `${W?"Read":"Edit"} file`, F = (D) => D;
  if (!Y) return wTA.default.createElement(F31, {
    toolUseConfirm: A,
    toolUseContext: Z,
    onDone: Q,
    onReject: B,
    verbose: G
  });
  let K = wTA.default.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, wTA.default.createElement($, null, J, "(", A.tool.renderToolUseMessage(A.input, {
    theme: I,
    verbose: G
  }), ")"));
  return wTA.default.createElement(bn, {
    toolUseConfirm: A,
    toolUseContext: Z,
    onDone: Q,
    onReject: B,
    title: V,
    content: K,
    path: Y,
    parseInput: F,
    operationType: W ? "read" : "write",
    completionType: "tool_use_single",
    languageName: "none"
  })
}
// @from(Start 11919669, End 11919672)
wTA
// @from(Start 11919678, End 11919742)
Bh2 = L(() => {
  hA();
  T70();
  UTA();
  wTA = BA(VA(), 1)
})
// @from(Start 11919748, End 11921106)
bWA = z((NJZ, Gh2) => {
  Gh2.exports = v0A;
  v0A.CAPTURING_PHASE = 1;
  v0A.AT_TARGET = 2;
  v0A.BUBBLING_PHASE = 3;

  function v0A(A, Q) {
    if (this.type = "", this.target = null, this.currentTarget = null, this.eventPhase = v0A.AT_TARGET, this.bubbles = !1, this.cancelable = !1, this.isTrusted = !1, this.defaultPrevented = !1, this.timeStamp = Date.now(), this._propagationStopped = !1, this._immediatePropagationStopped = !1, this._initialized = !0, this._dispatching = !1, A) this.type = A;
    if (Q)
      for (var B in Q) this[B] = Q[B]
  }
  v0A.prototype = Object.create(Object.prototype, {
    constructor: {
      value: v0A
    },
    stopPropagation: {
      value: function() {
        this._propagationStopped = !0
      }
    },
    stopImmediatePropagation: {
      value: function() {
        this._propagationStopped = !0, this._immediatePropagationStopped = !0
      }
    },
    preventDefault: {
      value: function() {
        if (this.cancelable) this.defaultPrevented = !0
      }
    },
    initEvent: {
      value: function(Q, B, G) {
        if (this._initialized = !0, this._dispatching) return;
        this._propagationStopped = !1, this._immediatePropagationStopped = !1, this.defaultPrevented = !1, this.isTrusted = !1, this.target = null, this.type = Q, this.bubbles = B, this.cancelable = G
      }
    }
  })
})
// @from(Start 11921112, End 11921489)
_70 = z((LJZ, Ih2) => {
  var Zh2 = bWA();
  Ih2.exports = S70;

  function S70() {
    Zh2.call(this), this.view = null, this.detail = 0
  }
  S70.prototype = Object.create(Zh2.prototype, {
    constructor: {
      value: S70
    },
    initUIEvent: {
      value: function(A, Q, B, G, Z) {
        this.initEvent(A, Q, B), this.view = G, this.detail = Z
      }
    }
  })
})
// @from(Start 11921495, End 11922882)
y70 = z((MJZ, Jh2) => {
  var Yh2 = _70();
  Jh2.exports = k70;

  function k70() {
    Yh2.call(this), this.screenX = this.screenY = this.clientX = this.clientY = 0, this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = !1, this.button = 0, this.buttons = 1, this.relatedTarget = null
  }
  k70.prototype = Object.create(Yh2.prototype, {
    constructor: {
      value: k70
    },
    initMouseEvent: {
      value: function(A, Q, B, G, Z, I, Y, J, W, X, V, F, K, D, H) {
        switch (this.initEvent(A, Q, B, G, Z), this.screenX = I, this.screenY = Y, this.clientX = J, this.clientY = W, this.ctrlKey = X, this.altKey = V, this.shiftKey = F, this.metaKey = K, this.button = D, D) {
          case 0:
            this.buttons = 1;
            break;
          case 1:
            this.buttons = 4;
            break;
          case 2:
            this.buttons = 2;
            break;
          default:
            this.buttons = 0;
            break
        }
        this.relatedTarget = H
      }
    },
    getModifierState: {
      value: function(A) {
        switch (A) {
          case "Alt":
            return this.altKey;
          case "Control":
            return this.ctrlKey;
          case "Shift":
            return this.shiftKey;
          case "Meta":
            return this.metaKey;
          default:
            return !1
        }
      }
    }
  })
})
// @from(Start 11922888, End 11926313)
E31 = z((OJZ, Xh2) => {
  Xh2.exports = C31;
  var gn5 = 1,
    un5 = 3,
    mn5 = 4,
    dn5 = 5,
    cn5 = 7,
    pn5 = 8,
    ln5 = 9,
    in5 = 11,
    nn5 = 12,
    an5 = 13,
    sn5 = 14,
    rn5 = 15,
    on5 = 17,
    tn5 = 18,
    en5 = 19,
    Aa5 = 20,
    Qa5 = 21,
    Ba5 = 22,
    Ga5 = 23,
    Za5 = 24,
    Ia5 = 25,
    Ya5 = [null, "INDEX_SIZE_ERR", null, "HIERARCHY_REQUEST_ERR", "WRONG_DOCUMENT_ERR", "INVALID_CHARACTER_ERR", null, "NO_MODIFICATION_ALLOWED_ERR", "NOT_FOUND_ERR", "NOT_SUPPORTED_ERR", "INUSE_ATTRIBUTE_ERR", "INVALID_STATE_ERR", "SYNTAX_ERR", "INVALID_MODIFICATION_ERR", "NAMESPACE_ERR", "INVALID_ACCESS_ERR", null, "TYPE_MISMATCH_ERR", "SECURITY_ERR", "NETWORK_ERR", "ABORT_ERR", "URL_MISMATCH_ERR", "QUOTA_EXCEEDED_ERR", "TIMEOUT_ERR", "INVALID_NODE_TYPE_ERR", "DATA_CLONE_ERR"],
    Ja5 = [null, "INDEX_SIZE_ERR (1): the index is not in the allowed range", null, "HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model", "WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required", "INVALID_CHARACTER_ERR (5): the string contains invalid characters", null, "NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified", "NOT_FOUND_ERR (8): the object can not be found here", "NOT_SUPPORTED_ERR (9): this operation is not supported", "INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute", "INVALID_STATE_ERR (11): the object is in an invalid state", "SYNTAX_ERR (12): the string did not match the expected pattern", "INVALID_MODIFICATION_ERR (13): the object can not be modified in this way", "NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML", "INVALID_ACCESS_ERR (15): the object does not support the operation or argument", null, "TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type", "SECURITY_ERR (18): the operation is insecure", "NETWORK_ERR (19): a network error occurred", "ABORT_ERR (20): the user aborted an operation", "URL_MISMATCH_ERR (21): the given URL does not match another URL", "QUOTA_EXCEEDED_ERR (22): the quota has been exceeded", "TIMEOUT_ERR (23): a timeout occurred", "INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation", "DATA_CLONE_ERR (25): the object can not be cloned."],
    Wh2 = {
      INDEX_SIZE_ERR: gn5,
      DOMSTRING_SIZE_ERR: 2,
      HIERARCHY_REQUEST_ERR: un5,
      WRONG_DOCUMENT_ERR: mn5,
      INVALID_CHARACTER_ERR: dn5,
      NO_DATA_ALLOWED_ERR: 6,
      NO_MODIFICATION_ALLOWED_ERR: cn5,
      NOT_FOUND_ERR: pn5,
      NOT_SUPPORTED_ERR: ln5,
      INUSE_ATTRIBUTE_ERR: 10,
      INVALID_STATE_ERR: in5,
      SYNTAX_ERR: nn5,
      INVALID_MODIFICATION_ERR: an5,
      NAMESPACE_ERR: sn5,
      INVALID_ACCESS_ERR: rn5,
      VALIDATION_ERR: 16,
      TYPE_MISMATCH_ERR: on5,
      SECURITY_ERR: tn5,
      NETWORK_ERR: en5,
      ABORT_ERR: Aa5,
      URL_MISMATCH_ERR: Qa5,
      QUOTA_EXCEEDED_ERR: Ba5,
      TIMEOUT_ERR: Ga5,
      INVALID_NODE_TYPE_ERR: Za5,
      DATA_CLONE_ERR: Ia5
    };

  function C31(A) {
    Error.call(this), Error.captureStackTrace(this, this.constructor), this.code = A, this.message = Ja5[A], this.name = Ya5[A]
  }
  C31.prototype.__proto__ = Error.prototype;
  for (qTA in Wh2) H31 = {
    value: Wh2[qTA]
  }, Object.defineProperty(C31, qTA, H31), Object.defineProperty(C31.prototype, qTA, H31);
  var H31, qTA
})
// @from(Start 11926319, End 11926392)
z31 = z((Wa5) => {
  Wa5.isApiWritable = !globalThis.__domino_frozen__
})
// @from(Start 11926398, End 11929343)
dJ = z((Fa5) => {
  var mJ = E31(),
    uW = mJ,
    Va5 = z31().isApiWritable;
  Fa5.NAMESPACE = {
    HTML: "http://www.w3.org/1999/xhtml",
    XML: "http://www.w3.org/XML/1998/namespace",
    XMLNS: "http://www.w3.org/2000/xmlns/",
    MATHML: "http://www.w3.org/1998/Math/MathML",
    SVG: "http://www.w3.org/2000/svg",
    XLINK: "http://www.w3.org/1999/xlink"
  };
  Fa5.IndexSizeError = function() {
    throw new mJ(uW.INDEX_SIZE_ERR)
  };
  Fa5.HierarchyRequestError = function() {
    throw new mJ(uW.HIERARCHY_REQUEST_ERR)
  };
  Fa5.WrongDocumentError = function() {
    throw new mJ(uW.WRONG_DOCUMENT_ERR)
  };
  Fa5.InvalidCharacterError = function() {
    throw new mJ(uW.INVALID_CHARACTER_ERR)
  };
  Fa5.NoModificationAllowedError = function() {
    throw new mJ(uW.NO_MODIFICATION_ALLOWED_ERR)
  };
  Fa5.NotFoundError = function() {
    throw new mJ(uW.NOT_FOUND_ERR)
  };
  Fa5.NotSupportedError = function() {
    throw new mJ(uW.NOT_SUPPORTED_ERR)
  };
  Fa5.InvalidStateError = function() {
    throw new mJ(uW.INVALID_STATE_ERR)
  };
  Fa5.SyntaxError = function() {
    throw new mJ(uW.SYNTAX_ERR)
  };
  Fa5.InvalidModificationError = function() {
    throw new mJ(uW.INVALID_MODIFICATION_ERR)
  };
  Fa5.NamespaceError = function() {
    throw new mJ(uW.NAMESPACE_ERR)
  };
  Fa5.InvalidAccessError = function() {
    throw new mJ(uW.INVALID_ACCESS_ERR)
  };
  Fa5.TypeMismatchError = function() {
    throw new mJ(uW.TYPE_MISMATCH_ERR)
  };
  Fa5.SecurityError = function() {
    throw new mJ(uW.SECURITY_ERR)
  };
  Fa5.NetworkError = function() {
    throw new mJ(uW.NETWORK_ERR)
  };
  Fa5.AbortError = function() {
    throw new mJ(uW.ABORT_ERR)
  };
  Fa5.UrlMismatchError = function() {
    throw new mJ(uW.URL_MISMATCH_ERR)
  };
  Fa5.QuotaExceededError = function() {
    throw new mJ(uW.QUOTA_EXCEEDED_ERR)
  };
  Fa5.TimeoutError = function() {
    throw new mJ(uW.TIMEOUT_ERR)
  };
  Fa5.InvalidNodeTypeError = function() {
    throw new mJ(uW.INVALID_NODE_TYPE_ERR)
  };
  Fa5.DataCloneError = function() {
    throw new mJ(uW.DATA_CLONE_ERR)
  };
  Fa5.nyi = function() {
    throw Error("NotYetImplemented")
  };
  Fa5.shouldOverride = function() {
    throw Error("Abstract function; should be overriding in subclass.")
  };
  Fa5.assert = function(A, Q) {
    if (!A) throw Error("Assertion failed: " + (Q || "") + `
` + Error().stack)
  };
  Fa5.expose = function(A, Q) {
    for (var B in A) Object.defineProperty(Q.prototype, B, {
      value: A[B],
      writable: Va5
    })
  };
  Fa5.merge = function(A, Q) {
    for (var B in Q) A[B] = Q[B]
  };
  Fa5.documentOrder = function(A, Q) {
    return 3 - (A.compareDocumentPosition(Q) & 6)
  };
  Fa5.toASCIILowerCase = function(A) {
    return A.replace(/[A-Z]+/g, function(Q) {
      return Q.toLowerCase()
    })
  };
  Fa5.toASCIIUpperCase = function(A) {
    return A.replace(/[a-z]+/g, function(Q) {
      return Q.toUpperCase()
    })
  }
})
// @from(Start 11929349, End 11934530)
x70 = z((PJZ, Fh2) => {
  var b0A = bWA(),
    da5 = y70(),
    ca5 = dJ();
  Fh2.exports = Vh2;

  function Vh2() {}
  Vh2.prototype = {
    addEventListener: function(Q, B, G) {
      if (!B) return;
      if (G === void 0) G = !1;
      if (!this._listeners) this._listeners = Object.create(null);
      if (!this._listeners[Q]) this._listeners[Q] = [];
      var Z = this._listeners[Q];
      for (var I = 0, Y = Z.length; I < Y; I++) {
        var J = Z[I];
        if (J.listener === B && J.capture === G) return
      }
      var W = {
        listener: B,
        capture: G
      };
      if (typeof B === "function") W.f = B;
      Z.push(W)
    },
    removeEventListener: function(Q, B, G) {
      if (G === void 0) G = !1;
      if (this._listeners) {
        var Z = this._listeners[Q];
        if (Z)
          for (var I = 0, Y = Z.length; I < Y; I++) {
            var J = Z[I];
            if (J.listener === B && J.capture === G) {
              if (Z.length === 1) this._listeners[Q] = void 0;
              else Z.splice(I, 1);
              return
            }
          }
      }
    },
    dispatchEvent: function(Q) {
      return this._dispatchEvent(Q, !1)
    },
    _dispatchEvent: function(Q, B) {
      if (typeof B !== "boolean") B = !1;

      function G(X, V) {
        var {
          type: F,
          eventPhase: K
        } = V;
        if (V.currentTarget = X, K !== b0A.CAPTURING_PHASE && X._handlers && X._handlers[F]) {
          var D = X._handlers[F],
            H;
          if (typeof D === "function") H = D.call(V.currentTarget, V);
          else {
            var C = D.handleEvent;
            if (typeof C !== "function") throw TypeError("handleEvent property of event handler object isnot a function.");
            H = C.call(D, V)
          }
          switch (V.type) {
            case "mouseover":
              if (H === !0) V.preventDefault();
              break;
            case "beforeunload":
            default:
              if (H === !1) V.preventDefault();
              break
          }
        }
        var E = X._listeners && X._listeners[F];
        if (!E) return;
        E = E.slice();
        for (var U = 0, q = E.length; U < q; U++) {
          if (V._immediatePropagationStopped) return;
          var w = E[U];
          if (K === b0A.CAPTURING_PHASE && !w.capture || K === b0A.BUBBLING_PHASE && w.capture) continue;
          if (w.f) w.f.call(V.currentTarget, V);
          else {
            var N = w.listener.handleEvent;
            if (typeof N !== "function") throw TypeError("handleEvent property of event listener object is not a function.");
            N.call(w.listener, V)
          }
        }
      }
      if (!Q._initialized || Q._dispatching) ca5.InvalidStateError();
      Q.isTrusted = B, Q._dispatching = !0, Q.target = this;
      var Z = [];
      for (var I = this.parentNode; I; I = I.parentNode) Z.push(I);
      Q.eventPhase = b0A.CAPTURING_PHASE;
      for (var Y = Z.length - 1; Y >= 0; Y--)
        if (G(Z[Y], Q), Q._propagationStopped) break;
      if (!Q._propagationStopped) Q.eventPhase = b0A.AT_TARGET, G(this, Q);
      if (Q.bubbles && !Q._propagationStopped) {
        Q.eventPhase = b0A.BUBBLING_PHASE;
        for (var J = 0, W = Z.length; J < W; J++)
          if (G(Z[J], Q), Q._propagationStopped) break
      }
      if (Q._dispatching = !1, Q.eventPhase = b0A.AT_TARGET, Q.currentTarget = null, B && !Q.defaultPrevented && Q instanceof da5) switch (Q.type) {
        case "mousedown":
          this._armed = {
            x: Q.clientX,
            y: Q.clientY,
            t: Q.timeStamp
          };
          break;
        case "mouseout":
        case "mouseover":
          this._armed = null;
          break;
        case "mouseup":
          if (this._isClick(Q)) this._doClick(Q);
          this._armed = null;
          break
      }
      return !Q.defaultPrevented
    },
    _isClick: function(A) {
      return this._armed !== null && A.type === "mouseup" && A.isTrusted && A.button === 0 && A.timeStamp - this._armed.t < 1000 && Math.abs(A.clientX - this._armed.x) < 10 && Math.abs(A.clientY - this._armed.Y) < 10
    },
    _doClick: function(A) {
      if (this._click_in_progress) return;
      this._click_in_progress = !0;
      var Q = this;
      while (Q && !Q._post_click_activation_steps) Q = Q.parentNode;
      if (Q && Q._pre_click_activation_steps) Q._pre_click_activation_steps();
      var B = this.ownerDocument.createEvent("MouseEvent");
      B.initMouseEvent("click", !0, !0, this.ownerDocument.defaultView, 1, A.screenX, A.screenY, A.clientX, A.clientY, A.ctrlKey, A.altKey, A.shiftKey, A.metaKey, A.button, null);
      var G = this._dispatchEvent(B, !0);
      if (Q) {
        if (G) {
          if (Q._post_click_activation_steps) Q._post_click_activation_steps(B)
        } else if (Q._cancelled_activation_steps) Q._cancelled_activation_steps()
      }
    },
    _setEventHandler: function(Q, B) {
      if (!this._handlers) this._handlers = Object.create(null);
      this._handlers[Q] = B
    },
    _getEventHandler: function(Q) {
      return this._handlers && this._handlers[Q] || null
    }
  }
})
// @from(Start 11934536, End 11935613)
v70 = z((jJZ, Kh2) => {
  var Zg = dJ(),
    qO = Kh2.exports = {
      valid: function(A) {
        return Zg.assert(A, "list falsy"), Zg.assert(A._previousSibling, "previous falsy"), Zg.assert(A._nextSibling, "next falsy"), !0
      },
      insertBefore: function(A, Q) {
        Zg.assert(qO.valid(A) && qO.valid(Q));
        var B = A,
          G = A._previousSibling,
          Z = Q,
          I = Q._previousSibling;
        B._previousSibling = I, G._nextSibling = Z, I._nextSibling = B, Z._previousSibling = G, Zg.assert(qO.valid(A) && qO.valid(Q))
      },
      replace: function(A, Q) {
        if (Zg.assert(qO.valid(A) && (Q === null || qO.valid(Q))), Q !== null) qO.insertBefore(Q, A);
        qO.remove(A), Zg.assert(qO.valid(A) && (Q === null || qO.valid(Q)))
      },
      remove: function(A) {
        Zg.assert(qO.valid(A));
        var Q = A._previousSibling;
        if (Q === A) return;
        var B = A._nextSibling;
        Q._nextSibling = B, B._previousSibling = Q, A._previousSibling = A._nextSibling = A, Zg.assert(qO.valid(A))
      }
    }
})
// @from(Start 11935619, End 11939053)
b70 = z((SJZ, wh2) => {
  wh2.exports = {
    serializeOne: ra5,
    ɵescapeMatchingClosingTag: zh2,
    ɵescapeClosingCommentTag: Uh2,
    ɵescapeProcessingInstructionContent: $h2
  };
  var Eh2 = dJ(),
    f0A = Eh2.NAMESPACE,
    Dh2 = {
      STYLE: !0,
      SCRIPT: !0,
      XMP: !0,
      IFRAME: !0,
      NOEMBED: !0,
      NOFRAMES: !0,
      PLAINTEXT: !0
    },
    pa5 = {
      area: !0,
      base: !0,
      basefont: !0,
      bgsound: !0,
      br: !0,
      col: !0,
      embed: !0,
      frame: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
    },
    la5 = {},
    Hh2 = /[&<>\u00A0]/g,
    Ch2 = /[&"<>\u00A0]/g;

  function ia5(A) {
    if (!Hh2.test(A)) return A;
    return A.replace(Hh2, (Q) => {
      switch (Q) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case " ":
          return "&nbsp;"
      }
    })
  }

  function na5(A) {
    if (!Ch2.test(A)) return A;
    return A.replace(Ch2, (Q) => {
      switch (Q) {
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "&":
          return "&amp;";
        case '"':
          return "&quot;";
        case " ":
          return "&nbsp;"
      }
    })
  }

  function aa5(A) {
    var Q = A.namespaceURI;
    if (!Q) return A.localName;
    if (Q === f0A.XML) return "xml:" + A.localName;
    if (Q === f0A.XLINK) return "xlink:" + A.localName;
    if (Q === f0A.XMLNS)
      if (A.localName === "xmlns") return "xmlns";
      else return "xmlns:" + A.localName;
    return A.name
  }

  function zh2(A, Q) {
    let B = "</" + Q;
    if (!A.toLowerCase().includes(B)) return A;
    let G = [...A],
      Z = A.matchAll(new RegExp(B, "ig"));
    for (let I of Z) G[I.index] = "&lt;";
    return G.join("")
  }
  var sa5 = /--!?>/;

  function Uh2(A) {
    if (!sa5.test(A)) return A;
    return A.replace(/(--\!?)>/g, "$1&gt;")
  }

  function $h2(A) {
    return A.includes(">") ? A.replaceAll(">", "&gt;") : A
  }

  function ra5(A, Q) {
    var B = "";
    switch (A.nodeType) {
      case 1:
        var G = A.namespaceURI,
          Z = G === f0A.HTML,
          I = Z || G === f0A.SVG || G === f0A.MATHML ? A.localName : A.tagName;
        B += "<" + I;
        for (var Y = 0, J = A._numattrs; Y < J; Y++) {
          var W = A._attr(Y);
          if (B += " " + aa5(W), W.value !== void 0) B += '="' + na5(W.value) + '"'
        }
        if (B += ">", !(Z && pa5[I])) {
          var X = A.serialize();
          if (Dh2[I.toUpperCase()]) X = zh2(X, I);
          if (Z && la5[I] && X.charAt(0) === `
`) B += `
`;
          B += X, B += "</" + I + ">"
        }
        break;
      case 3:
      case 4:
        var V;
        if (Q.nodeType === 1 && Q.namespaceURI === f0A.HTML) V = Q.tagName;
        else V = "";
        if (Dh2[V] || V === "NOSCRIPT" && Q.ownerDocument._scripting_enabled) B += A.data;
        else B += ia5(A.data);
        break;
      case 8:
        B += "<!--" + Uh2(A.data) + "-->";
        break;
      case 7:
        let F = $h2(A.data);
        B += "<?" + A.target + " " + F + "?>";
        break;
      case 10:
        B += "<!DOCTYPE " + A.name, B += ">";
        break;
      default:
        Eh2.InvalidStateError()
    }
    return B
  }
})
// @from(Start 11939059, End 11953701)
nD = z((_JZ, Rh2) => {
  Rh2.exports = EY;
  var Oh2 = x70(),
    U31 = v70(),
    qh2 = b70(),
    y7 = dJ();

  function EY() {
    Oh2.call(this), this.parentNode = null, this._nextSibling = this._previousSibling = this, this._index = void 0
  }
  var K$ = EY.ELEMENT_NODE = 1,
    f70 = EY.ATTRIBUTE_NODE = 2,
    $31 = EY.TEXT_NODE = 3,
    oa5 = EY.CDATA_SECTION_NODE = 4,
    ta5 = EY.ENTITY_REFERENCE_NODE = 5,
    h70 = EY.ENTITY_NODE = 6,
    Nh2 = EY.PROCESSING_INSTRUCTION_NODE = 7,
    Lh2 = EY.COMMENT_NODE = 8,
    NTA = EY.DOCUMENT_NODE = 9,
    NO = EY.DOCUMENT_TYPE_NODE = 10,
    hn = EY.DOCUMENT_FRAGMENT_NODE = 11,
    g70 = EY.NOTATION_NODE = 12,
    u70 = EY.DOCUMENT_POSITION_DISCONNECTED = 1,
    m70 = EY.DOCUMENT_POSITION_PRECEDING = 2,
    d70 = EY.DOCUMENT_POSITION_FOLLOWING = 4,
    Mh2 = EY.DOCUMENT_POSITION_CONTAINS = 8,
    c70 = EY.DOCUMENT_POSITION_CONTAINED_BY = 16,
    p70 = EY.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  EY.prototype = Object.create(Oh2.prototype, {
    baseURI: {
      get: y7.nyi
    },
    parentElement: {
      get: function() {
        return this.parentNode && this.parentNode.nodeType === K$ ? this.parentNode : null
      }
    },
    hasChildNodes: {
      value: y7.shouldOverride
    },
    firstChild: {
      get: y7.shouldOverride
    },
    lastChild: {
      get: y7.shouldOverride
    },
    isConnected: {
      get: function() {
        let A = this;
        while (A != null) {
          if (A.nodeType === EY.DOCUMENT_NODE) return !0;
          if (A = A.parentNode, A != null && A.nodeType === EY.DOCUMENT_FRAGMENT_NODE) A = A.host
        }
        return !1
      }
    },
    previousSibling: {
      get: function() {
        var A = this.parentNode;
        if (!A) return null;
        if (this === A.firstChild) return null;
        return this._previousSibling
      }
    },
    nextSibling: {
      get: function() {
        var A = this.parentNode,
          Q = this._nextSibling;
        if (!A) return null;
        if (Q === A.firstChild) return null;
        return Q
      }
    },
    textContent: {
      get: function() {
        return null
      },
      set: function(A) {}
    },
    innerText: {
      get: function() {
        return null
      },
      set: function(A) {}
    },
    _countChildrenOfType: {
      value: function(A) {
        var Q = 0;
        for (var B = this.firstChild; B !== null; B = B.nextSibling)
          if (B.nodeType === A) Q++;
        return Q
      }
    },
    _ensureInsertValid: {
      value: function(Q, B, G) {
        var Z = this,
          I, Y;
        if (!Q.nodeType) throw TypeError("not a node");
        switch (Z.nodeType) {
          case NTA:
          case hn:
          case K$:
            break;
          default:
            y7.HierarchyRequestError()
        }
        if (Q.isAncestor(Z)) y7.HierarchyRequestError();
        if (B !== null || !G) {
          if (B.parentNode !== Z) y7.NotFoundError()
        }
        switch (Q.nodeType) {
          case hn:
          case NO:
          case K$:
          case $31:
          case Nh2:
          case Lh2:
            break;
          default:
            y7.HierarchyRequestError()
        }
        if (Z.nodeType === NTA) switch (Q.nodeType) {
          case $31:
            y7.HierarchyRequestError();
            break;
          case hn:
            if (Q._countChildrenOfType($31) > 0) y7.HierarchyRequestError();
            switch (Q._countChildrenOfType(K$)) {
              case 0:
                break;
              case 1:
                if (B !== null) {
                  if (G && B.nodeType === NO) y7.HierarchyRequestError();
                  for (Y = B.nextSibling; Y !== null; Y = Y.nextSibling)
                    if (Y.nodeType === NO) y7.HierarchyRequestError()
                }
                if (I = Z._countChildrenOfType(K$), G) {
                  if (I > 0) y7.HierarchyRequestError()
                } else if (I > 1 || I === 1 && B.nodeType !== K$) y7.HierarchyRequestError();
                break;
              default:
                y7.HierarchyRequestError()
            }
            break;
          case K$:
            if (B !== null) {
              if (G && B.nodeType === NO) y7.HierarchyRequestError();
              for (Y = B.nextSibling; Y !== null; Y = Y.nextSibling)
                if (Y.nodeType === NO) y7.HierarchyRequestError()
            }
            if (I = Z._countChildrenOfType(K$), G) {
              if (I > 0) y7.HierarchyRequestError()
            } else if (I > 1 || I === 1 && B.nodeType !== K$) y7.HierarchyRequestError();
            break;
          case NO:
            if (B === null) {
              if (Z._countChildrenOfType(K$)) y7.HierarchyRequestError()
            } else
              for (Y = Z.firstChild; Y !== null; Y = Y.nextSibling) {
                if (Y === B) break;
                if (Y.nodeType === K$) y7.HierarchyRequestError()
              }
            if (I = Z._countChildrenOfType(NO), G) {
              if (I > 0) y7.HierarchyRequestError()
            } else if (I > 1 || I === 1 && B.nodeType !== NO) y7.HierarchyRequestError();
            break
        } else if (Q.nodeType === NO) y7.HierarchyRequestError()
      }
    },
    insertBefore: {
      value: function(Q, B) {
        var G = this;
        G._ensureInsertValid(Q, B, !0);
        var Z = B;
        if (Z === Q) Z = Q.nextSibling;
        return G.doc.adoptNode(Q), Q._insertOrReplace(G, Z, !1), Q
      }
    },
    appendChild: {
      value: function(A) {
        return this.insertBefore(A, null)
      }
    },
    _appendChild: {
      value: function(A) {
        A._insertOrReplace(this, null, !1)
      }
    },
    removeChild: {
      value: function(Q) {
        var B = this;
        if (!Q.nodeType) throw TypeError("not a node");
        if (Q.parentNode !== B) y7.NotFoundError();
        return Q.remove(), Q
      }
    },
    replaceChild: {
      value: function(Q, B) {
        var G = this;
        if (G._ensureInsertValid(Q, B, !1), Q.doc !== G.doc) G.doc.adoptNode(Q);
        return Q._insertOrReplace(G, B, !0), B
      }
    },
    contains: {
      value: function(Q) {
        if (Q === null) return !1;
        if (this === Q) return !0;
        return (this.compareDocumentPosition(Q) & c70) !== 0
      }
    },
    compareDocumentPosition: {
      value: function(Q) {
        if (this === Q) return 0;
        if (this.doc !== Q.doc || this.rooted !== Q.rooted) return u70 + p70;
        var B = [],
          G = [];
        for (var Z = this; Z !== null; Z = Z.parentNode) B.push(Z);
        for (Z = Q; Z !== null; Z = Z.parentNode) G.push(Z);
        if (B.reverse(), G.reverse(), B[0] !== G[0]) return u70 + p70;
        Z = Math.min(B.length, G.length);
        for (var I = 1; I < Z; I++)
          if (B[I] !== G[I])
            if (B[I].index < G[I].index) return d70;
            else return m70;
        if (B.length < G.length) return d70 + c70;
        else return m70 + Mh2
      }
    },
    isSameNode: {
      value: function(Q) {
        return this === Q
      }
    },
    isEqualNode: {
      value: function(Q) {
        if (!Q) return !1;
        if (Q.nodeType !== this.nodeType) return !1;
        if (!this.isEqual(Q)) return !1;
        for (var B = this.firstChild, G = Q.firstChild; B && G; B = B.nextSibling, G = G.nextSibling)
          if (!B.isEqualNode(G)) return !1;
        return B === null && G === null
      }
    },
    cloneNode: {
      value: function(A) {
        var Q = this.clone();
        if (A)
          for (var B = this.firstChild; B !== null; B = B.nextSibling) Q._appendChild(B.cloneNode(!0));
        return Q
      }
    },
    lookupPrefix: {
      value: function(Q) {
        var B;
        if (Q === "" || Q === null || Q === void 0) return null;
        switch (this.nodeType) {
          case K$:
            return this._lookupNamespacePrefix(Q, this);
          case NTA:
            return B = this.documentElement, B ? B.lookupPrefix(Q) : null;
          case h70:
          case g70:
          case hn:
          case NO:
            return null;
          case f70:
            return B = this.ownerElement, B ? B.lookupPrefix(Q) : null;
          default:
            return B = this.parentElement, B ? B.lookupPrefix(Q) : null
        }
      }
    },
    lookupNamespaceURI: {
      value: function(Q) {
        if (Q === "" || Q === void 0) Q = null;
        var B;
        switch (this.nodeType) {
          case K$:
            return y7.shouldOverride();
          case NTA:
            return B = this.documentElement, B ? B.lookupNamespaceURI(Q) : null;
          case h70:
          case g70:
          case NO:
          case hn:
            return null;
          case f70:
            return B = this.ownerElement, B ? B.lookupNamespaceURI(Q) : null;
          default:
            return B = this.parentElement, B ? B.lookupNamespaceURI(Q) : null
        }
      }
    },
    isDefaultNamespace: {
      value: function(Q) {
        if (Q === "" || Q === void 0) Q = null;
        var B = this.lookupNamespaceURI(null);
        return B === Q
      }
    },
    index: {
      get: function() {
        var A = this.parentNode;
        if (this === A.firstChild) return 0;
        var Q = A.childNodes;
        if (this._index === void 0 || Q[this._index] !== this) {
          for (var B = 0; B < Q.length; B++) Q[B]._index = B;
          y7.assert(Q[this._index] === this)
        }
        return this._index
      }
    },
    isAncestor: {
      value: function(A) {
        if (this.doc !== A.doc) return !1;
        if (this.rooted !== A.rooted) return !1;
        for (var Q = A; Q; Q = Q.parentNode)
          if (Q === this) return !0;
        return !1
      }
    },
    ensureSameDoc: {
      value: function(A) {
        if (A.ownerDocument === null) A.ownerDocument = this.doc;
        else if (A.ownerDocument !== this.doc) y7.WrongDocumentError()
      }
    },
    removeChildren: {
      value: y7.shouldOverride
    },
    _insertOrReplace: {
      value: function(Q, B, G) {
        var Z = this,
          I, Y;
        if (Z.nodeType === hn && Z.rooted) y7.HierarchyRequestError();
        if (Q._childNodes) {
          if (I = B === null ? Q._childNodes.length : B.index, Z.parentNode === Q) {
            var J = Z.index;
            if (J < I) I--
          }
        }
        if (G) {
          if (B.rooted) B.doc.mutateRemove(B);
          B.parentNode = null
        }
        var W = B;
        if (W === null) W = Q.firstChild;
        var X = Z.rooted && Q.rooted;
        if (Z.nodeType === hn) {
          var V = [0, G ? 1 : 0],
            F;
          for (var K = Z.firstChild; K !== null; K = F) F = K.nextSibling, V.push(K), K.parentNode = Q;
          var D = V.length;
          if (G) U31.replace(W, D > 2 ? V[2] : null);
          else if (D > 2 && W !== null) U31.insertBefore(V[2], W);
          if (Q._childNodes) {
            V[0] = B === null ? Q._childNodes.length : B._index, Q._childNodes.splice.apply(Q._childNodes, V);
            for (Y = 2; Y < D; Y++) V[Y]._index = V[0] + (Y - 2)
          } else if (Q._firstChild === B) {
            if (D > 2) Q._firstChild = V[2];
            else if (G) Q._firstChild = null
          }
          if (Z._childNodes) Z._childNodes.length = 0;
          else Z._firstChild = null;
          if (Q.rooted) {
            Q.modify();
            for (Y = 2; Y < D; Y++) Q.doc.mutateInsert(V[Y])
          }
        } else {
          if (B === Z) return;
          if (X) Z._remove();
          else if (Z.parentNode) Z.remove();
          if (Z.parentNode = Q, G) {
            if (U31.replace(W, Z), Q._childNodes) Z._index = I, Q._childNodes[I] = Z;
            else if (Q._firstChild === B) Q._firstChild = Z
          } else {
            if (W !== null) U31.insertBefore(Z, W);
            if (Q._childNodes) Z._index = I, Q._childNodes.splice(I, 0, Z);
            else if (Q._firstChild === B) Q._firstChild = Z
          }
          if (X) Q.modify(), Q.doc.mutateMove(Z);
          else if (Q.rooted) Q.modify(), Q.doc.mutateInsert(Z)
        }
      }
    },
    lastModTime: {
      get: function() {
        if (!this._lastModTime) this._lastModTime = this.doc.modclock;
        return this._lastModTime
      }
    },
    modify: {
      value: function() {
        if (this.doc.modclock) {
          var A = ++this.doc.modclock;
          for (var Q = this; Q; Q = Q.parentElement)
            if (Q._lastModTime) Q._lastModTime = A
        }
      }
    },
    doc: {
      get: function() {
        return this.ownerDocument || this
      }
    },
    rooted: {
      get: function() {
        return !!this._nid
      }
    },
    normalize: {
      value: function() {
        var A;
        for (var Q = this.firstChild; Q !== null; Q = A) {
          if (A = Q.nextSibling, Q.normalize) Q.normalize();
          if (Q.nodeType !== EY.TEXT_NODE) continue;
          if (Q.nodeValue === "") {
            this.removeChild(Q);
            continue
          }
          var B = Q.previousSibling;
          if (B === null) continue;
          else if (B.nodeType === EY.TEXT_NODE) B.appendData(Q.nodeValue), this.removeChild(Q)
        }
      }
    },
    serialize: {
      value: function() {
        if (this._innerHTML) return this._innerHTML;
        var A = "";
        for (var Q = this.firstChild; Q !== null; Q = Q.nextSibling) A += qh2.serializeOne(Q, this);
        return A
      }
    },
    outerHTML: {
      get: function() {
        return qh2.serializeOne(this, {
          nodeType: 0
        })
      },
      set: y7.nyi
    },
    ELEMENT_NODE: {
      value: K$
    },
    ATTRIBUTE_NODE: {
      value: f70
    },
    TEXT_NODE: {
      value: $31
    },
    CDATA_SECTION_NODE: {
      value: oa5
    },
    ENTITY_REFERENCE_NODE: {
      value: ta5
    },
    ENTITY_NODE: {
      value: h70
    },
    PROCESSING_INSTRUCTION_NODE: {
      value: Nh2
    },
    COMMENT_NODE: {
      value: Lh2
    },
    DOCUMENT_NODE: {
      value: NTA
    },
    DOCUMENT_TYPE_NODE: {
      value: NO
    },
    DOCUMENT_FRAGMENT_NODE: {
      value: hn
    },
    NOTATION_NODE: {
      value: g70
    },
    DOCUMENT_POSITION_DISCONNECTED: {
      value: u70
    },
    DOCUMENT_POSITION_PRECEDING: {
      value: m70
    },
    DOCUMENT_POSITION_FOLLOWING: {
      value: d70
    },
    DOCUMENT_POSITION_CONTAINS: {
      value: Mh2
    },
    DOCUMENT_POSITION_CONTAINED_BY: {
      value: c70
    },
    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: {
      value: p70
    }
  })
})
// @from(Start 11953707, End 11953937)
Ph2 = z((kJZ, Th2) => {
  Th2.exports = class extends Array {
    constructor(Q) {
      super(Q && Q.length || 0);
      if (Q)
        for (var B in Q) this[B] = Q[B]
    }
    item(Q) {
      return this[Q] || null
    }
  }
})
// @from(Start 11953943, End 11954112)
Sh2 = z((yJZ, jh2) => {
  function ea5(A) {
    return this[A] || null
  }

  function As5(A) {
    if (!A) A = [];
    return A.item = ea5, A
  }
  jh2.exports = As5
})
// @from(Start 11954118, End 11954235)
h0A = z((xJZ, _h2) => {
  var l70;
  try {
    l70 = Ph2()
  } catch (A) {
    l70 = Sh2()
  }
  _h2.exports = l70
})
// @from(Start 11954241, End 11955911)
w31 = z((vJZ, xh2) => {
  xh2.exports = yh2;
  var kh2 = nD(),
    Qs5 = h0A();

  function yh2() {
    kh2.call(this), this._firstChild = this._childNodes = null
  }
  yh2.prototype = Object.create(kh2.prototype, {
    hasChildNodes: {
      value: function() {
        if (this._childNodes) return this._childNodes.length > 0;
        return this._firstChild !== null
      }
    },
    childNodes: {
      get: function() {
        return this._ensureChildNodes(), this._childNodes
      }
    },
    firstChild: {
      get: function() {
        if (this._childNodes) return this._childNodes.length === 0 ? null : this._childNodes[0];
        return this._firstChild
      }
    },
    lastChild: {
      get: function() {
        var A = this._childNodes,
          Q;
        if (A) return A.length === 0 ? null : A[A.length - 1];
        if (Q = this._firstChild, Q === null) return null;
        return Q._previousSibling
      }
    },
    _ensureChildNodes: {
      value: function() {
        if (this._childNodes) return;
        var A = this._firstChild,
          Q = A,
          B = this._childNodes = new Qs5;
        if (A)
          do B.push(Q), Q = Q._nextSibling; while (Q !== A);
        this._firstChild = null
      }
    },
    removeChildren: {
      value: function() {
        var Q = this.rooted ? this.ownerDocument : null,
          B = this.firstChild,
          G;
        while (B !== null) {
          if (G = B, B = G.nextSibling, Q) Q.mutateRemove(G);
          G.parentNode = null
        }
        if (this._childNodes) this._childNodes.length = 0;
        else this._firstChild = null;
        this.modify()
      }
    }
  })
})
// @from(Start 11955917, End 11957330)
q31 = z((Vs5) => {
  Vs5.isValidName = Ws5;
  Vs5.isValidQName = Xs5;
  var Bs5 = /^[_:A-Za-z][-.:\w]+$/,
    Gs5 = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/,
    LTA = "_A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�",
    MTA = "-._A-Za-z0-9·À-ÖØ-öø-˿̀-ͽͿ-῿‌‍‿⁀⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�",
    g0A = "[" + LTA + "][" + MTA + "]*",
    i70 = LTA + ":",
    n70 = MTA + ":",
    Zs5 = new RegExp("^[" + i70 + "][" + n70 + "]*$"),
    Is5 = new RegExp("^(" + g0A + "|" + g0A + ":" + g0A + ")$"),
    vh2 = /[\uD800-\uDB7F\uDC00-\uDFFF]/,
    bh2 = /[\uD800-\uDB7F\uDC00-\uDFFF]/g,
    fh2 = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;
  LTA += "\uD800-\uDB7F\uDC00-\uDFFF";
  MTA += "\uD800-\uDB7F\uDC00-\uDFFF";
  g0A = "[" + LTA + "][" + MTA + "]*";
  i70 = LTA + ":";
  n70 = MTA + ":";
  var Ys5 = new RegExp("^[" + i70 + "][" + n70 + "]*$"),
    Js5 = new RegExp("^(" + g0A + "|" + g0A + ":" + g0A + ")$");

  function Ws5(A) {
    if (Bs5.test(A)) return !0;
    if (Zs5.test(A)) return !0;
    if (!vh2.test(A)) return !1;
    if (!Ys5.test(A)) return !1;
    var Q = A.match(bh2),
      B = A.match(fh2);
    return B !== null && 2 * B.length === Q.length
  }

  function Xs5(A) {
    if (Gs5.test(A)) return !0;
    if (Is5.test(A)) return !0;
    if (!vh2.test(A)) return !1;
    if (!Js5.test(A)) return !1;
    var Q = A.match(bh2),
      B = A.match(fh2);
    return B !== null && 2 * B.length === Q.length
  }
})
// @from(Start 11957336, End 11960474)
a70 = z((Hs5) => {
  var hh2 = dJ();
  Hs5.property = function(A) {
    if (Array.isArray(A.type)) {
      var Q = Object.create(null);
      A.type.forEach(function(Z) {
        Q[Z.value || Z] = Z.alias || Z
      });
      var B = A.missing;
      if (B === void 0) B = null;
      var G = A.invalid;
      if (G === void 0) G = B;
      return {
        get: function() {
          var Z = this._getattr(A.name);
          if (Z === null) return B;
          if (Z = Q[Z.toLowerCase()], Z !== void 0) return Z;
          if (G !== null) return G;
          return Z
        },
        set: function(Z) {
          this._setattr(A.name, Z)
        }
      }
    } else if (A.type === Boolean) return {
      get: function() {
        return this.hasAttribute(A.name)
      },
      set: function(Z) {
        if (Z) this._setattr(A.name, "");
        else this.removeAttribute(A.name)
      }
    };
    else if (A.type === Number || A.type === "long" || A.type === "unsigned long" || A.type === "limited unsigned long with fallback") return Ds5(A);
    else if (!A.type || A.type === String) return {
      get: function() {
        return this._getattr(A.name) || ""
      },
      set: function(Z) {
        if (A.treatNullAsEmptyString && Z === null) Z = "";
        this._setattr(A.name, Z)
      }
    };
    else if (typeof A.type === "function") return A.type(A.name, A);
    throw Error("Invalid attribute definition")
  };

  function Ds5(A) {
    var Q;
    if (typeof A.default === "function") Q = A.default;
    else if (typeof A.default === "number") Q = function() {
      return A.default
    };
    else Q = function() {
      hh2.assert(!1, typeof A.default)
    };
    var B = A.type === "unsigned long",
      G = A.type === "long",
      Z = A.type === "limited unsigned long with fallback",
      I = A.min,
      Y = A.max,
      J = A.setmin;
    if (I === void 0) {
      if (B) I = 0;
      if (G) I = -2147483648;
      if (Z) I = 1
    }
    if (Y === void 0) {
      if (B || G || Z) Y = 2147483647
    }
    return {
      get: function() {
        var W = this._getattr(A.name),
          X = A.float ? parseFloat(W) : parseInt(W, 10);
        if (W === null || !isFinite(X) || I !== void 0 && X < I || Y !== void 0 && X > Y) return Q.call(this);
        if (B || G || Z) {
          if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(W)) return Q.call(this);
          X = X | 0
        }
        return X
      },
      set: function(W) {
        if (!A.float) W = Math.floor(W);
        if (J !== void 0 && W < J) hh2.IndexSizeError(A.name + " set to " + W);
        if (B) W = W < 0 || W > 2147483647 ? Q.call(this) : W | 0;
        else if (Z) W = W < 1 || W > 2147483647 ? Q.call(this) : W | 0;
        else if (G) W = W < -2147483648 || W > 2147483647 ? Q.call(this) : W | 0;
        this._setattr(A.name, String(W))
      }
    }
  }
  Hs5.registerChangeHandler = function(A, Q, B) {
    var G = A.prototype;
    if (!Object.prototype.hasOwnProperty.call(G, "_attributeChangeHandlers")) G._attributeChangeHandlers = Object.create(G._attributeChangeHandlers || null);
    G._attributeChangeHandlers[Q] = B
  }
})
// @from(Start 11960480, End 11962024)
mh2 = z((hJZ, uh2) => {
  uh2.exports = gh2;
  var zs5 = nD();

  function gh2(A, Q) {
    this.root = A, this.filter = Q, this.lastModTime = A.lastModTime, this.done = !1, this.cache = [], this.traverse()
  }
  gh2.prototype = Object.create(Object.prototype, {
    length: {
      get: function() {
        if (this.checkcache(), !this.done) this.traverse();
        return this.cache.length
      }
    },
    item: {
      value: function(A) {
        if (this.checkcache(), !this.done && A >= this.cache.length) this.traverse();
        return this.cache[A]
      }
    },
    checkcache: {
      value: function() {
        if (this.lastModTime !== this.root.lastModTime) {
          for (var A = this.cache.length - 1; A >= 0; A--) this[A] = void 0;
          this.cache.length = 0, this.done = !1, this.lastModTime = this.root.lastModTime
        }
      }
    },
    traverse: {
      value: function(A) {
        if (A !== void 0) A++;
        var Q;
        while ((Q = this.next()) !== null)
          if (this[this.cache.length] = Q, this.cache.push(Q), A && this.cache.length === A) return;
        this.done = !0
      }
    },
    next: {
      value: function() {
        var A = this.cache.length === 0 ? this.root : this.cache[this.cache.length - 1],
          Q;
        if (A.nodeType === zs5.DOCUMENT_NODE) Q = A.documentElement;
        else Q = A.nextElement(this.root);
        while (Q) {
          if (this.filter(Q)) return Q;
          Q = Q.nextElement(this.root)
        }
        return null
      }
    }
  })
})
// @from(Start 11962030, End 11965186)
r70 = z((gJZ, ph2) => {
  var s70 = dJ();
  ph2.exports = ch2;

  function ch2(A, Q) {
    this._getString = A, this._setString = Q, this._length = 0, this._lastStringValue = "", this._update()
  }
  Object.defineProperties(ch2.prototype, {
    length: {
      get: function() {
        return this._length
      }
    },
    item: {
      value: function(A) {
        var Q = fWA(this);
        if (A < 0 || A >= Q.length) return null;
        return Q[A]
      }
    },
    contains: {
      value: function(A) {
        A = String(A);
        var Q = fWA(this);
        return Q.indexOf(A) > -1
      }
    },
    add: {
      value: function() {
        var A = fWA(this);
        for (var Q = 0, B = arguments.length; Q < B; Q++) {
          var G = OTA(arguments[Q]);
          if (A.indexOf(G) < 0) A.push(G)
        }
        this._update(A)
      }
    },
    remove: {
      value: function() {
        var A = fWA(this);
        for (var Q = 0, B = arguments.length; Q < B; Q++) {
          var G = OTA(arguments[Q]),
            Z = A.indexOf(G);
          if (Z > -1) A.splice(Z, 1)
        }
        this._update(A)
      }
    },
    toggle: {
      value: function(Q, B) {
        if (Q = OTA(Q), this.contains(Q)) {
          if (B === void 0 || B === !1) return this.remove(Q), !1;
          return !0
        } else {
          if (B === void 0 || B === !0) return this.add(Q), !0;
          return !1
        }
      }
    },
    replace: {
      value: function(Q, B) {
        if (String(B) === "") s70.SyntaxError();
        Q = OTA(Q), B = OTA(B);
        var G = fWA(this),
          Z = G.indexOf(Q);
        if (Z < 0) return !1;
        var I = G.indexOf(B);
        if (I < 0) G[Z] = B;
        else if (Z < I) G[Z] = B, G.splice(I, 1);
        else G.splice(Z, 1);
        return this._update(G), !0
      }
    },
    toString: {
      value: function() {
        return this._getString()
      }
    },
    value: {
      get: function() {
        return this._getString()
      },
      set: function(A) {
        this._setString(A), this._update()
      }
    },
    _update: {
      value: function(A) {
        if (A) dh2(this, A), this._setString(A.join(" ").trim());
        else dh2(this, fWA(this));
        this._lastStringValue = this._getString()
      }
    }
  });

  function dh2(A, Q) {
    var B = A._length,
      G;
    A._length = Q.length;
    for (G = 0; G < Q.length; G++) A[G] = Q[G];
    for (; G < B; G++) A[G] = void 0
  }

  function OTA(A) {
    if (A = String(A), A === "") s70.SyntaxError();
    if (/[ \t\r\n\f]/.test(A)) s70.InvalidCharacterError();
    return A
  }

  function Us5(A) {
    var Q = A._length,
      B = Array(Q);
    for (var G = 0; G < Q; G++) B[G] = A[G];
    return B
  }

  function fWA(A) {
    var Q = A._getString();
    if (Q === A._lastStringValue) return Us5(A);
    var B = Q.replace(/(^[ \t\r\n\f]+)|([ \t\r\n\f]+$)/g, "");
    if (B === "") return [];
    else {
      var G = Object.create(null);
      return B.split(/[ \t\r\n\f]+/g).filter(function(Z) {
        var I = "$" + Z;
        if (G[I]) return !1;
        return G[I] = !0, !0
      })
    }
  }
})
// @from(Start 11965192, End 11982977)
O31 = z((uWA, rh2) => {
  var N31 = Object.create(null, {
      location: {
        get: function() {
          throw Error("window.location is not supported.")
        }
      }
    }),
    $s5 = function(A, Q) {
      return A.compareDocumentPosition(Q)
    },
    ws5 = function(A, Q) {
      return $s5(A, Q) & 2 ? 1 : -1
    },
    M31 = function(A) {
      while ((A = A.nextSibling) && A.nodeType !== 1);
      return A
    },
    gWA = function(A) {
      while ((A = A.previousSibling) && A.nodeType !== 1);
      return A
    },
    qs5 = function(A) {
      if (A = A.firstChild)
        while (A.nodeType !== 1 && (A = A.nextSibling));
      return A
    },
    Ns5 = function(A) {
      if (A = A.lastChild)
        while (A.nodeType !== 1 && (A = A.previousSibling));
      return A
    },
    hWA = function(A) {
      if (!A.parentNode) return !1;
      var Q = A.parentNode.nodeType;
      return Q === 1 || Q === 9
    },
    lh2 = function(A) {
      if (!A) return A;
      var Q = A[0];
      if (Q === '"' || Q === "'") {
        if (A[A.length - 1] === Q) A = A.slice(1, -1);
        else A = A.slice(1);
        return A.replace($4.str_escape, function(B) {
          var G = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(B);
          if (!G) return B.slice(1);
          if (G[2]) return "";
          var Z = parseInt(G[1], 16);
          return String.fromCodePoint ? String.fromCodePoint(Z) : String.fromCharCode(Z)
        })
      } else if ($4.ident.test(A)) return gn(A);
      else return A
    },
    gn = function(A) {
      return A.replace($4.escape, function(Q) {
        var B = /^\\([0-9A-Fa-f]+)/.exec(Q);
        if (!B) return Q[1];
        var G = parseInt(B[1], 16);
        return String.fromCodePoint ? String.fromCodePoint(G) : String.fromCharCode(G)
      })
    },
    Ls5 = function() {
      if (Array.prototype.indexOf) return Array.prototype.indexOf;
      return function(A, Q) {
        var B = this.length;
        while (B--)
          if (this[B] === Q) return B;
        return -1
      }
    }(),
    nh2 = function(A, Q) {
      var B = $4.inside.source.replace(/</g, A).replace(/>/g, Q);
      return new RegExp(B)
    },
    D$ = function(A, Q, B) {
      return A = A.source, A = A.replace(Q, B.source || B), new RegExp(A)
    },
    ih2 = function(A, Q) {
      return A.replace(/^(?:\w+:\/\/|\/+)/, "").replace(/(?:\/+|\/*#.*?)$/, "").split("/", Q).join("/")
    },
    Ms5 = function(A, Q) {
      var B = A.replace(/\s+/g, ""),
        G;
      if (B === "even") B = "2n+0";
      else if (B === "odd") B = "2n+1";
      else if (B.indexOf("n") === -1) B = "0n" + B;
      return G = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(B), {
        group: G[1] === "-" ? -(G[2] || 1) : +(G[2] || 1),
        offset: G[4] ? G[3] === "-" ? -G[4] : +G[4] : 0
      }
    },
    o70 = function(A, Q, B) {
      var G = Ms5(A),
        Z = G.group,
        I = G.offset,
        Y = !B ? qs5 : Ns5,
        J = !B ? M31 : gWA;
      return function(W) {
        if (!hWA(W)) return;
        var X = Y(W.parentNode),
          V = 0;
        while (X) {
          if (Q(X, W)) V++;
          if (X === W) return V -= I, Z && V ? V % Z === 0 && V < 0 === Z < 0 : !V;
          X = J(X)
        }
      }
    },
    HK = {
      "*": function() {
        return function() {
          return !0
        }
      }(),
      type: function(A) {
        return A = A.toLowerCase(),
          function(Q) {
            return Q.nodeName.toLowerCase() === A
          }
      },
      attr: function(A, Q, B, G) {
        return Q = ah2[Q],
          function(Z) {
            var I;
            switch (A) {
              case "for":
                I = Z.htmlFor;
                break;
              case "class":
                if (I = Z.className, I === "" && Z.getAttribute("class") == null) I = null;
                break;
              case "href":
              case "src":
                I = Z.getAttribute(A, 2);
                break;
              case "title":
                I = Z.getAttribute("title") || null;
                break;
              case "id":
              case "lang":
              case "dir":
              case "accessKey":
              case "hidden":
              case "tabIndex":
              case "style":
                if (Z.getAttribute) {
                  I = Z.getAttribute(A);
                  break
                }
              default:
                if (Z.hasAttribute && !Z.hasAttribute(A)) break;
                I = Z[A] != null ? Z[A] : Z.getAttribute && Z.getAttribute(A);
                break
            }
            if (I == null) return;
            if (I = I + "", G) I = I.toLowerCase(), B = B.toLowerCase();
            return Q(I, B)
          }
      },
      ":first-child": function(A) {
        return !gWA(A) && hWA(A)
      },
      ":last-child": function(A) {
        return !M31(A) && hWA(A)
      },
      ":only-child": function(A) {
        return !gWA(A) && !M31(A) && hWA(A)
      },
      ":nth-child": function(A, Q) {
        return o70(A, function() {
          return !0
        }, Q)
      },
      ":nth-last-child": function(A) {
        return HK[":nth-child"](A, !0)
      },
      ":root": function(A) {
        return A.ownerDocument.documentElement === A
      },
      ":empty": function(A) {
        return !A.firstChild
      },
      ":not": function(A) {
        var Q = e70(A);
        return function(B) {
          return !Q(B)
        }
      },
      ":first-of-type": function(A) {
        if (!hWA(A)) return;
        var Q = A.nodeName;
        while (A = gWA(A))
          if (A.nodeName === Q) return;
        return !0
      },
      ":last-of-type": function(A) {
        if (!hWA(A)) return;
        var Q = A.nodeName;
        while (A = M31(A))
          if (A.nodeName === Q) return;
        return !0
      },
      ":only-of-type": function(A) {
        return HK[":first-of-type"](A) && HK[":last-of-type"](A)
      },
      ":nth-of-type": function(A, Q) {
        return o70(A, function(B, G) {
          return B.nodeName === G.nodeName
        }, Q)
      },
      ":nth-last-of-type": function(A) {
        return HK[":nth-of-type"](A, !0)
      },
      ":checked": function(A) {
        return !!(A.checked || A.selected)
      },
      ":indeterminate": function(A) {
        return !HK[":checked"](A)
      },
      ":enabled": function(A) {
        return !A.disabled && A.type !== "hidden"
      },
      ":disabled": function(A) {
        return !!A.disabled
      },
      ":target": function(A) {
        return A.id === N31.location.hash.substring(1)
      },
      ":focus": function(A) {
        return A === A.ownerDocument.activeElement
      },
      ":is": function(A) {
        return e70(A)
      },
      ":matches": function(A) {
        return HK[":is"](A)
      },
      ":nth-match": function(A, Q) {
        var B = A.split(/\s*,\s*/),
          G = B.shift(),
          Z = e70(B.join(","));
        return o70(G, Z, Q)
      },
      ":nth-last-match": function(A) {
        return HK[":nth-match"](A, !0)
      },
      ":links-here": function(A) {
        return A + "" === N31.location + ""
      },
      ":lang": function(A) {
        return function(Q) {
          while (Q) {
            if (Q.lang) return Q.lang.indexOf(A) === 0;
            Q = Q.parentNode
          }
        }
      },
      ":dir": function(A) {
        return function(Q) {
          while (Q) {
            if (Q.dir) return Q.dir === A;
            Q = Q.parentNode
          }
        }
      },
      ":scope": function(A, Q) {
        var B = Q || A.ownerDocument;
        if (B.nodeType === 9) return A === B.documentElement;
        return A === B
      },
      ":any-link": function(A) {
        return typeof A.href === "string"
      },
      ":local-link": function(A) {
        if (A.nodeName) return A.href && A.host === N31.location.host;
        var Q = +A + 1;
        return function(B) {
          if (!B.href) return;
          var G = N31.location + "",
            Z = B + "";
          return ih2(G, Q) === ih2(Z, Q)
        }
      },
      ":default": function(A) {
        return !!A.defaultSelected
      },
      ":valid": function(A) {
        return A.willValidate || A.validity && A.validity.valid
      },
      ":invalid": function(A) {
        return !HK[":valid"](A)
      },
      ":in-range": function(A) {
        return A.value > A.min && A.value <= A.max
      },
      ":out-of-range": function(A) {
        return !HK[":in-range"](A)
      },
      ":required": function(A) {
        return !!A.required
      },
      ":optional": function(A) {
        return !A.required
      },
      ":read-only": function(A) {
        if (A.readOnly) return !0;
        var Q = A.getAttribute("contenteditable"),
          B = A.contentEditable,
          G = A.nodeName.toLowerCase();
        return G = G !== "input" && G !== "textarea", (G || A.disabled) && Q == null && B !== "true"
      },
      ":read-write": function(A) {
        return !HK[":read-only"](A)
      },
      ":hover": function() {
        throw Error(":hover is not supported.")
      },
      ":active": function() {
        throw Error(":active is not supported.")
      },
      ":link": function() {
        throw Error(":link is not supported.")
      },
      ":visited": function() {
        throw Error(":visited is not supported.")
      },
      ":column": function() {
        throw Error(":column is not supported.")
      },
      ":nth-column": function() {
        throw Error(":nth-column is not supported.")
      },
      ":nth-last-column": function() {
        throw Error(":nth-last-column is not supported.")
      },
      ":current": function() {
        throw Error(":current is not supported.")
      },
      ":past": function() {
        throw Error(":past is not supported.")
      },
      ":future": function() {
        throw Error(":future is not supported.")
      },
      ":contains": function(A) {
        return function(Q) {
          var B = Q.innerText || Q.textContent || Q.value || "";
          return B.indexOf(A) !== -1
        }
      },
      ":has": function(A) {
        return function(Q) {
          return sh2(A, Q).length > 0
        }
      }
    },
    ah2 = {
      "-": function() {
        return !0
      },
      "=": function(A, Q) {
        return A === Q
      },
      "*=": function(A, Q) {
        return A.indexOf(Q) !== -1
      },
      "~=": function(A, Q) {
        var B, G, Z, I;
        for (G = 0;; G = B + 1) {
          if (B = A.indexOf(Q, G), B === -1) return !1;
          if (Z = A[B - 1], I = A[B + Q.length], (!Z || Z === " ") && (!I || I === " ")) return !0
        }
      },
      "|=": function(A, Q) {
        var B = A.indexOf(Q),
          G;
        if (B !== 0) return;
        return G = A[B + Q.length], G === "-" || !G
      },
      "^=": function(A, Q) {
        return A.indexOf(Q) === 0
      },
      "$=": function(A, Q) {
        var B = A.lastIndexOf(Q);
        return B !== -1 && B + Q.length === A.length
      },
      "!=": function(A, Q) {
        return A !== Q
      }
    },
    RTA = {
      " ": function(A) {
        return function(Q) {
          while (Q = Q.parentNode)
            if (A(Q)) return Q
        }
      },
      ">": function(A) {
        return function(Q) {
          if (Q = Q.parentNode) return A(Q) && Q
        }
      },
      "+": function(A) {
        return function(Q) {
          if (Q = gWA(Q)) return A(Q) && Q
        }
      },
      "~": function(A) {
        return function(Q) {
          while (Q = gWA(Q))
            if (A(Q)) return Q
        }
      },
      noop: function(A) {
        return function(Q) {
          return A(Q) && Q
        }
      },
      ref: function(A, Q) {
        var B;

        function G(Z) {
          var I = Z.ownerDocument,
            Y = I.getElementsByTagName("*"),
            J = Y.length;
          while (J--)
            if (B = Y[J], G.test(Z)) return B = null, !0;
          B = null
        }
        return G.combinator = function(Z) {
          if (!B || !B.getAttribute) return;
          var I = B.getAttribute(Q) || "";
          if (I[0] === "#") I = I.substring(1);
          if (I === Z.id && A(B)) return B
        }, G
      }
    },
    $4 = {
      escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
      str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
      nonascii: /[\u00A0-\uFFFF]/,
      cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
      qname: /^ *(cssid|\*)/,
      simple: /^(?:([.#]cssid)|pseudo|attr)/,
      ref: /^ *\/(cssid)\/ */,
      combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
      attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
      pseudo: /^(:cssid)(?:\((inside)\))?/,
      inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
      ident: /^(cssid)$/
    };
  $4.cssid = D$($4.cssid, "nonascii", $4.nonascii);
  $4.cssid = D$($4.cssid, "escape", $4.escape);
  $4.qname = D$($4.qname, "cssid", $4.cssid);
  $4.simple = D$($4.simple, "cssid", $4.cssid);
  $4.ref = D$($4.ref, "cssid", $4.cssid);
  $4.attr = D$($4.attr, "cssid", $4.cssid);
  $4.pseudo = D$($4.pseudo, "cssid", $4.cssid);
  $4.inside = D$($4.inside, `[^"'>]*`, $4.inside);
  $4.attr = D$($4.attr, "inside", nh2("\\[", "\\]"));
  $4.pseudo = D$($4.pseudo, "inside", nh2("\\(", "\\)"));
  $4.simple = D$($4.simple, "pseudo", $4.pseudo);
  $4.simple = D$($4.simple, "attr", $4.attr);
  $4.ident = D$($4.ident, "cssid", $4.cssid);
  $4.str_escape = D$($4.str_escape, "escape", $4.escape);
  var TTA = function(A) {
      var Q = A.replace(/^\s+|\s+$/g, ""),
        B, G = [],
        Z = [],
        I, Y, J, W, X;
      while (Q) {
        if (J = $4.qname.exec(Q)) Q = Q.substring(J[0].length), Y = gn(J[1]), Z.push(L31(Y, !0));
        else if (J = $4.simple.exec(Q)) Q = Q.substring(J[0].length), Y = "*", Z.push(L31(Y, !0)), Z.push(L31(J));
        else throw SyntaxError("Invalid selector.");
        while (J = $4.simple.exec(Q)) Q = Q.substring(J[0].length), Z.push(L31(J));
        if (Q[0] === "!") Q = Q.substring(1), I = Rs5(), I.qname = Y, Z.push(I.simple);
        if (J = $4.ref.exec(Q)) {
          Q = Q.substring(J[0].length), X = RTA.ref(t70(Z), gn(J[1])), G.push(X.combinator), Z = [];
          continue
        }
        if (J = $4.combinator.exec(Q)) {
          if (Q = Q.substring(J[0].length), W = J[1] || J[2] || J[3], W === ",") {
            G.push(RTA.noop(t70(Z)));
            break
          }
        } else W = "noop";
        if (!RTA[W]) throw SyntaxError("Bad combinator.");
        G.push(RTA[W](t70(Z))), Z = []
      }
      if (B = Os5(G), B.qname = Y, B.sel = Q, I) I.lname = B.qname, I.test = B, I.qname = I.qname, I.sel = B.sel, B = I;
      if (X) X.test = B, X.qname = B.qname, X.sel = B.sel, B = X;
      return B
    },
    L31 = function(A, Q) {
      if (Q) return A === "*" ? HK["*"] : HK.type(A);
      if (A[1]) return A[1][0] === "." ? HK.attr("class", "~=", gn(A[1].substring(1)), !1) : HK.attr("id", "=", gn(A[1].substring(1)), !1);
      if (A[2]) return A[3] ? HK[gn(A[2])](lh2(A[3])) : HK[gn(A[2])];
      if (A[4]) {
        var B = A[6],
          G = /["'\s]\s*I$/i.test(B);
        if (G) B = B.replace(/\s*I$/i, "");
        return HK.attr(gn(A[4]), A[5] || "-", lh2(B), G)
      }
      throw SyntaxError("Unknown Selector.")
    },
    t70 = function(A) {
      var Q = A.length,
        B;
      if (Q < 2) return A[0];
      return function(G) {
        if (!G) return;
        for (B = 0; B < Q; B++)
          if (!A[B](G)) return;
        return !0
      }
    },
    Os5 = function(A) {
      if (A.length < 2) return function(Q) {
        return !!A[0](Q)
      };
      return function(Q) {
        var B = A.length;
        while (B--)
          if (!(Q = A[B](Q))) return;
        return !0
      }
    },
    Rs5 = function() {
      var A;

      function Q(B) {
        var G = B.ownerDocument,
          Z = G.getElementsByTagName(Q.lname),
          I = Z.length;
        while (I--)
          if (Q.test(Z[I]) && A === B) return A = null, !0;
        A = null
      }
      return Q.simple = function(B) {
        return A = B, !0
      }, Q
    },
    e70 = function(A) {
      var Q = TTA(A),
        B = [Q];
      while (Q.sel) Q = TTA(Q.sel), B.push(Q);
      if (B.length < 2) return Q;
      return function(G) {
        var Z = B.length,
          I = 0;
        for (; I < Z; I++)
          if (B[I](G)) return !0
      }
    },
    sh2 = function(A, Q) {
      var B = [],
        G = TTA(A),
        Z = Q.getElementsByTagName(G.qname),
        I = 0,
        Y;
      while (Y = Z[I++])
        if (G(Y)) B.push(Y);
      if (G.sel) {
        while (G.sel) {
          G = TTA(G.sel), Z = Q.getElementsByTagName(G.qname), I = 0;
          while (Y = Z[I++])
            if (G(Y) && Ls5.call(B, Y) === -1) B.push(Y)
        }
        B.sort(ws5)
      }
      return B
    };
  rh2.exports = uWA = function(A, Q) {
    var B, G;
    if (Q.nodeType !== 11 && A.indexOf(" ") === -1) {
      if (A[0] === "#" && Q.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(A)) {
        if (Q.doc._hasMultipleElementsWithId) {
          if (B = A.substring(1), !Q.doc._hasMultipleElementsWithId(B)) return G = Q.doc.getElementById(B), G ? [G] : []
        }
      }
      if (A[0] === "." && /^\.\w+$/.test(A)) return Q.getElementsByClassName(A.substring(1));
      if (/^\w+$/.test(A)) return Q.getElementsByTagName(A)
    }
    return sh2(A, Q)
  };
  uWA.selectors = HK;
  uWA.operators = ah2;
  uWA.combinators = RTA;
  uWA.matches = function(A, Q) {
    var B = {
      sel: Q
    };
    do
      if (B = TTA(B.sel), B(A)) return !0; while (B.sel);
    return !1
  }
})
// @from(Start 11982983, End 11985345)
R31 = z((uJZ, oh2) => {
  var Ts5 = nD(),
    Ps5 = v70(),
    AG0 = function(A, Q) {
      var B = A.createDocumentFragment();
      for (var G = 0; G < Q.length; G++) {
        var Z = Q[G],
          I = Z instanceof Ts5;
        B.appendChild(I ? Z : A.createTextNode(String(Z)))
      }
      return B
    },
    js5 = {
      after: {
        value: function() {
          var Q = Array.prototype.slice.call(arguments),
            B = this.parentNode,
            G = this.nextSibling;
          if (B === null) return;
          while (G && Q.some(function(I) {
              return I === G
            })) G = G.nextSibling;
          var Z = AG0(this.doc, Q);
          B.insertBefore(Z, G)
        }
      },
      before: {
        value: function() {
          var Q = Array.prototype.slice.call(arguments),
            B = this.parentNode,
            G = this.previousSibling;
          if (B === null) return;
          while (G && Q.some(function(Y) {
              return Y === G
            })) G = G.previousSibling;
          var Z = AG0(this.doc, Q),
            I = G ? G.nextSibling : B.firstChild;
          B.insertBefore(Z, I)
        }
      },
      remove: {
        value: function() {
          if (this.parentNode === null) return;
          if (this.doc) {
            if (this.doc._preremoveNodeIterators(this), this.rooted) this.doc.mutateRemove(this)
          }
          this._remove(), this.parentNode = null
        }
      },
      _remove: {
        value: function() {
          var Q = this.parentNode;
          if (Q === null) return;
          if (Q._childNodes) Q._childNodes.splice(this.index, 1);
          else if (Q._firstChild === this)
            if (this._nextSibling === this) Q._firstChild = null;
            else Q._firstChild = this._nextSibling;
          Ps5.remove(this), Q.modify()
        }
      },
      replaceWith: {
        value: function() {
          var Q = Array.prototype.slice.call(arguments),
            B = this.parentNode,
            G = this.nextSibling;
          if (B === null) return;
          while (G && Q.some(function(I) {
              return I === G
            })) G = G.nextSibling;
          var Z = AG0(this.doc, Q);
          if (this.parentNode === B) B.replaceChild(Z, this);
          else B.insertBefore(Z, G)
        }
      }
    };
  oh2.exports = js5
})
// @from(Start 11985351, End 11985993)
QG0 = z((mJZ, eh2) => {
  var th2 = nD(),
    Ss5 = {
      nextElementSibling: {
        get: function() {
          if (this.parentNode) {
            for (var A = this.nextSibling; A !== null; A = A.nextSibling)
              if (A.nodeType === th2.ELEMENT_NODE) return A
          }
          return null
        }
      },
      previousElementSibling: {
        get: function() {
          if (this.parentNode) {
            for (var A = this.previousSibling; A !== null; A = A.previousSibling)
              if (A.nodeType === th2.ELEMENT_NODE) return A
          }
          return null
        }
      }
    };
  eh2.exports = Ss5
})
// @from(Start 11985999, End 11987004)
BG0 = z((dJZ, Qg2) => {
  Qg2.exports = Ag2;
  var mWA = dJ();

  function Ag2(A) {
    this.element = A
  }
  Object.defineProperties(Ag2.prototype, {
    length: {
      get: mWA.shouldOverride
    },
    item: {
      value: mWA.shouldOverride
    },
    getNamedItem: {
      value: function(Q) {
        return this.element.getAttributeNode(Q)
      }
    },
    getNamedItemNS: {
      value: function(Q, B) {
        return this.element.getAttributeNodeNS(Q, B)
      }
    },
    setNamedItem: {
      value: mWA.nyi
    },
    setNamedItemNS: {
      value: mWA.nyi
    },
    removeNamedItem: {
      value: function(Q) {
        var B = this.element.getAttributeNode(Q);
        if (B) return this.element.removeAttribute(Q), B;
        mWA.NotFoundError()
      }
    },
    removeNamedItemNS: {
      value: function(Q, B) {
        var G = this.element.getAttributeNodeNS(Q, B);
        if (G) return this.element.removeAttributeNS(Q, B), G;
        mWA.NotFoundError()
      }
    }
  })
})
// @from(Start 12286070, End 12287879)
hTA = z((zWZ, ou2) => {
  ou2.exports = ru2;
  var au2 = b31(),
    su2 = h31(),
    Qo5 = l31(),
    i31 = dJ(),
    Bo5 = q31();

  function ru2(A) {
    this.contextObject = A
  }
  var Go5 = {
    xml: {
      "": !0,
      "1.0": !0,
      "2.0": !0
    },
    core: {
      "": !0,
      "2.0": !0
    },
    html: {
      "": !0,
      "1.0": !0,
      "2.0": !0
    },
    xhtml: {
      "": !0,
      "1.0": !0,
      "2.0": !0
    }
  };
  ru2.prototype = {
    hasFeature: function(Q, B) {
      var G = Go5[(Q || "").toLowerCase()];
      return G && G[B || ""] || !1
    },
    createDocumentType: function(Q, B, G) {
      if (!Bo5.isValidQName(Q)) i31.InvalidCharacterError();
      return new su2(this.contextObject, Q, B, G)
    },
    createDocument: function(Q, B, G) {
      var Z = new au2(!1, null),
        I;
      if (B) I = Z.createElementNS(Q, B);
      else I = null;
      if (G) Z.appendChild(G);
      if (I) Z.appendChild(I);
      if (Q === i31.NAMESPACE.HTML) Z._contentType = "application/xhtml+xml";
      else if (Q === i31.NAMESPACE.SVG) Z._contentType = "image/svg+xml";
      else Z._contentType = "application/xml";
      return Z
    },
    createHTMLDocument: function(Q) {
      var B = new au2(!0, null);
      B.appendChild(new su2(B, "html"));
      var G = B.createElement("html");
      B.appendChild(G);
      var Z = B.createElement("head");
      if (G.appendChild(Z), Q !== void 0) {
        var I = B.createElement("title");
        Z.appendChild(I), I.appendChild(B.createTextNode(Q))
      }
      return G.appendChild(B.createElement("body")), B.modclock = 1, B
    },
    mozSetOutputMutationHandler: function(A, Q) {
      A.mutationHandler = Q
    },
    mozGetInputMutationHandler: function(A) {
      i31.nyi()
    },
    mozHTMLParser: Qo5
  }
})
// @from(Start 12287885, End 12288655)
eu2 = z((UWZ, tu2) => {
  var Zo5 = _31(),
    Io5 = TG0();
  tu2.exports = mG0;

  function mG0(A, Q) {
    this._window = A, this._href = Q
  }
  mG0.prototype = Object.create(Io5.prototype, {
    constructor: {
      value: mG0
    },
    href: {
      get: function() {
        return this._href
      },
      set: function(A) {
        this.assign(A)
      }
    },
    assign: {
      value: function(A) {
        var Q = new Zo5(this._href),
          B = Q.resolve(A);
        this._href = B
      }
    },
    replace: {
      value: function(A) {
        this.assign(A)
      }
    },
    reload: {
      value: function() {
        this.assign(this.href)
      }
    },
    toString: {
      value: function() {
        return this.href
      }
    }
  })
})
// @from(Start 12288661, End 12289212)
Qm2 = z(($WZ, Am2) => {
  var Yo5 = Object.create(null, {
    appCodeName: {
      value: "Mozilla"
    },
    appName: {
      value: "Netscape"
    },
    appVersion: {
      value: "4.0"
    },
    platform: {
      value: ""
    },
    product: {
      value: "Gecko"
    },
    productSub: {
      value: "20100101"
    },
    userAgent: {
      value: ""
    },
    vendor: {
      value: ""
    },
    vendorSub: {
      value: ""
    },
    taintEnabled: {
      value: function() {
        return !1
      }
    }
  });
  Am2.exports = Yo5
})
// @from(Start 12289218, End 12289352)
Gm2 = z((wWZ, Bm2) => {
  var Jo5 = {
    setTimeout,
    clearTimeout,
    setInterval,
    clearInterval
  };
  Bm2.exports = Jo5
})
// @from(Start 12289358, End 12289953)
cG0 = z((gTA, Zm2) => {
  var dG0 = dJ();
  gTA = Zm2.exports = {
    CSSStyleDeclaration: k31(),
    CharacterData: jTA(),
    Comment: DG0(),
    DOMException: E31(),
    DOMImplementation: hTA(),
    DOMTokenList: r70(),
    Document: b31(),
    DocumentFragment: CG0(),
    DocumentType: h31(),
    Element: cWA(),
    HTMLParser: l31(),
    NamedNodeMap: BG0(),
    Node: nD(),
    NodeList: h0A(),
    NodeFilter: yTA(),
    ProcessingInstruction: zG0(),
    Text: FG0(),
    Window: pG0()
  };
  dG0.merge(gTA, RG0());
  dG0.merge(gTA, x31().elements);
  dG0.merge(gTA, kG0().elements)
})
// @from(Start 12289959, End 12291354)
pG0 = z((qWZ, Im2) => {
  var Wo5 = hTA(),
    Xo5 = x70(),
    Vo5 = eu2(),
    uTA = dJ();
  Im2.exports = n31;

  function n31(A) {
    this.document = A || new Wo5(null).createHTMLDocument(""), this.document._scripting_enabled = !0, this.document.defaultView = this, this.location = new Vo5(this, this.document._address || "about:blank")
  }
  n31.prototype = Object.create(Xo5.prototype, {
    console: {
      value: console
    },
    history: {
      value: {
        back: uTA.nyi,
        forward: uTA.nyi,
        go: uTA.nyi
      }
    },
    navigator: {
      value: Qm2()
    },
    window: {
      get: function() {
        return this
      }
    },
    self: {
      get: function() {
        return this
      }
    },
    frames: {
      get: function() {
        return this
      }
    },
    parent: {
      get: function() {
        return this
      }
    },
    top: {
      get: function() {
        return this
      }
    },
    length: {
      value: 0
    },
    frameElement: {
      value: null
    },
    opener: {
      value: null
    },
    onload: {
      get: function() {
        return this._getEventHandler("load")
      },
      set: function(A) {
        this._setEventHandler("load", A)
      }
    },
    getComputedStyle: {
      value: function(Q) {
        return Q.style
      }
    }
  });
  uTA.expose(Gm2(), n31);
  uTA.expose(cG0(), n31)
})
// @from(Start 12291360, End 12292335)
Vm2 = z((Fo5) => {
  var Ym2 = hTA(),
    Jm2 = l31(),
    NWZ = pG0(),
    Wm2 = cG0();
  Fo5.createDOMImplementation = function() {
    return new Ym2(null)
  };
  Fo5.createDocument = function(A, Q) {
    if (A || Q) {
      var B = new Jm2;
      return B.parse(A || "", !0), B.document()
    }
    return new Ym2(null).createHTMLDocument("")
  };
  Fo5.createIncrementalHTMLParser = function() {
    var A = new Jm2;
    return {
      write: function(Q) {
        if (Q.length > 0) A.parse(Q, !1, function() {
          return !0
        })
      },
      end: function(Q) {
        A.parse(Q || "", !0, function() {
          return !0
        })
      },
      process: function(Q) {
        return A.parse("", !1, Q)
      },
      document: function() {
        return A.document()
      }
    }
  };
  Fo5.createWindow = function(A, Q) {
    var B = Fo5.createDocument(A);
    if (Q !== void 0) B._address = Q;
    return new Wm2.Window(B)
  };
  Fo5.impl = Wm2
})
// @from(Start 12292341, End 12307409)
Nm2 = z((MWZ, qm2) => {
  function Eo5(A) {
    for (var Q = 1; Q < arguments.length; Q++) {
      var B = arguments[Q];
      for (var G in B)
        if (B.hasOwnProperty(G)) A[G] = B[G]
    }
    return A
  }

  function aG0(A, Q) {
    return Array(Q + 1).join(A)
  }

  function zo5(A) {
    return A.replace(/^\n*/, "")
  }

  function Uo5(A) {
    var Q = A.length;
    while (Q > 0 && A[Q - 1] === `
`) Q--;
    return A.substring(0, Q)
  }
  var $o5 = ["ADDRESS", "ARTICLE", "ASIDE", "AUDIO", "BLOCKQUOTE", "BODY", "CANVAS", "CENTER", "DD", "DIR", "DIV", "DL", "DT", "FIELDSET", "FIGCAPTION", "FIGURE", "FOOTER", "FORM", "FRAMESET", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "HTML", "ISINDEX", "LI", "MAIN", "MENU", "NAV", "NOFRAMES", "NOSCRIPT", "OL", "OUTPUT", "P", "PRE", "SECTION", "TABLE", "TBODY", "TD", "TFOOT", "TH", "THEAD", "TR", "UL"];

  function sG0(A) {
    return rG0(A, $o5)
  }
  var Dm2 = ["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"];

  function Hm2(A) {
    return rG0(A, Dm2)
  }

  function wo5(A) {
    return Em2(A, Dm2)
  }
  var Cm2 = ["A", "TABLE", "THEAD", "TBODY", "TFOOT", "TH", "TD", "IFRAME", "SCRIPT", "AUDIO", "VIDEO"];

  function qo5(A) {
    return rG0(A, Cm2)
  }

  function No5(A) {
    return Em2(A, Cm2)
  }

  function rG0(A, Q) {
    return Q.indexOf(A.nodeName) >= 0
  }

  function Em2(A, Q) {
    return A.getElementsByTagName && Q.some(function(B) {
      return A.getElementsByTagName(B).length
    })
  }
  var HC = {};
  HC.paragraph = {
    filter: "p",
    replacement: function(A) {
      return `

` + A + `

`
    }
  };
  HC.lineBreak = {
    filter: "br",
    replacement: function(A, Q, B) {
      return B.br + `
`
    }
  };
  HC.heading = {
    filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
    replacement: function(A, Q, B) {
      var G = Number(Q.nodeName.charAt(1));
      if (B.headingStyle === "setext" && G < 3) {
        var Z = aG0(G === 1 ? "=" : "-", A.length);
        return `

` + A + `
` + Z + `

`
      } else return `

` + aG0("#", G) + " " + A + `

`
    }
  };
  HC.blockquote = {
    filter: "blockquote",
    replacement: function(A) {
      return A = A.replace(/^\n+|\n+$/g, ""), A = A.replace(/^/gm, "> "), `

` + A + `

`
    }
  };
  HC.list = {
    filter: ["ul", "ol"],
    replacement: function(A, Q) {
      var B = Q.parentNode;
      if (B.nodeName === "LI" && B.lastElementChild === Q) return `
` + A;
      else return `

` + A + `

`
    }
  };
  HC.listItem = {
    filter: "li",
    replacement: function(A, Q, B) {
      A = A.replace(/^\n+/, "").replace(/\n+$/, `
`).replace(/\n/gm, `
    `);
      var G = B.bulletListMarker + "   ",
        Z = Q.parentNode;
      if (Z.nodeName === "OL") {
        var I = Z.getAttribute("start"),
          Y = Array.prototype.indexOf.call(Z.children, Q);
        G = (I ? Number(I) + Y : Y + 1) + ".  "
      }
      return G + A + (Q.nextSibling && !/\n$/.test(A) ? `
` : "")
    }
  };
  HC.indentedCodeBlock = {
    filter: function(A, Q) {
      return Q.codeBlockStyle === "indented" && A.nodeName === "PRE" && A.firstChild && A.firstChild.nodeName === "CODE"
    },
    replacement: function(A, Q, B) {
      return `

    ` + Q.firstChild.textContent.replace(/\n/g, `
    `) + `

`
    }
  };
  HC.fencedCodeBlock = {
    filter: function(A, Q) {
      return Q.codeBlockStyle === "fenced" && A.nodeName === "PRE" && A.firstChild && A.firstChild.nodeName === "CODE"
    },
    replacement: function(A, Q, B) {
      var G = Q.firstChild.getAttribute("class") || "",
        Z = (G.match(/language-(\S+)/) || [null, ""])[1],
        I = Q.firstChild.textContent,
        Y = B.fence.charAt(0),
        J = 3,
        W = new RegExp("^" + Y + "{3,}", "gm"),
        X;
      while (X = W.exec(I))
        if (X[0].length >= J) J = X[0].length + 1;
      var V = aG0(Y, J);
      return `

` + V + Z + `
` + I.replace(/\n$/, "") + `
` + V + `

`
    }
  };
  HC.horizontalRule = {
    filter: "hr",
    replacement: function(A, Q, B) {
      return `

` + B.hr + `

`
    }
  };
  HC.inlineLink = {
    filter: function(A, Q) {
      return Q.linkStyle === "inlined" && A.nodeName === "A" && A.getAttribute("href")
    },
    replacement: function(A, Q) {
      var B = Q.getAttribute("href");
      if (B) B = B.replace(/([()])/g, "\\$1");
      var G = a31(Q.getAttribute("title"));
      if (G) G = ' "' + G.replace(/"/g, "\\\"") + '"';
      return "[" + A + "](" + B + G + ")"
    }
  };
  HC.referenceLink = {
    filter: function(A, Q) {
      return Q.linkStyle === "referenced" && A.nodeName === "A" && A.getAttribute("href")
    },
    replacement: function(A, Q, B) {
      var G = Q.getAttribute("href"),
        Z = a31(Q.getAttribute("title"));
      if (Z) Z = ' "' + Z + '"';
      var I, Y;
      switch (B.linkReferenceStyle) {
        case "collapsed":
          I = "[" + A + "][]", Y = "[" + A + "]: " + G + Z;
          break;
        case "shortcut":
          I = "[" + A + "]", Y = "[" + A + "]: " + G + Z;
          break;
        default:
          var J = this.references.length + 1;
          I = "[" + A + "][" + J + "]", Y = "[" + J + "]: " + G + Z
      }
      return this.references.push(Y), I
    },
    references: [],
    append: function(A) {
      var Q = "";
      if (this.references.length) Q = `

` + this.references.join(`
`) + `

`, this.references = [];
      return Q
    }
  };
  HC.emphasis = {
    filter: ["em", "i"],
    replacement: function(A, Q, B) {
      if (!A.trim()) return "";
      return B.emDelimiter + A + B.emDelimiter
    }
  };
  HC.strong = {
    filter: ["strong", "b"],
    replacement: function(A, Q, B) {
      if (!A.trim()) return "";
      return B.strongDelimiter + A + B.strongDelimiter
    }
  };
  HC.code = {
    filter: function(A) {
      var Q = A.previousSibling || A.nextSibling,
        B = A.parentNode.nodeName === "PRE" && !Q;
      return A.nodeName === "CODE" && !B
    },
    replacement: function(A) {
      if (!A) return "";
      A = A.replace(/\r?\n|\r/g, " ");
      var Q = /^`|^ .*?[^ ].* $|`$/.test(A) ? " " : "",
        B = "`",
        G = A.match(/`+/gm) || [];
      while (G.indexOf(B) !== -1) B = B + "`";
      return B + Q + A + Q + B
    }
  };
  HC.image = {
    filter: "img",
    replacement: function(A, Q) {
      var B = a31(Q.getAttribute("alt")),
        G = Q.getAttribute("src") || "",
        Z = a31(Q.getAttribute("title")),
        I = Z ? ' "' + Z + '"' : "";
      return G ? "![" + B + "](" + G + I + ")" : ""
    }
  };

  function a31(A) {
    return A ? A.replace(/(\n+\s*)+/g, `
`) : ""
  }

  function zm2(A) {
    this.options = A, this._keep = [], this._remove = [], this.blankRule = {
      replacement: A.blankReplacement
    }, this.keepReplacement = A.keepReplacement, this.defaultRule = {
      replacement: A.defaultReplacement
    }, this.array = [];
    for (var Q in A.rules) this.array.push(A.rules[Q])
  }
  zm2.prototype = {
    add: function(A, Q) {
      this.array.unshift(Q)
    },
    keep: function(A) {
      this._keep.unshift({
        filter: A,
        replacement: this.keepReplacement
      })
    },
    remove: function(A) {
      this._remove.unshift({
        filter: A,
        replacement: function() {
          return ""
        }
      })
    },
    forNode: function(A) {
      if (A.isBlank) return this.blankRule;
      var Q;
      if (Q = lG0(this.array, A, this.options)) return Q;
      if (Q = lG0(this._keep, A, this.options)) return Q;
      if (Q = lG0(this._remove, A, this.options)) return Q;
      return this.defaultRule
    },
    forEach: function(A) {
      for (var Q = 0; Q < this.array.length; Q++) A(this.array[Q], Q)
    }
  };

  function lG0(A, Q, B) {
    for (var G = 0; G < A.length; G++) {
      var Z = A[G];
      if (Lo5(Z, Q, B)) return Z
    }
    return
  }

  function Lo5(A, Q, B) {
    var G = A.filter;
    if (typeof G === "string") {
      if (G === Q.nodeName.toLowerCase()) return !0
    } else if (Array.isArray(G)) {
      if (G.indexOf(Q.nodeName.toLowerCase()) > -1) return !0
    } else if (typeof G === "function") {
      if (G.call(A, Q, B)) return !0
    } else throw TypeError("`filter` needs to be a string, array, or function")
  }

  function Mo5(A) {
    var {
      element: Q,
      isBlock: B,
      isVoid: G
    } = A, Z = A.isPre || function(F) {
      return F.nodeName === "PRE"
    };
    if (!Q.firstChild || Z(Q)) return;
    var I = null,
      Y = !1,
      J = null,
      W = Fm2(J, Q, Z);
    while (W !== Q) {
      if (W.nodeType === 3 || W.nodeType === 4) {
        var X = W.data.replace(/[ \r\n\t]+/g, " ");
        if ((!I || / $/.test(I.data)) && !Y && X[0] === " ") X = X.substr(1);
        if (!X) {
          W = iG0(W);
          continue
        }
        W.data = X, I = W
      } else if (W.nodeType === 1) {
        if (B(W) || W.nodeName === "BR") {
          if (I) I.data = I.data.replace(/ $/, "");
          I = null, Y = !1
        } else if (G(W) || Z(W)) I = null, Y = !0;
        else if (I) Y = !1
      } else {
        W = iG0(W);
        continue
      }
      var V = Fm2(J, W, Z);
      J = W, W = V
    }
    if (I) {
      if (I.data = I.data.replace(/ $/, ""), !I.data) iG0(I)
    }
  }

  function iG0(A) {
    var Q = A.nextSibling || A.parentNode;
    return A.parentNode.removeChild(A), Q
  }

  function Fm2(A, Q, B) {
    if (A && A.parentNode === Q || B(Q)) return Q.nextSibling || Q.parentNode;
    return Q.firstChild || Q.nextSibling || Q.parentNode
  }
  var Um2 = typeof window < "u" ? window : {};

  function Oo5() {
    var A = Um2.DOMParser,
      Q = !1;
    try {
      if (new A().parseFromString("", "text/html")) Q = !0
    } catch (B) {}
    return Q
  }

  function Ro5() {
    var A = function() {};
    {
      var Q = Vm2();
      A.prototype.parseFromString = function(B) {
        return Q.createDocument(B)
      }
    }
    return A
  }
  var To5 = Oo5() ? Um2.DOMParser : Ro5();

  function Po5(A, Q) {
    var B;
    if (typeof A === "string") {
      var G = jo5().parseFromString('<x-turndown id="turndown-root">' + A + "</x-turndown>", "text/html");
      B = G.getElementById("turndown-root")
    } else B = A.cloneNode(!0);
    return Mo5({
      element: B,
      isBlock: sG0,
      isVoid: Hm2,
      isPre: Q.preformattedCode ? So5 : null
    }), B
  }
  var nG0;

  function jo5() {
    return nG0 = nG0 || new To5, nG0
  }

  function So5(A) {
    return A.nodeName === "PRE" || A.nodeName === "CODE"
  }

  function _o5(A, Q) {
    return A.isBlock = sG0(A), A.isCode = A.nodeName === "CODE" || A.parentNode.isCode, A.isBlank = ko5(A), A.flankingWhitespace = yo5(A, Q), A
  }

  function ko5(A) {
    return !Hm2(A) && !qo5(A) && /^\s*$/i.test(A.textContent) && !wo5(A) && !No5(A)
  }

  function yo5(A, Q) {
    if (A.isBlock || Q.preformattedCode && A.isCode) return {
      leading: "",
      trailing: ""
    };
    var B = xo5(A.textContent);
    if (B.leadingAscii && Km2("left", A, Q)) B.leading = B.leadingNonAscii;
    if (B.trailingAscii && Km2("right", A, Q)) B.trailing = B.trailingNonAscii;
    return {
      leading: B.leading,
      trailing: B.trailing
    }
  }

  function xo5(A) {
    var Q = A.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
    return {
      leading: Q[1],
      leadingAscii: Q[2],
      leadingNonAscii: Q[3],
      trailing: Q[4],
      trailingNonAscii: Q[5],
      trailingAscii: Q[6]
    }
  }

  function Km2(A, Q, B) {
    var G, Z, I;
    if (A === "left") G = Q.previousSibling, Z = / $/;
    else G = Q.nextSibling, Z = /^ /;
    if (G) {
      if (G.nodeType === 3) I = Z.test(G.nodeValue);
      else if (B.preformattedCode && G.nodeName === "CODE") I = !1;
      else if (G.nodeType === 1 && !sG0(G)) I = Z.test(G.textContent)
    }
    return I
  }
  var vo5 = Array.prototype.reduce,
    bo5 = [
      [/\\/g, "\\\\"],
      [/\*/g, "\\*"],
      [/^-/g, "\\-"],
      [/^\+ /g, "\\+ "],
      [/^(=+)/g, "\\$1"],
      [/^(#{1,6}) /g, "\\$1 "],
      [/`/g, "\\`"],
      [/^~~~/g, "\\~~~"],
      [/\[/g, "\\["],
      [/\]/g, "\\]"],
      [/^>/g, "\\>"],
      [/_/g, "\\_"],
      [/^(\d+)\. /g, "$1\\. "]
    ];

  function s31(A) {
    if (!(this instanceof s31)) return new s31(A);
    var Q = {
      rules: HC,
      headingStyle: "setext",
      hr: "* * *",
      bulletListMarker: "*",
      codeBlockStyle: "indented",
      fence: "```",
      emDelimiter: "_",
      strongDelimiter: "**",
      linkStyle: "inlined",
      linkReferenceStyle: "full",
      br: "  ",
      preformattedCode: !1,
      blankReplacement: function(B, G) {
        return G.isBlock ? `

` : ""
      },
      keepReplacement: function(B, G) {
        return G.isBlock ? `

` + G.outerHTML + `

` : G.outerHTML
      },
      defaultReplacement: function(B, G) {
        return G.isBlock ? `

` + B + `

` : B
      }
    };
    this.options = Eo5({}, Q, A), this.rules = new zm2(this.options)
  }
  s31.prototype = {
    turndown: function(A) {
      if (!go5(A)) throw TypeError(A + " is not a string, or an element/document/fragment node.");
      if (A === "") return "";
      var Q = $m2.call(this, new Po5(A, this.options));
      return fo5.call(this, Q)
    },
    use: function(A) {
      if (Array.isArray(A))
        for (var Q = 0; Q < A.length; Q++) this.use(A[Q]);
      else if (typeof A === "function") A(this);
      else throw TypeError("plugin must be a Function or an Array of Functions");
      return this
    },
    addRule: function(A, Q) {
      return this.rules.add(A, Q), this
    },
    keep: function(A) {
      return this.rules.keep(A), this
    },
    remove: function(A) {
      return this.rules.remove(A), this
    },
    escape: function(A) {
      return bo5.reduce(function(Q, B) {
        return Q.replace(B[0], B[1])
      }, A)
    }
  };

  function $m2(A) {
    var Q = this;
    return vo5.call(A.childNodes, function(B, G) {
      G = new _o5(G, Q.options);
      var Z = "";
      if (G.nodeType === 3) Z = G.isCode ? G.nodeValue : Q.escape(G.nodeValue);
      else if (G.nodeType === 1) Z = ho5.call(Q, G);
      return wm2(B, Z)
    }, "")
  }

  function fo5(A) {
    var Q = this;
    return this.rules.forEach(function(B) {
      if (typeof B.append === "function") A = wm2(A, B.append(Q.options))
    }), A.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "")
  }

  function ho5(A) {
    var Q = this.rules.forNode(A),
      B = $m2.call(this, A),
      G = A.flankingWhitespace;
    if (G.leading || G.trailing) B = B.trim();
    return G.leading + Q.replacement(B, A, this.options) + G.trailing
  }

  function wm2(A, Q) {
    var B = Uo5(A),
      G = zo5(Q),
      Z = Math.max(A.length - B.length, Q.length - G.length),
      I = `

`.substring(0, Z);
    return B + I + G
  }

  function go5(A) {
    return A != null && (typeof A === "string" || A.nodeType && (A.nodeType === 1 || A.nodeType === 9 || A.nodeType === 11))
  }
  qm2.exports = s31
})
// @from(Start 12307412, End 12307533)
function uo5() {
  let A = Date.now();
  for (let [Q, B] of r31.entries())
    if (A - B.timestamp > Om2) r31.delete(Q)
}
// @from(Start 12307535, End 12307759)
function co5(A) {
  if (A.length > mo5) return !1;
  let Q;
  try {
    Q = new URL(A)
  } catch {
    return !1
  }
  if (Q.username || Q.password) return !1;
  if (Q.hostname.split(".").length < 2) return !1;
  return !0
}
// @from(Start 12307760, End 12308221)
async function po5(A) {
  try {
    let Q = await YQ.get(`https://claude.ai/api/web/domain_info?domain=${encodeURIComponent(A)}`);
    if (Q.status === 200) return Q.data.can_fetch === !0 ? {
      status: "allowed"
    } : {
      status: "blocked"
    };
    return {
      status: "check_failed",
      error: Error(`Domain check returned status ${Q.status}`)
    }
  } catch (Q) {
    return AA(Q), {
      status: "check_failed",
      error: Q
    }
  }
}
// @from(Start 12308223, End 12308575)
function lo5(A, Q) {
  try {
    let B = new URL(A),
      G = new URL(Q);
    if (G.protocol !== B.protocol) return !1;
    if (G.port !== B.port) return !1;
    if (G.username || G.password) return !1;
    let Z = (J) => J.replace(/^www\./, ""),
      I = Z(B.hostname),
      Y = Z(G.hostname);
    return I === Y
  } catch (B) {
    return !1
  }
}
// @from(Start 12308576, End 12309288)
async function Rm2(A, Q, B) {
  try {
    return await YQ.get(A, {
      signal: Q,
      maxRedirects: 0,
      responseType: "arraybuffer",
      maxContentLength: do5,
      headers: {
        Accept: "text/markdown, text/html, */*"
      }
    })
  } catch (G) {
    if (YQ.isAxiosError(G) && G.response && [301, 302, 307, 308].includes(G.response.status)) {
      let Z = G.response.headers.location;
      if (!Z) throw Error("Redirect missing Location header");
      let I = new URL(Z, A).toString();
      if (B(A, I)) return Rm2(I, Q, B);
      else return {
        type: "redirect",
        originalUrl: A,
        redirectUrl: I,
        statusCode: G.response.status
      }
    }
    throw G
  }
}
// @from(Start 12309290, End 12309355)
function io5(A) {
  return "type" in A && A.type === "redirect"
}
// @from(Start 12309356, End 12310594)
async function Tm2(A, Q) {
  if (!co5(A)) throw Error("Invalid URL");
  uo5();
  let B = Date.now(),
    G = r31.get(A);
  if (G && B - G.timestamp < Om2) return {
    bytes: G.bytes,
    code: G.code,
    codeText: G.codeText,
    content: G.content
  };
  let Z, I = A;
  try {
    if (Z = new URL(A), Z.protocol === "http:") Z.protocol = "https:", I = Z.toString();
    let F = Z.hostname;
    if (!l0().skipWebFetchPreflight) switch ((await po5(F)).status) {
      case "allowed":
        break;
      case "blocked":
        throw new oG0(F);
      case "check_failed":
        throw new tG0(F)
    }
  } catch (F) {
    if (AA(F), F instanceof oG0 || F instanceof tG0) throw F
  }
  let Y = await Rm2(I, Q.signal, lo5);
  if (io5(Y)) return Y;
  let J = Buffer.from(Y.data).toString("utf-8"),
    W = Y.headers["content-type"] ?? "",
    X = Buffer.byteLength(J),
    V;
  if (W.includes("text/html")) V = new Mm2.default().turndown(J);
  else V = J;
  if (V.length > Lm2) V = V.substring(0, Lm2) + "...[content truncated]";
  return r31.set(A, {
    bytes: X,
    code: Y.status,
    codeText: Y.statusText,
    content: V,
    timestamp: B
  }), {
    code: Y.status,
    codeText: Y.statusText,
    content: V,
    bytes: X
  }
}
// @from(Start 12310595, End 12311134)
async function Pm2(A, Q, B, G) {
  let Z = ld0(Q, A),
    I = await uX({
      systemPrompt: [],
      userPrompt: Z,
      signal: B,
      options: {
        querySource: "web_fetch_apply",
        agents: [],
        isNonInteractiveSession: G,
        hasAppendSystemPrompt: !1,
        mcpTools: [],
        agentIdOrSessionId: e1()
      }
    });
  if (B.aborted) throw new WW;
  let {
    content: Y
  } = I.message;
  if (Y.length > 0) {
    let J = Y[0];
    if ("text" in J) return J.text
  }
  return "No response from model"
}
// @from(Start 12311139, End 12311142)
Mm2
// @from(Start 12311144, End 12311147)
oG0
// @from(Start 12311149, End 12311152)
tG0
// @from(Start 12311154, End 12311157)
r31
// @from(Start 12311159, End 12311171)
Om2 = 900000
// @from(Start 12311175, End 12311185)
mo5 = 2000
// @from(Start 12311189, End 12311203)
do5 = 10485760
// @from(Start 12311207, End 12311216)
Lm2 = 1e5
// @from(Start 12311222, End 12311763)
jm2 = L(() => {
  O3();
  fZ();
  q0();
  RZ();
  g1();
  MB();
  _0();
  Mm2 = BA(Nm2(), 1);
  oG0 = class oG0 extends Error {
    constructor(A) {
      super(`Claude Code is unable to fetch from ${A}`);
      this.name = "DomainBlockedError"
    }
  };
  tG0 = class tG0 extends Error {
    constructor(A) {
      super(`Unable to verify if domain ${A} is safe to fetch. This may be due to network restrictions or enterprise security policies blocking claude.ai.`);
      this.name = "DomainCheckFailedError"
    }
  };
  r31 = new Map
})
// @from(Start 12311769, End 12311772)
Sm2
// @from(Start 12311778, End 12313390)
_m2 = L(() => {
  Sm2 = new Set(["docs.anthropic.com", "docs.claude.com", "code.claude.com", "modelcontextprotocol.io", "docs.python.org", "en.cppreference.com", "docs.oracle.com", "learn.microsoft.com", "developer.mozilla.org", "go.dev", "www.php.net", "docs.swift.org", "kotlinlang.org", "ruby-doc.org", "doc.rust-lang.org", "www.typescriptlang.org", "react.dev", "angular.io", "vuejs.org", "nextjs.org", "expressjs.com", "nodejs.org", "jquery.com", "getbootstrap.com", "tailwindcss.com", "d3js.org", "threejs.org", "redux.js.org", "webpack.js.org", "jestjs.io", "reactrouter.com", "docs.djangoproject.com", "flask.palletsprojects.com", "fastapi.tiangolo.com", "pandas.pydata.org", "numpy.org", "www.tensorflow.org", "pytorch.org", "scikit-learn.org", "matplotlib.org", "requests.readthedocs.io", "jupyter.org", "laravel.com", "symfony.com", "wordpress.org", "docs.spring.io", "hibernate.org", "tomcat.apache.org", "gradle.org", "maven.apache.org", "asp.net", "dotnet.microsoft.com", "nuget.org", "blazor.net", "reactnative.dev", "docs.flutter.dev", "developer.apple.com", "developer.android.com", "keras.io", "spark.apache.org", "huggingface.co", "www.kaggle.com", "www.mongodb.com", "redis.io", "www.postgresql.org", "dev.mysql.com", "www.sqlite.org", "graphql.org", "prisma.io", "docs.aws.amazon.com", "cloud.google.com", "learn.microsoft.com", "kubernetes.io", "www.docker.com", "www.terraform.io", "www.ansible.com", "vercel.com/docs", "docs.netlify.com", "devcenter.heroku.com/", "cypress.io", "selenium.dev", "docs.unity.com", "docs.unrealengine.com", "git-scm.com", "nginx.org", "httpd.apache.org"])
})
// @from(Start 12313393, End 12313548)
function km2({
  url: A,
  prompt: Q
}, {
  verbose: B
}) {
  if (!A) return null;
  if (B) return `url: "${A}"${B&&Q?`, prompt: "${Q}"`:""}`;
  return A
}
// @from(Start 12313550, End 12313612)
function ym2() {
  return H$.default.createElement(k5, null)
}
// @from(Start 12313614, End 12313726)
function xm2(A, {
  verbose: Q
}) {
  return H$.default.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 12313728, End 12313871)
function vm2() {
  return H$.default.createElement(S0, {
    height: 1
  }, H$.default.createElement($, {
    dimColor: !0
  }, "Fetching…"))
}
// @from(Start 12313873, End 12314518)
function bm2({
  bytes: A,
  code: Q,
  codeText: B,
  result: G
}, Z, {
  verbose: I
}) {
  let Y = UJ(A);
  if (I) return H$.default.createElement(S, {
    flexDirection: "column"
  }, H$.default.createElement(S0, {
    height: 1
  }, H$.default.createElement($, null, "Received ", H$.default.createElement($, {
    bold: !0
  }, Y), " (", Q, " ", B, ")")), H$.default.createElement(S, {
    flexDirection: "column"
  }, H$.default.createElement($, null, G)));
  return H$.default.createElement(S0, {
    height: 1
  }, H$.default.createElement($, null, "Received ", H$.default.createElement($, {
    bold: !0
  }, Y), " (", Q, " ", B, ")"))
}
// @from(Start 12314520, End 12314590)
function fm2(A) {
  if (!A?.url) return null;
  return J7(A.url, $k)
}
// @from(Start 12314595, End 12314597)
H$
// @from(Start 12314603, End 12314680)
hm2 = L(() => {
  hA();
  q8();
  iX();
  yJ();
  R9();
  H$ = BA(VA(), 1)
})
// @from(Start 12314683, End 12314936)
function so5(A) {
  try {
    let Q = nV.inputSchema.safeParse(A);
    if (!Q.success) return `input:${A.toString()}`;
    let {
      url: B
    } = Q.data;
    return `domain:${new URL(B).hostname}`
  } catch {
    return `input:${A.toString()}`
  }
}
// @from(Start 12314941, End 12314944)
no5
// @from(Start 12314946, End 12314949)
ao5
// @from(Start 12314951, End 12314953)
nV
// @from(Start 12314959, End 12319982)
oWA = L(() => {
  Q2();
  jm2();
  AZ();
  _m2();
  hm2();
  no5 = j.strictObject({
    url: j.string().url().describe("The URL to fetch content from"),
    prompt: j.string().describe("The prompt to run on the fetched content")
  }), ao5 = j.object({
    bytes: j.number().describe("Size of the fetched content in bytes"),
    code: j.number().describe("HTTP response code"),
    codeText: j.string().describe("HTTP response code text"),
    result: j.string().describe("Processed result from applying the prompt to the content"),
    durationMs: j.number().describe("Time taken to fetch and process the content"),
    url: j.string().describe("The URL that was fetched")
  });
  nV = {
    name: $X,
    async description(A) {
      let {
        url: Q
      } = A;
      try {
        return `Claude wants to fetch content from ${new URL(Q).hostname}`
      } catch {
        return "Claude wants to fetch content from this URL"
      }
    },
    userFacingName() {
      return "Fetch"
    },
    getToolUseSummary: fm2,
    isEnabled() {
      return !0
    },
    inputSchema: no5,
    outputSchema: ao5,
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    async checkPermissions(A, Q) {
      let G = (await Q.getAppState()).toolPermissionContext;
      try {
        let {
          url: W
        } = A, X = new URL(W), V = X.hostname, F = X.pathname;
        for (let K of Sm2)
          if (K.includes("/")) {
            let [D, ...H] = K.split("/"), C = "/" + H.join("/");
            if (V === D && F.startsWith(C)) return {
              behavior: "allow",
              updatedInput: A,
              decisionReason: {
                type: "other",
                reason: "Preapproved host and path"
              }
            }
          } else if (V === K) return {
          behavior: "allow",
          updatedInput: A,
          decisionReason: {
            type: "other",
            reason: "Preapproved host"
          }
        }
      } catch {}
      let Z = so5(A),
        I = fU(G, nV, "deny").get(Z);
      if (I) return {
        behavior: "deny",
        message: `${nV.name} denied access to ${Z}.`,
        decisionReason: {
          type: "rule",
          rule: I
        }
      };
      let Y = fU(G, nV, "ask").get(Z);
      if (Y) return {
        behavior: "ask",
        message: `Claude requested permissions to use ${nV.name}, but you haven't granted it yet.`,
        decisionReason: {
          type: "rule",
          rule: Y
        }
      };
      let J = fU(G, nV, "allow").get(Z);
      if (J) return {
        behavior: "allow",
        updatedInput: A,
        decisionReason: {
          type: "rule",
          rule: J
        }
      };
      return {
        behavior: "ask",
        message: `Claude requested permissions to use ${nV.name}, but you haven't granted it yet.`
      }
    },
    async prompt() {
      return pd0
    },
    async validateInput(A) {
      let {
        url: Q
      } = A;
      try {
        new URL(Q)
      } catch {
        return {
          result: !1,
          message: `Error: Invalid URL "${Q}". The URL provided could not be parsed.`,
          meta: {
            reason: "invalid_url"
          },
          errorCode: 1
        }
      }
      return {
        result: !0
      }
    },
    renderToolUseMessage: km2,
    renderToolUseRejectedMessage: ym2,
    renderToolUseErrorMessage: xm2,
    renderToolUseProgressMessage: vm2,
    renderToolResultMessage: bm2,
    async call({
      url: A,
      prompt: Q
    }, {
      abortController: B,
      options: {
        isNonInteractiveSession: G
      }
    }) {
      let Z = Date.now(),
        I = await Tm2(A, B);
      if ("type" in I && I.type === "redirect") {
        let K = I.statusCode === 301 ? "Moved Permanently" : I.statusCode === 308 ? "Permanent Redirect" : I.statusCode === 307 ? "Temporary Redirect" : "Found",
          D = `REDIRECT DETECTED: The URL redirects to a different host.

Original URL: ${I.originalUrl}
Redirect URL: ${I.redirectUrl}
Status: ${I.statusCode} ${K}

To complete your request, I need to fetch content from the redirected URL. Please use WebFetch again with these parameters:
- url: "${I.redirectUrl}"
- prompt: "${Q}"`;
        return {
          data: {
            bytes: Buffer.byteLength(D),
            code: I.statusCode,
            codeText: K,
            result: D,
            durationMs: Date.now() - Z,
            url: A
          }
        }
      }
      let {
        content: Y,
        bytes: J,
        code: W,
        codeText: X
      } = I, V = await Pm2(Q, Y, B.signal, G);
      return {
        data: {
          bytes: J,
          code: W,
          codeText: X,
          result: V,
          durationMs: Date.now() - Z,
          url: A
        }
      }
    },
    mapToolResultToToolResultBlockParam({
      result: A
    }, Q) {
      return {
        tool_use_id: Q,
        type: "tool_result",
        content: A
      }
    }
  }
})
// @from(Start 12319985, End 12320238)
function ro5(A) {
  try {
    let Q = nV.inputSchema.safeParse(A);
    if (!Q.success) return `input:${A.toString()}`;
    let {
      url: B
    } = Q.data;
    return `domain:${new URL(B).hostname}`
  } catch {
    return `input:${A.toString()}`
  }
}
// @from(Start 12320240, End 12322096)
function gm2({
  toolUseConfirm: A,
  onDone: Q,
  onReject: B,
  verbose: G
}) {
  let [Z] = qB(), {
    url: I
  } = A.input, Y = new URL(I).hostname, J = mP.useMemo(() => ({
    completion_type: "tool_use_single",
    language_name: "none"
  }), []);
  V$(A, J);
  let W = [{
    label: "Yes",
    value: "yes"
  }, {
    label: `Yes, and don't ask again for ${tA.bold(Y)}`,
    value: "yes-dont-ask-again-domain"
  }, {
    label: `No, and tell Claude what to do differently ${tA.bold("(esc)")}`,
    value: "no"
  }];

  function X(V) {
    switch (V) {
      case "yes":
        fn("tool_use_single", A, "accept"), A.onAllow(A.input, []), Q();
        break;
      case "yes-dont-ask-again-domain": {
        fn("tool_use_single", A, "accept");
        let F = ro5(A.input),
          K = {
            toolName: A.tool.name,
            ruleContent: F
          };
        A.onAllow(A.input, [{
          type: "addRules",
          rules: [K],
          behavior: "allow",
          destination: "localSettings"
        }]), Q();
        break
      }
      case "no":
        fn("tool_use_single", A, "reject"), A.onReject(), B(), Q();
        break
    }
  }
  return mP.default.createElement(uJ, {
    title: "Fetch"
  }, mP.default.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, mP.default.createElement($, null, nV.renderToolUseMessage(A.input, {
    theme: Z,
    verbose: G
  })), mP.default.createElement($, {
    dimColor: !0
  }, A.description)), mP.default.createElement(S, {
    flexDirection: "column"
  }, mP.default.createElement(VC, {
    permissionResult: A.permissionResult,
    toolType: "tool"
  }), mP.default.createElement($, null, "Do you want to allow Claude to fetch this content?"), mP.default.createElement(M0, {
    options: W,
    onChange: X,
    onCancel: () => X("no")
  })))
}
// @from(Start 12322101, End 12322103)
mP
// @from(Start 12322109, End 12322212)
um2 = L(() => {
  hA();
  oWA();
  vn();
  wO();
  R70();
  S5();
  F9();
  Gg();
  mP = BA(VA(), 1)
})
// @from(Start 12322257, End 12324765)
function mm2({
  notebook_path: A,
  cell_id: Q,
  new_source: B,
  cell_type: G,
  edit_mode: Z = "replace",
  verbose: I,
  width: Y
}) {
  let J = tWA.useMemo(() => RA().existsSync(A), [A]),
    W = tWA.useMemo(() => {
      if (!J) return null;
      try {
        let D = _q(A);
        return f7(D)
      } catch (D) {
        return null
      }
    }, [A, J]),
    X = tWA.useMemo(() => {
      if (!W || !Q) return "";
      let D = S$A(Q);
      if (D !== void 0) {
        if (W.cells[D]) {
          let C = W.cells[D].source;
          return Array.isArray(C) ? C.join("") : C
        }
        return ""
      }
      let H = W.cells.find((C) => C.id === Q);
      if (!H) return "";
      return Array.isArray(H.source) ? H.source.join("") : H.source
    }, [W, Q]),
    V = tWA.useMemo(() => {
      if (!W || !W.metadata.language_info) return "python";
      return W.metadata.language_info.name || "python"
    }, [W]),
    F = tWA.useMemo(() => {
      if (!J || Z === "insert" || Z === "delete") return null;
      return Uq({
        filePath: A,
        fileContents: X,
        edits: [{
          old_string: X,
          new_string: B,
          replace_all: !1
        }],
        ignoreWhitespace: !1
      })
    }, [J, A, X, B, Z]),
    K;
  switch (Z) {
    case "insert":
      K = "Insert new cell";
      break;
    case "delete":
      K = "Delete cell";
      break;
    default:
      K = "Replace cell contents"
  }
  return MI.createElement(S, {
    flexDirection: "column"
  }, MI.createElement(S, {
    borderDimColor: !0,
    borderStyle: "round",
    flexDirection: "column",
    paddingX: 1
  }, MI.createElement(S, {
    paddingBottom: 1,
    flexDirection: "column"
  }, MI.createElement($, {
    bold: !0
  }, I ? A : oo5(W0(), A)), MI.createElement($, {
    dimColor: !0
  }, K, " for cell ", Q, G ? ` (${G})` : "")), Z === "delete" ? MI.createElement(S, {
    flexDirection: "column",
    paddingLeft: 2
  }, MI.createElement(CO, {
    code: X,
    language: V
  })) : Z === "insert" ? MI.createElement(S, {
    flexDirection: "column",
    paddingLeft: 2
  }, MI.createElement(CO, {
    code: B,
    language: G === "markdown" ? "markdown" : V
  })) : F ? dV(F.map((D) => MI.createElement(J$, {
    key: D.newStart,
    patch: D,
    dim: !1,
    width: Y,
    filePath: A
  })), (D) => MI.createElement($, {
    dimColor: !0,
    key: `ellipsis-${D}`
  }, "...")) : MI.createElement(CO, {
    code: B,
    language: G === "markdown" ? "markdown" : V
  })))
}
// @from(Start 12324770, End 12324772)
MI
// @from(Start 12324774, End 12324777)
tWA
// @from(Start 12324783, End 12324913)
dm2 = L(() => {
  En();
  hA();
  U2();
  FWA();
  Rh();
  R9();
  LF();
  AQ();
  LrA();
  MI = BA(VA(), 1), tWA = BA(VA(), 1)
})
// @from(Start 12324958, End 12326230)
function cm2(A) {
  let Q = (W) => {
      let X = kP.inputSchema.safeParse(W);
      if (!X.success) return AA(Error(`Failed to parse notebook edit input: ${X.error.message}`)), {
        notebook_path: "",
        new_source: "",
        cell_id: ""
      };
      return X.data
    },
    B = Q(A.toolUseConfirm.input),
    {
      notebook_path: G,
      edit_mode: Z,
      cell_type: I
    } = B,
    Y = I === "markdown" ? "markdown" : "python",
    J = Z === "insert" ? "insert this cell into" : Z === "delete" ? "delete this cell from" : "make this edit to";
  return mTA.default.createElement(bn, {
    toolUseConfirm: A.toolUseConfirm,
    toolUseContext: A.toolUseContext,
    onDone: A.onDone,
    onReject: A.onReject,
    title: "Edit notebook",
    question: mTA.default.createElement($, null, "Do you want to ", J, " ", mTA.default.createElement($, {
      bold: !0
    }, to5(G)), "?"),
    content: mTA.default.createElement(mm2, {
      notebook_path: B.notebook_path,
      cell_id: B.cell_id,
      new_source: B.new_source,
      cell_type: B.cell_type,
      edit_mode: B.edit_mode,
      verbose: A.verbose,
      width: A.verbose ? 120 : 80
    }),
    path: G,
    completionType: "tool_use_single",
    languageName: Y,
    parseInput: Q
  })
}
// @from(Start 12326235, End 12326238)
mTA
// @from(Start 12326244, End 12326325)
pm2 = L(() => {
  hA();
  DWA();
  dm2();
  UTA();
  g1();
  mTA = BA(VA(), 1)
})
// @from(Start 12326331, End 12326353)
pJ = "AskUserQuestion"
// @from(Start 12326357, End 12326365)
lm2 = 12
// @from(Start 12326369, End 12326520)
im2 = "Asks the user multiple choice questions to gather information, clarify ambiguity, understand preferences, make decisions or offer them choices."
// @from(Start 12326524, End 12326984)
nm2 = `Use this tool when you need to ask the user questions during execution. This allows you to:
1. Gather user preferences or requirements
2. Clarify ambiguous instructions
3. Get decisions on implementation choices as you work
4. Offer choices to the user about what direction to take.

Usage notes:
- Users will always be able to select "Other" to provide custom text input
- Use multiSelect: true to allow multiple answers to be selected for a question
`
// @from(Start 12326990, End 12326993)
TXZ
// @from(Start 12326995, End 12326998)
am2
// @from(Start 12327004, End 12330373)
sm2 = L(() => {
  TXZ = `Use this tool when you are in plan mode and have finished presenting your plan and are ready to code. This will prompt the user to exit plan mode.
IMPORTANT: Only use this tool when the task requires planning the implementation steps of a task that requires writing code. For research tasks where you're gathering information, searching files, reading files or in general trying to understand the codebase - do NOT use this tool.

## Handling Ambiguity in Plans
Before using this tool, ensure your plan is clear and unambiguous. If there are multiple valid approaches or unclear requirements:
1. Use the ${pJ} tool to clarify with the user
2. Ask about specific implementation choices (e.g., architectural patterns, which library to use)
3. Clarify any assumptions that could affect the implementation
4. Only proceed with ExitPlanMode after resolving ambiguities

## Examples

1. Initial task: "Search for and understand the implementation of vim mode in the codebase" - Do not use the exit plan mode tool because you are not planning the implementation steps of a task.
2. Initial task: "Help me implement yank mode for vim" - Use the exit plan mode tool after you have finished planning the implementation steps of the task.
3. Initial task: "Add a new feature to handle user authentication" - If unsure about auth method (OAuth, JWT, etc.), use ${pJ} first, then use exit plan mode tool after clarifying the approach.
`, am2 = `Use this tool when you are in plan mode and have finished writing your plan to the plan file and are ready for user approval.

## How This Tool Works
- You should have already written your plan to the plan file specified in the plan mode system message
- This tool does NOT take the plan content as a parameter - it will read the plan from the file you wrote
- This tool simply signals that you're done planning and ready for the user to review and approve
- The user will see the contents of your plan file when they review it

## When to Use This Tool
IMPORTANT: Only use this tool when the task requires planning the implementation steps of a task that requires writing code. For research tasks where you're gathering information, searching files, reading files or in general trying to understand the codebase - do NOT use this tool.

## Handling Ambiguity in Plans
Before using this tool, ensure your plan is clear and unambiguous. If there are multiple valid approaches or unclear requirements:
1. Use the ${pJ} tool to clarify with the user
2. Ask about specific implementation choices (e.g., architectural patterns, which library to use)
3. Clarify any assumptions that could affect the implementation
4. Edit your plan file to incorporate user feedback
5. Only proceed with ExitPlanMode after resolving ambiguities and updating the plan file

## Examples

1. Initial task: "Search for and understand the implementation of vim mode in the codebase" - Do not use the exit plan mode tool because you are not planning the implementation steps of a task.
2. Initial task: "Help me implement yank mode for vim" - Use the exit plan mode tool after you have finished planning the implementation steps of the task.
3. Initial task: "Add a new feature to handle user authentication" - If unsure about auth method (OAuth, JWT, etc.), use ${pJ} first, then use exit plan mode tool after clarifying the approach.
`
})
// @from(Start 12330379, End 12330381)
rD
// @from(Start 12330387, End 12330456)
dn = L(() => {
  c5();
  rD = d0.platform === "darwin" ? "⏺" : "●"
})
// @from(Start 12330459, End 12330879)
function o31({
  plan: A,
  themeName: Q
}) {
  return dP.createElement(S0, null, dP.createElement(S, {
    flexDirection: "column"
  }, dP.createElement($, {
    color: "error"
  }, "User rejected Claude's plan:"), dP.createElement(S, {
    borderStyle: "round",
    borderColor: "planMode",
    borderDimColor: !0,
    paddingX: 1,
    overflow: "hidden"
  }, dP.createElement($, {
    dimColor: !0
  }, fD(A, Q)))))
}
// @from(Start 12330884, End 12330886)
dP
// @from(Start 12330892, End 12330953)
eG0 = L(() => {
  hA();
  wh();
  q8();
  dP = BA(VA(), 1)
})
// @from(Start 12330956, End 12330988)
function rm2() {
  return null
}
// @from(Start 12330990, End 12331022)
function om2() {
  return null
}
// @from(Start 12331024, End 12331633)
function tm2(A, Q, {
  theme: B
}) {
  let {
    plan: G
  } = A, Z = "filePath" in A ? A.filePath : void 0, I = Z ? Q5(Z) : "";
  return mW.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, mW.createElement(S, {
    flexDirection: "row"
  }, mW.createElement($, {
    color: ZS("plan")
  }, rD), mW.createElement($, null, " User approved Claude's plan")), mW.createElement(S0, null, mW.createElement(S, {
    flexDirection: "column"
  }, Z && mW.createElement($, {
    dimColor: !0
  }, "Plan saved to: ", I, " · /plan to edit"), mW.createElement($, {
    dimColor: !0
  }, fD(G, B)))))
}
// @from(Start 12331635, End 12331846)
function em2({
  plan: A
}, {
  theme: Q
}) {
  let B = A ?? xU() ?? "No plan found";
  return mW.createElement(S, {
    flexDirection: "column"
  }, mW.createElement(o31, {
    plan: B,
    themeName: Q
  }))
}
// @from(Start 12331848, End 12331880)
function Ad2() {
  return null
}
// @from(Start 12331885, End 12331887)
mW
// @from(Start 12331893, End 12331995)
Qd2 = L(() => {
  hA();
  wh();
  q8();
  dn();
  eG0();
  Zw();
  NE();
  R9();
  mW = BA(VA(), 1)
})
// @from(Start 12332001, End 12332004)
eo5
// @from(Start 12332006, End 12332009)
At5
// @from(Start 12332011, End 12332013)
gq
// @from(Start 12332019, End 12334045)
dTA = L(() => {
  Q2();
  _0();
  sm2();
  Qd2();
  NE();
  eo5 = j.strictObject({}).passthrough(), At5 = j.object({
    plan: j.string().describe("The plan that was presented to the user"),
    isAgent: j.boolean(),
    filePath: j.string().optional().describe("The file path where the plan was saved")
  }), gq = {
    name: rRA,
    async description() {
      return "Prompts the user to exit plan mode and start coding"
    },
    async prompt() {
      return am2
    },
    inputSchema: eo5,
    outputSchema: At5,
    userFacingName() {
      return ""
    },
    isEnabled() {
      return !0
    },
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !1
    },
    async checkPermissions(A) {
      return {
        behavior: "ask",
        message: "Exit plan mode?",
        updatedInput: A
      }
    },
    renderToolUseMessage: rm2,
    renderToolUseProgressMessage: om2,
    renderToolResultMessage: tm2,
    renderToolUseRejectedMessage: em2,
    renderToolUseErrorMessage: Ad2,
    async call(A, Q) {
      let B = e1(),
        G = Q.agentId !== B,
        Z = yU(Q.agentId),
        I = xU(Q.agentId);
      if (!I) throw Error(`No plan file found at ${Z}. Please write your plan to this file before calling ExitPlanMode.`);
      return {
        data: {
          plan: I,
          isAgent: G,
          filePath: Z
        }
      }
    },
    mapToolResultToToolResultBlockParam({
      isAgent: A,
      plan: Q,
      filePath: B
    }, G) {
      if (A) return {
        type: "tool_result",
        content: 'User has approved the plan. There is nothing else needed from you now. Please respond with "ok"',
        tool_use_id: G
      };
      return {
        type: "tool_result",
        content: `User has approved your plan. You can now start coding. Start with updating your todo list if applicable

Your plan has been saved to: ${B}
You can refer back to it if needed during implementation.

## Approved Plan:
${Q}`,
        tool_use_id: G
      }
    }
  }
})
// @from(Start 12334099, End 12334281)
function Qt5(A) {
  try {
    let Q = process.platform === "win32" ? "where" : "which";
    return Bd2(`${Q} ${A}`, {
      stdio: "ignore"
    }), !0
  } catch {
    return !1
  }
}
// @from(Start 12334282, End 12334417)
async function cn(A) {
  let Q = Jg();
  if (!Q) throw Error("No editor available");
  Bd2(`${Q} "${A}"`, {
    stdio: "inherit"
  })
}
// @from(Start 12334422, End 12334424)
Jg
// @from(Start 12334430, End 12334740)
pn = L(() => {
  l2();
  Jg = s1(() => {
    if (process.env.VISUAL?.trim()) return process.env.VISUAL.trim();
    if (process.env.EDITOR?.trim()) return process.env.EDITOR.trim();
    if (process.platform === "win32") return "start /wait notepad";
    return ["code", "vi", "nano"].find((Q) => Qt5(Q))
  })
})
// @from(Start 12334865, End 12334967)
function t31(A = "claude-prompt", Q = ".md") {
  let B = Zt5();
  return Bt5(Gt5(), `${A}-${B}${Q}`)
}
// @from(Start 12334972, End 12334986)
AZ0 = () => {}
// @from(Start 12335040, End 12335132)
function Wt5(A) {
  let Q = A.split(" ")[0] ?? "";
  return Jt5.some((B) => Q.includes(B))
}
// @from(Start 12335134, End 12335784)
function QZ0(A) {
  let Q = RA(),
    B = Qf.get(process.stdout);
  if (!B) throw Error("Ink instance not found - cannot pause rendering");
  let G = Jg();
  if (!G) return null;
  if (!Q.existsSync(A)) return null;
  let Z = !Wt5(G);
  try {
    if (B.pause(), B.suspendStdin(), Z) process.stdout.write("\x1B[?1049h\x1B[?1004l\x1B[0m\x1B[?25h\x1B[2J\x1B[H");
    let I = Yt5[G] ?? G;
    return It5(`${I} "${A}"`, {
      stdio: "inherit"
    }), Q.readFileSync(A, {
      encoding: "utf-8"
    })
  } catch (I) {
    return null
  } finally {
    if (Z) process.stdout.write("\x1B[?1049l\x1B[?1004h\x1B[?25l");
    B.resumeStdin(), B.resume()
  }
}
// @from(Start 12335786, End 12336142)
function e31(A) {
  let Q = RA(),
    B = t31();
  try {
    Q.writeFileSync(B, A, {
      encoding: "utf-8",
      flush: !0
    });
    let G = QZ0(B);
    if (G === null) return null;
    if (G.endsWith(`
`) && !G.endsWith(`

`)) return G.slice(0, -1);
    return G
  } finally {
    try {
      if (Q.existsSync(B)) Q.unlinkSync(B)
    } catch {}
  }
}
// @from(Start 12336147, End 12336150)
Yt5
// @from(Start 12336152, End 12336155)
Jt5
// @from(Start 12336161, End 12336337)
BZ0 = L(() => {
  pn();
  AQ();
  AZ0();
  uaA();
  Yt5 = {
    code: "code -w",
    subl: "subl --wait"
  }, Jt5 = ["code", "subl", "atom", "gedit", "notepad++", "notepad"]
})
// @from(Start 12336340, End 12340477)
function Gd2({
  toolUseConfirm: A,
  onDone: Q,
  onReject: B
}) {
  let [G] = qB(), [Z] = OQ(), [I, Y] = qG.useState(""), [J, W] = qG.useState(null), X = A.input.plan, V = X === void 0, F = V ? yU(e1()) : void 0, [K, D] = qG.useState(() => {
    if (X) return X;
    return xU(e1()) ?? "No plan found. Please write your plan to the plan file first."
  }), [H, C] = qG.useState(!1);
  qG.useEffect(() => {
    if (H) {
      let w = setTimeout(() => {
        C(!1)
      }, 5000);
      return () => clearTimeout(w)
    }
  }, [H]), f1((w, N) => {
    if (N.ctrl && w.toLowerCase() === "g")
      if (GA("tengu_plan_external_editor_used", {}), V && F) {
        let R = QZ0(F);
        if (R !== null) D(R), C(!0)
      } else {
        let R = e31(K);
        if (R !== null && R !== K) D(R), C(!0)
      }
  });

  function E(w) {
    let N = V ? {} : {
      plan: K
    };
    if (w === "yes-bypass-permissions") GA("tengu_plan_exit", {
      planLengthChars: K.length,
      outcome: w
    }), ou(!0), Q(), A.onAllow(N, [{
      type: "setMode",
      mode: "bypassPermissions",
      destination: "session"
    }]);
    else if (w === "yes-accept-edits") GA("tengu_plan_exit", {
      planLengthChars: K.length,
      outcome: w
    }), ou(!0), Q(), A.onAllow(N, [{
      type: "setMode",
      mode: "acceptEdits",
      destination: "session"
    }]);
    else if (w === "yes-default") GA("tengu_plan_exit", {
      planLengthChars: K.length,
      outcome: w
    }), ou(!0), Q(), A.onAllow(N, [{
      type: "setMode",
      mode: "default",
      destination: "session"
    }]);
    else {
      let R = I.trim();
      if (!R) {
        W("no");
        return
      }
      GA("tengu_plan_exit", {
        planLengthChars: K.length,
        outcome: "no"
      }), Q(), B(), A.onReject(R)
    }
  }
  let U = Jg(),
    q = U ? aF(U) : null;
  return qG.default.createElement(qG.default.Fragment, null, qG.default.createElement(uJ, {
    color: "planMode",
    title: "Ready to code?",
    innerPaddingX: 0
  }, qG.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, qG.default.createElement(S, {
    paddingX: 1
  }, qG.default.createElement($, null, "Here is Claude's plan:")), qG.default.createElement(S, {
    borderDimColor: !0,
    borderColor: "subtle",
    borderStyle: "dashed",
    flexDirection: "column",
    borderLeft: !1,
    borderRight: !1,
    paddingX: 1,
    marginBottom: 1,
    overflow: "hidden"
  }, qG.default.createElement($, null, fD(K, G))), qG.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, qG.default.createElement(VC, {
    permissionResult: A.permissionResult,
    toolType: "tool"
  }), qG.default.createElement($, {
    dimColor: !0
  }, "Would you like to proceed?"), qG.default.createElement(S, {
    marginTop: 1
  }, qG.default.createElement(M0, {
    options: [...Z.toolPermissionContext.isBypassPermissionsModeAvailable ? [{
      label: "Yes, and bypass permissions",
      value: "yes-bypass-permissions"
    }] : [{
      label: "Yes, and auto-accept edits",
      value: "yes-accept-edits"
    }], {
      label: "Yes, and manually approve edits",
      value: "yes-default"
    }, {
      type: "input",
      label: "No, keep planning",
      value: "no",
      placeholder: "Type here to tell Claude what to change",
      onChange: Y
    }],
    onChange: (w) => E(w),
    onCancel: () => {
      GA("tengu_plan_exit", {
        planLengthChars: K.length,
        outcome: "no"
      }), Q(), B(), A.onReject()
    },
    onFocus: W,
    focusValue: J || void 0
  }))))), q && qG.default.createElement(S, {
    flexDirection: "row",
    gap: 1,
    paddingX: 1,
    marginTop: 1
  }, qG.default.createElement(S, null, qG.default.createElement($, {
    dimColor: !0
  }, "ctrl-g to edit in "), qG.default.createElement($, {
    bold: !0,
    dimColor: !0
  }, q), V && F && qG.default.createElement($, {
    dimColor: !0
  }, " · ", F)), H && qG.default.createElement(S, null, qG.default.createElement($, {
    dimColor: !0
  }, " · "), qG.default.createElement($, {
    color: "success"
  }, H1.tick, "Plan saved!"))))
}
// @from(Start 12340482, End 12340484)
qG
// @from(Start 12340490, End 12340632)
Zd2 = L(() => {
  hA();
  J5();
  wO();
  wh();
  Gg();
  z9();
  BZ0();
  q0();
  V9();
  pn();
  nY();
  NE();
  _0();
  qG = BA(VA(), 1)
})
// @from(Start 12340638, End 12340641)
Id2
// @from(Start 12340647, End 12343855)
Yd2 = L(() => {
  Id2 = `Use this tool when you encounter a complex task that requires careful planning and exploration before implementation. This tool transitions you into plan mode where you can thoroughly explore the codebase and design an implementation approach.

## When to Use This Tool

Use EnterPlanMode when ANY of these conditions apply:

1. **Multiple Valid Approaches**: The task can be solved in several different ways, each with trade-offs
   - Example: "Add caching to the API" - could use Redis, in-memory, file-based, etc.
   - Example: "Improve performance" - many optimization strategies possible

2. **Significant Architectural Decisions**: The task requires choosing between architectural patterns
   - Example: "Add real-time updates" - WebSockets vs SSE vs polling
   - Example: "Implement state management" - Redux vs Context vs custom solution

3. **Large-Scale Changes**: The task touches many files or systems
   - Example: "Refactor the authentication system"
   - Example: "Migrate from REST to GraphQL"

4. **Unclear Requirements**: You need to explore before understanding the full scope
   - Example: "Make the app faster" - need to profile and identify bottlenecks
   - Example: "Fix the bug in checkout" - need to investigate root cause

5. **User Input Needed**: You'll need to ask clarifying questions before starting
   - If you would use ${pJ} to clarify the approach, consider EnterPlanMode instead
   - Plan mode lets you explore first, then present options with context

## When NOT to Use This Tool

Do NOT use EnterPlanMode for:
- Simple, straightforward tasks with obvious implementation
- Small bug fixes where the solution is clear
- Adding a single function or small feature
- Tasks you're already confident how to implement
- Research-only tasks (use the Task tool with explore agent instead)

## What Happens in Plan Mode

In plan mode, you'll:
1. Thoroughly explore the codebase using Glob, Grep, and Read tools
2. Understand existing patterns and architecture
3. Design an implementation approach
4. Present your plan to the user for approval
5. Use ${pJ} if you need to clarify approaches
6. Exit plan mode with ExitPlanMode when ready to implement

## Examples

### GOOD - Use EnterPlanMode:
User: "Add user authentication to the app"
- This requires architectural decisions (session vs JWT, where to store tokens, middleware structure)

User: "Optimize the database queries"
- Multiple approaches possible, need to profile first, significant impact

User: "Implement dark mode"
- Architectural decision on theme system, affects many components

### BAD - Don't use EnterPlanMode:
User: "Fix the typo in the README"
- Straightforward, no planning needed

User: "Add a console.log to debug this function"
- Simple, obvious implementation

User: "What files handle routing?"
- Research task, not implementation planning

## Important Notes

- This tool REQUIRES user approval - they must consent to entering plan mode
- Be thoughtful about when to use it - unnecessary plan mode slows down simple tasks
- If unsure whether to use it, err on the side of starting implementation
- You can always ask the user "Would you like me to plan this out first?"
`
})
// @from(Start 12343858, End 12343890)
function Jd2() {
  return null
}
// @from(Start 12343892, End 12343924)
function Wd2() {
  return null
}
// @from(Start 12343926, End 12344368)
function Xd2(A, Q, B) {
  return aV.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, aV.createElement(S, {
    flexDirection: "row"
  }, aV.createElement($, {
    color: ZS("plan")
  }, rD), aV.createElement($, null, " Entered plan mode")), aV.createElement(S, {
    marginTop: 1,
    paddingLeft: 2
  }, aV.createElement($, {
    dimColor: !0
  }, "Claude is now exploring and designing an implementation approach.")))
}
// @from(Start 12344370, End 12344588)
function Vd2() {
  return aV.createElement(S, {
    flexDirection: "row",
    marginTop: 1
  }, aV.createElement($, {
    color: ZS("default")
  }, rD), aV.createElement($, null, " User declined to enter plan mode"))
}
// @from(Start 12344590, End 12344622)
function Fd2() {
  return null
}
// @from(Start 12344627, End 12344629)
aV
// @from(Start 12344635, End 12344696)
Kd2 = L(() => {
  hA();
  dn();
  Zw();
  aV = BA(VA(), 1)
})
// @from(Start 12344702, End 12344723)
A71 = "EnterPlanMode"
// @from(Start 12344729, End 12344732)
Xt5
// @from(Start 12344734, End 12344737)
Vt5
// @from(Start 12344739, End 12344742)
cTA
// @from(Start 12344748, End 12346661)
GZ0 = L(() => {
  Q2();
  _0();
  Yd2();
  Kd2();
  Xt5 = j.strictObject({}), Vt5 = j.object({
    message: j.string().describe("Confirmation that plan mode was entered")
  }), cTA = {
    name: A71,
    async description() {
      return "Requests permission to enter plan mode for complex tasks requiring exploration and design"
    },
    async prompt() {
      return Id2
    },
    inputSchema: Xt5,
    outputSchema: Vt5,
    userFacingName() {
      return ""
    },
    isEnabled() {
      return !0
    },
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    async checkPermissions(A) {
      return {
        behavior: "ask",
        message: "Enter plan mode?",
        updatedInput: A
      }
    },
    renderToolUseMessage: Jd2,
    renderToolUseProgressMessage: Wd2,
    renderToolResultMessage: Xd2,
    renderToolUseRejectedMessage: Vd2,
    renderToolUseErrorMessage: Fd2,
    async call(A, Q) {
      let B = e1();
      if (Q.agentId !== B) throw Error("EnterPlanMode tool cannot be used in agent contexts");
      return {
        data: {
          message: "Entered plan mode. You should now focus on exploring the codebase and designing an implementation approach."
        }
      }
    },
    mapToolResultToToolResultBlockParam({
      message: A
    }, Q) {
      return {
        type: "tool_result",
        content: `${A}

In plan mode, you should:
1. Thoroughly explore the codebase to understand existing patterns
2. Identify similar features and architectural approaches
3. Consider multiple approaches and their trade-offs
4. Use AskUserQuestion if you need to clarify the approach
5. Design a concrete implementation strategy
6. When ready, use ExitPlanMode to present your plan for approval

Remember: DO NOT write or edit any files yet. This is a read-only exploration and planning phase.`,
        tool_use_id: Q
      }
    }
  }
})
// @from(Start 12346664, End 12348206)
function Dd2({
  toolUseConfirm: A,
  onDone: Q,
  onReject: B
}) {
  function G(Z) {
    if (Z === "yes") Q(), A.onAllow({}, [{
      type: "setMode",
      mode: "plan",
      destination: "session"
    }]);
    else Q(), B(), A.onReject()
  }
  return C$.default.createElement(uJ, {
    color: "planMode",
    title: "Enter plan mode?"
  }, C$.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    paddingX: 1
  }, C$.default.createElement($, null, "Claude wants to enter plan mode to explore and design an implementation approach."), C$.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, C$.default.createElement($, {
    dimColor: !0
  }, "In plan mode, Claude will:"), C$.default.createElement($, {
    dimColor: !0
  }, " · Explore the codebase thoroughly"), C$.default.createElement($, {
    dimColor: !0
  }, " · Identify existing patterns"), C$.default.createElement($, {
    dimColor: !0
  }, " · Design an implementation strategy"), C$.default.createElement($, {
    dimColor: !0
  }, " · Present a plan for your approval")), C$.default.createElement(S, {
    marginTop: 1
  }, C$.default.createElement($, {
    dimColor: !0
  }, "No code changes will be made until you approve the plan.")), C$.default.createElement(S, {
    marginTop: 1
  }, C$.default.createElement(M0, {
    options: [{
      label: "Yes, enter plan mode",
      value: "yes"
    }, {
      label: "No, start implementing now",
      value: "no"
    }],
    onChange: G,
    onCancel: () => G("no")
  }))))
}
// @from(Start 12348211, End 12348213)
C$
// @from(Start 12348219, End 12348280)
Hd2 = L(() => {
  hA();
  J5();
  wO();
  C$ = BA(VA(), 1)
})
// @from(Start 12348283, End 12348636)
function Cd2(A, Q, {
  verbose: B
}) {
  let G = [];
  if (A.allowedTools && A.allowedTools.length > 0) {
    let Z = A.allowedTools.length;
    G.push(`${Z} tool${Z===1?"":"s"} allowed`)
  }
  if (A.model) G.push(A.model);
  if (G.length === 0) return null;
  return uq.createElement(S0, {
    height: 1
  }, uq.createElement($, null, G.join(" · ")))
}
// @from(Start 12348638, End 12348722)
function Ed2({
  skill: A
}, {
  verbose: Q
}) {
  if (!A) return null;
  return A
}
// @from(Start 12348724, End 12348850)
function zd2() {
  return uq.createElement(S0, {
    height: 1
  }, uq.createElement($, {
    dimColor: !0
  }, "Loading…"))
}
// @from(Start 12348852, End 12348906)
function Ud2() {
  return uq.createElement(k5, null)
}
// @from(Start 12348908, End 12349012)
function $d2(A, {
  verbose: Q
}) {
  return uq.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 12349017, End 12349019)
uq
// @from(Start 12349025, End 12349094)
wd2 = L(() => {
  hA();
  yJ();
  iX();
  q8();
  uq = BA(VA(), 1)
})
// @from(Start 12349097, End 12349261)
function Q71(A, Q) {
  if (!Q) return A;
  return A.map((B) => {
    if (B.type === "user") return {
      ...B,
      sourceToolUseID: Q
    };
    return B
  })
}
// @from(Start 12349263, End 12349417)
function B71(A, Q) {
  let B = A.message.content.find((G) => G.type === "tool_use" && G.name === Q);
  return B && B.type === "tool_use" ? B.id : void 0
}
// @from(Start 12349422, End 12349425)
Ft5
// @from(Start 12349427, End 12349430)
Kt5
// @from(Start 12349432, End 12349434)
ln
// @from(Start 12349440, End 12355221)
G71 = L(() => {
  Q2();
  cE();
  AZ();
  vRA();
  K70();
  wd2();
  q0();
  V0();
  Ft5 = j.object({
    skill: j.string().describe('The skill name (no arguments). E.g., "pdf" or "xlsx"')
  }), Kt5 = j.object({
    success: j.boolean().describe("Whether the skill is valid"),
    commandName: j.string().describe("The name of the skill"),
    allowedTools: j.array(j.string()).optional().describe("Tools allowed by this skill"),
    model: j.string().optional().describe("Model override if specified")
  }), ln = {
    name: kq,
    inputSchema: Ft5,
    outputSchema: Kt5,
    description: async ({
      skill: A
    }) => `Execute skill: ${A}`,
    prompt: async () => _b2(),
    userFacingName: () => kq,
    isConcurrencySafe: () => !1,
    isEnabled: () => !0,
    isReadOnly: () => !1,
    async validateInput({
      skill: A
    }, Q) {
      let B = A.trim();
      if (!B) return {
        result: !1,
        message: `Invalid skill format: ${A}`,
        errorCode: 1
      };
      let G = B.startsWith("/") ? B.substring(1) : B,
        Z = await sE();
      if (!ph(G, Z)) return {
        result: !1,
        message: `Unknown skill: ${G}`,
        errorCode: 2
      };
      let I = Pq(G, Z);
      if (!I) return {
        result: !1,
        message: `Could not load skill: ${G}`,
        errorCode: 3
      };
      if (I.disableModelInvocation) return {
        result: !1,
        message: `Skill ${G} cannot be used with ${kq} tool due to disable-model-invocation`,
        errorCode: 4
      };
      if (I.type !== "prompt") return {
        result: !1,
        message: `Skill ${G} is not a prompt-based skill`,
        errorCode: 5
      };
      return {
        result: !0
      }
    },
    async checkPermissions({
      skill: A
    }, Q) {
      let B = A.trim(),
        G = B.startsWith("/") ? B.substring(1) : B,
        I = (await Q.getAppState()).toolPermissionContext,
        Y = await sE(),
        J = Pq(G, Y),
        W = (K) => {
          if (K === A) return !0;
          if (K.endsWith(":*")) {
            let D = K.slice(0, -2);
            return A.startsWith(D)
          }
          return !1
        },
        X = fU(I, ln, "deny");
      for (let [K, D] of X.entries())
        if (W(K)) return {
          behavior: "deny",
          message: "Skill execution blocked by permission rules",
          decisionReason: {
            type: "rule",
            rule: D
          }
        };
      let V = fU(I, ln, "allow");
      for (let [K, D] of V.entries())
        if (W(K)) return {
          behavior: "allow",
          updatedInput: {
            skill: A
          },
          decisionReason: {
            type: "rule",
            rule: D
          }
        };
      let F = [{
        type: "addRules",
        rules: [{
          toolName: kq,
          ruleContent: A
        }],
        behavior: "allow",
        destination: "localSettings"
      }];
      return {
        behavior: "ask",
        message: `Execute skill: ${G}`,
        decisionReason: void 0,
        suggestions: F,
        metadata: {
          command: J
        }
      }
    },
    async call({
      skill: A
    }, Q, B, G) {
      let Z = A.trim(),
        I = Z.startsWith("/") ? Z.substring(1) : Z,
        Y = await sE(),
        J = await s61(I, "", Y, Q);
      if (!J.shouldQuery) throw Error("Command processing failed");
      let W = J.allowedTools || [],
        X = J.model,
        V = J.maxThinkingTokens,
        F = Ny().has(I) ? I : "custom";
      GA("tengu_skill_tool_invocation", {
        command_name: F
      });
      let K = B71(G, kq),
        D = Q71(J.messages.filter((H) => {
          if (H.type === "progress") return !1;
          if (H.type === "user" && "message" in H) {
            let C = H.message.content;
            if (typeof C === "string" && C.includes("<command-message>")) return !1
          }
          return !0
        }), K);
      return g(`SkillTool returning ${D.length} newMessages for skill ${I}`), D.forEach((H, C) => {
        if (H.type === "user" && "message" in H) {
          let E = typeof H.message.content === "string" ? H.message.content : JSON.stringify(H.message.content);
          g(`  newMessage ${C+1}: ${E.substring(0,150)}...`)
        }
      }), {
        data: {
          success: !0,
          commandName: I,
          allowedTools: W.length > 0 ? W : void 0,
          model: X
        },
        newMessages: D,
        contextModifier(H) {
          let C = H;
          if (W.length > 0) C = {
            ...C,
            async getAppState() {
              let E = await Q.getAppState();
              return {
                ...E,
                toolPermissionContext: {
                  ...E.toolPermissionContext,
                  alwaysAllowRules: {
                    ...E.toolPermissionContext.alwaysAllowRules,
                    command: [...new Set([...E.toolPermissionContext.alwaysAllowRules.command || [], ...W])]
                  }
                }
              }
            }
          };
          if (X) C = {
            ...C,
            options: {
              ...C.options,
              mainLoopModel: X
            }
          };
          if (V !== void 0) C = {
            ...C,
            options: {
              ...C.options,
              maxThinkingTokens: V
            }
          };
          return C
        }
      }
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      return {
        type: "tool_result",
        tool_use_id: Q,
        content: `Launching skill: ${A.commandName}`
      }
    },
    renderToolResultMessage: Cd2,
    renderToolUseMessage: Ed2,
    renderToolUseProgressMessage: zd2,
    renderToolUseRejectedMessage: Ud2,
    renderToolUseErrorMessage: $d2
  }
})
// @from(Start 12355227, End 12355246)
cP = "SlashCommand"
// @from(Start 12355249, End 12355336)
function Dt5() {
  return Number(process.env.SLASH_COMMAND_TOOL_CHAR_BUDGET) || 15000
}
// @from(Start 12355338, End 12355532)
function qd2(A) {
  let Q = `/${A.name}`,
    B = A.argumentHint ? ` ${A.argumentHint}` : "",
    G = A.whenToUse ? `- ${A.whenToUse}` : "";
  return `- ${Q}${B}: ${A.description} ${G}`.trim()
}
// @from(Start 12355534, End 12355693)
function Ht5(A) {
  let Q = [],
    B = 0;
  for (let G of A) {
    let Z = qd2(G);
    if (B += Z.length + 1, B > Dt5()) break;
    Q.push(G)
  }
  return Q
}
// @from(Start 12355695, End 12355757)
function Ct5(A) {
  return {
    limitedCommands: Ht5(A)
  }
}
// @from(Start 12355762, End 12355765)
Nd2
// @from(Start 12355771, End 12357602)
Ld2 = L(() => {
  cE();
  V0();
  $9A();
  Nd2 = s1(async () => {
    let A = await Z71(),
      {
        limitedCommands: Q
      } = Ct5(A),
      B = Q.length > 0 ? Q.map((Y) => qd2(Y)).join(`
`) : "",
      G = Q.map((Y) => `/${Y.userFacingName()}`).join(", ");
    g(`Slash commands included in SlashCommand tool: ${G}`);
    let Z = A.length > Q.length ? `
(Showing ${Q.length} of ${A.length} commands due to token limits)` : "";
    return `Execute a slash command within the main conversation

How slash commands work:
When you use this tool or when a user types a slash command, you will see <command-message>{name} is running…</command-message> followed by the expanded prompt. For example, if .claude/commands/foo.md contains "Print today's date", then /foo expands to that prompt in the next message.

Usage:
- \`command\` (required): The slash command to execute, including any arguments
- Example: \`command: "/review-pr 123"\`

IMPORTANT: Only use this tool for custom slash commands that appear in the Available Commands list below. Do NOT use for:
- Built-in CLI commands (like /help, /clear, etc.)
- Commands not shown in the list
- Commands you think might exist but aren't listed

${B?`Available Commands:
${B}${Z}
`:""}Notes:
- When a user requests multiple slash commands, execute each one sequentially and check for <command-message>{name} is running…</command-message> to verify each has been processed
- Do not invoke a command that is already running. For example, if you see <command-message>foo is running…</command-message>, do NOT use this tool with "/foo" - process the expanded prompt in the following message
- Only custom slash commands with descriptions are listed in Available Commands. If a user's command is not listed, ask them to check the slash command file and consult the docs.
`
  })
})
// @from(Start 12357605, End 12357637)
function Md2() {
  return null
}
// @from(Start 12357639, End 12357671)
function Od2() {
  return null
}
// @from(Start 12357673, End 12357705)
function Rd2() {
  return null
}
// @from(Start 12357707, End 12357762)
function Td2() {
  return pTA.createElement(k5, null)
}
// @from(Start 12357764, End 12357869)
function Pd2(A, {
  verbose: Q
}) {
  return pTA.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 12357874, End 12357877)
pTA
// @from(Start 12357883, End 12357937)
jd2 = L(() => {
  yJ();
  iX();
  pTA = BA(VA(), 1)
})
// @from(Start 12357943, End 12357946)
Et5
// @from(Start 12357948, End 12357951)
zt5
// @from(Start 12357953, End 12357955)
nn
// @from(Start 12357961, End 12363298)
I71 = L(() => {
  Q2();
  cE();
  AZ();
  vRA();
  Ld2();
  jd2();
  q0();
  Et5 = j.object({
    command: j.string().describe('The slash command to execute with its arguments, e.g., "/review-pr 123"')
  }), zt5 = j.object({
    success: j.boolean().describe("Whether the slash command is valid"),
    commandName: j.string().describe("The name of the slash command")
  }), nn = {
    name: cP,
    inputSchema: Et5,
    outputSchema: zt5,
    description: async ({
      command: A
    }) => `Execute slash command: ${A}`,
    prompt: async () => Nd2(),
    userFacingName: () => cP,
    isConcurrencySafe: () => !1,
    isEnabled: () => !0,
    isReadOnly: () => !1,
    async validateInput({
      command: A
    }, Q) {
      let B = rJA(A);
      if (!B) return {
        result: !1,
        message: `Invalid slash command format: ${A}`,
        errorCode: 1
      };
      let {
        commandName: G
      } = B, Z = await sE();
      if (!ph(G, Z)) return {
        result: !1,
        message: `Unknown slash command: ${G}`,
        errorCode: 2
      };
      let I = Pq(G, Z);
      if (!I) return {
        result: !1,
        message: `Could not load slash command: ${G}`,
        errorCode: 3
      };
      if (I.disableModelInvocation) return {
        result: !1,
        message: `Slash command ${G} cannot be used with ${cP} tool due to disable-model-invocation`,
        errorCode: 4
      };
      if (I.type !== "prompt") return {
        result: !1,
        message: `Slash command ${G} is not a prompt-based command`,
        errorCode: 5
      };
      return {
        result: !0
      }
    },
    async checkPermissions({
      command: A
    }, Q) {
      let {
        commandName: B
      } = rJA(A) || {
        commandName: "unknown"
      }, Z = (await Q.getAppState()).toolPermissionContext, I = await sE(), Y = Pq(B, I), J = (K) => {
        if (K === A) return !0;
        if (K.endsWith(":*")) {
          let D = K.slice(0, -2);
          return A.startsWith(D)
        }
        return !1
      }, W = fU(Z, nn, "deny");
      for (let [K, D] of W.entries())
        if (J(K)) return {
          behavior: "deny",
          message: "Slash command execution blocked by permission rules",
          decisionReason: {
            type: "rule",
            rule: D
          }
        };
      let X = fU(Z, nn, "allow");
      for (let [K, D] of X.entries())
        if (J(K)) return {
          behavior: "allow",
          updatedInput: {
            command: A
          },
          decisionReason: {
            type: "rule",
            rule: D
          }
        };
      let V = [{
          type: "addRules",
          rules: [{
            toolName: cP,
            ruleContent: A
          }],
          behavior: "allow",
          destination: "localSettings"
        }],
        F = A.indexOf(" ");
      if (F > 0) {
        let K = A.substring(0, F);
        V.push({
          type: "addRules",
          rules: [{
            toolName: cP,
            ruleContent: `${K}:*`
          }],
          behavior: "allow",
          destination: "localSettings"
        })
      }
      return {
        behavior: "ask",
        message: `Execute slash command: /${B}`,
        decisionReason: void 0,
        suggestions: V,
        metadata: {
          command: Y
        }
      }
    },
    async call({
      command: A
    }, Q, B, G) {
      let {
        commandName: Z,
        args: I
      } = rJA(A), Y = await sE(), J = await s61(Z, I, Y, Q);
      if (!J.shouldQuery) throw Error("Command processing failed");
      let W = J.allowedTools || [],
        X = J.model,
        V = J.maxThinkingTokens,
        F = Ny().has(Z) ? Z : "custom";
      GA("tengu_slash_command_tool_invocation", {
        command_name: F
      });
      let K = B71(G, cP),
        D = Q71(J.messages.filter((H) => H.type !== "progress"), K);
      return {
        data: {
          success: !0,
          commandName: Z
        },
        newMessages: D,
        contextModifier(H) {
          let C = H;
          if (W.length > 0) C = {
            ...C,
            async getAppState() {
              let E = await Q.getAppState();
              return {
                ...E,
                toolPermissionContext: {
                  ...E.toolPermissionContext,
                  alwaysAllowRules: {
                    ...E.toolPermissionContext.alwaysAllowRules,
                    command: [...new Set([...E.toolPermissionContext.alwaysAllowRules.command || [], ...W])]
                  }
                }
              }
            }
          };
          if (X) C = {
            ...C,
            options: {
              ...C.options,
              mainLoopModel: X
            }
          };
          if (V !== void 0) C = {
            ...C,
            options: {
              ...C.options,
              maxThinkingTokens: V
            }
          };
          return C
        }
      }
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      return {
        type: "tool_result",
        tool_use_id: Q,
        content: `Launching command: /${A.commandName}`
      }
    },
    renderToolResultMessage: Md2,
    renderToolUseMessage: Od2,
    renderToolUseProgressMessage: Rd2,
    renderToolUseRejectedMessage: Td2,
    renderToolUseErrorMessage: Pd2
  }
})
// @from(Start 12363301, End 12367185)
function Sd2(A) {
  let {
    toolUseConfirm: Q,
    onDone: B,
    onReject: G,
    verbose: Z
  } = A, Y = ((K) => {
    let D = ln.inputSchema.safeParse(K);
    if (!D.success) return AA(Error(`Failed to parse skill tool input: ${D.error.message}`)), "";
    return D.data.skill
  })(Q.input), J = Q.permissionResult.behavior === "ask" && Q.permissionResult.metadata && "command" in Q.permissionResult.metadata ? Q.permissionResult.metadata.command : void 0, W = LO.useMemo(() => ({
    completion_type: "tool_use_single",
    language_name: "none"
  }), []);
  V$(Q, W);
  let X = uQ(),
    V = LO.useMemo(() => {
      let K = [{
          label: "Yes",
          value: "yes"
        }],
        D = {
          label: `Yes, and don't ask again for ${tA.bold(Y)} in ${tA.bold(X)}`,
          value: "yes-exact"
        },
        H = Y.indexOf(" "),
        C = [];
      if (H > 0) {
        let U = Y.substring(0, H);
        C.push({
          label: `Yes, and don't ask again for ${tA.bold(U+":*")} commands in ${tA.bold(X)}`,
          value: "yes-prefix"
        })
      }
      let E = {
        label: `No, and tell Claude what to do differently ${tA.bold("(esc)")}`,
        value: "no"
      };
      return [...K, D, ...C, E]
    }, [Y, X]),
    F = (K) => {
      switch (K) {
        case "yes":
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          }), Q.onAllow(Q.input, []), B();
          break;
        case "yes-exact": {
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          }), Q.onAllow(Q.input, [{
            type: "addRules",
            rules: [{
              toolName: kq,
              ruleContent: Y
            }],
            behavior: "allow",
            destination: "localSettings"
          }]), B();
          break
        }
        case "yes-prefix": {
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          });
          let D = Y.indexOf(" "),
            H = D > 0 ? Y.substring(0, D) : Y;
          Q.onAllow(Q.input, [{
            type: "addRules",
            rules: [{
              toolName: kq,
              ruleContent: `${H}:*`
            }],
            behavior: "allow",
            destination: "localSettings"
          }]), B();
          break
        }
        case "no":
          CY({
            completion_type: "tool_use_single",
            event: "reject",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          }), Q.onReject(), G(), B();
          break
      }
    };
  return LO.default.createElement(uJ, {
    title: `Use skill "${Y}"?`
  }, LO.default.createElement($, null, "Claude may use instructions, code, or files from this Skill."), LO.default.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, LO.default.createElement($, {
    dimColor: !0
  }, J?.description)), LO.default.createElement(S, {
    flexDirection: "column"
  }, LO.default.createElement(VC, {
    permissionResult: Q.permissionResult,
    toolType: "tool"
  }), LO.default.createElement($, null, "Do you want to proceed?"), LO.default.createElement(M0, {
    options: V,
    onChange: F,
    onCancel: () => F("no")
  })))
}
// @from(Start 12367190, End 12367192)
LO
// @from(Start 12367198, End 12367324)
_d2 = L(() => {
  hA();
  J5();
  wO();
  xn();
  c5();
  _0();
  F9();
  vn();
  Gg();
  G71();
  g1();
  LO = BA(VA(), 1)
})
// @from(Start 12367327, End 12371143)
function kd2(A) {
  let {
    toolUseConfirm: Q,
    onDone: B,
    onReject: G,
    verbose: Z
  } = A, Y = ((K) => {
    let D = nn.inputSchema.safeParse(K);
    if (!D.success) return AA(Error(`Failed to parse slash command tool input: ${D.error.message}`)), "";
    return D.data.command
  })(Q.input), J = Q.permissionResult.behavior === "ask" && Q.permissionResult.metadata && "command" in Q.permissionResult.metadata ? Q.permissionResult.metadata.command : void 0, W = MO.useMemo(() => ({
    completion_type: "tool_use_single",
    language_name: "none"
  }), []);
  V$(Q, W);
  let X = uQ(),
    V = MO.useMemo(() => {
      let K = [{
          label: "Yes",
          value: "yes"
        }],
        D = {
          label: `Yes, and don't ask again for ${tA.bold(Y)} in ${tA.bold(X)}`,
          value: "yes-exact"
        },
        H = Y.indexOf(" "),
        C = [];
      if (H > 0) {
        let U = Y.substring(0, H);
        C.push({
          label: `Yes, and don't ask again for ${tA.bold(U+":*")} commands in ${tA.bold(X)}`,
          value: "yes-prefix"
        })
      }
      let E = {
        label: `No, and tell Claude what to do differently ${tA.bold("(esc)")}`,
        value: "no"
      };
      return [...K, D, ...C, E]
    }, [Y, X]),
    F = (K) => {
      switch (K) {
        case "yes":
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          }), Q.onAllow(Q.input, []), B();
          break;
        case "yes-exact": {
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          }), Q.onAllow(Q.input, [{
            type: "addRules",
            rules: [{
              toolName: cP,
              ruleContent: Y
            }],
            behavior: "allow",
            destination: "localSettings"
          }]), B();
          break
        }
        case "yes-prefix": {
          CY({
            completion_type: "tool_use_single",
            event: "accept",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          });
          let D = Y.indexOf(" "),
            H = D > 0 ? Y.substring(0, D) : Y;
          Q.onAllow(Q.input, [{
            type: "addRules",
            rules: [{
              toolName: cP,
              ruleContent: `${H}:*`
            }],
            behavior: "allow",
            destination: "localSettings"
          }]), B();
          break
        }
        case "no":
          CY({
            completion_type: "tool_use_single",
            event: "reject",
            metadata: {
              language_name: "none",
              message_id: Q.assistantMessage.message.id,
              platform: d0.platform
            }
          }), Q.onReject(), G(), B();
          break
      }
    };
  return MO.default.createElement(uJ, {
    title: cP
  }, MO.default.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, MO.default.createElement($, null, Y), MO.default.createElement($, {
    dimColor: !0
  }, J?.description)), MO.default.createElement(S, {
    flexDirection: "column"
  }, MO.default.createElement(VC, {
    permissionResult: Q.permissionResult,
    toolType: "tool"
  }), MO.default.createElement($, null, "Do you want to proceed?"), MO.default.createElement(M0, {
    options: V,
    onChange: F,
    onCancel: () => F("no")
  })))
}
// @from(Start 12371148, End 12371150)
MO
// @from(Start 12371156, End 12371282)
yd2 = L(() => {
  hA();
  J5();
  wO();
  xn();
  c5();
  _0();
  F9();
  vn();
  Gg();
  I71();
  g1();
  MO = BA(VA(), 1)
})
// @from(Start 12371285, End 12371780)
function $t5({
  answers: A
}) {
  return tY.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, tY.createElement(S, {
    flexDirection: "row"
  }, tY.createElement($, {
    color: ZS("default")
  }, rD, " "), tY.createElement($, null, "User answered Claude's questions:")), tY.createElement(S0, null, tY.createElement(S, {
    flexDirection: "column"
  }, Object.entries(A).map(([Q, B]) => tY.createElement($, {
    key: Q,
    color: "inactive"
  }, "· ", Q, " → ", B)))))
}
// @from(Start 12371785, End 12371787)
tY
// @from(Start 12371789, End 12371792)
Ut5
// @from(Start 12371794, End 12371797)
xd2
// @from(Start 12371799, End 12371802)
ZZ0
// @from(Start 12371804, End 12371807)
GKZ
// @from(Start 12371809, End 12371812)
Y71
// @from(Start 12371818, End 12375713)
J71 = L(() => {
  Q2();
  hA();
  q8();
  dn();
  Zw();
  _0();
  hQ();
  tY = BA(VA(), 1), Ut5 = j.object({
    label: j.string().describe("The display text for this option that the user will see and select. Should be concise (1-5 words) and clearly describe the choice."),
    description: j.string().describe("Explanation of what this option means or what will happen if chosen. Useful for providing context about trade-offs or implications.")
  }), xd2 = j.object({
    question: j.string().describe('The complete question to ask the user. Should be clear, specific, and end with a question mark. Example: "Which library should we use for date formatting?" If multiSelect is true, phrase it accordingly, e.g. "Which features do you want to enable?"'),
    header: j.string().describe(`Very short label displayed as a chip/tag (max ${lm2} chars). Examples: "Auth method", "Library", "Approach".`),
    options: j.array(Ut5).min(2).max(4).describe("The available choices for this question. Must have 2-4 options. Each option should be a distinct, mutually exclusive choice (unless multiSelect is enabled). There should be no 'Other' option, that will be provided automatically."),
    multiSelect: j.boolean().describe("Set to true to allow the user to select multiple options instead of just one. Use when choices are not mutually exclusive.")
  }), ZZ0 = j.strictObject({
    questions: j.array(xd2).min(1).max(4).describe("Questions to ask the user (1-4 questions)"),
    answers: j.record(j.string(), j.string()).optional().describe("User answers collected by the permission component")
  }).refine((A) => {
    let Q = A.questions.map((B) => B.question);
    if (Q.length !== new Set(Q).size) return !1;
    for (let B of A.questions) {
      let G = B.options.map((Z) => Z.label);
      if (G.length !== new Set(G).size) return !1
    }
    return !0
  }, {
    message: "Question texts must be unique, option labels must be unique within each question"
  }), GKZ = j.object({
    questions: j.array(xd2).describe("The questions that were asked"),
    answers: j.record(j.string(), j.string()).describe("The answers provided by the user (question text -> answer string; multi-select answers are comma-separated)")
  });
  Y71 = {
    name: pJ,
    async description() {
      return im2
    },
    async prompt() {
      return nm2
    },
    inputSchema: ZZ0,
    userFacingName() {
      return ""
    },
    isEnabled() {
      return wkA() || Y0(process.env.CLAUDE_CODE_ENABLE_ASK_USER_QUESTION_TOOL)
    },
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    requiresUserInteraction() {
      return !0
    },
    async checkPermissions(A) {
      return {
        behavior: "ask",
        message: "Answer questions?",
        updatedInput: A
      }
    },
    renderToolUseMessage() {
      return null
    },
    renderToolUseProgressMessage() {
      return null
    },
    renderToolResultMessage({
      answers: A
    }, Q) {
      return tY.createElement($t5, {
        answers: A
      })
    },
    renderToolUseRejectedMessage() {
      return tY.createElement(S, {
        flexDirection: "row",
        marginTop: 1
      }, tY.createElement($, {
        color: ZS("default")
      }, rD, " "), tY.createElement($, null, "User declined to answer questions"))
    },
    renderToolUseErrorMessage() {
      return null
    },
    async call({
      questions: A,
      answers: Q = {}
    }, B) {
      return {
        data: {
          questions: A,
          answers: Q
        }
      }
    },
    mapToolResultToToolResultBlockParam({
      answers: A
    }, Q) {
      return {
        type: "tool_result",
        content: `User has answered your questions: ${Object.entries(A).map(([G,Z])=>`"${G}"="${Z}"`).join(", ")}. You can now continue with the user's answers in mind.`,
        tool_use_id: Q
      }
    }
  }
})
// @from(Start 12375716, End 12376885)
function wt5(A, Q) {
  switch (Q.type) {
    case "next-question":
      return {
        ...A, currentQuestionIndex: A.currentQuestionIndex + 1, isInTextInput: !1
      };
    case "prev-question":
      return {
        ...A, currentQuestionIndex: Math.max(0, A.currentQuestionIndex - 1), isInTextInput: !1
      };
    case "update-question-state": {
      let B = A.questionStates[Q.questionText],
        G = {
          selectedValue: Q.updates.selectedValue ?? B?.selectedValue ?? (Q.isMultiSelect ? [] : void 0),
          textInputValue: Q.updates.textInputValue ?? B?.textInputValue ?? ""
        };
      return {
        ...A,
        questionStates: {
          ...A.questionStates,
          [Q.questionText]: G
        }
      }
    }
    case "set-answer": {
      let B = {
        ...A,
        answers: {
          ...A.answers,
          [Q.questionText]: Q.answer
        }
      };
      if (Q.shouldAdvance) return {
        ...B,
        currentQuestionIndex: B.currentQuestionIndex + 1,
        isInTextInput: !1
      };
      return B
    }
    case "set-text-input-mode":
      return {
        ...A, isInTextInput: Q.isInInput
      }
  }
}
// @from(Start 12376887, End 12377800)
function vd2() {
  let [A, Q] = an.useReducer(wt5, qt5), B = an.useCallback(() => {
    Q({
      type: "next-question"
    })
  }, []), G = an.useCallback(() => {
    Q({
      type: "prev-question"
    })
  }, []), Z = an.useCallback((J, W, X) => {
    Q({
      type: "update-question-state",
      questionText: J,
      updates: W,
      isMultiSelect: X
    })
  }, []), I = an.useCallback((J, W, X = !0) => {
    Q({
      type: "set-answer",
      questionText: J,
      answer: W,
      shouldAdvance: X
    })
  }, []), Y = an.useCallback((J) => {
    Q({
      type: "set-text-input-mode",
      isInInput: J
    })
  }, []);
  return {
    currentQuestionIndex: A.currentQuestionIndex,
    answers: A.answers,
    questionStates: A.questionStates,
    isInTextInput: A.isInTextInput,
    nextQuestion: B,
    prevQuestion: G,
    updateQuestionState: Z,
    setAnswer: I,
    setTextInputMode: Y
  }
}
// @from(Start 12377805, End 12377807)
an
// @from(Start 12377809, End 12377812)
qt5
// @from(Start 12377818, End 12377962)
bd2 = L(() => {
  an = BA(VA(), 1);
  qt5 = {
    currentQuestionIndex: 0,
    answers: {},
    questionStates: {},
    isInTextInput: !1
  }
})
// @from(Start 12377965, End 12380171)
function W71({
  questions: A,
  currentQuestionIndex: Q,
  answers: B,
  hideSubmitTab: G = !1
}) {
  let {
    columns: Z
  } = WB(), I = OO.useMemo(() => {
    let X = G ? "" : ` ${H1.tick} Submit `,
      V = 2,
      F = 2,
      K = $D("← ") + $D(" →") + $D(X),
      D = Z - K;
    if (D <= 0) return A.map((v, x) => {
      let p = v?.header || `Q${x+1}`;
      return x === Q ? p.slice(0, 3) : ""
    });
    let H = A.map((v, x) => v?.header || `Q${x+1}`);
    if (H.map((v) => 4 + $D(v)).reduce((v, x) => v + x, 0) <= D) return H;
    let U = H[Q] || "",
      q = 4 + $D(U),
      w = 6,
      N = Math.min(q, D / 2),
      R = D - N,
      T = A.length - 1,
      y = Math.max(w, Math.floor(R / Math.max(T, 1)));
    return H.map((v, x) => {
      if (x === Q) {
        let p = N - 2 - 2;
        if ($D(v) <= p) return v;
        let u = v;
        while ($D(u + "…") > p && u.length > 1) u = u.slice(0, -1);
        return u + "…"
      } else {
        let p = y - 2 - 2;
        if ($D(v) <= p) return v;
        let u = v;
        while ($D(u + "…") > p && u.length > 1) u = u.slice(0, -1);
        return u.length > 0 ? u + "…" : v[0] + "…"
      }
    })
  }, [A, Q, Z, G]), Y = A.length === 1 && G;
  return OO.default.createElement(S, {
    flexDirection: "row",
    marginBottom: 1
  }, !Y && OO.default.createElement($, {
    color: Q === 0 ? "inactive" : void 0
  }, "←", " "), A.map((J, W) => {
    let X = W === Q,
      F = J?.question && !!B[J.question] ? H1.checkboxOn : H1.checkboxOff,
      K = I[W] || J?.header || `Q${W+1}`;
    return OO.default.createElement(S, {
      key: J?.question || `question-${W}`
    }, X ? OO.default.createElement($, {
      backgroundColor: "permission",
      color: "inverseText"
    }, " ", F, " ", K, " ") : OO.default.createElement($, null, " ", F, " ", K, " "))
  }), !G && OO.default.createElement(S, {
    key: "submit"
  }, Q === A.length ? OO.default.createElement($, {
    backgroundColor: "permission",
    color: "inverseText"
  }, " ", H1.tick, " Submit", " ") : OO.default.createElement($, null, " ", H1.tick, " Submit ")), !Y && OO.default.createElement($, {
    color: Q === A.length ? "inactive" : void 0
  }, " ", "→"))
}
// @from(Start 12380176, End 12380178)
OO
// @from(Start 12380184, End 12380254)
IZ0 = L(() => {
  V9();
  hA();
  i8();
  jUA();
  OO = BA(VA(), 1)
})
// @from(Start 12380257, End 12382603)
function fd2({
  question: A,
  questions: Q,
  currentQuestionIndex: B,
  answers: G,
  questionStates: Z,
  hideSubmitTab: I = !1,
  onUpdateQuestionState: Y,
  onAnswer: J,
  onTextInputFocus: W,
  onCancel: X,
  onSubmit: V
}) {
  let F = mq.useCallback((U) => {
      W(U === "__other__")
    }, [W]),
    K = A.options.map((U) => ({
      type: "text",
      value: U.label,
      label: U.label,
      description: U.description
    })),
    D = A.question,
    H = Z[D],
    C = {
      type: "input",
      value: "__other__",
      label: "Other",
      placeholder: A.multiSelect ? "Type something" : "Type something.",
      initialValue: H?.textInputValue ?? "",
      onChange: (U) => {
        Y(D, {
          textInputValue: U
        }, A.multiSelect ?? !1)
      }
    },
    E = [...K, C];
  return mq.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, mq.default.createElement(D3, {
    dividerColor: "inactive"
  }), mq.default.createElement(S, {
    flexDirection: "column",
    paddingTop: 0
  }, mq.default.createElement(W71, {
    questions: Q,
    currentQuestionIndex: B,
    answers: G,
    hideSubmitTab: I
  }), mq.default.createElement(xWA, {
    title: A.question,
    color: "text"
  }), mq.default.createElement(S, {
    marginTop: 1
  }, A.multiSelect ? mq.default.createElement(PQ0, {
    key: A.question,
    options: E,
    defaultValue: Z[A.question]?.selectedValue,
    onChange: (U) => {
      Y(D, {
        selectedValue: U
      }, !0);
      let q = U.includes("__other__") ? Z[D]?.textInputValue : void 0,
        w = U.filter((N) => N !== "__other__").concat(q ? [q] : []);
      J(D, w, void 0, !1)
    },
    onFocus: F,
    onCancel: X,
    submitButtonText: B === Q.length - 1 ? "Submit" : "Next",
    onSubmit: V
  }) : mq.default.createElement(M0, {
    key: A.question,
    options: E,
    defaultValue: Z[A.question]?.selectedValue,
    onChange: (U) => {
      Y(D, {
        selectedValue: U
      }, !1);
      let q = U === "__other__" ? Z[D]?.textInputValue : void 0;
      J(D, U, q)
    },
    onFocus: F,
    onCancel: X,
    layout: "compact-vertical"
  })), mq.default.createElement(S, {
    marginTop: 1
  }, mq.default.createElement($, {
    color: "inactive",
    dimColor: !0
  }, "Enter to select · Tab/Arrow keys to navigate · Esc to cancel"))))
}
// @from(Start 12382608, End 12382610)
mq
// @from(Start 12382616, End 12382695)
hd2 = L(() => {
  hA();
  J5();
  Z31();
  IZ0();
  BK();
  mq = BA(VA(), 1)
})
// @from(Start 12382698, End 12384633)
function gd2({
  questions: A,
  currentQuestionIndex: Q,
  answers: B,
  allQuestionsAnswered: G,
  permissionResult: Z,
  onFinalResponse: I
}) {
  return EK.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, EK.default.createElement(D3, {
    dividerColor: "inactive"
  }), EK.default.createElement(S, {
    flexDirection: "column",
    borderTop: !0,
    borderColor: "inactive",
    paddingTop: 0
  }, EK.default.createElement(W71, {
    questions: A,
    currentQuestionIndex: Q,
    answers: B
  }), EK.default.createElement(xWA, {
    title: "Review your answers",
    color: "text"
  }), EK.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, !G && EK.default.createElement(S, {
    marginBottom: 1
  }, EK.default.createElement($, {
    color: "warning"
  }, H1.warning, " You have not answered all questions")), Object.keys(B).length > 0 && EK.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, A.filter((Y) => Y?.question && B[Y.question]).map((Y) => {
    let J = B[Y?.question];
    return EK.default.createElement(S, {
      key: Y?.question || "answer",
      flexDirection: "column",
      marginLeft: 1
    }, EK.default.createElement($, null, H1.bullet, " ", Y?.question || "Question"), EK.default.createElement(S, {
      marginLeft: 2
    }, EK.default.createElement($, {
      color: "success"
    }, H1.arrowRight, " ", J)))
  })), EK.default.createElement(VC, {
    permissionResult: Z,
    toolType: "tool"
  }), EK.default.createElement($, {
    color: "inactive"
  }, "Ready to submit your answers?"), EK.default.createElement(S, {
    marginTop: 1
  }, EK.default.createElement(M0, {
    options: [{
      type: "text",
      label: "Submit answers",
      value: "submit"
    }, {
      type: "text",
      label: "Cancel",
      value: "cancel"
    }],
    onChange: (Y) => I(Y),
    onCancel: () => I("cancel")
  })))))
}
// @from(Start 12384638, End 12384640)
EK
// @from(Start 12384646, End 12384741)
ud2 = L(() => {
  V9();
  hA();
  J5();
  Z31();
  Gg();
  IZ0();
  BK();
  EK = BA(VA(), 1)
})
// @from(Start 12384744, End 12386766)
function md2({
  toolUseConfirm: A,
  onDone: Q,
  onReject: B
}) {
  let G = ZZ0.safeParse(A.input),
    Z = G.success ? G.data.questions || [] : [],
    I = vd2(),
    {
      currentQuestionIndex: Y,
      answers: J,
      questionStates: W,
      isInTextInput: X,
      nextQuestion: V,
      prevQuestion: F,
      updateQuestionState: K,
      setAnswer: D,
      setTextInputMode: H
    } = I,
    C = Y < (Z?.length || 0) ? Z?.[Y] : null,
    E = Y === (Z?.length || 0),
    U = Z?.every((y) => y?.question && !!J[y.question]) ?? !1,
    q = Z.length === 1 && !Z[0]?.multiSelect,
    w = c0A.useCallback(() => {
      Q(), B(), A.onReject()
    }, [Q, B, A]),
    N = c0A.useCallback((y) => {
      let v = {
        ...A.input,
        answers: y
      };
      Q(), A.onAllow(v, [])
    }, [A, Q]),
    R = c0A.useCallback((y, v, x, p = !0) => {
      let u, e = Array.isArray(v);
      if (e) u = v.join(", ");
      else u = x || v;
      let l = Z.length === 1;
      if (!e && l && p) {
        let k = {
          ...J,
          [y]: u
        };
        N(k);
        return
      }
      D(y, u, p)
    }, [D, Z.length, J, N]);

  function T(y) {
    if (y === "cancel") {
      w();
      return
    }
    if (y === "submit") N(J)
  }
  if (f1((y, v) => {
      if (X && !E) return;
      if (v.return) return;
      if ((v.leftArrow || v.shift && v.tab) && Y > 0) F();
      let x = q ? (Z?.length || 1) - 1 : Z?.length || 0;
      if ((v.rightArrow || v.tab && !v.shift) && Y < x) V()
    }), C) return c0A.default.createElement(fd2, {
    question: C,
    questions: Z,
    currentQuestionIndex: Y,
    answers: J,
    questionStates: W,
    hideSubmitTab: q,
    onUpdateQuestionState: K,
    onAnswer: R,
    onTextInputFocus: H,
    onCancel: w,
    onSubmit: V
  });
  if (E) return c0A.default.createElement(gd2, {
    questions: Z,
    currentQuestionIndex: Y,
    answers: J,
    allQuestionsAnswered: U,
    permissionResult: A.permissionResult,
    onFinalResponse: T
  });
  return null
}
// @from(Start 12386771, End 12386774)
c0A
// @from(Start 12386780, End 12386862)
dd2 = L(() => {
  hA();
  J71();
  bd2();
  hd2();
  ud2();
  c0A = BA(VA(), 1)
})
// @from(Start 12386865, End 12387302)
function Nt5(A) {
  switch (A) {
    case lD:
      return hf2;
    case QV:
      return ef2;
    case D9:
      return af2;
    case nV:
      return gm2;
    case kP:
      return cm2;
    case gq:
      return Gd2;
    case cTA:
      return Dd2;
    case ln:
      return Sd2;
    case nn:
      return kd2;
    case Y71:
      return md2;
    case zO:
    case Py:
    case n8:
      return Qh2;
    default:
      return F31
  }
}
// @from(Start 12387304, End 12387634)
function Lt5(A) {
  let Q = A.tool.userFacingName(A.input);
  if (A.tool === gq) return "Claude Code needs your approval for the plan";
  if (A.tool === cTA) return "Claude Code wants to enter plan mode";
  if (!Q || Q.trim() === "") return "Claude Code needs your attention";
  return `Claude needs your permission to use ${Q}`
}
// @from(Start 12387636, End 12388017)
function cd2({
  toolUseConfirm: A,
  toolUseContext: Q,
  onDone: B,
  onReject: G,
  verbose: Z
}) {
  f1((J, W) => {
    if (W.ctrl && J === "c") B(), G(), A.onReject()
  });
  let I = Lt5(A);
  K31(I, "permission_prompt");
  let Y = Nt5(A.tool);
  return YZ0.createElement(Y, {
    toolUseContext: Q,
    toolUseConfirm: A,
    onDone: B,
    onReject: G,
    verbose: Z
  })
}
// @from(Start 12388022, End 12388025)
YZ0
// @from(Start 12388031, End 12388307)
pd2 = L(() => {
  hA();
  zn();
  rh();
  pF();
  gf2();
  sf2();
  T70();
  j70();
  Ah2();
  Bh2();
  DWA();
  KTA();
  VTA();
  Dq();
  oWA();
  um2();
  pm2();
  dTA();
  Zd2();
  GZ0();
  Hd2();
  G71();
  I71();
  _d2();
  yd2();
  J71();
  dd2();
  YZ0 = BA(VA(), 1)
})
// @from(Start 12388310, End 12389769)
function Ot5(A) {
  if (lTA(A)) return j.enum(A.enum);
  if (A.type === "string") {
    let Q = j.string();
    if (A.minLength !== void 0) Q = Q.min(A.minLength, {
      message: `Must be at least ${A.minLength} character${A.minLength===1?"":"s"}`
    });
    if (A.maxLength !== void 0) Q = Q.max(A.maxLength, {
      message: `Must be at most ${A.maxLength} character${A.maxLength===1?"":"s"}`
    });
    switch (A.format) {
      case "email":
        Q = Q.email({
          message: "Please enter a valid email address"
        });
        break;
      case "uri":
        Q = Q.url({
          message: "Please enter a valid URI"
        });
        break;
      case "date":
        Q = Q.date("Please enter a valid date (YYYY-MM-DD)");
        break;
      case "date-time":
        Q = Q.datetime({
          offset: !0,
          message: "Please enter a valid date-time (YYYY-MM-DDTHH:MM:SSZ)"
        });
        break;
      default:
        break
    }
    return Q
  }
  if (A.type === "number" || A.type === "integer") {
    let Q = j.coerce.number();
    if (A.type === "integer") Q = Q.int();
    if (A.minimum !== void 0) Q = Q.min(A.minimum, {
      message: `Must be at least ${A.minimum}`
    });
    if (A.maximum !== void 0) Q = Q.max(A.maximum, {
      message: `Must be at most ${A.maximum}`
    });
    return Q
  }
  if (A.type === "boolean") return j.coerce.boolean();
  throw Error(`Unsupported schema: ${JSON.stringify(A)}`)
}
// @from(Start 12389771, End 12389981)
function JZ0(A, Q) {
  let G = Ot5(Q).safeParse(A);
  if (G.success) return {
    value: G.data,
    isValid: !0
  };
  return {
    isValid: !1,
    error: G.error.errors.map((Z) => Z.message).join("; ")
  }
}
// @from(Start 12389983, End 12390713)
function ld2(A) {
  if (A.type === "string") {
    if (!Rt5(A)) return;
    let {
      description: Q,
      example: B
    } = Mt5[A.format] || {};
    return `${Q}, e.g. ${B}`
  }
  if (A.type === "number" || A.type === "integer") {
    let Q = A.type === "integer",
      B = (G) => Number.isInteger(G) && !Q ? `${G}.0` : String(G);
    if (A.minimum !== void 0 && A.maximum !== void 0) return `(${A.type} between ${B(A.minimum)} and ${B(A.maximum)})`;
    else if (A.minimum !== void 0) return `(${A.type} >= ${B(A.minimum)})`;
    else if (A.maximum !== void 0) return `(${A.type} <= ${B(A.maximum)})`;
    else {
      let G = A.type === "integer" ? "42" : "3.14";
      return `(${A.type}, e.g. ${G})`
    }
  }
  return
}
// @from(Start 12390718, End 12390721)
Mt5
// @from(Start 12390723, End 12390787)
lTA = (A) => {
    return A.type === "string" && "enum" in A
  }
// @from(Start 12390791, End 12390889)
Rt5 = (A) => {
    return A.type === "string" && "format" in A && typeof A.format === "string"
  }
// @from(Start 12390895, End 12391275)
id2 = L(() => {
  Q2();
  Mt5 = {
    email: {
      description: "email address",
      example: "user@example.com"
    },
    uri: {
      description: "URI",
      example: "https://example.com"
    },
    date: {
      description: "date",
      example: "2024-03-15"
    },
    "date-time": {
      description: "date-time",
      example: "2024-03-15T14:30:00Z"
    }
  }
})
// @from(Start 12391278, End 12391384)
function X71() {
  return Z9.default.createElement($, {
    italic: !0,
    dimColor: !0
  }, "<unset>")
}
// @from(Start 12391386, End 12401207)
function ad2({
  serverName: A,
  request: Q,
  onResponse: B,
  signal: G
}) {
  let {
    message: Z,
    requestedSchema: I
  } = Q, [Y, J] = Z9.useState(null), [W, X] = Z9.useState(() => {
    let zA = {};
    if (I.properties) {
      for (let [NA, OA] of Object.entries(I.properties))
        if (typeof OA === "object" && OA !== null) {
          if (OA.default !== void 0) zA[NA] = OA.default
        }
    }
    return zA
  }), [V, F] = Z9.useState(() => {
    let zA = {};
    for (let [NA, OA] of Object.entries(I.properties))
      if (nd2(OA) && OA?.default !== void 0) {
        let mA = JZ0(String(OA.default), OA);
        if (!mA.isValid && mA.error) zA[NA] = mA.error
      } return zA
  });
  Z9.useEffect(() => {
    if (!G) return;
    let zA = () => {
      B("cancel")
    };
    if (G.aborted) {
      zA();
      return
    }
    return G.addEventListener("abort", zA), () => {
      G.removeEventListener("abort", zA)
    }
  }, [G, B]);
  let K = Z9.useMemo(() => {
      let zA = I.required ?? [];
      return Object.entries(I.properties).map(([NA, OA]) => ({
        name: NA,
        schema: OA,
        isRequired: zA.includes(NA)
      }))
    }, [I]),
    [D, H] = Z9.useState(0),
    [C, E] = Z9.useState(),
    [U, q] = Z9.useState(""),
    [w, N] = Z9.useState(0),
    {
      columns: R
    } = WB(),
    T = D !== void 0 ? K[D] : void 0,
    y = T && nd2(T.schema);
  EQ(), K31("Claude Code needs your input", "elicitation_dialog");

  function v(zA) {
    let NA = K.length + 2,
      OA = D ?? (Y === "accept" ? K.length : Y === "decline" ? K.length + 1 : void 0),
      mA = OA !== void 0 ? (OA + (zA === "up" ? NA - 1 : 1)) % NA : 0;
    if (mA < K.length) H(mA), J(null);
    else H(void 0), J(mA === K.length ? "accept" : "decline")
  }

  function x(zA, NA) {
    X((OA) => {
      let mA = {
        ...OA
      };
      if (NA === void 0) delete mA[zA];
      else mA[zA] = NA;
      return mA
    })
  }

  function p(zA, NA) {
    F((OA) => {
      let mA = {
        ...OA
      };
      if (NA) mA[zA] = NA;
      else delete mA[zA];
      return mA
    })
  }

  function u(zA) {
    if (!zA) return;
    x(zA, void 0), p(zA), E(void 0), q(""), N(0)
  }

  function e(zA) {
    if (!T) return;
    if (zA.trim() === "" && (T.schema.type !== "string" || ("format" in T.schema) && T.schema.format !== void 0)) {
      u(T.name), v("down");
      return
    }
    let OA = JZ0(zA, T.schema);
    x(T.name, OA.isValid ? OA.value : zA), p(T.name, OA.isValid ? void 0 : OA.error), E(void 0), q(""), N(0), v("down")
  }

  function l() {
    if (!T) return;
    E(void 0), q(""), N(0)
  }
  f1((zA, NA) => {
    if (T && C === T.name) {
      if (lTA(T?.schema)) return;
      if (y) {
        if (NA.escape && U === "") {
          l();
          return
        }
      }
    } else {
      if (NA.escape) {
        B("cancel");
        return
      }
      if (NA.return && Y === "accept") {
        if (k() && Object.keys(V).length === 0) B("accept", W);
        return
      }
      if (NA.return && Y === "decline") {
        B("decline");
        return
      }
      if (NA.upArrow || NA.downArrow) {
        v(NA.upArrow ? "up" : "down");
        return
      }
      if (T) {
        let {
          schema: OA,
          name: mA,
          isRequired: wA
        } = T, qA = W[mA];
        if (NA.backspace && !wA) {
          u(T.name);
          return
        }
        if (NA.return) {
          if (OA.type === "boolean") {
            x(mA, !(qA ?? !1)), v("down");
            return
          }
          if (E(mA), y) {
            let KA = qA !== void 0 ? String(qA) : "";
            q(KA), N(KA.length)
          }
        }
      }
    }
  }, {
    isActive: !0
  });
  let k = () => {
      let zA = I.required || [];
      for (let NA of zA) {
        let OA = W[NA];
        if (OA === void 0 || OA === null || OA === "") return !1
      }
      return !0
    },
    m = () => {
      if (!K.length) return null;
      return Z9.default.createElement(S, {
        flexDirection: "column",
        gap: 1
      }, K.map((zA, NA) => {
        let {
          name: OA,
          schema: mA,
          isRequired: wA
        } = zA, qA = NA === D && !Y, KA = W[OA], yA = (() => {
          if (!qA || C !== void 0) return null;
          let X1 = mA.type === "boolean" ? "toggle" : lTA(mA) ? "select" : "edit",
            WA = KA === void 0 || wA ? `(Press Enter to ${X1})` : `(Press Enter to ${X1}, Backspace to unset)`;
          return Z9.default.createElement($, {
            dimColor: !0
          }, " ", WA)
        })(), oA = (X1, WA) => {
          return Z9.default.createElement(S, {
            key: OA,
            flexDirection: "column"
          }, Z9.default.createElement(S, {
            gap: 1,
            paddingLeft: qA ? 0 : 2
          }, qA && Z9.default.createElement($, {
            color: "success"
          }, H1.pointer), Z9.default.createElement(S, {
            flexGrow: 1,
            flexDirection: "column"
          }, X1, mA.description && Z9.default.createElement(S, {
            marginLeft: 2
          }, Z9.default.createElement($, {
            dimColor: !0
          }, mA.description)), WA && Z9.default.createElement(S, {
            marginLeft: 2
          }, Z9.default.createElement($, {
            color: "error",
            bold: !0
          }, H1.warning, " ", WA)))))
        };
        if (lTA(mA)) {
          let X1 = mA.enum.map((WA, EA) => ({
            label: mA.enumNames?.[EA] ?? WA,
            value: WA
          }));
          if (qA && C === OA) return Z9.default.createElement(S, {
            key: OA,
            flexDirection: "column"
          }, Z9.default.createElement($, {
            color: "success"
          }, mA.title || OA, wA && Z9.default.createElement($, {
            color: "error"
          }, "*"), mA.description && Z9.default.createElement($, {
            dimColor: !0
          }, " - ", mA.description)), Z9.default.createElement(M0, {
            options: X1,
            defaultValue: KA !== void 0 ? KA : mA.default ?? mA.enum[0],
            onChange: (WA) => {
              x(OA, WA), E(void 0), v("down")
            },
            onCancel: () => {
              E(void 0)
            }
          }));
          else {
            let WA = mA.enum.findIndex((MA) => MA === KA),
              EA = KA !== void 0 ? WA >= 0 && mA.enumNames?.[WA] ? mA.enumNames[WA] : KA : Z9.default.createElement(X71, null);
            return oA(Z9.default.createElement($, {
              color: qA ? "success" : void 0
            }, mA.title || OA, wA && Z9.default.createElement($, {
              color: "error"
            }, "*"), ": ", EA, yA))
          }
        } else if (mA.type === "boolean") return oA(Z9.default.createElement($, {
          color: qA ? "success" : void 0
        }, mA.title || OA, wA && Z9.default.createElement($, {
          color: "error"
        }, "*"), ":", " ", KA !== void 0 ? KA ? `${H1.tick} Yes` : `${H1.cross} No` : Z9.default.createElement(X71, null), yA));
        else if (y) {
          let X1 = V[OA],
            WA = ld2(mA);
          if (qA && C === OA) return oA(Z9.default.createElement(S, {
            flexDirection: "column"
          }, Z9.default.createElement($, {
            color: "success"
          }, mA.title || OA, wA && Z9.default.createElement($, {
            color: "error"
          }, "*"), ":", WA && Z9.default.createElement($, {
            dimColor: !0
          }, ` ${WA}`)), Z9.default.createElement(S, {
            marginLeft: 2
          }, Z9.default.createElement(s4, {
            value: U,
            onChange: q,
            onSubmit: e,
            onExit: l,
            placeholder: `Enter ${mA.type}…`,
            columns: Math.min(R - 6, 80),
            cursorOffset: w,
            onChangeCursorOffset: N,
            focus: !0,
            showCursor: !0,
            multiline: mA.type === "string"
          }))));
          return oA(Z9.default.createElement($, {
            color: qA ? "success" : void 0
          }, mA.title || OA, wA && Z9.default.createElement($, {
            color: "error"
          }, "*"), ":", " ", KA === void 0 ? Z9.default.createElement(X71, null) : String(KA), yA), X1)
        } else return oA(Z9.default.createElement($, {
          color: qA ? "success" : void 0
        }, mA.title || OA, wA && Z9.default.createElement($, {
          color: "error"
        }, "*"), ":", " ", KA === void 0 ? Z9.default.createElement(X71, null) : String(KA), yA))
      }))
    },
    o = (zA) => {
      return I.properties[zA]?.title ?? zA
    },
    IA = Object.keys(V),
    FA = (I.required || []).filter((zA) => W[zA] === void 0);
  return Z9.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "permission"
  }, Z9.default.createElement($, {
    bold: !0
  }, H1.info, " MCP Server “", A, "” requests your input"), Z9.default.createElement(S, {
    padding: 1
  }, Z9.default.createElement($, null, Z)), m(), K.length > 0 && Z9.default.createElement(Z9.default.Fragment, null, FA.length > 0 && Z9.default.createElement($, {
    color: "error"
  }, H1.warning, " Missing required fields:", " ", FA.map(o).join(", ")), IA.length > 0 && Z9.default.createElement($, {
    color: "error"
  }, H1.warning, " Validation errors in:", " ", IA.map(o).join(", ")), Z9.default.createElement($, {
    bold: !0,
    color: Y === "accept" ? "success" : void 0,
    inverse: Y === "accept"
  }, "Accept"), Z9.default.createElement($, {
    bold: !0,
    color: Y === "decline" ? "error" : void 0,
    inverse: Y === "decline"
  }, "Decline"), Z9.default.createElement($, {
    dimColor: !0
  }, "Press ↑↓ to navigate · Enter to edit · Esc to cancel / go back")))
}
// @from(Start 12401212, End 12401214)
Z9
// @from(Start 12401216, End 12401277)
nd2 = (A) => ["string", "number", "integer"].includes(A.type)
// @from(Start 12401283, End 12401386)
sd2 = L(() => {
  hA();
  V9();
  Q4();
  j70();
  S5();
  id2();
  ZY();
  i8();
  Z9 = BA(VA(), 1)
})
// @from(Start 12401389, End 12401583)
function F71(A) {
  let [Q, B] = V71.useState(!1);
  return V71.useEffect(() => {
    B(!1);
    let G = setTimeout(() => {
      B(!0)
    }, A);
    return () => clearTimeout(G)
  }, [A]), Q
}
// @from(Start 12401588, End 12401591)
V71
// @from(Start 12401597, End 12401635)
WZ0 = L(() => {
  V71 = BA(VA(), 1)
})
// @from(Start 12401715, End 12401802)
function rd2() {
  return process.env.XDG_STATE_HOME ?? D71(K71(), ".local", "state")
}
// @from(Start 12401804, End 12401882)
function od2() {
  return process.env.XDG_CACHE_HOME ?? D71(K71(), ".cache")
}
// @from(Start 12401884, End 12401970)
function td2() {
  return process.env.XDG_DATA_HOME ?? D71(K71(), ".local", "share")
}
// @from(Start 12401972, End 12402027)
function ed2() {
  return D71(K71(), ".local", "bin")
}
// @from(Start 12402032, End 12402046)
Ac2 = () => {}
// @from(Start 12402289, End 12403075)
async function yt5(A = "stable", Q, B) {
  let G = Date.now(),
    Z = Q === H71;
  try {
    let I = await YQ.get(`${Q}/${A}`, {
        timeout: 30000,
        responseType: "text",
        ...B
      }),
      Y = Date.now() - G;
    return GA("tengu_version_check_success", {
      latency_ms: Y,
      source_gcs: Z
    }), I.data.trim()
  } catch (I) {
    let Y = Date.now() - G,
      J = I instanceof Error ? I.message : String(I),
      W;
    if (YQ.isAxiosError(I) && I.response) W = I.response.status;
    throw GA("tengu_version_check_failure", {
      latency_ms: Y,
      http_status: W,
      source_gcs: Z,
      is_timeout: J.includes("timeout")
    }), AA(Error(`Failed to fetch version from ${Q}/${A}: ${J}`)), Error(`Failed to fetch version from ${A}: ${I}`)
  }
}
// @from(Start 12403076, End 12403341)
async function VZ0(A) {
  if (A && /^v?\d+\.\d+\.\d+(-\S+)?$/.test(A)) return A.startsWith("v") ? A.slice(1) : A;
  let Q = A || "stable";
  if (Q !== "stable" && Q !== "latest") throw Error(`Invalid channel: ${A}. Use 'stable' or 'latest'`);
  return yt5(Q, H71)
}
// @from(Start 12403342, End 12403704)
async function xt5(A, Q, B, G = {}) {
  let Z = await YQ.get(A, {
      timeout: 300000,
      responseType: "arraybuffer",
      ...G
    }),
    I = Tt5("sha256");
  I.update(Z.data);
  let Y = I.digest("hex");
  if (Y !== Q) throw Error(`Checksum mismatch: expected ${Q}, got ${Y}`);
  (await import("fs")).writeFileSync(B, Buffer.from(Z.data)), jt5(B, 493)
}
// @from(Start 12403705, End 12404504)
async function vt5(A) {
  let Q = Date.now(),
    B;
  try {
    B = _t5(XZ0(Pt5(), "claude-cdn-dark-read-")), await Bc2(A, B, Qc2);
    let G = Date.now() - Q;
    GA("tengu_native_cdn_dark_read_success", {
      latency_ms: G
    }), g(`CDN dark read succeeded for ${A}`)
  } catch (G) {
    let Z = Date.now() - Q,
      I = G instanceof Error ? G.message : String(G),
      Y;
    if (YQ.isAxiosError(G) && G.response) Y = G.response.status;
    GA("tengu_native_cdn_dark_read_failure", {
      latency_ms: Z,
      http_status: Y,
      is_timeout: I.includes("timeout"),
      is_checksum_mismatch: I.includes("Checksum mismatch")
    }), AA(Error(`CDN dark read failed for ${A}: ${I}`))
  } finally {
    if (B) try {
      let G = iTA(by());
      St5(XZ0(B, G)), kt5(B)
    } catch {}
  }
}
// @from(Start 12404505, End 12406279)
async function Bc2(A, Q, B, G) {
  let Z = RA(),
    I = B === Qc2,
    Y = B === H71;
  if (Z.existsSync(Q)) Z.rmSync(Q, {
    recursive: !0,
    force: !0
  });
  let J = by(),
    W = Date.now();
  GA("tengu_binary_download_attempt", {
    is_cdn: I,
    is_gcs: Y
  });
  let X;
  try {
    X = (await YQ.get(`${B}/${A}/manifest.json`, {
      timeout: 1e4,
      responseType: "json",
      ...G
    })).data
  } catch (C) {
    let E = Date.now() - W,
      U = C instanceof Error ? C.message : String(C),
      q;
    if (YQ.isAxiosError(C) && C.response) q = C.response.status;
    throw GA("tengu_binary_manifest_fetch_failure", {
      latency_ms: E,
      http_status: q,
      is_cdn: I,
      is_gcs: Y,
      is_timeout: U.includes("timeout")
    }), AA(Error(`Failed to fetch manifest from ${B}/${A}/manifest.json: ${U}`)), C
  }
  let V = X.platforms[J];
  if (!V) throw GA("tengu_binary_platform_not_found", {
    is_cdn: I,
    is_gcs: Y
  }), Error(`Platform ${J} not found in manifest for version ${A}`);
  let F = V.checksum,
    K = iTA(J),
    D = `${B}/${A}/${J}/${K}`;
  Z.mkdirSync(Q);
  let H = XZ0(Q, K);
  try {
    await xt5(D, F, H, G || {});
    let C = Date.now() - W;
    GA("tengu_binary_download_success", {
      latency_ms: C,
      is_cdn: I,
      is_gcs: Y
    })
  } catch (C) {
    let E = Date.now() - W,
      U = C instanceof Error ? C.message : String(C),
      q;
    if (YQ.isAxiosError(C) && C.response) q = C.response.status;
    throw GA("tengu_binary_download_failure", {
      latency_ms: E,
      http_status: q,
      is_cdn: I,
      is_gcs: Y,
      is_timeout: U.includes("timeout"),
      is_checksum_mismatch: U.includes("Checksum mismatch")
    }), AA(Error(`Failed to download binary from ${D}: ${U}`)), C
  }
}
// @from(Start 12406280, End 12406356)
async function Gc2(A, Q) {
  return vt5(A), await Bc2(A, Q, H71), "binary"
}
// @from(Start 12406361, End 12406417)
Qc2 = "https://downloads.claude.ai/claude-code-releases"
// @from(Start 12406421, End 12406534)
H71 = "https://storage.googleapis.com/claude-code-dist-86c565f3-f756-42ad-8dfa-d59b1c096819/claude-code-releases"
// @from(Start 12406540, End 12406614)
Zc2 = L(() => {
  O3();
  AQ();
  _8();
  V0();
  q0();
  FZ0();
  g1()
})
// @from(Start 12406943, End 12407353)
function by() {
  let A = d0.platform,
    Q = process.arch === "x64" ? "x64" : process.arch === "arm64" ? "arm64" : null;
  if (!Q) {
    let B = Error(`Unsupported architecture: ${process.arch}`);
    throw g(`Native installer does not support architecture: ${process.arch}`, {
      level: "error"
    }), B
  }
  if (A === "linux" && WU.isMuslEnvironment()) return `linux-${Q}-musl`;
  return `${A}-${Q}`
}
// @from(Start 12407355, End 12407431)
function iTA(A) {
  return A.startsWith("win32") ? "claude.exe" : "claude"
}
// @from(Start 12407433, End 12407660)
function p0A() {
  let A = by(),
    Q = iTA(A);
  return {
    versions: dW(td2(), "claude", "versions"),
    staging: dW(od2(), "claude", "staging"),
    locks: dW(rd2(), "claude", "locks"),
    executable: dW(ed2(), Q)
  }
}
// @from(Start 12407662, End 12407873)
function eWA(A) {
  let Q = RA();
  if (!Q.existsSync(A)) return !1;
  let B = Q.statSync(A);
  if (!B.isFile() || B.size === 0) return !1;
  try {
    return ht5(A, ut5.X_OK), !0
  } catch {
    return !1
  }
}
// @from(Start 12407875, End 12408281)
function HZ0(A) {
  let Q = p0A(),
    B = RA();
  [Q.versions, Q.staging, Q.locks].forEach((Y) => {
    if (!B.existsSync(Y)) B.mkdirSync(Y)
  });
  let Z = fy(Q.executable);
  if (!B.existsSync(Z)) B.mkdirSync(Z);
  let I = dW(Q.versions, A);
  if (!B.existsSync(I)) B.writeFileSync(I, "", {
    flush: !0,
    encoding: "utf8"
  });
  return {
    stagingPath: dW(Q.staging, A),
    installPath: I
  }
}
// @from(Start 12408282, End 12409063)
async function KZ0(A, Q, B = 0) {
  let G = p0A(),
    Z = RA(),
    I = Wc2(G, A);
  if (!Z.existsSync(G.locks)) Z.mkdirSync(G.locks);
  let Y = null;
  try {
    try {
      Y = await DZ0.default.lock(A, {
        stale: 60000,
        retries: {
          retries: B,
          minTimeout: B > 0 ? 1000 : 100,
          maxTimeout: B > 0 ? 5000 : 500
        },
        lockfilePath: I,
        onCompromised: (J) => {
          g(`NON-FATAL: Version lock was compromised during operation: ${J.message}`, {
            level: "info"
          })
        }
      })
    } catch (J) {
      return Xc2(A, J), !1
    }
    try {
      return await Q(), !0
    } catch (J) {
      throw AA(J instanceof Error ? J : Error(String(J))), J
    }
  } finally {
    if (Y) await Y()
  }
}
// @from(Start 12409065, End 12409368)
function Jc2(A, Q) {
  let B = RA();
  if (!B.existsSync(fy(Q))) B.mkdirSync(fy(Q));
  let G = `${Q}.tmp.${process.pid}.${Date.now()}`;
  try {
    B.copyFileSync(A, G), gt5(G, 493), B.renameSync(G, Q)
  } catch (Z) {
    try {
      if (B.existsSync(G)) B.unlinkSync(G)
    } catch {}
    throw Z
  }
}
// @from(Start 12409370, End 12410420)
function it5(A, Q) {
  let B = RA();
  try {
    let G = dW(A, "node_modules", "@anthropic-ai"),
      I = B.readdirStringSync(G).find((J) => J.startsWith("claude-cli-native-"));
    if (!I) throw GA("tengu_native_install_package_failure", {
      stage_find_package: !0,
      error_package_not_found: !0
    }), Error("Could not find platform-specific native package");
    let Y = dW(G, I, "cli");
    if (!B.existsSync(Y)) throw GA("tengu_native_install_package_failure", {
      stage_binary_exists: !0,
      error_binary_not_found: !0
    }), Error(`Native binary not found at ${Y}`);
    Jc2(Y, Q), B.rmSync(A, {
      recursive: !0,
      force: !0
    }), GA("tengu_native_install_package_success", {})
  } catch (G) {
    let Z = G instanceof Error ? G.message : String(G);
    if (!Z.includes("Could not find platform-specific") && !Z.includes("Native binary not found")) GA("tengu_native_install_package_failure", {
      stage_atomic_move: !0,
      error_move_failed: !0
    });
    throw AA(G instanceof Error ? G : Error(Z)), G
  }
}
// @from(Start 12410422, End 12411118)
function nt5(A, Q) {
  let B = RA();
  try {
    let G = by(),
      Z = iTA(G),
      I = dW(A, Z);
    if (!B.existsSync(I)) throw GA("tengu_native_install_binary_failure", {
      stage_binary_exists: !0,
      error_binary_not_found: !0
    }), Error(`Staged binary not found at ${I}`);
    Jc2(I, Q), B.rmSync(A, {
      recursive: !0,
      force: !0
    }), GA("tengu_native_install_binary_success", {})
  } catch (G) {
    let Z = G instanceof Error ? G.message : String(G);
    if (!Z.includes("Staged binary not found")) GA("tengu_native_install_binary_failure", {
      stage_atomic_move: !0,
      error_move_failed: !0
    });
    throw AA(G instanceof Error ? G : Error(Z)), G
  }
}
// @from(Start 12411120, End 12411250)
function at5(A, Q) {
  let {
    stagingPath: B,
    installPath: G
  } = HZ0(A);
  if (Q === "npm") it5(B, G);
  else nt5(B, G)
}
// @from(Start 12411252, End 12411328)
function st5(A) {
  let {
    installPath: Q
  } = HZ0(A);
  return eWA(Q)
}
// @from(Start 12411329, End 12412202)
async function rt5(A, Q = !1) {
  let B = Date.now(),
    G = await VZ0(A),
    {
      installPath: Z,
      stagingPath: I
    } = HZ0(G);
  g(`Checking for native installer update to version ${G}`);
  let Y = !1,
    J = await KZ0(Z, async () => {
      if (!st5(G) || Q) {
        Y = !0, g(Q ? `Force reinstalling native installer version ${G}` : `Downloading native installer version ${G}`);
        let V = await Gc2(G, I);
        at5(G, V)
      } else g(`Version ${G} already installed, updating symlink`);
      let X = p0A();
      ot5(X.executable), tt5(X.executable, Z)
    }, 3),
    W = Date.now() - B;
  if (!J) return GA("tengu_native_update_lock_failed", {
    latency_ms: W
  }), !1;
  return GA("tengu_native_update_complete", {
    latency_ms: W,
    was_new_install: Y,
    was_force_reinstall: Q
  }), g(`Successfully updated to version ${G}`), !0
}
// @from(Start 12412204, End 12412507)
function ot5(A) {
  let Q = RA();
  try {
    if (Q.existsSync(A)) {
      if (Q.statSync(A).isDirectory()) {
        if (Q.readdirStringSync(A).length === 0) Q.rmdirSync(A), g(`Removed empty directory at ${A}`)
      }
    }
  } catch (B) {
    g(`Could not remove empty directory at ${A}: ${B}`)
  }
}
// @from(Start 12412509, End 12414214)
function tt5(A, Q) {
  let B = RA();
  if (by().startsWith("win32")) try {
    let J = fy(A);
    if (!B.existsSync(J)) B.mkdirSync(J);
    if (B.existsSync(A)) {
      try {
        let X = B.statSync(A),
          V = B.statSync(Q);
        if (X.size === V.size) return !1
      } catch {}
      let W = `${A}.old.${Date.now()}`;
      B.renameSync(A, W);
      try {
        B.copyFileSync(Q, A);
        try {
          B.unlinkSync(W)
        } catch {}
      } catch (X) {
        try {
          B.renameSync(W, A)
        } catch (V) {
          let F = Error(`Failed to restore old executable: ${V}`, {
            cause: X
          });
          throw AA(F), F
        }
        throw X
      }
    } else {
      if (!B.existsSync(Q)) throw Error(`Source file does not exist: ${Q}`);
      B.copyFileSync(Q, A)
    }
    return !0
  } catch (J) {
    return AA(Error(`Failed to copy executable from ${Q} to ${A}: ${J}`)), !1
  }
  let I = fy(A);
  if (!B.existsSync(I)) try {
    B.mkdirSync(I), g(`Created directory ${I} for symlink`)
  } catch (J) {
    return AA(Error(`Failed to create directory ${I}: ${J}`)), !1
  }
  try {
    if (B.existsSync(A)) {
      try {
        let J = B.readlinkSync(A),
          W = hy(fy(A), J),
          X = hy(Q);
        if (W === X) return !1
      } catch {}
      B.unlinkSync(A)
    }
  } catch (J) {
    AA(Error(`Failed to check/remove existing symlink: ${J}`))
  }
  let Y = `${A}.tmp.${process.pid}.${Date.now()}`;
  try {
    return B.symlinkSync(Q, Y), B.renameSync(Y, A), !0
  } catch (J) {
    try {
      if (B.existsSync(Y)) B.unlinkSync(Y)
    } catch {}
    return AA(Error(`Failed to create symlink from ${A} to ${Q}: ${J}`)), !1
  }
}
// @from(Start 12414215, End 12414336)
async function nTA() {
  if (N1().installMethod === "native") return !0;
  return await hX("tengu_native_installation")
}
// @from(Start 12414337, End 12416690)
async function gy(A = !1) {
  if (Y0(process.env.DISABLE_INSTALLATION_CHECKS)) return [];
  let Q = await Nk(),
    B = N1();
  if (!(A || Q === "native" || B.installMethod === "native")) return [];
  let Z = RA(),
    I = p0A(),
    Y = [],
    J = fy(I.executable),
    W = hy(J),
    V = by().startsWith("win32");
  if (!Z.existsSync(J)) Y.push({
    message: `installMethod is native, but directory ${J} does not exist`,
    userActionRequired: !0,
    type: "error"
  });
  if (!Z.existsSync(I.executable)) Y.push({
    message: `installMethod is native, but claude command not found at ${I.executable}`,
    userActionRequired: !0,
    type: "error"
  });
  else if (!V) try {
    let K = Z.readlinkSync(I.executable),
      D = hy(fy(I.executable), K);
    if (!Z.existsSync(D)) Y.push({
      message: `Claude symlink points to non-existent file: ${K}`,
      userActionRequired: !0,
      type: "error"
    });
    else if (!eWA(D)) Y.push({
      message: `Claude symlink points to invalid binary: ${K}`,
      userActionRequired: !0,
      type: "error"
    })
  } catch {
    if (!eWA(I.executable)) Y.push({
      message: `${I.executable} exists but is not a valid Claude binary`,
      userActionRequired: !0,
      type: "error"
    })
  } else if (!eWA(I.executable)) Y.push({
    message: `${I.executable} exists but is not a valid Claude binary`,
    userActionRequired: !0,
    type: "error"
  });
  if (!(process.env.PATH || "").split(bt5).some((K) => {
      try {
        let D = hy(K);
        if (V) return D.toLowerCase() === W.toLowerCase();
        return D === W
      } catch {
        return !1
      }
    }))
    if (V) {
      let K = J.replace(/\//g, "\\");
      Y.push({
        message: `Native installation exists but ${K} is not in your PATH. Add it by opening: System Properties → Environment Variables → Edit User PATH → New → Add the path above. Then restart your terminal.`,
        userActionRequired: !0,
        type: "path"
      })
    } else {
      let K = GIA(),
        H = fl()[K],
        C = H ? H.replace(Yc2(), "~") : "your shell config file";
      Y.push({
        message: `Native installation exists but ~/.local/bin is not in your PATH. Run:

echo 'export PATH="$HOME/.local/bin:$PATH"' >> ${C} && source ${C}`,
        userActionRequired: !0,
        type: "path"
      })
    } return Y
}
// @from(Start 12416691, End 12417323)
async function Wg(A = !1, Q, B = !1) {
  if (!A && !await nTA()) return {
    latestVersion: null,
    wasUpdated: !1
  };
  let G = await VZ0(Q),
    Z = await rt5(Q, B);
  if (!Z) return {
    latestVersion: null,
    wasUpdated: !1,
    lockFailed: !0
  };
  if (G || Z) {
    let I = N1();
    if (I.installMethod !== "native") c0({
      ...I,
      installMethod: "native",
      autoUpdates: !1,
      autoUpdatesProtectedForNative: !0
    }), g('Native installer: Set installMethod to "native" and disabled legacy auto-updater for protection')
  }
  return {
    latestVersion: G,
    wasUpdated: Z,
    lockFailed: !1
  }
}
// @from(Start 12417325, End 12417533)
function et5(A) {
  let Q = RA();
  try {
    if (Q.existsSync(A)) {
      let B = Q.readlinkSync(A),
        G = hy(fy(A), B);
      if (Q.existsSync(G) && eWA(G)) return G
    }
  } catch {}
  return null
}
// @from(Start 12417535, End 12417609)
function Wc2(A, Q) {
  let B = ft5(Q);
  return dW(A.locks, `${B}.lock`)
}
// @from(Start 12417610, End 12418530)
async function CZ0() {
  let A = p0A();
  if (!process.execPath.includes(A.versions)) return;
  try {
    let Q = hy(process.execPath),
      B = Wc2(A, Q),
      G = RA();
    if (!G.existsSync(A.locks)) G.mkdirSync(A.locks);
    if (!G.existsSync(Q)) {
      g(`Cannot lock current version - file does not exist: ${Q}`, {
        level: "info"
      });
      return
    }
    try {
      await DZ0.default.lock(Q, {
        stale: 60000,
        retries: 0,
        lockfilePath: B,
        onCompromised: (Z) => {
          g(`NON-FATAL: Lock on running version was compromised: ${Z.message}`, {
            level: "info"
          })
        }
      })
    } catch (Z) {
      Xc2(Q, Z);
      return
    }
    g(`Acquired lock on running version: ${Q}`)
  } catch (Q) {
    g(`NON-FATAL: Failed to lock current version during execution ${Q instanceof Error?Q.message:String(Q)}`, {
      level: "info"
    })
  }
}
// @from(Start 12418532, End 12418742)
function Xc2(A, Q) {
  let B = `NON-FATAL: Lock acquisition failed for ${A} (expected in multi-process scenarios)`,
    G = Q instanceof Error ? Error(B, {
      cause: Q
    }) : Error(`${B}: ${Q}`);
  AA(G)
}
// @from(Start 12418743, End 12421997)
async function EZ0() {
  if (await Promise.resolve(), !await nTA()) return;
  let A = RA(),
    Q = p0A();
  if (by().startsWith("win32")) try {
    let G = fy(Q.executable);
    if (A.existsSync(G)) {
      let I = A.readdirStringSync(G).filter((J) => J.startsWith("claude.exe.old.") && J.match(/claude\.exe\.old\.\d+$/)),
        Y = 0;
      for (let J of I) try {
        let W = dW(G, J);
        A.unlinkSync(W), Y++
      } catch {}
      if (Y > 0) g(`Cleaned up ${Y} old Windows executables on startup`)
    }
  } catch (G) {
    g(`Failed to clean up old Windows executables: ${G}`)
  }
  if (A.existsSync(Q.staging)) try {
    let G = A.readdirStringSync(Q.staging),
      Z = Date.now() - 3600000,
      I = 0;
    for (let Y of G) {
      let J = dW(Q.staging, Y);
      try {
        if (A.statSync(J).mtime.getTime() < Z) A.rmSync(J, {
          recursive: !0,
          force: !0
        }), I++, g(`Cleaned up old staging directory: ${Y}`)
      } catch {}
    }
    if (I > 0) g(`Cleaned up ${I} orphaned staging directories`), GA("tengu_native_staging_cleanup", {
      cleaned_count: I
    })
  } catch (G) {
    g(`Failed to clean up staging directories: ${G}`)
  }
  if (A.existsSync(Q.versions)) try {
    let G = A.readdirStringSync(Q.versions),
      Z = Date.now() - 3600000,
      I = 0;
    for (let Y of G)
      if (Y.match(/\.tmp\.\d+\.\d+$/)) {
        let J = dW(Q.versions, Y);
        try {
          if (A.statSync(J).mtime.getTime() < Z) A.unlinkSync(J), I++, g(`Cleaned up orphaned temp install file: ${Y}`)
        } catch {}
      } if (I > 0) g(`Cleaned up ${I} orphaned temp install files`), GA("tengu_native_temp_files_cleanup", {
      cleaned_count: I
    })
  } catch (G) {
    g(`Failed to clean up temp install files: ${G}`)
  }
  if (!A.existsSync(Q.versions)) return;
  try {
    let G = A.readdirStringSync(Q.versions).filter((F) => {
        let K = dW(Q.versions, F);
        try {
          let D = A.statSync(K);
          return D.isFile() && (D.size === 0 || eWA(K))
        } catch {
          return !1
        }
      }),
      Z = process.execPath,
      I = Z && Z.includes(Q.versions) ? hy(Z) : null,
      Y = new Set([...I ? [I] : []]),
      J = et5(Q.executable);
    if (J) Y.add(J);
    for (let F of G) {
      let K = hy(Q.versions, F);
      if (Y.has(K)) continue;
      if (!await KZ0(K, () => {})) Y.add(K), g(`Protecting locked version from cleanup: ${F}`)
    }
    let W = G.map((F) => {
        let K = hy(Q.versions, F);
        return {
          name: F,
          path: K,
          mtime: A.statSync(K).mtime
        }
      }).filter((F) => !Y.has(F.path)).sort((F, K) => K.mtime.getTime() - F.mtime.getTime()),
      X = W.slice(lt5);
    if (X.length === 0) return;
    let V = 0;
    for (let F of X) try {
      if (await KZ0(F.path, () => {
          A.unlinkSync(F.path)
        })) V++;
      else g(`Skipping deletion of ${F.name} - locked by another process`)
    } catch (K) {
      AA(Error(`Failed to delete version ${F.name}: ${K}`))
    }
    if (V > 0) GA("tengu_native_version_cleanup", {
      deleted_count: V,
      protected_count: Y.size,
      retained_count: W.length - V
    })
  } catch (G) {
    AA(Error(`Version cleanup failed: ${G}`))
  }
}
// @from(Start 12421999, End 12422131)
function Ae5(A) {
  let Q = A;
  if (dt5(A).isSymbolicLink()) Q = ct5(A);
  return Q.endsWith(".js") || Q.includes("node_modules")
}
// @from(Start 12422133, End 12422481)
function aTA() {
  let A = p0A();
  try {
    if (!mt5(A.executable)) return;
    if (Ae5(A.executable)) {
      g(`Skipping removal of ${A.executable} - appears to be npm-managed`);
      return
    }
    pt5(A.executable), g(`Removed claude symlink at ${A.executable}`)
  } catch (Q) {
    AA(Error(`Failed to remove claude symlink: ${Q}`))
  }
}
// @from(Start 12422483, End 12423081)
function sTA() {
  let A = [],
    Q = fl();
  for (let [B, G] of Object.entries(Q)) try {
    let Z = iNA(G);
    if (!Z) continue;
    let {
      filtered: I,
      hadAlias: Y
    } = C01(Z);
    if (Y) E01(G, I), A.push({
      message: `Removed claude alias from ${G}. Run: unalias claude`,
      userActionRequired: !0,
      type: "alias"
    }), g(`Cleaned up claude alias from ${B} config`)
  } catch (Z) {
    AA(Z instanceof Error ? Z : Error(String(Z))), A.push({
      message: `Failed to clean up ${G}: ${Z}`,
      userActionRequired: !1,
      type: "error"
    })
  }
  return A
}
// @from(Start 12423082, End 12424461)
async function Qe5(A) {
  try {
    let Q = await A3("npm", ["config", "get", "prefix"]);
    if (Q.code !== 0 || !Q.stdout) return {
      success: !1,
      error: "Failed to get npm global prefix"
    };
    let B = Q.stdout.trim(),
      G = RA(),
      Z = !1;
    if (by() === "windows") {
      let I = dW(B, "claude.cmd"),
        Y = dW(B, "claude.ps1"),
        J = dW(B, "claude");
      if (G.existsSync(I)) G.unlinkSync(I), g(`Manually removed bin script: ${I}`), Z = !0;
      if (G.existsSync(Y)) G.unlinkSync(Y), g(`Manually removed PowerShell script: ${Y}`), Z = !0;
      if (G.existsSync(J)) G.unlinkSync(J), g(`Manually removed bin executable: ${J}`), Z = !0
    } else {
      let I = dW(B, "bin", "claude");
      if (G.existsSync(I)) G.unlinkSync(I), g(`Manually removed bin symlink: ${I}`), Z = !0
    }
    if (Z) {
      g(`Successfully removed ${A} manually`);
      let I = by() === "windows" ? dW(B, "node_modules", A) : dW(B, "lib", "node_modules", A);
      return {
        success: !0,
        warning: `${A} executables removed, but node_modules directory was left intact for safety. You may manually delete it later at: ${I}`
      }
    } else return {
      success: !1
    }
  } catch (Q) {
    return g(`Manual removal failed: ${Q}`, {
      level: "error"
    }), {
      success: !1,
      error: `Manual removal failed: ${Q}`
    }
  }
}
// @from(Start 12424462, End 12425465)
async function Ic2(A) {
  let {
    code: Q,
    stderr: B
  } = await A3("npm", ["uninstall", "-g", A], {
    cwd: RA().cwd()
  });
  if (Q === 0) return g(`Removed global npm installation of ${A}`), {
    success: !0
  };
  else if (B && !B.includes("npm ERR! code E404")) {
    if (B.includes("npm error code ENOTEMPTY")) {
      g(`Failed to uninstall global npm package ${A}: ${B}`, {
        level: "error"
      }), g("Attempting manual removal due to ENOTEMPTY error");
      let G = await Qe5(A);
      if (G.success) return {
        success: !0,
        warning: G.warning
      };
      else if (G.error) return {
        success: !1,
        error: `Failed to remove global npm installation of ${A}: ${B}. Manual removal also failed: ${G.error}`
      }
    }
    return g(`Failed to uninstall global npm package ${A}: ${B}`, {
      level: "error"
    }), {
      success: !1,
      error: `Failed to remove global npm installation of ${A}: ${B}`
    }
  }
  return {
    success: !1
  }
}
// @from(Start 12425466, End 12427224)
async function rTA() {
  let A = [],
    Q = [],
    B = 0,
    G = await Ic2("@anthropic-ai/claude-code");
  if (G.success) {
    if (B++, G.warning) Q.push(G.warning)
  } else if (G.error) A.push(G.error);
  if ({
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.PACKAGE_URL && {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.PACKAGE_URL !== "@anthropic-ai/claude-code") {
    let Y = await Ic2({
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.PACKAGE_URL);
    if (Y.success) {
      if (B++, Y.warning) Q.push(Y.warning)
    } else if (Y.error) A.push(Y.error)
  }
  let Z = RA(),
    I = dW(Yc2(), ".claude", "local");
  if (Z.existsSync(I)) try {
    Z.rmSync(I, {
      recursive: !0,
      force: !0
    }), B++, g(`Removed local installation at ${I}`)
  } catch (Y) {
    A.push(`Failed to remove ${I}: ${Y}`), g(`Failed to remove local installation: ${Y}`, {
      level: "error"
    })
  }
  return {
    removed: B,
    errors: A,
    warnings: Q
  }
}
// @from(Start 12427229, End 12427232)
DZ0
// @from(Start 12427234, End 12427241)
lt5 = 2
// @from(Start 12427247, End 12427410)
FZ0 = L(() => {
  c5();
  It();
  AQ();
  _8();
  u2();
  g1();
  q0();
  V0();
  Ac2();
  jQ();
  z01();
  xAA();
  Zc2();
  Zh();
  hQ();
  DZ0 = BA(T4A(), 1)
})
// @from(Start 12427416, End 12427441)
uy = L(() => {
  FZ0()
})
// @from(Start 12427444, End 12427555)
function Vc2(A) {
  return `${AXA.major(A,{loose:!0})}.${AXA.minor(A,{loose:!0})}.${AXA.patch(A,{loose:!0})}`
}
// @from(Start 12427557, End 12428008)
function C71(A, Q = {
  ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
  PACKAGE_URL: "@anthropic-ai/claude-code",
  README_URL: "https://code.claude.com/docs/en/overview",
  VERSION: "2.0.59",
  FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
}.VERSION) {
  let [B, G] = Fc2.useState(() => Vc2(Q));
  if (!A) return null;
  let Z = Vc2(A);
  if (Z !== B) return G(Z), Z;
  return null
}
// @from(Start 12428013, End 12428016)
Fc2
// @from(Start 12428018, End 12428021)
AXA
// @from(Start 12428027, End 12428084)
zZ0 = L(() => {
  Fc2 = BA(VA(), 1), AXA = BA(KU(), 1)
})
// @from(Start 12428087, End 12432023)
function Dc2({
  isUpdating: A,
  onChangeIsUpdating: Q,
  onAutoUpdaterResult: B,
  autoUpdaterResult: G,
  showSuccessMessage: Z,
  verbose: I
}) {
  let [Y, J] = E71.useState({}), W = C71(G?.version), X = E3.useCallback(async () => {
    if (A) return;
    let V = {
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.VERSION,
      F = await bAA(),
      K = fb();
    if (J({
        global: V,
        latest: F
      }), !K && V && F && !Kc2.gte(V, F, {
        loose: !0
      })) {
      let D = Date.now();
      Q(!0);
      let H = N1();
      if (H.installMethod !== "native") aTA();
      let C = await Nk();
      if (g(`AutoUpdater: Detected installation type: ${C}`), C === "development") {
        g("AutoUpdater: Cannot auto-update development build"), Q(!1);
        return
      }
      let E, U;
      if (C === "npm-local") g("AutoUpdater: Using local update method"), U = "local", E = await lNA();
      else if (C === "npm-global") g("AutoUpdater: Using global update method"), U = "global", E = await nNA();
      else if (C === "native") {
        g("AutoUpdater: Unexpected native installation in non-native updater"), Q(!1);
        return
      } else {
        g("AutoUpdater: Unknown installation type, falling back to config");
        let q = H.installMethod === "local";
        if (U = q ? "local" : "global", q) E = await lNA();
        else E = await nNA()
      }
      if (Q(!1), E === "success") St(), GA("tengu_auto_updater_success", {
        fromVersion: V,
        toVersion: F,
        durationMs: Date.now() - D,
        wasMigrated: U === "local",
        installationType: C
      });
      else GA("tengu_auto_updater_fail", {
        fromVersion: V,
        attemptedVersion: F,
        status: E,
        durationMs: Date.now() - D,
        wasMigrated: U === "local",
        installationType: C
      });
      B({
        version: F,
        status: E
      })
    }
  }, [B]);
  if (E71.useEffect(() => {
      X()
    }, [X]), CI(X, 1800000), !G?.version && (!Y.global || !Y.latest)) return null;
  if (!G?.version && !A) return null;
  return E3.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, I && E3.createElement($, {
    dimColor: !0
  }, "globalVersion: ", Y.global, " · latestVersion:", " ", Y.latest), A ? E3.createElement(E3.Fragment, null, E3.createElement(S, null, E3.createElement($, {
    color: "text",
    dimColor: !0,
    wrap: "end"
  }, "Auto-updating…"))) : G?.status === "success" && Z && W && E3.createElement($, {
    color: "success"
  }, "✓ Update installed · Restart to apply"), (G?.status === "install_failed" || G?.status === "no_permissions") && E3.createElement($, {
    color: "error"
  }, "✗ Auto-update failed · Try ", E3.createElement($, {
    bold: !0
  }, "claude doctor"), !bl() && E3.createElement(E3.Fragment, null, " ", "or ", E3.createElement($, {
    bold: !0
  }, "npm i -g ", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.PACKAGE_URL)), bl() && E3.createElement(E3.Fragment, null, " ", "or", " ", E3.createElement($, {
    bold: !0
  }, "cd ~/.claude/local && npm update ", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.PACKAGE_URL))))
}
// @from(Start 12432028, End 12432030)
E3
// @from(Start 12432032, End 12432035)
Kc2
// @from(Start 12432037, End 12432040)
E71
// @from(Start 12432046, End 12432212)
Hc2 = L(() => {
  hA();
  jQ();
  ZIA();
  xAA();
  uy();
  JE();
  u2();
  q0();
  zZ0();
  Zh();
  V0();
  E3 = BA(VA(), 1), Kc2 = BA(KU(), 1), E71 = BA(VA(), 1)
})
// @from(Start 12432215, End 12432729)
function Be5(A) {
  if (A.includes("timeout")) return "timeout";
  if (A.includes("Checksum mismatch")) return "checksum_mismatch";
  if (A.includes("ENOENT") || A.includes("not found")) return "not_found";
  if (A.includes("EACCES") || A.includes("permission")) return "permission_denied";
  if (A.includes("ENOSPC")) return "disk_full";
  if (A.includes("npm")) return "npm_error";
  if (A.includes("network") || A.includes("ECONNREFUSED") || A.includes("ENOTFOUND")) return "network_error";
  return "unknown"
}
// @from(Start 12432731, End 12435461)
function Cc2({
  isUpdating: A,
  onChangeIsUpdating: Q,
  onAutoUpdaterResult: B,
  autoUpdaterResult: G,
  showSuccessMessage: Z,
  verbose: I
}) {
  let [Y, J] = z71.useState({}), W = C71(G?.version), X = sV.useRef(!1), V = sV.useCallback(async () => {
    if (A || fb()) return;
    Q(!0);
    let F = Date.now();
    GA("tengu_native_auto_updater_start", {});
    try {
      let K = await Wg(),
        D = {
          ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
          PACKAGE_URL: "@anthropic-ai/claude-code",
          README_URL: "https://code.claude.com/docs/en/overview",
          VERSION: "2.0.59",
          FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
        }.VERSION,
        H = Date.now() - F;
      if (K.lockFailed) {
        GA("tengu_native_auto_updater_lock_contention", {
          latency_ms: H
        });
        return
      }
      if (J({
          current: D,
          latest: K.latestVersion
        }), K.wasUpdated) St(), GA("tengu_native_auto_updater_success", {
        latency_ms: H
      }), B({
        version: K.latestVersion,
        status: "success"
      });
      else GA("tengu_native_auto_updater_up_to_date", {
        latency_ms: H
      })
    } catch (K) {
      let D = Date.now() - F,
        H = K instanceof Error ? K.message : String(K);
      AA(K instanceof Error ? K : Error(String(K)));
      let C = Be5(H);
      GA("tengu_native_auto_updater_fail", {
        latency_ms: D,
        error_timeout: C === "timeout",
        error_checksum: C === "checksum_mismatch",
        error_not_found: C === "not_found",
        error_permission: C === "permission_denied",
        error_disk_full: C === "disk_full",
        error_npm: C === "npm_error",
        error_network: C === "network_error"
      }), B({
        version: null,
        status: "install_failed"
      })
    } finally {
      Q(!1)
    }
  }, [A, Q, B]);
  if (z71.useEffect(() => {
      if (!X.current) X.current = !0, V()
    }), CI(V, 1800000), !G?.version && (!Y.current || !Y.latest)) return null;
  if (!G?.version && !A) return null;
  return sV.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, I && sV.createElement($, {
    dimColor: !0
  }, "current: ", Y.current, " · latest: ", Y.latest), A ? sV.createElement(S, null, sV.createElement($, {
    dimColor: !0,
    wrap: "end"
  }, "Checking for updates")) : G?.status === "success" && Z && W && sV.createElement($, {
    color: "success"
  }, "✓ Update installed · Restart to update"), G?.status === "install_failed" && sV.createElement($, {
    color: "error"
  }, "✗ Auto-update failed · Try ", sV.createElement($, {
    bold: !0
  }, "/status")))
}
// @from(Start 12435466, End 12435468)
sV
// @from(Start 12435470, End 12435473)
z71
// @from(Start 12435479, End 12435600)
Ec2 = L(() => {
  hA();
  jQ();
  uy();
  JE();
  u2();
  q0();
  g1();
  zZ0();
  sV = BA(VA(), 1), z71 = BA(VA(), 1)
})
// @from(Start 12435603, End 12437245)
function $c2({
  verbose: A
}) {
  let [Q, B] = Uc2.useState(!1), G = IIA(), Z = CC.useCallback(async () => {
    if (fb()) return;
    let Y = await bAA(),
      J = Y && !zc2.gte({
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.VERSION, Y, {
        loose: !0
      });
    if (B(!!J), J) g(`PackageManagerAutoUpdater: Update available ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION} -> ${Y}`)
  }, []);
  if (CC.useEffect(() => {
      Z()
    }, [Z]), CI(Z, 1800000), !Q) return null;
  let I = G === "homebrew" ? "brew upgrade claude-code" : "your package manager update command";
  return CC.createElement(CC.Fragment, null, A && CC.createElement($, {
    dimColor: !0
  }, "currentVersion: ", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION), CC.createElement($, {
    color: "warning"
  }, "Update available! Run: ", CC.createElement($, {
    bold: !0
  }, I)))
}
// @from(Start 12437250, End 12437252)
CC
// @from(Start 12437254, End 12437257)
zc2
// @from(Start 12437259, End 12437262)
Uc2
// @from(Start 12437268, End 12437393)
wc2 = L(() => {
  hA();
  ZIA();
  JE();
  V0();
  w01();
  jQ();
  CC = BA(VA(), 1), zc2 = BA(KU(), 1), Uc2 = BA(VA(), 1)
})
// @from(Start 12437395, End 12437743)
async function U71() {
  let A = process.argv.includes("-p") || process.argv.includes("--print");
  if (await Nk() === "development") return !1;
  if (!await hX("auto_migrate_to_native")) return !1;
  if (Y0(!1) || !1 || A || Y0(process.env.DISABLE_AUTO_MIGRATE_TO_NATIVE)) return !1;
  if (N1().installMethod === "native") return !1;
  return !0
}
// @from(Start 12437744, End 12439559)
async function qc2() {
  GA("tengu_auto_migrate_to_native_attempt", {});
  try {
    let A = await Wg(!0),
      Q = [];
    if (A.latestVersion) {
      GA("tengu_auto_migrate_to_native_success", {}), g("✅ Upgraded to native installation. Future sessions will use the native version.");
      let {
        removed: G,
        errors: Z,
        warnings: I
      } = await rTA(), Y = [];
      if (Z.length > 0) Z.forEach((X) => {
        Y.push({
          message: X,
          userActionRequired: !1,
          type: "error"
        })
      });
      if (I.length > 0) I.forEach((X) => {
        Y.push({
          message: X,
          userActionRequired: !1,
          type: "info"
        })
      });
      if (G > 0) Y.push({
        message: `Cleaned up ${G} old npm installation(s)`,
        userActionRequired: !1,
        type: "info"
      });
      let J = sTA();
      Q = [...await gy(!0), ...J, ...Y]
    } else GA("tengu_auto_migrate_to_native_partial", {}), g("⚠️ Native installation setup encountered issues but cleanup completed."), Q = await gy(!0);
    let B = [];
    if (Q.length > 0) {
      let G = Q.filter((Z) => Z.userActionRequired);
      if (G.length > 0) {
        let Z = ["⚠️  Manual action required after migration to native installer:", ...G.map((I) => `• ${I.message}`)].join(`
`);
        B.push(Z)
      }
      g("Migration completed with the following notes:"), Q.forEach((Z) => {
        g(`  • [${Z.type}] ${Z.message}`)
      })
    }
    return {
      success: !0,
      version: A.latestVersion,
      notifications: B.length > 0 ? B : void 0
    }
  } catch (A) {
    return GA("tengu_auto_migrate_to_native_failure", {
      error: A instanceof Error ? A.message : String(A)
    }), AA(A instanceof Error ? A : Error(String(A))), {
      success: !1
    }
  }
}
// @from(Start 12439564, End 12439645)
UZ0 = L(() => {
  uy();
  u2();
  q0();
  g1();
  V0();
  hQ();
  Zh();
  jQ()
})
// @from(Start 12439648, End 12441455)
function Nc2({
  onMigrationComplete: A,
  onChangeIsUpdating: Q,
  onAutoUpdaterResult: B,
  verbose: G
}) {
  let [Z, I] = $71.useState("checking"), Y = Xg.useRef(!1);
  if ($71.useEffect(() => {
      async function J() {
        if (Y.current) return;
        Y.current = !0;
        try {
          if (!await U71()) {
            I("idle");
            return
          }
          if (G) g("Starting auto-migration from npm to native installation");
          GA("tengu_auto_migrate_to_native_ui_shown", {}), I("migrating"), Q?.(!0);
          let X = await qc2();
          if (X.success) I("success"), GA("tengu_auto_migrate_to_native_ui_success", {}), B?.({
            status: "success",
            version: X.version,
            notifications: X.notifications
          }), setTimeout(() => {
            I("idle"), Q?.(!1), A?.()
          }, 5000);
          else I("error"), GA("tengu_auto_migrate_to_native_ui_error", {}), B?.({
            status: "install_failed",
            version: null
          }), setTimeout(() => {
            I("idle"), Q?.(!1)
          }, 1e4)
        } catch (W) {
          AA(W instanceof Error ? W : Error(String(W))), I("error"), B?.({
            status: "install_failed",
            version: null
          }), setTimeout(() => {
            I("idle"), Q?.(!1)
          }, 1e4)
        }
      }
      J()
    }, [A, Q, B, G]), Z === "idle" || Z === "checking") return null;
  if (Z === "migrating") return Xg.createElement($, {
    dimColor: !0
  }, "Migrating to native installation…");
  if (Z === "success") return Xg.createElement($, {
    color: "success"
  }, H1.tick, " Migrated to native installation");
  if (Z === "error") return Xg.createElement($, {
    color: "error"
  }, "Migration failed · Run /doctor for details");
  return null
}
// @from(Start 12441460, End 12441462)
Xg
// @from(Start 12441464, End 12441467)
$71
// @from(Start 12441473, End 12441578)
Lc2 = L(() => {
  hA();
  V9();
  UZ0();
  q0();
  g1();
  V0();
  Xg = BA(VA(), 1), $71 = BA(VA(), 1)
})
// @from(Start 12441581, End 12442938)
function Mc2({
  isUpdating: A,
  onChangeIsUpdating: Q,
  onAutoUpdaterResult: B,
  autoUpdaterResult: G,
  showSuccessMessage: Z,
  verbose: I
}) {
  let [Y, J] = dq.useState(null), [W, X] = dq.useState(null), [V, F] = dq.useState(null);
  if (dq.useEffect(() => {
      async function D() {
        let H = await Nk(),
          C = H === "native",
          E = H === "package-manager";
        if (g(`AutoUpdaterWrapper: Installation type: ${H}`), J(C), X(E), !C && !E) {
          let U = await U71();
          F(U)
        } else F(!1)
      }
      D()
    }, []), Y === null || V === null || W === null) return null;
  if (W) return dq.createElement($c2, {
    verbose: I,
    onAutoUpdaterResult: B,
    autoUpdaterResult: G,
    isUpdating: A,
    onChangeIsUpdating: Q,
    showSuccessMessage: Z
  });
  if (!Y && V) return dq.createElement(Nc2, {
    onMigrationComplete: async () => {
      try {
        let H = await Nk() === "native";
        J(H), F(!1)
      } catch (D) {
        g(`Error checking installation type after migration: ${D}`), J(!0), F(!1)
      }
    },
    onChangeIsUpdating: Q,
    onAutoUpdaterResult: B,
    verbose: I
  });
  return dq.createElement(Y ? Cc2 : Dc2, {
    verbose: I,
    onAutoUpdaterResult: B,
    autoUpdaterResult: G,
    isUpdating: A,
    onChangeIsUpdating: Q,
    showSuccessMessage: Z
  })
}
// @from(Start 12442943, End 12442945)
dq
// @from(Start 12442951, End 12443049)
Oc2 = L(() => {
  Hc2();
  Ec2();
  wc2();
  Lc2();
  Zh();
  V0();
  UZ0();
  dq = BA(VA(), 1)
})
// @from(Start 12443055, End 12445085)
RO = z((jc2) => {
  Object.defineProperty(jc2, "__esModule", {
    value: !0
  });
  var Rc2 = Object.prototype.toString;

  function Ge5(A) {
    switch (Rc2.call(A)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return !0;
      default:
        return w71(A, Error)
    }
  }

  function QXA(A, Q) {
    return Rc2.call(A) === `[object ${Q}]`
  }

  function Ze5(A) {
    return QXA(A, "ErrorEvent")
  }

  function Ie5(A) {
    return QXA(A, "DOMError")
  }

  function Ye5(A) {
    return QXA(A, "DOMException")
  }

  function Je5(A) {
    return QXA(A, "String")
  }

  function Tc2(A) {
    return typeof A === "object" && A !== null && "__sentry_template_string__" in A && "__sentry_template_values__" in A
  }

  function We5(A) {
    return A === null || Tc2(A) || typeof A !== "object" && typeof A !== "function"
  }

  function Pc2(A) {
    return QXA(A, "Object")
  }

  function Xe5(A) {
    return typeof Event < "u" && w71(A, Event)
  }

  function Ve5(A) {
    return typeof Element < "u" && w71(A, Element)
  }

  function Fe5(A) {
    return QXA(A, "RegExp")
  }

  function Ke5(A) {
    return Boolean(A && A.then && typeof A.then === "function")
  }

  function De5(A) {
    return Pc2(A) && "nativeEvent" in A && "preventDefault" in A && "stopPropagation" in A
  }

  function He5(A) {
    return typeof A === "number" && A !== A
  }

  function w71(A, Q) {
    try {
      return A instanceof Q
    } catch (B) {
      return !1
    }
  }

  function Ce5(A) {
    return !!(typeof A === "object" && A !== null && (A.__isVue || A._isVue))
  }
  jc2.isDOMError = Ie5;
  jc2.isDOMException = Ye5;
  jc2.isElement = Ve5;
  jc2.isError = Ge5;
  jc2.isErrorEvent = Ze5;
  jc2.isEvent = Xe5;
  jc2.isInstanceOf = w71;
  jc2.isNaN = He5;
  jc2.isParameterizedString = Tc2;
  jc2.isPlainObject = Pc2;
  jc2.isPrimitive = We5;
  jc2.isRegExp = Fe5;
  jc2.isString = Je5;
  jc2.isSyntheticEvent = De5;
  jc2.isThenable = Ke5;
  jc2.isVueViewModel = Ce5
})
// @from(Start 12445091, End 12446454)
oTA = z((_c2) => {
  Object.defineProperty(_c2, "__esModule", {
    value: !0
  });
  var q71 = RO();

  function ke5(A, Q = 0) {
    if (typeof A !== "string" || Q === 0) return A;
    return A.length <= Q ? A : `${A.slice(0,Q)}...`
  }

  function ye5(A, Q) {
    let B = A,
      G = B.length;
    if (G <= 150) return B;
    if (Q > G) Q = G;
    let Z = Math.max(Q - 60, 0);
    if (Z < 5) Z = 0;
    let I = Math.min(Z + 140, G);
    if (I > G - 5) I = G;
    if (I === G) Z = Math.max(I - 140, 0);
    if (B = B.slice(Z, I), Z > 0) B = `'{snip} ${B}`;
    if (I < G) B += " {snip}";
    return B
  }

  function xe5(A, Q) {
    if (!Array.isArray(A)) return "";
    let B = [];
    for (let G = 0; G < A.length; G++) {
      let Z = A[G];
      try {
        if (q71.isVueViewModel(Z)) B.push("[VueViewModel]");
        else B.push(String(Z))
      } catch (I) {
        B.push("[value cannot be serialized]")
      }
    }
    return B.join(Q)
  }

  function Sc2(A, Q, B = !1) {
    if (!q71.isString(A)) return !1;
    if (q71.isRegExp(Q)) return Q.test(A);
    if (q71.isString(Q)) return B ? A === Q : A.includes(Q);
    return !1
  }

  function ve5(A, Q = [], B = !1) {
    return Q.some((G) => Sc2(A, G, B))
  }
  _c2.isMatchingPattern = Sc2;
  _c2.safeJoin = xe5;
  _c2.snipLine = ye5;
  _c2.stringMatchesSomePattern = ve5;
  _c2.truncate = ke5
})
// @from(Start 12446460, End 12448176)
vc2 = z((xc2) => {
  Object.defineProperty(xc2, "__esModule", {
    value: !0
  });
  var $Z0 = RO(),
    me5 = oTA();

  function de5(A, Q, B = 250, G, Z, I, Y) {
    if (!I.exception || !I.exception.values || !Y || !$Z0.isInstanceOf(Y.originalException, Error)) return;
    let J = I.exception.values.length > 0 ? I.exception.values[I.exception.values.length - 1] : void 0;
    if (J) I.exception.values = ce5(wZ0(A, Q, Z, Y.originalException, G, I.exception.values, J, 0), B)
  }

  function wZ0(A, Q, B, G, Z, I, Y, J) {
    if (I.length >= B + 1) return I;
    let W = [...I];
    if ($Z0.isInstanceOf(G[Z], Error)) {
      kc2(Y, J);
      let X = A(Q, G[Z]),
        V = W.length;
      yc2(X, Z, V, J), W = wZ0(A, Q, B, G[Z], Z, [X, ...W], X, V)
    }
    if (Array.isArray(G.errors)) G.errors.forEach((X, V) => {
      if ($Z0.isInstanceOf(X, Error)) {
        kc2(Y, J);
        let F = A(Q, X),
          K = W.length;
        yc2(F, `errors[${V}]`, K, J), W = wZ0(A, Q, B, X, Z, [F, ...W], F, K)
      }
    });
    return W
  }

  function kc2(A, Q) {
    A.mechanism = A.mechanism || {
      type: "generic",
      handled: !0
    }, A.mechanism = {
      ...A.mechanism,
      ...A.type === "AggregateError" && {
        is_exception_group: !0
      },
      exception_id: Q
    }
  }

  function yc2(A, Q, B, G) {
    A.mechanism = A.mechanism || {
      type: "generic",
      handled: !0
    }, A.mechanism = {
      ...A.mechanism,
      type: "chained",
      source: Q,
      exception_id: B,
      parent_id: G
    }
  }

  function ce5(A, Q) {
    return A.map((B) => {
      if (B.value) B.value = me5.truncate(B.value, Q);
      return B
    })
  }
  xc2.applyAggregateErrorsToEvent = de5
})
// @from(Start 12448182, End 12448823)
EC = z((bc2) => {
  Object.defineProperty(bc2, "__esModule", {
    value: !0
  });

  function N71(A) {
    return A && A.Math == Math ? A : void 0
  }
  var qZ0 = typeof globalThis == "object" && N71(globalThis) || typeof window == "object" && N71(window) || typeof self == "object" && N71(self) || typeof global == "object" && N71(global) || function() {
    return this
  }() || {};

  function le5() {
    return qZ0
  }

  function ie5(A, Q, B) {
    let G = B || qZ0,
      Z = G.__SENTRY__ = G.__SENTRY__ || {};
    return Z[A] || (Z[A] = Q())
  }
  bc2.GLOBAL_OBJ = qZ0;
  bc2.getGlobalObject = le5;
  bc2.getGlobalSingleton = ie5
})
// @from(Start 12448829, End 12451093)
NZ0 = z((fc2) => {
  Object.defineProperty(fc2, "__esModule", {
    value: !0
  });
  var re5 = RO(),
    oe5 = EC(),
    BXA = oe5.getGlobalObject(),
    te5 = 80;

  function ee5(A, Q = {}) {
    if (!A) return "<unknown>";
    try {
      let B = A,
        G = 5,
        Z = [],
        I = 0,
        Y = 0,
        J = " > ",
        W = J.length,
        X, V = Array.isArray(Q) ? Q : Q.keyAttrs,
        F = !Array.isArray(Q) && Q.maxStringLength || te5;
      while (B && I++ < G) {
        if (X = AA3(B, V), X === "html" || I > 1 && Y + Z.length * W + X.length >= F) break;
        Z.push(X), Y += X.length, B = B.parentNode
      }
      return Z.reverse().join(J)
    } catch (B) {
      return "<unknown>"
    }
  }

  function AA3(A, Q) {
    let B = A,
      G = [],
      Z, I, Y, J, W;
    if (!B || !B.tagName) return "";
    if (BXA.HTMLElement) {
      if (B instanceof HTMLElement && B.dataset && B.dataset.sentryComponent) return B.dataset.sentryComponent
    }
    G.push(B.tagName.toLowerCase());
    let X = Q && Q.length ? Q.filter((F) => B.getAttribute(F)).map((F) => [F, B.getAttribute(F)]) : null;
    if (X && X.length) X.forEach((F) => {
      G.push(`[${F[0]}="${F[1]}"]`)
    });
    else {
      if (B.id) G.push(`#${B.id}`);
      if (Z = B.className, Z && re5.isString(Z)) {
        I = Z.split(/\s+/);
        for (W = 0; W < I.length; W++) G.push(`.${I[W]}`)
      }
    }
    let V = ["aria-label", "type", "name", "title", "alt"];
    for (W = 0; W < V.length; W++)
      if (Y = V[W], J = B.getAttribute(Y), J) G.push(`[${Y}="${J}"]`);
    return G.join("")
  }

  function QA3() {
    try {
      return BXA.document.location.href
    } catch (A) {
      return ""
    }
  }

  function BA3(A) {
    if (BXA.document && BXA.document.querySelector) return BXA.document.querySelector(A);
    return null
  }

  function GA3(A) {
    if (!BXA.HTMLElement) return null;
    let Q = A,
      B = 5;
    for (let G = 0; G < B; G++) {
      if (!Q) return null;
      if (Q instanceof HTMLElement && Q.dataset.sentryComponent) return Q.dataset.sentryComponent;
      Q = Q.parentNode
    }
    return null
  }
  fc2.getComponentName = GA3;
  fc2.getDomElement = BA3;
  fc2.getLocationHref = QA3;
  fc2.htmlTreeAsString = ee5
})
// @from(Start 12451099, End 12451271)
my = z((hc2) => {
  Object.defineProperty(hc2, "__esModule", {
    value: !0
  });
  var WA3 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
  hc2.DEBUG_BUILD = WA3
})
// @from(Start 12451277, End 12452451)
pP = z((uc2) => {
  Object.defineProperty(uc2, "__esModule", {
    value: !0
  });
  var VA3 = my(),
    LZ0 = EC(),
    FA3 = "Sentry Logger ",
    MZ0 = ["debug", "info", "warn", "error", "log", "assert", "trace"],
    OZ0 = {};

  function gc2(A) {
    if (!("console" in LZ0.GLOBAL_OBJ)) return A();
    let Q = LZ0.GLOBAL_OBJ.console,
      B = {},
      G = Object.keys(OZ0);
    G.forEach((Z) => {
      let I = OZ0[Z];
      B[Z] = Q[Z], Q[Z] = I
    });
    try {
      return A()
    } finally {
      G.forEach((Z) => {
        Q[Z] = B[Z]
      })
    }
  }

  function KA3() {
    let A = !1,
      Q = {
        enable: () => {
          A = !0
        },
        disable: () => {
          A = !1
        },
        isEnabled: () => A
      };
    if (VA3.DEBUG_BUILD) MZ0.forEach((B) => {
      Q[B] = (...G) => {
        if (A) gc2(() => {
          LZ0.GLOBAL_OBJ.console[B](`${FA3}[${B}]:`, ...G)
        })
      }
    });
    else MZ0.forEach((B) => {
      Q[B] = () => {
        return
      }
    });
    return Q
  }
  var DA3 = KA3();
  uc2.CONSOLE_LEVELS = MZ0;
  uc2.consoleSandbox = gc2;
  uc2.logger = DA3;
  uc2.originalConsoleMethods = OZ0
})
// @from(Start 12452457, End 12454584)
RZ0 = z((cc2) => {
  Object.defineProperty(cc2, "__esModule", {
    value: !0
  });
  var UA3 = my(),
    tTA = pP(),
    $A3 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

  function wA3(A) {
    return A === "http" || A === "https"
  }

  function qA3(A, Q = !1) {
    let {
      host: B,
      path: G,
      pass: Z,
      port: I,
      projectId: Y,
      protocol: J,
      publicKey: W
    } = A;
    return `${J}://${W}${Q&&Z?`:${Z}`:""}@${B}${I?`:${I}`:""}/${G?`${G}/`:G}${Y}`
  }

  function mc2(A) {
    let Q = $A3.exec(A);
    if (!Q) {
      tTA.consoleSandbox(() => {
        console.error(`Invalid Sentry Dsn: ${A}`)
      });
      return
    }
    let [B, G, Z = "", I, Y = "", J] = Q.slice(1), W = "", X = J, V = X.split("/");
    if (V.length > 1) W = V.slice(0, -1).join("/"), X = V.pop();
    if (X) {
      let F = X.match(/^\d+/);
      if (F) X = F[0]
    }
    return dc2({
      host: I,
      pass: Z,
      path: W,
      projectId: X,
      port: Y,
      protocol: B,
      publicKey: G
    })
  }

  function dc2(A) {
    return {
      protocol: A.protocol,
      publicKey: A.publicKey || "",
      pass: A.pass || "",
      host: A.host,
      port: A.port || "",
      path: A.path || "",
      projectId: A.projectId
    }
  }

  function NA3(A) {
    if (!UA3.DEBUG_BUILD) return !0;
    let {
      port: Q,
      projectId: B,
      protocol: G
    } = A;
    if (["protocol", "publicKey", "host", "projectId"].find((Y) => {
        if (!A[Y]) return tTA.logger.error(`Invalid Sentry Dsn: ${Y} missing`), !0;
        return !1
      })) return !1;
    if (!B.match(/^\d+$/)) return tTA.logger.error(`Invalid Sentry Dsn: Invalid projectId ${B}`), !1;
    if (!wA3(G)) return tTA.logger.error(`Invalid Sentry Dsn: Invalid protocol ${G}`), !1;
    if (Q && isNaN(parseInt(Q, 10))) return tTA.logger.error(`Invalid Sentry Dsn: Invalid port ${Q}`), !1;
    return !0
  }

  function LA3(A) {
    let Q = typeof A === "string" ? mc2(A) : dc2(A);
    if (!Q || !NA3(Q)) return;
    return Q
  }
  cc2.dsnFromString = mc2;
  cc2.dsnToString = qA3;
  cc2.makeDsn = LA3
})
// @from(Start 12454590, End 12454931)
TZ0 = z((lc2) => {
  Object.defineProperty(lc2, "__esModule", {
    value: !0
  });
  class pc2 extends Error {
    constructor(A, Q = "warn") {
      super(A);
      this.message = A, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = Q
    }
  }
  lc2.SentryError = pc2
})
// @from(Start 12454937, End 12458476)
TO = z((tc2) => {
  Object.defineProperty(tc2, "__esModule", {
    value: !0
  });
  var PA3 = NZ0(),
    jA3 = my(),
    GXA = RO(),
    SA3 = pP(),
    ic2 = oTA();

  function _A3(A, Q, B) {
    if (!(Q in A)) return;
    let G = A[Q],
      Z = B(G);
    if (typeof Z === "function") rc2(Z, G);
    A[Q] = Z
  }

  function sc2(A, Q, B) {
    try {
      Object.defineProperty(A, Q, {
        value: B,
        writable: !0,
        configurable: !0
      })
    } catch (G) {
      jA3.DEBUG_BUILD && SA3.logger.log(`Failed to add non-enumerable property "${Q}" to object`, A)
    }
  }

  function rc2(A, Q) {
    try {
      let B = Q.prototype || {};
      A.prototype = Q.prototype = B, sc2(A, "__sentry_original__", Q)
    } catch (B) {}
  }

  function kA3(A) {
    return A.__sentry_original__
  }

  function yA3(A) {
    return Object.keys(A).map((Q) => `${encodeURIComponent(Q)}=${encodeURIComponent(A[Q])}`).join("&")
  }

  function oc2(A) {
    if (GXA.isError(A)) return {
      message: A.message,
      name: A.name,
      stack: A.stack,
      ...ac2(A)
    };
    else if (GXA.isEvent(A)) {
      let Q = {
        type: A.type,
        target: nc2(A.target),
        currentTarget: nc2(A.currentTarget),
        ...ac2(A)
      };
      if (typeof CustomEvent < "u" && GXA.isInstanceOf(A, CustomEvent)) Q.detail = A.detail;
      return Q
    } else return A
  }

  function nc2(A) {
    try {
      return GXA.isElement(A) ? PA3.htmlTreeAsString(A) : Object.prototype.toString.call(A)
    } catch (Q) {
      return "<unknown>"
    }
  }

  function ac2(A) {
    if (typeof A === "object" && A !== null) {
      let Q = {};
      for (let B in A)
        if (Object.prototype.hasOwnProperty.call(A, B)) Q[B] = A[B];
      return Q
    } else return {}
  }

  function xA3(A, Q = 40) {
    let B = Object.keys(oc2(A));
    if (B.sort(), !B.length) return "[object has no keys]";
    if (B[0].length >= Q) return ic2.truncate(B[0], Q);
    for (let G = B.length; G > 0; G--) {
      let Z = B.slice(0, G).join(", ");
      if (Z.length > Q) continue;
      if (G === B.length) return Z;
      return ic2.truncate(Z, Q)
    }
    return ""
  }

  function vA3(A) {
    return PZ0(A, new Map)
  }

  function PZ0(A, Q) {
    if (bA3(A)) {
      let B = Q.get(A);
      if (B !== void 0) return B;
      let G = {};
      Q.set(A, G);
      for (let Z of Object.keys(A))
        if (typeof A[Z] < "u") G[Z] = PZ0(A[Z], Q);
      return G
    }
    if (Array.isArray(A)) {
      let B = Q.get(A);
      if (B !== void 0) return B;
      let G = [];
      return Q.set(A, G), A.forEach((Z) => {
        G.push(PZ0(Z, Q))
      }), G
    }
    return A
  }

  function bA3(A) {
    if (!GXA.isPlainObject(A)) return !1;
    try {
      let Q = Object.getPrototypeOf(A).constructor.name;
      return !Q || Q === "Object"
    } catch (Q) {
      return !0
    }
  }

  function fA3(A) {
    let Q;
    switch (!0) {
      case (A === void 0 || A === null):
        Q = new String(A);
        break;
      case (typeof A === "symbol" || typeof A === "bigint"):
        Q = Object(A);
        break;
      case GXA.isPrimitive(A):
        Q = new A.constructor(A);
        break;
      default:
        Q = A;
        break
    }
    return Q
  }
  tc2.addNonEnumerableProperty = sc2;
  tc2.convertToPlainObject = oc2;
  tc2.dropUndefinedKeys = vA3;
  tc2.extractExceptionKeysForMessage = xA3;
  tc2.fill = _A3;
  tc2.getOriginalFunction = kA3;
  tc2.markFunctionWrapped = rc2;
  tc2.objectify = fA3;
  tc2.urlEncode = yA3
})
// @from(Start 12458482, End 12460065)
L71 = z((Ap2) => {
  Object.defineProperty(Ap2, "__esModule", {
    value: !0
  });

  function ec2(A, Q = !1) {
    return !(Q || A && !A.startsWith("/") && !A.match(/^[A-Z]:/) && !A.startsWith(".") && !A.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//)) && A !== void 0 && !A.includes("node_modules/")
  }

  function nA3(A) {
    let Q = /^\s*[-]{4,}$/,
      B = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
    return (G) => {
      let Z = G.match(B);
      if (Z) {
        let I, Y, J, W, X;
        if (Z[1]) {
          J = Z[1];
          let K = J.lastIndexOf(".");
          if (J[K - 1] === ".") K--;
          if (K > 0) {
            I = J.slice(0, K), Y = J.slice(K + 1);
            let D = I.indexOf(".Module");
            if (D > 0) J = J.slice(D + 1), I = I.slice(0, D)
          }
          W = void 0
        }
        if (Y) W = I, X = Y;
        if (Y === "<anonymous>") X = void 0, J = void 0;
        if (J === void 0) X = X || "<anonymous>", J = W ? `${W}.${X}` : X;
        let V = Z[2] && Z[2].startsWith("file://") ? Z[2].slice(7) : Z[2],
          F = Z[5] === "native";
        if (V && V.match(/\/[A-Z]:/)) V = V.slice(1);
        if (!V && Z[5] && !F) V = Z[5];
        return {
          filename: V,
          module: A ? A(V) : void 0,
          function: J,
          lineno: parseInt(Z[3], 10) || void 0,
          colno: parseInt(Z[4], 10) || void 0,
          in_app: ec2(V, F)
        }
      }
      if (G.match(Q)) return {
        filename: G
      };
      return
    }
  }
  Ap2.filenameIsInApp = ec2;
  Ap2.node = nA3
})
// @from(Start 12460071, End 12461818)
M71 = z((Jp2) => {
  Object.defineProperty(Jp2, "__esModule", {
    value: !0
  });
  var Gp2 = L71(),
    Zp2 = 50,
    Qp2 = /\(error: (.*)\)/,
    Bp2 = /captureMessage|captureException/;

  function Ip2(...A) {
    let Q = A.sort((B, G) => B[0] - G[0]).map((B) => B[1]);
    return (B, G = 0) => {
      let Z = [],
        I = B.split(`
`);
      for (let Y = G; Y < I.length; Y++) {
        let J = I[Y];
        if (J.length > 1024) continue;
        let W = Qp2.test(J) ? J.replace(Qp2, "$1") : J;
        if (W.match(/\S*Error: /)) continue;
        for (let X of Q) {
          let V = X(W);
          if (V) {
            Z.push(V);
            break
          }
        }
        if (Z.length >= Zp2) break
      }
      return Yp2(Z)
    }
  }

  function rA3(A) {
    if (Array.isArray(A)) return Ip2(...A);
    return A
  }

  function Yp2(A) {
    if (!A.length) return [];
    let Q = Array.from(A);
    if (/sentryWrapped/.test(Q[Q.length - 1].function || "")) Q.pop();
    if (Q.reverse(), Bp2.test(Q[Q.length - 1].function || "")) {
      if (Q.pop(), Bp2.test(Q[Q.length - 1].function || "")) Q.pop()
    }
    return Q.slice(0, Zp2).map((B) => ({
      ...B,
      filename: B.filename || Q[Q.length - 1].filename,
      function: B.function || "?"
    }))
  }
  var jZ0 = "<anonymous>";

  function oA3(A) {
    try {
      if (!A || typeof A !== "function") return jZ0;
      return A.name || jZ0
    } catch (Q) {
      return jZ0
    }
  }

  function tA3(A) {
    return [90, Gp2.node(A)]
  }
  Jp2.filenameIsInApp = Gp2.filenameIsInApp;
  Jp2.createStackParser = Ip2;
  Jp2.getFunctionName = oA3;
  Jp2.nodeStackLineParser = tA3;
  Jp2.stackParserFromStackParserOptions = rA3;
  Jp2.stripSentryFramesAndReverse = Yp2
})
// @from(Start 12461824, End 12462615)
Vg = z((Xp2) => {
  Object.defineProperty(Xp2, "__esModule", {
    value: !0
  });
  var I13 = my(),
    Y13 = pP(),
    J13 = M71(),
    ZXA = {},
    Wp2 = {};

  function W13(A, Q) {
    ZXA[A] = ZXA[A] || [], ZXA[A].push(Q)
  }

  function X13() {
    Object.keys(ZXA).forEach((A) => {
      ZXA[A] = void 0
    })
  }

  function V13(A, Q) {
    if (!Wp2[A]) Q(), Wp2[A] = !0
  }

  function F13(A, Q) {
    let B = A && ZXA[A];
    if (!B) return;
    for (let G of B) try {
      G(Q)
    } catch (Z) {
      I13.DEBUG_BUILD && Y13.logger.error(`Error while triggering instrumentation handler.
Type: ${A}
Name: ${J13.getFunctionName(G)}
Error:`, Z)
    }
  }
  Xp2.addHandler = W13;
  Xp2.maybeInstrument = V13;
  Xp2.resetInstrumentationHandlers = X13;
  Xp2.triggerHandlers = F13
})
// @from(Start 12462621, End 12463474)
kZ0 = z((Vp2) => {
  Object.defineProperty(Vp2, "__esModule", {
    value: !0
  });
  var SZ0 = pP(),
    E13 = TO(),
    O71 = EC(),
    _Z0 = Vg();

  function z13(A) {
    _Z0.addHandler("console", A), _Z0.maybeInstrument("console", U13)
  }

  function U13() {
    if (!("console" in O71.GLOBAL_OBJ)) return;
    SZ0.CONSOLE_LEVELS.forEach(function(A) {
      if (!(A in O71.GLOBAL_OBJ.console)) return;
      E13.fill(O71.GLOBAL_OBJ.console, A, function(Q) {
        return SZ0.originalConsoleMethods[A] = Q,
          function(...B) {
            let G = {
              args: B,
              level: A
            };
            _Z0.triggerHandlers("console", G);
            let Z = SZ0.originalConsoleMethods[A];
            Z && Z.apply(O71.GLOBAL_OBJ.console, B)
          }
      })
    })
  }
  Vp2.addConsoleInstrumentationHandler = z13
})
// @from(Start 12463480, End 12466429)
eTA = z((Kp2) => {
  Object.defineProperty(Kp2, "__esModule", {
    value: !0
  });
  var w13 = TO(),
    yZ0 = oTA(),
    q13 = EC();

  function N13() {
    let A = q13.GLOBAL_OBJ,
      Q = A.crypto || A.msCrypto,
      B = () => Math.random() * 16;
    try {
      if (Q && Q.randomUUID) return Q.randomUUID().replace(/-/g, "");
      if (Q && Q.getRandomValues) B = () => {
        let G = new Uint8Array(1);
        return Q.getRandomValues(G), G[0]
      }
    } catch (G) {}
    return ([1e7] + 1000 + 4000 + 8000 + 100000000000).replace(/[018]/g, (G) => (G ^ (B() & 15) >> G / 4).toString(16))
  }

  function Fp2(A) {
    return A.exception && A.exception.values ? A.exception.values[0] : void 0
  }

  function L13(A) {
    let {
      message: Q,
      event_id: B
    } = A;
    if (Q) return Q;
    let G = Fp2(A);
    if (G) {
      if (G.type && G.value) return `${G.type}: ${G.value}`;
      return G.type || G.value || B || "<unknown>"
    }
    return B || "<unknown>"
  }

  function M13(A, Q, B) {
    let G = A.exception = A.exception || {},
      Z = G.values = G.values || [],
      I = Z[0] = Z[0] || {};
    if (!I.value) I.value = Q || "";
    if (!I.type) I.type = B || "Error"
  }

  function O13(A, Q) {
    let B = Fp2(A);
    if (!B) return;
    let G = {
        type: "generic",
        handled: !0
      },
      Z = B.mechanism;
    if (B.mechanism = {
        ...G,
        ...Z,
        ...Q
      }, Q && "data" in Q) {
      let I = {
        ...Z && Z.data,
        ...Q.data
      };
      B.mechanism.data = I
    }
  }
  var R13 = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;

  function T13(A) {
    let Q = A.match(R13) || [],
      B = parseInt(Q[1], 10),
      G = parseInt(Q[2], 10),
      Z = parseInt(Q[3], 10);
    return {
      buildmetadata: Q[5],
      major: isNaN(B) ? void 0 : B,
      minor: isNaN(G) ? void 0 : G,
      patch: isNaN(Z) ? void 0 : Z,
      prerelease: Q[4]
    }
  }

  function P13(A, Q, B = 5) {
    if (Q.lineno === void 0) return;
    let G = A.length,
      Z = Math.max(Math.min(G - 1, Q.lineno - 1), 0);
    Q.pre_context = A.slice(Math.max(0, Z - B), Z).map((I) => yZ0.snipLine(I, 0)), Q.context_line = yZ0.snipLine(A[Math.min(G - 1, Z)], Q.colno || 0), Q.post_context = A.slice(Math.min(Z + 1, G), Z + 1 + B).map((I) => yZ0.snipLine(I, 0))
  }

  function j13(A) {
    if (A && A.__sentry_captured__) return !0;
    try {
      w13.addNonEnumerableProperty(A, "__sentry_captured__", !0)
    } catch (Q) {}
    return !1
  }

  function S13(A) {
    return Array.isArray(A) ? A : [A]
  }
  Kp2.addContextToFrame = P13;
  Kp2.addExceptionMechanism = O13;
  Kp2.addExceptionTypeValue = M13;
  Kp2.arrayify = S13;
  Kp2.checkOrSetAlreadyCaught = j13;
  Kp2.getEventDescription = L13;
  Kp2.parseSemver = T13;
  Kp2.uuid4 = N13
})
// @from(Start 12466435, End 12469440)
fZ0 = z((Ep2) => {
  Object.defineProperty(Ep2, "__esModule", {
    value: !0
  });
  var g13 = eTA(),
    R71 = TO(),
    u13 = EC(),
    xZ0 = Vg(),
    IXA = u13.GLOBAL_OBJ,
    m13 = 1000,
    Dp2, vZ0, bZ0;

  function d13(A) {
    xZ0.addHandler("dom", A), xZ0.maybeInstrument("dom", Cp2)
  }

  function Cp2() {
    if (!IXA.document) return;
    let A = xZ0.triggerHandlers.bind(null, "dom"),
      Q = Hp2(A, !0);
    IXA.document.addEventListener("click", Q, !1), IXA.document.addEventListener("keypress", Q, !1), ["EventTarget", "Node"].forEach((B) => {
      let G = IXA[B] && IXA[B].prototype;
      if (!G || !G.hasOwnProperty || !G.hasOwnProperty("addEventListener")) return;
      R71.fill(G, "addEventListener", function(Z) {
        return function(I, Y, J) {
          if (I === "click" || I == "keypress") try {
            let W = this,
              X = W.__sentry_instrumentation_handlers__ = W.__sentry_instrumentation_handlers__ || {},
              V = X[I] = X[I] || {
                refCount: 0
              };
            if (!V.handler) {
              let F = Hp2(A);
              V.handler = F, Z.call(this, I, F, J)
            }
            V.refCount++
          } catch (W) {}
          return Z.call(this, I, Y, J)
        }
      }), R71.fill(G, "removeEventListener", function(Z) {
        return function(I, Y, J) {
          if (I === "click" || I == "keypress") try {
            let W = this,
              X = W.__sentry_instrumentation_handlers__ || {},
              V = X[I];
            if (V) {
              if (V.refCount--, V.refCount <= 0) Z.call(this, I, V.handler, J), V.handler = void 0, delete X[I];
              if (Object.keys(X).length === 0) delete W.__sentry_instrumentation_handlers__
            }
          } catch (W) {}
          return Z.call(this, I, Y, J)
        }
      })
    })
  }

  function c13(A) {
    if (A.type !== vZ0) return !1;
    try {
      if (!A.target || A.target._sentryId !== bZ0) return !1
    } catch (Q) {}
    return !0
  }

  function p13(A, Q) {
    if (A !== "keypress") return !1;
    if (!Q || !Q.tagName) return !0;
    if (Q.tagName === "INPUT" || Q.tagName === "TEXTAREA" || Q.isContentEditable) return !1;
    return !0
  }

  function Hp2(A, Q = !1) {
    return (B) => {
      if (!B || B._sentryCaptured) return;
      let G = l13(B);
      if (p13(B.type, G)) return;
      if (R71.addNonEnumerableProperty(B, "_sentryCaptured", !0), G && !G._sentryId) R71.addNonEnumerableProperty(G, "_sentryId", g13.uuid4());
      let Z = B.type === "keypress" ? "input" : B.type;
      if (!c13(B)) A({
        event: B,
        name: Z,
        global: Q
      }), vZ0 = B.type, bZ0 = G ? G._sentryId : void 0;
      clearTimeout(Dp2), Dp2 = IXA.setTimeout(() => {
        bZ0 = void 0, vZ0 = void 0
      }, m13)
    }
  }

  function l13(A) {
    try {
      return A.target
    } catch (Q) {
      return null
    }
  }
  Ep2.addClickKeypressInstrumentationHandler = d13;
  Ep2.instrumentDOM = Cp2
})
// @from(Start 12469446, End 12471312)
uZ0 = z((zp2) => {
  Object.defineProperty(zp2, "__esModule", {
    value: !0
  });
  var a13 = my(),
    s13 = pP(),
    r13 = EC(),
    T71 = r13.getGlobalObject();

  function o13() {
    try {
      return new ErrorEvent(""), !0
    } catch (A) {
      return !1
    }
  }

  function t13() {
    try {
      return new DOMError(""), !0
    } catch (A) {
      return !1
    }
  }

  function e13() {
    try {
      return new DOMException(""), !0
    } catch (A) {
      return !1
    }
  }

  function gZ0() {
    if (!("fetch" in T71)) return !1;
    try {
      return new Request("http://www.example.com"), !0
    } catch (A) {
      return !1
    }
  }

  function hZ0(A) {
    return A && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(A.toString())
  }

  function A03() {
    if (typeof EdgeRuntime === "string") return !0;
    if (!gZ0()) return !1;
    if (hZ0(T71.fetch)) return !0;
    let A = !1,
      Q = T71.document;
    if (Q && typeof Q.createElement === "function") try {
      let B = Q.createElement("iframe");
      if (B.hidden = !0, Q.head.appendChild(B), B.contentWindow && B.contentWindow.fetch) A = hZ0(B.contentWindow.fetch);
      Q.head.removeChild(B)
    } catch (B) {
      a13.DEBUG_BUILD && s13.logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", B)
    }
    return A
  }

  function Q03() {
    return "ReportingObserver" in T71
  }

  function B03() {
    if (!gZ0()) return !1;
    try {
      return new Request("_", {
        referrerPolicy: "origin"
      }), !0
    } catch (A) {
      return !1
    }
  }
  zp2.isNativeFetch = hZ0;
  zp2.supportsDOMError = t13;
  zp2.supportsDOMException = e13;
  zp2.supportsErrorEvent = o13;
  zp2.supportsFetch = gZ0;
  zp2.supportsNativeFetch = A03;
  zp2.supportsReferrerPolicy = B03;
  zp2.supportsReportingObserver = Q03
})
// @from(Start 12471318, End 12473151)
dZ0 = z((qp2) => {
  Object.defineProperty(qp2, "__esModule", {
    value: !0
  });
  var F03 = TO(),
    K03 = uZ0(),
    Up2 = EC(),
    APA = Vg();

  function D03(A) {
    APA.addHandler("fetch", A), APA.maybeInstrument("fetch", H03)
  }

  function H03() {
    if (!K03.supportsNativeFetch()) return;
    F03.fill(Up2.GLOBAL_OBJ, "fetch", function(A) {
      return function(...Q) {
        let {
          method: B,
          url: G
        } = wp2(Q), Z = {
          args: Q,
          fetchData: {
            method: B,
            url: G
          },
          startTimestamp: Date.now()
        };
        return APA.triggerHandlers("fetch", {
          ...Z
        }), A.apply(Up2.GLOBAL_OBJ, Q).then((I) => {
          let Y = {
            ...Z,
            endTimestamp: Date.now(),
            response: I
          };
          return APA.triggerHandlers("fetch", Y), I
        }, (I) => {
          let Y = {
            ...Z,
            endTimestamp: Date.now(),
            error: I
          };
          throw APA.triggerHandlers("fetch", Y), I
        })
      }
    })
  }

  function mZ0(A, Q) {
    return !!A && typeof A === "object" && !!A[Q]
  }

  function $p2(A) {
    if (typeof A === "string") return A;
    if (!A) return "";
    if (mZ0(A, "url")) return A.url;
    if (A.toString) return A.toString();
    return ""
  }

  function wp2(A) {
    if (A.length === 0) return {
      method: "GET",
      url: ""
    };
    if (A.length === 2) {
      let [B, G] = A;
      return {
        url: $p2(B),
        method: mZ0(G, "method") ? String(G.method).toUpperCase() : "GET"
      }
    }
    let Q = A[0];
    return {
      url: $p2(Q),
      method: mZ0(Q, "method") ? String(Q.method).toUpperCase() : "GET"
    }
  }
  qp2.addFetchInstrumentationHandler = D03;
  qp2.parseFetchArgs = wp2
})
// @from(Start 12473157, End 12473836)
lZ0 = z((Np2) => {
  Object.defineProperty(Np2, "__esModule", {
    value: !0
  });
  var cZ0 = EC(),
    pZ0 = Vg(),
    P71 = null;

  function z03(A) {
    pZ0.addHandler("error", A), pZ0.maybeInstrument("error", U03)
  }

  function U03() {
    P71 = cZ0.GLOBAL_OBJ.onerror, cZ0.GLOBAL_OBJ.onerror = function(A, Q, B, G, Z) {
      let I = {
        column: G,
        error: Z,
        line: B,
        msg: A,
        url: Q
      };
      if (pZ0.triggerHandlers("error", I), P71 && !P71.__SENTRY_LOADER__) return P71.apply(this, arguments);
      return !1
    }, cZ0.GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0
  }
  Np2.addGlobalErrorInstrumentationHandler = z03
})
// @from(Start 12473842, End 12474507)
aZ0 = z((Lp2) => {
  Object.defineProperty(Lp2, "__esModule", {
    value: !0
  });
  var iZ0 = EC(),
    nZ0 = Vg(),
    j71 = null;

  function w03(A) {
    nZ0.addHandler("unhandledrejection", A), nZ0.maybeInstrument("unhandledrejection", q03)
  }

  function q03() {
    j71 = iZ0.GLOBAL_OBJ.onunhandledrejection, iZ0.GLOBAL_OBJ.onunhandledrejection = function(A) {
      let Q = A;
      if (nZ0.triggerHandlers("unhandledrejection", Q), j71 && !j71.__SENTRY_LOADER__) return j71.apply(this, arguments);
      return !0
    }, iZ0.GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
  }
  Lp2.addGlobalUnhandledRejectionInstrumentationHandler = w03
})
// @from(Start 12474513, End 12474869)
sZ0 = z((Mp2) => {
  Object.defineProperty(Mp2, "__esModule", {
    value: !0
  });
  var L03 = EC(),
    S71 = L03.getGlobalObject();

  function M03() {
    let A = S71.chrome,
      Q = A && A.app && A.app.runtime,
      B = "history" in S71 && !!S71.history.pushState && !!S71.history.replaceState;
    return !Q && B
  }
  Mp2.supportsHistory = M03
})
// @from(Start 12474875, End 12476025)
rZ0 = z((Rp2) => {
  Object.defineProperty(Rp2, "__esModule", {
    value: !0
  });
  var Op2 = TO();
  my();
  pP();
  var R03 = EC(),
    T03 = sZ0(),
    k71 = Vg(),
    QPA = R03.GLOBAL_OBJ,
    _71;

  function P03(A) {
    k71.addHandler("history", A), k71.maybeInstrument("history", j03)
  }

  function j03() {
    if (!T03.supportsHistory()) return;
    let A = QPA.onpopstate;
    QPA.onpopstate = function(...B) {
      let G = QPA.location.href,
        Z = _71;
      _71 = G;
      let I = {
        from: Z,
        to: G
      };
      if (k71.triggerHandlers("history", I), A) try {
        return A.apply(this, B)
      } catch (Y) {}
    };

    function Q(B) {
      return function(...G) {
        let Z = G.length > 2 ? G[2] : void 0;
        if (Z) {
          let I = _71,
            Y = String(Z);
          _71 = Y;
          let J = {
            from: I,
            to: Y
          };
          k71.triggerHandlers("history", J)
        }
        return B.apply(this, G)
      }
    }
    Op2.fill(QPA.history, "pushState", Q), Op2.fill(QPA.history, "replaceState", Q)
  }
  Rp2.addHistoryInstrumentationHandler = P03
})
// @from(Start 13088290, End 13094062)
DJ0 = z((u19) => {
  Object.defineProperty(u19, "__esModule", {
    value: !0
  });
  var R2 = _4(),
    QN3 = mo2(),
    BN3 = mY0(),
    GN3 = pY0(),
    lPA = GJ0(),
    KJ0 = i0(),
    ZN3 = Se2(),
    b19 = BJ0(),
    IN3 = he2(),
    YN3 = ne2(),
    JN3 = BA9(),
    WN3 = ZA9(),
    Ia = M19(),
    XN3 = sG1(),
    VN3 = YZ1(),
    FN3 = WZ1(),
    KN3 = GZ1(),
    DN3 = tG1(),
    HN3 = rG1(),
    CN3 = BZ1(),
    EN3 = XZ1(),
    zN3 = HZ1(),
    f19 = WJ0(),
    h19 = FZ1(),
    g19 = eG1(),
    UN3 = JJ0(),
    $N3 = S19(),
    wN3 = y19(),
    qN3 = v19(),
    NN3 = b19.createGetModuleFromFilename(),
    LN3 = {
      ...R2.Integrations,
      ...JN3,
      ...WN3
    },
    MN3 = {
      instrumentCron: $N3.instrumentCron,
      instrumentNodeCron: wN3.instrumentNodeCron,
      instrumentNodeSchedule: qN3.instrumentNodeSchedule
    };
  u19.Hub = R2.Hub;
  u19.SDK_VERSION = R2.SDK_VERSION;
  u19.SEMANTIC_ATTRIBUTE_SENTRY_OP = R2.SEMANTIC_ATTRIBUTE_SENTRY_OP;
  u19.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = R2.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN;
  u19.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = R2.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE;
  u19.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = R2.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE;
  u19.Scope = R2.Scope;
  u19.addBreadcrumb = R2.addBreadcrumb;
  u19.addEventProcessor = R2.addEventProcessor;
  u19.addGlobalEventProcessor = R2.addGlobalEventProcessor;
  u19.addIntegration = R2.addIntegration;
  u19.captureCheckIn = R2.captureCheckIn;
  u19.captureEvent = R2.captureEvent;
  u19.captureException = R2.captureException;
  u19.captureMessage = R2.captureMessage;
  u19.captureSession = R2.captureSession;
  u19.close = R2.close;
  u19.configureScope = R2.configureScope;
  u19.continueTrace = R2.continueTrace;
  u19.createTransport = R2.createTransport;
  u19.endSession = R2.endSession;
  u19.extractTraceparentData = R2.extractTraceparentData;
  u19.flush = R2.flush;
  u19.functionToStringIntegration = R2.functionToStringIntegration;
  u19.getActiveSpan = R2.getActiveSpan;
  u19.getActiveTransaction = R2.getActiveTransaction;
  u19.getClient = R2.getClient;
  u19.getCurrentHub = R2.getCurrentHub;
  u19.getCurrentScope = R2.getCurrentScope;
  u19.getGlobalScope = R2.getGlobalScope;
  u19.getHubFromCarrier = R2.getHubFromCarrier;
  u19.getIsolationScope = R2.getIsolationScope;
  u19.getSpanStatusFromHttpCode = R2.getSpanStatusFromHttpCode;
  u19.inboundFiltersIntegration = R2.inboundFiltersIntegration;
  u19.isInitialized = R2.isInitialized;
  u19.lastEventId = R2.lastEventId;
  u19.linkedErrorsIntegration = R2.linkedErrorsIntegration;
  u19.makeMain = R2.makeMain;
  u19.metrics = R2.metrics;
  u19.parameterize = R2.parameterize;
  u19.requestDataIntegration = R2.requestDataIntegration;
  u19.runWithAsyncContext = R2.runWithAsyncContext;
  u19.setContext = R2.setContext;
  u19.setCurrentClient = R2.setCurrentClient;
  u19.setExtra = R2.setExtra;
  u19.setExtras = R2.setExtras;
  u19.setHttpStatus = R2.setHttpStatus;
  u19.setMeasurement = R2.setMeasurement;
  u19.setTag = R2.setTag;
  u19.setTags = R2.setTags;
  u19.setUser = R2.setUser;
  u19.spanStatusfromHttpCode = R2.spanStatusfromHttpCode;
  u19.startActiveSpan = R2.startActiveSpan;
  u19.startInactiveSpan = R2.startInactiveSpan;
  u19.startSession = R2.startSession;
  u19.startSpan = R2.startSpan;
  u19.startSpanManual = R2.startSpanManual;
  u19.startTransaction = R2.startTransaction;
  u19.trace = R2.trace;
  u19.withActiveSpan = R2.withActiveSpan;
  u19.withIsolationScope = R2.withIsolationScope;
  u19.withMonitor = R2.withMonitor;
  u19.withScope = R2.withScope;
  u19.autoDiscoverNodePerformanceMonitoringIntegrations = QN3.autoDiscoverNodePerformanceMonitoringIntegrations;
  u19.NodeClient = BN3.NodeClient;
  u19.makeNodeTransport = GN3.makeNodeTransport;
  u19.defaultIntegrations = lPA.defaultIntegrations;
  u19.defaultStackParser = lPA.defaultStackParser;
  u19.getDefaultIntegrations = lPA.getDefaultIntegrations;
  u19.getSentryRelease = lPA.getSentryRelease;
  u19.init = lPA.init;
  u19.DEFAULT_USER_INCLUDES = KJ0.DEFAULT_USER_INCLUDES;
  u19.addRequestDataToEvent = KJ0.addRequestDataToEvent;
  u19.extractRequestData = KJ0.extractRequestData;
  u19.deepReadDirSync = ZN3.deepReadDirSync;
  u19.createGetModuleFromFilename = b19.createGetModuleFromFilename;
  u19.enableAnrDetection = IN3.enableAnrDetection;
  u19.Handlers = YN3;
  u19.captureConsoleIntegration = Ia.captureConsoleIntegration;
  u19.debugIntegration = Ia.debugIntegration;
  u19.dedupeIntegration = Ia.dedupeIntegration;
  u19.extraErrorDataIntegration = Ia.extraErrorDataIntegration;
  u19.httpClientIntegration = Ia.httpClientIntegration;
  u19.reportingObserverIntegration = Ia.reportingObserverIntegration;
  u19.rewriteFramesIntegration = Ia.rewriteFramesIntegration;
  u19.sessionTimingIntegration = Ia.sessionTimingIntegration;
  u19.consoleIntegration = XN3.consoleIntegration;
  u19.onUncaughtExceptionIntegration = VN3.onUncaughtExceptionIntegration;
  u19.onUnhandledRejectionIntegration = FN3.onUnhandledRejectionIntegration;
  u19.modulesIntegration = KN3.modulesIntegration;
  u19.contextLinesIntegration = DN3.contextLinesIntegration;
  u19.nodeContextIntegration = HN3.nodeContextIntegration;
  u19.localVariablesIntegration = CN3.localVariablesIntegration;
  u19.spotlightIntegration = EN3.spotlightIntegration;
  u19.anrIntegration = zN3.anrIntegration;
  u19.hapiErrorPlugin = f19.hapiErrorPlugin;
  u19.hapiIntegration = f19.hapiIntegration;
  u19.Undici = h19.Undici;
  u19.nativeNodeFetchintegration = h19.nativeNodeFetchintegration;
  u19.Http = g19.Http;
  u19.httpIntegration = g19.httpIntegration;
  u19.trpcMiddleware = UN3.trpcMiddleware;
  u19.Integrations = LN3;
  u19.cron = MN3;
  u19.getModuleFromFilename = NN3
})
// @from(Start 13094068, End 13094071)
m19
// @from(Start 13094073, End 13094076)
d19
// @from(Start 13094078, End 13094081)
CQA
// @from(Start 13094087, End 13094567)
$Z1 = L(() => {
  m19 = BA(VA(), 1), d19 = BA(DJ0(), 1);
  CQA = class CQA extends m19.Component {
    constructor(A) {
      super(A);
      this.state = {
        hasError: !1
      }
    }
    static getDerivedStateFromError() {
      return {
        hasError: !0
      }
    }
    componentDidCatch(A) {
      try {
        d19.captureException(A)
      } catch {}
    }
    render() {
      if (this.state.hasError) return null;
      return this.props.children
    }
  }
})
// @from(Start 13094570, End 13094774)
function NM3() {
  if (Tt() === "sonnet") {
    let {
      hasAccess: Q
    } = hc();
    if (Q) return {
      alias: "sonnet[1m]",
      name: "Sonnet 1M",
      multiplier: 5
    }
  }
  return null
}
// @from(Start 13094776, End 13095057)
function EQA(A) {
  let Q = NM3();
  if (!Q) return null;
  switch (A) {
    case "warning":
      return `/model ${Q.alias} for more context`;
    case "tip":
      return `Tip: You have access to ${Q.name} with ${Q.multiplier}x more context`;
    default:
      return null
  }
}
// @from(Start 13095062, End 13095096)
wZ1 = L(() => {
  t2();
  giA()
})
// @from(Start 13095099, End 13095707)
function c19({
  tokenUsage: A
}) {
  let {
    percentLeft: Q,
    isAboveWarningThreshold: B,
    isAboveErrorThreshold: G
  } = x1A(A), Z = nI2();
  if (!B || Z) return null;
  let I = b1A(),
    Y = EQA("warning");
  return zQA.createElement(S, {
    flexDirection: "row"
  }, I ? zQA.createElement($, {
    dimColor: !0
  }, Y ? `Context left until auto-compact: ${Q}% · ${Y}` : `Context left until auto-compact: ${Q}%`) : zQA.createElement($, {
    color: G ? "error" : "warning"
  }, Y ? `Context low (${Q}% remaining) · ${Y}` : `Context low (${Q}% remaining) · Run /compact to compact & continue`))
}
// @from(Start 13095712, End 13095715)
zQA
// @from(Start 13095721, End 13095794)
p19 = L(() => {
  hA();
  v1A();
  y1A();
  wZ1();
  zQA = BA(VA(), 1)
})
// @from(Start 13095797, End 13095856)
function l19(A) {
  return x1A(A).isAboveWarningThreshold
}
// @from(Start 13095861, End 13095887)
i19 = L(() => {
  v1A()
})
// @from(Start 13095890, End 13096084)
function yXA(A) {
  return n19.useMemo(() => {
    let Q = A?.find((B) => B.name === "ide");
    if (!Q) return null;
    return Q.type === "connected" ? "connected" : "disconnected"
  }, [A])
}
// @from(Start 13096089, End 13096092)
n19
// @from(Start 13096098, End 13096136)
qZ1 = L(() => {
  n19 = BA(VA(), 1)
})
// @from(Start 13096181, End 13096693)
function a19({
  ideSelection: A,
  mcpClients: Q
}) {
  let B = yXA(Q),
    G = B === "connected" && (A?.filePath || A?.text && A.lineCount > 0);
  if (B === null || !G || !A) return null;
  if (A.text && A.lineCount > 0) return iPA.createElement($, {
    color: "ide",
    key: "selection-indicator"
  }, "⧉ ", A.lineCount, " ", A.lineCount === 1 ? "line" : "lines", " selected");
  if (A.filePath) return iPA.createElement($, {
    color: "ide",
    key: "selection-indicator"
  }, "⧉ In ", LM3(A.filePath))
}
// @from(Start 13096698, End 13096701)
iPA
// @from(Start 13096707, End 13096762)
s19 = L(() => {
  hA();
  qZ1();
  iPA = BA(VA(), 1)
})
// @from(Start 13096765, End 13096874)
function o19() {
  let [A, Q] = r19.useState(null);

  function B() {
    return
  }
  return CI(B, 1e4), A
}
// @from(Start 13096879, End 13096882)
r19
// @from(Start 13096884, End 13096900)
MM3 = 2147483648
// @from(Start 13096904, End 13096920)
OM3 = 2684354560
// @from(Start 13096926, End 13096972)
t19 = L(() => {
  JE();
  r19 = BA(VA(), 1)
})
// @from(Start 13096975, End 13097024)
function e19() {
  let A = o19();
  return null
}
// @from(Start 13097029, End 13097032)
nPA
// @from(Start 13097038, End 13097101)
A09 = L(() => {
  hA();
  t19();
  R9();
  nPA = BA(VA(), 1)
})
// @from(Start 13097104, End 13097992)
function Q09() {
  let [A, Q] = xXA.useState(0), B = xXA.useRef(null);
  if (xXA.useEffect(() => {
      if (!nQ.isSandboxingEnabled()) return;
      let G = nQ.getSandboxViolationStore(),
        Z = G.getTotalCount(),
        I = G.subscribe(() => {
          let Y = G.getTotalCount(),
            J = Y - Z;
          if (J > 0) {
            if (Q(J), Z = Y, B.current) clearTimeout(B.current);
            B.current = setTimeout(() => {
              Q(0)
            }, 5000)
          }
        });
      return () => {
        if (I(), B.current) clearTimeout(B.current)
      }
    }, []), !nQ.isSandboxingEnabled() || A === 0) return null;
  return aPA.createElement(S, {
    paddingX: 0,
    paddingY: 0
  }, aPA.createElement($, {
    color: "inactive"
  }, "⧈ Sandbox blocked ", A, " ", A === 1 ? "operation" : "operations", " · ctrl+o for details · /sandbox to disable"))
}
// @from(Start 13097997, End 13098000)
aPA
// @from(Start 13098002, End 13098005)
xXA
// @from(Start 13098011, End 13098084)
B09 = L(() => {
  hA();
  $J();
  aPA = BA(VA(), 1), xXA = BA(VA(), 1)
})
// @from(Start 13098087, End 13100436)
function Z09({
  apiKeyStatus: A,
  autoUpdaterResult: Q,
  debug: B,
  isAutoUpdating: G,
  verbose: Z,
  messages: I,
  onAutoUpdaterResult: Y,
  onChangeIsUpdating: J,
  ideSelection: W,
  mcpClients: X,
  isInputWrapped: V = !1,
  shouldShowSearchHint: F = !1
}) {
  let K = NZ1.useMemo(() => {
      let v = nk(I);
      return ZK(v)
    }, [I]),
    D = l19(K),
    H = yXA(X),
    [{
      notifications: C
    }] = OQ(),
    E = w91(),
    q = !(H === "connected" && (W?.filePath || W?.text && W.lineCount > 0)) || G || Q?.status !== "success",
    w = E.isUsingOverage,
    N = f4(),
    R = N === "team" || N === "enterprise",
    T = Jg(),
    y = V && !D && A !== "invalid" && A !== "missing" && T !== void 0;
  return NZ1.useEffect(() => {
    if (y) GA("tengu_external_editor_hint_shown", {})
  }, [y]), w4.createElement(CQA, null, w4.createElement(S, {
    flexDirection: "column",
    alignItems: "flex-end"
  }, w4.createElement(a19, {
    ideSelection: W,
    mcpClients: X
  }), C.current && ("jsx" in C.current ? w4.createElement(S, {
    key: C.current.key
  }, C.current.jsx) : w4.createElement($, {
    color: C.current.color,
    dimColor: !C.current.color
  }, C.current.text)), w && !R && w4.createElement(S, null, w4.createElement($, {
    dimColor: !0
  }, "Now using extra usage")), A === "invalid" && w4.createElement(S, null, w4.createElement($, {
    color: "error"
  }, "Invalid API key · Run /login")), A === "missing" && w4.createElement(S, null, w4.createElement($, {
    color: "error"
  }, "Missing API key · Run /login")), B && w4.createElement(S, null, w4.createElement($, {
    color: "warning"
  }, "Debug mode")), A !== "invalid" && A !== "missing" && Z && w4.createElement(S, null, w4.createElement($, {
    dimColor: !0
  }, K, " tokens")), w4.createElement(c19, {
    tokenUsage: K
  }), q && w4.createElement(Mc2, {
    verbose: Z,
    onAutoUpdaterResult: Y,
    autoUpdaterResult: Q,
    isUpdating: G,
    onChangeIsUpdating: J,
    showSuccessMessage: !D
  }), F ? w4.createElement(S, null, w4.createElement($, {
    dimColor: !0
  }, "ctrl-r to search history")) : y && w4.createElement(S, null, w4.createElement($, {
    dimColor: !0
  }, "ctrl-g to edit prompt in "), w4.createElement($, {
    bold: !0,
    dimColor: !0
  }, aF(T))), w4.createElement(e19, null), w4.createElement(Q09, null)))
}
// @from(Start 13100441, End 13100443)
w4
// @from(Start 13100445, End 13100448)
NZ1
// @from(Start 13100450, End 13100460)
G09 = 5000
// @from(Start 13100466, End 13100666)
HJ0 = L(() => {
  hA();
  Oc2();
  $Z1();
  p19();
  i19();
  s19();
  qZ1();
  z9();
  A09();
  q0();
  pn();
  nY();
  GO();
  cQ();
  B09();
  Pi();
  gB();
  w4 = BA(VA(), 1), NZ1 = BA(VA(), 1)
})
// @from(Start 13100669, End 13102020)
function I09(A, Q, B, G) {
  let [Z, I] = vXA.useState(0), [Y, J] = vXA.useState(void 0), [W, X] = vXA.useState(!1), V = vXA.useRef(!1), F = F71(W ? G09 : 0), K = (q, w, N, R = !1) => {
    A(q, w, N), G?.(R ? 0 : q.length)
  }, D = (q, w = !1) => {
    if (!q) return;
    let N = Wf(q.display),
      R = N === "bash" || N === "memory" || N === "background" ? q.display.slice(1) : q.display;
    K(R, N, q.pastedContents, w)
  };

  function H() {
    (async () => {
      let q = [];
      for await (let N of Cm1()) q.push(N);
      if (Z >= q.length) return;
      if (Z === 0) {
        let N = Q.trim() !== "";
        J(N ? {
          display: Q,
          pastedContents: B
        } : void 0)
      }
      let w = Z + 1;
      if (I(w), D(q[Z], !0), w >= 2 && !V.current) X(!0), V.current = !0
    })()
  }

  function C() {
    return (async () => {
      let q = [];
      for await (let w of Cm1()) q.push(w);
      if (Z > 1) I(Z - 1), D(q[Z - 2]);
      else if (Z === 1)
        if (I(0), Y) D(Y);
        else K("", "prompt", {})
    })(), Z <= 0
  }

  function E() {
    J(void 0), I(0), X(!1)
  }

  function U() {
    X(!1), V.current = !0
  }
  return {
    historyIndex: Z,
    setHistoryIndex: I,
    onHistoryUp: H,
    onHistoryDown: C,
    resetHistory: E,
    shouldShowSearchHint: W && !F,
    dismissSearchHint: U
  }
}
// @from(Start 13102025, End 13102028)
vXA
// @from(Start 13102034, End 13102107)
Y09 = L(() => {
  zp();
  o7A();
  WZ0();
  HJ0();
  vXA = BA(VA(), 1)
})
// @from(Start 13102110, End 13102201)
function Og(A) {
  return !Array.isArray ? H09(A) === "[object Array]" : Array.isArray(A)
}
// @from(Start 13102203, End 13102324)
function TM3(A) {
  if (typeof A == "string") return A;
  let Q = A + "";
  return Q == "0" && 1 / A == -RM3 ? "-0" : Q
}
// @from(Start 13102326, End 13102378)
function PM3(A) {
  return A == null ? "" : TM3(A)
}
// @from(Start 13102380, End 13102429)
function Bx(A) {
  return typeof A === "string"
}
// @from(Start 13102431, End 13102481)
function K09(A) {
  return typeof A === "number"
}
// @from(Start 13102483, End 13102574)
function jM3(A) {
  return A === !0 || A === !1 || SM3(A) && H09(A) == "[object Boolean]"
}
// @from(Start 13102576, End 13102626)
function D09(A) {
  return typeof A === "object"
}
// @from(Start 13102628, End 13102677)
function SM3(A) {
  return D09(A) && A !== null
}
// @from(Start 13102679, End 13102733)
function aq(A) {
  return A !== void 0 && A !== null
}
// @from(Start 13102735, End 13102780)
function CJ0(A) {
  return !A.trim().length
}
// @from(Start 13102782, End 13102912)
function H09(A) {
  return A == null ? A === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(A)
}
// @from(Start 13102913, End 13103310)
class C09 {
  constructor(A) {
    this._keys = [], this._keyMap = {};
    let Q = 0;
    A.forEach((B) => {
      let G = E09(B);
      this._keys.push(G), this._keyMap[G.id] = G, Q += G.weight
    }), this._keys.forEach((B) => {
      B.weight /= Q
    })
  }
  get(A) {
    return this._keyMap[A]
  }
  keys() {
    return this._keys
  }
  toJSON() {
    return JSON.stringify(this._keys)
  }
}
// @from(Start 13103312, End 13103759)
function E09(A) {
  let Q = null,
    B = null,
    G = null,
    Z = 1,
    I = null;
  if (Bx(A) || Og(A)) G = A, Q = W09(A), B = EJ0(A);
  else {
    if (!J09.call(A, "name")) throw Error(xM3("name"));
    let Y = A.name;
    if (G = Y, J09.call(A, "weight")) {
      if (Z = A.weight, Z <= 0) throw Error(vM3(Y))
    }
    Q = W09(Y), B = EJ0(Y), I = A.getFn
  }
  return {
    path: Q,
    id: B,
    weight: Z,
    src: G,
    getFn: I
  }
}
// @from(Start 13103761, End 13103814)
function W09(A) {
  return Og(A) ? A : A.split(".")
}
// @from(Start 13103816, End 13103868)
function EJ0(A) {
  return Og(A) ? A.join(".") : A
}
// @from(Start 13103870, End 13104390)
function bM3(A, Q) {
  let B = [],
    G = !1,
    Z = (I, Y, J) => {
      if (!aq(I)) return;
      if (!Y[J]) B.push(I);
      else {
        let W = Y[J],
          X = I[W];
        if (!aq(X)) return;
        if (J === Y.length - 1 && (Bx(X) || K09(X) || jM3(X))) B.push(PM3(X));
        else if (Og(X)) {
          G = !0;
          for (let V = 0, F = X.length; V < F; V += 1) Z(X[V], Y, J + 1)
        } else if (Y.length) Z(X, Y, J + 1)
      }
    };
  return Z(A, Bx(Q) ? Q.split(".") : Q, 0), G ? B : B[0]
}
// @from(Start 13104392, End 13104724)
function dM3(A = 1, Q = 3) {
  let B = new Map,
    G = Math.pow(10, Q);
  return {
    get(Z) {
      let I = Z.match(mM3).length;
      if (B.has(I)) return B.get(I);
      let Y = 1 / Math.pow(I, 0.5 * A),
        J = parseFloat(Math.round(Y * G) / G);
      return B.set(I, J), J
    },
    clear() {
      B.clear()
    }
  }
}
// @from(Start 13104725, End 13106999)
class OZ1 {
  constructor({
    getFn: A = B8.getFn,
    fieldNormWeight: Q = B8.fieldNormWeight
  } = {}) {
    this.norm = dM3(Q, 3), this.getFn = A, this.isCreated = !1, this.setIndexRecords()
  }
  setSources(A = []) {
    this.docs = A
  }
  setIndexRecords(A = []) {
    this.records = A
  }
  setKeys(A = []) {
    this.keys = A, this._keysMap = {}, A.forEach((Q, B) => {
      this._keysMap[Q.id] = B
    })
  }
  create() {
    if (this.isCreated || !this.docs.length) return;
    if (this.isCreated = !0, Bx(this.docs[0])) this.docs.forEach((A, Q) => {
      this._addString(A, Q)
    });
    else this.docs.forEach((A, Q) => {
      this._addObject(A, Q)
    });
    this.norm.clear()
  }
  add(A) {
    let Q = this.size();
    if (Bx(A)) this._addString(A, Q);
    else this._addObject(A, Q)
  }
  removeAt(A) {
    this.records.splice(A, 1);
    for (let Q = A, B = this.size(); Q < B; Q += 1) this.records[Q].i -= 1
  }
  getValueForItemAtKeyId(A, Q) {
    return A[this._keysMap[Q]]
  }
  size() {
    return this.records.length
  }
  _addString(A, Q) {
    if (!aq(A) || CJ0(A)) return;
    let B = {
      v: A,
      i: Q,
      n: this.norm.get(A)
    };
    this.records.push(B)
  }
  _addObject(A, Q) {
    let B = {
      i: Q,
      $: {}
    };
    this.keys.forEach((G, Z) => {
      let I = G.getFn ? G.getFn(A) : this.getFn(A, G.path);
      if (!aq(I)) return;
      if (Og(I)) {
        let Y = [],
          J = [{
            nestedArrIndex: -1,
            value: I
          }];
        while (J.length) {
          let {
            nestedArrIndex: W,
            value: X
          } = J.pop();
          if (!aq(X)) continue;
          if (Bx(X) && !CJ0(X)) {
            let V = {
              v: X,
              i: W,
              n: this.norm.get(X)
            };
            Y.push(V)
          } else if (Og(X)) X.forEach((V, F) => {
            J.push({
              nestedArrIndex: F,
              value: V
            })
          })
        }
        B.$[Z] = Y
      } else if (Bx(I) && !CJ0(I)) {
        let Y = {
          v: I,
          n: this.norm.get(I)
        };
        B.$[Z] = Y
      }
    }), this.records.push(B)
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    }
  }
}
// @from(Start 13107001, End 13107224)
function z09(A, Q, {
  getFn: B = B8.getFn,
  fieldNormWeight: G = B8.fieldNormWeight
} = {}) {
  let Z = new OZ1({
    getFn: B,
    fieldNormWeight: G
  });
  return Z.setKeys(A.map(E09)), Z.setSources(Q), Z.create(), Z
}
// @from(Start 13107226, End 13107469)
function cM3(A, {
  getFn: Q = B8.getFn,
  fieldNormWeight: B = B8.fieldNormWeight
} = {}) {
  let {
    keys: G,
    records: Z
  } = A, I = new OZ1({
    getFn: Q,
    fieldNormWeight: B
  });
  return I.setKeys(G), I.setIndexRecords(Z), I
}
// @from(Start 13107471, End 13107756)
function LZ1(A, {
  errors: Q = 0,
  currentLocation: B = 0,
  expectedLocation: G = 0,
  distance: Z = B8.distance,
  ignoreLocation: I = B8.ignoreLocation
} = {}) {
  let Y = Q / A.length;
  if (I) return Y;
  let J = Math.abs(G - B);
  if (!Z) return J ? 1 : Y;
  return Y + J / Z
}
// @from(Start 13107758, End 13108116)
function pM3(A = [], Q = B8.minMatchCharLength) {
  let B = [],
    G = -1,
    Z = -1,
    I = 0;
  for (let Y = A.length; I < Y; I += 1) {
    let J = A[I];
    if (J && G === -1) G = I;
    else if (!J && G !== -1) {
      if (Z = I - 1, Z - G + 1 >= Q) B.push([G, Z]);
      G = -1
    }
  }
  if (A[I - 1] && I - G >= Q) B.push([G, I - 1]);
  return B
}
// @from(Start 13108118, End 13110306)
function lM3(A, Q, B, {
  location: G = B8.location,
  distance: Z = B8.distance,
  threshold: I = B8.threshold,
  findAllMatches: Y = B8.findAllMatches,
  minMatchCharLength: J = B8.minMatchCharLength,
  includeMatches: W = B8.includeMatches,
  ignoreLocation: X = B8.ignoreLocation
} = {}) {
  if (Q.length > UQA) throw Error(yM3(UQA));
  let V = Q.length,
    F = A.length,
    K = Math.max(0, Math.min(G, F)),
    D = I,
    H = K,
    C = J > 1 || W,
    E = C ? Array(F) : [],
    U;
  while ((U = A.indexOf(Q, H)) > -1) {
    let y = LZ1(Q, {
      currentLocation: U,
      expectedLocation: K,
      distance: Z,
      ignoreLocation: X
    });
    if (D = Math.min(y, D), H = U + V, C) {
      let v = 0;
      while (v < V) E[U + v] = 1, v += 1
    }
  }
  H = -1;
  let q = [],
    w = 1,
    N = V + F,
    R = 1 << V - 1;
  for (let y = 0; y < V; y += 1) {
    let v = 0,
      x = N;
    while (v < x) {
      if (LZ1(Q, {
          errors: y,
          currentLocation: K + x,
          expectedLocation: K,
          distance: Z,
          ignoreLocation: X
        }) <= D) v = x;
      else N = x;
      x = Math.floor((N - v) / 2 + v)
    }
    N = x;
    let p = Math.max(1, K - x + 1),
      u = Y ? F : Math.min(K + x, F) + V,
      e = Array(u + 2);
    e[u + 1] = (1 << y) - 1;
    for (let k = u; k >= p; k -= 1) {
      let m = k - 1,
        o = B[A.charAt(m)];
      if (C) E[m] = +!!o;
      if (e[k] = (e[k + 1] << 1 | 1) & o, y) e[k] |= (q[k + 1] | q[k]) << 1 | 1 | q[k + 1];
      if (e[k] & R) {
        if (w = LZ1(Q, {
            errors: y,
            currentLocation: m,
            expectedLocation: K,
            distance: Z,
            ignoreLocation: X
          }), w <= D) {
          if (D = w, H = m, H <= K) break;
          p = Math.max(1, 2 * K - H)
        }
      }
    }
    if (LZ1(Q, {
        errors: y + 1,
        currentLocation: K,
        expectedLocation: K,
        distance: Z,
        ignoreLocation: X
      }) > D) break;
    q = e
  }
  let T = {
    isMatch: H >= 0,
    score: Math.max(0.001, w)
  };
  if (C) {
    let y = pM3(E, J);
    if (!y.length) T.isMatch = !1;
    else if (W) T.indices = y
  }
  return T
}
// @from(Start 13110308, End 13110470)
function iM3(A) {
  let Q = {};
  for (let B = 0, G = A.length; B < G; B += 1) {
    let Z = A.charAt(B);
    Q[Z] = (Q[Z] || 0) | 1 << G - B - 1
  }
  return Q
}
// @from(Start 13110471, End 13112675)
class NJ0 {
  constructor(A, {
    location: Q = B8.location,
    threshold: B = B8.threshold,
    distance: G = B8.distance,
    includeMatches: Z = B8.includeMatches,
    findAllMatches: I = B8.findAllMatches,
    minMatchCharLength: Y = B8.minMatchCharLength,
    isCaseSensitive: J = B8.isCaseSensitive,
    ignoreLocation: W = B8.ignoreLocation
  } = {}) {
    if (this.options = {
        location: Q,
        threshold: B,
        distance: G,
        includeMatches: Z,
        findAllMatches: I,
        minMatchCharLength: Y,
        isCaseSensitive: J,
        ignoreLocation: W
      }, this.pattern = J ? A : A.toLowerCase(), this.chunks = [], !this.pattern.length) return;
    let X = (F, K) => {
        this.chunks.push({
          pattern: F,
          alphabet: iM3(F),
          startIndex: K
        })
      },
      V = this.pattern.length;
    if (V > UQA) {
      let F = 0,
        K = V % UQA,
        D = V - K;
      while (F < D) X(this.pattern.substr(F, UQA), F), F += UQA;
      if (K) {
        let H = V - UQA;
        X(this.pattern.substr(H), H)
      }
    } else X(this.pattern, 0)
  }
  searchIn(A) {
    let {
      isCaseSensitive: Q,
      includeMatches: B
    } = this.options;
    if (!Q) A = A.toLowerCase();
    if (this.pattern === A) {
      let D = {
        isMatch: !0,
        score: 0
      };
      if (B) D.indices = [
        [0, A.length - 1]
      ];
      return D
    }
    let {
      location: G,
      distance: Z,
      threshold: I,
      findAllMatches: Y,
      minMatchCharLength: J,
      ignoreLocation: W
    } = this.options, X = [], V = 0, F = !1;
    this.chunks.forEach(({
      pattern: D,
      alphabet: H,
      startIndex: C
    }) => {
      let {
        isMatch: E,
        score: U,
        indices: q
      } = lM3(A, D, H, {
        location: G + C,
        distance: Z,
        threshold: I,
        findAllMatches: Y,
        minMatchCharLength: J,
        includeMatches: B,
        ignoreLocation: W
      });
      if (E) F = !0;
      if (V += U, E && q) X = [...X, ...q]
    });
    let K = {
      isMatch: F,
      score: F ? V / this.chunks.length : 1
    };
    if (F && B) K.indices = X;
    return K
  }
}
// @from(Start 13112676, End 13112880)
class Rg {
  constructor(A) {
    this.pattern = A
  }
  static isMultiMatch(A) {
    return X09(A, this.multiRegex)
  }
  static isSingleMatch(A) {
    return X09(A, this.singleRegex)
  }
  search() {}
}
// @from(Start 13112882, End 13112951)
function X09(A, Q) {
  let B = A.match(Q);
  return B ? B[1] : null
}
// @from(Start 13112953, End 13113563)
function sM3(A, Q = {}) {
  return A.split(aM3).map((B) => {
    let G = B.trim().split(nM3).filter((I) => I && !!I.trim()),
      Z = [];
    for (let I = 0, Y = G.length; I < Y; I += 1) {
      let J = G[I],
        W = !1,
        X = -1;
      while (!W && ++X < V09) {
        let V = zJ0[X],
          F = V.isMultiMatch(J);
        if (F) Z.push(new V(F, Q)), W = !0
      }
      if (W) continue;
      X = -1;
      while (++X < V09) {
        let V = zJ0[X],
          F = V.isSingleMatch(J);
        if (F) {
          Z.push(new V(F, Q));
          break
        }
      }
    }
    return Z
  })
}
// @from(Start 13113564, End 13115326)
class M09 {
  constructor(A, {
    isCaseSensitive: Q = B8.isCaseSensitive,
    includeMatches: B = B8.includeMatches,
    minMatchCharLength: G = B8.minMatchCharLength,
    ignoreLocation: Z = B8.ignoreLocation,
    findAllMatches: I = B8.findAllMatches,
    location: Y = B8.location,
    threshold: J = B8.threshold,
    distance: W = B8.distance
  } = {}) {
    this.query = null, this.options = {
      isCaseSensitive: Q,
      includeMatches: B,
      minMatchCharLength: G,
      findAllMatches: I,
      ignoreLocation: Z,
      location: Y,
      threshold: J,
      distance: W
    }, this.pattern = Q ? A : A.toLowerCase(), this.query = sM3(this.pattern, this.options)
  }
  static condition(A, Q) {
    return Q.useExtendedSearch
  }
  searchIn(A) {
    let Q = this.query;
    if (!Q) return {
      isMatch: !1,
      score: 1
    };
    let {
      includeMatches: B,
      isCaseSensitive: G
    } = this.options;
    A = G ? A : A.toLowerCase();
    let Z = 0,
      I = [],
      Y = 0;
    for (let J = 0, W = Q.length; J < W; J += 1) {
      let X = Q[J];
      I.length = 0, Z = 0;
      for (let V = 0, F = X.length; V < F; V += 1) {
        let K = X[V],
          {
            isMatch: D,
            indices: H,
            score: C
          } = K.search(A);
        if (D) {
          if (Z += 1, Y += C, B) {
            let E = K.constructor.type;
            if (rM3.has(E)) I = [...I, ...H];
            else I.push(H)
          }
        } else {
          Y = 0, Z = 0, I.length = 0;
          break
        }
      }
      if (Z) {
        let V = {
          isMatch: !0,
          score: Y / Z
        };
        if (B) V.indices = I;
        return V
      }
    }
    return {
      isMatch: !1,
      score: 1
    }
  }
}
// @from(Start 13115328, End 13115367)
function oM3(...A) {
  UJ0.push(...A)
}
// @from(Start 13115369, End 13115535)
function $J0(A, Q) {
  for (let B = 0, G = UJ0.length; B < G; B += 1) {
    let Z = UJ0[B];
    if (Z.condition(A, Q)) return new Z(A, Q)
  }
  return new NJ0(A, Q)
}
// @from(Start 13115537, End 13116208)
function O09(A, Q, {
  auto: B = !0
} = {}) {
  let G = (Z) => {
    let I = Object.keys(Z),
      Y = tM3(Z);
    if (!Y && I.length > 1 && !qJ0(Z)) return G(F09(Z));
    if (eM3(Z)) {
      let W = Y ? Z[wJ0.PATH] : I[0],
        X = Y ? Z[wJ0.PATTERN] : Z[W];
      if (!Bx(X)) throw Error(kM3(W));
      let V = {
        keyId: EJ0(W),
        pattern: X
      };
      if (B) V.searcher = $J0(X, Q);
      return V
    }
    let J = {
      children: [],
      operator: I[0]
    };
    return I.forEach((W) => {
      let X = Z[W];
      if (Og(X)) X.forEach((V) => {
        J.children.push(G(V))
      })
    }), J
  };
  if (!qJ0(A)) A = F09(A);
  return G(A)
}
// @from(Start 13116210, End 13116532)
function AO3(A, {
  ignoreFieldNorm: Q = B8.ignoreFieldNorm
}) {
  A.forEach((B) => {
    let G = 1;
    B.matches.forEach(({
      key: Z,
      norm: I,
      score: Y
    }) => {
      let J = Z ? Z.weight : null;
      G *= Math.pow(Y === 0 && J ? Number.EPSILON : Y, (J || 1) * (Q ? 1 : I))
    }), B.score = G
  })
}
// @from(Start 13116534, End 13116890)
function QO3(A, Q) {
  let B = A.matches;
  if (Q.matches = [], !aq(B)) return;
  B.forEach((G) => {
    if (!aq(G.indices) || !G.indices.length) return;
    let {
      indices: Z,
      value: I
    } = G, Y = {
      indices: Z,
      value: I
    };
    if (G.key) Y.key = G.key.src;
    if (G.idx > -1) Y.refIndex = G.idx;
    Q.matches.push(Y)
  })
}
// @from(Start 13116892, End 13116934)
function BO3(A, Q) {
  Q.score = A.score
}
// @from(Start 13116936, End 13117287)
function GO3(A, Q, {
  includeMatches: B = B8.includeMatches,
  includeScore: G = B8.includeScore
} = {}) {
  let Z = [];
  if (B) Z.push(QO3);
  if (G) Z.push(BO3);
  return A.map((I) => {
    let {
      idx: Y
    } = I, J = {
      item: Q[Y],
      refIndex: Y
    };
    if (Z.length) Z.forEach((W) => {
      W(I, J)
    });
    return J
  })
}
// @from(Start 13117288, End 13121635)
class yO {
  constructor(A, Q = {}, B) {
    this.options = {
      ...B8,
      ...Q
    }, this.options.useExtendedSearch, this._keyStore = new C09(this.options.keys), this.setCollection(A, B)
  }
  setCollection(A, Q) {
    if (this._docs = A, Q && !(Q instanceof OZ1)) throw Error(_M3);
    this._myIndex = Q || z09(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    })
  }
  add(A) {
    if (!aq(A)) return;
    this._docs.push(A), this._myIndex.add(A)
  }
  remove(A = () => !1) {
    let Q = [];
    for (let B = 0, G = this._docs.length; B < G; B += 1) {
      let Z = this._docs[B];
      if (A(Z, B)) this.removeAt(B), B -= 1, G -= 1, Q.push(Z)
    }
    return Q
  }
  removeAt(A) {
    this._docs.splice(A, 1), this._myIndex.removeAt(A)
  }
  getIndex() {
    return this._myIndex
  }
  search(A, {
    limit: Q = -1
  } = {}) {
    let {
      includeMatches: B,
      includeScore: G,
      shouldSort: Z,
      sortFn: I,
      ignoreFieldNorm: Y
    } = this.options, J = Bx(A) ? Bx(this._docs[0]) ? this._searchStringList(A) : this._searchObjectList(A) : this._searchLogical(A);
    if (AO3(J, {
        ignoreFieldNorm: Y
      }), Z) J.sort(I);
    if (K09(Q) && Q > -1) J = J.slice(0, Q);
    return GO3(J, this._docs, {
      includeMatches: B,
      includeScore: G
    })
  }
  _searchStringList(A) {
    let Q = $J0(A, this.options),
      {
        records: B
      } = this._myIndex,
      G = [];
    return B.forEach(({
      v: Z,
      i: I,
      n: Y
    }) => {
      if (!aq(Z)) return;
      let {
        isMatch: J,
        score: W,
        indices: X
      } = Q.searchIn(Z);
      if (J) G.push({
        item: Z,
        idx: I,
        matches: [{
          score: W,
          value: Z,
          norm: Y,
          indices: X
        }]
      })
    }), G
  }
  _searchLogical(A) {
    let Q = O09(A, this.options),
      B = (Y, J, W) => {
        if (!Y.children) {
          let {
            keyId: V,
            searcher: F
          } = Y, K = this._findMatches({
            key: this._keyStore.get(V),
            value: this._myIndex.getValueForItemAtKeyId(J, V),
            searcher: F
          });
          if (K && K.length) return [{
            idx: W,
            item: J,
            matches: K
          }];
          return []
        }
        let X = [];
        for (let V = 0, F = Y.children.length; V < F; V += 1) {
          let K = Y.children[V],
            D = B(K, J, W);
          if (D.length) X.push(...D);
          else if (Y.operator === MZ1.AND) return []
        }
        return X
      },
      G = this._myIndex.records,
      Z = {},
      I = [];
    return G.forEach(({
      $: Y,
      i: J
    }) => {
      if (aq(Y)) {
        let W = B(Q, Y, J);
        if (W.length) {
          if (!Z[J]) Z[J] = {
            idx: J,
            item: Y,
            matches: []
          }, I.push(Z[J]);
          W.forEach(({
            matches: X
          }) => {
            Z[J].matches.push(...X)
          })
        }
      }
    }), I
  }
  _searchObjectList(A) {
    let Q = $J0(A, this.options),
      {
        keys: B,
        records: G
      } = this._myIndex,
      Z = [];
    return G.forEach(({
      $: I,
      i: Y
    }) => {
      if (!aq(I)) return;
      let J = [];
      if (B.forEach((W, X) => {
          J.push(...this._findMatches({
            key: W,
            value: I[X],
            searcher: Q
          }))
        }), J.length) Z.push({
        idx: Y,
        item: I,
        matches: J
      })
    }), Z
  }
  _findMatches({
    key: A,
    value: Q,
    searcher: B
  }) {
    if (!aq(Q)) return [];
    let G = [];
    if (Og(Q)) Q.forEach(({
      v: Z,
      i: I,
      n: Y
    }) => {
      if (!aq(Z)) return;
      let {
        isMatch: J,
        score: W,
        indices: X
      } = B.searchIn(Z);
      if (J) G.push({
        score: W,
        key: A,
        value: Z,
        idx: I,
        norm: Y,
        indices: X
      })
    });
    else {
      let {
        v: Z,
        n: I
      } = Q, {
        isMatch: Y,
        score: J,
        indices: W
      } = B.searchIn(Z);
      if (Y) G.push({
        score: J,
        key: A,
        value: Z,
        norm: I,
        indices: W
      })
    }
    return G
  }
}
// @from(Start 13121640, End 13121651)
RM3 = 1 / 0
// @from(Start 13121655, End 13121685)
_M3 = "Incorrect 'index' type"
// @from(Start 13121689, End 13121730)
kM3 = (A) => `Invalid value for key ${A}`
// @from(Start 13121734, End 13121784)
yM3 = (A) => `Pattern length exceeds max of ${A}.`
// @from(Start 13121788, End 13121831)
xM3 = (A) => `Missing ${A} property in key`
// @from(Start 13121835, End 13121908)
vM3 = (A) => `Property 'weight' in key '${A}' must be a positive integer`
// @from(Start 13121912, End 13121915)
J09
// @from(Start 13121917, End 13121920)
fM3
// @from(Start 13121922, End 13121925)
hM3
// @from(Start 13121927, End 13121930)
gM3
// @from(Start 13121932, End 13121935)
uM3
// @from(Start 13121937, End 13121939)
B8
// @from(Start 13121941, End 13121944)
mM3
// @from(Start 13121946, End 13121954)
UQA = 32
// @from(Start 13121958, End 13121961)
U09
// @from(Start 13121963, End 13121966)
$09
// @from(Start 13121968, End 13121971)
w09
// @from(Start 13121973, End 13121976)
q09
// @from(Start 13121978, End 13121981)
N09
// @from(Start 13121983, End 13121986)
L09
// @from(Start 13121988, End 13121991)
LJ0
// @from(Start 13121993, End 13121996)
MJ0
// @from(Start 13121998, End 13122001)
zJ0
// @from(Start 13122003, End 13122006)
V09
// @from(Start 13122008, End 13122011)
nM3
// @from(Start 13122013, End 13122022)
aM3 = "|"
// @from(Start 13122026, End 13122029)
rM3
// @from(Start 13122031, End 13122034)
UJ0
// @from(Start 13122036, End 13122039)
MZ1
// @from(Start 13122041, End 13122044)
wJ0
// @from(Start 13122046, End 13122086)
qJ0 = (A) => !!(A[MZ1.AND] || A[MZ1.OR])
// @from(Start 13122090, End 13122116)
tM3 = (A) => !!A[wJ0.PATH]
// @from(Start 13122120, End 13122160)
eM3 = (A) => !Og(A) && D09(A) && !qJ0(A)
// @from(Start 13122164, End 13122252)
F09 = (A) => ({
    [MZ1.AND]: Object.keys(A).map((Q) => ({
      [Q]: A[Q]
    }))
  })
// @from(Start 13122258, End 13127322)
RZ1 = L(() => {
  J09 = Object.prototype.hasOwnProperty;
  fM3 = {
    includeMatches: !1,
    findAllMatches: !1,
    minMatchCharLength: 1
  }, hM3 = {
    isCaseSensitive: !1,
    includeScore: !1,
    keys: [],
    shouldSort: !0,
    sortFn: (A, Q) => A.score === Q.score ? A.idx < Q.idx ? -1 : 1 : A.score < Q.score ? -1 : 1
  }, gM3 = {
    location: 0,
    threshold: 0.6,
    distance: 100
  }, uM3 = {
    useExtendedSearch: !1,
    getFn: bM3,
    ignoreLocation: !1,
    ignoreFieldNorm: !1,
    fieldNormWeight: 1
  }, B8 = {
    ...hM3,
    ...fM3,
    ...gM3,
    ...uM3
  }, mM3 = /[^ ]+/g;
  U09 = class U09 extends Rg {
    constructor(A) {
      super(A)
    }
    static get type() {
      return "exact"
    }
    static get multiRegex() {
      return /^="(.*)"$/
    }
    static get singleRegex() {
      return /^=(.*)$/
    }
    search(A) {
      let Q = A === this.pattern;
      return {
        isMatch: Q,
        score: Q ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      }
    }
  };
  $09 = class $09 extends Rg {
    constructor(A) {
      super(A)
    }
    static get type() {
      return "inverse-exact"
    }
    static get multiRegex() {
      return /^!"(.*)"$/
    }
    static get singleRegex() {
      return /^!(.*)$/
    }
    search(A) {
      let B = A.indexOf(this.pattern) === -1;
      return {
        isMatch: B,
        score: B ? 0 : 1,
        indices: [0, A.length - 1]
      }
    }
  };
  w09 = class w09 extends Rg {
    constructor(A) {
      super(A)
    }
    static get type() {
      return "prefix-exact"
    }
    static get multiRegex() {
      return /^\^"(.*)"$/
    }
    static get singleRegex() {
      return /^\^(.*)$/
    }
    search(A) {
      let Q = A.startsWith(this.pattern);
      return {
        isMatch: Q,
        score: Q ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      }
    }
  };
  q09 = class q09 extends Rg {
    constructor(A) {
      super(A)
    }
    static get type() {
      return "inverse-prefix-exact"
    }
    static get multiRegex() {
      return /^!\^"(.*)"$/
    }
    static get singleRegex() {
      return /^!\^(.*)$/
    }
    search(A) {
      let Q = !A.startsWith(this.pattern);
      return {
        isMatch: Q,
        score: Q ? 0 : 1,
        indices: [0, A.length - 1]
      }
    }
  };
  N09 = class N09 extends Rg {
    constructor(A) {
      super(A)
    }
    static get type() {
      return "suffix-exact"
    }
    static get multiRegex() {
      return /^"(.*)"\$$/
    }
    static get singleRegex() {
      return /^(.*)\$$/
    }
    search(A) {
      let Q = A.endsWith(this.pattern);
      return {
        isMatch: Q,
        score: Q ? 0 : 1,
        indices: [A.length - this.pattern.length, A.length - 1]
      }
    }
  };
  L09 = class L09 extends Rg {
    constructor(A) {
      super(A)
    }
    static get type() {
      return "inverse-suffix-exact"
    }
    static get multiRegex() {
      return /^!"(.*)"\$$/
    }
    static get singleRegex() {
      return /^!(.*)\$$/
    }
    search(A) {
      let Q = !A.endsWith(this.pattern);
      return {
        isMatch: Q,
        score: Q ? 0 : 1,
        indices: [0, A.length - 1]
      }
    }
  };
  LJ0 = class LJ0 extends Rg {
    constructor(A, {
      location: Q = B8.location,
      threshold: B = B8.threshold,
      distance: G = B8.distance,
      includeMatches: Z = B8.includeMatches,
      findAllMatches: I = B8.findAllMatches,
      minMatchCharLength: Y = B8.minMatchCharLength,
      isCaseSensitive: J = B8.isCaseSensitive,
      ignoreLocation: W = B8.ignoreLocation
    } = {}) {
      super(A);
      this._bitapSearch = new NJ0(A, {
        location: Q,
        threshold: B,
        distance: G,
        includeMatches: Z,
        findAllMatches: I,
        minMatchCharLength: Y,
        isCaseSensitive: J,
        ignoreLocation: W
      })
    }
    static get type() {
      return "fuzzy"
    }
    static get multiRegex() {
      return /^"(.*)"$/
    }
    static get singleRegex() {
      return /^(.*)$/
    }
    search(A) {
      return this._bitapSearch.searchIn(A)
    }
  };
  MJ0 = class MJ0 extends Rg {
    constructor(A) {
      super(A)
    }
    static get type() {
      return "include"
    }
    static get multiRegex() {
      return /^'"(.*)"$/
    }
    static get singleRegex() {
      return /^'(.*)$/
    }
    search(A) {
      let Q = 0,
        B, G = [],
        Z = this.pattern.length;
      while ((B = A.indexOf(this.pattern, Q)) > -1) Q = B + Z, G.push([B, Q - 1]);
      let I = !!G.length;
      return {
        isMatch: I,
        score: I ? 0 : 1,
        indices: G
      }
    }
  };
  zJ0 = [U09, MJ0, w09, q09, L09, N09, $09, LJ0], V09 = zJ0.length, nM3 = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  rM3 = new Set([LJ0.type, MJ0.type]);
  UJ0 = [];
  MZ1 = {
    AND: "$and",
    OR: "$or"
  }, wJ0 = {
    PATH: "$path",
    PATTERN: "$val"
  };
  yO.version = "7.0.0";
  yO.createIndex = z09;
  yO.parseIndex = cM3;
  yO.config = B8;
  yO.parseQuery = O09;
  oM3(M09)
})
// @from(Start 13127325, End 13127371)
function bXA(A) {
  return A.startsWith("/")
}
// @from(Start 13127373, End 13127499)
function IO3(A) {
  if (!bXA(A)) return !1;
  if (!A.includes(" ")) return !1;
  if (A.endsWith(" ")) return !1;
  return !0
}
// @from(Start 13127501, End 13127538)
function YO3(A) {
  return `/${A} `
}
// @from(Start 13127540, End 13127866)
function R09(A) {
  let Q = A.userFacingName(),
    B = A.aliases && A.aliases.length > 0 ? ` (${A.aliases.join(", ")})` : "";
  return {
    id: Q,
    displayText: `/${Q}${B}`,
    description: A.description + (A.type === "prompt" && A.argNames?.length ? ` (arguments: ${A.argNames.join(", ")})` : ""),
    metadata: A
  }
}
// @from(Start 13127868, End 13129277)
function T09(A, Q) {
  if (!bXA(A)) return [];
  if (IO3(A)) return [];
  let B = A.slice(1).toLowerCase().trim();
  if (B === "") {
    let Y = Q.filter((K) => !K.isHidden),
      J = [],
      W = [],
      X = [],
      V = [];
    Y.forEach((K) => {
      if (K.type === "prompt" && K.source === "localSettings") J.push(K);
      else if (K.type === "prompt" && K.source === "projectSettings") W.push(K);
      else if (K.type === "prompt" && K.source === "policySettings") X.push(K);
      else V.push(K)
    });
    let F = (K, D) => K.userFacingName().localeCompare(D.userFacingName());
    return J.sort(F), W.sort(F), X.sort(F), V.sort(F), [...J, ...W, ...X, ...V].map(R09)
  }
  let G = Q.filter((Y) => !Y.isHidden).map((Y) => {
    let J = Y.userFacingName(),
      W = J.split(ZO3).filter(Boolean);
    return {
      nameKey: J,
      descriptionKey: Y.description.split(" ").map((X) => JO3(X)).filter(Boolean),
      partKey: W.length > 1 ? W : void 0,
      commandName: J,
      command: Y,
      aliasKey: Y.aliases
    }
  });
  return new yO(G, {
    includeScore: !0,
    threshold: 0.3,
    location: 0,
    distance: 100,
    keys: [{
      name: "commandName",
      weight: 3
    }, {
      name: "partKey",
      weight: 2
    }, {
      name: "aliasKey",
      weight: 2
    }, {
      name: "descriptionKey",
      weight: 0.5
    }]
  }).search(B).map((Y) => R09(Y.item.command))
}
// @from(Start 13129279, End 13129349)
function JO3(A) {
  return A.toLowerCase().replace(/[^a-z0-9]/g, "")
}
// @from(Start 13129351, End 13129611)
function OJ0(A, Q, B, G, Z, I) {
  let Y = typeof A === "string" ? A : A.id,
    J = YO3(Y);
  if (G(J), Z(J.length), Q) {
    let W = typeof A === "string" ? Pq(Y, B) : A.metadata;
    if (W.type !== "prompt" || (W.argNames ?? []).length === 0) I(J, !0)
  }
}
// @from(Start 13129616, End 13129619)
ZO3
// @from(Start 13129625, End 13129677)
P09 = L(() => {
  RZ1();
  cE();
  ZO3 = /[:_-]/g
})
// @from(Start 13129769, End 13130046)
function HO3(A, Q) {
  if (!A) return {
    directory: Q || W0(),
    prefix: ""
  };
  let B = b9(A, Q);
  if (A.endsWith("/") || A.endsWith(FO3)) return {
    directory: B,
    prefix: ""
  };
  let G = WO3(B),
    Z = XO3(A);
  return {
    directory: G,
    prefix: Z
  }
}
// @from(Start 13130048, End 13130424)
function CO3(A) {
  let Q = j09.get(A);
  if (Q) return Q;
  try {
    let Z = RA().readdirSync(A).filter((I) => I.isDirectory() && !I.name.startsWith(".")).map((I) => ({
      name: I.name,
      path: VO3(A, I.name),
      type: "directory"
    })).slice(0, 100);
    return j09.set(A, Z), Z
  } catch (B) {
    return AA(B instanceof Error ? B : Error(String(B))), []
  }
}
// @from(Start 13130425, End 13130798)
async function S09(A, Q = {}) {
  let {
    basePath: B = W0(),
    maxResults: G = 10
  } = Q, {
    directory: Z,
    prefix: I
  } = HO3(A, B), Y = CO3(Z), J = I.toLowerCase();
  return Y.filter((X) => X.name.toLowerCase().startsWith(J)).slice(0, G).map((X) => ({
    id: X.path,
    displayText: X.name + "/",
    description: "directory",
    type: "directory"
  }))
}
// @from(Start 13130803, End 13130812)
KO3 = 500
// @from(Start 13130816, End 13130828)
DO3 = 300000
// @from(Start 13130832, End 13130835)
j09
// @from(Start 13130841, End 13130949)
_09 = L(() => {
  bbA();
  U2();
  AQ();
  g1();
  yI();
  j09 = new tm({
    max: KO3,
    ttl: DO3
  })
})
// @from(Start 13130955, End 13130963)
RJ0 = {}
// @from(Start 13131028, End 13131031)
TZ1
// @from(Start 13131033, End 13131036)
EO3
// @from(Start 13131038, End 13131041)
zO3
// @from(Start 13131047, End 13131256)
TJ0 = L(() => {
  try {
    TZ1 = (() => {
      throw new Error("Cannot require module " + "../../file-index.node");
    })()
  } catch (A) {
    TZ1 = null
  }
  EO3 = TZ1?.FileIndex, zO3 = TZ1?.FileIndex
})
// @from(Start 13131286, End 13131713)
async function UO3() {
  if (PJ0) return null;
  if (PZ1) return PZ1;
  if (UX()) try {
    return PZ1 = new(await Promise.resolve().then(() => (TJ0(), RJ0))).FileIndex, PZ1
  } catch (A) {
    return PJ0 = !0, g(`[FileIndex] Rust module unavailable, falling back to Fuse.js: ${A instanceof Error?A.message:String(A)}`), AA(A), null
  } else return PJ0 = !0, g("[FileIndex] Not in bundled mode, using Fuse.js fallback"), null
}
// @from(Start 13131715, End 13131920)
function wO3(A) {
  let Q = new Set;
  return A.forEach((B) => {
    let Z = $K.dirname(B);
    while (Z !== "." && Z !== $K.parse(Z).root) Q.add(Z), Z = $K.dirname(Z)
  }), [...Q].map((B) => B + $K.sep)
}
// @from(Start 13131921, End 13132038)
async function qO3() {
  return (await Promise.all(v09.map((Q) => _n(Q)))).flatMap((Q) => Q.map((B) => B.filePath))
}
// @from(Start 13132039, End 13132777)
async function NO3() {
  let A = o9(),
    Q = setTimeout(() => {
      A.abort()
    }, 1e4);
  try {
    let G = N1().respectGitignore ?? !0,
      Z = ["--files", "--follow", "--hidden", "--glob", "!.git/"];
    if (!G) Z.push("--no-ignore-vcs");
    let [I, Y] = await Promise.all([aj(Z, ".", A.signal).then((K) => K.map((D) => $K.relative(uQ(), D))), qO3()]), J = [...I, ...Y], X = [...wO3(J), ...J], V = [], F = await UO3();
    if (F) try {
      F.loadFromFileList(X)
    } catch (K) {
      g(`[FileIndex] Failed to load Rust index, using Fuse.js fallback: ${K instanceof Error?K.message:String(K)}`), AA(K), V = X
    } else V = X;
    return {
      fileIndex: F,
      fileList: V
    }
  } finally {
    clearTimeout(Q)
  }
}
// @from(Start 13132779, End 13132917)
function LO3(A, Q) {
  let B = Math.min(A.length, Q.length),
    G = 0;
  while (G < B && A[G] === Q[G]) G++;
  return A.substring(0, G)
}
// @from(Start 13132919, End 13133139)
function y09(A) {
  if (A.length === 0) return "";
  let Q = A.map((G) => G.displayText),
    B = Q[0];
  for (let G = 1; G < Q.length; G++) {
    let Z = Q[G];
    if (B = LO3(B, Z), B === "") return ""
  }
  return B
}
// @from(Start 13133141, End 13133280)
function jZ1(A, Q) {
  return {
    id: `file-${A}`,
    displayText: A,
    metadata: Q !== void 0 ? {
      score: Q
    } : void 0
  }
}
// @from(Start 13133281, End 13134570)
async function MO3(A, Q, B) {
  if (A) try {
    return A.search(B, sPA).map((X) => jZ1(X.path, X.score))
  } catch (W) {
    g(`[FileIndex] Rust search failed, falling back to Fuse.js: ${W instanceof Error?W.message:String(W)}`), AA(W)
  }
  g("[FileIndex] Using Fuse.js fallback for search");
  let G = [...new Set(Q)];
  if (!B) {
    let W = new Set;
    for (let X of G) {
      let V = X.split($K.sep)[0];
      if (V) {
        if (W.add(V), W.size >= sPA) break
      }
    }
    return [...W].sort().map(jZ1)
  }
  let Z = G.map((W) => {
      return {
        path: W,
        filename: $K.basename(W),
        testPenalty: W.includes("test") ? 1 : 0
      }
    }),
    I = B.lastIndexOf($K.sep);
  if (I > 2) Z = Z.filter((W) => {
    return W.path.substring(0, I).startsWith(B.substring(0, I))
  });
  let J = new yO(Z, {
    includeScore: !0,
    threshold: 0.5,
    keys: [{
      name: "path",
      weight: 1
    }, {
      name: "filename",
      weight: 2
    }]
  }).search(B, {
    limit: sPA
  });
  return J = J.sort((W, X) => {
    if (W.score === void 0 || X.score === void 0) return 0;
    if (Math.abs(W.score - X.score) > 0.05) return W.score - X.score;
    return W.item.testPenalty - X.item.testPenalty
  }), J.map((W) => W.item.path).slice(0, sPA).map(jZ1)
}
// @from(Start 13134572, End 13134895)
function jJ0() {
  if (!fXA) fXA = NO3().then((A) => {
    return SJ0 = A.fileIndex, _J0 = A.fileList, k09 = Date.now(), fXA = null, A
  }).catch((A) => {
    return g(`[FileIndex] Cache refresh failed: ${A instanceof Error?A.message:String(A)}`), AA(A), fXA = null, {
      fileIndex: null,
      fileList: []
    }
  })
}
// @from(Start 13134896, End 13135158)
async function OO3() {
  let A = RA(),
    Q = W0();
  try {
    return A.readdirSync(Q).map((G) => {
      let Z = $K.join(Q, G.name),
        I = $K.relative(Q, Z);
      return G.isDirectory() ? I + $K.sep : I
    })
  } catch (B) {
    return AA(B), []
  }
}
// @from(Start 13135159, End 13135670)
async function x09(A, Q = !1) {
  if (!A && !Q) return [];
  if (A === "" || A === "." || A === "./") {
    let B = await OO3();
    return jJ0(), B.slice(0, sPA).map(jZ1)
  }
  try {
    let G = Date.now() - k09 > $O3;
    if (!SJ0 && _J0.length === 0) {
      if (jJ0(), fXA) await fXA
    } else if (G) jJ0();
    let Z = A,
      I = "." + $K.sep;
    if (A.startsWith(I)) Z = A.substring(2);
    if (Z.startsWith("~")) Z = b9(Z);
    return await MO3(SJ0, _J0, Z)
  } catch (B) {
    return AA(B), []
  }
}
// @from(Start 13135672, End 13135857)
function SZ1(A, Q, B, G, Z, I) {
  let Y = typeof A === "string" ? A : A.displayText,
    J = Q.substring(0, G) + Y + Q.substring(G + B.length);
  Z(J);
  let W = G + Y.length;
  I(W)
}
// @from(Start 13135862, End 13135872)
PZ1 = null
// @from(Start 13135876, End 13135884)
PJ0 = !1
// @from(Start 13135888, End 13135898)
SJ0 = null
// @from(Start 13135902, End 13135905)
_J0
// @from(Start 13135907, End 13135917)
fXA = null
// @from(Start 13135921, End 13135928)
k09 = 0
// @from(Start 13135932, End 13135943)
$O3 = 60000
// @from(Start 13135947, End 13135955)
sPA = 15
// @from(Start 13135961, End 13136079)
kJ0 = L(() => {
  RZ1();
  _0();
  g1();
  AQ();
  U2();
  _y();
  yI();
  jQ();
  sj();
  OZ();
  V0();
  _J0 = []
})
// @from(Start 13136082, End 13136181)
function f09(A) {
  return typeof A === "object" && A !== null && "op" in A && TO3.includes(A.op)
}
// @from(Start 13136183, End 13136345)
function b09(A) {
  if (A.startsWith("$")) return "variable";
  if (A.includes("/") || A.startsWith("~") || A.startsWith(".")) return "file";
  return "command"
}
// @from(Start 13136347, End 13136506)
function PO3(A) {
  for (let Q = A.length - 1; Q >= 0; Q--)
    if (typeof A[Q] === "string") return {
      token: A[Q],
      index: Q
    };
  return null
}
// @from(Start 13136508, End 13136608)
function jO3(A, Q) {
  if (Q === 0) return !0;
  let B = A[Q - 1];
  return B !== void 0 && f09(B)
}
// @from(Start 13136610, End 13137497)
function SO3(A, Q) {
  let B = A.slice(0, Q),
    G = B.match(/\$[a-zA-Z_][a-zA-Z0-9_]*$/);
  if (G) return {
    prefix: G[0],
    completionType: "variable"
  };
  let Z = JW(B);
  if (!Z.success) {
    let W = B.split(/\s+/),
      X = W[W.length - 1] || "",
      F = W.length === 1 && !B.includes(" ") ? "command" : b09(X);
    return {
      prefix: X,
      completionType: F
    }
  }
  let I = PO3(Z.tokens);
  if (!I) {
    let W = Z.tokens[Z.tokens.length - 1];
    return {
      prefix: "",
      completionType: W && f09(W) ? "command" : "command"
    }
  }
  if (B.endsWith(" ")) return {
    prefix: "",
    completionType: "file"
  };
  let Y = b09(I.token);
  if (Y === "variable" || Y === "file") return {
    prefix: I.token,
    completionType: Y
  };
  let J = jO3(Z.tokens, I.index) ? "command" : "file";
  return {
    prefix: I.token,
    completionType: J
  }
}
// @from(Start 13137499, End 13137827)
function _O3(A, Q) {
  if (Q === "variable") {
    let B = A.slice(1);
    return `compgen -v ${z8([B])} 2>/dev/null`
  } else if (Q === "file") return `compgen -f ${z8([A])} 2>/dev/null | head -${yJ0} | while IFS= read -r f; do [ -d "$f" ] && echo "$f/" || echo "$f "; done`;
  else return `compgen -c ${z8([A])} 2>/dev/null`
}
// @from(Start 13137829, End 13138169)
function kO3(A, Q) {
  if (Q === "variable") {
    let B = A.slice(1);
    return `print -rl -- \${(k)parameters[(I)${z8([B])}*]} 2>/dev/null`
  } else if (Q === "file") return `for f in ${z8([A])}*(N[1,${yJ0}]); do [[ -d "$f" ]] && echo "$f/" || echo "$f "; done`;
  else return `print -rl -- \${(k)commands[(I)${z8([A])}*]} 2>/dev/null`
}
// @from(Start 13138170, End 13138530)
async function yO3(A, Q, B, G) {
  let Z;
  if (A === "bash") Z = _O3(Q, B);
  else if (A === "zsh") Z = kO3(Q, B);
  else return [];
  return (await (await $rA(Z, G, RO3)).result).stdout.split(`
`).filter((J) => J.trim()).slice(0, yJ0).map((J) => ({
    id: J,
    displayText: J,
    description: void 0,
    metadata: {
      completionType: B
    }
  }))
}
// @from(Start 13138531, End 13138939)
async function h09(A, Q, B) {
  let G = GIA();
  if (G !== "bash" && G !== "zsh") return [];
  try {
    let {
      prefix: Z,
      completionType: I
    } = SO3(A, Q);
    if (!Z) return [];
    return (await yO3(G, Z, I, B)).map((J) => ({
      ...J,
      metadata: {
        ...J.metadata,
        inputSnapshot: A
      }
    }))
  } catch (Z) {
    return g(`Shell completion failed: ${Z}`), []
  }
}
// @from(Start 13138944, End 13138952)
yJ0 = 15
// @from(Start 13138956, End 13138966)
RO3 = 1000
// @from(Start 13138970, End 13138973)
TO3
// @from(Start 13138979, End 13139061)
g09 = L(() => {
  xAA();
  u_();
  V0();
  dK();
  TO3 = ["|", "||", "&&", ";"]
})
// @from(Start 13139093, End 13139796)
function u09(A) {
  switch (A.type) {
    case "file":
      return {
        id: `file-${A.path}`, displayText: A.displayText, description: A.description
      };
    case "mcp_resource":
      return {
        id: `mcp-resource-${A.server}__${A.uri}`, displayText: A.displayText, description: A.description
      };
    case "agent":
      return {
        id: `agent-${A.agentType}`, displayText: A.displayText, description: A.description, color: A.color
      };
    case "mcp_server":
      return {
        id: `mcp-server-${A.serverName}`, displayText: A.displayText, description: A.description, metadata: {
          serverName: A.serverName,
          enabled: A.enabled
        }
      }
  }
}
// @from(Start 13139798, End 13139891)
function xO3(A) {
  if (A.length <= m09) return A;
  return A.substring(0, m09 - 3) + "..."
}
// @from(Start 13139893, End 13140369)
function vO3(A, Q, B = !1) {
  if (!Q && !B) return [];
  try {
    let G = A.map((I) => ({
      type: "agent",
      displayText: `agent-${I.agentType}`,
      description: `Agent: ${xO3(I.whenToUse)}`,
      agentType: I.agentType,
      color: PWA(I.agentType)
    }));
    if (!Q) return G;
    let Z = Q.toLowerCase();
    return G.filter((I) => I.agentType.toLowerCase().includes(Z) || I.displayText.toLowerCase().includes(Z))
  } catch (G) {
    return AA(G), []
  }
}
// @from(Start 13140371, End 13140873)
function bO3(A, Q, B = !1) {
  if (!Q && !B) return [];
  let Z = A.filter((Y) => Y.name !== "ide").map((Y) => {
    let J = Y.type !== "disabled",
      W = J ? "✓" : "○",
      X = J ? "enabled" : "disabled";
    return {
      type: "mcp_server",
      displayText: `${W} [mcp] ${Y.name}`,
      description: `${X} (⏎ to toggle)`,
      serverName: Y.name,
      enabled: J
    }
  });
  if (!Q) return Z;
  let I = Q.toLowerCase();
  return Z.filter((Y) => Y.serverName.toLowerCase().includes(I))
}
// @from(Start 13140874, End 13142366)
async function vJ0(A, Q, B, G = !1, Z = []) {
  if (!A && !G) return [];
  let [I, Y, J] = await Promise.all([x09(A, G), Promise.resolve(vO3(B, A, G)), Promise.resolve(bO3(Z, A, G))]), W = I.map((K) => ({
    type: "file",
    displayText: K.displayText,
    description: K.description,
    path: K.displayText,
    filename: d09.basename(K.displayText),
    score: K.metadata?.score
  })), X = Object.values(Q).flat().map((K) => ({
    type: "mcp_resource",
    displayText: `${K.server}:${K.uri}`,
    description: K.name + (K.description ? ` - ${K.description}` : ""),
    server: K.server,
    uri: K.uri,
    name: K.name || K.uri
  }));
  if (!A) return [...J, ...W, ...X, ...Y].slice(0, xJ0).map(u09);
  let V = [...J, ...X, ...Y],
    F = [];
  for (let K of W) F.push({
    source: K,
    score: K.score ?? 0.5
  });
  if (V.length > 0) {
    let D = new yO(V, {
      includeScore: !0,
      threshold: 0.6,
      keys: [{
        name: "displayText",
        weight: 2
      }, {
        name: "name",
        weight: 3
      }, {
        name: "server",
        weight: 1
      }, {
        name: "description",
        weight: 1
      }, {
        name: "agentType",
        weight: 3
      }, {
        name: "serverName",
        weight: 3
      }]
    }).search(A, {
      limit: xJ0
    });
    for (let H of D) F.push({
      source: H.item,
      score: H.score ?? 0.5
    })
  }
  return F.sort((K, D) => K.score - D.score), F.slice(0, xJ0).map((K) => K.source).map(u09)
}
// @from(Start 13142371, End 13142379)
xJ0 = 15
// @from(Start 13142383, End 13142391)
m09 = 60
// @from(Start 13142397, End 13142448)
c09 = L(() => {
  RZ1();
  jy();
  g1();
  kJ0()
})
// @from(Start 13142454, End 13142487)
p09 = L(() => {
  SD();
  g1()
})
// @from(Start 13142490, End 13142597)
function l09(A) {
  let Q = "plugin" in A ? A.plugin : "no-plugin";
  return `${A.type}:${A.source}:${Q}`
}
// @from(Start 13142599, End 13142926)
function i09(A, Q) {
  if (Q.length === 0) return;
  A((B) => {
    let G = new Set(B.plugins.errors.map((I) => l09(I))),
      Z = Q.filter((I) => !G.has(l09(I)));
    if (Z.length === 0) return B;
    return {
      ...B,
      plugins: {
        ...B.plugins,
        errors: [...B.plugins.errors, ...Z]
      }
    }
  })
}
// @from(Start 13142928, End 13149378)
function n09(A, Q = !1, B) {
  let [G, Z] = OQ(), I = oE.useRef(new Map), Y = oE.useCallback((F, K = [], D = [], H) => {
    Z((C) => {
      let E = s09(F.name),
        q = C.mcp.clients.findIndex((w) => w.name === F.name) === -1 ? [...C.mcp.clients, F] : C.mcp.clients.map((w) => w.name === F.name ? F : w);
      return {
        ...C,
        mcp: {
          ...C.mcp,
          clients: q,
          tools: [...CH1(C.mcp.tools, (w) => w.name?.startsWith(E)), ...K],
          commands: [...CH1(C.mcp.commands, (w) => w.name?.startsWith(E)), ...D],
          resources: {
            ...C.mcp.resources,
            ...H && H.length > 0 ? {
              [F.name]: H
            } : uu0(C.mcp.resources, F.name)
          }
        }
      }
    })
  }, [Z]), J = oE.useCallback(({
    client: F,
    tools: K,
    commands: D,
    resources: H
  }) => {
    switch (Y(F, K, D, H), F.type) {
      case "connected": {
        F.client.onclose = () => {
          if (IYA(F.name, F.config).catch(() => {
              g(`Failed to invalidate the server cache: ${F.name}`)
            }), IMA(F.name)) {
            y0(F.name, "Server is disabled, skipping automatic reconnection");
            return
          }
          let C = F.config.type ?? "stdio";
          if (C !== "stdio" && C !== "sdk") {
            let E = gO3(C);
            y0(F.name, `${E} transport closed/disconnected, attempting automatic reconnection`);
            let U = I.current.get(F.name);
            if (U) clearTimeout(U), I.current.delete(F.name);
            (async () => {
              for (let w = 1; w <= hXA; w++) {
                if (IMA(F.name)) {
                  y0(F.name, "Server disabled during reconnection, stopping retry"), I.current.delete(F.name);
                  return
                }
                Y({
                  ...F,
                  type: "pending",
                  reconnectAttempt: w,
                  maxReconnectAttempts: hXA
                });
                let N = Date.now();
                try {
                  let T = await D1A(F.name, F.config),
                    y = Date.now() - N;
                  if (T.client.type === "connected") {
                    y0(F.name, `${E} reconnection successful after ${y}ms (attempt ${w})`), I.current.delete(F.name), J(T);
                    return
                  }
                  if (y0(F.name, `${E} reconnection attempt ${w} completed with status: ${T.client.type}`), w === hXA) {
                    y0(F.name, `Max reconnection attempts (${hXA}) reached, giving up`), I.current.delete(F.name), J(T);
                    return
                  }
                } catch (T) {
                  let y = Date.now() - N;
                  if (WI(F.name, `${E} reconnection attempt ${w} failed after ${y}ms: ${T}`), w === hXA) {
                    y0(F.name, `Max reconnection attempts (${hXA}) reached, giving up`), I.current.delete(F.name), Y({
                      ...F,
                      type: "failed"
                    });
                    return
                  }
                }
                let R = Math.min(fO3 * Math.pow(2, w - 1), hO3);
                y0(F.name, `Scheduling reconnection attempt ${w+1} in ${R}ms`), await new Promise((T) => {
                  let y = setTimeout(T, R);
                  I.current.set(F.name, y)
                })
              }
            })()
          } else Y({
            ...F,
            type: "failed"
          })
        };
        break
      }
      case "needs-auth":
      case "failed":
      case "pending":
      case "disabled":
        break
    }
  }, [Y]), W = e1();
  oE.useEffect(() => {
    async function F() {
      let {
        servers: K,
        errors: D
      } = Q ? {
        servers: {},
        errors: []
      } : await fk(), H = {
        ...K,
        ...A
      };
      i09(Z, D), Z((C) => {
        let E = new Set(C.mcp.clients.map((q) => q.name)),
          U = Object.entries(H).filter(([q]) => !E.has(q)).map(([q, w]) => ({
            name: q,
            type: "pending",
            config: w
          }));
        if (U.length === 0) return C;
        return {
          ...C,
          mcp: {
            ...C.mcp,
            clients: [...C.mcp.clients, ...U]
          }
        }
      })
    }
    F().catch((K) => {
      WI("useManageMCPConnections", `Failed to initialize servers as pending: ${K instanceof Error?K.message:String(K)}`)
    })
  }, [Q, A, Z, W]), oE.useEffect(() => {
    let F = !1;
    async function K() {
      let {
        servers: D,
        errors: H
      } = Q ? {
        servers: {},
        errors: []
      } : await fk();
      if (F) return;
      i09(Z, H);
      let C = {
        ...D,
        ...A
      };
      v10(J, C).catch((E) => {
        WI("useManageMcpConnections", `Failed to get MCP resources: ${E instanceof Error?E.message:String(E)}`)
      })
    }
    return K(), () => {
      F = !0
    }
  }, [Q, A, J, W]), oE.useEffect(() => {
    let F = I.current;
    return () => {
      for (let K of F.values()) clearTimeout(K);
      F.clear()
    }
  }, []), oE.useEffect(() => {}, [G.mcp.clients, Z]), oE.useEffect(() => B?.updateClients(G.mcp.clients), [B, G.mcp.clients]), oE.useEffect(() => B?.updateTools(G.mcp.tools), [B, G.mcp.tools]), oE.useEffect(() => B?.updateResources(G.mcp.resources), [B, G.mcp.resources]);
  let X = oE.useCallback(async (F) => {
      let K = G.mcp.clients.find((C) => C.name === F);
      if (!K) throw Error(`MCP server ${F} not found`);
      let D = I.current.get(F);
      if (D) clearTimeout(D), I.current.delete(F);
      let H = await D1A(F, K.config);
      return J(H), H
    }, [G.mcp.clients, J, Z]),
    V = oE.useCallback(async (F) => {
      let K = G.mcp.clients.find((H) => H.name === F);
      if (!K) throw Error(`MCP server ${F} not found`);
      if (K.type !== "disabled") {
        let H = I.current.get(F);
        if (H) clearTimeout(H), I.current.delete(F);
        if (k10(F, !1), K.type === "connected") await IYA(F, K.config);
        Y({
          name: F,
          type: "disabled",
          config: K.config
        })
      } else {
        k10(F, !0), Y({
          name: F,
          type: "pending",
          config: K.config
        });
        let H = await D1A(F, K.config);
        J(H)
      }
    }, [G.mcp.clients, Y, J, Z]);
  return {
    reconnectMcpServer: X,
    toggleMcpServer: V
  }
}
// @from(Start 13149380, End 13149548)
function gO3(A) {
  switch (A) {
    case "http":
      return "HTTP";
    case "ws":
    case "ws-ide":
      return "WebSocket";
    default:
      return "SSE"
  }
}
// @from(Start 13149553, End 13149555)
oE
// @from(Start 13149557, End 13149564)
hXA = 5
// @from(Start 13149568, End 13149578)
fO3 = 1000
// @from(Start 13149582, End 13149593)
hO3 = 30000
// @from(Start 13149599, End 13149719)
a09 = L(() => {
  _0();
  Ok();
  g1();
  z9();
  mu0();
  au0();
  tM();
  nX();
  V0();
  p09();
  oE = BA(VA(), 1)
})
// @from(Start 13149722, End 13149883)
function gXA() {
  let A = Tg.useContext(bJ0);
  if (!A) throw Error("useMcpReconnect must be used within MCPConnectionManager");
  return A.reconnectMcpServer
}
// @from(Start 13149885, End 13150047)
function uXA() {
  let A = Tg.useContext(bJ0);
  if (!A) throw Error("useMcpToggleEnabled must be used within MCPConnectionManager");
  return A.toggleMcpServer
}
// @from(Start 13150049, End 13150390)
function _Z1({
  children: A,
  dynamicMcpConfig: Q,
  isStrictMcpConfig: B,
  mcpCliEndpoint: G
}) {
  let {
    reconnectMcpServer: Z,
    toggleMcpServer: I
  } = n09(Q, B, G), Y = Tg.useMemo(() => ({
    reconnectMcpServer: Z,
    toggleMcpServer: I
  }), [Z, I]);
  return Tg.default.createElement(bJ0.Provider, {
    value: Y
  }, A)
}
// @from(Start 13150395, End 13150397)
Tg
// @from(Start 13150399, End 13150402)
bJ0
// @from(Start 13150408, End 13150484)
$QA = L(() => {
  a09();
  Tg = BA(VA(), 1), bJ0 = Tg.createContext(null)
})
// @from(Start 13150487, End 13150546)
function r09(A) {
  return A.id.startsWith("mcp-server-")
}
// @from(Start 13150548, End 13150748)
function rPA(A, Q, B) {
  if (Q < 0 || B.length === 0) return B.length > 0 ? 0 : -1;
  if (A.length === B.length && A.every((Z, I) => Z.id === B[I]?.id)) return Math.min(Q, B.length - 1);
  return 0
}
// @from(Start 13150750, End 13150869)
function o09(A) {
  let Q = A.metadata;
  return Q?.sessionId ? `/resume ${Q.sessionId}` : `/resume ${A.displayText}`
}
// @from(Start 13150871, End 13151038)
function t09(A) {
  if (A.isQuoted) return A.token.slice(2).replace(/"$/, "");
  else if (A.token.startsWith("@")) return A.token.substring(1);
  else return A.token
}
// @from(Start 13151040, End 13151346)
function fJ0(A) {
  let {
    displayText: Q,
    mode: B,
    hasAtPrefix: G,
    needsQuotes: Z,
    isQuoted: I,
    isComplete: Y
  } = A, J = Y ? " " : "";
  if (I || Z) return B === "bash" ? `"${Q}"${J}` : `@"${Q}"${J}`;
  else if (G) return B === "bash" ? `${Q}${J}` : `@${Q}${J}`;
  else return Q
}
// @from(Start 13151348, End 13151635)
function hJ0(A, Q, B, G, Z, I) {
  let W = Q.slice(0, B).lastIndexOf(" ") + 1,
    X;
  if (I === "variable") X = "$" + A.displayText + " ";
  else if (I === "command") X = A.displayText + " ";
  else X = A.displayText;
  let V = Q.slice(0, W) + X + Q.slice(B);
  G(V), Z(W + X.length)
}
// @from(Start 13151636, End 13151835)
async function uO3(A, Q) {
  try {
    if (kZ1) kZ1.abort();
    return kZ1 = new AbortController, await h09(A, Q, kZ1.signal)
  } catch {
    return GA("tengu_shell_completion_failed", {}), []
  }
}
// @from(Start 13151837, End 13152336)
function oPA(A, Q, B = !1) {
  if (!A) return null;
  let G = A.substring(0, Q);
  if (B) {
    let Y = /@"([^"]*)"?$/,
      J = G.match(Y);
    if (J && J.index !== void 0) return {
      token: J[0],
      startPos: J.index,
      isQuoted: !0
    }
  }
  let Z = B ? /(@[a-zA-Z0-9_\-./\\()[\]~]*|[a-zA-Z0-9_\-./\\()[\]~]+)$/ : /[a-zA-Z0-9_\-./\\()[\]~]+$/,
    I = G.match(Z);
  if (!I || I.index === void 0) return null;
  return {
    token: I[0],
    startPos: I.index,
    isQuoted: !1
  }
}
// @from(Start 13152338, End 13152579)
function mO3(A) {
  if (bXA(A)) {
    let Q = A.indexOf(" ");
    if (Q === -1) return {
      commandName: A.slice(1),
      args: ""
    };
    return {
      commandName: A.slice(1, Q),
      args: A.slice(Q + 1)
    }
  }
  return null
}
// @from(Start 13152581, End 13152654)
function dO3(A, Q) {
  return !A && Q.includes(" ") && !Q.endsWith(" ")
}
// @from(Start 13152656, End 13163681)
function e09({
  commands: A,
  onInputChange: Q,
  onSubmit: B,
  setCursorOffset: G,
  input: Z,
  cursorOffset: I,
  mode: Y,
  agents: J,
  setSuggestionsState: W,
  suggestionsState: {
    suggestions: X,
    selectedSuggestion: V,
    commandArgumentHint: F
  },
  suppressSuggestions: K = !1
}) {
  let {
    addNotification: D
  } = vZ(), [H, C] = sq.useState("none"), [E, U] = sq.useState(void 0), [q, w] = OQ(), N = uXA(), R = sq.useRef(I);
  R.current = I;
  let T = sq.useCallback(() => {
      W(() => ({
        commandArgumentHint: void 0,
        suggestions: [],
        selectedSuggestion: -1
      })), C("none"), U(void 0)
    }, [W]),
    y = sq.useCallback(async (l, k = !1) => {
      let m = await vJ0(l, q.mcp.resources, J, k, q.mcp.clients);
      if (m.length === 0) {
        W(() => ({
          commandArgumentHint: void 0,
          suggestions: [],
          selectedSuggestion: -1
        })), C("none"), U(void 0);
        return
      }
      W((o) => ({
        commandArgumentHint: void 0,
        suggestions: m,
        selectedSuggestion: rPA(o.suggestions, o.selectedSuggestion, m)
      })), C(m.length > 0 ? "file" : "none"), U(void 0)
    }, [q.mcp.resources, q.mcp.clients, T, W, C, U, J]),
    v = qp(y, 200),
    x = sq.useCallback(async (l, k) => {
      let m = k ?? R.current;
      if (K) {
        v.cancel(), T();
        return
      }
      let o = l.substring(0, m).match(/(^|\s)@([a-zA-Z0-9_\-./\\()[\]~]*|"[^"]*"?)$/),
        IA = m === l.length && m > 0 && l.length > 0 && l[m - 1] === " ";
      if (Y === "prompt" && bXA(l) && m > 0) {
        let FA = mO3(l);
        if (FA && FA.commandName === "add-dir" && FA.args) {
          let {
            args: zA
          } = FA;
          if (zA.match(/\s+$/)) {
            v.cancel(), T();
            return
          }
          let NA = await S09(zA);
          if (NA.length > 0) {
            W((OA) => ({
              suggestions: NA,
              selectedSuggestion: rPA(OA.suggestions, OA.selectedSuggestion, NA),
              commandArgumentHint: void 0
            })), C("directory");
            return
          }
          v.cancel(), T();
          return
        }
        if (FA && FA.commandName === "resume" && FA.args !== void 0 && l.includes(" ")) {
          let {
            args: zA
          } = FA, OA = (await mXA(zA, {
            limit: 10
          })).map((mA) => {
            let wA = VP(mA);
            return {
              id: `resume-title-${wA}`,
              displayText: mA.customTitle,
              description: mzA(mA),
              metadata: {
                sessionId: wA
              }
            }
          });
          if (OA.length > 0) {
            W((mA) => ({
              suggestions: OA,
              selectedSuggestion: rPA(mA.suggestions, mA.selectedSuggestion, OA),
              commandArgumentHint: void 0
            })), C("custom-title");
            return
          }
          T();
          return
        }
      }
      if (Y === "prompt" && bXA(l) && m > 0 && !dO3(IA, l)) {
        let FA = T09(l, A),
          zA = void 0;
        if (l.length > 1) {
          let NA = l.endsWith(" ") ? l.slice(1, -1) : l.slice(1),
            OA = A.find((mA) => mA.userFacingName() === NA && mA.argumentHint);
          if (OA?.argumentHint) zA = OA.argumentHint
        }
        if (W((NA) => ({
            commandArgumentHint: zA,
            suggestions: FA,
            selectedSuggestion: rPA(NA.suggestions, NA.selectedSuggestion, FA)
          })), C(FA.length > 0 ? "command" : "none"), FA.length > 0) {
          let NA = Math.max(...FA.map((OA) => OA.displayText.length));
          U(NA + 5)
        }
        return
      }
      if (H === "command") v.cancel(), T();
      if (H === "custom-title") T();
      if (o) {
        let FA = oPA(l, m, !0);
        if (FA && FA.token.startsWith("@")) {
          let zA = t09(FA);
          v(zA, !0);
          return
        }
      }
      if (H === "file") {
        let FA = oPA(l, m, !0);
        if (FA) {
          let zA = t09(FA);
          v(zA, !1)
        } else v.cancel(), T()
      }
      if (H === "shell") {
        let FA = X[0]?.metadata?.inputSnapshot;
        if (Y !== "bash" || l !== FA) v.cancel(), T()
      }
    }, [H, A, W, T, v, Y, K]);
  sq.useEffect(() => {
    x(Z)
  }, [Z, x]);
  let p = sq.useCallback(async () => {
      if (X.length > 0) {
        v.cancel();
        let l = V === -1 ? 0 : V,
          k = X[l];
        if (k && r09(k)) return;
        if (H === "command" && l < X.length) {
          if (k) OJ0(k, !1, A, Q, G, B), T()
        } else if (H === "custom-title" && X.length > 0) {
          if (k) {
            let m = o09(k);
            Q(m), G(m.length), T()
          }
        } else if (H === "directory" && X.length > 0) {
          let m = X[l];
          if (m) {
            let o = Z.indexOf(" "),
              FA = Z.slice(0, o + 1) + m.id + "/";
            Q(FA), G(FA.length), W((zA) => ({
              ...zA,
              commandArgumentHint: void 0
            })), x(FA, FA.length)
          }
        } else if (H === "shell" && X.length > 0) {
          let m = X[l];
          if (m) {
            let o = m.metadata;
            hJ0(m, Z, I, Q, G, o?.completionType), T()
          }
        } else if (H === "file" && X.length > 0) {
          let m = oPA(Z, I, !0);
          if (!m) {
            T();
            return
          }
          let o = y09(X),
            IA = m.token.startsWith("@"),
            FA;
          if (m.isQuoted) FA = m.token.slice(2).replace(/"$/, "").length;
          else if (IA) FA = m.token.length - 1;
          else FA = m.token.length;
          if (o.length > FA) {
            let zA = fJ0({
              displayText: o,
              mode: Y,
              hasAtPrefix: IA,
              needsQuotes: !1,
              isQuoted: m.isQuoted,
              isComplete: !1
            });
            SZ1(zA, Z, m.token, m.startPos, Q, G), x(Z.replace(m.token, zA), I)
          } else if (l < X.length) {
            let zA = X[l];
            if (zA) {
              let NA = zA.displayText.includes(" "),
                OA = fJ0({
                  displayText: zA.displayText,
                  mode: Y,
                  hasAtPrefix: IA,
                  needsQuotes: NA,
                  isQuoted: m.isQuoted,
                  isComplete: !0
                });
              SZ1(OA, Z, m.token, m.startPos, Q, G), T()
            }
          }
        }
      } else if (Z.trim() !== "") {
        let l, k;
        if (Y === "bash") {
          l = "shell";
          let m = await uO3(Z, I);
          if (m.length === 1) {
            let o = m[0];
            if (o) {
              let IA = o.metadata;
              hJ0(o, Z, I, Q, G, IA?.completionType)
            }
            k = []
          } else k = m
        } else {
          l = "file";
          let m = oPA(Z, I, !0);
          if (m) {
            let o = m.token.startsWith("@"),
              IA = o ? m.token.substring(1) : m.token;
            k = await vJ0(IA, q.mcp.resources, J, o, q.mcp.clients)
          } else k = []
        }
        if (k.length > 0) W((m) => ({
          commandArgumentHint: void 0,
          suggestions: k,
          selectedSuggestion: rPA(m.suggestions, m.selectedSuggestion, k)
        })), C(l), U(void 0)
      }
    }, [X, V, Z, H, A, Y, Q, G, B, T, I, x, q.mcp.resources, q.mcp.clients, W, J, v]),
    u = sq.useCallback(() => {
      if (V < 0 || X.length === 0) return;
      let l = X[V];
      if (l && r09(l)) {
        let k = l.metadata;
        if (k?.serverName) {
          let m = k.enabled;
          N(k.serverName);
          let o = m ? "disabled" : "enabled";
          D({
            key: `mcp-server-toggle-${k.serverName}`,
            jsx: YV.createElement($, null, "MCP server '", k.serverName, "' ", o, ". Use", " ", YV.createElement($, {
              color: "suggestion"
            }, "/mcp"), " to manage servers."),
            priority: "immediate",
            timeoutMs: 3000
          }), Q(""), G(0), v.cancel(), T()
        }
        return
      }
      if (H === "command" && V < X.length) {
        if (l) OJ0(l, !0, A, Q, G, B), v.cancel(), T()
      } else if (H === "custom-title" && V < X.length) {
        if (l) {
          let k = o09(l);
          Q(k), G(k.length), B(k, !0), v.cancel(), T()
        }
      } else if (H === "shell" && V < X.length) {
        let k = X[V];
        if (k) {
          let m = k.metadata;
          hJ0(k, Z, I, Q, G, m?.completionType), v.cancel(), T()
        }
      } else if (H === "file" && V < X.length) {
        let k = oPA(Z, I, !0);
        if (k) {
          if (l) {
            let m = k.token.startsWith("@"),
              o = l.displayText.includes(" "),
              IA = fJ0({
                displayText: l.displayText,
                mode: Y,
                hasAtPrefix: m,
                needsQuotes: o,
                isQuoted: k.isQuoted,
                isComplete: !0
              });
            SZ1(IA, Z, k.token, k.startPos, Q, G), v.cancel(), T()
          }
        }
      }
    }, [X, V, H, A, Z, I, Y, Q, G, B, T, N, D, v]),
    e = Ae(Z).level !== "none";
  return f1((l, k) => {
    if (k.tab && !k.shift) {
      if (X.length === 0 && Y !== "bash" && !Y0(process.env.MAX_THINKING_TOKENS)) {
        if (e) return;
        let m = !q.thinkingEnabled;
        w((o) => ({
          ...o,
          thinkingEnabled: m
        })), D({
          key: `toggled-thinking-${m?"on":"off"}`,
          invalidates: ["toggled-thinking-on", "toggled-thinking-off", "toggled-thinking-initial"],
          jsx: m ? YV.createElement(YV.Fragment, null, YV.createElement($, {
            color: "suggestion"
          }, "Thinking on"), YV.createElement($, {
            dimColor: !0
          }, " ", YV.createElement(E4, {
            shortcut: "tab",
            action: "toggle",
            parens: !0
          }))) : YV.createElement($, {
            dimColor: !0
          }, "Thinking off", " ", YV.createElement(E4, {
            shortcut: "tab",
            action: "toggle",
            parens: !0
          })),
          priority: "immediate",
          timeoutMs: 3000
        }), GA("tengu_thinking_toggled", {
          enabled: m
        })
      } else p();
      return
    }
    if (X.length === 0) return;
    if (k.downArrow || k.ctrl && l === "n") {
      W((m) => ({
        ...m,
        selectedSuggestion: m.selectedSuggestion >= X.length - 1 ? 0 : m.selectedSuggestion + 1
      }));
      return
    }
    if (k.upArrow || k.ctrl && l === "p") {
      W((m) => ({
        ...m,
        selectedSuggestion: m.selectedSuggestion <= 0 ? X.length - 1 : m.selectedSuggestion - 1
      }));
      return
    }
    if (k.return) u();
    if (k.escape) v.cancel(), T()
  }), {
    suggestions: X,
    selectedSuggestion: V,
    suggestionType: H,
    maxColumnWidth: E,
    commandArgumentHint: F
  }
}
// @from(Start 13163686, End 13163688)
sq
// @from(Start 13163690, End 13163692)
YV
// @from(Start 13163694, End 13163704)
kZ1 = null
// @from(Start 13163710, End 13163899)
AQ9 = L(() => {
  hA();
  P09();
  _09();
  S7();
  kJ0();
  g09();
  c09();
  JE();
  z9();
  q0();
  hQ();
  EU();
  hA();
  dF();
  $QA();
  CU();
  sq = BA(VA(), 1), YV = BA(VA(), 1)
})
// @from(Start 13163902, End 13178093)
function QQ9(A) {
  let [Q, B] = Ya.useState("INSERT"), G = Ya.default.useRef(""), Z = Ya.default.useRef(null), I = Ya.default.useRef(""), Y = Ya.default.useRef(""), J = Ya.default.useRef(null), W = FrA(A), X = (y, v) => {
    return y === v && (y === "d" || y === "c")
  }, V = (y, v) => {
    switch (y) {
      case "h":
        return v.left();
      case "l":
        return v.right();
      case "j":
        return v.downLogicalLine();
      case "k":
        return v.upLogicalLine();
      case "0":
        return v.startOfLogicalLine();
      case "^":
        return v.firstNonBlankInLogicalLine();
      case "$":
        return v.endOfLogicalLine();
      case "w":
        return v.nextWord();
      case "e":
        return v.endOfWord();
      case "b":
        return v.prevWord();
      case "W":
        return v.nextWORD();
      case "E":
        return v.endOfWORD();
      case "B":
        return v.prevWORD();
      case "gg":
        return v.startOfFirstLine();
      case "G":
        return v.startOfLastLine();
      default:
        return null
    }
  }, F = (y, v, x = 1) => {
    if (X(y, G.current)) return v.startOfLine();
    let p = v;
    for (let u = 0; u < x; u++) {
      if (!p) break;
      p = V(y, p)
    }
    return p
  }, K = (y, v, x, p = 1) => {
    let u = W.offset,
      e = y === "change";
    if (X(v, G.current)) {
      let k = x.startOfLogicalLine();
      if (x.text.indexOf(`
`) === -1) A.onChange(""), u = 0;
      else {
        let {
          line: m
        } = x.getPosition();
        if (y === "delete") {
          let o = x.text.split(`
`),
            IA = Math.min(p, o.length - m);
          o.splice(m, IA);
          let FA = o.join(`
`);
          A.onChange(FA), u = j7.fromText(FA, A.columns, m < o.length ? k.offset : Math.max(0, k.offset - 1)).offset
        } else if (y === "change") {
          let o = x.text.split(`
`);
          for (let IA = 0; IA < Math.min(p, o.length - m); IA++) o[m + IA] = "";
          A.onChange(o.join(`
`)), u = k.offset
        } else u = k.offset
      }
      return {
        newOffset: u,
        switchToInsert: e
      }
    }
    let l = F(v, x, p);
    if (!l || x.equals(l)) return {
      newOffset: u,
      switchToInsert: e
    };
    if (y === "move") u = l.offset;
    else {
      let [k, m] = x.offset <= l.offset ? [x, l] : [l, x], o = m;
      if (v === "e" && x.offset <= l.offset) o = m.right();
      else if ((v === "w" || v === "W") && y === "change") o = q(x, v, p);
      let IA = k.modifyText(o, "");
      if (A.onChange(IA.text), y === "change") u = k.offset;
      else u = IA.offset
    }
    return {
      newOffset: u,
      switchToInsert: e
    }
  }, D = (y) => {
    if (y !== void 0) W.setOffset(y);
    B("INSERT"), A.onModeChange?.("INSERT")
  }, H = () => {
    B("NORMAL"), A.onModeChange?.("NORMAL")
  }, C = (y) => {
    Z.current = y
  }, E = (y, v) => {
    if (v === "below") {
      let p = y.endOfLogicalLine().insert(`
`);
      return A.onChange(p.text), p.offset
    } else {
      let x = y.startOfLogicalLine(),
        p = x.insert(`
`);
      return A.onChange(p.text), x.offset
    }
  }, U = (y, v) => {
    let x = y.text[y.offset] ?? "";
    return v.test(x)
  }, q = (y, v, x) => {
    let u = v === "w" ? /\w/ : /\S/;
    if (!U(y, u)) return F(v, y, x) || y;
    let e = y;
    while (U(e, u) && !e.isAtEnd()) e = e.right();
    if (x > 1)
      for (let l = 1; l < x; l++) {
        while (!U(e, u) && !e.isAtEnd()) e = e.right();
        while (U(e, u) && !e.isAtEnd()) e = e.right()
      }
    return e
  }, w = (y, v, x, p, u = 1) => {
    let e = y.text,
      l = 0;
    if (x === "forward") {
      for (let k = y.offset + 1; k < e.length; k++)
        if (e[k] === v) {
          if (l++, l === u) {
            let m = p ? Math.max(y.offset, k - 1) : k;
            return new j7(y.measuredText, m)
          }
        }
    } else
      for (let k = y.offset - 1; k >= 0; k--)
        if (e[k] === v) {
          if (l++, l === u) {
            let m = p ? Math.min(y.offset, k + 1) : k;
            return new j7(y.measuredText, m)
          }
        } return null
  }, N = (y) => {
    let v = Z.current;
    if (!v) return;
    switch (v.type) {
      case "delete":
        if (v.motion)
          if (v.motion.length === 2 && "fFtT".includes(v.motion[0])) {
            let x = v.motion[0],
              p = v.motion[1],
              u = x === "f" || x === "t" ? "forward" : "backward",
              e = x === "t" || x === "T",
              l = w(y, p, u, e, v.count || 1);
            if (l) {
              let k = y.offset <= l.offset,
                [m, o] = k ? [y, l] : [l, y],
                IA = o,
                FA = m;
              if (e) IA = o.right();
              else IA = o.right();
              let zA = FA.modifyText(IA, "");
              A.onChange(zA.text), W.setOffset(zA.offset)
            }
          } else {
            let {
              newOffset: x
            } = K("delete", v.motion, y, v.count || 1);
            W.setOffset(x)
          } break;
      case "change":
        if (v.motion)
          if (v.motion.length === 2 && "fFtT".includes(v.motion[0])) {
            let x = v.motion[0],
              p = v.motion[1],
              u = x === "f" || x === "t" ? "forward" : "backward",
              e = x === "t" || x === "T",
              l = w(y, p, u, e, v.count || 1);
            if (l) {
              let k = y.offset <= l.offset,
                [m, o] = k ? [y, l] : [l, y],
                IA = o,
                FA = m;
              if (e) IA = o.right();
              else IA = o.right();
              let zA = FA.modifyText(IA, "");
              A.onChange(zA.text), W.setOffset(FA.offset), D(FA.offset)
            }
          } else {
            let {
              newOffset: x
            } = K("change", v.motion, y, v.count || 1);
            W.setOffset(x), D(x)
          } break;
      case "insert":
        if (v.insertedText) {
          let x = y.insert(v.insertedText);
          A.onChange(x.text), W.setOffset(x.offset)
        }
        break;
      case "x": {
        let x = v.count || 1,
          p = y;
        for (let u = 0; u < x; u++)
          if (!p.equals(p.del())) p = p.del();
        A.onChange(p.text), W.setOffset(p.offset);
        break
      }
      case "o": {
        let x = E(y, "below");
        D(x);
        break
      }
      case "O": {
        let x = E(y, "above");
        D(x);
        break
      }
      case "replace":
        break;
      case "r": {
        if (v.replacementChar) {
          let x = v.count || 1,
            p = y;
          for (let u = 0; u < x; u++)
            if (p = p.modifyText(p.right(), v.replacementChar), u < x - 1) p = j7.fromText(p.text, A.columns, p.offset + 1);
          A.onChange(p.text), W.setOffset(y.offset)
        }
        break
      }
    }
  }, R = (y = !0) => {
    if (!Y.current) return 1;
    let v = parseInt(Y.current, 10);
    if (isNaN(v)) {
      if (y) Y.current = "";
      return 1
    }
    let x = Math.min(v, cO3);
    if (y) Y.current = "";
    return x
  };
  return {
    ...W,
    onInput: (y, v) => {
      let x = j7.fromText(A.value, A.columns, W.offset);
      if (v.ctrl) {
        W.onInput(y, v);
        return
      }
      if (v.escape && Q === "INSERT") {
        if (I.current) C({
          type: "insert",
          insertedText: I.current
        }), I.current = "";
        H();
        return
      }
      if (Q === "NORMAL" && J.current) {
        if (J.current === "change" && y === "c" || J.current === "delete" && y === "d") {
          let m = J.current,
            o = R(),
            {
              newOffset: IA
            } = K(m, y, x, o);
          if (W.setOffset(IA), C({
              type: m,
              motion: y,
              count: o
            }), J.current = null, G.current = "", m === "change") D(IA);
          return
        }
        if (G.current && "fFtT".includes(G.current)) {
          let m = G.current,
            o = R(!1),
            IA = m === "f" || m === "t" ? "forward" : "backward",
            FA = m === "t" || m === "T",
            zA = w(x, y, IA, FA, o || 1);
          if (zA) {
            let NA = J.current,
              OA = x.offset <= zA.offset,
              [mA, wA] = OA ? [x, zA] : [zA, x],
              qA = wA,
              KA = mA;
            if (FA) qA = wA.right();
            else qA = wA.right();
            let yA = KA.modifyText(qA, "");
            A.onChange(yA.text);
            let oA = NA === "change" ? KA.offset : yA.offset;
            if (W.setOffset(oA), C({
                type: NA,
                motion: m + y,
                count: o || 1
              }), NA === "change") D(oA)
          }
          J.current = null, G.current = "", Y.current = "";
          return
        }
        if ("fFtT".includes(y)) {
          G.current = y;
          return
        }
        if ("0123456789".includes(y)) {
          Y.current += y;
          return
        }
        let e = J.current,
          l = R(),
          {
            newOffset: k
          } = K(e, y, x, l);
        if (W.setOffset(k), C({
            type: e,
            motion: y,
            count: l
          }), J.current = null, G.current = "", e === "change") D(k);
        return
      }
      let p = (e, l, k) => {
          let {
            newOffset: m
          } = K(e, l, x, k || 1);
          if (W.setOffset(m), e !== "move") C({
            type: e,
            motion: l,
            count: k
          });
          if (e === "change") D(m);
          G.current = ""
        },
        u = (e) => {
          I.current = "", D(e.offset)
        };
      if (Q === "NORMAL" && G.current) {
        let e = G.current;
        switch (e) {
          case "d":
            if (y === "d") {
              let l = R();
              p("delete", y, l), J.current = null;
              return
            }
            return;
          case "c":
            if (y === "c") {
              let l = R();
              p("change", y, l), J.current = null;
              return
            }
            return;
          case "g":
            if (y === "g") {
              let l = R();
              p("move", "gg", l);
              return
            }
            break;
          case "r": {
            let l = R(),
              k = x;
            for (let m = 0; m < l; m++)
              if (k = k.modifyText(k.right(), y), m < l - 1) k = j7.fromText(k.text, A.columns, k.offset + 1);
            A.onChange(k.text), W.setOffset(x.offset), C({
              type: "r",
              replacementChar: y,
              count: l
            }), G.current = "";
            return
          }
          case "f":
          case "F":
          case "t":
          case "T": {
            let l = R(),
              o = w(x, y, e === "f" || e === "t" ? "forward" : "backward", e === "t" || e === "T", l);
            if (o) W.setOffset(o.offset);
            G.current = "";
            return
          }
        }
        G.current = ""
      }
      if (Q === "NORMAL") {
        if ("0123456789".includes(y)) {
          if (y === "0" && Y.current === "") {
            let {
              newOffset: e
            } = K("move", "0", x);
            W.setOffset(e);
            return
          }
          Y.current += y;
          return
        }
        switch (y) {
          case ".": {
            N(x);
            return
          }
          case "u": {
            if (A.onUndo) A.onUndo();
            return
          }
          case "i":
            Y.current = "", I.current = "", D();
            return;
          case "I": {
            Y.current = "", u(x.startOfLogicalLine());
            return
          }
          case "a": {
            Y.current = "", u(x.right());
            return
          }
          case "A": {
            Y.current = "", u(x.endOfLogicalLine());
            return
          }
          case "o": {
            Y.current = "";
            let e = E(x, "below");
            C({
              type: "o"
            }), I.current = "", D(e);
            return
          }
          case "O": {
            Y.current = "";
            let e = E(x, "above");
            C({
              type: "O"
            }), I.current = "", D(e);
            return
          }
          case "h":
          case "l":
          case "j":
          case "k":
          case "^":
          case "$":
          case "w":
          case "e":
          case "b":
          case "W":
          case "E":
          case "B":
          case "G": {
            let e = R();
            p("move", y, e);
            return
          }
          case "g": {
            G.current = "g";
            return
          }
          case "r": {
            G.current = "r";
            return
          }
          case "f":
          case "F":
          case "t":
          case "T": {
            G.current = y;
            return
          }
          case "x": {
            let e = R(),
              l = x;
            for (let k = 0; k < e; k++)
              if (!l.equals(l.del())) l = l.del();
            A.onChange(l.text), W.setOffset(l.offset), C({
              type: "x",
              count: e
            });
            return
          }
          case "d":
            G.current = "d", J.current = "delete";
            return;
          case "D": {
            let e = R();
            p("delete", "$", e);
            return
          }
          case "c":
            G.current = "c", J.current = "change";
            return;
          case "C": {
            let e = R();
            p("change", "$", e);
            return
          }
          case "?": {
            A.onChange("?");
            return
          }
        }
      }
      if (v.return) {
        W.onInput(y, v);
        return
      }
      if (Q === "INSERT") {
        if (v.backspace || v.delete) {
          if (I.current.length > 0) I.current = I.current.slice(0, -1)
        } else I.current += y;
        W.onInput(y, v)
      }
    },
    mode: Q,
    setMode: B
  }
}
// @from(Start 13178098, End 13178100)
Ya
// @from(Start 13178102, End 13178111)
cO3 = 1e4
// @from(Start 13178117, End 13178172)
BQ9 = L(() => {
  Um1();
  cu1();
  Ya = BA(VA(), 1)
})
// @from(Start 13178175, End 13179333)
function gJ0(A) {
  let [Q] = qB(), B = QQ9({
    value: A.value,
    onChange: A.onChange,
    onSubmit: A.onSubmit,
    onExit: A.onExit,
    onExitMessage: A.onExitMessage,
    onHistoryReset: A.onHistoryReset,
    onHistoryUp: A.onHistoryUp,
    onHistoryDown: A.onHistoryDown,
    focus: A.focus,
    mask: A.mask,
    multiline: A.multiline,
    cursorChar: A.showCursor ? " " : "",
    highlightPastedText: A.highlightPastedText,
    invert: tA.inverse,
    themeText: ZB("text", Q),
    columns: A.columns,
    onImagePaste: A.onImagePaste,
    disableCursorMovementForUpDownKeys: A.disableCursorMovementForUpDownKeys,
    externalOffset: A.cursorOffset,
    onOffsetChange: A.onChangeCursorOffset,
    onModeChange: A.onModeChange,
    isMessageLoading: A.isLoading,
    onUndo: A.onUndo
  }), {
    mode: G,
    setMode: Z
  } = B;
  return yZ1.default.useEffect(() => {
    if (A.initialMode && A.initialMode !== G) Z(A.initialMode)
  }, [A.initialMode, G, Z]), yZ1.default.createElement(S, {
    flexDirection: "column"
  }, yZ1.default.createElement(DrA, {
    inputState: B,
    terminalFocus: !0,
    highlights: A.highlights,
    ...A
  }))
}
// @from(Start 13179338, End 13179341)
yZ1
// @from(Start 13179347, End 13179419)
GQ9 = L(() => {
  hA();
  F9();
  BQ9();
  Mm1();
  yZ1 = BA(VA(), 1)
})
// @from(Start 13179422, End 13179475)
function dXA() {
  return N1().editorMode === "vim"
}
// @from(Start 13179477, End 13179737)
function ZQ9() {
  if (Ep.isEnabled() && d0.terminal === "Apple_Terminal" && yMB()) return "option + ⏎ for newline";
  if (Ep.isEnabled() && kMB()) return "shift + ⏎ for newline";
  return xMB() ? "\\⏎ for newline" : "backslash (\\) + return (⏎) for newline"
}
// @from(Start 13179742, End 13179784)
tPA = L(() => {
  r7A();
  jQ();
  c5()
})
// @from(Start 13179787, End 13179952)
function Ja() {
  let [{
    mainLoopModel: A,
    mainLoopModelForSession: Q
  }] = OQ();
  return IQ9.useMemo(() => {
    return UD(Q ?? A ?? cnA())
  }, [Q, A])
}
// @from(Start 13179957, End 13179960)
IQ9
// @from(Start 13179966, End 13180020)
ePA = L(() => {
  t2();
  z9();
  IQ9 = BA(VA(), 1)
})
// @from(Start 13180023, End 13180356)
function YQ9(A) {
  switch (A.mode) {
    case "default":
      return "acceptEdits";
    case "acceptEdits":
      return "plan";
    case "plan":
      return A.isBypassPermissionsModeAvailable ? "bypassPermissions" : "default";
    case "bypassPermissions":
      return "default";
    case "dontAsk":
      return "default"
  }
}
// @from(Start 13180358, End 13181061)
function WQ9({
  shell: A
}) {
  switch (A.status) {
    case "completed":
      return cXA.default.createElement($, {
        color: "success",
        dimColor: !0
      }, "done");
    case "failed":
      return cXA.default.createElement($, {
        color: "error",
        dimColor: !0
      }, "error");
    case "killed":
      return cXA.default.createElement($, {
        color: "error",
        dimColor: !0
      }, "killed");
    case "running": {
      let Q = JQ9(A.stderr) || JQ9(A.stdout);
      if (!Q) return cXA.default.createElement($, {
        dimColor: !0
      }, "no output");
      return cXA.default.createElement($, {
        dimColor: !0
      }, J7(Q, 20, !0))
    }
  }
}
// @from(Start 13181063, End 13181233)
function JQ9(A) {
  if (!A) return "";
  let Q = A.split(`
`);
  for (let B = Q.length - 1; B >= 0; B--) {
    let G = Q[B]?.trim();
    if (G) return G
  }
  return ""
}
// @from(Start 13181238, End 13181241)
cXA
// @from(Start 13181247, End 13181293)
XQ9 = L(() => {
  hA();
  cXA = BA(VA(), 1)
})
// @from(Start 13181296, End 13181871)
function xZ1({
  session: A
}) {
  if (A.status === "completed") return AjA.default.createElement($, {
    bold: !0,
    color: "success",
    dimColor: !0
  }, "done");
  if (A.status === "failed") return AjA.default.createElement($, {
    bold: !0,
    color: "error",
    dimColor: !0
  }, "error");
  if (!A.todoList.length) return AjA.default.createElement($, {
    dimColor: !0
  }, A.status, "…");
  let Q = A.todoList.filter((G) => G.status === "completed").length,
    B = A.todoList.length;
  return AjA.default.createElement($, {
    dimColor: !0
  }, Q, "/", B)
}
// @from(Start 13181876, End 13181879)
AjA
// @from(Start 13181885, End 13181931)
uJ0 = L(() => {
  hA();
  AjA = BA(VA(), 1)
})
// @from(Start 13181934, End 13182496)
function vZ1({
  task: A
}) {
  switch (A.type) {
    case "shell":
      return rq.createElement($, null, J7(A.command, 40, !0), " ", rq.createElement(WQ9, {
        shell: A
      }));
    case "remote_session":
      return rq.createElement($, null, J7(A.title, 40, !0), " ", rq.createElement(xZ1, {
        session: A
      }));
    case "async_agent":
      return rq.createElement($, null, J7(A.description, 40, !0), " ", rq.createElement($, {
        dimColor: !0
      }, "(", A.status, A.status === "completed" && !A.retrieved && ", unread", ")"))
  }
}
// @from(Start 13182501, End 13182503)
rq
// @from(Start 13182509, End 13182572)
mJ0 = L(() => {
  XQ9();
  uJ0();
  hA();
  rq = BA(VA(), 1)
})
// @from(Start 13182621, End 13183681)
function Pg(A) {
  return A.flatMap((Q) => {
    switch (Q.type) {
      case "assistant":
        return [{
          type: "assistant",
          message: Q.message,
          uuid: Q.uuid,
          requestId: void 0,
          timestamp: new Date().toISOString()
        }];
      case "user":
        return [{
          type: "user",
          message: Q.message,
          uuid: Q.uuid ?? pO3(),
          timestamp: new Date().toISOString(),
          isMeta: Q.isSynthetic
        }];
      case "system":
        if (Q.subtype === "compact_boundary") {
          let B = Q;
          return [{
            type: "system",
            content: "Conversation compacted",
            level: "info",
            subtype: "compact_boundary",
            compactMetadata: {
              trigger: B.compact_metadata.trigger,
              preTokens: B.compact_metadata.pre_tokens
            },
            uuid: Q.uuid,
            timestamp: new Date().toISOString()
          }]
        }
        return [];
      default:
        return []
    }
  })
}
// @from(Start 13183683, End 13185098)
function VQ9(A) {
  return A.flatMap((Q) => {
    switch (Q.type) {
      case "assistant":
        return [{
          type: "assistant",
          message: Q.message,
          session_id: e1(),
          parent_tool_use_id: null,
          uuid: Q.uuid,
          error: Q.error
        }];
      case "user":
        return [{
          type: "user",
          message: Q.message,
          session_id: e1(),
          parent_tool_use_id: null,
          uuid: Q.uuid,
          isSynthetic: Q.isMeta || Q.isVisibleInTranscriptOnly
        }];
      case "system":
        if (Q.subtype === "compact_boundary" && Q.compactMetadata) return [{
          type: "system",
          subtype: "compact_boundary",
          session_id: e1(),
          uuid: Q.uuid,
          compact_metadata: {
            trigger: Q.compactMetadata.trigger,
            pre_tokens: Q.compactMetadata.preTokens
          }
        }];
        return [];
      case "attachment":
        if (m91(Q.attachment)) return [{
          type: "system",
          subtype: "hook_response",
          session_id: e1(),
          uuid: Q.uuid,
          hook_name: Q.attachment.hookName,
          hook_event: Q.attachment.hookEvent,
          stdout: Q.attachment.stdout || "",
          stderr: Q.attachment.stderr || "",
          exit_code: Q.attachment.exitCode
        }];
        return [];
      default:
        return []
    }
  })
}
// @from(Start 13185103, End 13185136)
QjA = L(() => {
  _0();
  IO()
})
// @from(Start 13185139, End 13186163)
function FQ9({
  tasksSelected: A,
  showHint: Q
}) {
  let {
    columns: B
  } = WB(), G = jg.useMemo(() => N1().hasSeenTasksHint, []), [{
    backgroundTasks: Z
  }] = OQ();
  lO3();
  let I = Q && (A || !G) ? lG.createElement(lG.Fragment, null, lG.createElement($, {
      dimColor: !0
    }, "· "), lG.createElement($, {
      dimColor: !0
    }, A ? "Enter to view tasks" : "↓ to view")) : null,
    Y = Object.values(Z).filter((J) => J.status === "running");
  if (Y.length === 0) return;
  if (Y.length > 1 || B < 150) return lG.createElement(lG.Fragment, null, lG.createElement($, {
    color: "background",
    inverse: A
  }, Y.length, " background", " ", Y.length === 1 ? "task" : "tasks"), I ? lG.createElement($, null, " ", I) : null);
  if (Y.length === 1) {
    let J = Y[0];
    return lG.createElement(lG.Fragment, null, lG.createElement($, {
      color: "background",
      inverse: A
    }, lG.createElement(vZ1, {
      task: J
    })), I ? lG.createElement($, null, " ", I) : null)
  }
  return null
}
// @from(Start 13186165, End 13187075)
function lO3() {
  let [{
    backgroundTasks: A
  }, Q] = OQ(), B = jg.useMemo(() => Object.values(A).filter((Y) => Y.type === "remote_session"), [A]), [G, Z] = jg.useState([]), I = jg.useCallback(async (Y) => {
    for await (let {
        response: {
          log: J
        },
        session: W
      }
      of KQ9(Y)) {
      let X = J.find((V) => V.type === "result");
      Q((V) => ({
        ...V,
        backgroundTasks: {
          ...V.backgroundTasks,
          [W.id]: {
            ...W,
            status: X ? X.subtype === "success" ? "completed" : "failed" : J.length > 0 ? "running" : "starting",
            log: J
          }
        }
      }))
    }
  }, [Q]);
  jg.useEffect(() => {
    if (B.every((J) => G.includes(J.id))) return;
    Z(B.map((J) => J.id));
    let Y = B.filter((J) => !G.includes(J.id));
    if (!Y.length) return;
    I(Y).catch((J) => AA(J))
  }, [I, G, B])
}
// @from(Start 13187076, End 13188022)
async function* KQ9(A) {
  if (!o2("tengu_web_tasks")) return;
  let Q = await Promise.all(A.map(async (G) => {
    let Z = await xRA(G.id),
      I = Z.log.find((W) => W.type === "result"),
      Y = {
        session: {
          ...G,
          status: I ? I.subtype === "success" ? "completed" : "failed" : "running",
          log: Z.log,
          todoList: iO3(Z.log)
        },
        response: Z
      },
      J = Z.log.slice(G.log.length);
    if (J.length > 0) {
      let W = await TP2(Pg(G.log), new AbortController().signal, async () => ZE(), !1, !1),
        X = await nO3(J, W);
      if (X) return {
        ...Y,
        session: {
          ...Y.session,
          deltaSummarySinceLastFlushToAttachment: X
        }
      }
    }
    return Y
  }));
  yield* Q;
  let B = Q.filter((G) => !G.session.log.some((Z) => Z.type === "result")).map((G) => G.session);
  await new Promise((G) => setTimeout(G, 1000)), yield* KQ9(B)
}
// @from(Start 13188024, End 13188399)
function iO3(A) {
  let Q = A.findLast((Z) => Z.type === "assistant" && Z.message.content.some((I) => I.type === "tool_use" && I.name === BY.name));
  if (!Q) return [];
  let B = Q.message.content.find((Z) => Z.type === "tool_use" && Z.name === BY.name)?.input;
  if (!B) return [];
  let G = BY.inputSchema.safeParse(B);
  if (!G.success) return [];
  return G.data.todos
}
// @from(Start 13188400, End 13189344)
async function nO3(A, Q) {
  if (!o2("tengu_web_tasks")) return null;
  let B = await uX({
      systemPrompt: ["You are given a few messages from a conversation, as well as a summary of the conversation so far. Your task is to summarize the new messages in the conversation based on the summary so far. Aim for 1-2 sentences at most, focusing on the most important details. The summary MUST be in <summary>summary goes here</summary> tags. If there is no new information, return an empty string: <summary></summary>."],
      userPrompt: `Summary so far: ${Q}

New messages: ${JSON.stringify(A)}`,
      signal: new AbortController().signal,
      options: {
        querySource: "background_task_summarize_delta",
        agents: [],
        isNonInteractiveSession: !1,
        hasAppendSystemPrompt: !1,
        mcpTools: [],
        agentIdOrSessionId: e1()
      }
    }),
    G = ji(B);
  if (!G) return null;
  return B9(G, "summary")
}
// @from(Start 13189349, End 13189351)
lG
// @from(Start 13189353, End 13189355)
jg
// @from(Start 13189361, End 13189532)
DQ9 = L(() => {
  hA();
  jQ();
  z9();
  $0A();
  g1();
  kt();
  mJ0();
  i8();
  D60();
  QjA();
  fZ();
  cQ();
  u2();
  _0();
  lG = BA(VA(), 1), jg = BA(VA(), 1)
})
// @from(Start 13189535, End 13189971)
function aO3({
  value: A,
  onChange: Q,
  historyFailedMatch: B
}) {
  return wQA.createElement(S, {
    gap: 1
  }, wQA.createElement($, {
    dimColor: !0
  }, B ? "no matching prompt:" : "search prompts:"), wQA.createElement(s4, {
    value: A,
    onChange: Q,
    cursorOffset: A.length,
    onChangeCursorOffset: () => {},
    columns: A.length + 1,
    focus: !0,
    showCursor: !0,
    multiline: !1,
    dimColor: !0
  }))
}
// @from(Start 13189976, End 13189979)
wQA
// @from(Start 13189981, End 13189984)
HQ9
// @from(Start 13189990, End 13190057)
CQ9 = L(() => {
  hA();
  ZY();
  wQA = BA(VA(), 1);
  HQ9 = aO3
})
// @from(Start 13190060, End 13190949)
function zQ9({
  exitMessage: A,
  vimMode: Q,
  mode: B,
  toolPermissionContext: G,
  suppressHint: Z,
  tasksSelected: I,
  isPasting: Y,
  isSearching: J,
  historyQuery: W,
  setHistoryQuery: X,
  historyFailedMatch: V
}) {
  if (A.show) return h3.createElement($, {
    dimColor: !0,
    key: "exit-message"
  }, "Press ", A.key, " again to exit");
  if (Y) return h3.createElement($, {
    dimColor: !0,
    key: "pasting-message"
  }, "Pasting text…");
  let F = dXA() && Q === "INSERT" && !J;
  return h3.createElement(S, {
    justifyContent: "flex-start",
    gap: 1
  }, J && h3.createElement(HQ9, {
    value: W,
    onChange: X,
    historyFailedMatch: V
  }), F ? h3.createElement($, {
    dimColor: !0,
    key: "vim-insert"
  }, "-- INSERT --") : null, h3.createElement(sO3, {
    mode: B,
    toolPermissionContext: G,
    showHint: !Z && !F,
    tasksSelected: I
  }))
}
// @from(Start 13190951, End 13192252)
function sO3({
  mode: A,
  toolPermissionContext: Q,
  showHint: B,
  tasksSelected: G
}) {
  let [{
    backgroundTasks: Z
  }] = OQ(), I = EQ9.useMemo(() => Object.values(Z).filter((F) => F.type === "remote_session" || F.status === "running").length, [Z]), Y = L_2(), J = null;
  if (A === "memory") return h3.createElement($, {
    color: "remember"
  }, "# to memorize");
  if (A === "bash") return h3.createElement($, {
    color: "bashBorder"
  }, "! for bash mode");
  if (A === "background" && o2("tengu_web_tasks")) return h3.createElement($, {
    color: "background"
  }, "& to background");
  let W = Q?.mode,
    X = !Bc0(W),
    V = [...W && X ? [h3.createElement($, {
      color: ZS(W),
      key: "mode"
    }, Gc0(W), " ", Fv(W).toLowerCase(), " on", h3.createElement($, {
      dimColor: !0
    }, " ", h3.createElement(E4, {
      shortcut: HU.displayText,
      action: "cycle",
      parens: !0
    })))] : [], ...I > 0 ? [h3.createElement(FQ9, {
      key: "tasks",
      tasksSelected: G,
      showHint: B
    })] : [], ...[]];
  if (V.length) return h3.createElement(S, null, dV(V, (F) => h3.createElement($, {
    dimColor: !0,
    key: `separator-${F}`
  }, " ", "·", " ")));
  if (!B) return null;
  return h3.createElement($, {
    dimColor: !0
  }, "? for shortcuts")
}
// @from(Start 13192257, End 13192259)
h3
// @from(Start 13192261, End 13192264)
EQ9
// @from(Start 13192270, End 13192410)
UQ9 = L(() => {
  hA();
  tPA();
  Up();
  Zw();
  DQ9();
  z9();
  CQ9();
  u2();
  D51();
  dF();
  h3 = BA(VA(), 1), EQ9 = BA(VA(), 1)
})
// @from(Start 13192413, End 13192468)
function Sg() {
  let [A] = OQ();
  return A.settings
}
// @from(Start 13192473, End 13192498)
BjA = L(() => {
  z9()
})
// @from(Start 13192501, End 13192554)
function dJ0(A) {
  return A?.statusLine !== void 0
}
// @from(Start 13192556, End 13193456)
function rO3(A, Q, B) {
  let G = Pt({
      permissionMode: A,
      mainLoopModel: k3(),
      exceeds200kTokens: Q
    }),
    Z = B?.outputStyle || wK;
  return {
    ...tE(),
    model: {
      id: G,
      display_name: nc(G)
    },
    workspace: {
      current_dir: W0(),
      project_dir: uQ()
    },
    version: {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION,
    output_style: {
      name: Z
    },
    cost: {
      total_cost_usd: hK(),
      total_duration_ms: zFA(),
      total_api_duration_ms: gN(),
      total_lines_added: Y2A(),
      total_lines_removed: J2A()
    },
    exceeds_200k_tokens: Q
  }
}
// @from(Start 13193458, End 13195362)
function $Q9({
  messages: A
}) {
  let Q = _g.useRef(void 0),
    [{
      toolPermissionContext: B,
      statusLineText: G
    }, Z] = OQ(),
    I = Sg(),
    Y = _g.useRef({
      messageId: null,
      exceeds200kTokens: !1,
      permissionMode: B.mode
    }),
    J = _g.useCallback(async (V) => {
      Q.current?.abort();
      let F = new AbortController;
      Q.current = F;
      try {
        let K = Y.current.exceeds200kTokens;
        if (V !== void 0) {
          let C = V.filter((q) => q.type === "assistant"),
            E = C[C.length - 1],
            U = E?.uuid || E?.message?.id || null;
          if (U !== Y.current.messageId) K = z91(V), Y.current.messageId = U, Y.current.exceeds200kTokens = K
        }
        let D = rO3(Y.current.permissionMode, K, I),
          H = await cJ0(D, F.signal);
        if (!F.signal.aborted) Z((C) => ({
          ...C,
          statusLineText: H
        }))
      } catch {}
    }, [Z, I]),
    W = qp(() => J(A), 300);
  if (_g.useEffect(() => {
      let V = A.filter((D) => D.type === "assistant"),
        F = V[V.length - 1],
        K = F?.uuid || F?.message?.id || null;
      if (K !== Y.current.messageId || B.mode !== Y.current.permissionMode) Y.current.messageId = K, Y.current.permissionMode = B.mode, W()
    }, [A, B.mode, W]), _g.useEffect(() => {
      let V = I?.statusLine;
      if (V) {
        if (GA("tengu_status_line_mount", {
            command_length: V.command.length,
            padding: V.padding
          }), I.disableAllHooks === !0) g("Status line is configured but disableAllHooks is true", {
          level: "warn"
        })
      }
    }, []), _g.useEffect(() => {
      return J(), () => {
        Q.current?.abort()
      }
    }, []), !G) return null;
  let X = I?.statusLine?.padding ?? 0;
  return GjA.createElement(S, {
    paddingX: X
  }, GjA.createElement($, {
    dimColor: !0
  }, G))
}
// @from(Start 13195367, End 13195370)
GjA
// @from(Start 13195372, End 13195374)
_g
// @from(Start 13195380, End 13195549)
wQ9 = L(() => {
  hA();
  YO();
  _0();
  U2();
  BjA();
  t2();
  JE();
  YO();
  q0();
  V0();
  z9();
  Gx();
  M_();
  GO();
  GjA = BA(VA(), 1), _g = BA(VA(), 1)
})
// @from(Start 13195552, End 13196136)
function lJ0({
  suggestions: A,
  selectedSuggestion: Q
}) {
  let {
    rows: B
  } = WB(), G = Math.min(10, Math.max(1, B - 3)), Z = (X) => {
    return Math.max(...X.map((V) => V.displayText.length)) + 5
  };
  if (A.length === 0) return null;
  let I = Z(A),
    Y = Math.max(0, Math.min(Q - Math.floor(G / 2), A.length - G)),
    J = Math.min(Y + G, A.length),
    W = A.slice(Y, J);
  return eE.createElement(S, {
    flexDirection: "column"
  }, W.map((X) => eE.createElement(oO3, {
    key: X.id,
    item: X,
    maxColumnWidth: I,
    isSelected: X.id === A[Q]?.id
  })))
}
// @from(Start 13196141, End 13196143)
eE
// @from(Start 13196145, End 13196148)
pJ0
// @from(Start 13196150, End 13196153)
oO3
// @from(Start 13196155, End 13196158)
UNZ
// @from(Start 13196164, End 13197006)
qQ9 = L(() => {
  hA();
  i8();
  eE = BA(VA(), 1), pJ0 = BA(VA(), 1), oO3 = pJ0.memo(function({
    item: Q,
    maxColumnWidth: B,
    isSelected: G
  }) {
    let Z = WB().columns,
      I = B ?? Q.displayText.length + 5,
      Y = Z < 80 || Q.description && I * 2 > Z,
      J = Q.color || (G ? "suggestion" : void 0),
      W = !G;
    return eE.createElement(S, {
      key: Q.id,
      flexDirection: Y ? "column" : "row"
    }, eE.createElement(S, {
      width: Y ? void 0 : I
    }, eE.createElement($, {
      color: J,
      dimColor: W
    }, Q.displayText)), Q.description && eE.createElement(S, {
      width: Z - (Y ? 4 : I + 4),
      paddingLeft: Y ? 4 : 0
    }, eE.createElement($, {
      color: G ? "suggestion" : void 0,
      dimColor: !G,
      wrap: "wrap-trim"
    }, Q.description)))
  });
  UNZ = pJ0.memo(lJ0)
})
// @from(Start 13197009, End 13198826)
function bZ1(A) {
  let {
    dimColor: Q,
    fixedWidth: B,
    gap: G,
    paddingX: Z
  } = A;
  return N2.createElement(S, {
    paddingX: Z,
    flexDirection: "row",
    gap: G
  }, N2.createElement(S, {
    flexDirection: "column",
    width: B ? 22 : void 0
  }, N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "! for bash mode")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "/ for commands")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "@ for file paths")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "# to memorize")), o2("tengu_web_tasks") && N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "& for background"))), N2.createElement(S, {
    flexDirection: "column",
    width: B ? 35 : void 0
  }, N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "double tap esc to clear input")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, HU.displayText.replace("+", " + "), " to auto-accept edits")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "ctrl + o for verbose output")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "ctrl + t to show todos")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "tab to toggle thinking")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, ZQ9()))), N2.createElement(S, {
    flexDirection: "column"
  }, N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "ctrl + _ to undo")), ZS0 && N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, "ctrl + z to suspend")), N2.createElement(S, null, N2.createElement($, {
    dimColor: Q
  }, tt.displayText.replace("+", " + "), " to paste images"))))
}
// @from(Start 13198831, End 13198833)
N2
// @from(Start 13198839, End 13198917)
iJ0 = L(() => {
  hA();
  Up();
  Q3();
  tPA();
  u2();
  N2 = BA(VA(), 1)
})
// @from(Start 13198920, End 13200576)
function tO3({
  apiKeyStatus: A,
  debug: Q,
  exitMessage: B,
  vimMode: G,
  mode: Z,
  autoUpdaterResult: I,
  isAutoUpdating: Y,
  verbose: J,
  onAutoUpdaterResult: W,
  onChangeIsUpdating: X,
  suggestions: V,
  selectedSuggestion: F,
  toolPermissionContext: K,
  helpOpen: D,
  suppressHint: H,
  tasksSelected: C,
  ideSelection: E,
  mcpClients: U,
  isPasting: q = !1,
  isInputWrapped: w = !1,
  messages: N,
  isSearching: R,
  historyQuery: T,
  setHistoryQuery: y,
  historyFailedMatch: v,
  shouldShowSearchHint: x
}) {
  let p = Sg(),
    u = H || dJ0(p) || R;
  if (V.length) return oD.createElement(S, {
    paddingX: 2,
    paddingY: 0
  }, oD.createElement(lJ0, {
    suggestions: V,
    selectedSuggestion: F
  }));
  if (D) return oD.createElement(bZ1, {
    dimColor: !0,
    fixedWidth: !0,
    paddingX: 2
  });
  return oD.createElement(S, {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingX: 2
  }, oD.createElement(S, {
    flexDirection: "column"
  }, Z === "prompt" && !B.show && !q && dJ0(p) && oD.createElement($Q9, {
    messages: N
  }), oD.createElement(zQ9, {
    exitMessage: B,
    vimMode: G,
    mode: Z,
    toolPermissionContext: K,
    suppressHint: u,
    tasksSelected: C,
    isPasting: q,
    isSearching: R,
    historyQuery: T,
    setHistoryQuery: y,
    historyFailedMatch: v
  })), oD.createElement(Z09, {
    apiKeyStatus: A,
    autoUpdaterResult: I,
    debug: Q,
    isAutoUpdating: Y,
    verbose: J,
    messages: N,
    onAutoUpdaterResult: W,
    onChangeIsUpdating: X,
    ideSelection: E,
    mcpClients: U,
    isInputWrapped: w,
    shouldShowSearchHint: x
  }))
}
// @from(Start 13200581, End 13200583)
oD
// @from(Start 13200585, End 13200588)
NQ9
// @from(Start 13200590, End 13200593)
LQ9
// @from(Start 13200599, End 13200740)
MQ9 = L(() => {
  hA();
  UQ9();
  HJ0();
  wQ9();
  BjA();
  qQ9();
  iJ0();
  oD = BA(VA(), 1), NQ9 = BA(VA(), 1);
  LQ9 = NQ9.memo(tO3)
})
// @from(Start 13200781, End 13203074)
function hZ1({
  onSelect: A,
  onCancel: Q,
  title: B,
  renderDetails: G
}) {
  let Z = gV(),
    I = OQ9(MQ(), "CLAUDE.md"),
    Y = OQ9(uQ(), "CLAUDE.md"),
    J = Z.some((U) => U.path === I),
    W = Z.some((U) => U.path === Y),
    X = [...Z.map((U) => ({
      ...U,
      exists: !0
    })), ...J ? [] : [{
      path: I,
      type: "User",
      content: "",
      exists: !1
    }], ...W ? [] : [{
      path: Y,
      type: "Project",
      content: "",
      exists: !1
    }]],
    V = new Map,
    F = X.map((U) => {
      let q = Q5(U.path),
        w = U.exists ? "" : " (new)",
        N = U.parent ? (V.get(U.parent) ?? 0) + 1 : 0;
      V.set(U.path, N);
      let R = N > 0 ? "  ".repeat(N - 1) : "",
        T;
      if (U.type === "User" && !U.isNested && U.path === I) T = "User memory";
      else if (U.type === "Project" && !U.isNested && U.path === Y) T = "Project memory";
      else if (N > 0) T = `${R}L ${q}${w}`;
      else T = `${q}`;
      let y, v = bP2(uQ());
      if (U.type === "User" && !U.isNested) y = "Saved in ~/.claude/CLAUDE.md";
      else if (U.type === "Project" && !U.isNested && U.path === Y) y = `${v?"Checked in at":"Saved in"} ./CLAUDE.md`;
      else if (U.type, U.parent) y = "@-imported";
      else if (U.isNested) y = "dynamically loaded";
      else y = "";
      return {
        label: T,
        value: U.path,
        description: y
      }
    }),
    K = fZ1 && F.some((U) => U.value === fZ1) ? fZ1 : F[0]?.value || "",
    [D, H] = RQ9.useState(K),
    E = X.find((U) => U.path === D)?.type;
  return EQ(), f1((U, q) => {
    if (q.escape) Q()
  }), oq.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "remember",
    padding: 1,
    width: "100%"
  }, oq.createElement(S, {
    marginBottom: 1,
    flexDirection: "row",
    justifyContent: "space-between"
  }, oq.createElement($, {
    color: "remember",
    bold: !0
  }, B || "Select memory file to edit:")), oq.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, oq.createElement(M0, {
    focusValue: K,
    options: F,
    onFocus: (U) => H(U),
    onChange: (U) => {
      fZ1 = U, A(U)
    },
    onCancel: Q
  })), G && oq.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, G(D, E)))
}
// @from(Start 13203079, End 13203081)
oq
// @from(Start 13203083, End 13203086)
RQ9
// @from(Start 13203088, End 13203091)
fZ1
// @from(Start 13203097, End 13203218)
nJ0 = L(() => {
  hA();
  J5();
  Q4();
  gE();
  R9();
  M60();
  _0();
  hQ();
  oq = BA(VA(), 1), RQ9 = BA(VA(), 1)
})
// @from(Start 13203221, End 13203774)
function TQ9(A, Q) {
  let B = gZ1.useRef(void 0);
  gZ1.useEffect(() => {
    let G = uU(A);
    if (B.current !== G) B.current = G;
    if (G) G.client.setNotificationHandler(AR3, (Z) => {
      if (B.current !== G) return;
      try {
        let I = Z.params,
          Y = I.lineStart !== void 0 ? I.lineStart + 1 : void 0,
          J = I.lineEnd !== void 0 ? I.lineEnd + 1 : void 0;
        Q({
          filePath: I.filePath,
          lineStart: Y,
          lineEnd: J
        })
      } catch (I) {
        AA(I)
      }
    })
  }, [A, Q])
}
// @from(Start 13203779, End 13203782)
gZ1
// @from(Start 13203784, End 13203804)
eO3 = "at_mentioned"
// @from(Start 13203808, End 13203811)
AR3
// @from(Start 13203817, End 13204065)
PQ9 = L(() => {
  Q2();
  nY();
  g1();
  gZ1 = BA(VA(), 1), AR3 = j.object({
    method: j.literal(eO3),
    params: j.object({
      filePath: j.string(),
      lineStart: j.number().optional(),
      lineEnd: j.number().optional()
    })
  })
})
// @from(Start 13204068, End 13205326)
function jQ9({
  maxBufferSize: A,
  debounceMs: Q
}) {
  let [B, G] = Zx.useState([]), [Z, I] = Zx.useState(-1), Y = Zx.useRef(0), J = Zx.useRef(null), W = Zx.useCallback((K, D, H = {}) => {
    let C = Date.now();
    if (J.current) clearTimeout(J.current), J.current = null;
    if (C - Y.current < Q) {
      J.current = setTimeout(() => {
        W(K, D, H)
      }, Q);
      return
    }
    Y.current = C, G((E) => {
      let U = Z >= 0 ? E.slice(0, Z + 1) : E,
        q = U[U.length - 1];
      if (q && q.text === K) return U;
      let w = [...U, {
        text: K,
        cursorOffset: D,
        pastedContents: H,
        timestamp: C
      }];
      if (w.length > A) return w.slice(-A);
      return w
    }), I((E) => {
      let U = E >= 0 ? E + 1 : B.length;
      return Math.min(U, A - 1)
    })
  }, [Q, A, Z, B.length]), X = Zx.useCallback(() => {
    if (Z < 0 || B.length === 0) return;
    let K = Math.max(0, Z - 1),
      D = B[K];
    if (D) return I(K), D;
    return
  }, [B, Z]), V = Zx.useCallback(() => {
    if (G([]), I(-1), Y.current = 0, J.current) clearTimeout(J.current), J.current = null
  }, [Y, J]), F = Z > 0 && B.length > 1;
  return {
    pushToBuffer: W,
    undo: X,
    canUndo: F,
    clearBuffer: V
  }
}
// @from(Start 13205331, End 13205333)
Zx
// @from(Start 13205339, End 13205376)
SQ9 = L(() => {
  Zx = BA(VA(), 1)
})
// @from(Start 13205379, End 13210091)
function _Q9({
  shell: A,
  onDone: Q,
  onKillShell: B,
  onBack: G
}) {
  let {
    columns: Z
  } = WB(), [I, Y] = ZjA.useState(0), [J, W] = ZjA.useState({
    stdout: "",
    stderr: "",
    stdoutLines: 0,
    stderrLines: 0
  });
  f1((K, D) => {
    if (D.escape || D.return || K === " ") Q("Shell details dismissed", {
      display: "system"
    });
    else if (D.leftArrow && G) G();
    else if (K === "k" && A.status === "running" && B) B()
  });
  let X = EQ(),
    V = (K) => {
      let D = Math.floor((Date.now() - K) / 1000),
        H = Math.floor(D / 3600),
        C = Math.floor((D - H * 3600) / 60),
        E = D - H * 3600 - C * 60;
      return `${H>0?`${H}h `:""}${C>0||H>0?`${C}m `:""}${E}s`
    };
  ZjA.useEffect(() => {
    let K = J01(A),
      D = (N, R, T = 10) => {
        if (!R) return N;
        let y = N.split(`
`),
          v = R.split(`
`);
        return [...y, ...v].slice(-T).join(`
`)
      },
      H = D(J.stdout, K.stdout),
      C = D(J.stderr, K.stderr),
      {
        totalLines: E,
        truncatedContent: U
      } = m_(H),
      {
        totalLines: q,
        truncatedContent: w
      } = m_(C);
    if (W({
        stdout: U,
        stderr: w,
        stdoutLines: E,
        stderrLines: q
      }), A.status === "running") {
      let N = setTimeout(() => {
        Y((R) => R + 1)
      }, 1000);
      return () => clearTimeout(N)
    }
  }, [A.id, A.status, I, J.stdout, J.stderr, A]);
  let F = A.command.length > 280 ? A.command.substring(0, 277) + "…" : A.command;
  return z3.default.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, z3.default.createElement(S, {
    width: "100%"
  }, z3.default.createElement(S, {
    borderStyle: "round",
    borderColor: "background",
    flexDirection: "column",
    marginTop: 1,
    paddingLeft: 1,
    paddingRight: 1,
    width: "100%"
  }, z3.default.createElement(S, null, z3.default.createElement($, {
    color: "background",
    bold: !0
  }, "Shell details")), z3.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, z3.default.createElement($, null, z3.default.createElement($, {
    bold: !0
  }, "Status:"), " ", A.status === "running" ? z3.default.createElement($, {
    color: "background"
  }, A.status, A.result?.code !== void 0 && ` (exit code: ${A.result.code})`) : A.status === "completed" ? z3.default.createElement($, {
    color: "success"
  }, A.status, A.result?.code !== void 0 && ` (exit code: ${A.result.code})`) : z3.default.createElement($, {
    color: "error"
  }, A.status, A.result?.code !== void 0 && ` (exit code: ${A.result.code})`)), z3.default.createElement($, null, z3.default.createElement($, {
    bold: !0
  }, "Runtime:"), " ", V(A.startTime)), z3.default.createElement($, {
    wrap: "wrap"
  }, z3.default.createElement($, {
    bold: !0
  }, "Command:"), " ", F)), z3.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, z3.default.createElement($, {
    bold: !0
  }, "Stdout:"), J.stdout ? z3.default.createElement(z3.default.Fragment, null, z3.default.createElement(S, {
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1,
    flexDirection: "column",
    height: 12,
    maxWidth: Z - 8
  }, J.stdout.split(`
`).slice(-10).map((K, D) => z3.default.createElement($, {
    key: D,
    wrap: "truncate-end"
  }, K))), z3.default.createElement($, {
    dimColor: !0,
    italic: !0
  }, J.stdoutLines > 10 ? `Showing last 10 lines of ${J.stdoutLines} total lines` : `Showing ${J.stdoutLines} lines`)) : z3.default.createElement($, {
    dimColor: !0
  }, "No stdout output available")), J.stderr && z3.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, z3.default.createElement($, {
    bold: !0,
    color: "error"
  }, "Stderr:"), z3.default.createElement(S, {
    borderStyle: "round",
    borderColor: "error",
    paddingX: 1,
    flexDirection: "column",
    height: 3,
    maxWidth: Z - 8
  }, J.stderr.split(`
`).slice(-1).map((K, D) => z3.default.createElement($, {
    key: D,
    color: "error",
    wrap: "truncate-end"
  }, K))), z3.default.createElement($, {
    dimColor: !0,
    italic: !0,
    color: "error"
  }, J.stderrLines > 1 ? `Showing last line of ${J.stderrLines} total lines` : `Showing ${J.stderrLines} line`)))), z3.default.createElement(S, {
    marginLeft: 2
  }, X.pending ? z3.default.createElement($, {
    dimColor: !0
  }, "Press ", X.keyName, " again to exit") : z3.default.createElement($, {
    dimColor: !0
  }, G ? z3.default.createElement($, null, "← to go back · ") : null, "Esc/Enter/Space to close", A.status === "running" && B ? z3.default.createElement($, null, " · k to kill") : null)))
}
// @from(Start 13210096, End 13210098)
z3
// @from(Start 13210100, End 13210103)
ZjA
// @from(Start 13210109, End 13210206)
kQ9 = L(() => {
  hA();
  i8();
  Q4();
  _AA();
  Np();
  z3 = BA(VA(), 1), ZjA = BA(VA(), 1)
})
// @from(Start 13210209, End 13210308)
function yQ9() {
  return IjA.createElement(S0, {
    height: 1
  }, IjA.createElement(zk, null))
}
// @from(Start 13210313, End 13210316)
IjA
// @from(Start 13210322, End 13210377)
xQ9 = L(() => {
  tZA();
  q8();
  IjA = BA(VA(), 1)
})
// @from(Start 13210380, End 13210544)
function vQ9({
  feedback: A
}) {
  return YjA.createElement(S0, null, YjA.createElement($, {
    color: "error"
  }, "Tool use rejected with user message: ", A))
}
// @from(Start 13210549, End 13210552)
YjA
// @from(Start 13210558, End 13210612)
bQ9 = L(() => {
  hA();
  q8();
  YjA = BA(VA(), 1)
})
// @from(Start 13210615, End 13211453)
function fQ9({
  progressMessagesForMessage: A,
  tool: Q,
  tools: B,
  param: G,
  verbose: Z
}) {
  let [I] = qB();
  if (typeof G.content === "string" && G.content.includes(xO)) return sP.createElement(S0, {
    height: 1
  }, sP.createElement(zk, null));
  if (typeof G.content === "string" && G.content.startsWith(aJ0)) {
    let Y = G.content.substring(aJ0.length);
    return sP.createElement(o31, {
      plan: Y,
      themeName: I
    })
  }
  if (typeof G.content === "string" && G.content.startsWith(JjA)) {
    let Y = G.content.substring(JjA.length);
    return sP.createElement(vQ9, {
      feedback: Y
    })
  }
  if (!Q) return sP.createElement(Q6, {
    result: G.content,
    verbose: Z
  });
  return Q.renderToolUseErrorMessage(G.content, {
    progressMessagesForMessage: $p(A),
    tools: B,
    verbose: Z
  })
}
// @from(Start 13211458, End 13211460)
sP
// @from(Start 13211466, End 13211562)
hQ9 = L(() => {
  cQ();
  tZA();
  q8();
  yJ();
  hA();
  eG0();
  bQ9();
  sP = BA(VA(), 1)
})
// @from(Start 13211565, End 13212063)
function gQ9({
  input: A,
  progressMessagesForMessage: Q,
  style: B,
  tool: G,
  tools: Z,
  messages: I,
  verbose: Y
}) {
  let {
    columns: J
  } = WB(), [W] = qB();
  if (!G) return WjA.createElement(k5, null);
  let X = G.inputSchema.safeParse(A);
  if (!X.success) return WjA.createElement(k5, null);
  return G.renderToolUseRejectedMessage(X.data, {
    columns: J,
    messages: I,
    tools: Z,
    verbose: Y,
    progressMessagesForMessage: $p(Q),
    style: B,
    theme: W
  })
}
// @from(Start 13212068, End 13212071)
WjA
// @from(Start 13212077, End 13212139)
uQ9 = L(() => {
  iX();
  i8();
  hA();
  WjA = BA(VA(), 1)
})
// @from(Start 13212145, End 13212166)
mQ9 = "\x1B[0m\x1B(B"
// @from(Start 13212169, End 13212824)
function uZ1({
  hookEvent: A,
  messages: Q,
  toolUseID: B,
  verbose: G
}) {
  let Z = dQ9(Q, B, A),
    I = cQ9(Q, B, A);
  if (I === Z) return null;
  return lW.createElement(S0, null, lW.createElement(S, {
    flexDirection: "column"
  }, lW.createElement(S, {
    flexDirection: "row"
  }, lW.createElement($, {
    dimColor: !0
  }, "Running "), lW.createElement($, {
    dimColor: !0,
    bold: !0
  }, A), Z === 1 ? lW.createElement($, {
    dimColor: !0
  }, " hook…") : lW.createElement($, {
    dimColor: !0
  }, " ", "hooks… (", I, "/", Z, " done)")), G && lW.createElement(QR3, {
    messages: Q,
    toolUseID: B,
    hookEvent: A
  })))
}
// @from(Start 13212826, End 13213235)
function QR3({
  messages: A,
  toolUseID: Q,
  hookEvent: B
}) {
  let G = A.filter((Z) => Z.type === "progress" && Z.data.type === "hook_progress" && Z.data.hookEvent === B && Z.parentToolUseID === Q);
  return lW.createElement(S, {
    flexDirection: "column",
    marginLeft: 2
  }, G.map((Z) => lW.createElement($, {
    dimColor: !0,
    key: Z.uuid
  }, "· ", Z.data.hookName, ": ", Z.data.command)))
}
// @from(Start 13213240, End 13213242)
lW
// @from(Start 13213248, End 13213309)
sJ0 = L(() => {
  q8();
  hA();
  cQ();
  lW = BA(VA(), 1)
})
// @from(Start 13213312, End 13213993)
function pQ9({
  message: A,
  messages: Q,
  toolUseID: B,
  progressMessagesForMessage: G,
  style: Z,
  tool: I,
  tools: Y,
  verbose: J,
  width: W
}) {
  let [X] = qB();
  if (!A.toolUseResult || !I) return null;
  let V = I.renderToolResultMessage(A.toolUseResult, $p(G), {
    style: Z,
    theme: X,
    tools: Y,
    verbose: J
  });
  if (V === null) return null;
  return rP.createElement(S, {
    flexDirection: "column"
  }, rP.createElement(S, {
    flexDirection: "row",
    width: W
  }, V, rP.createElement($, null, mQ9)), rP.createElement(CQA, null, rP.createElement(uZ1, {
    hookEvent: "PostToolUse",
    messages: Q,
    toolUseID: B,
    verbose: J
  })))
}
// @from(Start 13213998, End 13214000)
rP
// @from(Start 13214006, End 13214069)
lQ9 = L(() => {
  hA();
  sJ0();
  $Z1();
  rP = BA(VA(), 1)
})
// @from(Start 13214072, End 13214315)
function BR3(A, Q) {
  let B = null;
  for (let G of Q) {
    if (G.type !== "assistant" || !Array.isArray(G.message.content)) continue;
    for (let Z of G.message.content)
      if (Z.type === "tool_use" && Z.id === A) B = Z
  }
  return B
}
// @from(Start 13214317, End 13214557)
function nQ9(A, Q, B) {
  return iQ9.useMemo(() => {
    let G = BR3(A, B);
    if (!G) return null;
    let Z = Q.find((I) => I.name === G.name);
    if (!Z) return null;
    return {
      tool: Z,
      toolUse: G
    }
  }, [A, B, Q])
}
// @from(Start 13214562, End 13214565)
iQ9
// @from(Start 13214571, End 13214609)
aQ9 = L(() => {
  iQ9 = BA(VA(), 1)
})
// @from(Start 13214612, End 13215460)
function sQ9({
  param: A,
  message: Q,
  messages: B,
  progressMessagesForMessage: G,
  style: Z,
  tools: I,
  verbose: Y,
  width: J
}) {
  let W = nQ9(A.tool_use_id, I, B);
  if (!W) return null;
  if (A.content === pXA) return kg.createElement(yQ9, null);
  if (A.content === XjA || A.content === xO) return kg.createElement(gQ9, {
    input: W.toolUse.input,
    progressMessagesForMessage: G,
    tool: W.tool,
    tools: I,
    messages: B,
    style: Z,
    verbose: Y
  });
  if (A.is_error) return kg.createElement(fQ9, {
    progressMessagesForMessage: G,
    tool: W.tool,
    tools: I,
    param: A,
    verbose: Y
  });
  return kg.createElement(pQ9, {
    message: Q,
    messages: B,
    toolUseID: W.toolUse.id,
    progressMessagesForMessage: G,
    style: Z,
    tool: W.tool,
    tools: I,
    verbose: Y,
    width: J
  })
}
// @from(Start 13215465, End 13215467)
kg
// @from(Start 13215473, End 13215563)
rQ9 = L(() => {
  cQ();
  xQ9();
  hQ9();
  uQ9();
  lQ9();
  aQ9();
  kg = BA(VA(), 1)
})
// @from(Start 13215566, End 13216009)
function GR3() {
  let A = new Bp;
  A.setMaxListeners(100);
  let Q = null,
    B = !0;
  return {
    subscribe(G) {
      if (A.on("blink", G), A.listenerCount("blink") === 1) Q = setInterval(() => {
        B = !B, A.emit("blink")
      }, 600);
      return B
    },
    unsubscribe(G) {
      if (A.off("blink", G), A.listenerCount("blink") === 0 && Q) clearInterval(Q), Q = null
    },
    getCurrentState() {
      return B
    }
  }
}
// @from(Start 13216011, End 13216307)
function tQ9(A) {
  let Q = oQ9(),
    [B, G] = mZ1.useState(Q.getCurrentState());
  return mZ1.useEffect(() => {
    if (!A) return;
    let Z = oQ9(),
      I = () => G(Z.getCurrentState()),
      Y = Z.subscribe(I);
    return G(Y), () => {
      Z.unsubscribe(I)
    }
  }, [A]), A ? B : !0
}
// @from(Start 13216312, End 13216315)
mZ1
// @from(Start 13216317, End 13216320)
oQ9
// @from(Start 13216326, End 13216397)
eQ9 = L(() => {
  hA();
  l2();
  mZ1 = BA(VA(), 1);
  oQ9 = s1(GR3)
})
// @from(Start 13216400, End 13216685)
function dZ1({
  isError: A,
  isUnresolved: Q,
  shouldAnimate: B
}) {
  let G = tQ9(B);
  return rJ0.default.createElement(S, {
    minWidth: 2
  }, rJ0.default.createElement($, {
    color: Q ? void 0 : A ? "error" : "success",
    dimColor: Q
  }, !B || G || A || !Q ? rD : " "))
}
// @from(Start 13216690, End 13216693)
rJ0
// @from(Start 13216699, End 13216762)
oJ0 = L(() => {
  hA();
  dn();
  eQ9();
  rJ0 = BA(VA(), 1)
})
// @from(Start 13216768, End 13216790)
Wa = "AgentOutputTool"
// @from(Start 13216793, End 13219640)
function AB9({
  param: A,
  addMargin: Q,
  tools: B,
  verbose: G,
  erroredToolUseIDs: Z,
  inProgressToolUseIDs: I,
  resolvedToolUseIDs: Y,
  progressMessagesForMessage: J,
  shouldAnimate: W,
  shouldShowDot: X,
  inProgressToolCallCount: V,
  messages: F
}) {
  let K = WB(),
    [D] = qB();
  if (!B) return AA(Error(`Tools array is undefined for tool ${A.name}`)), null;
  let H = B.find((R) => R.name === A.name);
  if (!H) return AA(Error(`Tool ${A.name} not found`)), null;
  let C = Y.has(A.id),
    E = !I.has(A.id) && !C,
    U = H.inputSchema.safeParse(A.input),
    q = H.userFacingName(U.success ? U.data : void 0),
    w = H.userFacingNameBackgroundColor?.(U.success ? U.data : void 0);
  if (q === "") return null;
  let N = U.success ? ZR3(H, U.data, {
    theme: D,
    verbose: G
  }) : null;
  if (N === null) return null;
  return eY.default.createElement(S, {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: Q ? 1 : 0,
    width: "100%"
  }, eY.default.createElement(S, {
    flexDirection: "column"
  }, eY.default.createElement(S, {
    flexDirection: "row",
    flexWrap: "nowrap",
    minWidth: q.length + (X ? 2 : 0)
  }, X && (E ? eY.default.createElement(S, {
    minWidth: 2
  }, eY.default.createElement($, {
    dimColor: E
  }, rD)) : eY.default.createElement(dZ1, {
    shouldAnimate: W,
    isUnresolved: !C,
    isError: Z.has(A.id)
  })), eY.default.createElement(S, {
    flexShrink: 0
  }, eY.default.createElement($, {
    bold: !0,
    wrap: "truncate-end",
    backgroundColor: w,
    color: w ? "inverseText" : void 0
  }, q)), N !== "" && eY.default.createElement(S, {
    flexWrap: "nowrap"
  }, eY.default.createElement($, null, "(", N, ")")), H.name === C9 && U.success && U.data.timeout && (() => {
    let R = U.data.timeout,
      T = ZGA();
    if (R !== T) return eY.default.createElement(S, {
      flexWrap: "nowrap",
      marginLeft: 1
    }, eY.default.createElement($, {
      dimColor: !0
    }, "timeout: ", eC(R)));
    return null
  })(), H.name === A6 && U.success && U.data.resume && eY.default.createElement(S, {
    flexWrap: "nowrap",
    marginLeft: 1
  }, eY.default.createElement($, {
    dimColor: !0
  }, "resuming ", U.data.resume)), H.name === A6 && U.success && U.data.model && (() => {
    let R = UD(U.data.model),
      T = k3();
    if (R !== T) return eY.default.createElement(S, {
      flexWrap: "nowrap",
      marginLeft: 1
    }, eY.default.createElement($, {
      dimColor: !0
    }, nc(R)));
    return null
  })(), H.name === Wa && U.success && U.data.agentId && eY.default.createElement(S, {
    flexWrap: "nowrap",
    marginLeft: 1
  }, eY.default.createElement($, {
    dimColor: !0
  }, U.data.agentId))), !C && !E && IR3(H, B, F, A.id, J, {
    verbose: G,
    inProgressToolCallCount: V
  }, K), !C && E && YR3(H)))
}
// @from(Start 13219642, End 13219958)
function ZR3(A, Q, {
  theme: B,
  verbose: G
}) {
  try {
    let Z = A.inputSchema.safeParse(Q);
    if (!Z.success) return "";
    return A.renderToolUseMessage(Z.data, {
      theme: B,
      verbose: G
    })
  } catch (Z) {
    return AA(Error(`Error rendering tool use message for ${A.name}: ${Z}`)), ""
  }
}
// @from(Start 13219960, End 13220603)
function IR3(A, Q, B, G, Z, {
  verbose: I,
  inProgressToolCallCount: Y
}, J) {
  let W = Z.filter((X) => X.data.type !== "hook_progress");
  try {
    let X = A.renderToolUseProgressMessage(W, {
      tools: Q,
      verbose: I,
      terminalSize: J,
      inProgressToolCallCount: Y ?? 1
    });
    return eY.default.createElement(eY.default.Fragment, null, eY.default.createElement(CQA, null, eY.default.createElement(uZ1, {
      hookEvent: "PreToolUse",
      messages: B,
      toolUseID: G,
      verbose: I
    })), X)
  } catch (X) {
    return AA(Error(`Error rendering tool use progress message for ${A.name}: ${X}`)), null
  }
}
// @from(Start 13220605, End 13220786)
function YR3(A) {
  try {
    return A.renderToolUseQueuedMessage?.()
  } catch (Q) {
    return AA(Error(`Error rendering tool use queued message for ${A.name}: ${Q}`)), null
  }
}
// @from(Start 13220791, End 13220793)
eY
// @from(Start 13220799, End 13220912)
QB9 = L(() => {
  hA();
  g1();
  oJ0();
  dn();
  i8();
  IGA();
  t2();
  sJ0();
  $Z1();
  eY = BA(VA(), 1)
})
// @from(Start 13220918, End 13238173)
oP = z((WMZ, lZ1) => {
  var BB9, GB9, ZB9, IB9, YB9, JB9, WB9, XB9, VB9, FB9, KB9, DB9, HB9, cZ1, tJ0, CB9, EB9, zB9, lXA, UB9, $B9, wB9, qB9, NB9, LB9, MB9, OB9, RB9, pZ1, TB9, PB9, jB9;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof lZ1 === "object" && typeof WMZ === "object") A(B(Q, B(WMZ)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    BB9 = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, GB9 = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, ZB9 = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, IB9 = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, YB9 = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, JB9 = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, WB9 = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, XB9 = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, VB9 = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, FB9 = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, KB9 = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, DB9 = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, HB9 = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) pZ1(Y, I, J)
    }, pZ1 = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, cZ1 = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, tJ0 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, CB9 = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(tJ0(arguments[Y]));
      return I
    }, EB9 = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, zB9 = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, lXA = function(I) {
      return this instanceof lXA ? (this.v = I, this) : new lXA(I)
    }, UB9 = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof lXA ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, $B9 = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: lXA(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, wB9 = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof cZ1 === "function" ? cZ1(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, qB9 = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    NB9 = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") pZ1(Y, I, J[W])
      }
      return B(Y, I), Y
    }, LB9 = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, MB9 = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, OB9 = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, RB9 = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, TB9 = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    PB9 = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, jB9 = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", BB9), A("__assign", GB9), A("__rest", ZB9), A("__decorate", IB9), A("__param", YB9), A("__esDecorate", JB9), A("__runInitializers", WB9), A("__propKey", XB9), A("__setFunctionName", VB9), A("__metadata", FB9), A("__awaiter", KB9), A("__generator", DB9), A("__exportStar", HB9), A("__createBinding", pZ1), A("__values", cZ1), A("__read", tJ0), A("__spread", CB9), A("__spreadArrays", EB9), A("__spreadArray", zB9), A("__await", lXA), A("__asyncGenerator", UB9), A("__asyncDelegator", $B9), A("__asyncValues", wB9), A("__makeTemplateObject", qB9), A("__importStar", NB9), A("__importDefault", LB9), A("__classPrivateFieldGet", MB9), A("__classPrivateFieldSet", OB9), A("__classPrivateFieldIn", RB9), A("__addDisposableResource", TB9), A("__disposeResources", PB9), A("__rewriteRelativeImportExtension", jB9)
  })
})
// @from(Start 13238179, End 13238264)
_B9 = z((SB9) => {
  Object.defineProperty(SB9, "__esModule", {
    value: !0
  })
})
// @from(Start 13238270, End 13238355)
yB9 = z((kB9) => {
  Object.defineProperty(kB9, "__esModule", {
    value: !0
  })
})
// @from(Start 13238361, End 13238446)
eJ0 = z((xB9) => {
  Object.defineProperty(xB9, "__esModule", {
    value: !0
  })
})
// @from(Start 13238452, End 13238861)
AW0 = z((WR3) => {
  function JR3(A, Q, B) {
    Q.split && (Q = Q.split("."));
    var G = 0,
      Z = Q.length,
      I = A,
      Y, J;
    while (G < Z) {
      if (J = "" + Q[G++], J === "__proto__" || J === "constructor" || J === "prototype") break;
      I = I[J] = G === Z ? B : typeof(Y = I[J]) === typeof Q ? Y : Q[G] * 0 !== 0 || !!~("" + Q[G]).indexOf(".") ? {} : []
    }
  }
  WR3.dset = JR3
})
// @from(Start 13238867, End 13239170)
fB9 = z((vB9) => {
  Object.defineProperty(vB9, "__esModule", {
    value: !0
  });
  vB9.pickBy = void 0;
  var VR3 = function(A, Q) {
    return Object.keys(A).filter(function(B) {
      return Q(B, A[B])
    }).reduce(function(B, G) {
      return B[G] = A[G], B
    }, {})
  };
  vB9.pickBy = VR3
})
// @from(Start 13239176, End 13239551)
QW0 = z((hB9) => {
  Object.defineProperty(hB9, "__esModule", {
    value: !0
  });
  hB9.ValidationError = void 0;
  var FR3 = oP(),
    KR3 = function(A) {
      FR3.__extends(Q, A);

      function Q(B, G) {
        var Z = A.call(this, "".concat(B, " ").concat(G)) || this;
        return Z.field = B, Z
      }
      return Q
    }(Error);
  hB9.ValidationError = KR3
})
// @from(Start 13239557, End 13240196)
BW0 = z((uB9) => {
  Object.defineProperty(uB9, "__esModule", {
    value: !0
  });
  uB9.isPlainObject = uB9.exists = uB9.isFunction = uB9.isNumber = uB9.isString = void 0;

  function DR3(A) {
    return typeof A === "string"
  }
  uB9.isString = DR3;

  function HR3(A) {
    return typeof A === "number"
  }
  uB9.isNumber = HR3;

  function CR3(A) {
    return typeof A === "function"
  }
  uB9.isFunction = CR3;

  function ER3(A) {
    return A !== void 0 && A !== null
  }
  uB9.exists = ER3;

  function zR3(A) {
    return Object.prototype.toString.call(A).slice(8, -1).toLowerCase() === "object"
  }
  uB9.isPlainObject = zR3
})
// @from(Start 13240202, End 13242029)
IW0 = z((sB9) => {
  Object.defineProperty(sB9, "__esModule", {
    value: !0
  });
  sB9.validateEvent = sB9.assertTraits = sB9.assertTrackEventProperties = sB9.assertTrackEventName = sB9.assertEventType = sB9.assertEventExists = sB9.assertUserIdentity = void 0;
  var Xa = QW0(),
    qQA = BW0(),
    GW0 = "is not a string",
    ZW0 = "is not an object",
    dB9 = "is nil";

  function cB9(A) {
    var Q = ".userId/anonymousId/previousId/groupId",
      B = function(Z) {
        var I, Y, J;
        return (J = (Y = (I = Z.userId) !== null && I !== void 0 ? I : Z.anonymousId) !== null && Y !== void 0 ? Y : Z.groupId) !== null && J !== void 0 ? J : Z.previousId
      },
      G = B(A);
    if (!(0, qQA.exists)(G)) throw new Xa.ValidationError(Q, dB9);
    else if (!(0, qQA.isString)(G)) throw new Xa.ValidationError(Q, GW0)
  }
  sB9.assertUserIdentity = cB9;

  function pB9(A) {
    if (!(0, qQA.exists)(A)) throw new Xa.ValidationError("Event", dB9);
    if (typeof A !== "object") throw new Xa.ValidationError("Event", ZW0)
  }
  sB9.assertEventExists = pB9;

  function lB9(A) {
    if (!(0, qQA.isString)(A.type)) throw new Xa.ValidationError(".type", GW0)
  }
  sB9.assertEventType = lB9;

  function iB9(A) {
    if (!(0, qQA.isString)(A.event)) throw new Xa.ValidationError(".event", GW0)
  }
  sB9.assertTrackEventName = iB9;

  function nB9(A) {
    if (!(0, qQA.isPlainObject)(A.properties)) throw new Xa.ValidationError(".properties", ZW0)
  }
  sB9.assertTrackEventProperties = nB9;

  function aB9(A) {
    if (!(0, qQA.isPlainObject)(A.traits)) throw new Xa.ValidationError(".traits", ZW0)
  }
  sB9.assertTraits = aB9;

  function NR3(A) {
    if (pB9(A), lB9(A), A.type === "track") iB9(A), nB9(A);
    if (["group", "identify"].includes(A.type)) aB9(A);
    cB9(A)
  }
  sB9.validateEvent = NR3
})
// @from(Start 13242035, End 13246504)
eB9 = z((YW0) => {
  Object.defineProperty(YW0, "__esModule", {
    value: !0
  });
  YW0.EventFactory = void 0;
  var y6 = oP();
  y6.__exportStar(eJ0(), YW0);
  var oB9 = AW0(),
    jR3 = fB9(),
    SR3 = IW0(),
    _R3 = function() {
      function A(Q) {
        this.user = Q.user, this.createMessageId = Q.createMessageId
      }
      return A.prototype.track = function(Q, B, G, Z) {
        return this.normalize(y6.__assign(y6.__assign({}, this.baseEvent()), {
          event: Q,
          type: "track",
          properties: B !== null && B !== void 0 ? B : {},
          options: y6.__assign({}, G),
          integrations: y6.__assign({}, Z)
        }))
      }, A.prototype.page = function(Q, B, G, Z, I) {
        var Y, J = {
          type: "page",
          properties: y6.__assign({}, G),
          options: y6.__assign({}, Z),
          integrations: y6.__assign({}, I)
        };
        if (Q !== null) J.category = Q, J.properties = (Y = J.properties) !== null && Y !== void 0 ? Y : {}, J.properties.category = Q;
        if (B !== null) J.name = B;
        return this.normalize(y6.__assign(y6.__assign({}, this.baseEvent()), J))
      }, A.prototype.screen = function(Q, B, G, Z, I) {
        var Y = {
          type: "screen",
          properties: y6.__assign({}, G),
          options: y6.__assign({}, Z),
          integrations: y6.__assign({}, I)
        };
        if (Q !== null) Y.category = Q;
        if (B !== null) Y.name = B;
        return this.normalize(y6.__assign(y6.__assign({}, this.baseEvent()), Y))
      }, A.prototype.identify = function(Q, B, G, Z) {
        return this.normalize(y6.__assign(y6.__assign({}, this.baseEvent()), {
          type: "identify",
          userId: Q,
          traits: B !== null && B !== void 0 ? B : {},
          options: y6.__assign({}, G),
          integrations: Z
        }))
      }, A.prototype.group = function(Q, B, G, Z) {
        return this.normalize(y6.__assign(y6.__assign({}, this.baseEvent()), {
          type: "group",
          traits: B !== null && B !== void 0 ? B : {},
          options: y6.__assign({}, G),
          integrations: y6.__assign({}, Z),
          groupId: Q
        }))
      }, A.prototype.alias = function(Q, B, G, Z) {
        var I = {
          userId: Q,
          type: "alias",
          options: y6.__assign({}, G),
          integrations: y6.__assign({}, Z)
        };
        if (B !== null) I.previousId = B;
        if (Q === void 0) return this.normalize(y6.__assign(y6.__assign({}, I), this.baseEvent()));
        return this.normalize(y6.__assign(y6.__assign({}, this.baseEvent()), I))
      }, A.prototype.baseEvent = function() {
        var Q = {
          integrations: {},
          options: {}
        };
        if (!this.user) return Q;
        var B = this.user;
        if (B.id()) Q.userId = B.id();
        if (B.anonymousId()) Q.anonymousId = B.anonymousId();
        return Q
      }, A.prototype.context = function(Q) {
        var B, G = ["userId", "anonymousId", "timestamp"];
        delete Q.integrations;
        var Z = Object.keys(Q),
          I = (B = Q.context) !== null && B !== void 0 ? B : {},
          Y = {};
        return Z.forEach(function(J) {
          if (J === "context") return;
          if (G.includes(J))(0, oB9.dset)(Y, J, Q[J]);
          else(0, oB9.dset)(I, J, Q[J])
        }), [I, Y]
      }, A.prototype.normalize = function(Q) {
        var B, G, Z = Object.keys((B = Q.integrations) !== null && B !== void 0 ? B : {}).reduce(function(D, H) {
          var C, E;
          return y6.__assign(y6.__assign({}, D), (C = {}, C[H] = Boolean((E = Q.integrations) === null || E === void 0 ? void 0 : E[H]), C))
        }, {});
        Q.options = (0, jR3.pickBy)(Q.options || {}, function(D, H) {
          return H !== void 0
        });
        var I = y6.__assign(y6.__assign({}, Z), (G = Q.options) === null || G === void 0 ? void 0 : G.integrations),
          Y = Q.options ? this.context(Q.options) : [],
          J = Y[0],
          W = Y[1],
          X = Q.options,
          V = y6.__rest(Q, ["options"]),
          F = y6.__assign(y6.__assign(y6.__assign({
            timestamp: new Date
          }, V), {
            integrations: I,
            context: J
          }), W),
          K = y6.__assign(y6.__assign({}, F), {
            messageId: this.createMessageId()
          });
        return (0, SR3.validateEvent)(K), K
      }, A
    }();
  YW0.EventFactory = _R3
})
// @from(Start 13246510, End 13247541)
JW0 = z((B29) => {
  Object.defineProperty(B29, "__esModule", {
    value: !0
  });
  B29.invokeCallback = B29.sleep = B29.pTimeout = void 0;

  function A29(A, Q) {
    return new Promise(function(B, G) {
      var Z = setTimeout(function() {
        G(Error("Promise timed out"))
      }, Q);
      A.then(function(I) {
        return clearTimeout(Z), B(I)
      }).catch(G)
    })
  }
  B29.pTimeout = A29;

  function Q29(A) {
    return new Promise(function(Q) {
      return setTimeout(Q, A)
    })
  }
  B29.sleep = Q29;

  function kR3(A, Q, B) {
    var G = function() {
      try {
        return Promise.resolve(Q(A))
      } catch (Z) {
        return Promise.reject(Z)
      }
    };
    return Q29(B).then(function() {
      return A29(G(), 1000)
    }).catch(function(Z) {
      A === null || A === void 0 || A.log("warn", "Callback Error", {
        error: Z
      }), A === null || A === void 0 || A.stats.increment("callback_error")
    }).then(function() {
      return A
    })
  }
  B29.invokeCallback = kR3
})
// @from(Start 13247547, End 13264803)
sZ1 = z(($MZ, aZ1) => {
  var Z29, I29, Y29, J29, W29, X29, V29, F29, K29, D29, H29, C29, E29, iZ1, WW0, z29, U29, $29, iXA, w29, q29, N29, L29, M29, O29, R29, T29, P29, nZ1, j29, S29, _29;
  (function(A) {
    var Q = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) define("tslib", ["exports"], function(G) {
      A(B(Q, B(G)))
    });
    else if (typeof aZ1 === "object" && typeof $MZ === "object") A(B(Q, B($MZ)));
    else A(B(Q));

    function B(G, Z) {
      if (G !== Q)
        if (typeof Object.create === "function") Object.defineProperty(G, "__esModule", {
          value: !0
        });
        else G.__esModule = !0;
      return function(I, Y) {
        return G[I] = Z ? Z(I, Y) : Y
      }
    }
  })(function(A) {
    var Q = Object.setPrototypeOf || {
      __proto__: []
    }
    instanceof Array && function(I, Y) {
      I.__proto__ = Y
    } || function(I, Y) {
      for (var J in Y)
        if (Object.prototype.hasOwnProperty.call(Y, J)) I[J] = Y[J]
    };
    Z29 = function(I, Y) {
      if (typeof Y !== "function" && Y !== null) throw TypeError("Class extends value " + String(Y) + " is not a constructor or null");
      Q(I, Y);

      function J() {
        this.constructor = I
      }
      I.prototype = Y === null ? Object.create(Y) : (J.prototype = Y.prototype, new J)
    }, I29 = Object.assign || function(I) {
      for (var Y, J = 1, W = arguments.length; J < W; J++) {
        Y = arguments[J];
        for (var X in Y)
          if (Object.prototype.hasOwnProperty.call(Y, X)) I[X] = Y[X]
      }
      return I
    }, Y29 = function(I, Y) {
      var J = {};
      for (var W in I)
        if (Object.prototype.hasOwnProperty.call(I, W) && Y.indexOf(W) < 0) J[W] = I[W];
      if (I != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var X = 0, W = Object.getOwnPropertySymbols(I); X < W.length; X++)
          if (Y.indexOf(W[X]) < 0 && Object.prototype.propertyIsEnumerable.call(I, W[X])) J[W[X]] = I[W[X]]
      }
      return J
    }, J29 = function(I, Y, J, W) {
      var X = arguments.length,
        V = X < 3 ? Y : W === null ? W = Object.getOwnPropertyDescriptor(Y, J) : W,
        F;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") V = Reflect.decorate(I, Y, J, W);
      else
        for (var K = I.length - 1; K >= 0; K--)
          if (F = I[K]) V = (X < 3 ? F(V) : X > 3 ? F(Y, J, V) : F(Y, J)) || V;
      return X > 3 && V && Object.defineProperty(Y, J, V), V
    }, W29 = function(I, Y) {
      return function(J, W) {
        Y(J, W, I)
      }
    }, X29 = function(I, Y, J, W, X, V) {
      function F(T) {
        if (T !== void 0 && typeof T !== "function") throw TypeError("Function expected");
        return T
      }
      var K = W.kind,
        D = K === "getter" ? "get" : K === "setter" ? "set" : "value",
        H = !Y && I ? W.static ? I : I.prototype : null,
        C = Y || (H ? Object.getOwnPropertyDescriptor(H, W.name) : {}),
        E, U = !1;
      for (var q = J.length - 1; q >= 0; q--) {
        var w = {};
        for (var N in W) w[N] = N === "access" ? {} : W[N];
        for (var N in W.access) w.access[N] = W.access[N];
        w.addInitializer = function(T) {
          if (U) throw TypeError("Cannot add initializers after decoration has completed");
          V.push(F(T || null))
        };
        var R = (0, J[q])(K === "accessor" ? {
          get: C.get,
          set: C.set
        } : C[D], w);
        if (K === "accessor") {
          if (R === void 0) continue;
          if (R === null || typeof R !== "object") throw TypeError("Object expected");
          if (E = F(R.get)) C.get = E;
          if (E = F(R.set)) C.set = E;
          if (E = F(R.init)) X.unshift(E)
        } else if (E = F(R))
          if (K === "field") X.unshift(E);
          else C[D] = E
      }
      if (H) Object.defineProperty(H, W.name, C);
      U = !0
    }, V29 = function(I, Y, J) {
      var W = arguments.length > 2;
      for (var X = 0; X < Y.length; X++) J = W ? Y[X].call(I, J) : Y[X].call(I);
      return W ? J : void 0
    }, F29 = function(I) {
      return typeof I === "symbol" ? I : "".concat(I)
    }, K29 = function(I, Y, J) {
      if (typeof Y === "symbol") Y = Y.description ? "[".concat(Y.description, "]") : "";
      return Object.defineProperty(I, "name", {
        configurable: !0,
        value: J ? "".concat(J, " ", Y) : Y
      })
    }, D29 = function(I, Y) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(I, Y)
    }, H29 = function(I, Y, J, W) {
      function X(V) {
        return V instanceof J ? V : new J(function(F) {
          F(V)
        })
      }
      return new(J || (J = Promise))(function(V, F) {
        function K(C) {
          try {
            H(W.next(C))
          } catch (E) {
            F(E)
          }
        }

        function D(C) {
          try {
            H(W.throw(C))
          } catch (E) {
            F(E)
          }
        }

        function H(C) {
          C.done ? V(C.value) : X(C.value).then(K, D)
        }
        H((W = W.apply(I, Y || [])).next())
      })
    }, C29 = function(I, Y) {
      var J = {
          label: 0,
          sent: function() {
            if (V[0] & 1) throw V[1];
            return V[1]
          },
          trys: [],
          ops: []
        },
        W, X, V, F = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return F.next = K(0), F.throw = K(1), F.return = K(2), typeof Symbol === "function" && (F[Symbol.iterator] = function() {
        return this
      }), F;

      function K(H) {
        return function(C) {
          return D([H, C])
        }
      }

      function D(H) {
        if (W) throw TypeError("Generator is already executing.");
        while (F && (F = 0, H[0] && (J = 0)), J) try {
          if (W = 1, X && (V = H[0] & 2 ? X.return : H[0] ? X.throw || ((V = X.return) && V.call(X), 0) : X.next) && !(V = V.call(X, H[1])).done) return V;
          if (X = 0, V) H = [H[0] & 2, V.value];
          switch (H[0]) {
            case 0:
            case 1:
              V = H;
              break;
            case 4:
              return J.label++, {
                value: H[1],
                done: !1
              };
            case 5:
              J.label++, X = H[1], H = [0];
              continue;
            case 7:
              H = J.ops.pop(), J.trys.pop();
              continue;
            default:
              if ((V = J.trys, !(V = V.length > 0 && V[V.length - 1])) && (H[0] === 6 || H[0] === 2)) {
                J = 0;
                continue
              }
              if (H[0] === 3 && (!V || H[1] > V[0] && H[1] < V[3])) {
                J.label = H[1];
                break
              }
              if (H[0] === 6 && J.label < V[1]) {
                J.label = V[1], V = H;
                break
              }
              if (V && J.label < V[2]) {
                J.label = V[2], J.ops.push(H);
                break
              }
              if (V[2]) J.ops.pop();
              J.trys.pop();
              continue
          }
          H = Y.call(I, J)
        } catch (C) {
          H = [6, C], X = 0
        } finally {
          W = V = 0
        }
        if (H[0] & 5) throw H[1];
        return {
          value: H[0] ? H[1] : void 0,
          done: !0
        }
      }
    }, E29 = function(I, Y) {
      for (var J in I)
        if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J)) nZ1(Y, I, J)
    }, nZ1 = Object.create ? function(I, Y, J, W) {
      if (W === void 0) W = J;
      var X = Object.getOwnPropertyDescriptor(Y, J);
      if (!X || ("get" in X ? !Y.__esModule : X.writable || X.configurable)) X = {
        enumerable: !0,
        get: function() {
          return Y[J]
        }
      };
      Object.defineProperty(I, W, X)
    } : function(I, Y, J, W) {
      if (W === void 0) W = J;
      I[W] = Y[J]
    }, iZ1 = function(I) {
      var Y = typeof Symbol === "function" && Symbol.iterator,
        J = Y && I[Y],
        W = 0;
      if (J) return J.call(I);
      if (I && typeof I.length === "number") return {
        next: function() {
          if (I && W >= I.length) I = void 0;
          return {
            value: I && I[W++],
            done: !I
          }
        }
      };
      throw TypeError(Y ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }, WW0 = function(I, Y) {
      var J = typeof Symbol === "function" && I[Symbol.iterator];
      if (!J) return I;
      var W = J.call(I),
        X, V = [],
        F;
      try {
        while ((Y === void 0 || Y-- > 0) && !(X = W.next()).done) V.push(X.value)
      } catch (K) {
        F = {
          error: K
        }
      } finally {
        try {
          if (X && !X.done && (J = W.return)) J.call(W)
        } finally {
          if (F) throw F.error
        }
      }
      return V
    }, z29 = function() {
      for (var I = [], Y = 0; Y < arguments.length; Y++) I = I.concat(WW0(arguments[Y]));
      return I
    }, U29 = function() {
      for (var I = 0, Y = 0, J = arguments.length; Y < J; Y++) I += arguments[Y].length;
      for (var W = Array(I), X = 0, Y = 0; Y < J; Y++)
        for (var V = arguments[Y], F = 0, K = V.length; F < K; F++, X++) W[X] = V[F];
      return W
    }, $29 = function(I, Y, J) {
      if (J || arguments.length === 2) {
        for (var W = 0, X = Y.length, V; W < X; W++)
          if (V || !(W in Y)) {
            if (!V) V = Array.prototype.slice.call(Y, 0, W);
            V[W] = Y[W]
          }
      }
      return I.concat(V || Array.prototype.slice.call(Y))
    }, iXA = function(I) {
      return this instanceof iXA ? (this.v = I, this) : new iXA(I)
    }, w29 = function(I, Y, J) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var W = J.apply(I, Y || []),
        X, V = [];
      return X = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), K("next"), K("throw"), K("return", F), X[Symbol.asyncIterator] = function() {
        return this
      }, X;

      function F(q) {
        return function(w) {
          return Promise.resolve(w).then(q, E)
        }
      }

      function K(q, w) {
        if (W[q]) {
          if (X[q] = function(N) {
              return new Promise(function(R, T) {
                V.push([q, N, R, T]) > 1 || D(q, N)
              })
            }, w) X[q] = w(X[q])
        }
      }

      function D(q, w) {
        try {
          H(W[q](w))
        } catch (N) {
          U(V[0][3], N)
        }
      }

      function H(q) {
        q.value instanceof iXA ? Promise.resolve(q.value.v).then(C, E) : U(V[0][2], q)
      }

      function C(q) {
        D("next", q)
      }

      function E(q) {
        D("throw", q)
      }

      function U(q, w) {
        if (q(w), V.shift(), V.length) D(V[0][0], V[0][1])
      }
    }, q29 = function(I) {
      var Y, J;
      return Y = {}, W("next"), W("throw", function(X) {
        throw X
      }), W("return"), Y[Symbol.iterator] = function() {
        return this
      }, Y;

      function W(X, V) {
        Y[X] = I[X] ? function(F) {
          return (J = !J) ? {
            value: iXA(I[X](F)),
            done: !1
          } : V ? V(F) : F
        } : V
      }
    }, N29 = function(I) {
      if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
      var Y = I[Symbol.asyncIterator],
        J;
      return Y ? Y.call(I) : (I = typeof iZ1 === "function" ? iZ1(I) : I[Symbol.iterator](), J = {}, W("next"), W("throw"), W("return"), J[Symbol.asyncIterator] = function() {
        return this
      }, J);

      function W(V) {
        J[V] = I[V] && function(F) {
          return new Promise(function(K, D) {
            F = I[V](F), X(K, D, F.done, F.value)
          })
        }
      }

      function X(V, F, K, D) {
        Promise.resolve(D).then(function(H) {
          V({
            value: H,
            done: K
          })
        }, F)
      }
    }, L29 = function(I, Y) {
      if (Object.defineProperty) Object.defineProperty(I, "raw", {
        value: Y
      });
      else I.raw = Y;
      return I
    };
    var B = Object.create ? function(I, Y) {
        Object.defineProperty(I, "default", {
          enumerable: !0,
          value: Y
        })
      } : function(I, Y) {
        I.default = Y
      },
      G = function(I) {
        return G = Object.getOwnPropertyNames || function(Y) {
          var J = [];
          for (var W in Y)
            if (Object.prototype.hasOwnProperty.call(Y, W)) J[J.length] = W;
          return J
        }, G(I)
      };
    M29 = function(I) {
      if (I && I.__esModule) return I;
      var Y = {};
      if (I != null) {
        for (var J = G(I), W = 0; W < J.length; W++)
          if (J[W] !== "default") nZ1(Y, I, J[W])
      }
      return B(Y, I), Y
    }, O29 = function(I) {
      return I && I.__esModule ? I : {
        default: I
      }
    }, R29 = function(I, Y, J, W) {
      if (J === "a" && !W) throw TypeError("Private accessor was defined without a getter");
      if (typeof Y === "function" ? I !== Y || !W : !Y.has(I)) throw TypeError("Cannot read private member from an object whose class did not declare it");
      return J === "m" ? W : J === "a" ? W.call(I) : W ? W.value : Y.get(I)
    }, T29 = function(I, Y, J, W, X) {
      if (W === "m") throw TypeError("Private method is not writable");
      if (W === "a" && !X) throw TypeError("Private accessor was defined without a setter");
      if (typeof Y === "function" ? I !== Y || !X : !Y.has(I)) throw TypeError("Cannot write private member to an object whose class did not declare it");
      return W === "a" ? X.call(I, J) : X ? X.value = J : Y.set(I, J), J
    }, P29 = function(I, Y) {
      if (Y === null || typeof Y !== "object" && typeof Y !== "function") throw TypeError("Cannot use 'in' operator on non-object");
      return typeof I === "function" ? Y === I : I.has(Y)
    }, j29 = function(I, Y, J) {
      if (Y !== null && Y !== void 0) {
        if (typeof Y !== "object" && typeof Y !== "function") throw TypeError("Object expected.");
        var W, X;
        if (J) {
          if (!Symbol.asyncDispose) throw TypeError("Symbol.asyncDispose is not defined.");
          W = Y[Symbol.asyncDispose]
        }
        if (W === void 0) {
          if (!Symbol.dispose) throw TypeError("Symbol.dispose is not defined.");
          if (W = Y[Symbol.dispose], J) X = W
        }
        if (typeof W !== "function") throw TypeError("Object not disposable.");
        if (X) W = function() {
          try {
            X.call(this)
          } catch (V) {
            return Promise.reject(V)
          }
        };
        I.stack.push({
          value: Y,
          dispose: W,
          async: J
        })
      } else if (J) I.stack.push({
        async: !0
      });
      return Y
    };
    var Z = typeof SuppressedError === "function" ? SuppressedError : function(I, Y, J) {
      var W = Error(J);
      return W.name = "SuppressedError", W.error = I, W.suppressed = Y, W
    };
    S29 = function(I) {
      function Y(V) {
        I.error = I.hasError ? new Z(V, I.error, "An error was suppressed during disposal.") : V, I.hasError = !0
      }
      var J, W = 0;

      function X() {
        while (J = I.stack.pop()) try {
          if (!J.async && W === 1) return W = 0, I.stack.push(J), Promise.resolve().then(X);
          if (J.dispose) {
            var V = J.dispose.call(J.value);
            if (J.async) return W |= 2, Promise.resolve(V).then(X, function(F) {
              return Y(F), X()
            })
          } else W |= 1
        } catch (F) {
          Y(F)
        }
        if (W === 1) return I.hasError ? Promise.reject(I.error) : Promise.resolve();
        if (I.hasError) throw I.error
      }
      return X()
    }, _29 = function(I, Y) {
      if (typeof I === "string" && /^\.\.?\//.test(I)) return I.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(J, W, X, V, F) {
        return W ? Y ? ".jsx" : ".js" : X && (!V || !F) ? J : X + V + "." + F.toLowerCase() + "js"
      });
      return I
    }, A("__extends", Z29), A("__assign", I29), A("__rest", Y29), A("__decorate", J29), A("__param", W29), A("__esDecorate", X29), A("__runInitializers", V29), A("__propKey", F29), A("__setFunctionName", K29), A("__metadata", D29), A("__awaiter", H29), A("__generator", C29), A("__exportStar", E29), A("__createBinding", nZ1), A("__values", iZ1), A("__read", WW0), A("__spread", z29), A("__spreadArrays", U29), A("__spreadArray", $29), A("__await", iXA), A("__asyncGenerator", w29), A("__asyncDelegator", q29), A("__asyncValues", N29), A("__makeTemplateObject", L29), A("__importStar", M29), A("__importDefault", O29), A("__classPrivateFieldGet", R29), A("__classPrivateFieldSet", T29), A("__classPrivateFieldIn", P29), A("__addDisposableResource", j29), A("__disposeResources", S29), A("__rewriteRelativeImportExtension", _29)
  })
})
// @from(Start 13264809, End 13265128)
x29 = z((k29) => {
  Object.defineProperty(k29, "__esModule", {
    value: !0
  });
  k29.createDeferred = void 0;
  var vR3 = function() {
    var A, Q, B = new Promise(function(G, Z) {
      A = G, Q = Z
    });
    return {
      resolve: A,
      reject: Q,
      promise: B
    }
  };
  k29.createDeferred = vR3
})
// @from(Start 13265134, End 13265270)
v29 = z((XW0) => {
  Object.defineProperty(XW0, "__esModule", {
    value: !0
  });
  var bR3 = sZ1();
  bR3.__exportStar(x29(), XW0)
})
// @from(Start 13265276, End 13266956)
h29 = z((b29) => {
  Object.defineProperty(b29, "__esModule", {
    value: !0
  });
  b29.Emitter = void 0;
  var fR3 = function() {
    function A(Q) {
      var B;
      this.callbacks = {}, this.warned = !1, this.maxListeners = (B = Q === null || Q === void 0 ? void 0 : Q.maxListeners) !== null && B !== void 0 ? B : 10
    }
    return A.prototype.warnIfPossibleMemoryLeak = function(Q) {
      if (this.warned) return;
      if (this.maxListeners && this.callbacks[Q].length > this.maxListeners) console.warn("Event Emitter: Possible memory leak detected; ".concat(String(Q), " has exceeded ").concat(this.maxListeners, " listeners.")), this.warned = !0
    }, A.prototype.on = function(Q, B) {
      if (!this.callbacks[Q]) this.callbacks[Q] = [B];
      else this.callbacks[Q].push(B), this.warnIfPossibleMemoryLeak(Q);
      return this
    }, A.prototype.once = function(Q, B) {
      var G = this,
        Z = function() {
          var I = [];
          for (var Y = 0; Y < arguments.length; Y++) I[Y] = arguments[Y];
          G.off(Q, Z), B.apply(G, I)
        };
      return this.on(Q, Z), this
    }, A.prototype.off = function(Q, B) {
      var G, Z = (G = this.callbacks[Q]) !== null && G !== void 0 ? G : [],
        I = Z.filter(function(Y) {
          return Y !== B
        });
      return this.callbacks[Q] = I, this
    }, A.prototype.emit = function(Q) {
      var B = this,
        G, Z = [];
      for (var I = 1; I < arguments.length; I++) Z[I - 1] = arguments[I];
      var Y = (G = this.callbacks[Q]) !== null && G !== void 0 ? G : [];
      return Y.forEach(function(J) {
        J.apply(B, Z)
      }), this
    }, A
  }();
  b29.Emitter = fR3
})
// @from(Start 13266962, End 13267098)
g29 = z((VW0) => {
  Object.defineProperty(VW0, "__esModule", {
    value: !0
  });
  var hR3 = sZ1();
  hR3.__exportStar(h29(), VW0)
})
// @from(Start 13267104, End 13267272)
nXA = z((rZ1) => {
  Object.defineProperty(rZ1, "__esModule", {
    value: !0
  });
  var u29 = sZ1();
  u29.__exportStar(v29(), rZ1);
  u29.__exportStar(g29(), rZ1)
})
// @from(Start 13267278, End 13267702)
FW0 = z((m29) => {
  Object.defineProperty(m29, "__esModule", {
    value: !0
  });
  m29.backoff = void 0;

  function gR3(A) {
    var Q = Math.random() + 1,
      B = A.minTimeout,
      G = B === void 0 ? 500 : B,
      Z = A.factor,
      I = Z === void 0 ? 2 : Z,
      Y = A.attempt,
      J = A.maxTimeout,
      W = J === void 0 ? 1 / 0 : J;
    return Math.min(Q * G * Math.pow(I, Y), W)
  }
  m29.backoff = gR3
})
// @from(Start 13267708, End 13270142)
KW0 = z((c29) => {
  Object.defineProperty(c29, "__esModule", {
    value: !0
  });
  c29.PriorityQueue = c29.ON_REMOVE_FROM_FUTURE = void 0;
  var uR3 = oP(),
    mR3 = nXA(),
    dR3 = FW0();
  c29.ON_REMOVE_FROM_FUTURE = "onRemoveFromFuture";
  var cR3 = function(A) {
    uR3.__extends(Q, A);

    function Q(B, G, Z) {
      var I = A.call(this) || this;
      return I.future = [], I.maxAttempts = B, I.queue = G, I.seen = Z !== null && Z !== void 0 ? Z : {}, I
    }
    return Q.prototype.push = function() {
      var B = this,
        G = [];
      for (var Z = 0; Z < arguments.length; Z++) G[Z] = arguments[Z];
      var I = G.map(function(Y) {
        var J = B.updateAttempts(Y);
        if (J > B.maxAttempts || B.includes(Y)) return !1;
        return B.queue.push(Y), !0
      });
      return this.queue = this.queue.sort(function(Y, J) {
        return B.getAttempts(Y) - B.getAttempts(J)
      }), I
    }, Q.prototype.pushWithBackoff = function(B) {
      var G = this;
      if (this.getAttempts(B) === 0) return this.push(B)[0];
      var Z = this.updateAttempts(B);
      if (Z > this.maxAttempts || this.includes(B)) return !1;
      var I = (0, dR3.backoff)({
        attempt: Z - 1
      });
      return setTimeout(function() {
        G.queue.push(B), G.future = G.future.filter(function(Y) {
          return Y.id !== B.id
        }), G.emit(c29.ON_REMOVE_FROM_FUTURE)
      }, I), this.future.push(B), !0
    }, Q.prototype.getAttempts = function(B) {
      var G;
      return (G = this.seen[B.id]) !== null && G !== void 0 ? G : 0
    }, Q.prototype.updateAttempts = function(B) {
      return this.seen[B.id] = this.getAttempts(B) + 1, this.getAttempts(B)
    }, Q.prototype.includes = function(B) {
      return this.queue.includes(B) || this.future.includes(B) || Boolean(this.queue.find(function(G) {
        return G.id === B.id
      })) || Boolean(this.future.find(function(G) {
        return G.id === B.id
      }))
    }, Q.prototype.pop = function() {
      return this.queue.shift()
    }, Object.defineProperty(Q.prototype, "length", {
      get: function() {
        return this.queue.length
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(Q.prototype, "todo", {
      get: function() {
        return this.queue.length + this.future.length
      },
      enumerable: !1,
      configurable: !0
    }), Q
  }(mR3.Emitter);
  c29.PriorityQueue = cR3
})
// @from(Start 13270148, End 13270711)
DW0 = z((lR3) => {
  var NQA = 256,
    tZ1 = [],
    oZ1;
  while (NQA--) tZ1[NQA] = (NQA + 256).toString(16).substring(1);

  function pR3() {
    var A = 0,
      Q, B = "";
    if (!oZ1 || NQA + 16 > 256) {
      oZ1 = Array(A = 256);
      while (A--) oZ1[A] = 256 * Math.random() | 0;
      A = NQA = 0
    }
    for (; A < 16; A++) {
      if (Q = oZ1[NQA + A], A == 6) B += tZ1[Q & 15 | 64];
      else if (A == 8) B += tZ1[Q & 63 | 128];
      else B += tZ1[Q];
      if (A & 1 && A > 1 && A < 11) B += "-"
    }
    return NQA++, B
  }
  lR3.v4 = pR3
})
// @from(Start 13270717, End 13272370)
HW0 = z((i29) => {
  Object.defineProperty(i29, "__esModule", {
    value: !0
  });
  i29.CoreLogger = void 0;
  var eZ1 = oP(),
    nR3 = function() {
      function A() {
        this._logs = []
      }
      return A.prototype.log = function(Q, B, G) {
        var Z = new Date;
        this._logs.push({
          level: Q,
          message: B,
          time: Z,
          extras: G
        })
      }, Object.defineProperty(A.prototype, "logs", {
        get: function() {
          return this._logs
        },
        enumerable: !1,
        configurable: !0
      }), A.prototype.flush = function() {
        if (this.logs.length > 1) {
          var Q = this._logs.reduce(function(B, G) {
            var Z, I, Y, J = eZ1.__assign(eZ1.__assign({}, G), {
              json: JSON.stringify(G.extras, null, " "),
              extras: G.extras
            });
            delete J.time;
            var W = (Y = (I = G.time) === null || I === void 0 ? void 0 : I.toISOString()) !== null && Y !== void 0 ? Y : "";
            if (B[W]) W = "".concat(W, "-").concat(Math.random());
            return eZ1.__assign(eZ1.__assign({}, B), (Z = {}, Z[W] = J, Z))
          }, {});
          if (console.table) console.table(Q);
          else console.log(Q)
        } else this.logs.forEach(function(B) {
          var {
            level: G,
            message: Z,
            extras: I
          } = B;
          if (G === "info" || G === "debug") console.log(Z, I !== null && I !== void 0 ? I : "");
          else console[G](Z, I !== null && I !== void 0 ? I : "")
        });
        this._logs = []
      }, A
    }();
  i29.CoreLogger = nR3
})
// @from(Start 13272376, End 13274557)
EW0 = z((s29) => {
  Object.defineProperty(s29, "__esModule", {
    value: !0
  });
  s29.NullStats = s29.CoreStats = void 0;
  var CW0 = oP(),
    aR3 = function(A) {
      var Q = {
        gauge: "g",
        counter: "c"
      };
      return Q[A]
    },
    a29 = function() {
      function A() {
        this.metrics = []
      }
      return A.prototype.increment = function(Q, B, G) {
        if (B === void 0) B = 1;
        this.metrics.push({
          metric: Q,
          value: B,
          tags: G !== null && G !== void 0 ? G : [],
          type: "counter",
          timestamp: Date.now()
        })
      }, A.prototype.gauge = function(Q, B, G) {
        this.metrics.push({
          metric: Q,
          value: B,
          tags: G !== null && G !== void 0 ? G : [],
          type: "gauge",
          timestamp: Date.now()
        })
      }, A.prototype.flush = function() {
        var Q = this.metrics.map(function(B) {
          return CW0.__assign(CW0.__assign({}, B), {
            tags: B.tags.join(",")
          })
        });
        if (console.table) console.table(Q);
        else console.log(Q);
        this.metrics = []
      }, A.prototype.serialize = function() {
        return this.metrics.map(function(Q) {
          return {
            m: Q.metric,
            v: Q.value,
            t: Q.tags,
            k: aR3(Q.type),
            e: Q.timestamp
          }
        })
      }, A
    }();
  s29.CoreStats = a29;
  var sR3 = function(A) {
    CW0.__extends(Q, A);

    function Q() {
      return A !== null && A.apply(this, arguments) || this
    }
    return Q.prototype.gauge = function() {
      var B = [];
      for (var G = 0; G < arguments.length; G++) B[G] = arguments[G]
    }, Q.prototype.increment = function() {
      var B = [];
      for (var G = 0; G < arguments.length; G++) B[G] = arguments[G]
    }, Q.prototype.flush = function() {
      var B = [];
      for (var G = 0; G < arguments.length; G++) B[G] = arguments[G]
    }, Q.prototype.serialize = function() {
      var B = [];
      for (var G = 0; G < arguments.length; G++) B[G] = arguments[G];
      return []
    }, Q
  }(a29);
  s29.NullStats = sR3
})
// @from(Start 13274563, End 13276714)
AI1 = z((t29) => {
  Object.defineProperty(t29, "__esModule", {
    value: !0
  });
  t29.CoreContext = t29.ContextCancelation = void 0;
  var oR3 = DW0(),
    tR3 = AW0(),
    eR3 = HW0(),
    AT3 = EW0(),
    o29 = function() {
      function A(Q) {
        var B, G, Z;
        this.retry = (B = Q.retry) !== null && B !== void 0 ? B : !0, this.type = (G = Q.type) !== null && G !== void 0 ? G : "plugin Error", this.reason = (Z = Q.reason) !== null && Z !== void 0 ? Z : ""
      }
      return A
    }();
  t29.ContextCancelation = o29;
  var QT3 = function() {
    function A(Q, B, G, Z) {
      if (B === void 0) B = (0, oR3.v4)();
      if (G === void 0) G = new AT3.NullStats;
      if (Z === void 0) Z = new eR3.CoreLogger;
      this.attempts = 0, this.event = Q, this._id = B, this.logger = Z, this.stats = G
    }
    return A.system = function() {}, A.prototype.isSame = function(Q) {
      return Q.id === this.id
    }, A.prototype.cancel = function(Q) {
      if (Q) throw Q;
      throw new o29({
        reason: "Context Cancel"
      })
    }, A.prototype.log = function(Q, B, G) {
      this.logger.log(Q, B, G)
    }, Object.defineProperty(A.prototype, "id", {
      get: function() {
        return this._id
      },
      enumerable: !1,
      configurable: !0
    }), A.prototype.updateEvent = function(Q, B) {
      var G;
      if (Q.split(".")[0] === "integrations") {
        var Z = Q.split(".")[1];
        if (((G = this.event.integrations) === null || G === void 0 ? void 0 : G[Z]) === !1) return this.event
      }
      return (0, tR3.dset)(this.event, Q, B), this.event
    }, A.prototype.failedDelivery = function() {
      return this._failedDelivery
    }, A.prototype.setFailedDelivery = function(Q) {
      this._failedDelivery = Q
    }, A.prototype.logs = function() {
      return this.logger.logs
    }, A.prototype.flush = function() {
      this.logger.flush(), this.stats.flush()
    }, A.prototype.toJSON = function() {
      return {
        id: this._id,
        event: this.event,
        logs: this.logger.logs,
        metrics: this.stats.metrics
      }
    }, A
  }();
  t29.CoreContext = QT3
})
// @from(Start 13276720, End 13277292)
G99 = z((Q99) => {
  Object.defineProperty(Q99, "__esModule", {
    value: !0
  });
  Q99.groupBy = void 0;
  var A99 = oP();

  function GT3(A, Q) {
    var B = {};
    return A.forEach(function(G) {
      var Z, I = void 0;
      if (typeof Q === "string") {
        var Y = G[Q];
        I = typeof Y !== "string" ? JSON.stringify(Y) : Y
      } else if (Q instanceof Function) I = Q(G);
      if (I === void 0) return;
      B[I] = A99.__spreadArray(A99.__spreadArray([], (Z = B[I]) !== null && Z !== void 0 ? Z : [], !0), [G], !1)
    }), B
  }
  Q99.groupBy = GT3
})
// @from(Start 13277298, End 13277559)
Y99 = z((Z99) => {
  Object.defineProperty(Z99, "__esModule", {
    value: !0
  });
  Z99.isThenable = void 0;
  var ZT3 = function(A) {
    return typeof A === "object" && A !== null && "then" in A && typeof A.then === "function"
  };
  Z99.isThenable = ZT3
})
// @from(Start 13277565, End 13278182)
X99 = z((J99) => {
  Object.defineProperty(J99, "__esModule", {
    value: !0
  });
  J99.createTaskGroup = void 0;
  var IT3 = Y99(),
    YT3 = function() {
      var A, Q, B = 0;
      return {
        done: function() {
          return A
        },
        run: function(G) {
          var Z = G();
          if ((0, IT3.isThenable)(Z)) {
            if (++B === 1) A = new Promise(function(I) {
              return Q = I
            });
            Z.finally(function() {
              return --B === 0 && Q()
            })
          }
          return Z
        }
      }
    };
  J99.createTaskGroup = YT3
})
// @from(Start 13278188, End 13279884)
UW0 = z((K99) => {
  Object.defineProperty(K99, "__esModule", {
    value: !0
  });
  K99.ensure = K99.attempt = void 0;
  var V99 = oP(),
    zW0 = AI1();

  function JT3(A) {
    return V99.__awaiter(this, void 0, void 0, function() {
      var Q;
      return V99.__generator(this, function(B) {
        switch (B.label) {
          case 0:
            return B.trys.push([0, 2, , 3]), [4, A()];
          case 1:
            return [2, B.sent()];
          case 2:
            return Q = B.sent(), [2, Promise.reject(Q)];
          case 3:
            return [2]
        }
      })
    })
  }

  function F99(A, Q) {
    A.log("debug", "plugin", {
      plugin: Q.name
    });
    var B = new Date().getTime(),
      G = Q[A.event.type];
    if (G === void 0) return Promise.resolve(A);
    var Z = JT3(function() {
      return G.apply(Q, [A])
    }).then(function(I) {
      var Y = new Date().getTime() - B;
      return I.stats.gauge("plugin_time", Y, ["plugin:".concat(Q.name)]), I
    }).catch(function(I) {
      if (I instanceof zW0.ContextCancelation && I.type === "middleware_cancellation") throw I;
      if (I instanceof zW0.ContextCancelation) return A.log("warn", I.type, {
        plugin: Q.name,
        error: I
      }), I;
      return A.log("error", "plugin Error", {
        plugin: Q.name,
        error: I
      }), A.stats.increment("plugin_error", 1, ["plugin:".concat(Q.name)]), I
    });
    return Z
  }
  K99.attempt = F99;

  function WT3(A, Q) {
    return F99(A, Q).then(function(B) {
      if (B instanceof zW0.CoreContext) return B;
      A.log("debug", "Context canceled"), A.stats.increment("context_canceled"), A.cancel(B)
    })
  }
  K99.ensure = WT3
})
// @from(Start 13279890, End 13289421)
E99 = z((H99) => {
  Object.defineProperty(H99, "__esModule", {
    value: !0
  });
  H99.CoreEventQueue = void 0;
  var tD = oP(),
    VT3 = G99(),
    FT3 = KW0(),
    $W0 = AI1(),
    KT3 = nXA(),
    DT3 = X99(),
    QI1 = UW0(),
    HT3 = function(A) {
      tD.__extends(Q, A);

      function Q(B) {
        var G = A.call(this) || this;
        return G.criticalTasks = (0, DT3.createTaskGroup)(), G.plugins = [], G.failedInitializations = [], G.flushing = !1, G.queue = B, G.queue.on(FT3.ON_REMOVE_FROM_FUTURE, function() {
          G.scheduleFlush(0)
        }), G
      }
      return Q.prototype.register = function(B, G, Z) {
        return tD.__awaiter(this, void 0, void 0, function() {
          var I = this;
          return tD.__generator(this, function(Y) {
            switch (Y.label) {
              case 0:
                return [4, Promise.resolve(G.load(B, Z)).then(function() {
                  I.plugins.push(G)
                }).catch(function(J) {
                  if (G.type === "destination") {
                    I.failedInitializations.push(G.name), console.warn(G.name, J), B.log("warn", "Failed to load destination", {
                      plugin: G.name,
                      error: J
                    });
                    return
                  }
                  throw J
                })];
              case 1:
                return Y.sent(), [2]
            }
          })
        })
      }, Q.prototype.deregister = function(B, G, Z) {
        return tD.__awaiter(this, void 0, void 0, function() {
          var I;
          return tD.__generator(this, function(Y) {
            switch (Y.label) {
              case 0:
                if (Y.trys.push([0, 3, , 4]), !G.unload) return [3, 2];
                return [4, Promise.resolve(G.unload(B, Z))];
              case 1:
                Y.sent(), Y.label = 2;
              case 2:
                return this.plugins = this.plugins.filter(function(J) {
                  return J.name !== G.name
                }), [3, 4];
              case 3:
                return I = Y.sent(), B.log("warn", "Failed to unload destination", {
                  plugin: G.name,
                  error: I
                }), [3, 4];
              case 4:
                return [2]
            }
          })
        })
      }, Q.prototype.dispatch = function(B) {
        return tD.__awaiter(this, void 0, void 0, function() {
          var G;
          return tD.__generator(this, function(Z) {
            return B.log("debug", "Dispatching"), B.stats.increment("message_dispatched"), this.queue.push(B), G = this.subscribeToDelivery(B), this.scheduleFlush(0), [2, G]
          })
        })
      }, Q.prototype.subscribeToDelivery = function(B) {
        return tD.__awaiter(this, void 0, void 0, function() {
          var G = this;
          return tD.__generator(this, function(Z) {
            return [2, new Promise(function(I) {
              var Y = function(J, W) {
                if (J.isSame(B))
                  if (G.off("flush", Y), W) I(J);
                  else I(J)
              };
              G.on("flush", Y)
            })]
          })
        })
      }, Q.prototype.dispatchSingle = function(B) {
        return tD.__awaiter(this, void 0, void 0, function() {
          var G = this;
          return tD.__generator(this, function(Z) {
            return B.log("debug", "Dispatching"), B.stats.increment("message_dispatched"), this.queue.updateAttempts(B), B.attempts = 1, [2, this.deliver(B).catch(function(I) {
              var Y = G.enqueuRetry(I, B);
              if (!Y) return B.setFailedDelivery({
                reason: I
              }), B;
              return G.subscribeToDelivery(B)
            })]
          })
        })
      }, Q.prototype.isEmpty = function() {
        return this.queue.length === 0
      }, Q.prototype.scheduleFlush = function(B) {
        var G = this;
        if (B === void 0) B = 500;
        if (this.flushing) return;
        this.flushing = !0, setTimeout(function() {
          G.flush().then(function() {
            setTimeout(function() {
              if (G.flushing = !1, G.queue.length) G.scheduleFlush(0)
            }, 0)
          })
        }, B)
      }, Q.prototype.deliver = function(B) {
        return tD.__awaiter(this, void 0, void 0, function() {
          var G, Z, I, Y;
          return tD.__generator(this, function(J) {
            switch (J.label) {
              case 0:
                return [4, this.criticalTasks.done()];
              case 1:
                J.sent(), G = Date.now(), J.label = 2;
              case 2:
                return J.trys.push([2, 4, , 5]), [4, this.flushOne(B)];
              case 3:
                return B = J.sent(), Z = Date.now() - G, this.emit("delivery_success", B), B.stats.gauge("delivered", Z), B.log("debug", "Delivered", B.event), [2, B];
              case 4:
                throw I = J.sent(), Y = I, B.log("error", "Failed to deliver", Y), this.emit("delivery_failure", B, Y), B.stats.increment("delivery_failed"), I;
              case 5:
                return [2]
            }
          })
        })
      }, Q.prototype.enqueuRetry = function(B, G) {
        var Z = !(B instanceof $W0.ContextCancelation) || B.retry;
        if (!Z) return !1;
        return this.queue.pushWithBackoff(G)
      }, Q.prototype.flush = function() {
        return tD.__awaiter(this, void 0, void 0, function() {
          var B, G, Z;
          return tD.__generator(this, function(I) {
            switch (I.label) {
              case 0:
                if (this.queue.length === 0) return [2, []];
                if (B = this.queue.pop(), !B) return [2, []];
                B.attempts = this.queue.getAttempts(B), I.label = 1;
              case 1:
                return I.trys.push([1, 3, , 4]), [4, this.deliver(B)];
              case 2:
                return B = I.sent(), this.emit("flush", B, !0), [3, 4];
              case 3:
                if (G = I.sent(), Z = this.enqueuRetry(G, B), !Z) B.setFailedDelivery({
                  reason: G
                }), this.emit("flush", B, !1);
                return [2, []];
              case 4:
                return [2, [B]]
            }
          })
        })
      }, Q.prototype.isReady = function() {
        return !0
      }, Q.prototype.availableExtensions = function(B) {
        var G = this.plugins.filter(function(D) {
            var H, C, E;
            if (D.type !== "destination" && D.name !== "Segment.io") return !0;
            var U = void 0;
            return (H = D.alternativeNames) === null || H === void 0 || H.forEach(function(q) {
              if (B[q] !== void 0) U = B[q]
            }), (E = (C = B[D.name]) !== null && C !== void 0 ? C : U) !== null && E !== void 0 ? E : (D.name === "Segment.io" ? !0 : B.All) !== !1
          }),
          Z = (0, VT3.groupBy)(G, "type"),
          I = Z.before,
          Y = I === void 0 ? [] : I,
          J = Z.enrichment,
          W = J === void 0 ? [] : J,
          X = Z.destination,
          V = X === void 0 ? [] : X,
          F = Z.after,
          K = F === void 0 ? [] : F;
        return {
          before: Y,
          enrichment: W,
          destinations: V,
          after: K
        }
      }, Q.prototype.flushOne = function(B) {
        var G, Z;
        return tD.__awaiter(this, void 0, void 0, function() {
          var I, Y, J, W, X, V, H, F, K, D, H, C, E, U, q;
          return tD.__generator(this, function(w) {
            switch (w.label) {
              case 0:
                if (!this.isReady()) throw Error("Not ready");
                if (B.attempts > 1) this.emit("delivery_retry", B);
                I = this.availableExtensions((G = B.event.integrations) !== null && G !== void 0 ? G : {}), Y = I.before, J = I.enrichment, W = 0, X = Y, w.label = 1;
              case 1:
                if (!(W < X.length)) return [3, 4];
                return V = X[W], [4, (0, QI1.ensure)(B, V)];
              case 2:
                if (H = w.sent(), H instanceof $W0.CoreContext) B = H;
                this.emit("message_enriched", B, V), w.label = 3;
              case 3:
                return W++, [3, 1];
              case 4:
                F = 0, K = J, w.label = 5;
              case 5:
                if (!(F < K.length)) return [3, 8];
                return D = K[F], [4, (0, QI1.attempt)(B, D)];
              case 6:
                if (H = w.sent(), H instanceof $W0.CoreContext) B = H;
                this.emit("message_enriched", B, D), w.label = 7;
              case 7:
                return F++, [3, 5];
              case 8:
                return C = this.availableExtensions((Z = B.event.integrations) !== null && Z !== void 0 ? Z : {}), E = C.destinations, U = C.after, [4, new Promise(function(N, R) {
                  setTimeout(function() {
                    var T = E.map(function(y) {
                      return (0, QI1.attempt)(B, y)
                    });
                    Promise.all(T).then(N).catch(R)
                  }, 0)
                })];
              case 9:
                return w.sent(), B.stats.increment("message_delivered"), this.emit("message_delivered", B), q = U.map(function(N) {
                  return (0, QI1.attempt)(B, N)
                }), [4, Promise.all(q)];
              case 10:
                return w.sent(), [2, B]
            }
          })
        })
      }, Q
    }(KT3.Emitter);
  H99.CoreEventQueue = HT3
})
// @from(Start 13289427, End 13289512)
U99 = z((z99) => {
  Object.defineProperty(z99, "__esModule", {
    value: !0
  })
})
// @from(Start 13289518, End 13290762)
L99 = z((w99) => {
  Object.defineProperty(w99, "__esModule", {
    value: !0
  });
  w99.dispatch = w99.getDelay = void 0;
  var $99 = oP(),
    CT3 = JW0(),
    ET3 = function(A, Q) {
      var B = Date.now() - A;
      return Math.max((Q !== null && Q !== void 0 ? Q : 300) - B, 0)
    };
  w99.getDelay = ET3;

  function zT3(A, Q, B, G) {
    return $99.__awaiter(this, void 0, void 0, function() {
      var Z, I;
      return $99.__generator(this, function(Y) {
        switch (Y.label) {
          case 0:
            if (B.emit("dispatch_start", A), Z = Date.now(), !Q.isEmpty()) return [3, 2];
            return [4, Q.dispatchSingle(A)];
          case 1:
            return I = Y.sent(), [3, 4];
          case 2:
            return [4, Q.dispatch(A)];
          case 3:
            I = Y.sent(), Y.label = 4;
          case 4:
            if (!(G === null || G === void 0 ? void 0 : G.callback)) return [3, 6];
            return [4, (0, CT3.invokeCallback)(I, G.callback, w99.getDelay(Z, G.timeout))];
          case 5:
            I = Y.sent(), Y.label = 6;
          case 6:
            if (G === null || G === void 0 ? void 0 : G.debug) I.flush();
            return [2, I]
        }
      })
    })
  }
  w99.dispatch = zT3
})
// @from(Start 13290768, End 13291263)
R99 = z((M99) => {
  Object.defineProperty(M99, "__esModule", {
    value: !0
  });
  M99.bindAll = void 0;

  function UT3(A) {
    var Q = A.constructor.prototype;
    for (var B = 0, G = Object.getOwnPropertyNames(Q); B < G.length; B++) {
      var Z = G[B];
      if (Z !== "constructor") {
        var I = Object.getOwnPropertyDescriptor(A.constructor.prototype, Z);
        if (!!I && typeof I.value === "function") A[Z] = A[Z].bind(A)
      }
    }
    return A
  }
  M99.bindAll = UT3
})
// @from(Start 13291269, End 13292171)
Va = z((JV) => {
  Object.defineProperty(JV, "__esModule", {
    value: !0
  });
  JV.CoreLogger = JV.backoff = void 0;
  var qC = oP();
  qC.__exportStar(_B9(), JV);
  qC.__exportStar(yB9(), JV);
  qC.__exportStar(eJ0(), JV);
  qC.__exportStar(eB9(), JV);
  qC.__exportStar(JW0(), JV);
  qC.__exportStar(KW0(), JV);
  var $T3 = FW0();
  Object.defineProperty(JV, "backoff", {
    enumerable: !0,
    get: function() {
      return $T3.backoff
    }
  });
  qC.__exportStar(AI1(), JV);
  qC.__exportStar(E99(), JV);
  qC.__exportStar(U99(), JV);
  qC.__exportStar(L99(), JV);
  qC.__exportStar(BW0(), JV);
  qC.__exportStar(QW0(), JV);
  qC.__exportStar(IW0(), JV);
  qC.__exportStar(R99(), JV);
  qC.__exportStar(EW0(), JV);
  var wT3 = HW0();
  Object.defineProperty(JV, "CoreLogger", {
    enumerable: !0,
    get: function() {
      return wT3.CoreLogger
    }
  });
  qC.__exportStar(UW0(), JV)
})
// @from(Start 13292177, End 13292458)
j99 = z((T99) => {
  Object.defineProperty(T99, "__esModule", {
    value: !0
  });
  T99.validateSettings = void 0;
  var NT3 = Va(),
    LT3 = (A) => {
      if (!A.writeKey) throw new NT3.ValidationError("writeKey", "writeKey is missing.")
    };
  T99.validateSettings = LT3
})
// @from(Start 13292464, End 13292598)
wW0 = z((S99) => {
  Object.defineProperty(S99, "__esModule", {
    value: !0
  });
  S99.version = void 0;
  S99.version = "1.3.0"
})
// @from(Start 13292604, End 13292875)
x99 = z((k99) => {
  Object.defineProperty(k99, "__esModule", {
    value: !0
  });
  k99.tryCreateFormattedUrl = void 0;
  var MT3 = (A) => A.replace(/\/$/, ""),
    OT3 = (A, Q) => {
      return MT3(new URL(Q || "", A).href)
    };
  k99.tryCreateFormattedUrl = OT3
})
// @from(Start 13292881, End 13293119)
NW0 = z((qW0) => {
  Object.defineProperty(qW0, "__esModule", {
    value: !0
  });
  qW0.uuid = void 0;
  var RT3 = DW0();
  Object.defineProperty(qW0, "uuid", {
    enumerable: !0,
    get: function() {
      return RT3.v4
    }
  })
})
// @from(Start 13293125, End 13294496)
u99 = z((h99) => {
  Object.defineProperty(h99, "__esModule", {
    value: !0
  });
  h99.ContextBatch = void 0;
  var PT3 = NW0(),
    v99 = 32,
    b99 = 480;
  class f99 {
    constructor(A) {
      this.id = (0, PT3.uuid)(), this.items = [], this.sizeInBytes = 0, this.maxEventCount = Math.max(1, A)
    }
    tryAdd(A) {
      if (this.length === this.maxEventCount) return {
        success: !1,
        message: `Event limit of ${this.maxEventCount} has been exceeded.`
      };
      let Q = this.calculateSize(A.context);
      if (Q > v99 * 1024) return {
        success: !1,
        message: `Event exceeds maximum event size of ${v99} KB`
      };
      if (this.sizeInBytes + Q > b99 * 1024) return {
        success: !1,
        message: `Event has caused batch size to exceed ${b99} KB`
      };
      return this.items.push(A), this.sizeInBytes += Q, {
        success: !0
      }
    }
    get length() {
      return this.items.length
    }
    calculateSize(A) {
      return encodeURI(JSON.stringify(A.event)).split(/%..|i/).length
    }
    getEvents() {
      return this.items.map(({
        context: Q
      }) => Q.event)
    }
    getContexts() {
      return this.items.map((A) => A.context)
    }
    resolveEvents() {
      this.items.forEach(({
        resolver: A,
        context: Q
      }) => A(Q))
    }
  }
  h99.ContextBatch = f99
})
// @from(Start 13294502, End 13294739)
c99 = z((m99) => {
  Object.defineProperty(m99, "__esModule", {
    value: !0
  });
  m99.b64encode = void 0;
  var jT3 = UA("buffer"),
    ST3 = (A) => {
      return jT3.Buffer.from(A).toString("base64")
    };
  m99.b64encode = ST3
})
// @from(Start 13294745, End 13298762)
a99 = z((i99) => {
  Object.defineProperty(i99, "__esModule", {
    value: !0
  });
  i99.Publisher = void 0;
  var _T3 = Va(),
    kT3 = x99(),
    yT3 = nXA(),
    xT3 = u99(),
    vT3 = c99();

  function bT3(A) {
    return new Promise((Q) => setTimeout(Q, A))
  }

  function VjA() {}
  class l99 {
    constructor({
      host: A,
      path: Q,
      maxRetries: B,
      flushAt: G,
      flushInterval: Z,
      writeKey: I,
      httpRequestTimeout: Y,
      httpClient: J,
      disable: W
    }, X) {
      this._emitter = X, this._maxRetries = B, this._flushAt = Math.max(G, 1), this._flushInterval = Z, this._auth = (0, vT3.b64encode)(`${I}:`), this._url = (0, kT3.tryCreateFormattedUrl)(A ?? "https://api.segment.io", Q ?? "/v1/batch"), this._httpRequestTimeout = Y ?? 1e4, this._disable = Boolean(W), this._httpClient = J
    }
    createBatch() {
      this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout);
      let A = new xT3.ContextBatch(this._flushAt);
      return this._batch = A, this.pendingFlushTimeout = setTimeout(() => {
        if (A === this._batch) this._batch = void 0;
        if (this.pendingFlushTimeout = void 0, A.length) this.send(A).catch(VjA)
      }, this._flushInterval), A
    }
    clearBatch() {
      this.pendingFlushTimeout && clearTimeout(this.pendingFlushTimeout), this._batch = void 0
    }
    flush(A) {
      if (!A) return;
      if (this._flushPendingItemsCount = A, !this._batch) return;
      if (this._batch.length === A) this.send(this._batch).catch(VjA), this.clearBatch()
    }
    enqueue(A) {
      let Q = this._batch ?? this.createBatch(),
        {
          promise: B,
          resolve: G
        } = (0, yT3.createDeferred)(),
        Z = {
          context: A,
          resolver: G
        };
      if (Q.tryAdd(Z).success) {
        let W = Q.length === this._flushPendingItemsCount;
        if (Q.length === this._flushAt || W) this.send(Q).catch(VjA), this.clearBatch();
        return B
      }
      if (Q.length) this.send(Q).catch(VjA), this.clearBatch();
      let Y = this.createBatch(),
        J = Y.tryAdd(Z);
      if (J.success) {
        if (Y.length === this._flushPendingItemsCount) this.send(Y).catch(VjA), this.clearBatch();
        return B
      } else return A.setFailedDelivery({
        reason: Error(J.message)
      }), Promise.resolve(A)
    }
    async send(A) {
      if (this._flushPendingItemsCount) this._flushPendingItemsCount -= A.length;
      let Q = A.getEvents(),
        B = this._maxRetries + 1,
        G = 0;
      while (G < B) {
        G++;
        let Z;
        try {
          if (this._disable) return A.resolveEvents();
          let I = {
            url: this._url,
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Basic ${this._auth}`,
              "User-Agent": "analytics-node-next/latest"
            },
            data: {
              batch: Q,
              sentAt: new Date
            },
            httpRequestTimeout: this._httpRequestTimeout
          };
          this._emitter.emit("http_request", {
            body: I.data,
            method: I.method,
            url: I.url,
            headers: I.headers
          });
          let Y = await this._httpClient.makeRequest(I);
          if (Y.status >= 200 && Y.status < 300) {
            A.resolveEvents();
            return
          } else if (Y.status === 400) {
            p99(A, Error(`[${Y.status}] ${Y.statusText}`));
            return
          } else Z = Error(`[${Y.status}] ${Y.statusText}`)
        } catch (I) {
          Z = I
        }
        if (G === B) {
          p99(A, Z);
          return
        }
        await bT3((0, _T3.backoff)({
          attempt: G,
          minTimeout: 25,
          maxTimeout: 1000
        }))
      }
    }
  }
  i99.Publisher = l99;

  function p99(A, Q) {
    A.getContexts().forEach((B) => B.setFailedDelivery({
      reason: Q
    })), A.resolveEvents()
  }
})
// @from(Start 13298768, End 13299389)
LW0 = z((s99) => {
  Object.defineProperty(s99, "__esModule", {
    value: !0
  });
  s99.detectRuntime = void 0;
  var fT3 = () => {
    if (typeof process === "object" && process && typeof process.env === "object" && process.env && typeof process.version === "string") return "node";
    if (typeof window === "object") return "browser";
    if (typeof WebSocketPair < "u") return "cloudflare-worker";
    if (typeof EdgeRuntime === "string") return "vercel-edge";
    if (typeof WorkerGlobalScope < "u" && typeof importScripts === "function") return "web-worker";
    return "unknown"
  };
  s99.detectRuntime = fT3
})
// @from(Start 13299395, End 13300448)
A49 = z((t99) => {
  Object.defineProperty(t99, "__esModule", {
    value: !0
  });
  t99.createConfiguredNodePlugin = t99.createNodePlugin = void 0;
  var hT3 = a99(),
    gT3 = wW0(),
    uT3 = LW0();

  function mT3(A) {
    A.updateEvent("context.library.name", "@segment/analytics-node"), A.updateEvent("context.library.version", gT3.version);
    let Q = (0, uT3.detectRuntime)();
    if (Q === "node") A.updateEvent("_metadata.nodeVersion", process.version);
    A.updateEvent("_metadata.jsRuntime", Q)
  }

  function o99(A) {
    function Q(B) {
      return mT3(B), A.enqueue(B)
    }
    return {
      name: "Segment.io",
      type: "destination",
      version: "1.0.0",
      isLoaded: () => !0,
      load: () => Promise.resolve(),
      alias: Q,
      group: Q,
      identify: Q,
      page: Q,
      screen: Q,
      track: Q
    }
  }
  t99.createNodePlugin = o99;
  var dT3 = (A, Q) => {
    let B = new hT3.Publisher(A, Q);
    return {
      publisher: B,
      plugin: o99(B)
    }
  };
  t99.createConfiguredNodePlugin = dT3
})
// @from(Start 13300454, End 13300701)
G49 = z((Q49) => {
  Object.defineProperty(Q49, "__esModule", {
    value: !0
  });
  Q49.createMessageId = void 0;
  var pT3 = NW0(),
    lT3 = () => {
      return `node-next-${Date.now()}-${(0,pT3.uuid)()}`
    };
  Q49.createMessageId = lT3
})
// @from(Start 13300707, End 13301027)
J49 = z((I49) => {
  Object.defineProperty(I49, "__esModule", {
    value: !0
  });
  I49.NodeEventFactory = void 0;
  var iT3 = Va(),
    nT3 = G49();
  class Z49 extends iT3.EventFactory {
    constructor() {
      super({
        createMessageId: nT3.createMessageId
      })
    }
  }
  I49.NodeEventFactory = Z49
})
// @from(Start 13301033, End 13301331)
BI1 = z((X49) => {
  Object.defineProperty(X49, "__esModule", {
    value: !0
  });
  X49.Context = void 0;
  var aT3 = Va();
  class W49 extends aT3.CoreContext {
    static system() {
      return new this({
        type: "track",
        event: "system"
      })
    }
  }
  X49.Context = W49
})
// @from(Start 13301337, End 13302158)
D49 = z((F49) => {
  Object.defineProperty(F49, "__esModule", {
    value: !0
  });
  F49.dispatchAndEmit = void 0;
  var sT3 = Va(),
    rT3 = BI1(),
    oT3 = (A) => (Q) => {
      let B = Q.failedDelivery();
      return B ? A(B.reason, Q) : A(void 0, Q)
    },
    tT3 = async (A, Q, B, G) => {
      try {
        let Z = new rT3.Context(A),
          I = await (0, sT3.dispatch)(Z, Q, B, {
            ...G ? {
              callback: oT3(G)
            } : {}
          }),
          Y = I.failedDelivery();
        if (Y) B.emit("error", {
          code: "delivery_failure",
          reason: Y.reason,
          ctx: I
        });
        else B.emit(A.type, I)
      } catch (Z) {
        B.emit("error", {
          code: "unknown",
          reason: Z
        })
      }
    };
  F49.dispatchAndEmit = tT3
})
// @from(Start 13302164, End 13302356)
z49 = z((C49) => {
  Object.defineProperty(C49, "__esModule", {
    value: !0
  });
  C49.NodeEmitter = void 0;
  var eT3 = nXA();
  class H49 extends eT3.Emitter {}
  C49.NodeEmitter = H49
})
// @from(Start 13302362, End 13302862)
L49 = z((q49) => {
  Object.defineProperty(q49, "__esModule", {
    value: !0
  });
  q49.NodeEventQueue = void 0;
  var U49 = Va();
  class $49 extends U49.PriorityQueue {
    constructor() {
      super(1, [])
    }
    getAttempts(A) {
      return A.attempts ?? 0
    }
    updateAttempts(A) {
      return A.attempts = this.getAttempts(A) + 1, this.getAttempts(A)
    }
  }
  class w49 extends U49.CoreEventQueue {
    constructor() {
      super(new $49)
    }
  }
  q49.NodeEventQueue = w49
})
// @from(Start 13302868, End 13304283)
T49 = z((O49) => {
  Object.defineProperty(O49, "__esModule", {
    value: !0
  });
  O49.abortSignalAfterTimeout = O49.AbortSignal = void 0;
  var AP3 = nXA(),
    QP3 = LW0();
  class MW0 {
    constructor() {
      this.onabort = null, this.aborted = !1, this.eventEmitter = new AP3.Emitter
    }
    toString() {
      return "[object AbortSignal]"
    }
    get[Symbol.toStringTag]() {
      return "AbortSignal"
    }
    removeEventListener(...A) {
      this.eventEmitter.off(...A)
    }
    addEventListener(...A) {
      this.eventEmitter.on(...A)
    }
    dispatchEvent(A) {
      let Q = {
          type: A,
          target: this
        },
        B = `on${A}`;
      if (typeof this[B] === "function") this[B](Q);
      this.eventEmitter.emit(A, Q)
    }
  }
  O49.AbortSignal = MW0;
  class M49 {
    constructor() {
      this.signal = new MW0
    }
    abort() {
      if (this.signal.aborted) return;
      this.signal.aborted = !0, this.signal.dispatchEvent("abort")
    }
    toString() {
      return "[object AbortController]"
    }
    get[Symbol.toStringTag]() {
      return "AbortController"
    }
  }
  var BP3 = (A) => {
    if ((0, QP3.detectRuntime)() === "cloudflare-worker") return [];
    let Q = new(globalThis.AbortController || M49),
      B = setTimeout(() => {
        Q.abort()
      }, A);
    return B?.unref?.(), [Q.signal, B]
  };
  O49.abortSignalAfterTimeout = BP3
})
// @from(Start 13304289, End 13305686)
P49 = z((Ix) => {
  var ZP3 = Ix && Ix.__createBinding || (Object.create ? function(A, Q, B, G) {
      if (G === void 0) G = B;
      var Z = Object.getOwnPropertyDescriptor(Q, B);
      if (!Z || ("get" in Z ? !Q.__esModule : Z.writable || Z.configurable)) Z = {
        enumerable: !0,
        get: function() {
          return Q[B]
        }
      };
      Object.defineProperty(A, G, Z)
    } : function(A, Q, B, G) {
      if (G === void 0) G = B;
      A[G] = Q[B]
    }),
    IP3 = Ix && Ix.__setModuleDefault || (Object.create ? function(A, Q) {
      Object.defineProperty(A, "default", {
        enumerable: !0,
        value: Q
      })
    } : function(A, Q) {
      A.default = Q
    }),
    YP3 = Ix && Ix.__importStar || function(A) {
      if (A && A.__esModule) return A;
      var Q = {};
      if (A != null) {
        for (var B in A)
          if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B)) ZP3(Q, A, B)
      }
      return IP3(Q, A), Q
    };
  Object.defineProperty(Ix, "__esModule", {
    value: !0
  });
  Ix.fetch = void 0;
  var JP3 = async (...A) => {
    if (globalThis.fetch) return globalThis.fetch(...A);
    else if (typeof EdgeRuntime !== "string") return (await Promise.resolve().then(() => YP3(Yl1()))).default(...A);
    else throw Error("Invariant: an edge runtime that does not support fetch should not exist")
  };
  Ix.fetch = JP3
})
// @from(Start 13305692, End 13306273)
OW0 = z((S49) => {
  Object.defineProperty(S49, "__esModule", {
    value: !0
  });
  S49.FetchHTTPClient = void 0;
  var WP3 = T49(),
    XP3 = P49();
  class j49 {
    constructor(A) {
      this._fetch = A ?? XP3.fetch
    }
    async makeRequest(A) {
      let [Q, B] = (0, WP3.abortSignalAfterTimeout)(A.httpRequestTimeout), G = {
        url: A.url,
        method: A.method,
        headers: A.headers,
        body: JSON.stringify(A.data),
        signal: Q
      };
      return this._fetch(A.url, G).finally(() => clearTimeout(B))
    }
  }
  S49.FetchHTTPClient = j49
})
// @from(Start 13306279, End 13311570)
RW0 = z((b49) => {
  Object.defineProperty(b49, "__esModule", {
    value: !0
  });
  b49.Analytics = void 0;
  var k49 = Va(),
    VP3 = j99(),
    FP3 = wW0(),
    KP3 = A49(),
    DP3 = J49(),
    HP3 = D49(),
    CP3 = z49(),
    y49 = BI1(),
    EP3 = L49(),
    x49 = OW0();
  class v49 extends CP3.NodeEmitter {
    constructor(A) {
      super();
      this._isClosed = !1, this._pendingEvents = 0, this._isFlushing = !1, (0, VP3.validateSettings)(A), this._eventFactory = new DP3.NodeEventFactory, this._queue = new EP3.NodeEventQueue;
      let Q = A.flushInterval ?? 1e4;
      this._closeAndFlushDefaultTimeout = Q * 1.25;
      let {
        plugin: B,
        publisher: G
      } = (0, KP3.createConfiguredNodePlugin)({
        writeKey: A.writeKey,
        host: A.host,
        path: A.path,
        maxRetries: A.maxRetries ?? 3,
        flushAt: A.flushAt ?? A.maxEventsInBatch ?? 15,
        httpRequestTimeout: A.httpRequestTimeout,
        disable: A.disable,
        flushInterval: Q,
        httpClient: typeof A.httpClient === "function" ? new x49.FetchHTTPClient(A.httpClient) : A.httpClient ?? new x49.FetchHTTPClient
      }, this);
      this._publisher = G, this.ready = this.register(B).then(() => {
        return
      }), this.emit("initialize", A), (0, k49.bindAll)(this)
    }
    get VERSION() {
      return FP3.version
    }
    closeAndFlush({
      timeout: A = this._closeAndFlushDefaultTimeout
    } = {}) {
      return this.flush({
        timeout: A,
        close: !0
      })
    }
    async flush({
      timeout: A,
      close: Q = !1
    } = {}) {
      if (this._isFlushing) {
        console.warn("Overlapping flush calls detected. Please wait for the previous flush to finish before calling .flush again");
        return
      } else this._isFlushing = !0;
      if (Q) this._isClosed = !0;
      this._publisher.flush(this._pendingEvents);
      let B = new Promise((G) => {
        if (!this._pendingEvents) G();
        else this.once("drained", () => {
          G()
        })
      }).finally(() => {
        this._isFlushing = !1
      });
      return A ? (0, k49.pTimeout)(B, A).catch(() => {
        return
      }) : B
    }
    _dispatch(A, Q) {
      if (this._isClosed) {
        this.emit("call_after_close", A);
        return
      }
      this._pendingEvents++, (0, HP3.dispatchAndEmit)(A, this._queue, this, Q).catch((B) => B).finally(() => {
        if (this._pendingEvents--, !this._pendingEvents) this.emit("drained")
      })
    }
    alias({
      userId: A,
      previousId: Q,
      context: B,
      timestamp: G,
      integrations: Z
    }, I) {
      let Y = this._eventFactory.alias(A, Q, {
        context: B,
        integrations: Z,
        timestamp: G
      });
      this._dispatch(Y, I)
    }
    group({
      timestamp: A,
      groupId: Q,
      userId: B,
      anonymousId: G,
      traits: Z = {},
      context: I,
      integrations: Y
    }, J) {
      let W = this._eventFactory.group(Q, Z, {
        context: I,
        anonymousId: G,
        userId: B,
        timestamp: A,
        integrations: Y
      });
      this._dispatch(W, J)
    }
    identify({
      userId: A,
      anonymousId: Q,
      traits: B = {},
      context: G,
      timestamp: Z,
      integrations: I
    }, Y) {
      let J = this._eventFactory.identify(A, B, {
        context: G,
        anonymousId: Q,
        userId: A,
        timestamp: Z,
        integrations: I
      });
      this._dispatch(J, Y)
    }
    page({
      userId: A,
      anonymousId: Q,
      category: B,
      name: G,
      properties: Z,
      context: I,
      timestamp: Y,
      integrations: J
    }, W) {
      let X = this._eventFactory.page(B ?? null, G ?? null, Z, {
        context: I,
        anonymousId: Q,
        userId: A,
        timestamp: Y,
        integrations: J
      });
      this._dispatch(X, W)
    }
    screen({
      userId: A,
      anonymousId: Q,
      category: B,
      name: G,
      properties: Z,
      context: I,
      timestamp: Y,
      integrations: J
    }, W) {
      let X = this._eventFactory.screen(B ?? null, G ?? null, Z, {
        context: I,
        anonymousId: Q,
        userId: A,
        timestamp: Y,
        integrations: J
      });
      this._dispatch(X, W)
    }
    track({
      userId: A,
      anonymousId: Q,
      event: B,
      properties: G,
      context: Z,
      timestamp: I,
      integrations: Y
    }, J) {
      let W = this._eventFactory.track(B, G, {
        context: Z,
        userId: A,
        anonymousId: Q,
        timestamp: I,
        integrations: Y
      });
      this._dispatch(W, J)
    }
    register(...A) {
      return this._queue.criticalTasks.run(async () => {
        let Q = y49.Context.system(),
          B = A.map((G) => this._queue.register(Q, G, this));
        await Promise.all(B), this.emit("register", A.map((G) => G.name))
      })
    }
    async deregister(...A) {
      let Q = y49.Context.system(),
        B = A.map((G) => {
          let Z = this._queue.plugins.find((I) => I.name === G);
          if (Z) return this._queue.deregister(Q, Z, this);
          else Q.log("warn", `plugin ${G} not found`)
        });
      await Promise.all(B), this.emit("deregister", A)
    }
  }
  b49.Analytics = v49
})
// @from(Start 13311576, End 13312213)
h49 = z((FjA) => {
  Object.defineProperty(FjA, "__esModule", {
    value: !0
  });
  FjA.FetchHTTPClient = FjA.Context = FjA.Analytics = void 0;
  var zP3 = RW0();
  Object.defineProperty(FjA, "Analytics", {
    enumerable: !0,
    get: function() {
      return zP3.Analytics
    }
  });
  var UP3 = BI1();
  Object.defineProperty(FjA, "Context", {
    enumerable: !0,
    get: function() {
      return UP3.Context
    }
  });
  var $P3 = OW0();
  Object.defineProperty(FjA, "FetchHTTPClient", {
    enumerable: !0,
    get: function() {
      return $P3.FetchHTTPClient
    }
  });
  var wP3 = RW0();
  FjA.default = wP3.Analytics
})
// @from(Start 13312216, End 13312331)
function MP3() {
  let A = ["test", "dev"].includes("production") ? "development" : "production";
  return LP3[A]
}
// @from(Start 13312332, End 13312391)
async function OP3() {
  if (fX()) return !1;
  return !0
}
// @from(Start 13312392, End 13312816)
async function TW0(A, Q) {
  let B = await u49();
  if (!B) return;
  try {
    let G = iv1(),
      Z = t6(),
      I = await lc({
        model: Q.model
      }),
      Y = LCB(I, Q),
      J = {
        anonymousId: G,
        event: A,
        properties: Y
      };
    if (Z) {
      let W = vc(!0);
      J.userId = W.userID
    }
    B.track(J)
  } catch (G) {
    AA(G instanceof Error ? G : Error(String(G)))
  }
}
// @from(Start 13312817, End 13313144)
async function m49(A) {
  let Q = await u49();
  if (!Q) return;
  try {
    let B = iv1(),
      G = t6(),
      Z = {
        anonymousId: B,
        traits: A
      };
    if (G) {
      let I = vc(!0);
      Z.userId = I.userID
    }
    Q.identify(Z)
  } catch (B) {
    AA(B instanceof Error ? B : Error(String(B)))
  }
}
// @from(Start 13313149, End 13313152)
g49
// @from(Start 13313154, End 13313157)
LP3
// @from(Start 13313159, End 13313169)
GI1 = null
// @from(Start 13313173, End 13313176)
u49
// @from(Start 13313182, End 13313787)
PW0 = L(() => {
  l2();
  gb();
  jQ();
  g1();
  gB();
  B7A();
  Ft();
  g49 = BA(h49(), 1), LP3 = {
    production: "LKJN8LsLERHEOXkw487o7qCTFOrGPimI",
    development: "b64sf1kxwDGe1PiSAlv5ixuH0f509RKK"
  };
  u49 = s1(async () => {
    if (!await OP3()) return null;
    try {
      return GI1 = new g49.Analytics({
        writeKey: MP3()
      }), process.on("beforeExit", async () => {
        await GI1?.closeAndFlush()
      }), process.on("exit", () => {
        GI1?.closeAndFlush()
      }), GI1
    } catch (Q) {
      return AA(Q instanceof Error ? Q : Error(String(Q))), null
    }
  })
})
// @from(Start 13313790, End 13313962)
function RP3() {
  let A = t6();
  if (!A) return {};
  return {
    email: A.emailAddress,
    account_uuid: A.accountUuid,
    organization_uuid: A.organizationUuid
  }
}
// @from(Start 13313964, End 13314458)
function KjA(A) {
  let Q = Ja(),
    B = EQ(() => A.onDone(!1, Q));
  return f1((G, Z) => {
    if (Z.escape) A.onDone(!1, Q)
  }), NC.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, NC.createElement(Vn, {
    onDone: () => A.onDone(!0, Q),
    startingMessage: A.startingMessage
  }), NC.createElement(S, {
    marginLeft: 1
  }, NC.createElement($, {
    dimColor: !0
  }, B.pending ? NC.createElement(NC.Fragment, null, "Press ", B.keyName, " again to exit") : "")))
}
// @from(Start 13314463, End 13314465)
NC
// @from(Start 13314467, End 13314950)
d49 = () => ({
  type: "local-jsx",
  name: "login",
  description: g4B() ? "Switch Anthropic accounts" : "Sign in with your Anthropic account",
  isEnabled: () => !process.env.DISABLE_LOGIN_COMMAND,
  isHidden: !1,
  async call(A, Q) {
    return NC.createElement(KjA, {
      onDone: async (B) => {
        if (Q.onChangeAPIKey(), B) OX1(), St(), m49(RP3());
        A(B ? "Login successful" : "Login interrupted")
      }
    })
  },
  userFacingName() {
    return "login"
  }
})
// @from(Start 13314956, End 13315068)
ZI1 = L(() => {
  SRA();
  Q4();
  hA();
  gB();
  ePA();
  u2();
  _0();
  PW0();
  gB();
  NC = BA(VA(), 1)
})
// @from(Start 13315074, End 13315077)
c49
// @from(Start 13315079, End 13315082)
TP3
// @from(Start 13315084, End 13315086)
Yx
// @from(Start 13315092, End 13316091)
DjA = L(() => {
  g1();
  gB();
  gM();
  ZI1();
  c49 = BA(VA(), 1), TP3 = {
    type: "local-jsx",
    name: "extra-usage",
    description: "Access and configure extra usage to keep working when limits are hit",
    isEnabled: () => {
      if (process.env.DISABLE_EXTRA_USAGE_COMMAND) return !1;
      let A = f4();
      return A === "pro" || A === "max"
    },
    isHidden: !1,
    async call(A, Q) {
      try {
        return await cZ("https://claude.ai/settings/usage"), c49.default.createElement(KjA, {
          startingMessage: "Starting new login following /extra-usage. Exit with Ctrl-C to use existing account.",
          onDone: (B) => {
            Q.onChangeAPIKey(), A(B ? "Login successful" : "Login interrupted")
          }
        })
      } catch (B) {
        AA(B), A("Failed to open browser. Please visit https://claude.ai/settings/usage to see your extra usage.")
      }
      return null
    },
    userFacingName() {
      return "extra-usage"
    }
  }, Yx = TP3
})
// @from(Start 13316094, End 13316176)
function jW0() {
  return BZ("claude_code_overages_upgrade_cta", "variant", p49)
}
// @from(Start 13316178, End 13317367)
function l49({
  text: A,
  onOpenRateLimitOptions: Q
}) {
  let B = f4(),
    G = yc(),
    Z = B === "pro" || B === "max",
    I = G === "default_claude_max_20x",
    Y = (y4A() || BB()) && Z,
    J = Y && !I,
    W = J ? jW0() : p49,
    [X, V] = L$.useState(!1);
  L$.useEffect(() => {
    if (J && W === "interactive_menu" && !X && Q) V(!0), Q()
  }, [J, W, X, Q]);
  let F = L$.useMemo(() => {
    if (!Y) return null;
    let K = Yx.isEnabled();
    if (I && K) return L$.default.createElement($, {
      dimColor: !0
    }, "/extra-usage to finish what you're working on.");
    if (W === "interactive_menu" && Q) return L$.default.createElement($, {
      dimColor: !0
    }, "Opening your options…");
    if (W === "control" || !K) return L$.default.createElement($, {
      dimColor: !0
    }, "/upgrade to increase your usage limit.");
    return L$.default.createElement($, {
      dimColor: !0
    }, "/upgrade or /extra-usage to finish what you're working on.")
  }, [Y, I, W, Q]);
  if (X) return null;
  return L$.default.createElement(S0, null, L$.default.createElement(S, {
    flexDirection: "column"
  }, L$.default.createElement($, {
    color: "error"
  }, A), F))
}
// @from(Start 13317372, End 13317374)
L$
// @from(Start 13317376, End 13317391)
p49 = "control"
// @from(Start 13317397, End 13317484)
SW0 = L(() => {
  gB();
  mMA();
  u2();
  hA();
  q8();
  DjA();
  L$ = BA(VA(), 1)
})
// @from(Start 13317487, End 13317803)
function PP3() {
  let A = wo0();
  return g3.default.createElement(S0, null, g3.default.createElement(S, {
    flexDirection: "column"
  }, g3.default.createElement($, {
    color: "error"
  }, N91), A && g3.default.createElement($, {
    dimColor: !0
  }, "· Run in another terminal: security unlock-keychain")))
}
// @from(Start 13317805, End 13320615)
function i49({
  param: {
    text: A
  },
  addMargin: Q,
  shouldShowDot: B,
  onOpenRateLimitOptions: G
}) {
  let {
    columns: Z
  } = WB(), [I] = qB();
  if (B31(A)) return null;
  if (OI2(A)) return g3.default.createElement(l49, {
    text: A,
    onOpenRateLimitOptions: G
  });
  switch (A) {
    case S1A:
      return null;
    case OYA: {
      let Y = EQA("warning") ?? "Run /compact to compact & continue";
      return g3.default.createElement(S0, {
        height: 1
      }, g3.default.createElement($, {
        color: "error"
      }, "Context low · ", Y))
    }
    case q91:
      return g3.default.createElement(S0, {
        height: 1
      }, g3.default.createElement($, {
        color: "error"
      }, "Credit balance too low · Add funds: https://console.anthropic.com/settings/billing"));
    case N91:
      return g3.default.createElement(PP3, null);
    case L91:
      return g3.default.createElement(S0, {
        height: 1
      }, g3.default.createElement($, {
        color: "error"
      }, L91));
    case M91:
      return g3.default.createElement(S0, {
        height: 1
      }, g3.default.createElement($, {
        color: "error"
      }, M91));
    case O91:
      return g3.default.createElement(S0, {
        height: 1
      }, g3.default.createElement($, {
        color: "error"
      }, O91, process.env.API_TIMEOUT_MS && g3.default.createElement(g3.default.Fragment, null, " ", "(API_TIMEOUT_MS=", process.env.API_TIMEOUT_MS, "ms, try increasing it)")));
    case j1A:
      return g3.default.createElement(S0, null, g3.default.createElement(S, {
        flexDirection: "column",
        gap: 1
      }, g3.default.createElement($, {
        color: "error"
      }, "We are experiencing high demand for Opus 4."), g3.default.createElement($, null, "To continue immediately, use /model to switch to", " ", nc(XU()), " and continue coding.")));
    case pMA:
      return g3.default.createElement(S0, {
        height: 1
      }, g3.default.createElement(zk, null));
    case _W0:
      return null;
    default:
      if (A.startsWith(uV)) return g3.default.createElement(S0, null, g3.default.createElement($, {
        color: "error"
      }, A === uV ? `${uV}: Please wait a moment and try again.` : A));
      return g3.default.createElement(S, {
        alignItems: "flex-start",
        flexDirection: "row",
        justifyContent: "space-between",
        marginTop: Q ? 1 : 0,
        width: "100%"
      }, g3.default.createElement(S, {
        flexDirection: "row"
      }, B && g3.default.createElement(S, {
        minWidth: 2
      }, g3.default.createElement($, {
        color: "text"
      }, rD)), g3.default.createElement(S, {
        flexDirection: "column",
        width: Z - 6
      }, g3.default.createElement($, null, fD(A, I)))))
  }
}
// @from(Start 13320620, End 13320622)
g3
// @from(Start 13320628, End 13320783)
n49 = L(() => {
  hA();
  ZO();
  cQ();
  dn();
  wh();
  i8();
  q8();
  t2();
  wZ1();
  lMA();
  tZA();
  e00();
  _DA();
  SW0();
  g3 = BA(VA(), 1)
})
// @from(Start 13320786, End 13321357)
function a49({
  addMargin: A,
  param: {
    text: Q
  }
}) {
  let B = B9(Q, "command-message"),
    G = B9(Q, "command-args");
  if (!B) return null;
  g(`UserCommandMessage rendering: "${B}" (args: "${G||"none"}")`);
  let Z = B.startsWith("The "),
    I = Z ? "" : "/";
  return g(`  isSkillFormat: ${Z}, prefix: "${I}"`), HjA.createElement(S, {
    flexDirection: "column",
    marginTop: A ? 1 : 0,
    width: "100%"
  }, HjA.createElement($, {
    backgroundColor: "userMessageBackground",
    color: "text"
  }, "> ", I, [B, G].filter(Boolean).join(" "), " "))
}
// @from(Start 13321362, End 13321365)
HjA
// @from(Start 13321371, End 13321433)
s49 = L(() => {
  hA();
  cQ();
  V0();
  HjA = BA(VA(), 1)
})
// @from(Start 13321436, End 13322317)
function r49({
  text: A,
  thinkingMetadata: Q
}) {
  if (!Q || Q.triggers.length === 0) return tq.createElement($, {
    backgroundColor: "userMessageBackground",
    color: "text"
  }, "> ", A + " ");
  let B = Q.disabled ? void 0 : JrA[Q.level],
    G = nMB(A, Q.triggers);
  return tq.createElement($, null, ">", " ", G.map((Z, I) => {
    if (Z.isTrigger)
      if (WrA(Z.text)) return tq.createElement($, {
        key: I
      }, Z.text.split("").map((J, W) => tq.createElement($, {
        key: W,
        backgroundColor: "userMessageBackground",
        color: O$A(W, !1)
      }, J)));
      else return tq.createElement($, {
        key: I,
        backgroundColor: "userMessageBackground",
        color: B
      }, Z.text);
    return tq.createElement($, {
      key: I,
      backgroundColor: "userMessageBackground",
      color: "text"
    }, Z.text)
  }), " ")
}
// @from(Start 13322322, End 13322324)
tq
// @from(Start 13322330, End 13322383)
o49 = L(() => {
  hA();
  CU();
  tq = BA(VA(), 1)
})
// @from(Start 13322386, End 13322798)
function t49({
  addMargin: A,
  param: {
    text: Q
  },
  thinkingMetadata: B
}) {
  let {
    columns: G
  } = WB();
  if (!Q) return AA(Error("No content found in user prompt message")), null;
  let Z = Q.trim();
  return kW0.default.createElement(S, {
    flexDirection: "column",
    marginTop: A ? 1 : 0,
    width: G - 4
  }, kW0.default.createElement(r49, {
    text: Z,
    thinkingMetadata: B
  }))
}
// @from(Start 13322803, End 13322806)
kW0
// @from(Start 13322812, End 13322883)
e49 = L(() => {
  hA();
  g1();
  i8();
  o49();
  kW0 = BA(VA(), 1)
})
// @from(Start 13460849, End 13460927)
function jP3() {
  return Q89.sample(["Got it.", "Good to know.", "Noted."])
}
// @from(Start 13460929, End 13461508)
function G89({
  text: A,
  addMargin: Q
}) {
  let B = B9(A, "user-memory-input"),
    G = B89.useMemo(() => jP3(), []);
  if (!B) return null;
  return eq.createElement(S, {
    flexDirection: "column",
    marginTop: Q ? 1 : 0,
    width: "100%"
  }, eq.createElement(S, null, eq.createElement($, {
    color: "remember",
    backgroundColor: "memoryBackgroundColor"
  }, "#"), eq.createElement($, {
    backgroundColor: "memoryBackgroundColor",
    color: "text"
  }, " ", B, " ")), eq.createElement(S0, {
    height: 1
  }, eq.createElement($, {
    dimColor: !0
  }, G)))
}
// @from(Start 13461513, End 13461515)
eq
// @from(Start 13461517, End 13461520)
Q89
// @from(Start 13461522, End 13461525)
B89
// @from(Start 13461531, End 13461631)
Z89 = L(() => {
  hA();
  cQ();
  q8();
  eq = BA(VA(), 1), Q89 = BA(A89(), 1), B89 = BA(VA(), 1)
})
// @from(Start 13461634, End 13461867)
function I89({
  content: A,
  verbose: Q
}) {
  let B = B9(A, "bash-stdout") ?? "",
    G = B9(A, "bash-stderr") ?? "";
  return yW0.createElement(L1A, {
    content: {
      stdout: B,
      stderr: G
    },
    verbose: !!Q
  })
}
// @from(Start 13461872, End 13461875)
yW0
// @from(Start 13461881, End 13461936)
Y89 = L(() => {
  l21();
  cQ();
  yW0 = BA(VA(), 1)
})
// @from(Start 13461939, End 13462435)
function J89({
  content: A
}) {
  let Q = B9(A, "local-command-stdout"),
    B = B9(A, "local-command-stderr");
  if (!Q && !B) return AN.createElement(S0, null, AN.createElement($, {
    dimColor: !0
  }, $q));
  let G = [];
  if (Q?.trim()) G.push(AN.createElement(S0, {
    key: "stdout"
  }, AN.createElement($, {
    color: "text"
  }, Q.trim())));
  if (B?.trim()) G.push(AN.createElement(S0, {
    key: "stderr"
  }, AN.createElement($, {
    color: "error"
  }, B.trim())));
  return G
}
// @from(Start 13462440, End 13462442)
AN
// @from(Start 13462448, End 13462517)
W89 = L(() => {
  cQ();
  hA();
  q8();
  ZO();
  AN = BA(VA(), 1)
})
// @from(Start 13462520, End 13462689)
function X89({
  content: A
}) {
  let Q = B9(A, "background-task-output") ?? "";
  return zjA.createElement(S0, null, zjA.createElement($, {
    dimColor: !0
  }, Q))
}
// @from(Start 13462694, End 13462697)
zjA
// @from(Start 13462703, End 13462765)
V89 = L(() => {
  hA();
  cQ();
  q8();
  zjA = BA(VA(), 1)
})
// @from(Start 13462768, End 13463974)
function LQA({
  addMargin: A,
  param: Q,
  verbose: B,
  thinkingMetadata: G
}) {
  if (Q.text.trim() === $q) return null;
  if (Q.text.startsWith("<bash-stdout") || Q.text.startsWith("<bash-stderr")) return iW.createElement(I89, {
    content: Q.text,
    verbose: B
  });
  if (Q.text.startsWith("<background-task-output>")) return iW.createElement(X89, {
    content: Q.text
  });
  if (Q.text.startsWith("<local-command-stdout") || Q.text.startsWith("<local-command-stderr")) return iW.createElement(J89, {
    content: Q.text
  });
  if (Q.text === sJA || Q.text === xO) return iW.createElement(S0, {
    height: 1
  }, iW.createElement(zk, null));
  if (Q.text.includes("<bash-input>")) return iW.createElement(l61, {
    addMargin: A,
    param: Q
  });
  if (Q.text.includes("<background-task-input>")) return iW.createElement(f1A, {
    addMargin: A,
    param: Q
  });
  if (Q.text.includes("<command-message>")) return iW.createElement(a49, {
    addMargin: A,
    param: Q
  });
  if (Q.text.includes("<user-memory-input>")) return iW.createElement(G89, {
    addMargin: A,
    text: Q.text
  });
  return iW.createElement(t49, {
    addMargin: A,
    param: Q,
    thinkingMetadata: G
  })
}
// @from(Start 13463979, End 13463981)
iW
// @from(Start 13463987, End 13464129)
II1 = L(() => {
  C60();
  s49();
  e49();
  ZO();
  Z89();
  tZA();
  cQ();
  q8();
  Y89();
  W89();
  MQ0();
  V89();
  iW = BA(VA(), 1)
})
// @from(Start 13464132, End 13464823)
function F89({
  param: {
    thinking: A
  },
  addMargin: Q = !1,
  isTranscriptMode: B,
  verbose: G
}) {
  let [Z] = qB();
  if (!A) return null;
  if (!(B || G)) return MQA.default.createElement(S, {
    marginTop: Q ? 1 : 0
  }, MQA.default.createElement($, {
    dimColor: !0,
    italic: !0
  }, "∴ Thinking (ctrl+o to expand)"));
  return MQA.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    marginTop: Q ? 1 : 0,
    width: "100%"
  }, MQA.default.createElement($, {
    dimColor: !0,
    italic: !0
  }, "∴ Thinking…"), MQA.default.createElement(S, {
    paddingLeft: 2
  }, MQA.default.createElement($, {
    dimColor: !0,
    italic: !0
  }, fD(A, Z))))
}
// @from(Start 13464828, End 13464831)
MQA
// @from(Start 13464837, End 13464891)
K89 = L(() => {
  hA();
  wh();
  MQA = BA(VA(), 1)
})
// @from(Start 13464894, End 13465090)
function D89({
  addMargin: A = !1
}) {
  return xW0.default.createElement(S, {
    marginTop: A ? 1 : 0
  }, xW0.default.createElement($, {
    dimColor: !0,
    italic: !0
  }, "✻ Thinking…"))
}
// @from(Start 13465095, End 13465098)
xW0
// @from(Start 13465104, End 13465150)
H89 = L(() => {
  hA();
  xW0 = BA(VA(), 1)
})
// @from(Start 13465195, End 13466459)
function C89({
  attachment: A,
  verbose: Q
}) {
  if (A.files.length === 0) return null;
  let B = A.files.reduce((Z, I) => Z + I.diagnostics.length, 0),
    G = A.files.length;
  if (Q) return Jx.default.createElement(S, {
    flexDirection: "column"
  }, A.files.map((Z, I) => Jx.default.createElement(Jx.default.Fragment, {
    key: I
  }, Jx.default.createElement(S0, null, Jx.default.createElement($, {
    dimColor: !0,
    wrap: "wrap"
  }, tA.bold(SP3(W0(), Z.uri.replace("file://", "").replace("_claude_fs_right:", ""))), " ", tA.dim(Z.uri.startsWith("file://") ? "(file://)" : Z.uri.startsWith("_claude_fs_right:") ? "(claude_fs_right)" : `(${Z.uri.split(":")[0]})`), ":")), Z.diagnostics.map((Y, J) => Jx.default.createElement(S0, {
    key: J
  }, Jx.default.createElement($, {
    dimColor: !0,
    wrap: "wrap"
  }, "  ", WP.getSeveritySymbol(Y.severity), " [Line ", Y.range.start.line + 1, ":", Y.range.start.character + 1, "] ", Y.message, Y.code ? ` [${Y.code}]` : "", Y.source ? ` (${Y.source})` : ""))))));
  else return Jx.default.createElement(S0, null, Jx.default.createElement($, {
    dimColor: !0,
    wrap: "wrap"
  }, `Found ${tA.bold(B)} new diagnostic ${B===1?"issue":"issues"} in ${G} ${G===1?"file":"files"} (ctrl+o to expand)`))
}
// @from(Start 13466464, End 13466466)
Jx
// @from(Start 13466472, End 13466550)
E89 = L(() => {
  hA();
  F9();
  U2();
  q8();
  R1A();
  Jx = BA(VA(), 1)
})
// @from(Start 13466609, End 13474429)
function z89({
  attachment: A,
  addMargin: Q,
  verbose: B
}) {
  switch (A.type) {
    case "directory":
      return rB.default.createElement(AJ, null, "Listed directory", " ", tA.bold(aXA(W0(), A.path) + _P3));
    case "file":
    case "already_read_file":
      if (A.content.type === "notebook") return rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, "Read "), rB.default.createElement($, {
        bold: !0
      }, aXA(W0(), A.filename)), rB.default.createElement($, null, " "), rB.default.createElement($, {
        dimColor: !0
      }, "(", A.content.file.cells.length, " cells)"));
      return rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, "Read "), rB.default.createElement($, {
        bold: !0
      }, aXA(W0(), A.filename)), rB.default.createElement($, null, " "), rB.default.createElement($, {
        dimColor: !0
      }, "(", A.content.type === "text" ? `${A.content.file.numLines}${A.truncated?"+":""} lines` : UJ(A.content.file.originalSize), ")"));
    case "compact_file_reference":
      return rB.default.createElement(AJ, null, "Referenced file ", tA.bold(aXA(W0(), A.filename)));
    case "selected_lines_in_ide":
      return rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, "⧉ Selected "), rB.default.createElement($, {
        bold: !0
      }, A.lineEnd - A.lineStart + 1), rB.default.createElement($, null, " "), rB.default.createElement($, {
        dimColor: !0
      }, "lines from "), rB.default.createElement($, {
        bold: !0
      }, aXA(W0(), A.filename)), rB.default.createElement($, null, " "), rB.default.createElement($, {
        dimColor: !0
      }, "in ", A.ideName));
    case "nested_memory":
      return rB.default.createElement(AJ, null, tA.bold(aXA(W0(), A.path)));
    case "queued_command": {
      let G = typeof A.prompt === "string" ? A.prompt : QWA(A.prompt) || "";
      return rB.default.createElement(LQA, {
        addMargin: Q,
        param: {
          text: G,
          type: "text"
        },
        verbose: B
      })
    }
    case "todo":
      if (A.context === "post-compact") return rB.default.createElement(AJ, null, "Todo list read (", A.itemCount, " ", A.itemCount === 1 ? "item" : "items", ")");
      return null;
    case "plan_file_reference":
      return rB.default.createElement(AJ, null, "Plan file referenced (", Q5(A.planFilePath), ")");
    case "diagnostics":
      return rB.default.createElement(C89, {
        attachment: A,
        verbose: B
      });
    case "mcp_resource":
      return rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, "Read MCP resource "), rB.default.createElement($, {
        bold: !0
      }, A.name), rB.default.createElement($, null, " "), rB.default.createElement($, {
        dimColor: !0
      }, "from ", A.server));
    case "command_permissions":
      return rB.default.createElement(S, {
        flexDirection: "column",
        paddingLeft: 0
      }, A.model && rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, "Model: "), rB.default.createElement($, {
        dimColor: !0,
        bold: !0
      }, A.model)), A.allowedTools.length > 0 && rB.default.createElement(rB.default.Fragment, null, rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, "Allowed "), rB.default.createElement($, {
        dimColor: !0,
        bold: !0
      }, A.allowedTools.length), rB.default.createElement($, {
        dimColor: !0
      }, " tools for this command")), B && rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, A.allowedTools.join(", ")))));
    case "async_hook_response": {
      if (A.hookEvent === "SessionStart" && !B) return null;
      let G = A.response;
      return rB.default.createElement(AJ, {
        dimColor: !1
      }, rB.default.createElement($, {
        dimColor: !0
      }, "Async hook "), rB.default.createElement($, {
        dimColor: !0,
        bold: !0
      }, A.hookEvent), rB.default.createElement($, null, " "), rB.default.createElement($, {
        dimColor: !0
      }, "completed"), B && rB.default.createElement(rB.default.Fragment, null, rB.default.createElement($, {
        dimColor: !0
      }, ":", `
`), G.systemMessage ? rB.default.createElement($, {
        dimColor: !0
      }, G.systemMessage) : G.hookSpecificOutput && ("additionalContext" in G.hookSpecificOutput) && G.hookSpecificOutput.additionalContext ? rB.default.createElement($, {
        dimColor: !0
      }, G.hookSpecificOutput.additionalContext) : null))
    }
    case "hook_blocking_error": {
      if (A.hookEvent === "Stop" || A.hookEvent === "SubagentStop") return null;
      if (B) return rB.default.createElement(AJ, {
        color: "error"
      }, A.hookName, " hook returned blocking error:", " ", A.blockingError.blockingError);
      return rB.default.createElement(AJ, {
        color: "error"
      }, A.hookName, " hook returned blocking error")
    }
    case "hook_non_blocking_error": {
      if (A.hookEvent === "Stop" || A.hookEvent === "SubagentStop") return null;
      if (B) return rB.default.createElement(AJ, {
        color: "error"
      }, A.hookName, " hook error: ", A.stderr);
      return rB.default.createElement(AJ, {
        color: "error"
      }, A.hookName, " hook error")
    }
    case "hook_error_during_execution":
      if (A.hookEvent === "Stop" || A.hookEvent === "SubagentStop") return null;
      if (B) return rB.default.createElement(AJ, null, A.hookName, " hook warning: ", A.content);
      return rB.default.createElement(AJ, null, A.hookName, " hook warning");
    case "hook_success":
      if (A.hookEvent === "Stop" || A.hookEvent === "SubagentStop") return null;
      if (B) return rB.default.createElement(AJ, null, A.hookName, " hook succeeded: ", A.content);
      return null;
    case "hook_stopped_continuation":
      if (A.hookEvent === "Stop" || A.hookEvent === "SubagentStop") return null;
      return rB.default.createElement(AJ, {
        color: "warning"
      }, A.hookName, " hook stopped continuation: ", A.message);
    case "hook_system_message":
      return rB.default.createElement(AJ, null, A.hookName, " says: ", A.content);
    case "hook_permission_decision": {
      let G = A.decision === "allow" ? "Allowed" : "Denied";
      return rB.default.createElement(AJ, null, G, " by ", rB.default.createElement($, {
        bold: !0
      }, A.hookEvent), " hook")
    }
    case "async_agent_status": {
      let G = A.status === "completed" ? "completed in background" : A.status,
        Z = A.error ? `: ${A.error}` : "";
      return rB.default.createElement(S, {
        flexDirection: "row",
        width: "100%",
        marginTop: 1,
        paddingLeft: 2
      }, rB.default.createElement($, {
        dimColor: !0,
        wrap: "wrap"
      }, 'Agent "', tA.bold(A.description), '" ', G, Z))
    }
    case "agent_mention":
    case "background_remote_session_status":
    case "background_shell_status":
    case "budget_usd":
    case "critical_system_reminder":
    case "edited_image_file":
    case "edited_text_file":
    case "hook_additional_context":
    case "hook_cancelled":
    case "memory":
    case "opened_file_in_ide":
    case "output_style":
    case "plan_mode":
    case "plan_mode_reentry":
    case "structured_output":
    case "teammate_mailbox":
    case "todo_reminder":
    case "ultramemory":
    case "token_usage":
      return null
  }
}
// @from(Start 13474431, End 13474628)
function AJ({
  dimColor: A = !0,
  children: Q,
  color: B
}) {
  return rB.default.createElement(S0, null, rB.default.createElement($, {
    color: B,
    dimColor: A,
    wrap: "wrap"
  }, Q))
}
// @from(Start 13474633, End 13474635)
rB
// @from(Start 13474641, End 13474744)
U89 = L(() => {
  hA();
  R9();
  q8();
  F9();
  U2();
  II1();
  E89();
  cQ();
  rB = BA(VA(), 1)
})
// @from(Start 13474747, End 13475422)
function $89({
  message: {
    retryAttempt: A,
    error: Q,
    retryInMs: B,
    maxRetries: G
  }
}) {
  let [Z, I] = YI1.useState(0);
  if (CI(() => I((J) => J + 1000), 1000), YI1.useEffect(() => I(0), [A]), A < 4) return null;
  let Y = Math.max(0, Math.round((B - Z) / 1000));
  return yg.createElement(S0, null, yg.createElement(S, {
    flexDirection: "column"
  }, yg.createElement($, {
    color: "error"
  }, Bj2(Q)), yg.createElement($, {
    dimColor: !0
  }, "Retrying in ", Y, " ", Y === 1 ? "second" : "seconds", "… (attempt", " ", A, "/", G, ")", process.env.API_TIMEOUT_MS ? ` · API_TIMEOUT_MS=${process.env.API_TIMEOUT_MS}ms, try increasing it` : "")))
}
// @from(Start 13475427, End 13475429)
yg
// @from(Start 13475431, End 13475434)
YI1
// @from(Start 13475440, End 13475529)
w89 = L(() => {
  q8();
  hA();
  x60();
  JE();
  yg = BA(VA(), 1), YI1 = BA(VA(), 1)
})
// @from(Start 13475532, End 13476172)
function q89({
  message: A,
  addMargin: Q,
  verbose: B
}) {
  if (A.subtype !== "stop_hook_summary" && !B && A.level === "info") return null;
  if (A.subtype === "api_error") return V5.createElement($89, {
    message: A
  });
  if (A.subtype === "stop_hook_summary") return V5.createElement(kP3, {
    message: A,
    addMargin: Q,
    verbose: B
  });
  let Z = A.content;
  return V5.createElement(S, {
    flexDirection: "row",
    width: "100%"
  }, V5.createElement(yP3, {
    content: Z,
    addMargin: Q,
    dot: A.level !== "info",
    color: A.level === "warning" ? "warning" : void 0,
    dimColor: A.level === "info"
  }))
}
// @from(Start 13476174, End 13477126)
function kP3({
  message: A,
  addMargin: Q,
  verbose: B
}) {
  let {
    hookCount: G,
    hookInfos: Z,
    hookErrors: I,
    preventedContinuation: Y,
    stopReason: J
  } = A, {
    columns: W
  } = WB();
  if (I.length === 0 && !Y) return null;
  return V5.createElement(S, {
    flexDirection: "row",
    marginTop: Q ? 1 : 0,
    width: "100%"
  }, V5.createElement(S, {
    minWidth: 2
  }, V5.createElement($, null, rD)), V5.createElement(S, {
    flexDirection: "column",
    width: W - 10
  }, V5.createElement($, null, "Ran ", V5.createElement($, {
    bold: !0
  }, G), " stop", " ", G === 1 ? "hook" : "hooks"), B && Z.length > 0 && Z.map((X, V) => V5.createElement($, {
    key: `cmd-${V}`
  }, "⎿  ", X.command === "prompt" ? `prompt: ${X.promptText||""}` : `command: ${X.command}`)), Y && J && V5.createElement($, null, "⎿  ", J), I.length > 0 && I.map((X, V) => V5.createElement($, {
    key: V
  }, "⎿  Stop hook error: ", X))))
}
// @from(Start 13477128, End 13477628)
function yP3({
  content: A,
  addMargin: Q,
  dot: B,
  color: G,
  dimColor: Z
}) {
  let {
    columns: I
  } = WB();
  return V5.createElement(S, {
    flexDirection: "row",
    marginTop: Q ? 1 : 0,
    width: "100%"
  }, B && V5.createElement(S, {
    minWidth: 2
  }, V5.createElement($, {
    color: G,
    dimColor: Z
  }, rD)), V5.createElement(S, {
    flexDirection: "column",
    width: I - 10
  }, V5.createElement($, {
    color: G,
    dimColor: Z,
    wrap: "wrap"
  }, A.trim())))
}
// @from(Start 13477633, End 13477635)
V5
// @from(Start 13477641, End 13477711)
N89 = L(() => {
  hA();
  dn();
  i8();
  w89();
  V5 = BA(VA(), 1)
})
// @from(Start 13477714, End 13477898)
function L89() {
  let {
    columns: A
  } = WB();
  return vW0.createElement(D3, {
    dividerChar: "═",
    title: "Conversation compacted · ctrl+o for history",
    width: A
  })
}
// @from(Start 13477903, End 13477906)
vW0
// @from(Start 13477912, End 13477966)
M89 = L(() => {
  BK();
  i8();
  vW0 = BA(VA(), 1)
})
// @from(Start 13477969, End 13478912)
function O89({
  message: A,
  tools: Q,
  normalizedMessages: B,
  resolvedToolUseIDs: G,
  erroredToolUseIDs: Z,
  inProgressToolUseIDs: I,
  shouldAnimate: Y
}) {
  let J = Q.find((F) => F.name === A.toolName);
  if (!J?.renderGroupedToolUse) return null;
  let W = new Map;
  for (let F of A.results)
    for (let K of F.message.content)
      if (K.type === "tool_result") W.set(K.tool_use_id, {
        param: K,
        output: F.toolUseResult
      });
  let X = A.messages.map((F) => {
      let K = F.message.content[0],
        D = W.get(K.id);
      return {
        param: K,
        isResolved: G.has(K.id),
        isError: Z.has(K.id),
        isInProgress: I.has(K.id),
        progressMessages: $p(B.filter((H) => H.type === "progress" && H.parentToolUseID === K.id)),
        result: D
      }
    }),
    V = X.some((F) => F.isInProgress);
  return J.renderGroupedToolUse(X, {
    shouldAnimate: Y && V,
    tools: Q
  })
}
// @from(Start 13478917, End 13478931)
R89 = () => {}
// @from(Start 13478934, End 13481076)
function xP3({
  message: A,
  messages: Q,
  addMargin: B,
  tools: G,
  verbose: Z,
  erroredToolUseIDs: I,
  inProgressToolUseIDs: Y,
  resolvedToolUseIDs: J,
  progressMessagesForMessage: W,
  shouldAnimate: X,
  shouldShowDot: V,
  style: F,
  width: K,
  isTranscriptMode: D,
  onOpenRateLimitOptions: H
}) {
  switch (A.type) {
    case "attachment":
      return u3.createElement(z89, {
        addMargin: B,
        attachment: A.attachment,
        verbose: Z
      });
    case "assistant":
      return u3.createElement(S, {
        flexDirection: "column",
        width: "100%"
      }, A.message.content.map((C, E) => u3.createElement(bP3, {
        key: E,
        param: C,
        addMargin: B,
        tools: G,
        verbose: Z,
        erroredToolUseIDs: I,
        inProgressToolUseIDs: Y,
        resolvedToolUseIDs: J,
        progressMessagesForMessage: W,
        shouldAnimate: X,
        shouldShowDot: V,
        width: K,
        inProgressToolCallCount: Y.size,
        isTranscriptMode: D,
        messages: Q,
        onOpenRateLimitOptions: H
      })));
    case "user":
      return u3.createElement(S, {
        flexDirection: "column",
        width: "100%"
      }, A.message.content.map((C, E) => u3.createElement(vP3, {
        key: E,
        message: A,
        messages: Q,
        addMargin: B,
        tools: G,
        progressMessagesForMessage: W,
        param: C,
        style: F,
        verbose: Z
      })));
    case "system":
      if (A.subtype === "compact_boundary") return u3.createElement(L89, null);
      if (A.subtype === "local_command") return u3.createElement(LQA, {
        addMargin: B,
        param: {
          type: "text",
          text: A.content
        },
        verbose: Z
      });
      return u3.createElement(q89, {
        message: A,
        addMargin: B,
        verbose: Z
      });
    case "grouped_tool_use":
      return u3.createElement(O89, {
        message: A,
        tools: G,
        normalizedMessages: Q,
        resolvedToolUseIDs: J,
        erroredToolUseIDs: I,
        inProgressToolUseIDs: Y,
        shouldAnimate: X
      })
  }
}
// @from(Start 13481078, End 13481726)
function vP3({
  message: A,
  messages: Q,
  addMargin: B,
  tools: G,
  progressMessagesForMessage: Z,
  param: I,
  style: Y,
  verbose: J
}) {
  let {
    columns: W
  } = WB();
  switch (I.type) {
    case "text":
      return u3.createElement(LQA, {
        addMargin: B,
        param: I,
        verbose: J,
        thinkingMetadata: A.thinkingMetadata
      });
    case "tool_result":
      return u3.createElement(sQ9, {
        param: I,
        message: A,
        messages: Q,
        progressMessagesForMessage: Z,
        style: Y,
        tools: G,
        verbose: J,
        width: W - 5
      });
    default:
      return
  }
}
// @from(Start 13481728, End 13483059)
function bP3({
  param: A,
  addMargin: Q,
  tools: B,
  verbose: G,
  erroredToolUseIDs: Z,
  inProgressToolUseIDs: I,
  resolvedToolUseIDs: Y,
  progressMessagesForMessage: J,
  shouldAnimate: W,
  shouldShowDot: X,
  width: V,
  inProgressToolCallCount: F,
  isTranscriptMode: K,
  messages: D,
  onOpenRateLimitOptions: H
}) {
  switch (A.type) {
    case "tool_use":
      return u3.createElement(AB9, {
        param: A,
        addMargin: Q,
        tools: B,
        verbose: G,
        erroredToolUseIDs: Z,
        inProgressToolUseIDs: I,
        resolvedToolUseIDs: Y,
        progressMessagesForMessage: J,
        shouldAnimate: W,
        shouldShowDot: X,
        inProgressToolCallCount: F,
        messages: D
      });
    case "text":
      return u3.createElement(i49, {
        param: A,
        addMargin: Q,
        shouldShowDot: X,
        width: V,
        onOpenRateLimitOptions: H
      });
    case "redacted_thinking":
      if (!K && !G) return null;
      return u3.createElement(D89, {
        addMargin: Q
      });
    case "thinking":
      if (!K && !G) return null;
      return u3.createElement(F89, {
        addMargin: Q,
        param: A,
        isTranscriptMode: K,
        verbose: G
      });
    default:
      return AA(Error(`Unable to render message type: ${A.type}`)), null
  }
}
// @from(Start 13483061, End 13483190)
function fP3(A, Q) {
  if (A.message.uuid !== Q.message.uuid) return !1;
  if (A.isStatic && Q.isStatic) return !0;
  return !1
}
// @from(Start 13483195, End 13483197)
u3
// @from(Start 13483199, End 13483201)
xg
// @from(Start 13483207, End 13483384)
UjA = L(() => {
  hA();
  g1();
  rQ9();
  QB9();
  n49();
  II1();
  K89();
  H89();
  i8();
  U89();
  N89();
  M89();
  R89();
  u3 = BA(VA(), 1);
  xg = u3.memo(xP3, fP3)
})
// @from(Start 13483387, End 13487511)
function T89({
  session: A,
  toolUseContext: Q,
  onDone: B,
  onBack: G
}) {
  let [Z, I] = $jA.useState(!1), [Y, J] = $jA.useState(null);
  f1((D, H) => {
    if (H.escape || H.return || D === " ") B("Remote session details dismissed", {
      display: "system"
    });
    else if (H.leftArrow && G) G();
    else if (D === "t" && !Z) X()
  });
  let W = EQ();
  async function X() {
    I(!0), J(null);
    try {
      await yRA(A.id)
    } catch (D) {
      J(D instanceof Error ? D.message : String(D)), I(!1)
    }
  }
  let V = (D) => {
      let H = Math.floor((Date.now() - D) / 1000),
        C = Math.floor(H / 3600),
        E = Math.floor((H - C * 3600) / 60),
        U = H - C * 3600 - E * 60;
      return `${C>0?`${C}h `:""}${E>0||C>0?`${E}m `:""}${U}s`
    },
    F = $jA.useMemo(() => {
      return nJ(Pg(A.log.slice(-3))).filter((D) => D.type !== "progress")
    }, [A]),
    K = A.title.length > 50 ? A.title.substring(0, 47) + "..." : A.title;
  return x6.default.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, x6.default.createElement(S, {
    width: "100%"
  }, x6.default.createElement(S, {
    borderStyle: "round",
    borderColor: "background",
    flexDirection: "column",
    marginTop: 1,
    paddingLeft: 1,
    paddingRight: 1,
    width: "100%"
  }, x6.default.createElement(S, null, x6.default.createElement($, {
    color: "background",
    bold: !0
  }, "Remote session details")), x6.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, x6.default.createElement($, null, x6.default.createElement($, {
    bold: !0
  }, "Status"), ":", " ", A.status === "running" || A.status === "starting" ? x6.default.createElement($, {
    color: "background"
  }, A.status) : A.status === "completed" ? x6.default.createElement($, {
    color: "success"
  }, A.status) : x6.default.createElement($, {
    color: "error"
  }, A.status)), x6.default.createElement($, null, x6.default.createElement($, {
    bold: !0
  }, "Runtime"), ": ", V(A.startTime)), x6.default.createElement($, {
    wrap: "truncate-end"
  }, x6.default.createElement($, {
    bold: !0
  }, "Title"), ": ", K), x6.default.createElement($, null, x6.default.createElement($, {
    bold: !0
  }, "Progress"), ":", " ", x6.default.createElement(xZ1, {
    session: A
  })), x6.default.createElement($, null, x6.default.createElement($, {
    bold: !0
  }, "Session URL"), ":", " ", x6.default.createElement($, {
    dimColor: !0
  }, "https://claude.ai/code/", A.id))), A.log.length > 0 && x6.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, x6.default.createElement($, null, x6.default.createElement($, {
    bold: !0
  }, "Recent messages"), ":"), x6.default.createElement(S, {
    flexDirection: "column",
    height: 10,
    overflowY: "hidden"
  }, F.map((D, H) => x6.default.createElement(xg, {
    key: H,
    message: D,
    messages: F,
    addMargin: H > 0,
    tools: Q.options.tools,
    verbose: Q.options.verbose,
    erroredToolUseIDs: new Set,
    inProgressToolUseIDs: new Set,
    resolvedToolUseIDs: new Set,
    progressMessagesForMessage: [],
    shouldAnimate: !1,
    shouldShowDot: !1,
    style: "condensed",
    isTranscriptMode: !1,
    isStatic: !0
  }))), x6.default.createElement(S, {
    marginTop: 1
  }, x6.default.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Showing last ", Math.min(3, A.log.length), " of", " ", A.log.length, " messages"))), Y && x6.default.createElement(S, {
    marginTop: 1
  }, x6.default.createElement($, {
    color: "error"
  }, "Teleport failed: ", Y)), Z && x6.default.createElement(S, {
    marginTop: 1
  }, x6.default.createElement($, {
    color: "background"
  }, "Teleporting to session...")))), x6.default.createElement(S, {
    marginLeft: 2
  }, W.pending ? x6.default.createElement($, {
    dimColor: !0
  }, "Press ", W.keyName, " again to exit") : x6.default.createElement($, {
    dimColor: !0
  }, G ? x6.default.createElement($, null, "← to go back · ") : null, "Esc/Enter/Space to close", !Z ? x6.default.createElement($, null, " · t to teleport") : null)))
}
// @from(Start 13487516, End 13487518)
x6
// @from(Start 13487520, End 13487523)
$jA
// @from(Start 13487529, End 13487645)
P89 = L(() => {
  hA();
  Q4();
  uJ0();
  $0A();
  UjA();
  QjA();
  cQ();
  x6 = BA(VA(), 1), $jA = BA(VA(), 1)
})
// @from(Start 13487648, End 13487895)
function hP3(A) {
  switch (A) {
    case "running":
      return H1.pointer;
    case "completed":
      return H1.tick;
    case "failed":
      return H1.cross;
    case "killed":
      return H1.cross;
    default:
      return H1.bullet
  }
}
// @from(Start 13487897, End 13488127)
function gP3(A) {
  switch (A) {
    case "running":
      return "background";
    case "completed":
      return "success";
    case "failed":
    case "killed":
      return "error";
    default:
      return "background"
  }
}
// @from(Start 13488129, End 13488602)
function uP3(A, Q, B) {
  let G = Q.find((Z) => Z.name === A.toolName);
  if (!G) return A.toolName;
  try {
    let Z = G.inputSchema.safeParse(A.input),
      I = Z.success ? Z.data : {},
      Y = G.userFacingName(I);
    if (!Y) return A.toolName;
    let J = G.renderToolUseMessage(I, {
      theme: B,
      verbose: !1
    });
    if (J) return U6.default.createElement(U6.default.Fragment, null, Y, "(", J, ")");
    return Y
  } catch {
    return A.toolName
  }
}
// @from(Start 13488604, End 13489136)
function mP3(A, Q) {
  let [B, G] = U6.useState(() => Math.floor((Date.now() - A) / 1000));
  return U6.useEffect(() => {
    if (!Q) return;
    let I = 1000 - Date.now() % 1000,
      Y = setTimeout(() => {
        G(Math.floor((Date.now() - A) / 1000));
        let J = setInterval(() => {
          G(Math.floor((Date.now() - A) / 1000))
        }, 1000);
        Y.intervalId = J
      }, I);
    return () => {
      clearTimeout(Y);
      let J = Y.intervalId;
      if (J) clearInterval(J)
    }
  }, [Q, A]), eC(B * 1000)
}
// @from(Start 13489138, End 13492526)
function j89({
  agent: A,
  onDone: Q,
  onKillAgent: B,
  onBack: G
}) {
  let [Z] = OQ(), I = Z.todos[A.agentId] ?? [], Y = I.filter((H) => H.status === "completed").length, [J] = qB(), W = U6.useMemo(() => LC(ZE()), []), X = mP3(A.startTime, A.status === "running");
  f1((H, C) => {
    if (C.escape || C.return || H === " ") Q();
    else if (C.leftArrow && G) G();
    else if (H === "k" && A.status === "running" && B) B()
  });
  let V = EQ(),
    F = A.prompt.length > 300 ? A.prompt.substring(0, 297) + "…" : A.prompt,
    K = A.result?.totalTokens ?? A.progress?.tokenCount,
    D = A.result?.totalToolUseCount ?? A.progress?.toolUseCount;
  return U6.default.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, U6.default.createElement(S, {
    width: "100%"
  }, U6.default.createElement(S, {
    borderStyle: "round",
    borderColor: "background",
    flexDirection: "column",
    marginTop: 1,
    paddingLeft: 1,
    paddingRight: 1,
    width: "100%"
  }, U6.default.createElement(S, null, U6.default.createElement($, {
    color: "background",
    bold: !0
  }, A.selectedAgent?.agentType ?? "agent", " ›", " ", A.description || "Async agent")), U6.default.createElement(S, null, A.status !== "running" && U6.default.createElement($, {
    color: gP3(A.status)
  }, hP3(A.status), " ", A.status === "completed" ? "Completed" : A.status === "failed" ? "Failed" : "Killed", " · "), U6.default.createElement($, {
    dimColor: !0
  }, X, K !== void 0 && K > 0 && U6.default.createElement(U6.default.Fragment, null, " · ", JZ(K), " tokens"), D !== void 0 && D > 0 && U6.default.createElement(U6.default.Fragment, null, " · ", D, " tools"))), U6.default.createElement(S, {
    flexDirection: "column"
  }, A.status === "running" && A.progress?.recentActivities && A.progress.recentActivities.length > 0 && U6.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, U6.default.createElement($, {
    bold: !0,
    dimColor: !0
  }, "Progress"), A.progress.recentActivities.map((H, C) => U6.default.createElement($, {
    key: C,
    dimColor: C < A.progress.recentActivities.length - 1,
    wrap: "truncate-end"
  }, C === A.progress.recentActivities.length - 1 ? "› " : "  ", uP3(H, W, J)))), I.length > 0 && U6.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, U6.default.createElement($, {
    bold: !0,
    dimColor: !0
  }, "Tasks (", Y, "/", I.length, ")"), U6.default.createElement(Yn, {
    todos: I
  })), U6.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, U6.default.createElement($, {
    bold: !0,
    dimColor: !0
  }, "Prompt"), U6.default.createElement($, {
    wrap: "wrap"
  }, F)), A.status === "failed" && A.error && U6.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, U6.default.createElement($, {
    bold: !0,
    color: "error"
  }, "Error"), U6.default.createElement($, {
    color: "error",
    wrap: "wrap"
  }, A.error))))), U6.default.createElement(S, {
    marginLeft: 2
  }, V.pending ? U6.default.createElement($, {
    dimColor: !0
  }, "Press ", V.keyName, " again to exit") : U6.default.createElement($, {
    dimColor: !0
  }, G ? U6.default.createElement($, null, "← to go back · ") : null, "Esc/Enter/Space to close", A.status === "running" && B ? U6.default.createElement($, null, " · k to kill") : null)))
}
// @from(Start 13492531, End 13492533)
U6
// @from(Start 13492539, End 13492625)
S89 = L(() => {
  hA();
  Q4();
  z9();
  HRA();
  V9();
  yq();
  U6 = BA(VA(), 1)
})
// @from(Start 13492628, End 13492961)
function dP3(A, Q, B) {
  Q((G) => {
    let Z = G.backgroundTasks[A];
    if (!Z || Z.type !== "async_agent") return AA(Error("Async Agent not found in AppState.backgroundTasks. This is a bug")), G;
    let I = B(Z);
    return {
      ...G,
      backgroundTasks: {
        ...G.backgroundTasks,
        [A]: I
      }
    }
  })
}
// @from(Start 13492963, End 13493160)
function bW0(A, Q) {
  dP3(A, Q, (B) => {
    if (B.status !== "running") return B;
    return B.abortController?.abort(), B.unregisterCleanup?.(), {
      ...B,
      status: "killed"
    }
  })
}
// @from(Start 13493165, End 13493214)
JI1 = L(() => {
  OZ();
  g1();
  HH();
  RZ()
})
// @from(Start 13493217, End 13498329)
function WI1({
  onDone: A,
  toolUseContext: Q
}) {
  let [{
    backgroundTasks: B
  }, G] = OQ(), [Z, I] = OQA.useState(null), [Y, J] = OQA.useState(0);
  f1((T, y) => {
    if (!Z && y.escape) A("Background tasks dialog dismissed", {
      display: "system"
    });
    if (!Z && y.return && E) I(E.id);
    if (!Z && T === "k" && E?.type === "shell") X(E.id);
    if (!Z && T === "k" && E?.type === "async_agent") bW0(E.id, G);
    if (!Z && (y.upArrow || y.downArrow)) {
      let v = C.length;
      if (v === 0) return;
      if (y.upArrow) J((x) => Math.max(0, x - 1));
      else J((x) => Math.min(v - 1, x + 1))
    }
  });
  let W = EQ();

  function X(T) {
    G((y) => {
      let v = B[T];
      if (!v) return y;
      if (v.type !== "shell") return y;
      return {
        ...y,
        backgroundTasks: {
          ...y.backgroundTasks,
          [T]: W01(v)
        }
      }
    })
  }
  let V = Object.values(B).map(cP3),
    F = V.sort((T, y) => {
      if (T.status === "running" && y.status !== "running") return -1;
      if (T.status !== "running" && y.status === "running") return 1;
      return y.task.startTime - T.task.startTime
    }),
    K = F.filter((T) => T.type === "shell"),
    D = F.filter((T) => T.type === "remote_session"),
    H = F.filter((T) => T.type === "async_agent"),
    C = OQA.useMemo(() => {
      return [...K, ...D, ...H]
    }, [K, D, H]),
    E = C[Y] || null;
  if (OQA.useEffect(() => {
      if (Z && !Object.values(B).some((y) => y.type === "async_agent" ? y.agentId === Z : y.id === Z)) I(null);
      let T = C.length;
      if (Y >= T && T > 0) J(T - 1)
    }, [Z, B, Y, C]), Z) {
    let T = Object.values(B).find((y) => y.type === "async_agent" ? y.agentId === Z : y.id === Z);
    if (!T) return null;
    if (T.type === "shell") return U3.default.createElement(_Q9, {
      shell: T,
      onDone: A,
      onKillShell: () => X(T.id),
      onBack: () => I(null),
      key: `shell-${T.id}`
    });
    else if (T.type === "async_agent") return U3.default.createElement(j89, {
      agent: T,
      onDone: A,
      onKillAgent: () => bW0(T.agentId, G),
      onBack: () => I(null),
      key: `agent-${T.agentId}`
    });
    else return U3.default.createElement(T89, {
      session: T,
      onDone: A,
      toolUseContext: Q,
      onBack: () => I(null),
      key: `session-${T.id}`
    })
  }
  let U = K.filter((T) => T.status === "running").length,
    q = D.filter((T) => T.status === "running" || T.status === "starting").length,
    w = H.filter((T) => T.status === "running").length,
    N = dV([...U > 0 ? [U3.default.createElement($, {
      key: "shells"
    }, U, " ", U !== 1 ? "active shells" : "active shell")] : [], ...q > 0 ? [U3.default.createElement($, {
      key: "sessions"
    }, q, " ", q !== 1 ? "active session" : "active session")] : [], ...[]], (T) => U3.default.createElement($, {
      key: `separator-${T}`
    }, " · ")),
    R = [U3.default.createElement($, {
      key: "upDown"
    }, "↑/↓ to select"), U3.default.createElement($, {
      key: "enter"
    }, "Enter to view"), ...(E?.type === "shell" || E?.type === "async_agent") && E.status === "running" ? [U3.default.createElement($, {
      key: "kill"
    }, "k to kill")] : [], U3.default.createElement($, {
      key: "esc"
    }, "Esc to close")];
  return U3.default.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, U3.default.createElement(S, {
    borderStyle: "round",
    borderColor: "background",
    flexDirection: "column",
    marginTop: 1,
    paddingLeft: 1,
    paddingRight: 1,
    width: "100%"
  }, U3.default.createElement($, {
    color: "background",
    bold: !0
  }, "Background tasks"), U3.default.createElement($, {
    dimColor: !0
  }, N), V.length === 0 ? U3.default.createElement($, {
    dimColor: !0
  }, "No tasks currently running") : U3.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, K.length > 0 && U3.default.createElement(S, {
    flexDirection: "column"
  }, (D.length > 0 || H.length > 0) && U3.default.createElement($, {
    dimColor: !0
  }, U3.default.createElement($, {
    bold: !0
  }, "  ", "Bashes"), " (", K.length, ")"), U3.default.createElement(S, {
    flexDirection: "column"
  }, K.map((T, y) => U3.default.createElement(_89, {
    key: T.id,
    item: T,
    isSelected: y === Y
  })))), D.length > 0 && U3.default.createElement(S, {
    flexDirection: "column",
    marginTop: K.length > 0 ? 1 : 0
  }, U3.default.createElement($, {
    dimColor: !0
  }, U3.default.createElement($, {
    bold: !0
  }, "  ", "Remote sessions"), " (", D.length, ")"), U3.default.createElement(S, {
    flexDirection: "column"
  }, D.map((T, y) => U3.default.createElement(_89, {
    key: T.id,
    item: T,
    isSelected: K.length + y === Y
  })))), !1)), U3.default.createElement(S, {
    marginLeft: 2
  }, W.pending ? U3.default.createElement($, {
    dimColor: !0
  }, "Press ", W.keyName, " again to exit") : U3.default.createElement($, {
    dimColor: !0
  }, dV(R, (T) => U3.default.createElement($, {
    key: `separator-${T}`
  }, " · ")))))
}
// @from(Start 13498331, End 13498771)
function cP3(A) {
  switch (A.type) {
    case "shell":
      return {
        id: A.id, type: "shell", label: A.description, status: A.status, task: A
      };
    case "remote_session":
      return {
        id: A.id, type: "remote_session", label: A.title, status: A.status, task: A
      };
    case "async_agent":
      return {
        id: A.agentId, type: "async_agent", label: A.description, status: A.status, task: A
      }
  }
}
// @from(Start 13498773, End 13499059)
function _89({
  item: A,
  isSelected: Q
}) {
  return U3.default.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, U3.default.createElement($, {
    color: Q ? "suggestion" : void 0
  }, Q ? H1.pointer + " " : "  ", U3.default.createElement(vZ1, {
    task: A.task
  })))
}
// @from(Start 13499064, End 13499066)
U3
// @from(Start 13499068, End 13499071)
OQA
// @from(Start 13499077, End 13499219)
fW0 = L(() => {
  hA();
  V9();
  Q4();
  kQ9();
  P89();
  S89();
  z9();
  _AA();
  JI1();
  mJ0();
  U3 = BA(VA(), 1), OQA = BA(VA(), 1)
})
// @from(Start 13499222, End 13499564)
function lP3(A, Q) {
  if (A.length <= pP3) return {
    truncatedText: A,
    placeholderContent: ""
  };
  let B = Math.floor(k89 / 2),
    G = Math.floor(k89 / 2),
    Z = A.slice(0, B),
    I = A.slice(-G),
    Y = A.slice(B, -G),
    J = GrA(Y),
    X = iP3(Q, J);
  return {
    truncatedText: Z + X + I,
    placeholderContent: Y
  }
}
// @from(Start 13499566, End 13499640)
function iP3(A, Q) {
  return `[...Truncated text #${A} +${Q} lines...]`
}
// @from(Start 13499642, End 13500044)
function y89(A, Q) {
  let B = Object.keys(Q).map(Number),
    G = B.length > 0 ? Math.max(...B) + 1 : 1,
    {
      truncatedText: Z,
      placeholderContent: I
    } = lP3(A, G);
  if (!I) return {
    newInput: A,
    newPastedContents: Q
  };
  return {
    newInput: Z,
    newPastedContents: {
      ...Q,
      [G]: {
        id: G,
        type: "text",
        content: I
      }
    }
  }
}
// @from(Start 13500049, End 13500058)
pP3 = 1e4
// @from(Start 13500062, End 13500072)
k89 = 1000
// @from(Start 13500078, End 13500103)
x89 = L(() => {
  zp()
})
// @from(Start 13500106, End 13500526)
function v89({
  input: A,
  pastedContents: Q,
  onInputChange: B,
  setCursorOffset: G,
  setPastedContents: Z
}) {
  let [I, Y] = wjA.useState(!1);
  wjA.useEffect(() => {
    if (I) return;
    if (A.length <= 1e4) return;
    let {
      newInput: J,
      newPastedContents: W
    } = y89(A, Q);
    B(J), G(J.length), Z(W), Y(!0)
  }, [A, I, Q, B, Z, G]), wjA.useEffect(() => {
    if (A === "") Y(!1)
  }, [A])
}
// @from(Start 13500531, End 13500534)
wjA
// @from(Start 13500540, End 13500587)
b89 = L(() => {
  x89();
  wjA = BA(VA(), 1)
})
// @from(Start 13500590, End 13500821)
function f89(A, Q = 20) {
  let B = new Map;
  for (let Z of A) B.set(Z, (B.get(Z) || 0) + 1);
  return Array.from(B.entries()).sort((Z, I) => I[1] - Z[1]).slice(0, Q).map(([Z, I]) => `${I.toString().padStart(6)} ${Z}`).join(`
`)
}
// @from(Start 13500822, End 13502678)
async function nP3() {
  if (d0.platform === "win32") return [];
  if (!await rw()) return [];
  try {
    let A = "",
      {
        stdout: Q
      } = await A3("git", ["config", "user.email"], {
        cwd: W0()
      }),
      B = "";
    if (Q.trim()) {
      let {
        stdout: Y
      } = await A3("git", ["log", "-n", "1000", "--pretty=format:", "--name-only", "--diff-filter=M", `--author=${Q.trim()}`], {
        cwd: W0()
      }), J = Y.split(`
`).filter((W) => W.trim());
      B = f89(J)
    }
    if (A = `Files modified by user:
` + B, B.split(`
`).length < 10) {
      let {
        stdout: Y
      } = await A3("git", ["log", "-n", "1000", "--pretty=format:", "--name-only", "--diff-filter=M"], {
        cwd: W0()
      }), J = Y.split(`
`).filter((X) => X.trim()), W = f89(J);
      A += `

Files modified by other users:
` + W
    }
    let Z = (await uX({
      systemPrompt: ["You are an expert at analyzing git history. Given a list of files and their modification counts, return exactly five filenames that are frequently modified and represent core application logic (not auto-generated files, dependencies, or configuration). Make sure filenames are diverse, not all in the same folder, and are a mix of user and other users. Return only the filenames' basenames (without the path) separated by newlines with no explanation."],
      userPrompt: A,
      signal: new AbortController().signal,
      options: {
        querySource: "example_commands_frequently_modified",
        agents: [],
        isNonInteractiveSession: !1,
        hasAppendSystemPrompt: !1,
        mcpTools: [],
        agentIdOrSessionId: e1()
      }
    })).message.content[0];
    if (!Z || Z.type !== "text") return [];
    let I = Z.text.trim().split(`
`);
    if (I.length < 5) return [];
    return I
  } catch (A) {
    return AA(A), []
  }
}
// @from(Start 13502683, End 13502698)
aP3 = 604800000
// @from(Start 13502702, End 13502705)
h89
// @from(Start 13502707, End 13502710)
g89
// @from(Start 13502716, End 13503489)
hW0 = L(() => {
  jQ();
  c5();
  U2();
  fZ();
  _8();
  g1();
  l2();
  LxA();
  PV();
  _0();
  h89 = s1(() => {
    let A = j5(),
      Q = A.exampleFiles?.length ? as(A.exampleFiles) : "<filepath>",
      B = ["fix lint errors", "fix typecheck errors", `how does ${Q} work?`, `refactor ${Q}`, "how do I log an error?", `edit ${Q} to...`, `write a test for ${Q}`, "create a util logging.py that..."];
    return `Try "${as(B)}"`
  }), g89 = s1(async () => {
    let A = j5(),
      Q = Date.now(),
      B = A.exampleFilesGeneratedAt ?? 0;
    if (Q - B > aP3) A.exampleFiles = [];
    if (!A.exampleFiles?.length) nP3().then((G) => {
      if (G.length) AY({
        ...j5(),
        exampleFiles: G,
        exampleFilesGeneratedAt: Date.now()
      })
    })
  })
})
// @from(Start 13503492, End 13503905)
function m89({
  input: A,
  mode: Q,
  submitCount: B
}) {
  let [{
    queuedCommands: G
  }] = OQ(), Z = u89.useMemo(() => {
    if (A !== "") return;
    if (G.length > 0 && (N1().queuedCommandUpHintCount || 0) < sP3) return "Press up to edit queued messages";
    if (B < 1) return h89()
  }, [A, G, B]);
  if (Q === "memory") return 'Add to memory. Try "Always use descriptive variable names"';
  return Z
}
// @from(Start 13503910, End 13503913)
u89
// @from(Start 13503915, End 13503922)
sP3 = 3
// @from(Start 13503928, End 13503991)
d89 = L(() => {
  z9();
  jQ();
  hW0();
  u89 = BA(VA(), 1)
})
// @from(Start 13503994, End 13504560)
function c89({
  mode: A,
  isLoading: Q
}) {
  return tP.createElement(S, {
    alignItems: "flex-start",
    alignSelf: "flex-start",
    flexWrap: "nowrap",
    justifyContent: "flex-start",
    width: 2
  }, A === "bash" ? tP.createElement($, {
    color: "bashBorder",
    dimColor: Q
  }, "! ") : A === "memory" || A === "memorySelect" ? tP.createElement($, {
    color: "remember",
    dimColor: Q
  }, "# ") : A === "background" ? tP.createElement($, {
    color: "background",
    dimColor: Q
  }, "& ") : tP.createElement($, {
    dimColor: Q
  }, "> "))
}
// @from(Start 13504565, End 13504567)
tP
// @from(Start 13504573, End 13504618)
p89 = L(() => {
  hA();
  tP = BA(VA(), 1)
})
// @from(Start 13504621, End 13504965)
function l89() {
  let {
    columns: A
  } = WB(), [{
    queuedCommands: Q
  }] = OQ();
  if (Q.length === 0) return null;
  return qjA.createElement(S, {
    marginTop: 1,
    paddingLeft: 2,
    flexDirection: "column",
    width: A - 4
  }, qjA.createElement($, {
    dimColor: !0,
    wrap: "wrap"
  }, Q.map((B) => B.value).join(`
`)))
}
// @from(Start 13504970, End 13504973)
qjA
// @from(Start 13504979, End 13505041)
i89 = L(() => {
  i8();
  z9();
  hA();
  qjA = BA(VA(), 1)
})
// @from(Start 13505044, End 13505276)
function NjA(A, Q) {
  let B = e1(),
    G = {
      type: "queue-operation",
      operation: A,
      timestamp: new Date().toISOString(),
      sessionId: B,
      ...Q !== void 0 && {
        content: Q
      }
    };
  r89(G)
}
// @from(Start 13505278, End 13505439)
function XI1(A, Q) {
  Q((B) => ({
    ...B,
    queuedCommands: [...B.queuedCommands, A]
  })), NjA("enqueue", typeof A.value === "string" ? A.value : void 0)
}
// @from(Start 13505440, End 13505648)
async function n89(A, Q) {
  let B = await A();
  if (B.queuedCommands.length === 0) return;
  let [G, ...Z] = B.queuedCommands;
  return Q((I) => ({
    ...I,
    queuedCommands: Z
  })), NjA("dequeue"), G
}
// @from(Start 13505649, End 13505879)
async function a89(A, Q) {
  let B = await A();
  if (B.queuedCommands.length === 0) return [];
  let G = [...B.queuedCommands];
  Q((Z) => ({
    ...Z,
    queuedCommands: []
  }));
  for (let Z of G) NjA("dequeue");
  return G
}
// @from(Start 13505881, End 13506085)
function s89(A, Q) {
  if (A.length === 0) return;
  Q((B) => ({
    ...B,
    queuedCommands: B.queuedCommands.filter((G) => !A.some((Z) => Z.value === G.value))
  }));
  for (let B of A) NjA("remove")
}
// @from(Start 13506086, End 13506512)
async function VI1(A, Q, B, G) {
  let Z = await B();
  if (Z.queuedCommands.length === 0) return;
  let I = Z.queuedCommands.map((W) => W.value),
    Y = [...I, A].filter(Boolean).join(`
`),
    J = I.join(`
`).length + 1 + Q;
  for (let W of Z.queuedCommands) NjA("popAll", typeof W.value === "string" ? W.value : void 0);
  return G((W) => ({
    ...W,
    queuedCommands: []
  })), {
    text: Y,
    cursorOffset: J
  }
}
// @from(Start 13506517, End 13506550)
RQA = L(() => {
  S7();
  _0()
})
// @from(Start 13506553, End 13508816)
function o89(A, Q, B, G, Z, I, Y, J, W) {
  let [X, V] = QN.useState(""), [F, K] = QN.useState(!1), [D, H] = QN.useState(""), [C, E] = QN.useState(0), [U, q] = QN.useState("prompt"), [w, N] = QN.useState(void 0), R = QN.useRef(void 0), T = QN.useRef(new Set), y = QN.useRef(null);

  function v() {
    if (R.current) R.current.return(void 0), R.current = void 0
  }

  function x() {
    W(!1), V(""), K(!1), H(""), E(0), q("prompt"), N(void 0), v(), T.current.clear()
  }
  async function p(u, e) {
    if (!J) return;
    if (X.length === 0) {
      v(), T.current.clear(), N(void 0), K(!1), B(D), G(C), I(U);
      return
    }
    if (!u) v(), R.current = ZrA(), T.current.clear();
    if (!R.current) return;
    while (!0) {
      if (e?.aborted) return;
      let l = await R.current.next();
      if (l.done) {
        K(!0);
        return
      }
      let k = l.value.display,
        m = k.lastIndexOf(X);
      if (m !== -1 && !T.current.has(k)) {
        T.current.add(k), N(l.value), K(!1);
        let o = Wf(k);
        I(o), B(k);
        let FA = et(k).lastIndexOf(X);
        G(FA !== -1 ? FA : m);
        return
      }
    }
  }
  return f1((u, e) => {
    if (J) {
      if (e.ctrl && u === "r") p(!0);
      else if (e.escape || e.tab) {
        if (w) {
          let l = typeof w === "string" ? w : w.display,
            k = Wf(l),
            m = et(l);
          B(m), I(k)
        }
        x()
      } else if (e.ctrl && u === "c" || e.backspace && X === "") B(D), G(C), x();
      else if (e.return) {
        if (X.length === 0) A({
          display: D,
          pastedContents: {}
        });
        else if (w) {
          let l = typeof w === "string" ? w : w.display,
            k = Wf(l),
            m = et(l);
          I(k), A({
            display: m,
            pastedContents: {}
          })
        }
        x()
      }
    } else if (e.ctrl && u === "r") W(!0), H(Q), E(Z), q(Y), R.current = ZrA(), T.current.clear()
  }, {
    isActive: !0
  }), QN.useEffect(() => {
    y.current?.abort();
    let u = new AbortController;
    return y.current = u, p(!1, u.signal), () => {
      u.abort()
    }
  }, [X]), {
    historyQuery: X,
    setHistoryQuery: V,
    historyMatch: w,
    historyFailedMatch: F
  }
}
// @from(Start 13508821, End 13508823)
QN
// @from(Start 13508829, End 13508891)
t89 = L(() => {
  hA();
  zp();
  o7A();
  QN = BA(VA(), 1)
})
// @from(Start 13508894, End 13509576)
function A69({
  inputValue: A,
  isAssistantResponding: Q
}) {
  let [B, G] = OQ(), I = Q || A.length > 0 ? null : B.promptSuggestion.text, Y = gW0.useCallback(() => {
    G((W) => ({
      ...W,
      promptSuggestion: {
        text: null,
        shownAt: 0
      }
    }))
  }, [G]), J = gW0.useCallback(() => {
    let W = B.promptSuggestion.text;
    if (W) {
      let X = B.promptSuggestion.shownAt;
      return GA("tengu_prompt_suggestion_accepted", {
        timeToAcceptMs: X > 0 ? Date.now() - X : 0,
        ...!1
      }), Y(), W
    }
    return null
  }, [B.promptSuggestion, Y]);
  return {
    suggestion: I,
    acceptSuggestion: J,
    clearSuggestion: Y
  }
}
// @from(Start 13509581, End 13509584)
gW0
// @from(Start 13509586, End 13509612)
e89 = " (enter to submit)"
// @from(Start 13509618, End 13509672)
Q69 = L(() => {
  z9();
  q0();
  gW0 = BA(VA(), 1)
})
// @from(Start 13509704, End 13521003)
function rP3({
  debug: A,
  ideSelection: Q,
  toolPermissionContext: B,
  setToolPermissionContext: G,
  apiKeyStatus: Z,
  commands: I,
  agents: Y,
  isLoading: J,
  verbose: W,
  messages: X,
  onAutoUpdaterResult: V,
  autoUpdaterResult: F,
  input: K,
  onInputChange: D,
  mode: H,
  onModeChange: C,
  submitCount: E,
  onShowMessageSelector: U,
  mcpClients: q,
  pastedContents: w,
  setPastedContents: N,
  vimMode: R,
  setVimMode: T,
  showBashesDialog: y,
  setShowBashesDialog: v,
  onExit: x,
  getToolUseContext: p,
  onSubmit: u,
  isSearchingHistory: e,
  setIsSearchingHistory: l
}) {
  let k = Ja(),
    [m, o] = aJ.useState(!1),
    [IA, FA] = aJ.useState({
      show: !1
    }),
    [zA, NA] = aJ.useState(K.length),
    [OA, mA] = OQ(),
    {
      historyQuery: wA,
      setHistoryQuery: qA,
      historyMatch: KA,
      historyFailedMatch: yA
    } = o89((M1) => {
      let k1 = typeof M1 === "string" ? M1 : M1.display;
      sQ(k1)
    }, K, D, NA, zA, C, H, e, l),
    oA = aJ.useMemo(() => {
      let M1 = Object.keys(w).map(Number);
      if (M1.length === 0) return 1;
      return Math.max(...M1) + 1
    }, [w]),
    [X1, WA] = aJ.useState(!1),
    [EA, MA] = aJ.useState(!1),
    [DA, $A] = aJ.useState(!1),
    [TA, rA] = aJ.useState(!1),
    {
      suggestion: iA,
      acceptSuggestion: J1,
      clearSuggestion: w1
    } = A69({
      inputValue: K,
      isAssistantResponding: J
    }),
    jA = aJ.useMemo(() => e && KA ? et(typeof KA === "string" ? KA : KA.display) : K, [e, KA, K]),
    eA = aJ.useMemo(() => XrA(jA), [jA]),
    t1 = aJ.useMemo(() => {
      let M1 = [];
      if (e && KA && !yA) M1.push({
        start: zA,
        end: zA + wA.length,
        style: {
          type: "solid",
          color: "warning"
        },
        priority: 20
      });
      if (eA.length > 0) {
        let k1 = Ae(jA);
        if (k1.level !== "none") {
          let O0 = JrA[k1.level],
            oQ = iMB[k1.level];
          for (let tB of eA) M1.push({
            start: tB.start,
            end: tB.end,
            style: WrA(tB.word) ? {
              type: "rainbow",
              useShimmer: !0
            } : {
              type: "shimmer",
              baseColor: O0,
              shimmerColor: oQ
            },
            priority: 10
          })
        }
      }
      return M1
    }, [e, wA, KA, yA, zA, eA, jA]),
    {
      addNotification: v1
    } = vZ();
  aJ.useEffect(() => {
    if (!eA.length) return;
    if (eA.length && !OA.thinkingEnabled) v1({
      key: "thinking-toggled-via-keyword",
      jsx: wZ.createElement($, {
        color: "suggestion"
      }, "Thinking on"),
      priority: "immediate",
      timeoutMs: 3000
    })
  }, [v1, OA.thinkingEnabled, mA, eA.length]);
  let {
    pushToBuffer: F0,
    undo: g0,
    canUndo: p0,
    clearBuffer: n0
  } = jQ9({
    maxBufferSize: 50,
    debounceMs: 1000
  });
  v89({
    input: K,
    pastedContents: w,
    onInputChange: D,
    setCursorOffset: NA,
    setPastedContents: N
  });
  let _1 = m89({
      input: K,
      mode: H,
      submitCount: E
    }),
    zQ = aJ.useCallback((M1) => {
      if (M1 === "?") {
        GA("tengu_help_toggled", {}), WA((y9) => !y9);
        return
      }
      WA(!1);
      let k1 = M1.length === K.length + 1,
        O0 = zA === 0,
        oQ = Wf(M1);
      if (k1 && O0 && oQ !== "prompt") {
        C(oQ);
        return
      }
      let tB = M1.replaceAll("\t", "    ");
      if (K !== tB) F0(K, zA, w);
      D(tB)
    }, [D, C, K, zA, F0, w]),
    {
      resetHistory: W1,
      onHistoryUp: O1,
      onHistoryDown: a1,
      shouldShowSearchHint: C0,
      dismissSearchHint: v0,
      historyIndex: k0
    } = I09((M1, k1, O0) => {
      zQ(M1), C(k1), N(O0)
    }, K, w, NA);
  aJ.useEffect(() => {
    if (e) v0()
  }, [e, v0]);

  function f0() {
    if (K0.length > 1) return;
    if (OA.queuedCommands.length > 0) {
      H7();
      return
    }
    if (EA) MA(!1);
    else O1()
  }

  function G0() {
    if (K0.length > 1) return;
    let M1 = a1(),
      k1 = Object.values(OA.backgroundTasks).filter((O0) => O0.status === "running").length;
    if (M1 && k1 > 0) {
      MA(!0);
      let O0 = N1();
      if (!O0.hasSeenTasksHint) c0({
        ...O0,
        hasSeenTasksHint: !0
      })
    } else MA(!1)
  }
  let [yQ, aQ] = aJ.useState({
    suggestions: [],
    selectedSuggestion: -1,
    commandArgumentHint: void 0
  }), sQ = aJ.useCallback(async (M1, k1 = !1, O0) => {
    let oQ = M1.trim() === "" && iA ? J1() ?? "" : M1;
    if (w1(), oQ.trim() === "") return;
    let tB = yQ.suggestions.length > 0 && yQ.suggestions.every((y9) => y9.description === "directory");
    if (yQ.suggestions.length > 0 && !k1 && !tB) return;
    await u(oQ, O0, {
      setCursorOffset: NA,
      clearBuffer: n0,
      resetHistory: W1
    })
  }, [yQ.suggestions, u, NA, n0, W1, w1, iA, J1]), {
    suggestions: K0,
    selectedSuggestion: mB,
    commandArgumentHint: e2
  } = e09({
    commands: I,
    onInputChange: D,
    onSubmit: sQ,
    setCursorOffset: NA,
    input: K,
    cursorOffset: zA,
    mode: H,
    agents: Y,
    setSuggestionsState: aQ,
    suggestionsState: yQ,
    suppressSuggestions: e || k0 > 0
  }), s8 = H === "prompt" && K0.length === 0 && iA ? iA + e89 : _1;

  function K5(M1, k1) {
    GA("tengu_paste_image", {}), C("prompt");
    let O0 = {
      id: oA,
      type: "image",
      content: M1,
      mediaType: k1 || "image/png"
    };
    N((oQ) => ({
      ...oQ,
      [oA]: O0
    })), c3(uMB(O0.id))
  }

  function g6(M1) {
    let k1 = cY(M1).replace(/\r/g, `
`).replaceAll("\t", "    "),
      O0 = GrA(k1),
      oQ = Math.min(nG - 10, 2);
    if (k1.length > asA || O0 > oQ) {
      let tB = {
        id: oA,
        type: "text",
        content: k1
      };
      N((y9) => ({
        ...y9,
        [oA]: tB
      })), c3(gMB(tB.id, O0))
    } else c3(k1)
  }

  function c3(M1) {
    F0(K, zA, w);
    let k1 = K.slice(0, zA) + M1 + K.slice(zA);
    D(k1), NA(zA + M1.length)
  }
  let tZ = Bf(() => {}, () => U()),
    H7 = aJ.useCallback(async () => {
      let M1 = await VI1(K, zA, async () => new Promise((k1) => mA((O0) => {
        return k1(O0), O0
      })), mA);
      if (!M1) return;
      D(M1.text), C("prompt"), NA(M1.cursorOffset)
    }, [mA, D, C, K, zA]);
  TQ9(q, function(M1) {
    GA("tengu_ext_at_mentioned", {});
    let k1, O0 = B69.relative(W0(), M1.filePath);
    if (M1.lineStart && M1.lineEnd) k1 = M1.lineStart === M1.lineEnd ? `@${O0}#L${M1.lineStart} ` : `@${O0}#L${M1.lineStart}-${M1.lineEnd} `;
    else k1 = `@${O0} `;
    let oQ = K[zA - 1] ?? " ";
    if (!/\s/.test(oQ)) k1 = ` ${k1}`;
    c3(k1)
  }), f1((M1, k1) => {
    if (k1.ctrl && M1 === "_") {
      if (p0) {
        let O0 = g0();
        if (O0) D(O0.text), NA(O0.cursorOffset), N(O0.pastedContents)
      }
      return
    }
    if (k1.ctrl && M1.toLowerCase() === "g") {
      GA("tengu_external_editor_used", {}), rA(!0);
      let O0 = e31(K);
      if (rA(!1), O0 !== null && O0 !== K) F0(K, zA, w), D(O0), NA(O0.length);
      return
    }
    if (k1.return && EA) {
      v(!0), MA(!1);
      return
    }
    if (zA === 0 && (k1.escape || k1.backspace || k1.delete)) C("prompt"), WA(!1);
    if (X1 && K === "" && (k1.backspace || k1.delete)) WA(!1);
    if (HU.check(M1, k1)) {
      let O0 = YQ9(B);
      if (GA("tengu_mode_cycle", {
          to: O0
        }), B.mode === "plan" && O0 !== "plan") ou(!0);
      if (O0 === "plan") {
        let tB = N1();
        c0({
          ...tB,
          lastPlanModeUse: Date.now()
        })
      }
      let oQ = UF(B, {
        type: "setMode",
        mode: O0,
        destination: "session"
      });
      if (G(oQ), X1) WA(!1);
      return
    }
    if (k1.escape) {
      if (EA) {
        MA(!1);
        return
      }
      if (OA.queuedCommands.length > 0) {
        H7();
        return
      }
      if (X.length > 0 && !K && !J) tZ()
    }
    if (k1.return && X1) WA(!1)
  });
  let {
    columns: r5,
    rows: nG
  } = WB(), aG = r5 - 3, U1 = aJ.useMemo(() => {
    let M1 = K.split(`
`);
    for (let k1 of M1)
      if (k1.length > aG) return !0;
    return M1.length > 1
  }, [K, aG]);
  if (y) return wZ.createElement(WI1, {
    onDone: () => {
      v(!1)
    },
    toolUseContext: p(X, [], new AbortController, [], void 0, k)
  });
  let sA = {
      multiline: !0,
      onSubmit: sQ,
      onChange: zQ,
      value: KA ? et(typeof KA === "string" ? KA : KA.display) : K,
      onHistoryUp: f0,
      onHistoryDown: G0,
      onHistoryReset: W1,
      placeholder: s8,
      onExit: x,
      onExitMessage: (M1, k1) => FA({
        show: M1,
        key: k1
      }),
      onImagePaste: K5,
      columns: aG,
      disableCursorMovementForUpDownKeys: K0.length > 0,
      cursorOffset: zA,
      onChangeCursorOffset: NA,
      onPaste: g6,
      onIsPastingChange: $A,
      focus: H !== "memorySelect" && !e,
      showCursor: H !== "memorySelect" && !EA && !e,
      argumentHint: e2,
      onUndo: p0 ? () => {
        let M1 = g0();
        if (M1) D(M1.text), NA(M1.cursorOffset), N(M1.pastedContents)
      } : void 0,
      highlights: t1
    },
    E1 = () => {
      let M1 = {
        bash: "bashBorder",
        memory: "remember",
        memorySelect: "remember",
        background: "background"
      };
      if (M1[H]) return M1[H];
      return OA.thinkingEnabled ? "suggestion" : "promptBorder"
    };
  if (TA) return wZ.createElement(S, {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    borderColor: E1(),
    borderDimColor: H !== "memory",
    borderStyle: "round",
    borderLeft: !1,
    borderRight: !1,
    borderBottom: !0,
    width: "100%"
  }, wZ.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Save and close editor to continue..."));
  return wZ.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, wZ.createElement(l89, null), wZ.createElement(S, {
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "flex-start",
    borderColor: E1(),
    borderDimColor: H !== "memory",
    borderStyle: "round",
    borderLeft: !1,
    borderRight: !1,
    borderBottom: !0,
    width: "100%"
  }, wZ.createElement(c89, {
    mode: H,
    isLoading: J
  }), wZ.createElement(S, {
    flexGrow: 1,
    flexShrink: 1
  }, dXA() ? wZ.createElement(gJ0, {
    ...sA,
    initialMode: R,
    onModeChange: T,
    isLoading: J
  }) : wZ.createElement(s4, {
    ...sA
  }))), H === "memorySelect" && wZ.createElement(hZ1, {
    onSelect: (M1) => {
      sQ(K, !1, M1)
    },
    onCancel: () => {
      C("memory")
    }
  }), wZ.createElement(LQ9, {
    apiKeyStatus: Z,
    debug: A,
    exitMessage: IA,
    vimMode: R,
    mode: H,
    autoUpdaterResult: F,
    isAutoUpdating: m,
    verbose: W,
    onAutoUpdaterResult: V,
    onChangeIsUpdating: o,
    suggestions: K0,
    selectedSuggestion: mB,
    toolPermissionContext: B,
    helpOpen: X1,
    suppressHint: K.length > 0,
    tasksSelected: EA,
    ideSelection: Q,
    mcpClients: q,
    isPasting: DA,
    isInputWrapped: U1,
    messages: X,
    isSearching: e,
    historyQuery: wA,
    setHistoryQuery: qA,
    historyFailedMatch: yA,
    shouldShowSearchHint: C0
  }))
}
// @from(Start 13521008, End 13521010)
wZ
// @from(Start 13521012, End 13521014)
aJ
// @from(Start 13521016, End 13521019)
G69
// @from(Start 13521025, End 13521402)
Z69 = L(() => {
  hA();
  ET();
  Y09();
  AQ9();
  jQ();
  zp();
  ZY();
  GQ9();
  tPA();
  i8();
  ePA();
  cK();
  _0();
  MQ9();
  nJ0();
  wsA();
  q0();
  rsA();
  Up();
  PQ9();
  U2();
  SQ9();
  CU();
  fW0();
  BZ0();
  CU();
  z9();
  o7A();
  b89();
  d89();
  p89();
  i89();
  RQA();
  t89();
  EU();
  Q69();
  wZ = BA(VA(), 1), aJ = BA(VA(), 1);
  G69 = rP3
})
// @from(Start 13521405, End 13521580)
function Y69() {
  I69.useEffect(() => {
    let A = Math.round(process.uptime() * 1000);
    GA("tengu_timer", {
      event: "startup",
      durationMs: A
    })
  }, [])
}
// @from(Start 13521585, End 13521588)
I69
// @from(Start 13521594, End 13521640)
J69 = L(() => {
  q0();
  I69 = BA(VA(), 1)
})
// @from(Start 13521643, End 13522226)
function W69() {
  let [A, Q] = LjA.useState(() => {
    let I = Kw();
    if (!JU() || BB()) return "valid";
    if (I) return "loading";
    return "missing"
  }), [B, G] = LjA.useState(null), Z = LjA.useCallback(async () => {
    if (!JU() || BB()) {
      Q("valid");
      return
    }
    let I = Kw();
    if (!I) {
      Q("missing");
      return
    }
    try {
      let J = await V69(I, !1) ? "valid" : "invalid";
      Q(J);
      return
    } catch (Y) {
      G(Y), Q("error");
      return
    }
  }, []);
  return {
    status: A,
    reverify: Z,
    error: B
  }
}
// @from(Start 13522231, End 13522234)
LjA
// @from(Start 13522240, End 13522294)
X69 = L(() => {
  fZ();
  gB();
  LjA = BA(VA(), 1)
})
// @from(Start 13522297, End 13522576)
function F69(A) {
  let [Q, B] = OQ();
  f1((G, Z) => {
    if (Z.ctrl && G === "t") GA("tengu_toggle_todos", {
      is_expanded: Q.showExpandedTodos,
      has_todos: A && A.length > 0
    }), B((I) => ({
      ...I,
      showExpandedTodos: !I.showExpandedTodos
    }))
  })
}
// @from(Start 13522581, End 13522622)
K69 = L(() => {
  hA();
  z9();
  q0()
})
// @from(Start 13522625, End 13523016)
function D69(A, Q, B, G, Z, I, Y, J, W) {
  let [{
    queuedCommands: X
  }] = OQ();
  f1((V, F) => {
    if (!F.escape) return;
    if (G === "transcript") return;
    if (W) return;
    if (Z?.aborted) return;
    if (!Z) return;
    if (B) return;
    if (dXA() && Y === "INSERT") return;
    if (X.length > 0) {
      if (I) I()
    }
    GA("tengu_cancel", {}), A(() => []), Q()
  })
}
// @from(Start 13523021, End 13523071)
H69 = L(() => {
  hA();
  q0();
  tPA();
  z9()
})
// @from(Start 13523074, End 13523118)
function FI1(A) {
  return oP3.includes(A)
}
// @from(Start 13523120, End 13523289)
function KI1(A, Q, B, G) {
  if (!A.toolDecisions) A.toolDecisions = new Map;
  A.toolDecisions.set(Q, {
    source: G,
    decision: B,
    timestamp: Date.now()
  })
}
// @from(Start 13523291, End 13523588)
function DI1(A, Q, B, G) {
  let Z;
  if (A.getPath && Q) {
    let I = A.inputSchema.safeParse(Q);
    if (I.success) {
      let Y = A.getPath(I.data);
      if (Y) Z = vWA(Y)
    }
  }
  return {
    decision: B,
    source: G,
    tool_name: A.name,
    ...Z && {
      language: Z
    }
  }
}
// @from(Start 13523589, End 13523704)
async function HI1(A, Q, B) {
  await HO("tool_decision", {
    decision: Q,
    source: B,
    tool_name: A
  })
}
// @from(Start 13523706, End 13524031)
function C69(A, Q, B, G, Z) {
  if (GA("tengu_tool_use_granted_in_config", {
      messageID: G,
      toolName: A.name,
      sandboxEnabled: nQ.isSandboxingEnabled()
    }), FI1(A.name)) {
    let I = DI1(A, Q, "accept", "config");
    wFA()?.add(1, I)
  }
  KI1(B, Z, "accept", "config"), HI1(A.name, "accept", "config")
}
// @from(Start 13524033, End 13524194)
function tP3(A) {
  switch (A.type) {
    case "hook":
      return "hook";
    case "user":
      return A.permanent ? "user_permanent" : "user_temporary"
  }
}
// @from(Start 13524196, End 13524890)
function E69(A, Q, B, G, Z, I) {
  switch (I.type) {
    case "user":
      GA(I.permanent ? "tengu_tool_use_granted_in_prompt_permanent" : "tengu_tool_use_granted_in_prompt_temporary", {
        messageID: G,
        toolName: A.name,
        sandboxEnabled: nQ.isSandboxingEnabled()
      });
      break;
    case "hook":
      GA("tengu_tool_use_granted_by_permission_hook", {
        messageID: G,
        toolName: A.name,
        sandboxEnabled: nQ.isSandboxingEnabled(),
        permanent: I.permanent ?? !1
      });
      break
  }
  let Y = tP3(I);
  if (FI1(A.name)) {
    let J = DI1(A, Q, "accept", Y);
    wFA()?.add(1, J)
  }
  KI1(B, Z, "accept", Y), HI1(A.name, "accept", Y)
}
// @from(Start 13524892, End 13525513)
function uW0(A, Q, B, G, Z, I) {
  let Y = I.type === "hook",
    J = Y ? "hook" : I.type;
  if (Y) GA("tengu_tool_use_rejected_in_prompt", {
    messageID: G,
    toolName: A.name,
    sandboxEnabled: nQ.isSandboxingEnabled(),
    isHook: !0
  });
  else {
    let W = I.type === "user_reject" ? I.hasFeedback : !1;
    GA("tengu_tool_use_rejected_in_prompt", {
      messageID: G,
      toolName: A.name,
      sandboxEnabled: nQ.isSandboxingEnabled(),
      hasFeedback: W
    })
  }
  if (FI1(A.name)) {
    let W = DI1(A, Q, "reject", J);
    wFA()?.add(1, W)
  }
  KI1(B, Z, "reject", J), HI1(A.name, "reject", J)
}
// @from(Start 13525515, End 13531251)
function eP3(A, Q) {
  return z69.useCallback(async (B, G, Z, I, Y, J) => {
    return new Promise((W) => {
      function X() {
        GA("tengu_tool_use_cancelled", {
          messageID: I.message.id,
          toolName: B.name
        })
      }

      function V(K) {
        let D = K ? `${JjA}${K}` : XjA;
        if (W({
            behavior: "ask",
            message: D
          }), !K) Z.abortController.abort("tool-rejection")
      }
      if (Z.abortController.signal.aborted) {
        X(), V();
        return
      }
      return (J !== void 0 ? Promise.resolve(J) : M$(B, G, Z, I, Y)).then(async (K) => {
        if (K.behavior === "allow") {
          C69(B, G, Z, I.message.id, Y), W({
            ...K,
            updatedInput: G,
            userModified: !1
          });
          return
        }
        let D = await Z.getAppState(),
          H = await B.description(G, {
            isNonInteractiveSession: Z.options.isNonInteractiveSession,
            toolPermissionContext: D.toolPermissionContext,
            tools: Z.options.tools
          });
        if (Z.abortController.signal.aborted) {
          X(), V();
          return
        }
        switch (K.behavior) {
          case "deny": {
            if (GA("tengu_tool_use_denied_in_config", {
                messageID: I.message.id,
                toolName: B.name,
                sandboxEnabled: nQ.isSandboxingEnabled()
              }), FI1(B.name)) {
              let C = DI1(B, G, "reject", "config");
              wFA()?.add(1, C)
            }
            KI1(Z, Y, "reject", "config"), HI1(B.name, "reject", "config"), W(K);
            return
          }
          case "ask": {
            let C = !1;
            A((U) => [...U, {
              assistantMessage: I,
              tool: B,
              description: H,
              input: G,
              toolUseContext: Z,
              toolUseID: Y,
              permissionResult: K,
              onAbort() {
                if (C) return;
                C = !0, X(), uW0(B, G, Z, I.message.id, Y, {
                  type: "user_abort"
                }), V()
              },
              async onAllow(q, w) {
                if (C) return;
                C = !0, QKA(w);
                let N = await Z.getAppState(),
                  R = jm(N.toolPermissionContext, w);
                Q(R);
                let T = w.some((v) => WxA(v.destination));
                E69(B, q, Z, I.message.id, Y, {
                  type: "user",
                  permanent: T
                });
                let y = B.inputsEquivalent ? !B.inputsEquivalent(G, q) : !1;
                W({
                  behavior: "allow",
                  updatedInput: q,
                  userModified: y
                })
              },
              onReject(q) {
                if (C) return;
                C = !0, uW0(B, G, Z, I.message.id, Y, {
                  type: "user_reject",
                  hasFeedback: !!q
                }), V(q)
              },
              async recheckPermission() {
                if (C) return;
                let q = await M$(B, G, Z, I, Y);
                if (q.behavior === "allow") A((w) => w.filter((N) => N.toolUseID !== Y)), C69(B, G, Z, I.message.id, Y), C = !0, W({
                  behavior: "allow",
                  updatedInput: q.updatedInput || G,
                  userModified: !1
                })
              }
            }]);
            let E = await Z.getAppState();
            (async () => {
              for await (let U of SYA([mW0(B.name, Y, G, Z, E.toolPermissionContext.mode, K.suggestions, Z.abortController.signal)])) {
                if (C) return;
                if (U.permissionRequestResult && (U.permissionRequestResult.behavior === "allow" || U.permissionRequestResult.behavior === "deny")) {
                  C = !0, A((w) => w.filter((N) => N.toolUseID !== Y));
                  let q = U.permissionRequestResult;
                  if (q.behavior === "allow") {
                    let w = q.updatedInput || G,
                      N = q.updatedPermissions ?? [];
                    if (N.length > 0) {
                      QKA(N);
                      let T = await Z.getAppState(),
                        y = jm(T.toolPermissionContext, N);
                      Q(y)
                    }
                    let R = N.some((T) => WxA(T.destination));
                    E69(B, w, Z, I.message.id, Y, {
                      type: "hook",
                      permanent: R
                    }), W({
                      behavior: "allow",
                      updatedInput: w,
                      userModified: !1,
                      decisionReason: {
                        type: "hook",
                        hookName: "PermissionRequest"
                      }
                    });
                    return
                  } else if (q.behavior === "deny") {
                    if (uW0(B, G, Z, I.message.id, Y, {
                        type: "hook"
                      }), W({
                        behavior: "deny",
                        message: q.message || "Permission denied by hook",
                        decisionReason: {
                          type: "hook",
                          hookName: "PermissionRequest",
                          reason: q.message
                        }
                      }), q.interrupt) Z.abortController.abort("tool-rejection");
                    return
                  }
                }
              }
            })();
            return
          }
        }
      }).catch((K) => {
        if (K instanceof WW) X(), V();
        else AA(K)
      })
    })
  }, [A, Q])
}
// @from(Start 13531256, End 13531259)
z69
// @from(Start 13531261, End 13531264)
oP3
// @from(Start 13531266, End 13531269)
U69
// @from(Start 13531275, End 13531464)
$69 = L(() => {
  AZ();
  q0();
  cQ();
  RZ();
  g1();
  _0();
  oJA();
  R9();
  cK();
  $J();
  YO();
  _i();
  z69 = BA(VA(), 1), oP3 = ["Edit", "Write", "NotebookEdit"];
  U69 = eP3
})
// @from(Start 13531467, End 13531608)
function q69(A) {
  return w69.useMemo(() => {
    let Q = Ae(A);
    return {
      level: Q.level,
      tokens: Q.tokens
    }
  }, [A])
}
// @from(Start 13531613, End 13531616)
w69
// @from(Start 13531622, End 13531668)
N69 = L(() => {
  CU();
  w69 = BA(VA(), 1)
})
// @from(Start 13531670, End 13531958)
async function L69({
  getAppState: A,
  setAppState: Q,
  executeInput: B
}) {
  let G = await a89(A, Q);
  if (G.length === 0) return !1;
  let Z = G.map((I) => I.value).filter((I) => typeof I === "string").join(`
`);
  if (Z.length === 0) return !1;
  return await B(Z, "prompt"), !0
}
// @from(Start 13531963, End 13531989)
M69 = L(() => {
  RQA()
})
// @from(Start 13531992, End 13532027)
function Aj3() {
  Zo1(""), l5(0)
}
// @from(Start 13532028, End 13534291)
async function dW0(A) {
  let {
    input: Q,
    memoryPath: B,
    helpers: G,
    isLoading: Z,
    mode: I,
    commands: Y,
    onInputChange: J,
    onModeChange: W,
    setPastedContents: X,
    onSubmitCountChange: V,
    setIDESelection: F,
    setIsLoading: K,
    setToolJSX: D,
    getToolUseContext: H,
    messages: C,
    mainLoopModel: E,
    pastedContents: U,
    ideSelection: q,
    setUserInputOnProcessing: w,
    setAbortController: N,
    onQuery: R,
    resetLoadingState: T,
    thinkingTokens: y,
    thinkingEnabled: v,
    getAppState: x,
    setAppState: p,
    onBeforeQuery: u
  } = A, {
    setCursorOffset: e,
    clearBuffer: l,
    resetHistory: k
  } = G;
  if (Q.trim() === "") return;
  if (["exit", "quit", ":q", ":q!", ":wq", ":wq!"].includes(Q.trim())) {
    if (Y.find((zA) => zA.name === "exit")) dW0({
      ...A,
      input: "/exit"
    });
    else Aj3();
    return
  }
  let m = Q,
    o = mMB(Q),
    IA = 0;
  for (let FA of o) {
    let zA = U[FA.id];
    if (zA && zA.type === "text") m = m.replace(FA.match, zA.content), IA++
  }
  if (GA("tengu_paste_text", {
      pastedTextCount: IA
    }), I === "memory") {
    W("memorySelect");
    return
  }
  if (Z) {
    if (I !== "prompt" && I !== "memorySelect") return;
    if (I === "memorySelect" && B) {
      let FA = o9(),
        zA = H(C, [], FA, [], void 0, E);
      TP({
        input: m,
        mode: "memorySelect",
        setIsLoading: K,
        setToolJSX: D,
        context: zA,
        memoryPath: B,
        messages: C
      }), W("prompt")
    }
    XI1({
      value: m,
      mode: "prompt"
    }, p), J(""), e(0), X({}), k(), l();
    return
  }
  J(""), e(0), W("prompt"), X({}), F(void 0), V((FA) => FA + 1), l(), sP2(), await O69({
    input: m,
    mode: I,
    messages: C,
    mainLoopModel: E,
    pastedContents: U,
    ideSelection: q,
    memoryPath: B,
    thinkingTokens: y,
    thinkingEnabled: v,
    querySource: A.querySource,
    getAppState: x,
    commands: Y,
    isLoading: Z,
    setIsLoading: K,
    setToolJSX: D,
    getToolUseContext: H,
    setUserInputOnProcessing: w,
    setAbortController: N,
    onQuery: R,
    resetLoadingState: T,
    setAppState: p,
    onBeforeQuery: u,
    resetHistory: k
  })
}
// @from(Start 13534292, End 13536301)
async function O69(A) {
  let {
    input: Q,
    mode: B,
    messages: G,
    mainLoopModel: Z,
    pastedContents: I,
    ideSelection: Y,
    memoryPath: J,
    thinkingTokens: W,
    thinkingEnabled: X,
    querySource: V,
    getAppState: F,
    isLoading: K,
    setIsLoading: D,
    setToolJSX: H,
    getToolUseContext: C,
    setUserInputOnProcessing: E,
    setAbortController: U,
    onQuery: q,
    setAppState: w,
    onBeforeQuery: N,
    resetHistory: R
  } = A, T = !K, y = o9();
  if (T) U(y);
  try {
    let v = Qj3(B, W, Q, X);
    s7("query_process_user_input_start");
    let {
      messages: x,
      shouldQuery: p,
      allowedTools: u,
      skipHistory: e,
      maxThinkingTokens: l,
      model: k
    } = await TP({
      input: Q,
      mode: B,
      setIsLoading: D,
      setToolJSX: H,
      context: C(G, [], y, [], void 0, Z),
      pastedContents: I,
      ideSelection: Y,
      memoryPath: J,
      messages: G,
      setUserInputOnProcessing: E,
      isAlreadyProcessing: K,
      thinkingMetadata: v,
      querySource: V
    });
    if (s7("query_process_user_input_end"), EG()) s7("query_file_history_snapshot_start"), x.filter(yn).forEach((m) => {
      yYA((o) => {
        w((IA) => ({
          ...IA,
          fileHistory: o(IA.fileHistory)
        }))
      }, m.uuid)
    }), s7("query_file_history_snapshot_end");
    if (H(null), x.length) {
      for (let IA of x)
        if (IA.type === "user") Jf({
          display: pMB(Q, B),
          pastedContents: I
        }), R();
      if ((await q(x, y, p, u ?? [], k ?? Z, l, B === "prompt" ? N : void 0, Q)).status === "completed") await L69({
        getAppState: F,
        setAppState: w,
        executeInput: async (IA, FA) => {
          await O69({
            ...A,
            input: IA,
            mode: FA
          })
        }
      })
    } else {
      if (!e) Jf({
        display: Q,
        pastedContents: I
      });
      if (R(), !K) U(null)
    }
  } finally {
    D(!1)
  }
}
// @from(Start 13536303, End 13536599)
function Qj3(A, Q, B, G) {
  if (A !== "prompt") return;
  let Z = Q > 0,
    I = Z ? XrA(B) : [],
    Y = !G && !Z;
  return {
    level: Y ? "none" : "high",
    disabled: Y,
    triggers: I.map((W) => ({
      start: W.start,
      end: W.end,
      text: B.slice(W.start, W.end)
    }))
  }
}
// @from(Start 13536604, End 13536731)
R69 = L(() => {
  RQA();
  M69();
  zp();
  o7A();
  q0();
  OZ();
  CU();
  AWA();
  sU();
  zTA();
  Bh();
  kW();
  fRA()
})
// @from(Start 13536734, End 13536883)
function P69(A, Q) {
  return T69.useMemo(() => {
    if (A && Q && Q.length > 0) return U9A([...A, ...Q], "name");
    return A || []
  }, [A, Q])
}
// @from(Start 13536888, End 13536891)
T69
// @from(Start 13536897, End 13536944)
j69 = L(() => {
  MxA();
  T69 = BA(VA(), 1)
})
// @from(Start 13536947, End 13537058)
function S69(A, Q) {
  if (Q) return A ? `agent:builtin:${A}` : "agent:default";
  else return "agent:custom"
}
// @from(Start 13537060, End 13537252)
function MjA() {
  let Q = l0()?.outputStyle ?? wK;
  if (Q === wK) return "repl_main_thread";
  return Q in TQA ? `repl_main_thread:outputStyle:${Q}` : "repl_main_thread:outputStyle:custom"
}
// @from(Start 13537257, End 13537290)
cW0 = L(() => {
  MB();
  Gx()
})
// @from(Start 13537293, End 13537418)
function CI1(A, Q) {
  return _69.useMemo(() => {
    if (bZ()) return A;
    return U9A([...A, ...Q], "name")
  }, [A, Q])
}
// @from(Start 13537423, End 13537426)
_69
// @from(Start 13537432, End 13537487)
pW0 = L(() => {
  MxA();
  dH();
  _69 = BA(VA(), 1)
})
// @from(Start 13537490, End 13537623)
function lW0(A, Q) {
  return k69.useMemo(() => {
    if (Q.length > 0) return U9A([...A, ...Q], "name");
    return A
  }, [A, Q])
}
// @from(Start 13537628, End 13537631)
k69
// @from(Start 13537637, End 13537684)
y69 = L(() => {
  MxA();
  k69 = BA(VA(), 1)
})
// @from(Start 13537686, End 13538426)
async function Fa(A, Q, B) {
  let G = A;
  return await Promise.all([...A.matchAll(Bj3), ...A.matchAll(Gj3)].map(async (Z) => {
    let I = Z[1]?.trim();
    if (I) try {
      let Y = await M$(D9, {
        command: I
      }, Q, uD({
        content: []
      }), "");
      if (Y.behavior !== "allow") throw g(`Bash command permission check failed for command in ${B}: ${I}. Error: ${Y.message}`), new oj(`Bash command permission check failed for pattern "${Z[0]}": ${Y.message||"Permission denied"}`);
      let {
        data: J
      } = await D9.call({
        command: I
      }, Q), W = x69(J.stdout, J.stderr);
      G = G.replace(Z[0], W)
    } catch (Y) {
      if (Y instanceof oj) throw Y;
      Zj3(Y, Z[0])
    }
  })), G
}
// @from(Start 13538428, End 13538638)
function x69(A, Q, B = !1) {
  let G = [];
  if (A.trim()) G.push(A.trim());
  if (Q.trim())
    if (B) G.push(`[stderr: ${Q.trim()}]`);
    else G.push(`[stderr]
${Q.trim()}`);
  return G.join(B ? " " : `
`)
}
// @from(Start 13538640, End 13539029)
function Zj3(A, Q, B = !1) {
  if (A instanceof tj) {
    if (A.interrupted) throw new oj(`Bash command interrupted for pattern "${Q}": [Command interrupted]`);
    let I = x69(A.stdout, A.stderr, B);
    throw new oj(`Bash command failed for pattern "${Q}": ${I}`)
  }
  let G = A instanceof Error ? A.message : String(A),
    Z = B ? `[Error: ${G}]` : `[Error]
${G}`;
  throw new oj(Z)
}
// @from(Start 13539034, End 13539037)
Bj3
// @from(Start 13539039, End 13539042)
Gj3
// @from(Start 13539048, End 13539175)
OjA = L(() => {
  pF();
  RZ();
  V0();
  AZ();
  cQ();
  Bj3 = /```!\s*\n?([\s\S]*?)\n?```/g, Gj3 = /(?<!\w|\$)!`([^`]+)`/g
})
// @from(Start 13539252, End 13539308)
function EI1(A) {
  return /^skill\.md$/i.test(rXA(A))
}
// @from(Start 13539310, End 13539798)
function Jj3(A, Q, B) {
  if (EI1(A)) {
    let Z = Ka(A),
      I = Ka(Z),
      Y = rXA(Z),
      J = I.startsWith(Q) ? I.slice(Q.length).replace(/^\//, "") : "",
      W = J ? J.split("/").join(":") : "";
    return W ? `${B}:${W}:${Y}` : `${B}:${Y}`
  } else {
    let Z = Ka(A),
      I = rXA(A).replace(/\.md$/, ""),
      Y = Z.startsWith(Q) ? Z.slice(Q.length).replace(/^\//, "") : "",
      J = Y ? Y.split("/").join(":") : "";
    return J ? `${B}:${J}:${I}` : `${B}:${I}`
  }
}
// @from(Start 13539800, End 13541072)
function Wj3(A, Q) {
  let B = [],
    G = RA();

  function Z(I) {
    try {
      let Y = G.readdirSync(I);
      if (Y.some((W) => W.isFile() && EI1(W.name))) {
        for (let W of Y)
          if (W.isFile() && W.name.toLowerCase().endsWith(".md")) {
            let X = sXA(I, W.name),
              V = G.readFileSync(X, {
                encoding: "utf-8"
              }),
              {
                frontmatter: F,
                content: K
              } = NV(V);
            B.push({
              filePath: X,
              baseDir: Q,
              frontmatter: F,
              content: K
            })
          } return
      }
      for (let W of Y) {
        let X = sXA(I, W.name);
        if (W.isDirectory()) Z(X);
        else if (W.isFile() && W.name.toLowerCase().endsWith(".md")) {
          let V = G.readFileSync(X, {
              encoding: "utf-8"
            }),
            {
              frontmatter: F,
              content: K
            } = NV(V);
          B.push({
            filePath: X,
            baseDir: Q,
            frontmatter: F,
            content: K
          })
        }
      }
    } catch (Y) {
      g(`Failed to scan directory ${I}: ${Y}`, {
        level: "error"
      })
    }
  }
  return Z(A), B
}
// @from(Start 13541074, End 13541494)
function Xj3(A) {
  let Q = new Map;
  for (let G of A) {
    let Z = Ka(G.filePath),
      I = Q.get(Z) ?? [];
    I.push(G), Q.set(Z, I)
  }
  let B = [];
  for (let [G, Z] of Q) {
    let I = Z.filter((Y) => EI1(Y.filePath));
    if (I.length > 0) {
      let Y = I[0];
      if (I.length > 1) g(`Multiple skill files found in ${G}, using ${rXA(Y.filePath)}`);
      B.push(Y)
    } else B.push(...Z)
  }
  return B
}
// @from(Start 13541495, End 13541758)
async function v69(A, Q, B, G, Z, I = {
  isSkillMode: !1
}) {
  let Y = Wj3(A, A),
    J = Xj3(Y),
    W = [];
  for (let X of J) {
    let V = Jj3(X.filePath, X.baseDir, Q),
      F = RjA(V, X, B, G, Z, EI1(X.filePath), I);
    if (F) W.push(F)
  }
  return W
}
// @from(Start 13541760, End 13543811)
function RjA(A, Q, B, G, Z, I, Y = {
  isSkillMode: !1
}) {
  try {
    let {
      frontmatter: J,
      content: W
    } = Q, X = J.description ?? Wx(W, I ? "Plugin skill" : "Plugin command"), V = UO(J["allowed-tools"]), F = J["argument-hint"], K = J.when_to_use, D = J.version, H = J.name, C = J.model === "inherit" ? void 0 : J.model, E = J["disable-model-invocation"], U;
    if (Y.isSkillMode) U = E === void 0 ? !1 : Y0(E);
    else U = Y0(E);
    let q = Y.isSkillMode ? Yj3 : Ij3,
      w = `${X} (${q}:${B})`,
      N = Y.isSkillMode ? !0 : !1;
    return {
      type: "prompt",
      name: A,
      description: w,
      hasUserSpecifiedDescription: !!J.description,
      allowedTools: V,
      argumentHint: F,
      whenToUse: K,
      version: D,
      model: C,
      isSkill: I || Y.isSkillMode,
      disableModelInvocation: U,
      source: "plugin",
      pluginInfo: {
        pluginManifest: G,
        repository: B
      },
      isEnabled: () => !0,
      isHidden: N,
      progressMessage: I || Y.isSkillMode ? "loading" : "running",
      userFacingName() {
        return H || A
      },
      async getPromptForCommand(R, T) {
        let y = Y.isSkillMode ? `Base directory for this skill: ${Ka(Q.filePath)}

${W}` : W;
        if (R)
          if (y.includes("$ARGUMENTS")) y = y.replaceAll("$ARGUMENTS", R);
          else y = y + `

ARGUMENTS: ${R}`;
        return y = R10(y, Z), y = await Fa(y, {
          ...T,
          async getAppState() {
            let v = await T.getAppState();
            return {
              ...v,
              toolPermissionContext: {
                ...v.toolPermissionContext,
                alwaysAllowRules: {
                  ...v.toolPermissionContext.alwaysAllowRules,
                  command: V
                }
              }
            }
          }
        }, `/${A}`), [{
          type: "text",
          text: y
        }]
      }
    }
  } catch (J) {
    return g(`Failed to create command from ${Q.filePath}: ${J}`, {
      level: "error"
    }), null
  }
}
// @from(Start 13543813, End 13543854)
function zI1() {
  PQA.cache?.clear?.()
}
// @from(Start 13543855, End 13545492)
async function b69(A, Q, B, G, Z) {
  let I = RA(),
    Y = [];
  try {
    if (!I.existsSync(A)) return [];
    let J = sXA(A, "SKILL.md");
    if (I.existsSync(J)) {
      try {
        let X = I.readFileSync(J, {
            encoding: "utf-8"
          }),
          {
            frontmatter: V,
            content: F
          } = NV(X),
          K = `${Q}:${rXA(A)}`,
          D = {
            filePath: J,
            baseDir: Ka(J),
            frontmatter: V,
            content: F
          },
          H = RjA(K, D, B, G, Z, !0, {
            isSkillMode: !0
          });
        if (H) Y.push(H)
      } catch (X) {
        g(`Failed to load skill from ${J}: ${X}`, {
          level: "error"
        })
      }
      return Y
    }
    let W = I.readdirSync(A);
    for (let X of W) {
      if (!X.isDirectory() && !X.isSymbolicLink()) continue;
      let V = sXA(A, X.name),
        F = sXA(V, "SKILL.md");
      if (I.existsSync(F)) try {
        let K = I.readFileSync(F, {
            encoding: "utf-8"
          }),
          {
            frontmatter: D,
            content: H
          } = NV(K),
          C = `${Q}:${X.name}`,
          E = {
            filePath: F,
            baseDir: Ka(F),
            frontmatter: D,
            content: H
          },
          U = RjA(C, E, B, G, Z, !0, {
            isSkillMode: !0
          });
        if (U) Y.push(U)
      } catch (K) {
        g(`Failed to load skill from ${F}: ${K}`, {
          level: "error"
        })
      }
    }
  } catch (J) {
    g(`Failed to load skills from directory ${A}: ${J}`, {
      level: "error"
    })
  }
  return Y
}
// @from(Start 13545494, End 13545535)
function f69() {
  iW0.cache?.clear?.()
}
// @from(Start 13545540, End 13545554)
Ij3 = "plugin"
// @from(Start 13545558, End 13545572)
Yj3 = "plugin"
// @from(Start 13545576, End 13545579)
PQA
// @from(Start 13545581, End 13545584)
iW0
// @from(Start 13545590, End 13551447)
TjA = L(() => {
  l2();
  AQ();
  fV();
  V0();
  OjA();
  _y();
  hQ();
  T10();
  PQA = s1(async () => {
    let {
      enabled: A,
      errors: Q
    } = await l7(), B = [];
    if (Q.length > 0) g(`Plugin loading errors: ${Q.map((G)=>oM(G)).join(", ")}`);
    for (let G of A) {
      if (G.commandsPath) try {
        let Z = await v69(G.commandsPath, G.name, G.source, G.manifest, G.path);
        if (B.push(...Z), Z.length > 0) g(`Loaded ${Z.length} commands from plugin ${G.name} default directory`)
      } catch (Z) {
        g(`Failed to load commands from plugin ${G.name} default directory: ${Z}`, {
          level: "error"
        })
      }
      if (G.commandsPaths) {
        g(`Plugin ${G.name} has commandsPaths: ${G.commandsPaths.join(", ")}`);
        for (let Z of G.commandsPaths) try {
          let I = RA(),
            Y = I.statSync(Z);
          if (g(`Checking commandPath ${Z} - isDirectory: ${Y.isDirectory()}, isFile: ${Y.isFile()}`), Y.isDirectory()) {
            let J = await v69(Z, G.name, G.source, G.manifest, G.path);
            if (B.push(...J), J.length > 0) g(`Loaded ${J.length} commands from plugin ${G.name} custom path: ${Z}`);
            else g(`Warning: No commands found in plugin ${G.name} custom directory: ${Z}. Expected .md files or SKILL.md in subdirectories.`, {
              level: "warn"
            })
          } else if (Y.isFile() && Z.endsWith(".md")) {
            let J = I.readFileSync(Z, {
                encoding: "utf-8"
              }),
              {
                frontmatter: W,
                content: X
              } = NV(J),
              V, F;
            if (G.commandsMetadata) {
              for (let [C, E] of Object.entries(G.commandsMetadata))
                if (E.source) {
                  let U = sXA(G.path, E.source);
                  if (Z === U) {
                    V = `${G.name}:${C}`, F = E;
                    break
                  }
                }
            }
            if (!V) V = `${G.name}:${rXA(Z).replace(/\.md$/,"")}`;
            let K = F ? {
                ...W,
                ...F.description && {
                  description: F.description
                },
                ...F.argumentHint && {
                  "argument-hint": F.argumentHint
                },
                ...F.model && {
                  model: F.model
                },
                ...F.allowedTools && {
                  "allowed-tools": F.allowedTools.join(",")
                }
              } : W,
              D = {
                filePath: Z,
                baseDir: Ka(Z),
                frontmatter: K,
                content: X
              },
              H = RjA(V, D, G.source, G.manifest, G.path, !1);
            if (H) B.push(H), g(`Loaded command from plugin ${G.name} custom file: ${Z}${F?" (with metadata override)":""}`)
          }
        } catch (I) {
          g(`Failed to load commands from plugin ${G.name} custom path ${Z}: ${I}`, {
            level: "error"
          })
        }
      }
      if (G.commandsMetadata) {
        for (let [Z, I] of Object.entries(G.commandsMetadata))
          if (I.content && !I.source) try {
            let {
              frontmatter: Y,
              content: J
            } = NV(I.content), W = {
              ...Y,
              ...I.description && {
                description: I.description
              },
              ...I.argumentHint && {
                "argument-hint": I.argumentHint
              },
              ...I.model && {
                model: I.model
              },
              ...I.allowedTools && {
                "allowed-tools": I.allowedTools.join(",")
              }
            }, X = `${G.name}:${Z}`, V = {
              filePath: `<inline:${X}>`,
              baseDir: G.path,
              frontmatter: W,
              content: J
            }, F = RjA(X, V, G.source, G.manifest, G.path, !1);
            if (F) B.push(F), g(`Loaded inline content command from plugin ${G.name}: ${X}`)
          } catch (Y) {
            g(`Failed to load inline content command ${Z} from plugin ${G.name}: ${Y}`, {
              level: "error"
            })
          }
      }
    }
    return g(`Total plugin commands loaded: ${B.length}`), B
  });
  iW0 = s1(async () => {
    g(">>>>> getPluginSkills CALLED <<<<<");
    let {
      enabled: A,
      errors: Q
    } = await l7(), B = [];
    if (Q.length > 0) g(`Plugin loading errors: ${Q.map((G)=>oM(G)).join(", ")}`);
    g(`getPluginSkills: Processing ${A.length} enabled plugins`);
    for (let G of A) {
      if (g(`Checking plugin ${G.name}: skillsPath=${G.skillsPath?"exists":"none"}, skillsPaths=${G.skillsPaths?G.skillsPaths.length:0} paths`), G.skillsPath) {
        g(`Attempting to load skills from plugin ${G.name} default skillsPath: ${G.skillsPath}`);
        try {
          let Z = await b69(G.skillsPath, G.name, G.source, G.manifest, G.path);
          B.push(...Z), g(`Loaded ${Z.length} skills from plugin ${G.name} default directory`)
        } catch (Z) {
          g(`Failed to load skills from plugin ${G.name} default directory: ${Z}`, {
            level: "error"
          })
        }
      }
      if (G.skillsPaths) {
        g(`Attempting to load skills from plugin ${G.name} skillsPaths: ${G.skillsPaths.join(", ")}`);
        for (let Z of G.skillsPaths) try {
          g(`Loading from skillPath: ${Z} for plugin ${G.name}`);
          let I = await b69(Z, G.name, G.source, G.manifest, G.path);
          B.push(...I), g(`Loaded ${I.length} skills from plugin ${G.name} custom path: ${Z}`)
        } catch (I) {
          g(`Failed to load skills from plugin ${G.name} custom path ${Z}: ${I}`, {
            level: "error"
          })
        }
      }
    }
    return g(`Total plugin skills loaded: ${B.length}`), B
  })
})
// @from(Start 13551450, End 13553331)
function $I1() {
  let [, A] = OQ(), Q = UI1.useCallback(async () => {
    try {
      let {
        enabled: B,
        disabled: G,
        errors: Z
      } = await l7(), I = [], Y = [];
      try {
        I = await PQA()
      } catch (J) {
        let W = J instanceof Error ? J.message : String(J);
        Z.push({
          type: "generic-error",
          source: "plugin-commands",
          error: `Failed to load plugin commands: ${W}`
        })
      }
      try {
        Y = await _0A()
      } catch (J) {
        let W = J instanceof Error ? J.message : String(J);
        Z.push({
          type: "generic-error",
          source: "plugin-agents",
          error: `Failed to load plugin agents: ${W}`
        })
      }
      try {
        await _1A()
      } catch (J) {
        let W = J instanceof Error ? J.message : String(J);
        Z.push({
          type: "generic-error",
          source: "plugin-hooks",
          error: `Failed to load plugin hooks: ${W}`
        })
      }
      A((J) => ({
        ...J,
        plugins: {
          ...J.plugins,
          enabled: B,
          disabled: G,
          commands: I,
          agents: Y,
          errors: Z
        }
      })), g(`Loaded plugins - Enabled: ${B.length}, Disabled: ${G.length}, Commands: ${I.length}, Agents: ${Y.length}, Errors: ${Z.length}`)
    } catch (B) {
      let G = B instanceof Error ? B : Error(String(B));
      AA(G), g(`Error loading plugins: ${B}`), A((Z) => ({
        ...Z,
        plugins: {
          ...Z.plugins,
          enabled: [],
          disabled: [],
          commands: [],
          agents: [],
          errors: [{
            type: "generic-error",
            source: "plugin-system",
            error: G.message
          }]
        }
      }))
    }
  }, [A]);
  return UI1.useEffect(() => {
    Q()
  }, [Q]), {
    refreshPlugins: Q
  }
}
// @from(Start 13553336, End 13553339)
UI1
// @from(Start 13553345, End 13553442)
nW0 = L(() => {
  z9();
  fV();
  TjA();
  ETA();
  dMA();
  V0();
  g1();
  UI1 = BA(VA(), 1)
})
// @from(Start 13553445, End 13553618)
function PjA({
  state: A,
  percentage: Q
}) {
  if (!N1().terminalProgressBarEnabled) return null;
  return aW0.createElement(UsA, {
    state: A,
    percentage: Q
  })
}
// @from(Start 13553623, End 13553626)
aW0
// @from(Start 13553632, End 13553686)
h69 = L(() => {
  hA();
  jQ();
  aW0 = BA(VA(), 1)
})
// @from(Start 13553689, End 13553933)
function sW0(A) {
  if (A.type === "assistant" && A.message.content[0]?.type === "tool_use") {
    let Q = A.message.content[0];
    return {
      messageId: A.message.id,
      toolUseId: Q.id,
      toolName: Q.name
    }
  }
  return null
}
// @from(Start 13553935, End 13555689)
function g69(A, Q, B = !1) {
  if (B) return {
    messages: A
  };
  let G = new Set(Q.filter((V) => V.renderGroupedToolUse).map((V) => V.name)),
    Z = new Map;
  for (let V of A) {
    let F = sW0(V);
    if (F && G.has(F.toolName)) {
      let K = `${F.messageId}:${F.toolName}`,
        D = Z.get(K) ?? [];
      D.push(V), Z.set(K, D)
    }
  }
  let I = new Map,
    Y = new Set;
  for (let [V, F] of Z)
    if (F.length >= 2) {
      I.set(V, F);
      for (let K of F) {
        let D = sW0(K);
        if (D) Y.add(D.toolUseId)
      }
    } let J = new Map;
  for (let V of A)
    if (V.type === "user") {
      for (let F of V.message.content)
        if (F.type === "tool_result" && Y.has(F.tool_use_id)) J.set(F.tool_use_id, V)
    } let W = [],
    X = new Set;
  for (let V of A) {
    let F = sW0(V);
    if (F) {
      let K = `${F.messageId}:${F.toolName}`,
        D = I.get(K);
      if (D) {
        if (!X.has(K)) {
          X.add(K);
          let H = D[0],
            C = [];
          for (let U of D) {
            let q = U.message.content[0].id,
              w = J.get(q);
            if (w) C.push(w)
          }
          let E = {
            type: "grouped_tool_use",
            toolName: F.toolName,
            messages: D,
            results: C,
            displayMessage: H,
            uuid: `grouped-${H.uuid}`,
            timestamp: H.timestamp,
            messageId: F.messageId
          };
          W.push(E)
        }
        continue
      }
    }
    if (V.type === "user") {
      let K = V.message.content.filter((D) => D.type === "tool_result");
      if (K.length > 0) {
        if (K.every((H) => Y.has(H.tool_use_id))) continue
      }
    }
    W.push(V)
  }
  return {
    messages: W
  }
}
// @from(Start 13555691, End 13555887)
function jjA(A) {
  if (!A) return 0;
  return A.activeAgents.filter((Q) => Q.source !== "built-in").reduce((Q, B) => {
    let G = `${B.agentType}: ${B.whenToUse}`;
    return Q + gG(G)
  }, 0)
}
// @from(Start 13555892, End 13555903)
jQA = 15000
// @from(Start 13555909, End 13555934)
rW0 = L(() => {
  xM()
})
// @from(Start 13555979, End 13556040)
function u69(A) {
  return wj3.filter((Q) => Q.isActive(A))
}
// @from(Start 13556045, End 13556047)
AB
// @from(Start 13556049, End 13556052)
Fj3
// @from(Start 13556054, End 13556057)
Kj3
// @from(Start 13556059, End 13556062)
Dj3
// @from(Start 13556064, End 13556067)
Hj3
// @from(Start 13556069, End 13556072)
Cj3
// @from(Start 13556074, End 13556077)
Ej3
// @from(Start 13556079, End 13556082)
zj3
// @from(Start 13556084, End 13556087)
Uj3
// @from(Start 13556089, End 13556092)
$j3
// @from(Start 13556094, End 13556097)
wj3
// @from(Start 13556103, End 13563266)
m69 = L(() => {
  hA();
  gE();
  V9();
  U2();
  gB();
  lK();
  _0();
  rW0();
  u2();
  nY();
  Fe1();
  AB = BA(VA(), 1), Fj3 = {
    id: "large-memory-files",
    type: "warning",
    isActive: () => {
      return M1A().length > 0
    },
    render: () => {
      let A = M1A();
      return AB.createElement(AB.Fragment, null, A.map((Q) => {
        let B = Q.path.startsWith(W0()) ? Vj3(W0(), Q.path) : Q.path;
        return AB.createElement(S, {
          key: Q.path,
          flexDirection: "row"
        }, AB.createElement($, {
          color: "warning"
        }, H1.warning), AB.createElement($, {
          color: "warning"
        }, "Large ", AB.createElement($, {
          bold: !0
        }, B), " will impact performance (", JZ(Q.content.length), " chars >", " ", JZ(Lh), ")", AB.createElement($, {
          dimColor: !0
        }, " • /memory to edit")))
      }))
    }
  }, Kj3 = {
    id: "ultra-claude-md",
    type: "warning",
    isActive: () => {
      let A = O1A();
      return A !== null && A.content.length > wYA
    },
    render: () => {
      let A = O1A();
      if (!A) return null;
      let Q = A.content.length;
      return AB.createElement(S, {
        flexDirection: "row",
        gap: 1
      }, AB.createElement($, {
        color: "warning"
      }, H1.warning), AB.createElement($, {
        color: "warning"
      }, "CLAUDE.md entries marked as IMPORTANT exceed", " ", wYA, " chars (", Q, " chars)", AB.createElement($, {
        dimColor: !0
      }, " • /memory to edit")))
    }
  }, Dj3 = {
    id: "claude-ai-external-token",
    type: "warning",
    isActive: () => {
      let A = kc();
      return BB() && (A.source === "ANTHROPIC_AUTH_TOKEN" || A.source === "apiKeyHelper")
    },
    render: () => {
      let A = kc();
      return AB.createElement(S, {
        flexDirection: "row",
        marginTop: 1
      }, AB.createElement($, {
        color: "warning"
      }, H1.warning), AB.createElement($, {
        color: "warning"
      }, "Auth conflict: Using ", A.source, " instead of Claude account subscription token. Either unset ", A.source, ", or run `claude /logout`."))
    }
  }, Hj3 = {
    id: "api-key-conflict",
    type: "warning",
    isActive: () => {
      let {
        source: A
      } = cw({
        skipRetrievingKeyFromApiKeyHelper: N6()
      });
      return !!hzA() && (A === "ANTHROPIC_API_KEY" || A === "apiKeyHelper")
    },
    render: () => {
      let {
        source: A
      } = cw({
        skipRetrievingKeyFromApiKeyHelper: N6()
      });
      return AB.createElement(S, {
        flexDirection: "row",
        marginTop: 1
      }, AB.createElement($, {
        color: "warning"
      }, H1.warning), AB.createElement($, {
        color: "warning"
      }, "Auth conflict: Using ", A, " instead of Anthropic Console key. Either unset ", A, ", or run `claude /logout`."))
    }
  }, Cj3 = {
    id: "both-auth-methods",
    type: "warning",
    isActive: () => {
      let {
        source: A
      } = cw({
        skipRetrievingKeyFromApiKeyHelper: N6()
      }), Q = kc();
      return A !== "none" && Q.source !== "none" && !(A === "apiKeyHelper" && Q.source === "apiKeyHelper")
    },
    render: () => {
      let {
        source: A
      } = cw({
        skipRetrievingKeyFromApiKeyHelper: N6()
      }), Q = kc();
      return AB.createElement(S, {
        flexDirection: "column",
        marginTop: 1
      }, AB.createElement(S, {
        flexDirection: "row"
      }, AB.createElement($, {
        color: "warning"
      }, H1.warning), AB.createElement($, {
        color: "warning"
      }, "Auth conflict: Both a token (", Q.source, ") and an API key (", A, ") are set. This may lead to unexpected behavior.")), AB.createElement(S, {
        flexDirection: "column",
        marginLeft: 3
      }, AB.createElement($, {
        color: "warning"
      }, "• Trying to use", " ", Q.source === "claude.ai" ? "claude.ai" : Q.source, "?", " ", A === "ANTHROPIC_API_KEY" ? 'Unset the ANTHROPIC_API_KEY environment variable, or claude /logout then say "No" to the API key approval before login.' : A === "apiKeyHelper" ? "Unset the apiKeyHelper setting." : "claude /logout"), AB.createElement($, {
        color: "warning"
      }, "• Trying to use ", A, "?", " ", Q.source === "claude.ai" ? "claude /logout to sign out of claude.ai." : `Unset the ${Q.source} environment variable.`)))
    }
  }, Ej3 = {
    id: "sonnet-1m-welcome",
    type: "info",
    isActive: (A) => A.showSonnet1MNotice === !0,
    render: () => {
      return AB.createElement(S, {
        flexDirection: "column",
        marginTop: 1
      }, AB.createElement($, {
        bold: !0
      }, "You now have access to Sonnet 4 with 1M context (uses more rate limits than Sonnet on long requests) • Update in /model"))
    }
  }, zj3 = {
    id: "opus-4.5-available",
    type: "info",
    isActive: (A) => A.showOpus45Notice === !0,
    render: () => {
      let Q = V6() !== "firstParty",
        B = f4(),
        G = B === "max",
        Z = B === "team",
        I = B === "pro",
        Y;
      if (G || Z) Y = AB.createElement($, {
        dimColor: !0
      }, "Welcome to Opus 4.5");
      else if (I)
        if (o2("tengu_backstage_only")) Y = AB.createElement($, {
          dimColor: !0
        }, "/upgrade or /extra-usage for Opus 4.5");
        else Y = AB.createElement($, {
          dimColor: !0
        }, "/model to try Opus 4.5");
      else if (Q) Y = AB.createElement($, {
        dimColor: !0
      }, "/model to try Opus 4.5. Note: you may need to request access from your cloud provider");
      else Y = AB.createElement($, {
        dimColor: !0
      }, "/model to try Opus 4.5");
      return AB.createElement(S, {
        marginLeft: 1
      }, Y)
    }
  }, Uj3 = {
    id: "large-agent-descriptions",
    type: "warning",
    isActive: (A) => {
      return jjA(A.agentDefinitions) > jQA
    },
    render: (A) => {
      let Q = jjA(A.agentDefinitions);
      return AB.createElement(S, {
        flexDirection: "row"
      }, AB.createElement($, {
        color: "warning"
      }, H1.warning), AB.createElement($, {
        color: "warning"
      }, "Large cumulative agent descriptions will impact performance (~", JZ(Q), " tokens >", " ", JZ(jQA), ")", AB.createElement($, {
        dimColor: !0
      }, " • /agents to manage")))
    }
  }, $j3 = {
    id: "jetbrains-plugin-install",
    type: "info",
    isActive: (A) => {
      if (!DLA()) return !1;
      if (!(A.config.autoInstallIdeExtension ?? !0)) return !1;
      let B = UIA();
      return B !== null && !lQ2(B)
    },
    render: () => {
      let A = UIA(),
        Q = aF(A);
      return AB.createElement(S, {
        flexDirection: "row",
        gap: 1,
        marginLeft: 1
      }, AB.createElement($, {
        color: "ide"
      }, H1.arrowUp), AB.createElement($, null, "Install the ", AB.createElement($, {
        color: "ide"
      }, Q), " plugin from the JetBrains Marketplace:", " ", AB.createElement($, {
        bold: !0
      }, "https://docs.claude.com/s/claude-code-jetbrains")))
    }
  }, wj3 = [Fj3, Kj3, Uj3, Dj3, Hj3, Cj3, Ej3, zj3, $j3]
})
// @from(Start 13563269, End 13564472)
function d69({
  agentDefinitions: A
} = {}) {
  let Q = N1(),
    B = t6()?.organizationUuid,
    Z = (B ? Q.s1mAccessCache?.[B] : void 0)?.hasAccessNotAsDefault,
    I = B && Q.hasShownS1MWelcomeV2?.[B],
    Y = BB() && Z && !I,
    W = !(B && Q.hasShownOpus45Notice?.[B]),
    X = {
      config: Q,
      showSonnet1MNotice: Y,
      showOpus45Notice: W,
      agentDefinitions: A
    },
    V = u69(X);
  if (vg.useEffect(() => {
      if (!B) return;
      let F = V.some((D) => D.id === "sonnet-1m-welcome"),
        K = V.some((D) => D.id === "opus-4.5-available");
      if (F) GA("tengu_sonnet_1m_notice_shown", {});
      if (K) GA("tengu_opus_45_notice_shown", {});
      if (F || K) c0({
        ...Q,
        ...F && {
          hasShownS1MWelcomeV2: {
            ...Q.hasShownS1MWelcomeV2,
            [B]: !0
          }
        },
        ...K && {
          hasShownOpus45Notice: {
            ...Q.hasShownOpus45Notice,
            [B]: !0
          }
        }
      })
    }, [V, Q, B]), V.length === 0) return null;
  return vg.createElement(S, {
    flexDirection: "column",
    paddingLeft: 1
  }, V.map((F) => vg.createElement(vg.Fragment, {
    key: F.id
  }, F.render(X))))
}
// @from(Start 13564477, End 13564479)
vg
// @from(Start 13564485, End 13564563)
c69 = L(() => {
  hA();
  jQ();
  m69();
  q0();
  gB();
  vg = BA(VA(), 1)
})
// @from(Start 13564566, End 13564666)
function p69(A, Q) {
  let B = new Set;
  for (let G of A)
    if (!Q.has(G)) B.add(G);
  return B
}
// @from(Start 13564668, End 13564751)
function l69(A, Q) {
  for (let B of A)
    if (!Q.has(B)) return !1;
  return !0
}
// @from(Start 13564753, End 13565198)
function i69({
  message: A,
  isTranscriptMode: Q
}) {
  if (!(Q && A.timestamp && A.type === "assistant" && A.message.content.some((Z) => Z.type === "text"))) return null;
  let G = new Date(A.timestamp).toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: !0
  });
  return oW0.default.createElement(S, {
    marginTop: 1,
    minWidth: G.length
  }, oW0.default.createElement($, {
    dimColor: !0
  }, G))
}
// @from(Start 13565203, End 13565206)
oW0
// @from(Start 13565212, End 13565258)
n69 = L(() => {
  hA();
  oW0 = BA(VA(), 1)
})
// @from(Start 13565261, End 13565634)
function a69({
  message: A,
  isTranscriptMode: Q
}) {
  if (!(Q && A.type === "assistant" && A.message.model && A.message.content.some((G) => G.type === "text"))) return null;
  return tW0.default.createElement(S, {
    marginTop: 1,
    marginLeft: 1,
    minWidth: A.message.model.length + 8
  }, tW0.default.createElement($, {
    dimColor: !0
  }, A.message.model))
}
// @from(Start 13565639, End 13565642)
tW0
// @from(Start 13565648, End 13565694)
s69 = L(() => {
  hA();
  tW0 = BA(VA(), 1)
})
// @from(Start 13565697, End 13566236)
function r69(A) {
  let [Q, B] = oXA.useState(1), [G, Z] = oXA.useState(-1);
  return f1((I, Y) => {
    if (Y.escape && G === -1) Z(0)
  }, {
    isActive: A
  }), oXA.useEffect(() => {
    if (!A) {
      Z(-1), B(0);
      return
    }
  }, [A]), oXA.useEffect(() => {
    if (G === -1) return;
    let I = [1, 0, 1, 2, 2, 1, 0, 0, 0, 1, 2, 2, 1];
    if (G >= I.length) {
      Z(-1), B(1);
      return
    }
    B(I[G]);
    let Y = setTimeout(() => {
      Z((J) => J + 1)
    }, 60);
    return () => clearTimeout(Y)
  }, [G]), Q
}
// @from(Start 13566241, End 13566244)
oXA
// @from(Start 13566250, End 13566296)
o69 = L(() => {
  hA();
  oXA = BA(VA(), 1)
})
// @from(Start 13566298, End 13566585)
async function eW0() {
  if (N6()) return;
  if (process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC) return;
  let A = await YQ.get(Nj3);
  if (A.status === 200) {
    let Q = N1();
    c0({
      ...Q,
      cachedChangelog: A.data,
      changelogLastFetched: Date.now()
    })
  }
}
// @from(Start 13566587, End 13566641)
function SQA() {
  return N1().cachedChangelog ?? ""
}
// @from(Start 13566643, End 13567231)
function wI1(A) {
  try {
    if (!A) return {};
    let Q = {},
      B = A.split(/^## /gm).slice(1);
    for (let G of B) {
      let Z = G.trim().split(`
`);
      if (Z.length === 0) continue;
      let I = Z[0];
      if (!I) continue;
      let Y = I.split(" - ")[0]?.trim() || "";
      if (!Y) continue;
      let J = Z.slice(1).filter((W) => W.trim().startsWith("- ")).map((W) => W.trim().substring(2).trim()).filter(Boolean);
      if (J.length > 0) Q[Y] = J
    }
    return Q
  } catch (Q) {
    return AA(Q instanceof Error ? Q : Error("Failed to parse changelog")), {}
  }
}
// @from(Start 13567233, End 13567731)
function Lj3(A, Q, B = SQA()) {
  try {
    let G = wI1(B),
      Z = Da.coerce(A),
      I = Q ? Da.coerce(Q) : null;
    if (!I || Z && Da.gt(Z, I, {
        loose: !0
      })) return Object.entries(G).filter(([Y]) => !I || Da.gt(Y, I, {
      loose: !0
    })).sort(([Y], [J]) => Da.gt(Y, J, {
      loose: !0
    }) ? -1 : 1).flatMap(([Y, J]) => J).filter(Boolean).slice(0, qj3)
  } catch (G) {
    return AA(G instanceof Error ? G : Error("Failed to get release notes")), []
  }
  return []
}
// @from(Start 13567733, End 13568180)
function AX0(A = SQA()) {
  try {
    let Q = wI1(A);
    return Object.keys(Q).sort((G, Z) => Da.gt(G, Z, {
      loose: !0
    }) ? 1 : -1).map((G) => {
      let Z = Q[G];
      if (!Z || Z.length === 0) return null;
      let I = Z.filter(Boolean);
      if (I.length === 0) return null;
      return [G, I]
    }).filter((G) => G !== null)
  } catch (Q) {
    return AA(Q instanceof Error ? Q : Error("Failed to get release notes")), []
  }
}
// @from(Start 13568182, End 13568705)
function SjA(A, Q = {
  ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
  PACKAGE_URL: "@anthropic-ai/claude-code",
  README_URL: "https://code.claude.com/docs/en/overview",
  VERSION: "2.0.59",
  FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
}.VERSION) {
  if (A !== Q || !SQA()) eW0().catch((Z) => AA(Z instanceof Error ? Z : Error("Failed to fetch changelog")));
  let B = Lj3(Q, A);
  return {
    hasReleaseNotes: B.length > 0,
    releaseNotes: B
  }
}
// @from(Start 13568710, End 13568712)
Da
// @from(Start 13568714, End 13568721)
qj3 = 5
// @from(Start 13568725, End 13568797)
t69 = "https://github.com/anthropics/claude-code/blob/main/CHANGELOG.md"
// @from(Start 13568801, End 13568894)
Nj3 = "https://raw.githubusercontent.com/anthropics/claude-code/refs/heads/main/CHANGELOG.md"
// @from(Start 13568900, End 13568969)
tXA = L(() => {
  g1();
  O3();
  jQ();
  _0();
  Da = BA(KU(), 1)
})
// @from(Start 13568972, End 13569046)
function Q59(A) {
  if (A >= 70) return "horizontal";
  return "compact"
}
// @from(Start 13569048, End 13569486)
function B59(A, Q, B) {
  if (Q === "horizontal") {
    let Z = B,
      I = QX0 + NI1 + qI1 + Z,
      Y = A - I,
      J = Math.max(30, Y),
      W = Math.min(Z + J + qI1 + NI1, A - QX0);
    if (W < Z + J + qI1 + NI1) J = W - Z - qI1 - NI1;
    return {
      leftWidth: Z,
      rightWidth: J,
      totalWidth: W
    }
  }
  let G = Math.min(A - QX0, A59 + 20);
  return {
    leftWidth: G,
    rightWidth: G,
    totalWidth: G
  }
}
// @from(Start 13569488, End 13569597)
function G59(A, Q, B) {
  let G = Math.max(A.length, Q.length, B.length, 20);
  return Math.min(G + 4, A59)
}
// @from(Start 13569599, End 13569700)
function MI1(A) {
  if (!A || A.length > Mj3) return "Welcome back!";
  return `Welcome back ${A}!`
}
// @from(Start 13569702, End 13570676)
function kjA(A, Q) {
  if (A.length <= Q) return A;
  let B = "/",
    G = "…",
    Z = A.split(B),
    I = Z[0] || "",
    Y = Z[Z.length - 1] || "";
  if (Z.length === 1) return A.substring(0, Q - G.length) + G;
  if (I === "" && G.length + B.length + Y.length >= Q) return `${B}${Y.substring(0,Q-G.length-B.length)}${G}`;
  if (I !== "" && G.length * 2 + B.length + Y.length >= Q) return `${G}${B}${Y.substring(0,Q-G.length*2-B.length)}${G}`;
  if (Z.length === 2) return `${I.substring(0,Q-G.length-B.length-Y.length)}${G}${B}${Y}`;
  let J = Q - I.length - Y.length - G.length - 2 * B.length;
  if (J <= 0) return `${I.substring(0,Math.max(0,Q-Y.length-G.length-2*B.length))}${B}${G}${B}${Y}`;
  let W = [];
  for (let X = Z.length - 2; X > 0; X--) {
    let V = Z[X];
    if (V && V.length + B.length <= J) W.unshift(V), J -= V.length + B.length;
    else break
  }
  if (W.length === 0) return `${I}${B}${G}${B}${Y}`;
  return `${I}${B}${G}${B}${W.join(B)}${B}${Y}`
}
// @from(Start 13570677, End 13571155)
async function Z59() {
  if (LI1) return LI1;
  let A = e1();
  return LI1 = eP(10).then((Q) => {
    return _jA = Q.filter((B) => {
      if (B.isSidechain) return !1;
      if (B.leafUuid === A) return !1;
      if (B.summary?.includes("I apologize")) return !1;
      let G = B.summary && B.summary !== "No prompt",
        Z = B.firstPrompt && B.firstPrompt !== "No prompt";
      return G || Z
    }).slice(0, 3), _jA
  }).catch(() => {
    return _jA = [], _jA
  }), LI1
}
// @from(Start 13571157, End 13571188)
function I59() {
  return _jA
}
// @from(Start 13571190, End 13571758)
function OI1() {
  let A = {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION,
    Q = Q5(W0()),
    B = k3(),
    G = zCB(B),
    Z = BB() ? mv1() : "API Usage Billing",
    I = $T().agent;
  return {
    version: A,
    cwd: Q,
    modelDisplayName: G,
    billingType: Z,
    agentName: I
  }
}
// @from(Start 13571760, End 13572035)
function Y59(A, Q, B) {
  if (A.length + 3 + Q.length > B) return {
    shouldSplit: !0,
    truncatedModel: J7(A, B),
    truncatedBilling: J7(Q, B)
  };
  return {
    shouldSplit: !1,
    truncatedModel: J7(A, Math.max(B - Q.length - 3, 10)),
    truncatedBilling: Q
  }
}
// @from(Start 13572037, End 13572313)
function J59(A) {
  let Q = SQA();
  if (!Q) return [];
  let B = wI1(Q),
    G = [],
    Z = Object.keys(B).sort((I, Y) => e69.gt(I, Y, {
      loose: !0
    }) ? -1 : 1).slice(0, 3);
  for (let I of Z) {
    let Y = B[I];
    if (Y) G.push(...Y)
  }
  return G.slice(0, A)
}
// @from(Start 13572318, End 13572321)
e69
// @from(Start 13572323, End 13572331)
A59 = 50
// @from(Start 13572335, End 13572343)
Mj3 = 20
// @from(Start 13572347, End 13572354)
QX0 = 4
// @from(Start 13572358, End 13572365)
qI1 = 1
// @from(Start 13572369, End 13572376)
NI1 = 2
// @from(Start 13572380, End 13572383)
_jA
// @from(Start 13572385, End 13572395)
LI1 = null
// @from(Start 13572401, End 13572516)
RI1 = L(() => {
  tXA();
  S7();
  _0();
  U2();
  R9();
  gB();
  t2();
  MB();
  e69 = BA(KU(), 1);
  _jA = []
})
// @from(Start 13572519, End 13573239)
function BX0() {
  if (d0.terminal === "Apple_Terminal") return F5.createElement(Oj3, null);
  return F5.createElement(S, {
    flexDirection: "column"
  }, F5.createElement($, null, F5.createElement($, {
    color: "clawd_body"
  }, " ▐"), F5.createElement($, {
    color: "clawd_body",
    backgroundColor: "clawd_background"
  }, "▛███▜"), F5.createElement($, {
    color: "clawd_body"
  }, "▌")), F5.createElement($, null, F5.createElement($, {
    color: "clawd_body"
  }, "▝▜"), F5.createElement($, {
    color: "clawd_body",
    backgroundColor: "clawd_background"
  }, "█████"), F5.createElement($, {
    color: "clawd_body"
  }, "▛▘")), F5.createElement($, {
    color: "clawd_body"
  }, "  ", "▘▘ ▝▝", "  "))
}
// @from(Start 13573241, End 13573748)
function Oj3() {
  return F5.createElement(S, {
    flexDirection: "column",
    alignItems: "center"
  }, F5.createElement($, null, F5.createElement($, {
    color: "clawd_body"
  }, "▗"), F5.createElement($, {
    color: "clawd_background",
    backgroundColor: "clawd_body"
  }, " ", "▗", "   ", "▖", " "), F5.createElement($, {
    color: "clawd_body"
  }, "▖")), F5.createElement($, {
    backgroundColor: "clawd_body"
  }, " ".repeat(7)), F5.createElement($, {
    color: "clawd_body"
  }, "▘▘ ▝▝"))
}
// @from(Start 13573753, End 13573755)
F5
// @from(Start 13573761, End 13573814)
W59 = L(() => {
  hA();
  c5();
  F5 = BA(VA(), 1)
})
// @from(Start 13573817, End 13574329)
function X59(A) {
  let {
    title: Q,
    lines: B,
    footer: G,
    emptyMessage: Z,
    customContent: I
  } = A, Y = Q.length;
  if (I !== void 0) Y = Math.max(Y, I.width);
  else if (B.length === 0 && Z) Y = Math.max(Y, Z.length);
  else {
    let W = Math.max(0, ...B.map((X) => X.timestamp ? X.timestamp.length : 0));
    for (let X of B) {
      let V = W > 0 ? W : 0,
        F = X.text.length + (V > 0 ? V + 2 : 0);
      Y = Math.max(Y, F)
    }
  }
  if (G) Y = Math.max(Y, G.length);
  return Y
}
// @from(Start 13574331, End 13575331)
function V59({
  config: A,
  actualWidth: Q
}) {
  let {
    title: B,
    lines: G,
    footer: Z,
    emptyMessage: I,
    customContent: Y
  } = A, J = "  ", W = Math.max(0, ...G.map((X) => X.timestamp ? X.timestamp.length : 0));
  return t7.createElement(S, {
    flexDirection: "column",
    width: Q
  }, t7.createElement($, {
    bold: !0,
    color: "claude"
  }, B), Y ? t7.createElement(t7.Fragment, null, Y.content, Z && t7.createElement($, {
    dimColor: !0,
    italic: !0
  }, J7(Z, Q))) : G.length === 0 && I ? t7.createElement($, {
    dimColor: !0
  }, J7(I, Q)) : t7.createElement(t7.Fragment, null, G.map((X, V) => {
    let F = Math.max(10, Q - (W > 0 ? W + 2 : 0));
    return t7.createElement($, {
      key: V
    }, W > 0 && t7.createElement(t7.Fragment, null, t7.createElement($, {
      dimColor: !0
    }, (X.timestamp || "").padEnd(W)), "  "), t7.createElement($, null, J7(X.text, F)))
  }), Z && t7.createElement($, {
    dimColor: !0,
    italic: !0
  }, J7(Z, Q))))
}
// @from(Start 13575336, End 13575338)
t7
// @from(Start 13575344, End 13575389)
F59 = L(() => {
  hA();
  t7 = BA(VA(), 1)
})
// @from(Start 13575392, End 13575789)
function K59({
  feeds: A,
  maxWidth: Q
}) {
  let B = A.map((I) => X59(I)),
    G = Math.max(...B),
    Z = Math.min(G, Q);
  return Aj.createElement(S, {
    flexDirection: "column"
  }, A.map((I, Y) => Aj.createElement(Aj.Fragment, {
    key: Y
  }, Aj.createElement(V59, {
    config: I,
    actualWidth: Z
  }), Y < A.length - 1 && Aj.createElement(D3, {
    dividerColor: "claude"
  }))))
}
// @from(Start 13575794, End 13575796)
Aj
// @from(Start 13575802, End 13575864)
D59 = L(() => {
  hA();
  F59();
  BK();
  Aj = BA(VA(), 1)
})
// @from(Start 13575906, End 13576264)
function TI1(A) {
  let Q = A.map((B) => {
    let G = Yt(B.modified);
    return {
      text: (B.summary && B.summary !== "No prompt" ? B.summary : B.firstPrompt) || "",
      timestamp: G
    }
  });
  return {
    title: "Recent activity",
    lines: Q,
    footer: Q.length > 0 ? "/resume for more" : void 0,
    emptyMessage: "No recent activity"
  }
}
// @from(Start 13576266, End 13576593)
function H59(A) {
  let Q = A.map((G) => {
      return {
        text: G
      }
    }),
    B = "Check the Claude Code changelog for updates";
  return {
    title: "What's new",
    lines: Q,
    footer: Q.length > 0 ? "/release-notes for more" : void 0,
    emptyMessage: "Check the Claude Code changelog for updates"
  }
}
// @from(Start 13576595, End 13577117)
function C59(A) {
  let B = A.filter(({
      isEnabled: Z
    }) => Z).sort((Z, I) => Number(Z.isComplete) - Number(I.isComplete)).map(({
      text: Z,
      isComplete: I
    }) => {
      return {
        text: `${I?`${H1.tick} `:""}${Z}`
      }
    }),
    G = W0() === Rj3() ? "Note: You have launched claude in your home directory. For the best experience, launch it in a project directory instead." : void 0;
  if (G) B.push({
    text: G
  });
  return {
    title: "Tips for getting started",
    lines: B
  }
}
// @from(Start 13577119, End 13577523)
function E59() {
  return {
    title: "3 guest passes",
    lines: [],
    customContent: {
      content: vO.createElement(vO.Fragment, null, vO.createElement(S, {
        marginY: 1
      }, vO.createElement($, {
        color: "claude"
      }, "[✻] [✻] [✻]")), vO.createElement($, {
        dimColor: !0
      }, "Share Claude Code with friends")),
      width: 30
    },
    footer: "/passes"
  }
}
// @from(Start 13577528, End 13577530)
vO
// @from(Start 13577536, End 13577597)
z59 = L(() => {
  V9();
  U2();
  hA();
  vO = BA(VA(), 1)
})
// @from(Start 13577599, End 13577938)
async function Tj3(A = "claude_code_guest_pass") {
  let {
    accessToken: Q,
    orgUUID: B
  } = await U0A(), G = {
    ...IC(Q),
    "x-organization-uuid": B
  }, Z = `${e9().BASE_API_URL}/api/oauth/organizations/${B}/referral/eligibility`;
  return (await YQ.get(Z, {
    headers: G,
    params: {
      campaign: A
    }
  })).data
}
// @from(Start 13577939, End 13578278)
async function w59(A = "claude_code_guest_pass") {
  let {
    accessToken: Q,
    orgUUID: B
  } = await U0A(), G = {
    ...IC(Q),
    "x-organization-uuid": B
  }, Z = `${e9().BASE_API_URL}/api/oauth/organizations/${B}/referral/redemptions`;
  return (await YQ.get(Z, {
    headers: G,
    params: {
      campaign: A
    }
  })).data
}
// @from(Start 13578280, End 13578360)
function q59() {
  return !!(t6()?.organizationUuid && BB() && f4() === "max")
}
// @from(Start 13578362, End 13578852)
function N59() {
  if (!q59()) return {
    eligible: !1,
    needsRefresh: !1,
    hasCache: !1
  };
  let A = t6()?.organizationUuid;
  if (!A) return {
    eligible: !1,
    needsRefresh: !1,
    hasCache: !1
  };
  let B = N1().passesEligibilityCache?.[A];
  if (!B) return {
    eligible: !1,
    needsRefresh: !0,
    hasCache: !1
  };
  let {
    eligible: G,
    timestamp: Z
  } = B, Y = Date.now() - Z > $59;
  return {
    eligible: G,
    needsRefresh: Y,
    hasCache: !0
  }
}
// @from(Start 13578853, End 13579520)
async function U59() {
  if (yjA) return g("Passes: Reusing in-flight eligibility fetch"), yjA;
  let A = t6()?.organizationUuid;
  if (!A) return null;
  return yjA = (async () => {
    try {
      let Q = await Tj3(),
        B = N1(),
        G = {
          ...B.passesEligibilityCache,
          [A]: {
            ...Q,
            timestamp: Date.now()
          }
        };
      return c0({
        ...B,
        passesEligibilityCache: G
      }), g(`Passes eligibility cached for org ${A}: ${Q.eligible}`), Q
    } catch (Q) {
      return g("Failed to fetch and cache passes eligibility"), AA(Q), null
    } finally {
      yjA = null
    }
  })(), yjA
}
// @from(Start 13579521, End 13580064)
async function xjA() {
  if (!q59()) return null;
  let A = t6()?.organizationUuid;
  if (!A) return null;
  let B = N1().passesEligibilityCache?.[A],
    G = Date.now();
  if (!B) return g("Passes: No cache, fetching eligibility"), await U59();
  if (G - B.timestamp > $59) {
    g("Passes: Cache stale, returning cached data and refreshing in background"), U59();
    let {
      timestamp: Y,
      ...J
    } = B;
    return J
  }
  g("Passes: Using fresh cached eligibility data");
  let {
    timestamp: Z,
    ...I
  } = B;
  return I
}
// @from(Start 13580065, End 13580097)
async function L59() {
  xjA()
}
// @from(Start 13580102, End 13580115)
$59 = 3600000
// @from(Start 13580119, End 13580129)
yjA = null
// @from(Start 13580135, End 13580208)
vjA = L(() => {
  O3();
  NX();
  Fn();
  jQ();
  gB();
  V0();
  g1()
})
// @from(Start 13580211, End 13580433)
function Pj3() {
  let A = N1(),
    {
      eligible: Q,
      hasCache: B
    } = N59();
  if (!Q || !B) return !1;
  if ((A.passesUpsellSeenCount ?? 0) >= 3) return !1;
  if (A.hasVisitedPasses) return !1;
  return !0
}
// @from(Start 13580435, End 13580503)
function PI1() {
  let [A] = M59.useState(() => Pj3());
  return A
}
// @from(Start 13580505, End 13580698)
function jI1() {
  let A = N1(),
    Q = (A.passesUpsellSeenCount ?? 0) + 1;
  c0({
    ...A,
    passesUpsellSeenCount: Q
  }), GA("tengu_guest_passes_upsell_shown", {
    seen_count: Q
  })
}
// @from(Start 13580700, End 13580978)
function O59() {
  return bg.createElement($, {
    dimColor: !0
  }, bg.createElement($, {
    color: "claude"
  }, "[✻]"), " ", bg.createElement($, {
    color: "claude"
  }, "[✻]"), " ", bg.createElement($, {
    color: "claude"
  }, "[✻]"), " · 3 guest passes at /passes")
}
// @from(Start 13580983, End 13580985)
bg
// @from(Start 13580987, End 13580990)
M59
// @from(Start 13580996, End 13581085)
GX0 = L(() => {
  hA();
  jQ();
  vjA();
  q0();
  bg = BA(VA(), 1), M59 = BA(VA(), 1)
})
// @from(Start 13581088, End 13582260)
function jj3() {
  if (d0.terminal === "Apple_Terminal") return b2.createElement(S, {
    flexDirection: "column",
    alignItems: "center"
  }, b2.createElement($, null, b2.createElement($, {
    color: "clawd_body"
  }, "▗"), b2.createElement($, {
    color: "clawd_background",
    backgroundColor: "clawd_body"
  }, " ", "▗", "   ", "▖", " "), b2.createElement($, {
    color: "clawd_body"
  }, "▖")), b2.createElement($, {
    backgroundColor: "clawd_body"
  }, " ".repeat(7)), b2.createElement($, {
    color: "clawd_body"
  }, "▘▘ ▝▝"));
  return b2.createElement(S, {
    flexDirection: "column"
  }, b2.createElement($, null, b2.createElement($, {
    color: "clawd_body"
  }, " ▐"), b2.createElement($, {
    color: "clawd_body",
    backgroundColor: "clawd_background"
  }, "▛███▜"), b2.createElement($, {
    color: "clawd_body"
  }, "▌")), b2.createElement($, null, b2.createElement($, {
    color: "clawd_body"
  }, "▝▜"), b2.createElement($, {
    color: "clawd_body",
    backgroundColor: "clawd_background"
  }, "█████"), b2.createElement($, {
    color: "clawd_body"
  }, "▛▘")), b2.createElement($, {
    color: "clawd_body"
  }, "  ", "▘▘ ▝▝", "  "))
}
// @from(Start 13582262, End 13583384)
function T59() {
  let {
    columns: A
  } = WB(), {
    version: Q,
    cwd: B,
    modelDisplayName: G,
    billingType: Z,
    agentName: I
  } = OI1(), Y = PI1();
  R59.useEffect(() => {
    if (Y) jI1()
  }, [Y]);
  let J = Math.max(A - 15, 20),
    X = J7(Q, Math.max(J - "Claude Code v".length, 6)),
    {
      shouldSplit: V,
      truncatedModel: F,
      truncatedBilling: K
    } = Y59(G, Z, J),
    D = " · ",
    H = I ? J - I.length - D.length : J,
    C = kjA(B, Math.max(H, 10));
  return b2.createElement(S, {
    flexDirection: "row",
    gap: 2,
    alignItems: "center"
  }, b2.createElement(jj3, null), b2.createElement(S, {
    flexDirection: "column"
  }, b2.createElement($, null, b2.createElement($, {
    bold: !0
  }, "Claude Code"), " ", b2.createElement($, {
    dimColor: !0
  }, "v", X)), V ? b2.createElement(b2.Fragment, null, b2.createElement($, {
    dimColor: !0
  }, F), b2.createElement($, {
    dimColor: !0
  }, K)) : b2.createElement($, {
    dimColor: !0
  }, F, " · ", K), b2.createElement($, {
    dimColor: !0
  }, I ? `${I} · ${C}` : C), Y && b2.createElement(O59, null)))
}
// @from(Start 13583389, End 13583391)
b2
// @from(Start 13583393, End 13583396)
R59
// @from(Start 13583402, End 13583500)
P59 = L(() => {
  hA();
  c5();
  i8();
  RI1();
  GX0();
  b2 = BA(VA(), 1), R59 = BA(VA(), 1)
})
// @from(Start 13583506, End 13583547)
bjA = L(() => {
  AQ();
  _0();
  hQ()
})
// @from(Start 13583550, End 13583946)
function ZX0() {
  let A = SI1.useMemo(_j3, []);
  if (SI1.useEffect(() => {
      yCB(j59)
    }, [A.tip]), !A.tip) return null;
  return fjA.createElement(S, {
    paddingLeft: 2,
    flexDirection: "column"
  }, fjA.createElement($, {
    ...A.color === "warning" ? {
      color: "warning"
    } : A.color === "error" ? {
      color: "error"
    } : {
      dimColor: !0
    }
  }, A.tip))
}
// @from(Start 13583948, End 13583989)
function _j3() {
  return Z7A(j59, Sj3)
}
// @from(Start 13583994, End 13583997)
fjA
// @from(Start 13583999, End 13584002)
SI1
// @from(Start 13584004, End 13584033)
j59 = "tengu-top-of-feed-tip"
// @from(Start 13584037, End 13584040)
Sj3
// @from(Start 13584046, End 13584164)
S59 = L(() => {
  hA();
  u2();
  fjA = BA(VA(), 1), SI1 = BA(VA(), 1);
  Sj3 = {
    tip: "",
    color: "dim"
  }
})
// @from(Start 13584167, End 13589513)
function k59({
  isBeforeFirstMessage: A
}) {
  let Q = r69(A),
    B = I59(),
    G = N1().oauthAccount?.displayName ?? "",
    Z = J59(3),
    {
      columns: I
    } = WB(),
    Y = MMB(),
    J = nQ.isSandboxingEnabled(),
    W = PI1(),
    X = Sg(),
    V = N1(),
    F = X.companyAnnouncements,
    [K] = hjA.useState(() => F && F.length > 0 ? V.numStartups === 1 ? F[0] : F[Math.floor(Math.random() * F.length)] : void 0),
    {
      hasReleaseNotes: D
    } = SjA(V.lastReleaseNotesSeen);
  hjA.useEffect(() => {
    let l = N1();
    if (l.lastReleaseNotesSeen === {
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.VERSION) return;
    if (c0({
        ...l,
        lastReleaseNotesSeen: {
          ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
          PACKAGE_URL: "@anthropic-ai/claude-code",
          README_URL: "https://code.claude.com/docs/en/overview",
          VERSION: "2.0.59",
          FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
        }.VERSION
      }), Y) OMB()
  }, [V, Y]), hjA.useEffect(() => {
    if (W && !Y) jI1()
  }, [W, Y]);
  let {
    version: H,
    cwd: C,
    modelDisplayName: E,
    billingType: U
  } = OI1(), q = J7(E, _59 - 20);
  if (!D && !Y && !Y0(process.env.CLAUDE_CODE_FORCE_FULL_LOGO)) return LQ.createElement(LQ.Fragment, null, LQ.createElement(S, null), LQ.createElement(T59, null), F2A() && LQ.createElement(S, {
    paddingLeft: 2,
    flexDirection: "column"
  }, LQ.createElement($, {
    color: "warning"
  }, "Debug mode enabled"), LQ.createElement($, {
    dimColor: !0
  }, "Logging to: ", gj() ? "stderr" : Ps())), LQ.createElement(ZX0, null), K && LQ.createElement(S, {
    paddingLeft: 2,
    flexDirection: "column"
  }, LQ.createElement($, null, K)), !1, !1);
  let w = Q59(I),
    N = N1().theme,
    R = ` ${ZB("claude",N)("Claude Code")} ${ZB("inactive",N)(`v${H}`)} `,
    T = ZB("claude", N)(" Claude Code ");
  if (w === "compact") {
    let k = MI1(G);
    if (k.length > I - 4) k = MI1(null);
    let m = kjA(C, I - 4);
    return LQ.createElement(LQ.Fragment, null, LQ.createElement(S, {
      flexDirection: "column",
      borderStyle: "round",
      borderColor: "claude",
      borderText: {
        content: T,
        position: "top",
        align: "start",
        offset: 1
      },
      paddingX: 1,
      paddingY: 1,
      alignItems: "center",
      width: I
    }, LQ.createElement($, {
      bold: !0
    }, k), LQ.createElement(S, {
      marginY: 1
    }, LQ.createElement(S, {
      height: 5,
      flexDirection: "column",
      justifyContent: "flex-end"
    }, LQ.createElement(S, {
      marginBottom: Q
    }, LQ.createElement(BX0, null)))), LQ.createElement($, {
      dimColor: !0
    }, q), LQ.createElement($, {
      dimColor: !0
    }, U), LQ.createElement($, {
      dimColor: !0
    }, m)), J && LQ.createElement(S, {
      marginTop: 1,
      flexDirection: "column"
    }, LQ.createElement($, {
      color: "warning"
    }, "Your bash commands will be sandboxed. Disable with /sandbox.")))
  }
  let y = MI1(G),
    v = `${q} · ${U}`,
    x = kjA(C, _59),
    p = G59(y, x, v),
    {
      leftWidth: u,
      rightWidth: e
    } = B59(I, w, p);
  return LQ.createElement(LQ.Fragment, null, LQ.createElement(S, null), LQ.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "claude",
    borderText: {
      content: R,
      position: "top",
      align: "start",
      offset: 3
    }
  }, LQ.createElement(S, {
    flexDirection: w === "horizontal" ? "row" : "column",
    paddingX: 1,
    gap: 1
  }, LQ.createElement(S, {
    flexDirection: "column",
    width: u,
    justifyContent: "space-between",
    alignItems: "center",
    minHeight: 9
  }, LQ.createElement(S, {
    marginTop: 1
  }, LQ.createElement($, {
    bold: !0
  }, y)), LQ.createElement(S, {
    height: 5,
    flexDirection: "column",
    justifyContent: "flex-end"
  }, LQ.createElement(S, {
    marginBottom: Q
  }, LQ.createElement(BX0, null))), LQ.createElement(S, {
    flexDirection: "column",
    alignItems: "center"
  }, LQ.createElement($, {
    dimColor: !0
  }, v), LQ.createElement($, {
    dimColor: !0
  }, x))), w === "horizontal" && LQ.createElement(D3, {
    orientation: "vertical",
    dividerColor: "claude"
  }), w === "horizontal" && LQ.createElement(K59, {
    feeds: Y ? [C59(Wm1()), TI1(B)] : W ? [TI1(B), E59()] : [TI1(B), H59(Z)],
    maxWidth: e
  }))), F2A() && LQ.createElement(S, {
    paddingLeft: 2,
    flexDirection: "column"
  }, LQ.createElement($, {
    color: "warning"
  }, "Debug mode enabled"), LQ.createElement($, {
    dimColor: !0
  }, "Logging to: ", gj() ? "stderr" : Ps())), LQ.createElement(ZX0, null), K && LQ.createElement(S, {
    paddingLeft: 2,
    flexDirection: "column"
  }, LQ.createElement($, null, K)), J && LQ.createElement(S, {
    paddingLeft: 2,
    flexDirection: "column"
  }, LQ.createElement($, {
    color: "warning"
  }, "Your bash commands will be sandboxed. Disable with /sandbox.")), !1, !1)
}
// @from(Start 13589518, End 13589520)
LQ
// @from(Start 13589522, End 13589525)
hjA
// @from(Start 13589527, End 13589535)
_59 = 50
// @from(Start 13589541, End 13589777)
y59 = L(() => {
  hA();
  i8();
  o69();
  RI1();
  R9();
  W59();
  D59();
  z59();
  BK();
  jQ();
  BjA();
  V0();
  N$A();
  P59();
  tXA();
  bjA();
  hQ();
  js();
  S59();
  $J();
  GX0();
  LQ = BA(VA(), 1), hjA = BA(VA(), 1)
})
// @from(Start 13589780, End 13590354)
function yj3(A, Q, B, G, Z, I, Y) {
  if (I === "transcript") return !0;
  switch (A.type) {
    case "attachment":
    case "user":
    case "assistant": {
      let J = mjA(A);
      if (!J) return !0;
      if (Q.has(J)) return !1;
      if (G.has(J)) return !1;
      if (h59(J, "PostToolUse", Y)) return !1;
      return l69(Z, B)
    }
    case "system":
      return A.subtype !== "api_error";
    case "grouped_tool_use":
      return A.messages.every((W) => {
        let X = W.message.content[0];
        return X?.type === "tool_use" && B.has(X.id)
      })
  }
}
// @from(Start 13590359, End 13590361)
I6
// @from(Start 13590363, End 13590365)
fg
// @from(Start 13590367, End 13590375)
gjA = 10
// @from(Start 13590379, End 13595044)
kj3 = ({
    messages: A,
    normalizedMessageHistory: Q,
    tools: B,
    verbose: G,
    toolJSX: Z,
    toolUseConfirmQueue: I,
    inProgressToolUseIDs: Y,
    isMessageSelectorVisible: J,
    conversationId: W,
    screen: X,
    screenToggleId: V,
    streamingToolUses: F,
    showAllInTranscript: K = !1,
    agentDefinitions: D,
    onOpenRateLimitOptions: H
  }) => {
    let {
      columns: C
    } = WB(), E = fg.useContext(k_), U = fg.useMemo(() => [...Q, ...nJ(A).filter(ujA)], [A, Q]), q = fg.useMemo(() => new Set(Object.keys(kI1(U))), [U]), w = fg.useMemo(() => g59(U), [U]), N = fg.useMemo(() => F.filter((p) => {
      if (Y.has(p.contentBlock.id)) return !1;
      if (U.some((u) => u.type === "assistant" && u.message.content[0].type === "tool_use" && u.message.content[0].id === p.contentBlock.id)) return !1;
      return !0
    }), [F, Y, U]), R = fg.useMemo(() => N.flatMap((p) => nJ([uD({
      content: [p.contentBlock]
    })])), [N]), T = fg.useMemo(() => {
      let p = X === "transcript",
        u = p && !K,
        e = G ? U : nk(U),
        l = x59(e.filter((IA) => IA.type !== "progress").filter((IA) => u59(IA, p)), R),
        k = u ? l.slice(-gjA) : l,
        m = u && l.length > gjA;
      return [{
        type: "static",
        jsx: I6.createElement(S, {
          flexDirection: "column",
          gap: 1,
          key: `logo-${W}-${V}`
        }, I6.createElement(k59, {
          isBeforeFirstMessage: !1
        }), I6.createElement(d69, {
          agentDefinitions: D
        }))
      }, ...m ? [{
        type: "static",
        jsx: I6.createElement(D3, {
          key: `truncation-indicator-${W}-${V}`,
          dividerChar: "─",
          title: `Ctrl+E to show ${tA.bold(U.length-gjA)} previous messages`,
          width: C
        })
      }] : [], ...p && K && U.length > gjA ? [{
        type: "static",
        jsx: I6.createElement(D3, {
          key: `hide-indicator-${W}-${V}`,
          dividerChar: "─",
          title: `Ctrl+E to hide ${tA.bold(U.length-gjA)} previous messages`,
          width: C
        })
      }] : [], ...(() => {
        let {
          messages: IA
        } = g69(k, B, G), FA = v59(U, k), zA = new Set(F.map((OA) => OA.contentBlock.id)), NA = (!Z || !!Z.shouldContinueAnimation) && !I.length && !J;
        return IA.map((OA) => {
          let mA = OA.type === "grouped_tool_use",
            wA = mA ? OA.displayMessage : OA,
            qA = mA ? [] : f59(OA, FA),
            KA = mA ? new Set : b59(OA, FA),
            yA = yj3(OA, zA, q, Y, KA, X, FA) ? "static" : "transient",
            oA = !1;
          if (NA)
            if (mA) oA = OA.messages.some((X1) => {
              let WA = X1.message.content[0];
              return WA?.type === "tool_use" && Y.has(WA.id)
            });
            else {
              let X1 = mjA(OA);
              oA = !X1 || Y.has(X1)
            } return {
            type: yA,
            jsx: I6.createElement(S, {
              key: `${OA.uuid}-${W}-${V}`,
              width: C,
              flexDirection: "row",
              flexWrap: "nowrap",
              alignItems: "flex-start",
              justifyContent: "space-between",
              gap: 1
            }, I6.createElement(xg, {
              message: OA,
              messages: U,
              addMargin: !0,
              tools: B,
              verbose: G,
              erroredToolUseIDs: w,
              inProgressToolUseIDs: Y,
              progressMessagesForMessage: qA,
              shouldAnimate: oA,
              shouldShowDot: !0,
              resolvedToolUseIDs: q,
              isTranscriptMode: p,
              isStatic: yA === "static",
              onOpenRateLimitOptions: H
            }), I6.createElement(i69, {
              message: wA,
              isTranscriptMode: p
            }), I6.createElement(a69, {
              message: wA,
              isTranscriptMode: p
            }))
          }
        })
      })()]
    }, [X, K, G, U, R, W, V, D, C, F, q, B, w, Y, Z, I.length, J, H]), y = Y.size > 0;
    if (E) return I6.createElement(I6.Fragment, null, T.map((p) => p.jsx), y ? I6.createElement(PjA, {
      state: "indeterminate"
    }) : I6.createElement(PjA, {
      state: "completed"
    }));
    let v = T.filter((p) => p.type === "static"),
      x = T.filter((p) => p.type === "transient");
    return I6.createElement(I6.Fragment, null, I6.createElement(Zp, {
      key: `static-messages-${W}-${V}`,
      items: v
    }, (p) => p.jsx), x.map((p) => p.jsx), y ? I6.createElement(PjA, {
      state: "indeterminate"
    }) : I6.createElement(PjA, {
      state: "completed"
    }))
  }
// @from(Start 13595048, End 13595051)
_QA
// @from(Start 13595057, End 13595669)
_I1 = L(() => {
  hA();
  hA();
  h69();
  k7A();
  cQ();
  c69();
  UjA();
  i8();
  BK();
  F9();
  n69();
  s69();
  y59();
  I6 = BA(VA(), 1), fg = BA(VA(), 1), _QA = I6.memo(kj3, (A, Q) => {
    let B = Object.keys(A);
    for (let G of B) {
      if (G === "onOpenRateLimitOptions") continue;
      if (A[G] !== Q[G]) {
        if (G === "streamingToolUses") {
          let Z = A.streamingToolUses,
            I = Q.streamingToolUses;
          if (Z.length === I.length && Z.every((Y, J) => Y.contentBlock === I[J]?.contentBlock)) continue
        }
        return !1
      }
    }
    return !0
  })
})
// @from(Start 13595672, End 13596170)
function d59(A, Q, B, G, Z) {
  let I = m59.useContext(k_);
  f1(async (Y, J) => {
    if (J.ctrl && Y === "o") {
      if (Q((W) => W === "transcript" ? "prompt" : "transcript"), B((W) => W + 1), G(!1), !I) await Z()
    }
    if (J.ctrl && Y === "e" && A === "transcript") {
      if (G((W) => !W), B((W) => W + 1), !I) await Z()
    }
    if (J.ctrl && Y === "c" && A === "transcript" || J.escape && A === "transcript") {
      if (Q("prompt"), B((W) => W + 1), G(!1), !I) await Z()
    }
  })
}
// @from(Start 13596175, End 13596178)
m59
// @from(Start 13596184, End 13596239)
c59 = L(() => {
  hA();
  k7A();
  m59 = BA(VA(), 1)
})
// @from(Start 13596242, End 13597336)
function p59(A, Q) {
  let B = djA.useRef(!1),
    G = djA.useRef(null);
  djA.useEffect(() => {
    let Z = uU(A);
    if (G.current !== Z) B.current = !1, G.current = Z || null, Q({
      lineCount: 0,
      lineStart: void 0,
      text: void 0,
      filePath: void 0
    });
    if (B.current || !Z) return;
    let I = (Y) => {
      if (Y.selection?.start && Y.selection?.end) {
        let {
          start: J,
          end: W
        } = Y.selection, X = W.line - J.line + 1;
        if (W.character === 0) X--;
        let V = {
          lineCount: X,
          lineStart: J.line,
          text: Y.text,
          filePath: Y.filePath
        };
        Q(V)
      }
    };
    Z.client.setNotificationHandler(xj3, (Y) => {
      if (G.current !== Z) return;
      try {
        let J = Y.params;
        if (J.selection && J.selection.start && J.selection.end) I(J);
        else if (J.text !== void 0) I({
          selection: null,
          text: J.text,
          filePath: J.filePath
        })
      } catch (J) {
        AA(J)
      }
    }), B.current = !0
  }, [A, Q])
}
// @from(Start 13597341, End 13597344)
djA
// @from(Start 13597346, End 13597349)
xj3
// @from(Start 13597355, End 13597840)
l59 = L(() => {
  Q2();
  nY();
  g1();
  djA = BA(VA(), 1), xj3 = j.object({
    method: j.literal("selection_changed"),
    params: j.object({
      selection: j.object({
        start: j.object({
          line: j.number(),
          character: j.number()
        }),
        end: j.object({
          line: j.number(),
          character: j.number()
        })
      }).nullable().optional(),
      text: j.string().optional(),
      filePath: j.string().optional()
    })
  })
})
// @from(Start 13597843, End 13597897)
function n59(A) {
  return A.isNonInteractiveSession
}
// @from(Start 13597899, End 13598531)
function yI1(A) {
  try {
    let Q = new i59.default({
      allErrors: !0
    });
    if (!Q.validateSchema(A)) throw Error(`Invalid JSON Schema: ${Q.errorsText(Q.errors)}`);
    let G = Q.compile(A);
    return {
      ...IX0,
      inputJSONSchema: A,
      async call(Z) {
        if (!G(Z)) {
          let Y = G.errors?.map((J) => `${J.dataPath||"root"}: ${J.message}`).join(", ");
          throw Error(`Output does not match required schema: ${Y}`)
        }
        return {
          data: "Structured output provided successfully",
          structured_output: Z
        }
      }
    }
  } catch {
    return null
  }
}
// @from(Start 13598536, End 13598539)
i59
// @from(Start 13598541, End 13598544)
vj3
// @from(Start 13598546, End 13598549)
bj3
// @from(Start 13598551, End 13598574)
Az = "StructuredOutput"
// @from(Start 13598578, End 13598581)
IX0
// @from(Start 13598587, End 13600326)
eXA = L(() => {
  Q2();
  i59 = BA(QQ1(), 1), vj3 = j.object({}).passthrough(), bj3 = j.string().describe("Structured output tool result");
  IX0 = {
    isMcp: !1,
    isEnabled() {
      return !0
    },
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    isDestructive() {
      return !1
    },
    isOpenWorld() {
      return !1
    },
    name: Az,
    async description() {
      return "Return structured output in the requested format"
    },
    async prompt() {
      return "Use this tool to return your final response in the requested structured format. You MUST call this tool exactly once at the end of your response to provide the structured output."
    },
    inputSchema: vj3,
    outputSchema: bj3,
    async call(A) {
      return {
        data: "Structured output provided successfully",
        structured_output: A
      }
    },
    async checkPermissions(A) {
      return {
        behavior: "allow",
        updatedInput: A
      }
    },
    renderToolUseMessage(A) {
      let Q = Object.keys(A);
      if (Q.length === 0) return null;
      if (Q.length <= 3) return Q.map((B) => `${B}: ${JSON.stringify(A[B])}`).join(", ");
      return `${Q.length} fields: ${Q.slice(0,3).join(", ")}…`
    },
    userFacingName: () => Az,
    renderToolUseRejectedMessage() {
      return "Structured output rejected"
    },
    renderToolUseErrorMessage() {
      return "Structured output error"
    },
    renderToolUseProgressMessage() {
      return null
    },
    renderToolResultMessage(A) {
      return A
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      return {
        tool_use_id: Q,
        type: "tool_result",
        content: A
      }
    }
  }
})
// @from(Start 13600329, End 13600500)
function fj3(A) {
  if (A instanceof n2) {
    let Q = A.error;
    if (Q?.error?.message) return Q.error.message
  }
  return A instanceof Error ? A.message : String(A)
}
// @from(Start 13600502, End 13600711)
function YX0(A) {
  let Q = new Set;
  A.forEach((B, G) => Q.add(G));
  for (let [B, G] of Object.entries(hj3))
    if (G.prefixes?.some((Z) => Array.from(Q).some((I) => I.startsWith(Z)))) return B;
  return
}
// @from(Start 13600713, End 13601066)
function JX0() {
  return {
    ...process.env.ANTHROPIC_BASE_URL ? {
      baseUrl: process.env.ANTHROPIC_BASE_URL
    } : {},
    ...process.env.ANTHROPIC_MODEL ? {
      envModel: process.env.ANTHROPIC_MODEL
    } : {},
    ...process.env.ANTHROPIC_SMALL_FAST_MODEL ? {
      envSmallFastModel: process.env.ANTHROPIC_SMALL_FAST_MODEL
    } : {}
  }
}
// @from(Start 13601068, End 13601514)
function a59({
  model: A,
  messagesLength: Q,
  temperature: B,
  betas: G,
  permissionMode: Z,
  querySource: I,
  queryTracking: Y
}) {
  GA("tengu_api_query", {
    model: A,
    messagesLength: Q,
    temperature: B,
    provider: _R(),
    ...G?.length ? {
      betas: G.join(",")
    } : {},
    permissionMode: Z,
    querySource: I,
    ...Y ? {
      queryChainId: Y.chainId,
      queryDepth: Y.depth
    } : {},
    ...JX0()
  })
}
// @from(Start 13601516, End 13602664)
function s59({
  error: A,
  model: Q,
  messageCount: B,
  messageTokens: G,
  durationMs: Z,
  durationMsIncludingRetries: I,
  attempt: Y,
  requestId: J,
  didFallBackToNonStreaming: W,
  promptCategory: X,
  headers: V,
  queryTracking: F
}) {
  let K = void 0;
  if (A instanceof n2 && A.headers) K = YX0(A.headers);
  else if (V) K = YX0(V);
  let D = fj3(A),
    H = A instanceof n2 ? String(A.status) : void 0,
    C = jI2(A);
  AA(A), GA("tengu_api_error", {
    model: Q,
    error: D,
    status: H,
    errorType: C,
    messageCount: B,
    messageTokens: G,
    durationMs: Z,
    durationMsIncludingRetries: I,
    attempt: Y,
    provider: _R(),
    requestId: J || void 0,
    didFallBackToNonStreaming: W,
    ...X ? {
      promptCategory: X
    } : {},
    ...K ? {
      gateway: K
    } : {},
    ...F ? {
      queryChainId: F.chainId,
      queryDepth: F.depth
    } : {},
    ...JX0()
  }), HO("api_error", {
    model: Q,
    error: D,
    status_code: String(H),
    duration_ms: String(Z),
    attempt: String(Y)
  }), V80({
    success: !1,
    statusCode: H ? parseInt(H) : void 0,
    error: D,
    attempt: Y
  })
}
// @from(Start 13602666, End 13603913)
function gj3({
  model: A,
  preNormalizedModel: Q,
  messageCount: B,
  messageTokens: G,
  usage: Z,
  durationMs: I,
  durationMsIncludingRetries: Y,
  attempt: J,
  ttftMs: W,
  requestId: X,
  stopReason: V,
  costUSD: F,
  didFallBackToNonStreaming: K,
  querySource: D,
  gateway: H,
  queryTracking: C,
  permissionMode: E
}) {
  let U = N6(),
    q = process.argv.includes("-p") || process.argv.includes("--print");
  GA("tengu_api_success", {
    model: A,
    ...Q !== A ? {
      preNormalizedModel: Q
    } : {},
    messageCount: B,
    messageTokens: G,
    inputTokens: Z.input_tokens,
    outputTokens: Z.output_tokens,
    cachedInputTokens: Z.cache_read_input_tokens ?? 0,
    uncachedInputTokens: Z.cache_creation_input_tokens ?? 0,
    durationMs: I,
    durationMsIncludingRetries: Y,
    attempt: J,
    ttftMs: W ?? void 0,
    provider: _R(),
    requestId: X ?? void 0,
    stop_reason: V ?? void 0,
    costUSD: F,
    didFallBackToNonStreaming: K,
    isNonInteractiveSession: U,
    print: q,
    isTTY: process.stdout.isTTY ?? !1,
    querySource: D,
    ...H ? {
      gateway: H
    } : {},
    ...C ? {
      queryChainId: C.chainId,
      queryDepth: C.depth
    } : {},
    permissionMode: E,
    ...JX0()
  })
}
// @from(Start 13603915, End 13605213)
function r59({
  model: A,
  preNormalizedModel: Q,
  start: B,
  startIncludingRetries: G,
  ttftMs: Z,
  usage: I,
  attempt: Y,
  messageCount: J,
  messageTokens: W,
  requestId: X,
  stopReason: V,
  didFallBackToNonStreaming: F,
  querySource: K,
  headers: D,
  costUSD: H,
  queryTracking: C,
  permissionMode: E
}) {
  let U = D ? YX0(D) : void 0,
    q = Date.now() - B,
    w = Date.now() - G;
  ME0(w, q), gj3({
    model: A,
    preNormalizedModel: Q,
    messageCount: J,
    messageTokens: W,
    usage: I,
    durationMs: q,
    durationMsIncludingRetries: w,
    attempt: Y,
    ttftMs: Z,
    requestId: X,
    stopReason: V,
    costUSD: H,
    didFallBackToNonStreaming: F,
    querySource: K,
    gateway: U,
    queryTracking: C,
    permissionMode: E
  }), HO("api_request", {
    model: A,
    input_tokens: String(I.input_tokens),
    output_tokens: String(I.output_tokens),
    cache_read_tokens: String(I.cache_read_input_tokens),
    cache_creation_tokens: String(I.cache_creation_input_tokens),
    cost_usd: String(H),
    duration_ms: String(q)
  }), V80({
    success: !0,
    inputTokens: I.input_tokens,
    outputTokens: I.output_tokens,
    cacheReadTokens: I.cache_read_input_tokens,
    cacheCreationTokens: I.cache_creation_input_tokens,
    attempt: Y
  })
}
// @from(Start 13605218, End 13605221)
hj3
// @from(Start 13605223, End 13605225)
bO
// @from(Start 13605231, End 13605895)
cjA = L(() => {
  p_();
  g1();
  lK();
  q0();
  oJA();
  F0A();
  _0();
  ZO();
  hj3 = {
    litellm: {
      prefixes: ["x-litellm-"]
    },
    helicone: {
      prefixes: ["helicone-"]
    },
    portkey: {
      prefixes: ["x-portkey-"]
    },
    "cloudflare-ai-gateway": {
      prefixes: ["cf-aig-"]
    }
  };
  bO = {
    input_tokens: 0,
    cache_creation_input_tokens: 0,
    cache_read_input_tokens: 0,
    output_tokens: 0,
    server_tool_use: {
      web_search_requests: 0,
      web_fetch_requests: 0
    },
    service_tier: "standard",
    cache_creation: {
      ephemeral_1h_input_tokens: 0,
      ephemeral_5m_input_tokens: 0
    }
  }
})
// @from(Start 13605947, End 13606854)
async function* mj3(A, Q, B, G) {
  let {
    permissionResult: Z,
    assistantMessage: I
  } = A, {
    toolUseID: Y
  } = Z;
  if (!Y) return;
  let J = I.message.content,
    W;
  if (Array.isArray(J)) {
    for (let C of J)
      if (C.type === "tool_use" && C.id === Y) {
        W = C;
        break
      }
  }
  if (!W) return;
  let {
    name: X,
    input: V
  } = W;
  if (!Q.find((C) => C.name === X)) return;
  let K = {
      ...W,
      input: Z.behavior === "allow" ? Z.updatedInput : V
    },
    D = async () => ({
      ...Z,
      decisionReason: {
        type: "mode",
        mode: "default"
      }
    });
  B.push(I), await y0A(B), yield {
    ...I,
    session_id: e1(),
    parent_tool_use_id: null
  };
  for await (let C of VX0([K], [I], D, G)) if (C.message) B.push(C.message), await y0A(B), yield {
    ...C.message,
    session_id: e1(),
    parent_tool_use_id: null
  }
}
// @from(Start 13606856, End 13607257)
function dj3(A) {
  if (!A) return !1;
  if (A.type === "assistant") {
    let Q = dC(A.message.content);
    return Q?.type === "text" || Q?.type === "thinking" || Q?.type === "redacted_thinking"
  }
  if (A.type === "user") {
    let Q = A.message.content;
    if (!Array.isArray(Q) || Q.length === 0) return !1;
    return Q.every((B) => ("type" in B) && B.type === "tool_result")
  }
  return !1
}
// @from(Start 13607258, End 13619394)
async function* o59({
  commands: A,
  prompt: Q,
  promptUuid: B,
  cwd: G,
  tools: Z,
  mcpClients: I,
  verbose: Y = !1,
  maxThinkingTokens: J,
  maxTurns: W,
  maxBudgetUsd: X,
  canUseTool: V,
  mutableMessages: F = [],
  customSystemPrompt: K,
  appendSystemPrompt: D,
  userSpecifiedModel: H,
  fallbackModel: C,
  sdkBetas: E,
  jsonSchema: U,
  getAppState: q,
  setAppState: w,
  abortController: N,
  replayUserMessages: R = !1,
  includePartialMessages: T = !1,
  agents: y = [],
  setSDKStatus: v,
  orphanedPermission: x
}) {
  Bq(G);
  let p = Date.now(),
    u = [],
    e = async (_1, zQ, W1, O1, a1, C0) => {
      let v0 = await V(_1, zQ, W1, O1, a1, C0);
      if (v0.behavior !== "allow") {
        let k0 = {
          tool_name: _1.name,
          tool_use_id: a1,
          tool_input: zQ
        };
        u.push(k0)
      }
      return v0
    }, l = await q(), k = H ? UD(H) : k3(), [m, o, IA] = await Promise.all([Tn(Z, k, Array.from(l.toolPermissionContext.additionalWorkingDirectories.keys()), I, l.toolPermissionContext), DK(), typeof K === "string" ? Promise.resolve({}) : iD()]), FA = [...typeof K === "string" ? [K] : m, ...D ? [D] : []], zA = typeof D === "string", NA = Z.some((_1) => _1.name === Az);
  if (U && NA) s21(w, e1(), "Stop", "", (_1) => bI1(_1, Az), `You MUST call the ${Az} tool to complete this request. Call this tool now.`, {
    timeout: 5000
  });
  let OA = {
    messages: F,
    setMessages: () => {},
    onChangeAPIKey: () => {},
    options: {
      commands: A,
      debug: !1,
      tools: Z,
      verbose: Y,
      mainLoopModel: k,
      maxThinkingTokens: J ?? 0,
      mcpClients: I,
      mcpResources: {},
      ideInstallationStatus: null,
      isNonInteractiveSession: !0,
      hasAppendSystemPrompt: zA,
      agentDefinitions: {
        activeAgents: y,
        allAgents: []
      },
      theme: N1().theme,
      maxBudgetUsd: X,
      sdkBetas: E
    },
    getAppState: q,
    setAppState: w,
    abortController: N ?? o9(),
    readFileState: xI1(F, G),
    setInProgressToolUseIDs: () => {},
    setResponseLength: () => {},
    updateFileHistoryState: (_1) => {
      w((zQ) => ({
        ...zQ,
        fileHistory: _1(zQ.fileHistory)
      }))
    },
    agentId: e1(),
    setSDKStatus: v
  };
  if (x)
    for await (let _1 of mj3(x, Z, F, OA)) yield _1;
  let {
    messages: mA,
    shouldQuery: wA,
    allowedTools: qA,
    maxThinkingTokens: KA,
    model: yA
  } = await TP({
    input: Q,
    mode: "prompt",
    setIsLoading: () => {},
    setToolJSX: () => {},
    context: {
      ...OA,
      messages: F
    },
    messages: F,
    uuid: B,
    querySource: "sdk"
  });
  F.push(...mA);
  let oA = J ?? KA ?? 0,
    X1 = [...F],
    WA = mA.filter((_1) => _1.type === "user" && !_1.isMeta && !_1.toolUseResult || _1.type === "system" && _1.subtype === "compact_boundary"),
    EA = R ? WA : [];
  w((_1) => ({
    ..._1,
    toolPermissionContext: {
      ..._1.toolPermissionContext,
      alwaysAllowRules: {
        ..._1.toolPermissionContext.alwaysAllowRules,
        command: qA
      }
    }
  }));
  let MA = yA ?? k,
    DA = xI1(X1, G),
    $A = X01(DA, OA.readFileState);
  OA = {
    messages: X1,
    setMessages: () => {},
    onChangeAPIKey: () => {},
    options: {
      commands: A,
      debug: !1,
      tools: Z,
      verbose: Y,
      mainLoopModel: MA,
      maxThinkingTokens: oA,
      mcpClients: I,
      mcpResources: {},
      ideInstallationStatus: null,
      isNonInteractiveSession: !0,
      hasAppendSystemPrompt: zA,
      theme: N1().theme,
      agentDefinitions: {
        activeAgents: y,
        allAgents: []
      },
      maxBudgetUsd: X,
      sdkBetas: E
    },
    getAppState: q,
    setAppState: w,
    abortController: N || o9(),
    readFileState: $A,
    setInProgressToolUseIDs: () => {},
    setResponseLength: () => {},
    updateFileHistoryState: OA.updateFileHistoryState,
    agentId: e1(),
    setSDKStatus: v
  };
  let rA = l0()?.outputStyle ?? wK,
    [iA, {
      enabled: J1
    }] = await Promise.all([n51(), l7()]);
  if (yield {
      type: "system",
      subtype: "init",
      cwd: G,
      session_id: e1(),
      tools: Z.map((_1) => _1.name),
      mcp_servers: I.map((_1) => ({
        name: _1.name,
        status: _1.type
      })),
      model: MA,
      permissionMode: l.toolPermissionContext.mode,
      slash_commands: A.map((_1) => _1.name),
      apiKeySource: cw().source,
      betas: E,
      claude_code_version: {
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.VERSION,
      output_style: rA,
      agents: y.map((_1) => _1.agentType),
      skills: iA.map((_1) => _1.name),
      plugins: J1.map((_1) => ({
        name: _1.name,
        path: _1.path
      })),
      uuid: Ha()
    }, !wA) {
    for (let _1 of WA) {
      if (_1.type === "user" && typeof _1.message.content === "string" && (_1.message.content.includes("<local-command-stdout>") || _1.message.content.includes("<local-command-stderr>") || _1.isCompactSummary)) X1.push(_1), yield {
        type: "user",
        message: {
          ..._1.message,
          content: cY(_1.message.content)
        },
        session_id: e1(),
        parent_tool_use_id: null,
        uuid: _1.uuid,
        isReplay: !_1.isCompactSummary
      };
      if (_1.type === "system" && _1.subtype === "compact_boundary") X1.push(_1), yield {
        type: "system",
        subtype: "compact_boundary",
        session_id: e1(),
        uuid: _1.uuid,
        compact_metadata: {
          trigger: _1.compactMetadata.trigger,
          pre_tokens: _1.compactMetadata.preTokens
        }
      }
    }
    await y0A(X1), yield {
      type: "result",
      subtype: "success",
      is_error: !1,
      duration_ms: Date.now() - p,
      duration_api_ms: gN(),
      num_turns: X1.length - 1,
      result: "",
      session_id: e1(),
      total_cost_usd: hK(),
      usage: bO,
      modelUsage: {},
      permission_denials: u,
      uuid: Ha()
    };
    return
  }
  if (EG()) mA.filter(yn).forEach((_1) => {
    yYA((zQ) => {
      w((W1) => ({
        ...W1,
        fileHistory: zQ(W1.fileHistory)
      }))
    }, _1.uuid)
  });
  let w1 = bO,
    jA = bO,
    eA = 1,
    t1 = !1,
    v1, F0 = U ? WX0(F, Az) : 0;
  for await (let _1 of O$({
    messages: X1,
    systemPrompt: FA,
    userContext: o,
    systemContext: IA,
    canUseTool: e,
    toolUseContext: OA,
    fallbackModel: C,
    querySource: "sdk"
  })) {
    if (_1.type === "assistant" || _1.type === "user" || _1.type === "system" && _1.subtype === "compact_boundary") {
      if (X1.push(_1), await y0A(X1), !t1 && EA.length > 0) {
        t1 = !0;
        for (let zQ of EA)
          if (zQ.type === "user") yield {
            type: "user",
            message: zQ.message,
            session_id: e1(),
            parent_tool_use_id: null,
            uuid: zQ.uuid,
            isReplay: !0
          }
      }
    }
    if (_1.type === "user") eA++;
    switch (_1.type) {
      case "assistant":
      case "progress":
      case "user":
        F.push(_1), yield* pj3(_1);
        break;
      case "stream_event":
        if (_1.event.type === "message_start") jA = bO, jA = ljA(jA, _1.event.message.usage);
        if (_1.event.type === "message_delta") jA = ljA(jA, _1.event.usage);
        if (_1.event.type === "message_stop") w1 = vI1(w1, jA);
        if (T) yield {
          type: "stream_event",
          event: _1.event,
          session_id: e1(),
          parent_tool_use_id: null,
          uuid: Ha()
        };
        break;
      case "attachment":
        if (F.push(_1), IY2(_1.attachment)) yield {
          type: "system",
          subtype: "hook_response",
          session_id: e1(),
          uuid: _1.uuid,
          hook_name: _1.attachment.hookName,
          hook_event: _1.attachment.hookEvent,
          stdout: _1.attachment.stdout,
          stderr: _1.attachment.stderr,
          exit_code: _1.attachment.exitCode
        };
        else if (m91(_1.attachment)) yield {
          type: "system",
          subtype: "hook_response",
          session_id: e1(),
          uuid: _1.uuid,
          hook_name: _1.attachment.hookName,
          hook_event: _1.attachment.hookEvent,
          stdout: _1.attachment.stdout || "",
          stderr: _1.attachment.stderr || "",
          exit_code: _1.attachment.exitCode
        };
        else if (R && u91(_1)) {
          let zQ = _1.attachment;
          if (zQ.type === "queued_command") yield {
            type: "user",
            message: {
              role: "user",
              content: typeof zQ.prompt === "string" ? zQ.prompt : zQ.prompt
            },
            session_id: e1(),
            parent_tool_use_id: null,
            uuid: zQ.source_uuid || _1.uuid,
            isReplay: !0
          }
        } else if (_1.attachment.type === "structured_output") v1 = _1.attachment.data;
        break;
      case "stream_request_start":
        break;
      case "system":
        if (F.push(_1), _1.subtype === "compact_boundary" && _1.compactMetadata) yield {
          type: "system",
          subtype: "compact_boundary",
          session_id: e1(),
          uuid: _1.uuid,
          compact_metadata: {
            trigger: _1.compactMetadata.trigger,
            pre_tokens: _1.compactMetadata.preTokens
          }
        };
        break
    }
    if (_1.type === "user" && W && eA >= W) {
      yield {
        type: "result",
        subtype: "error_max_turns",
        duration_ms: Date.now() - p,
        duration_api_ms: gN(),
        is_error: !1,
        num_turns: eA,
        session_id: e1(),
        total_cost_usd: hK(),
        usage: w1,
        modelUsage: ru(),
        permission_denials: u,
        uuid: Ha(),
        errors: []
      };
      return
    }
    if (X !== void 0 && hK() >= X) {
      yield {
        type: "result",
        subtype: "error_max_budget_usd",
        duration_ms: Date.now() - p,
        duration_api_ms: gN(),
        is_error: !1,
        num_turns: eA,
        session_id: e1(),
        total_cost_usd: hK(),
        usage: w1,
        modelUsage: ru(),
        permission_denials: u,
        uuid: Ha(),
        errors: []
      };
      return
    }
    if (_1.type === "user" && U) {
      let W1 = WX0(F, Az) - F0,
        O1 = parseInt(process.env.MAX_STRUCTURED_OUTPUT_RETRIES || "5", 10);
      if (W1 >= O1) {
        yield {
          type: "result",
          subtype: "error_max_structured_output_retries",
          duration_ms: Date.now() - p,
          duration_api_ms: gN(),
          is_error: !1,
          num_turns: eA,
          session_id: e1(),
          total_cost_usd: hK(),
          usage: w1,
          modelUsage: ru(),
          permission_denials: u,
          uuid: Ha(),
          errors: [`Failed to provide valid structured output after ${O1} attempts`]
        };
        return
      }
    }
  }
  let g0 = dC(X1);
  if (!dj3(g0)) {
    yield {
      type: "result",
      subtype: "error_during_execution",
      duration_ms: Date.now() - p,
      duration_api_ms: gN(),
      is_error: !1,
      num_turns: eA,
      session_id: e1(),
      total_cost_usd: hK(),
      usage: w1,
      modelUsage: ru(),
      permission_denials: u,
      uuid: Ha(),
      errors: z2A().map((_1) => _1.error)
    };
    return
  }
  let p0 = "",
    n0 = !1;
  if (g0.type === "assistant") {
    let _1 = dC(g0.message.content);
    if (_1?.type === "text") p0 = _1.text;
    n0 = Boolean(g0.isApiErrorMessage)
  }
  yield {
    type: "result",
    subtype: "success",
    is_error: n0,
    duration_ms: Date.now() - p,
    duration_api_ms: gN(),
    num_turns: eA,
    result: p0,
    session_id: e1(),
    total_cost_usd: hK(),
    usage: w1,
    modelUsage: ru(),
    permission_denials: u,
    structured_output: v1,
    uuid: Ha()
  }
}
// @from(Start 13619396, End 13621421)
function* pj3(A) {
  switch (A.type) {
    case "assistant":
      for (let Q of nJ([A])) yield {
        type: "assistant",
        message: Q.message,
        parent_tool_use_id: null,
        session_id: e1(),
        uuid: Q.uuid,
        error: Q.error
      };
      return;
    case "progress":
      if (A.data.type === "agent_progress")
        for (let Q of nJ([A.data.message])) switch (Q.type) {
          case "assistant":
            yield {
              type: "assistant", message: Q.message, parent_tool_use_id: A.parentToolUseID, session_id: e1(), uuid: Q.uuid, error: Q.error
            };
            break;
          case "user":
            yield {
              type: "user", message: Q.message, parent_tool_use_id: A.parentToolUseID, session_id: e1(), uuid: Q.uuid, isSynthetic: Q.isMeta || Q.isVisibleInTranscriptOnly, tool_use_result: Q.toolUseResult
            };
            break
        } else if (A.data.type === "bash_progress") {
          if (!process.env.CLAUDE_CODE_REMOTE && !process.env.CLAUDE_CODE_CONTAINER_ID) break;
          let Q = A.parentToolUseID,
            B = Date.now(),
            G = pjA.get(Q) || 0;
          if (B - G >= 60000) {
            if (pjA.size >= cj3) {
              let I = pjA.keys().next().value;
              if (I !== void 0) pjA.delete(I)
            }
            pjA.set(Q, B), yield {
              type: "tool_progress",
              tool_use_id: A.toolUseID,
              tool_name: "Bash",
              parent_tool_use_id: A.parentToolUseID,
              elapsed_time_seconds: A.data.elapsedTimeSeconds,
              session_id: e1(),
              uuid: A.uuid
            }
          }
        } break;
    case "user":
      for (let Q of nJ([A])) yield {
        type: "user",
        message: Q.message,
        parent_tool_use_id: null,
        session_id: e1(),
        uuid: Q.uuid,
        isSynthetic: Q.isMeta || Q.isVisibleInTranscriptOnly,
        tool_use_result: Q.toolUseResult
      };
      return;
    default:
  }
}
// @from(Start 13621423, End 13623258)
function xI1(A, Q, B = uj3) {
  let G = Gh(B),
    Z = new Map,
    I = new Map;
  for (let Y of A)
    if (Y.type === "assistant" && Array.isArray(Y.message.content)) {
      for (let J of Y.message.content)
        if (J.type === "tool_use" && J.name === d5) {
          let W = J.input;
          if (W?.file_path && W?.offset === void 0 && W?.limit === void 0) {
            let X = b9(W.file_path, Q);
            Z.set(J.id, X)
          }
        } else if (J.type === "tool_use" && J.name === wX) {
        let W = J.input;
        if (W?.file_path && W?.content) {
          let X = b9(W.file_path, Q);
          I.set(J.id, {
            filePath: X,
            content: W.content
          })
        }
      }
    } for (let Y of A)
    if (Y.type === "user" && Array.isArray(Y.message.content)) {
      for (let J of Y.message.content)
        if (J.type === "tool_result" && J.tool_use_id) {
          let W = Z.get(J.tool_use_id);
          if (W && typeof J.content === "string") {
            let K = J.content.replace(/<system-reminder>[\s\S]*?<\/system-reminder>/g, "").split(`
`).map((D) => {
              let H = D.match(/^\s*\d+→(.*)$/);
              return H ? H[1] : D
            }).join(`
`).trim();
            if (Y.timestamp) {
              let D = new Date(Y.timestamp).getTime();
              G.set(W, {
                content: K,
                timestamp: D,
                offset: void 0,
                limit: void 0
              })
            }
          }
          let X = I.get(J.tool_use_id);
          if (X && Y.timestamp) {
            let V = new Date(Y.timestamp).getTime();
            G.set(X.filePath, {
              content: X.content,
              timestamp: V,
              offset: void 0,
              limit: void 0
            })
          }
        }
    } return G
}
// @from(Start 13623263, End 13623271)
uj3 = 10
// @from(Start 13623275, End 13623284)
cj3 = 100
// @from(Start 13623288, End 13623291)
pjA
// @from(Start 13623297, End 13623585)
XX0 = L(() => {
  E9A();
  cE();
  Pn();
  Ty();
  M_();
  Ca();
  vM();
  wF();
  YS();
  u_();
  yI();
  S7();
  cQ();
  eXA();
  AWA();
  _0();
  t2();
  jMA();
  ET();
  gB();
  IO();
  cjA();
  fZ();
  jQ();
  OZ();
  Gx();
  MB();
  fV();
  g1();
  sU();
  zTA();
  pjA = new Map
})
// @from(Start 13623588, End 13623757)
function lj3() {
  return BZ("cache_warming", "config", {
    enabled: !1,
    idleThresholdMs: 240000,
    subsequentWarmupIntervalMs: 300000,
    maxRequests: 1
  })
}
// @from(Start 13623759, End 13625628)
function t59(A, Q) {
  let B = fI1.useRef(null);
  fI1.useEffect(() => {
    let G = lj3();
    if (!G.enabled) return;
    if (A || Q === 0) {
      if (B.current) B.current.abort(), B.current = null;
      return
    }
    let Z = 0,
      I = null,
      Y = async () => {
        let W = NkA();
        if (!W) {
          g("Cache warming: No previous API request to replay");
          return
        }
        if (B.current) B.current.abort();
        B.current = o9();
        try {
          g(`Cache warming: Sending request ${Z+1}/${G.maxRequests}`);
          let X = {
              ...W,
              messages: [...W.messages, {
                role: "user",
                content: 'Reply with just "OK"'
              }],
              max_tokens: 10
            },
            F = (await Kq({
              maxRetries: 0,
              model: W.model
            })).beta.messages.stream(X, {
              signal: B.current.signal
            });
          for await (let H of F) if (B.current?.signal.aborted) break;
          let D = (await F.finalMessage()).usage;
          if (g("Cache warming: Request completed"), GA("tengu_cache_warming_request", {
              warmup_number: Z + 1,
              cache_read_tokens: D.cache_read_input_tokens ?? 0,
              cache_creation_tokens: D.cache_creation_input_tokens ?? 0,
              input_tokens: D.input_tokens,
              output_tokens: D.output_tokens
            }), Z++, Z < G.maxRequests) J(G.subsequentWarmupIntervalMs)
        } catch (X) {
          if (X instanceof Error) AA(X)
        } finally {
          B.current = null
        }
      }, J = (W) => {
        I = setTimeout(() => {
          Y()
        }, W)
      };
    return J(G.idleThresholdMs), () => {
      if (I) clearTimeout(I);
      if (B.current) B.current.abort(), B.current = null
    }
  }, [A, Q])
}
// @from(Start 13625633, End 13625636)
fI1
// @from(Start 13625642, End 13625737)
e59 = L(() => {
  oZA();
  _0();
  V0();
  OZ();
  u2();
  q0();
  g1();
  fI1 = BA(VA(), 1)
})
// @from(Start 13625740, End 13626557)
function Q39({
  autoConnectIdeFlag: A,
  ideToInstallExtension: Q,
  setDynamicMcpConfig: B,
  setShowIdeOnboarding: G,
  setIDEInstallationState: Z
}) {
  A39.useEffect(() => {
    function I(Y) {
      if (!Y) return;
      if (!((N1().autoConnectIde || A || bV() || Q || Y0(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE)) && !_j(process.env.CLAUDE_CODE_AUTO_CONNECT_IDE))) return;
      B((X) => {
        if (X?.ide) return X;
        return {
          ...X,
          ide: {
            type: Y.url.startsWith("ws:") ? "ws-ide" : "sse-ide",
            url: Y.url,
            ideName: Y.name,
            authToken: Y.authToken,
            ideRunningInWindows: Y.ideRunningInWindows,
            scope: "dynamic"
          }
        }
      })
    }
    WB2(I, Q, () => G(!0), (Y) => Z(Y))
  }, [A, Q, B, G, Z])
}
// @from(Start 13626562, End 13626565)
A39
// @from(Start 13626571, End 13626633)
B39 = L(() => {
  jQ();
  nY();
  hQ();
  A39 = BA(VA(), 1)
})
// @from(Start 13626639, End 13626704)
ijA = L(() => {
  _8();
  U2();
  AQ();
  PV();
  V0();
  jQ()
})
// @from(Start 13626710, End 13626713)
FX0
// @from(Start 13626719, End 13626822)
G39 = L(() => {
  hA();
  S5();
  ijA();
  DY();
  u_();
  _8();
  q0();
  Mi();
  FX0 = BA(VA(), 1)
})
// @from(Start 13626828, End 13626831)
DvZ
// @from(Start 13626837, End 13626892)
Z39 = L(() => {
  G39();
  kW();
  DvZ = BA(VA(), 1)
})
// @from(Start 13626895, End 13626944)
function aj3() {
  return as(nj3) ?? "Goodbye!"
}
// @from(Start 13626949, End 13626952)
ij3
// @from(Start 13626954, End 13626957)
nj3
// @from(Start 13626959, End 13626962)
sj3
// @from(Start 13626964, End 13626967)
hI1
// @from(Start 13626973, End 13627410)
KX0 = L(() => {
  LxA();
  kW();
  ijA();
  Z39();
  ij3 = BA(VA(), 1), nj3 = ["Goodbye!", "See ya!", "Bye!", "Catch you later!"];
  sj3 = {
    type: "local-jsx",
    name: "exit",
    aliases: ["quit"],
    description: "Exit the REPL",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A) {
      return A(aj3()), await v6(0, "prompt_input_exit"), null
    },
    userFacingName() {
      return "exit"
    }
  }, hI1 = sj3
})
// @from(Start 13627413, End 13628287)
function I39() {
  let [A, Q] = Qj.useState(vH.getInstance().getStatus());
  if (Qj.useEffect(() => {
      return vH.getInstance().subscribe(Q)
    }, []), !A.isAuthenticating && !A.error && A.output.length === 0) return null;
  if (!A.isAuthenticating && !A.error) return null;
  return Qj.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "permission",
    paddingX: 1,
    marginY: 1
  }, Qj.default.createElement($, {
    bold: !0,
    color: "permission"
  }, "AWS Authentication"), A.output.length > 0 && Qj.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, A.output.slice(-5).map((B, G) => Qj.default.createElement($, {
    key: G,
    dimColor: !0
  }, B))), A.error && Qj.default.createElement(S, {
    marginTop: 1
  }, Qj.default.createElement($, {
    color: "error"
  }, A.error)))
}
// @from(Start 13628292, End 13628294)
Qj
// @from(Start 13628300, End 13628345)
Y39 = L(() => {
  hA();
  Qj = BA(VA(), 1)
})
// @from(Start 13628394, End 13628912)
function gI1({
  hideThanksAfterMs: A,
  onOpen: Q,
  onSelect: B
}) {
  let [G, Z] = Ea.useState("closed"), I = Ea.useRef(J39()), Y = Ea.useCallback(() => {
    Z("thanks"), setTimeout(() => Z("closed"), A)
  }, [A]), J = Ea.useCallback(() => {
    if (G !== "closed") return;
    Z("open"), I.current = J39(), Q(I.current)
  }, [G, Q]), W = Ea.useCallback((X) => {
    if (X === "dismissed") Z("closed");
    else Y();
    B(I.current, X)
  }, [Y, B]);
  return {
    state: G,
    open: J,
    handleSelect: W
  }
}
// @from(Start 13628917, End 13628919)
Ea
// @from(Start 13628925, End 13628962)
DX0 = L(() => {
  Ea = BA(VA(), 1)
})
// @from(Start 13628965, End 13631578)
function W39(A, Q, B, G = "session") {
  let Z = R$.useRef("unknown");
  Z.current = AVA(A)?.message?.id || "unknown";
  let [I, Y] = OQ(), J = snA("tengu_feedback_survey_config", rj3), W = R$.useRef(Date.now()), X = R$.useRef(B), V = R$.useRef(B);
  V.current = B;
  let F = R$.useCallback((N, R) => {
      Y((T) => ({
        ...T,
        feedbackSurvey: {
          timeLastShown: N,
          submitCountAtLastAppearance: R
        }
      }))
    }, [Y]),
    K = R$.useCallback((N) => {
      F(Date.now(), V.current), GA("tengu_feedback_survey_event", {
        event_type: "appeared",
        appearance_id: N,
        last_assistant_message_id: Z.current,
        survey_type: G
      })
    }, [F, G]),
    D = R$.useCallback((N, R) => {
      F(Date.now(), V.current), GA("tengu_feedback_survey_event", {
        event_type: "responded",
        appearance_id: N,
        response: R,
        last_assistant_message_id: Z.current,
        survey_type: G
      })
    }, [F, G]),
    {
      state: H,
      open: C,
      handleSelect: E
    } = gI1({
      hideThanksAfterMs: J.hideThanksAfterMs,
      onOpen: K,
      onSelect: D
    }),
    U = k3(),
    q = R$.useMemo(() => {
      if (J.onForModels.length === 0) return !1;
      if (J.onForModels.includes("*")) return !0;
      return J.onForModels.includes(U)
    }, [J.onForModels, U]),
    w = R$.useMemo(() => {
      if (H !== "closed") return !1;
      if (Q) return !1;
      if (process.env.CLAUDE_FORCE_DISPLAY_SURVEY && !I.feedbackSurvey.timeLastShown) return !0;
      if (!q) return !1;
      if (Y0(process.env.CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY)) return !1;
      if (fX()) return !1;
      if (I.feedbackSurvey.timeLastShown) {
        if (I.feedbackSurvey.submitCountAtLastAppearance !== null && B < I.feedbackSurvey.submitCountAtLastAppearance + J.minUserTurnsBetweenFeedback) return !1
      } else {
        if (Date.now() - W.current < J.minTimeBeforeFeedbackMs) return !1;
        if (B < X.current + J.minUserTurnsBeforeFeedback) return !1
      }
      if (Math.random() > J.probability) return !1;
      let N = N1().feedbackSurveyState;
      if (N?.lastShownTime) {
        if (Date.now() - N.lastShownTime < J.minTimeBetweenGlobalFeedbackMs) return !1
      }
      return !0
    }, [H, Q, q, I.feedbackSurvey.timeLastShown, I.feedbackSurvey.submitCountAtLastAppearance, B, J.minTimeBetweenGlobalFeedbackMs, J.minUserTurnsBetweenFeedback, J.minTimeBeforeFeedbackMs, J.minUserTurnsBeforeFeedback, J.probability]);
  return R$.useEffect(() => {
    if (w) C()
  }, [w, C]), {
    state: H,
    handleSelect: E
  }
}
// @from(Start 13631583, End 13631585)
R$
// @from(Start 13631587, End 13631590)
rj3
// @from(Start 13631596, End 13631945)
X39 = L(() => {
  u2();
  q0();
  Ft();
  jQ();
  t2();
  hQ();
  z9();
  cQ();
  DX0();
  R$ = BA(VA(), 1), rj3 = {
    minTimeBeforeFeedbackMs: 600000,
    minTimeBetweenGlobalFeedbackMs: 1e8,
    minUserTurnsBeforeFeedback: 5,
    minUserTurnsBetweenFeedback: 10,
    hideThanksAfterMs: 3000,
    onForModels: ["*"],
    probability: 0.005
  }
})
// @from(Start 13631948, End 13632188)
function ej3(A, Q) {
  let B = A.findIndex((G) => G.uuid === Q);
  if (B === -1) return !1;
  for (let G = B + 1; G < A.length; G++) {
    let Z = A[G];
    if (Z && (Z.type === "user" || Z.type === "assistant")) return !0
  }
  return !1
}
// @from(Start 13632190, End 13633491)
function V39(A, Q) {
  let [B, G] = BN.useState(null), Z = BN.useRef(new Set), I = BN.useRef(null), Y = BN.useCallback(async (K) => {
    let D = await b91();
    GA("tengu_post_compact_survey_event", {
      event_type: "appeared",
      appearance_id: K,
      session_memory_compaction_enabled: D
    })
  }, []), J = BN.useCallback(async (K, D) => {
    let H = await b91();
    GA("tengu_post_compact_survey_event", {
      event_type: "responded",
      appearance_id: K,
      response: D,
      session_memory_compaction_enabled: H
    })
  }, []), {
    state: W,
    open: X,
    handleSelect: V
  } = gI1({
    hideThanksAfterMs: oj3,
    onOpen: Y,
    onSelect: J
  });
  BN.useEffect(() => {
    hX(tj3).then(G)
  }, []);
  let F = BN.useMemo(() => new Set(A.filter((K) => lh(K)).map((K) => K.uuid)), [A]);
  return BN.useEffect(() => {
    if (W !== "closed" || Q) return;
    if (fX()) return;
    if (Y0(process.env.CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY)) return;
    if (I.current !== null) {
      if (ej3(A, I.current)) {
        I.current = null, X();
        return
      }
    }
    let K = Array.from(F).filter((D) => !Z.current.has(D));
    if (K.length > 0) Z.current = new Set(F), I.current = K[K.length - 1]
  }, [F, W, Q, B, A, X]), {
    state: W,
    handleSelect: V
  }
}
// @from(Start 13633496, End 13633498)
BN
// @from(Start 13633500, End 13633510)
oj3 = 3000
// @from(Start 13633514, End 13633547)
tj3 = "tengu_post_compact_survey"
// @from(Start 13633553, End 13633648)
F39 = L(() => {
  u2();
  q0();
  Ft();
  hQ();
  cQ();
  DX0();
  h91();
  BN = BA(VA(), 1)
})
// @from(Start 13633651, End 13634616)
function K39({
  onSelect: A,
  inputValue: Q,
  setInputValue: B,
  message: G = BS3
}) {
  let Z = qK.useRef(Q);
  return qK.useEffect(() => {
    if (Q !== Z.current) {
      let I = Q.slice(-1);
      if (HX0(I)) B(Q.slice(0, -1)), A(QS3[I])
    }
  }, [Q, A, B]), qK.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, qK.default.createElement(S, null, qK.default.createElement($, null, tA.cyan("● ")), qK.default.createElement($, {
    bold: !0
  }, G)), qK.default.createElement(S, {
    marginLeft: 2
  }, qK.default.createElement(S, {
    width: 10
  }, qK.default.createElement($, null, tA.cyan("1"), ": Bad")), qK.default.createElement(S, {
    width: 10
  }, qK.default.createElement($, null, tA.cyan("2"), ": Fine")), qK.default.createElement(S, {
    width: 10
  }, qK.default.createElement($, null, tA.cyan("3"), ": Good")), qK.default.createElement(S, null, qK.default.createElement($, null, tA.cyan("0"), ": Dismiss"))))
}
// @from(Start 13634621, End 13634623)
qK
// @from(Start 13634625, End 13634628)
AS3
// @from(Start 13634630, End 13634633)
QS3
// @from(Start 13634635, End 13634663)
HX0 = (A) => AS3.includes(A)
// @from(Start 13634667, End 13634719)
BS3 = "How is Claude doing this session? (optional)"
// @from(Start 13634725, End 13634890)
D39 = L(() => {
  F9();
  hA();
  qK = BA(VA(), 1), AS3 = ["0", "1", "2", "3"], QS3 = {
    "0": "dismissed",
    "1": "bad",
    "2": "fine",
    "3": "good"
  }
})
// @from(Start 13634893, End 13635518)
function CX0({
  state: A,
  handleSelect: Q,
  inputValue: B,
  setInputValue: G,
  message: Z
}) {
  if (A === "closed") return null;
  if (A === "thanks") return njA.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, njA.default.createElement($, {
    color: "success"
  }, "✓ Thanks for helping make Claude better!"), njA.default.createElement($, {
    dimColor: !0
  }, "Use ", "/feedback", " to share detailed feedback or file a bug."));
  if (B && !HX0(B)) return null;
  return njA.default.createElement(K39, {
    onSelect: Q,
    inputValue: B,
    setInputValue: G,
    message: Z
  })
}
// @from(Start 13635523, End 13635526)
njA
// @from(Start 13635532, End 13635587)
H39 = L(() => {
  hA();
  D39();
  njA = BA(VA(), 1)
})
// @from(Start 13635590, End 13636095)
function E39() {
  let {
    addNotification: A
  } = vZ();
  C39.useEffect(() => {
    gy().then((Q) => {
      Q.forEach((B, G) => {
        let Z = "low";
        if (B.type === "error" || B.userActionRequired) Z = "high";
        else if (B.type === "path" || B.type === "alias") Z = "medium";
        A({
          key: `install-message-${G}-${B.type}`,
          text: B.message,
          priority: Z,
          color: B.type === "error" ? "error" : "warning"
        })
      })
    })
  }, [A])
}
// @from(Start 13636100, End 13636103)
C39
// @from(Start 13636109, End 13636163)
z39 = L(() => {
  EU();
  uy();
  C39 = BA(VA(), 1)
})
// @from(Start 13636166, End 13636216)
function U39() {
  return N1().tipsHistory || {}
}
// @from(Start 13636218, End 13636294)
function GS3(A) {
  let Q = N1();
  c0({
    ...Q,
    tipsHistory: A
  })
}
// @from(Start 13636296, End 13636377)
function $39(A) {
  let Q = U39(),
    B = N1().numStartups;
  Q[A] = B, GS3(Q)
}
// @from(Start 13636379, End 13636421)
function ZS3(A) {
  return U39()[A] || 0
}
// @from(Start 13636423, End 13636519)
function uI1(A) {
  let Q = ZS3(A);
  if (Q === 0) return 1 / 0;
  return N1().numStartups - Q
}
// @from(Start 13636524, End 13636549)
EX0 = L(() => {
  jQ()
})
// @from(Start 13636607, End 13636659)
function dI1() {
  return Xx(MQ(), "plugins", JS3)
}
// @from(Start 13636661, End 13636713)
function UX0() {
  return Xx(MQ(), "plugins", WS3)
}
// @from(Start 13636715, End 13636974)
function ajA() {
  let A = RA(),
    Q = dI1();
  if (!A.existsSync(Q)) return null;
  let B = A.readFileSync(Q, {
      encoding: "utf-8"
    }),
    G = JSON.parse(B);
  return {
    version: typeof G?.version === "number" ? G.version : 1,
    data: G
  }
}
// @from(Start 13636976, End 13637235)
function XS3() {
  let A = RA(),
    Q = UX0();
  if (!A.existsSync(Q)) return null;
  let B = A.readFileSync(Q, {
      encoding: "utf-8"
    }),
    G = JSON.parse(B);
  return {
    version: typeof G?.version === "number" ? G.version : 2,
    data: G
  }
}
// @from(Start 13637237, End 13637609)
function VS3(A) {
  let Q = {};
  for (let [B, G] of Object.entries(A.plugins)) {
    let Z = G[0];
    if (Z) Q[B] = {
      version: Z.version || "unknown",
      installedAt: Z.installedAt || new Date().toISOString(),
      lastUpdated: Z.lastUpdated,
      installPath: Z.installPath,
      gitCommitSha: Z.gitCommitSha,
      isLocal: Z.isLocal
    }
  }
  return Q
}
// @from(Start 13637611, End 13638607)
function QVA() {
  if (hg !== null) return hg.plugins;
  let A = dI1();
  try {
    let Q = ajA();
    if (!Q) return g(`installed_plugins.json doesn't exist yet at ${A}, returning empty object`), hg = {
      version: 1,
      plugins: {}
    }, hg.plugins;
    if (Q.version === 2) {
      let G = AB1.parse(Q.data),
        Z = VS3(G);
      return hg = {
        version: 1,
        plugins: Z
      }, g(`Loaded ${Object.keys(Z).length} installed plugins from V2 file at ${A}`), Z
    }
    let B = $LA.parse(Q.data);
    return hg = B, g(`Loaded ${Object.keys(B.plugins).length} installed plugins from ${A} (schema version ${B.version})`), B.plugins
  } catch (Q) {
    let B = Q instanceof Error ? Q.message : String(Q);
    return g(`Failed to load installed_plugins.json: ${B}. Starting with empty state.`, {
      level: "error"
    }), AA(Q instanceof Error ? Q : Error(`Failed to load installed_plugins.json: ${B}`)), hg = {
      version: 1,
      plugins: {}
    }, hg.plugins
  }
}
// @from(Start 13638609, End 13639184)
function cI1(A) {
  let Q = RA(),
    B = dI1();
  try {
    let G = Xx(MQ(), "plugins");
    if (!Q.existsSync(G)) Q.mkdirSync(G);
    let Z = {
        version: 1,
        plugins: A
      },
      I = JSON.stringify(Z, null, 2);
    Q.writeFileSync(B, I, {
      encoding: "utf-8",
      flush: !0
    }), hg = Z, g(`Saved ${Object.keys(A).length} installed plugins to ${B} (schema version ${kQA})`)
  } catch (G) {
    let Z = G instanceof Error ? G.message : String(G);
    throw AA(G instanceof Error ? G : Error(`Failed to save installed_plugins.json: ${Z}`)), G
  }
}
// @from(Start 13639186, End 13639569)
function $X0(A) {
  let Q = {};
  for (let [B, G] of Object.entries(A.plugins)) {
    let Z = JB1(B, G.version);
    Q[B] = [{
      scope: "user",
      installPath: Z,
      version: G.version,
      installedAt: G.installedAt,
      lastUpdated: G.lastUpdated,
      gitCommitSha: G.gitCommitSha,
      isLocal: G.isLocal
    }]
  }
  return {
    version: 2,
    plugins: Q
  }
}
// @from(Start 13639571, End 13639606)
function FS3(A) {
  return $X0(A)
}
// @from(Start 13639608, End 13639729)
function yQA() {
  if (T$ !== null) return T$;
  if (o2("tengu_enable_versioned_plugins")) return KS3();
  return DS3()
}
// @from(Start 13639731, End 13640624)
function KS3() {
  let A = UX0();
  try {
    let Q = XS3();
    if (Q) {
      let G = AB1.parse(Q.data);
      return T$ = G, g(`Loaded ${Object.keys(G.plugins).length} installed plugins from V2 file at ${A}`), G
    }
    let B = ajA();
    if (B) {
      let G = $LA.parse(B.data),
        Z = $X0(G);
      return q39(Z), g(`Migrated ${Object.keys(G.plugins).length} plugins from V1 to V2 file`), Z
    }
    return g("Neither V1 nor V2 installed_plugins file exists, returning empty V2 object"), T$ = {
      version: 2,
      plugins: {}
    }, T$
  } catch (Q) {
    let B = Q instanceof Error ? Q.message : String(Q);
    return g(`Failed to load installed_plugins_v2.json: ${B}. Starting with empty state.`, {
      level: "error"
    }), AA(Q instanceof Error ? Q : Error(`Failed to load installed_plugins_v2.json: ${B}`)), T$ = {
      version: 2,
      plugins: {}
    }, T$
  }
}
// @from(Start 13640626, End 13641339)
function DS3() {
  let A = dI1();
  try {
    let Q = ajA();
    if (!Q) return g(`installed_plugins.json doesn't exist yet at ${A}, returning empty V2 object`), T$ = {
      version: 2,
      plugins: {}
    }, T$;
    let B = $LA.parse(Q.data),
      G = FS3(B);
    return T$ = G, g(`Loaded ${Object.keys(B.plugins).length} plugins from V1 file and wrapped as V2`), G
  } catch (Q) {
    let B = Q instanceof Error ? Q.message : String(Q);
    return g(`Failed to load installed_plugins.json (V2): ${B}. Starting with empty state.`, {
      level: "error"
    }), AA(Q instanceof Error ? Q : Error(`Failed to load installed_plugins.json (V2): ${B}`)), T$ = {
      version: 2,
      plugins: {}
    }, T$
  }
}
// @from(Start 13641341, End 13641854)
function q39(A) {
  let Q = RA(),
    B = UX0();
  try {
    let G = Xx(MQ(), "plugins");
    if (!Q.existsSync(G)) Q.mkdirSync(G);
    let Z = JSON.stringify(A, null, 2);
    Q.writeFileSync(B, Z, {
      encoding: "utf-8",
      flush: !0
    }), T$ = A, g(`Saved ${Object.keys(A.plugins).length} installed plugins to V2 file at ${B}`)
  } catch (G) {
    let Z = G instanceof Error ? G.message : String(G);
    throw AA(G instanceof Error ? G : Error(`Failed to save installed_plugins_v2.json: ${Z}`)), G
  }
}
// @from(Start 13641856, End 13641973)
function N39(A) {
  let Q = o2("tengu_enable_versioned_plugins"),
    B = ES3(A);
  if (cI1(B), Q) q39(A);
  T$ = A
}
// @from(Start 13641975, End 13642117)
function HS3(A) {
  let Q = al(),
    [B] = A.split("@");
  if (!B) return Q;
  let G = B.replace(/[^a-zA-Z0-9-_]/g, "-");
  return Xx(Q, G)
}
// @from(Start 13642119, End 13642262)
function CS3(A) {
  let [Q, B] = A.split("@");
  if (!Q || !B) return "";
  let G = Xx(MQ(), "plugins", "marketplaces");
  return Xx(G, B, Q)
}
// @from(Start 13642264, End 13642695)
function ES3(A) {
  let Q = {};
  for (let [B, G] of Object.entries(A.plugins)) {
    let Z = G[0];
    if (Z) {
      let I = Z.isLocal ? CS3(B) : HS3(B);
      Q[B] = {
        version: Z.version || "unknown",
        installedAt: Z.installedAt || new Date().toISOString(),
        lastUpdated: Z.lastUpdated,
        installPath: I,
        gitCommitSha: Z.gitCommitSha,
        isLocal: Z.isLocal
      }
    }
  }
  return Q
}
// @from(Start 13642697, End 13642965)
function pI1(A, Q, B) {
  let G = yQA(),
    Z = G.plugins[A];
  if (!Z) return;
  if (G.plugins[A] = Z.filter((I) => !(I.scope === Q && I.projectPath === B)), G.plugins[A].length === 0) delete G.plugins[A];
  N39(G), g(`Removed installation for ${A} at scope ${Q}`)
}
// @from(Start 13642967, End 13643031)
function wX0() {
  if (zX0 === null) zX0 = yQA();
  return zX0
}
// @from(Start 13643032, End 13643311)
async function L39() {
  try {
    await qX0()
  } catch (A) {
    AA(A instanceof Error ? A : Error(String(A)))
  }
  if (o2("tengu_enable_versioned_plugins")) {
    let A = wX0();
    g(`Initialized versioned plugins system with ${Object.keys(A.plugins).length} plugins`)
  }
}
// @from(Start 13643313, End 13643350)
function zS3(A) {
  return QVA()[A]
}
// @from(Start 13643352, End 13643397)
function gg(A) {
  return zS3(A) !== void 0
}
// @from(Start 13643399, End 13643525)
function M39(A, Q) {
  let B = QVA(),
    G = A in B;
  B[A] = Q, cI1(B), g(`${G?"Updated":"Added"} installed plugin: ${A}`)
}
// @from(Start 13643527, End 13643655)
function O39(A) {
  let Q = QVA(),
    B = Q[A];
  if (B) delete Q[A], cI1(Q), g(`Removed installed plugin: ${A}`);
  return B
}
// @from(Start 13643657, End 13644399)
function lI1(A) {
  let Q = RA();
  try {
    if (Q.existsSync(A)) {
      Q.rmSync(A, {
        recursive: !0,
        force: !0
      }), g(`Deleted plugin cache at ${A}`);
      let B = al();
      if (A.includes("/cache/") && A.startsWith(B)) {
        let G = YS3(A);
        if (Q.existsSync(G) && G !== B && G.startsWith(B)) {
          if (Q.readdirSync(G).length === 0) Q.rmdirSync(G), g(`Deleted empty plugin directory at ${G}`)
        }
      }
    } else g(`Plugin cache at ${A} doesn't exist, skipping deletion`)
  } catch (B) {
    let G = B instanceof Error ? B.message : String(B);
    throw AA(B instanceof Error ? B : Error(`Failed to delete plugin cache: ${G}`)), Error(`Failed to delete plugin cache at ${A}: ${G}`)
  }
}
// @from(Start 13644401, End 13644709)
function US3(A) {
  if (Object.keys(A).length === 0) return !0;
  let Q = ajA();
  if (!Q) return !1;
  if (Q.version !== kQA) return !1;
  try {
    let G = Q.data?.plugins || {};
    for (let Z of Object.keys(A))
      if (Z.includes("@") && !(Z in G)) return !1
  } catch {
    return !1
  }
  return !0
}
// @from(Start 13644711, End 13644867)
function $S3(A, Q) {
  if (!A.includes("@")) return !1;
  if (A in Q) return g(`Plugin ${A} already in installed_plugins.json, skipping`), !1;
  return !0
}
// @from(Start 13644868, End 13645117)
async function mI1(A) {
  try {
    let Q = await QQ("git", ["-C", A, "rev-parse", "HEAD"]);
    if (Q.code === 0 && Q.stdout) return Q.stdout.trim();
    return
  } catch (Q) {
    g(`Failed to get git commit SHA from ${A}: ${Q}`);
    return
  }
}
// @from(Start 13645119, End 13645454)
function w39(A, Q) {
  let B = RA(),
    G = Xx(A, ".claude-plugin", "plugin.json");
  if (!B.existsSync(G)) return "unknown";
  try {
    let Z = B.readFileSync(G, {
      encoding: "utf-8"
    });
    return JSON.parse(Z).version || "unknown"
  } catch {
    return g(`Could not read version from manifest for ${Q}`), "unknown"
  }
}
// @from(Start 13645455, End 13648033)
async function qX0() {
  let Q = l0().enabledPlugins || {},
    B = ajA(),
    G = B !== null,
    Z = B?.version ?? 0;
  if (US3(Q)) return;
  if (!G || Z !== kQA) g(`Schema version mismatch (current: ${Z}, expected: ${kQA}), syncing installed_plugins.json`);
  else g("Syncing installed_plugins.json with enabledPlugins from settings");
  let I = RA(),
    Y = QVA(),
    J = new Date().toISOString(),
    W = 0,
    X = 0;
  for (let [V] of Object.entries(Q)) {
    if (!$S3(V, Y)) {
      X++;
      continue
    }
    let F = V.split("@"),
      K = F[0];
    if (!K || F.length !== 2) {
      g(`Invalid plugin ID format: ${V}, skipping migration`), X++;
      continue
    }
    try {
      let D, H = "unknown",
        C = void 0,
        E = !1;
      try {
        let U = await nl(V);
        if (!U) {
          g(`Plugin ${V} not found in any marketplace, skipping`), X++;
          continue
        }
        let {
          entry: q,
          marketplaceInstallLocation: w
        } = U;
        if (typeof q.source === "string") E = !0, D = Xx(w, q.source), H = w39(D, V), C = await mI1(D);
        else {
          let N = al(),
            R = K.replace(/[^a-zA-Z0-9-_]/g, "-"),
            T = Xx(N, R);
          if (!I.existsSync(T)) {
            g(`External plugin ${V} not in cache, skipping`), X++;
            continue
          }
          D = T, H = w39(T, V), C = await mI1(T)
        }
        if (H === "unknown" && C) H = C.substring(0, 12), g(`Using git SHA as version for ${V}: ${H}`)
      } catch (U) {
        g(`Failed to get plugin info for ${V}: ${U}, skipping`), X++;
        continue
      }
      Y[V] = {
        version: H,
        installedAt: J,
        lastUpdated: J,
        installPath: D,
        gitCommitSha: C,
        isLocal: E
      }, W++, g(`Added ${V} to installed_plugins.json`)
    } catch (D) {
      let H = D instanceof Error ? D.message : String(D);
      g(`Failed to migrate plugin ${V}: ${H}`, {
        level: "warn"
      }), X++
    }
  }
  if (W > 0 || !G || Z !== kQA)
    if (o2("tengu_enable_versioned_plugins")) {
      let F = $X0({
        version: 1,
        plugins: Y
      });
      N39(F), g(`Sync completed (V2): ${W} plugins added to installed_plugins.json, ${X} skipped`)
    } else if (cI1(Y), !G || Z !== kQA) g(`Updated installed_plugins.json to schema version ${kQA} (${W} plugins added, ${X} skipped)`);
  else g(`Sync completed: ${W} plugins added to installed_plugins.json, ${X} skipped`);
  else if (X > 0) g(`Sync completed: All ${X} plugins already in installed_plugins.json`)
}
// @from(Start 13648038, End 13648068)
JS3 = "installed_plugins.json"
// @from(Start 13648072, End 13648105)
WS3 = "installed_plugins_v2.json"
// @from(Start 13648109, End 13648116)
kQA = 1
// @from(Start 13648120, End 13648129)
hg = null
// @from(Start 13648133, End 13648142)
T$ = null
// @from(Start 13648146, End 13648156)
zX0 = null
// @from(Start 13648162, End 13648259)
za = L(() => {
  AQ();
  V0();
  g1();
  hQ();
  u2();
  aAA();
  MB();
  fV();
  _8();
  oH()
})
// @from(Start 13648261, End 13648322)
async function wS3() {
  return "claude-code" in await pZ()
}
// @from(Start 13648323, End 13648510)
async function qS3() {
  let A = await QQ("rg", ["--files", "--glob", "*.{html,css,htm}", "--max-count=1"], {
    timeout: 5000
  });
  return A.code === 0 && A.stdout.trim().length > 0
}
// @from(Start 13648511, End 13648701)
async function iI1() {
  let A = [...NS3, ...LS3],
    Q = await Promise.all(A.map((B) => B.isRelevant()));
  return A.filter((B, G) => Q[G]).filter((B) => uI1(B.id) >= B.cooldownSessions)
}
// @from(Start 13648706, End 13648709)
NS3
// @from(Start 13648711, End 13648714)
LS3
// @from(Start 13648720, End 13658148)
NX0 = L(() => {
  jQ();
  PV();
  za();
  oH();
  _8();
  t2();
  r7A();
  c5();
  nY();
  Q3();
  Up();
  MB();
  EX0();
  S7();
  sU();
  V0();
  iUA();
  NS3 = [{
    id: "new-user-warmup",
    content: async () => "Start with small features or bug fixes, tell Claude to propose a plan, and verify its suggested edits",
    cooldownSessions: 3,
    async isRelevant() {
      return N1().numStartups < 10
    }
  }, {
    id: "plan-mode-for-complex-tasks",
    content: async () => `Use Plan Mode to prepare for a complex request before making changes. Press ${HU.displayText} twice to enable.`,
    cooldownSessions: 5,
    isRelevant: async () => {
      let A = N1();
      return (A.lastPlanModeUse ? (Date.now() - A.lastPlanModeUse) / 86400000 : 1 / 0) > 7
    }
  }, {
    id: "default-permission-mode-config",
    content: async () => "Use /config to change your default permission mode (including Plan Mode)",
    cooldownSessions: 10,
    isRelevant: async () => {
      try {
        let A = N1(),
          Q = l0(),
          B = Boolean(A.lastPlanModeUse),
          G = Boolean(Q?.permissions?.defaultMode);
        return B && !G
      } catch (A) {
        return g(`Failed to check default-permission-mode-config tip relevance: ${A}`, {
          level: "warn"
        }), !1
      }
    }
  }, {
    id: "git-worktrees",
    content: async () => "Use git worktrees to run multiple Claude sessions in parallel.",
    cooldownSessions: 10,
    isRelevant: async () => {
      try {
        let A = N1();
        return await NUA() <= 1 && A.numStartups > 50
      } catch (A) {
        return !1
      }
    }
  }, {
    id: "terminal-setup",
    content: async () => d0.terminal === "Apple_Terminal" ? "Run /terminal-setup to enable convenient terminal integration like Option + Enter for new line and more" : "Run /terminal-setup to enable convenient terminal integration like Shift + Enter for new line and more",
    cooldownSessions: 10,
    async isRelevant() {
      let A = N1();
      if (d0.terminal === "Apple_Terminal") return Ep.isEnabled() && !A.optionAsMetaKeyInstalled;
      return Ep.isEnabled() && !A.shiftEnterKeyBindingInstalled
    }
  }, {
    id: "shift-enter",
    content: async () => d0.terminal === "Apple_Terminal" ? "Press Option+Enter to send a multi-line message" : "Press Shift+Enter to send a multi-line message",
    cooldownSessions: 10,
    async isRelevant() {
      let A = N1();
      return Boolean((d0.terminal === "Apple_Terminal" ? A.optionAsMetaKeyInstalled : A.shiftEnterKeyBindingInstalled) && A.numStartups > 3)
    }
  }, {
    id: "shift-enter-setup",
    content: async () => d0.terminal === "Apple_Terminal" ? "Run /terminal-setup to enable Option+Enter for new lines" : "Run /terminal-setup to enable Shift+Enter for new lines",
    cooldownSessions: 10,
    async isRelevant() {
      if (!M$A()) return !1;
      let A = N1();
      return !(d0.terminal === "Apple_Terminal" ? A.optionAsMetaKeyInstalled : A.shiftEnterKeyBindingInstalled)
    }
  }, {
    id: "memory-command",
    content: async () => "Use /memory to view and manage Claude memory",
    cooldownSessions: 15,
    async isRelevant() {
      return N1().memoryUsageCount <= 0
    }
  }, {
    id: "theme-command",
    content: async () => "Use /theme to change the color theme",
    cooldownSessions: 20,
    isRelevant: async () => !0
  }, {
    id: "status-line",
    content: async () => "Use /statusline to set up a custom status line that will display beneath the input box",
    cooldownSessions: 25,
    isRelevant: async () => l0().statusLine === void 0
  }, {
    id: "stickers-command",
    content: async () => "Use /stickers to order Claude Code swag",
    cooldownSessions: 20,
    isRelevant: async () => !0
  }, {
    id: "prompt-queue",
    content: async () => "Hit Enter to queue up additional messages while Claude is working.",
    cooldownSessions: 5,
    async isRelevant() {
      return N1().promptQueueUseCount <= 3
    }
  }, {
    id: "enter-to-steer-in-relatime",
    content: async () => "Send messages to Claude while it works to steer Claude in real-time",
    cooldownSessions: 20,
    isRelevant: async () => !0
  }, {
    id: "todo-list",
    content: async () => "Ask Claude to create a todo list when working on complex tasks to track progress and remain on track",
    cooldownSessions: 20,
    isRelevant: async () => !0
  }, {
    id: "vscode-command-install",
    content: async () => `Open the Command Palette (Cmd+Shift+P) and run "Shell Command: Install '${d0.terminal==="vscode"?"code":d0.terminal}' command in PATH" to enable IDE integration`,
    cooldownSessions: 0,
    async isRelevant() {
      if (!KLA()) return !1;
      if (dQ() !== "macos") return !1;
      switch (d0.terminal) {
        case "vscode":
          return !YB2();
        case "cursor":
          return !ZB2();
        case "windsurf":
          return !IB2();
        default:
          return !1
      }
    }
  }, {
    id: "ide-upsell-external-terminal",
    content: async () => "Connect Claude to your IDE · /ide",
    cooldownSessions: 4,
    async isRelevant() {
      if (bV()) return !1;
      if (jQ1().length !== 0) return !1;
      return _Q1().length > 0
    }
  }, {
    id: "# for memory",
    content: async () => "Want Claude to remember something? Hit # to add preferences, tools, and instructions to Claude's memory",
    cooldownSessions: 10,
    isRelevant: async () => N1().memoryUsageCount <= 10
  }, {
    id: "install-github-app",
    content: async () => "Run /install-github-app to tag @claude right from your Github issues and PRs",
    cooldownSessions: 10,
    isRelevant: async () => !N1().githubActionSetupCount
  }, {
    id: "permissions",
    content: async () => "Use /permissions to pre-approve and pre-deny bash, edit, and MCP tools",
    cooldownSessions: 10,
    async isRelevant() {
      return N1().numStartups > 10
    }
  }, {
    id: "drag-and-drop-images",
    content: async () => "Did you know you can drag and drop image files into your terminal?",
    cooldownSessions: 10,
    isRelevant: async () => !0
  }, {
    id: "paste-images-mac",
    content: async () => "Paste images into Claude Code using control+v (not cmd+v!)",
    cooldownSessions: 10,
    isRelevant: async () => dQ() === "macos"
  }, {
    id: "double-esc",
    content: async () => "Double-tap esc to rewind the conversation to a previous point in time",
    cooldownSessions: 10,
    isRelevant: async () => !EG()
  }, {
    id: "double-esc-code-restore",
    content: async () => "Double-tap esc to rewind the code and/or conversation to a previous point in time",
    cooldownSessions: 10,
    isRelevant: async () => EG()
  }, {
    id: "continue",
    content: async () => "Run claude --continue or claude --resume to resume a conversation",
    cooldownSessions: 10,
    isRelevant: async () => !0
  }, {
    id: "rename-conversation",
    content: async () => "Name your conversations with /rename to find them easily in /resume later",
    cooldownSessions: 15,
    isRelevant: async () => ug() && N1().numStartups > 10
  }, {
    id: "custom-commands",
    content: async () => "Create custom slash commands by adding .md files to .claude/commands/ in your project or ~/.claude/commands/ for commands that work in any project",
    cooldownSessions: 15,
    async isRelevant() {
      return N1().numStartups > 10
    }
  }, {
    id: "shift-tab",
    content: async () => `Hit ${HU.displayText} to cycle between default mode, auto-accept edit mode, and plan mode`,
    cooldownSessions: 10,
    isRelevant: async () => !0
  }, {
    id: "image-paste",
    content: async () => `Use ${tt.displayText} to paste images from your clipboard`,
    cooldownSessions: 20,
    isRelevant: async () => !0
  }, {
    id: "tab-toggle-thinking",
    content: async () => "Hit tab to toggle thinking mode on and off",
    cooldownSessions: 10,
    isRelevant: async () => !0
  }, {
    id: "ultrathink-keyword",
    content: async () => "Type 'ultrathink' in your message to enable thinking for just that turn",
    cooldownSessions: 10,
    isRelevant: async () => !0
  }, {
    id: "custom-agents",
    content: async () => "Use /agents to optimize specific tasks. Eg. Software Architect, Code Writer, Code Reviewer",
    cooldownSessions: 15,
    async isRelevant() {
      return N1().numStartups > 5
    }
  }, {
    id: "opusplan-mode-reminder",
    content: async () => `Your default model setting is Opus Plan Mode. Press ${HU.displayText} twice to activate Plan Mode and plan with Claude Opus.`,
    cooldownSessions: 2,
    async isRelevant() {
      let A = N1(),
        B = Tt() === "opusplan",
        G = A.lastPlanModeUse ? (Date.now() - A.lastPlanModeUse) / 86400000 : 1 / 0;
      return B && G > 3
    }
  }, {
    id: "frontend-design-plugin",
    content: async (A) => {
      let Q = await wS3(),
        B = ZB("suggestion", A.theme);
      if (!Q) return `Working with HTML/CSS? Add the frontend-design plugin:
${B("/plugin marketplace add anthropics/claude-code")}
${B("/plugin install frontend-design@claude-code-plugins")}`;
      return `Working with HTML/CSS? Install the frontend-design plugin:
${B("/plugin install frontend-design@claude-code-plugins")}`
    },
    cooldownSessions: 3,
    async isRelevant() {
      if (gg("frontend-design@claude-code-plugins")) return !1;
      return qS3()
    }
  }], LS3 = []
})
// @from(Start 13658151, End 13658366)
function MS3(A) {
  if (A.length === 0) return;
  if (A.length === 1) return A[0];
  let Q = A.map((B) => ({
    tip: B,
    sessions: uI1(B.id)
  }));
  return Q.sort((B, G) => G.sessions - B.sessions), Q[0]?.tip
}
// @from(Start 13658367, End 13658506)
async function R39() {
  if (l0().spinnerTipsEnabled === !1) return;
  let A = await iI1();
  if (A.length === 0) return;
  return MS3(A)
}
// @from(Start 13658508, End 13658633)
function T39(A) {
  $39(A.id), GA("tengu_tip_shown", {
    tipIdLength: A.id,
    cooldownSessions: A.cooldownSessions
  })
}
// @from(Start 13658638, End 13658706)
P39 = L(() => {
  EX0();
  q0();
  jQ();
  MB();
  tXA();
  NX0()
})
// @from(Start 13658709, End 13658835)
function S39() {
  let [A, Q] = OQ(), {
    toolPermissionContext: B
  } = A;
  j39.useEffect(() => {
    LX0(B, Q)
  }, [])
}
// @from(Start 13658840, End 13658843)
j39
// @from(Start 13658845, End 13658848)
LX0
// @from(Start 13658854, End 13659152)
_39 = L(() => {
  l2();
  z9();
  tJA();
  j39 = BA(VA(), 1), LX0 = s1(async (A, Q) => {
    if (!A.isBypassPermissionsModeAvailable) return;
    if (!await MX0()) return;
    Q((G) => {
      return {
        ...G,
        toolPermissionContext: k39(G.toolPermissionContext)
      }
    })
  })
})
// @from(Start 13659155, End 13659319)
function y39(A, Q, B) {
  let G = nI1.useRef(!1);
  nI1.useEffect(() => {
    if (!EG() || G.current) return;
    if (G.current = !0, A) xYA(A, B)
  }, [Q, A, B])
}
// @from(Start 13659324, End 13659327)
nI1
// @from(Start 13659333, End 13659379)
x39 = L(() => {
  sU();
  nI1 = BA(VA(), 1)
})
// @from(Start 13659382, End 13660684)
function v39({
  hostPattern: {
    host: A
  },
  onUserResponse: Q
}) {
  function B(Z) {
    switch (Z) {
      case "yes":
        Q({
          allow: !0,
          persistToSettings: !1
        });
        break;
      case "yes-dont-ask-again":
        Q({
          allow: !0,
          persistToSettings: !0
        });
        break;
      case "no":
        Q({
          allow: !1,
          persistToSettings: !1
        });
        break
    }
  }
  let G = [{
    label: "Yes",
    value: "yes"
  }, {
    label: `Yes, and don't ask again for ${tA.bold(A)}`,
    value: "yes-dont-ask-again"
  }, {
    label: `No, and tell Claude what to do differently ${tA.bold("(esc)")}`,
    value: "no"
  }];
  return oV.createElement(uJ, {
    title: "Network request outside of sandbox"
  }, oV.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    paddingY: 1
  }, oV.createElement(S, null, oV.createElement($, {
    dimColor: !0
  }, "Host:"), oV.createElement($, null, " ", A)), oV.createElement(S, {
    marginTop: 1
  }, oV.createElement($, null, "Do you want to allow this connection?")), oV.createElement(S, null, oV.createElement(M0, {
    options: G,
    onChange: B,
    onCancel: () => {
      Q({
        allow: !1,
        persistToSettings: !1
      })
    }
  }))))
}
// @from(Start 13660689, End 13660691)
oV
// @from(Start 13660697, End 13660774)
b39 = L(() => {
  hA();
  S5();
  wO();
  F9();
  q0();
  oV = BA(VA(), 1)
})
// @from(Start 13660780, End 13660783)
OS3
// @from(Start 13660785, End 13660788)
AfZ
// @from(Start 13660790, End 13660805)
aI1 = 604800000
// @from(Start 13660809, End 13660823)
f39 = 86400000
// @from(Start 13660827, End 13660830)
OX0
// @from(Start 13660836, End 13660951)
sjA = L(() => {
  OS3 = Math.pow(10, 8) * 24 * 60 * 60 * 1000, AfZ = -OS3, OX0 = Symbol.for("constructDateFrom")
})
// @from(Start 13660954, End 13661158)
function P$(A, Q) {
  if (typeof A === "function") return A(Q);
  if (A && typeof A === "object" && OX0 in A) return A[OX0](Q);
  if (A instanceof Date) return new A.constructor(Q);
  return new Date(Q)
}
// @from(Start 13661163, End 13661188)
Ua = L(() => {
  sjA()
})
// @from(Start 13661191, End 13661235)
function sJ(A, Q) {
  return P$(Q || A, A)
}
// @from(Start 13661240, End 13661264)
GN = L(() => {
  Ua()
})
// @from(Start 13661270, End 13661284)
h39 = () => {}
// @from(Start 13661290, End 13661304)
g39 = () => {}
// @from(Start 13661310, End 13661324)
u39 = () => {}
// @from(Start 13661330, End 13661344)
m39 = () => {}
// @from(Start 13661350, End 13661364)
d39 = () => {}
// @from(Start 13661370, End 13661384)
c39 = () => {}
// @from(Start 13661390, End 13661404)
p39 = () => {}
// @from(Start 13661410, End 13661424)
l39 = () => {}
// @from(Start 13661430, End 13661444)
i39 = () => {}
// @from(Start 13661447, End 13661477)
function $a() {
  return RS3
}
// @from(Start 13661482, End 13661485)
RS3
// @from(Start 13661491, End 13661520)
rjA = L(() => {
  RS3 = {}
})
// @from(Start 13661523, End 13661817)
function mg(A, Q) {
  let B = $a(),
    G = Q?.weekStartsOn ?? Q?.locale?.options?.weekStartsOn ?? B.weekStartsOn ?? B.locale?.options?.weekStartsOn ?? 0,
    Z = sJ(A, Q?.in),
    I = Z.getDay(),
    Y = (I < G ? 7 : 0) + I - G;
  return Z.setDate(Z.getDate() - Y), Z.setHours(0, 0, 0, 0), Z
}
// @from(Start 13661822, End 13661856)
BVA = L(() => {
  rjA();
  GN()
})
// @from(Start 13661859, End 13661933)
function xQA(A, Q) {
  return mg(A, {
    ...Q,
    weekStartsOn: 1
  })
}
// @from(Start 13661938, End 13661964)
ojA = L(() => {
  BVA()
})
// @from(Start 13661967, End 13662331)
function sI1(A, Q) {
  let B = sJ(A, Q?.in),
    G = B.getFullYear(),
    Z = P$(B, 0);
  Z.setFullYear(G + 1, 0, 4), Z.setHours(0, 0, 0, 0);
  let I = xQA(Z),
    Y = P$(B, 0);
  Y.setFullYear(G, 0, 4), Y.setHours(0, 0, 0, 0);
  let J = xQA(Y);
  if (B.getTime() >= I.getTime()) return G + 1;
  else if (B.getTime() >= J.getTime()) return G;
  else return G - 1
}
// @from(Start 13662336, End 13662378)
rI1 = L(() => {
  Ua();
  ojA();
  GN()
})
// @from(Start 13662381, End 13662608)
function RX0(A) {
  let Q = sJ(A),
    B = new Date(Date.UTC(Q.getFullYear(), Q.getMonth(), Q.getDate(), Q.getHours(), Q.getMinutes(), Q.getSeconds(), Q.getMilliseconds()));
  return B.setUTCFullYear(Q.getFullYear()), +A - +B
}
// @from(Start 13662613, End 13662638)
n39 = L(() => {
  GN()
})
// @from(Start 13662641, End 13662752)
function a39(A, ...Q) {
  let B = P$.bind(null, A || Q.find((G) => typeof G === "object"));
  return Q.map(B)
}
// @from(Start 13662757, End 13662782)
s39 = L(() => {
  Ua()
})
// @from(Start 13662785, End 13662866)
function TX0(A, Q) {
  let B = sJ(A, Q?.in);
  return B.setHours(0, 0, 0, 0), B
}
// @from(Start 13662871, End 13662896)
PX0 = L(() => {
  GN()
})
// @from(Start 13662899, End 13663050)
function r39(A, Q, B) {
  let [G, Z] = a39(B?.in, A, Q), I = TX0(G), Y = TX0(Z), J = +I - RX0(I), W = +Y - RX0(Y);
  return Math.round((J - W) / f39)
}
// @from(Start 13663055, End 13663108)
jX0 = L(() => {
  n39();
  s39();
  sjA();
  PX0()
})
// @from(Start 13663111, End 13663245)
function o39(A, Q) {
  let B = sI1(A, Q),
    G = P$(Q?.in || A, 0);
  return G.setFullYear(B, 0, 4), G.setHours(0, 0, 0, 0), xQA(G)
}
// @from(Start 13663250, End 13663293)
SX0 = L(() => {
  Ua();
  rI1();
  ojA()
})
// @from(Start 13663299, End 13663313)
t39 = () => {}
// @from(Start 13663319, End 13663333)
e39 = () => {}
// @from(Start 13663339, End 13663353)
A79 = () => {}
// @from(Start 13663359, End 13663373)
Q79 = () => {}
// @from(Start 13663379, End 13663393)
B79 = () => {}
// @from(Start 13663399, End 13663413)
G79 = () => {}
// @from(Start 13663419, End 13663433)
Z79 = () => {}
// @from(Start 13663439, End 13663453)
I79 = () => {}
// @from(Start 13663459, End 13663473)
Y79 = () => {}
// @from(Start 13663479, End 13663493)
J79 = () => {}
// @from(Start 13663499, End 13663513)
W79 = () => {}
// @from(Start 13663519, End 13663533)
X79 = () => {}
// @from(Start 13663539, End 13663553)
V79 = () => {}
// @from(Start 13663559, End 13663573)
F79 = () => {}
// @from(Start 13663579, End 13663593)
K79 = () => {}
// @from(Start 13663599, End 13663613)
D79 = () => {}
// @from(Start 13663619, End 13663633)
H79 = () => {}
// @from(Start 13663639, End 13663653)
C79 = () => {}
// @from(Start 13663656, End 13663784)
function E79(A) {
  return A instanceof Date || typeof A === "object" && Object.prototype.toString.call(A) === "[object Date]"
}
// @from(Start 13663789, End 13663803)
_X0 = () => {}
// @from(Start 13663806, End 13663887)
function z79(A) {
  return !(!E79(A) && typeof A !== "number" || isNaN(+sJ(A)))
}
// @from(Start 13663892, End 13663926)
kX0 = L(() => {
  _X0();
  GN()
})
// @from(Start 13663932, End 13663946)
U79 = () => {}
// @from(Start 13663952, End 13663966)
$79 = () => {}
// @from(Start 13663972, End 13663986)
w79 = () => {}
// @from(Start 13663992, End 13664006)
q79 = () => {}
// @from(Start 13664012, End 13664026)
N79 = () => {}
// @from(Start 13664032, End 13664046)
L79 = () => {}
// @from(Start 13664052, End 13664066)
M79 = () => {}
// @from(Start 13664072, End 13664086)
O79 = () => {}
// @from(Start 13664092, End 13664106)
R79 = () => {}
// @from(Start 13664112, End 13664126)
T79 = () => {}
// @from(Start 13664132, End 13664146)
P79 = () => {}
// @from(Start 13664152, End 13664166)
j79 = () => {}
// @from(Start 13664172, End 13664186)
S79 = () => {}
// @from(Start 13664192, End 13664206)
_79 = () => {}
// @from(Start 13664212, End 13664226)
k79 = () => {}
// @from(Start 13664232, End 13664246)
y79 = () => {}
// @from(Start 13664252, End 13664266)
x79 = () => {}
// @from(Start 13664272, End 13664286)
v79 = () => {}
// @from(Start 13664292, End 13664306)
b79 = () => {}
// @from(Start 13664312, End 13664326)
f79 = () => {}
// @from(Start 13664332, End 13664346)
h79 = () => {}
// @from(Start 13664352, End 13664366)
g79 = () => {}
// @from(Start 13664372, End 13664386)
u79 = () => {}
// @from(Start 13664392, End 13664406)
m79 = () => {}
// @from(Start 13664412, End 13664426)
d79 = () => {}
// @from(Start 13664432, End 13664446)
c79 = () => {}
// @from(Start 13664452, End 13664466)
p79 = () => {}
// @from(Start 13664472, End 13664486)
l79 = () => {}
// @from(Start 13664492, End 13664506)
i79 = () => {}
// @from(Start 13664512, End 13664526)
n79 = () => {}
// @from(Start 13664532, End 13664546)
a79 = () => {}
// @from(Start 13664552, End 13664566)
s79 = () => {}
// @from(Start 13664572, End 13664586)
r79 = () => {}
// @from(Start 13664589, End 13664708)
function o79(A, Q) {
  let B = sJ(A, Q?.in);
  return B.setFullYear(B.getFullYear(), 0, 1), B.setHours(0, 0, 0, 0), B
}
// @from(Start 13664713, End 13664738)
yX0 = L(() => {
  GN()
})
// @from(Start 13664744, End 13664758)
t79 = () => {}
// @from(Start 13664764, End 13664778)
e79 = () => {}
// @from(Start 13664784, End 13664798)
AG9 = () => {}
// @from(Start 13664804, End 13664818)
QG9 = () => {}
// @from(Start 13664824, End 13664838)
BG9 = () => {}
// @from(Start 13664844, End 13664858)
GG9 = () => {}
// @from(Start 13664864, End 13664878)
ZG9 = () => {}
// @from(Start 13664884, End 13664898)
IG9 = () => {}
// @from(Start 13664904, End 13664918)
YG9 = () => {}
// @from(Start 13664924, End 13664938)
JG9 = () => {}
// @from(Start 13664944, End 13664958)
WG9 = () => {}
// @from(Start 13664964, End 13664978)
XG9 = () => {}
// @from(Start 13664984, End 13664998)
VG9 = () => {}
// @from(Start 13665004, End 13665007)
TS3
// @from(Start 13665009, End 13665293)
FG9 = (A, Q, B) => {
  let G, Z = TS3[A];
  if (typeof Z === "string") G = Z;
  else if (Q === 1) G = Z.one;
  else G = Z.other.replace("{{count}}", Q.toString());
  if (B?.addSuffix)
    if (B.comparison && B.comparison > 0) return "in " + G;
    else return G + " ago";
  return G
}
// @from(Start 13665299, End 13666644)
KG9 = L(() => {
  TS3 = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  }
})
// @from(Start 13666647, End 13666802)
function oI1(A) {
  return (Q = {}) => {
    let B = Q.width ? String(Q.width) : A.defaultWidth;
    return A.formats[B] || A.formats[A.defaultWidth]
  }
}
// @from(Start 13666807, End 13666810)
PS3
// @from(Start 13666812, End 13666815)
jS3
// @from(Start 13666817, End 13666820)
SS3
// @from(Start 13666822, End 13666825)
DG9
// @from(Start 13666831, End 13667456)
HG9 = L(() => {
  PS3 = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  }, jS3 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  }, SS3 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  }, DG9 = {
    date: oI1({
      formats: PS3,
      defaultWidth: "full"
    }),
    time: oI1({
      formats: jS3,
      defaultWidth: "full"
    }),
    dateTime: oI1({
      formats: SS3,
      defaultWidth: "full"
    })
  }
})
// @from(Start 13667462, End 13667465)
_S3
// @from(Start 13667467, End 13667495)
CG9 = (A, Q, B, G) => _S3[A]
// @from(Start 13667501, End 13667708)
EG9 = L(() => {
  _S3 = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  }
})
// @from(Start 13667711, End 13668253)
function GVA(A) {
  return (Q, B) => {
    let G = B?.context ? String(B.context) : "standalone",
      Z;
    if (G === "formatting" && A.formattingValues) {
      let Y = A.defaultFormattingWidth || A.defaultWidth,
        J = B?.width ? String(B.width) : Y;
      Z = A.formattingValues[J] || A.formattingValues[Y]
    } else {
      let Y = A.defaultWidth,
        J = B?.width ? String(B.width) : A.defaultWidth;
      Z = A.values[J] || A.values[Y]
    }
    let I = A.argumentCallback ? A.argumentCallback(Q) : Q;
    return Z[I]
  }
}
// @from(Start 13668258, End 13668261)
kS3
// @from(Start 13668263, End 13668266)
yS3
// @from(Start 13668268, End 13668271)
xS3
// @from(Start 13668273, End 13668276)
vS3
// @from(Start 13668278, End 13668281)
bS3
// @from(Start 13668283, End 13668286)
fS3
// @from(Start 13668288, End 13668537)
hS3 = (A, Q) => {
    let B = Number(A),
      G = B % 100;
    if (G > 20 || G < 10) switch (G % 10) {
      case 1:
        return B + "st";
      case 2:
        return B + "nd";
      case 3:
        return B + "rd"
    }
    return B + "th"
  }
// @from(Start 13668541, End 13668544)
zG9
// @from(Start 13668550, End 13671248)
UG9 = L(() => {
  kS3 = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  }, yS3 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  }, xS3 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  }, vS3 = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  }, bS3 = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  }, fS3 = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  }, zG9 = {
    ordinalNumber: hS3,
    era: GVA({
      values: kS3,
      defaultWidth: "wide"
    }),
    quarter: GVA({
      values: yS3,
      defaultWidth: "wide",
      argumentCallback: (A) => A - 1
    }),
    month: GVA({
      values: xS3,
      defaultWidth: "wide"
    }),
    day: GVA({
      values: vS3,
      defaultWidth: "wide"
    }),
    dayPeriod: GVA({
      values: bS3,
      defaultWidth: "wide",
      formattingValues: fS3,
      defaultFormattingWidth: "wide"
    })
  }
})
// @from(Start 13671251, End 13671803)
function ZVA(A) {
  return (Q, B = {}) => {
    let G = B.width,
      Z = G && A.matchPatterns[G] || A.matchPatterns[A.defaultMatchWidth],
      I = Q.match(Z);
    if (!I) return null;
    let Y = I[0],
      J = G && A.parsePatterns[G] || A.parsePatterns[A.defaultParseWidth],
      W = Array.isArray(J) ? uS3(J, (F) => F.test(Y)) : gS3(J, (F) => F.test(Y)),
      X;
    X = A.valueCallback ? A.valueCallback(W) : W, X = B.valueCallback ? B.valueCallback(X) : X;
    let V = Q.slice(Y.length);
    return {
      value: X,
      rest: V
    }
  }
}
// @from(Start 13671805, End 13671928)
function gS3(A, Q) {
  for (let B in A)
    if (Object.prototype.hasOwnProperty.call(A, B) && Q(A[B])) return B;
  return
}
// @from(Start 13671930, End 13672025)
function uS3(A, Q) {
  for (let B = 0; B < A.length; B++)
    if (Q(A[B])) return B;
  return
}
// @from(Start 13672027, End 13672406)
function $G9(A) {
  return (Q, B = {}) => {
    let G = Q.match(A.matchPattern);
    if (!G) return null;
    let Z = G[0],
      I = Q.match(A.parsePattern);
    if (!I) return null;
    let Y = A.valueCallback ? A.valueCallback(I[0]) : I[0];
    Y = B.valueCallback ? B.valueCallback(Y) : Y;
    let J = Q.slice(Z.length);
    return {
      value: Y,
      rest: J
    }
  }
}
// @from(Start 13672411, End 13672414)
mS3
// @from(Start 13672416, End 13672419)
dS3
// @from(Start 13672421, End 13672424)
cS3
// @from(Start 13672426, End 13672429)
pS3
// @from(Start 13672431, End 13672434)
lS3
// @from(Start 13672436, End 13672439)
iS3
// @from(Start 13672441, End 13672444)
nS3
// @from(Start 13672446, End 13672449)
aS3
// @from(Start 13672451, End 13672454)
sS3
// @from(Start 13672456, End 13672459)
rS3
// @from(Start 13672461, End 13672464)
oS3
// @from(Start 13672466, End 13672469)
tS3
// @from(Start 13672471, End 13672474)
wG9
// @from(Start 13672480, End 13674972)
qG9 = L(() => {
  mS3 = /^(\d+)(th|st|nd|rd)?/i, dS3 = /\d+/i, cS3 = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  }, pS3 = {
    any: [/^b/i, /^(a|c)/i]
  }, lS3 = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  }, iS3 = {
    any: [/1/i, /2/i, /3/i, /4/i]
  }, nS3 = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  }, aS3 = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  }, sS3 = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  }, rS3 = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  }, oS3 = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  }, tS3 = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  }, wG9 = {
    ordinalNumber: $G9({
      matchPattern: mS3,
      parsePattern: dS3,
      valueCallback: (A) => parseInt(A, 10)
    }),
    era: ZVA({
      matchPatterns: cS3,
      defaultMatchWidth: "wide",
      parsePatterns: pS3,
      defaultParseWidth: "any"
    }),
    quarter: ZVA({
      matchPatterns: lS3,
      defaultMatchWidth: "wide",
      parsePatterns: iS3,
      defaultParseWidth: "any",
      valueCallback: (A) => A + 1
    }),
    month: ZVA({
      matchPatterns: nS3,
      defaultMatchWidth: "wide",
      parsePatterns: aS3,
      defaultParseWidth: "any"
    }),
    day: ZVA({
      matchPatterns: sS3,
      defaultMatchWidth: "wide",
      parsePatterns: rS3,
      defaultParseWidth: "any"
    }),
    dayPeriod: ZVA({
      matchPatterns: oS3,
      defaultMatchWidth: "any",
      parsePatterns: tS3,
      defaultParseWidth: "any"
    })
  }
})
// @from(Start 13674978, End 13674981)
xX0
// @from(Start 13674987, End 13675264)
NG9 = L(() => {
  KG9();
  HG9();
  EG9();
  UG9();
  qG9();
  xX0 = {
    code: "en-US",
    formatDistance: FG9,
    formatLong: DG9,
    formatRelative: CG9,
    localize: zG9,
    match: wG9,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  }
})
// @from(Start 13675270, End 13675296)
LG9 = L(() => {
  NG9()
})
// @from(Start 13675299, End 13675373)
function MG9(A, Q) {
  let B = sJ(A, Q?.in);
  return r39(B, o79(B)) + 1
}
// @from(Start 13675378, End 13675421)
vX0 = L(() => {
  jX0();
  yX0();
  GN()
})
// @from(Start 13675424, End 13675530)
function OG9(A, Q) {
  let B = sJ(A, Q?.in),
    G = +xQA(B) - +o39(B);
  return Math.round(G / aI1) + 1
}
// @from(Start 13675535, End 13675587)
bX0 = L(() => {
  sjA();
  ojA();
  SX0();
  GN()
})
// @from(Start 13675590, End 13676109)
function tI1(A, Q) {
  let B = sJ(A, Q?.in),
    G = B.getFullYear(),
    Z = $a(),
    I = Q?.firstWeekContainsDate ?? Q?.locale?.options?.firstWeekContainsDate ?? Z.firstWeekContainsDate ?? Z.locale?.options?.firstWeekContainsDate ?? 1,
    Y = P$(Q?.in || A, 0);
  Y.setFullYear(G + 1, 0, I), Y.setHours(0, 0, 0, 0);
  let J = mg(Y, Q),
    W = P$(Q?.in || A, 0);
  W.setFullYear(G, 0, I), W.setHours(0, 0, 0, 0);
  let X = mg(W, Q);
  if (+B >= +J) return G + 1;
  else if (+B >= +X) return G;
  else return G - 1
}
// @from(Start 13676114, End 13676165)
eI1 = L(() => {
  rjA();
  Ua();
  BVA();
  GN()
})
// @from(Start 13676168, End 13676473)
function RG9(A, Q) {
  let B = $a(),
    G = Q?.firstWeekContainsDate ?? Q?.locale?.options?.firstWeekContainsDate ?? B.firstWeekContainsDate ?? B.locale?.options?.firstWeekContainsDate ?? 1,
    Z = tI1(A, Q),
    I = P$(Q?.in || A, 0);
  return I.setFullYear(Z, 0, G), I.setHours(0, 0, 0, 0), mg(I, Q)
}
// @from(Start 13676478, End 13676530)
fX0 = L(() => {
  rjA();
  Ua();
  eI1();
  BVA()
})
// @from(Start 13676533, End 13676644)
function TG9(A, Q) {
  let B = sJ(A, Q?.in),
    G = +mg(B, Q) - +RG9(B, Q);
  return Math.round(G / aI1) + 1
}
// @from(Start 13676649, End 13676701)
hX0 = L(() => {
  sjA();
  BVA();
  fX0();
  GN()
})
// @from(Start 13676704, End 13676817)
function x7(A, Q) {
  let B = A < 0 ? "-" : "",
    G = Math.abs(A).toString().padStart(Q, "0");
  return B + G
}
// @from(Start 13676822, End 13676824)
dg
// @from(Start 13676830, End 13677913)
PG9 = L(() => {
  dg = {
    y(A, Q) {
      let B = A.getFullYear(),
        G = B > 0 ? B : 1 - B;
      return x7(Q === "yy" ? G % 100 : G, Q.length)
    },
    M(A, Q) {
      let B = A.getMonth();
      return Q === "M" ? String(B + 1) : x7(B + 1, 2)
    },
    d(A, Q) {
      return x7(A.getDate(), Q.length)
    },
    a(A, Q) {
      let B = A.getHours() / 12 >= 1 ? "pm" : "am";
      switch (Q) {
        case "a":
        case "aa":
          return B.toUpperCase();
        case "aaa":
          return B;
        case "aaaaa":
          return B[0];
        case "aaaa":
        default:
          return B === "am" ? "a.m." : "p.m."
      }
    },
    h(A, Q) {
      return x7(A.getHours() % 12 || 12, Q.length)
    },
    H(A, Q) {
      return x7(A.getHours(), Q.length)
    },
    m(A, Q) {
      return x7(A.getMinutes(), Q.length)
    },
    s(A, Q) {
      return x7(A.getSeconds(), Q.length)
    },
    S(A, Q) {
      let B = Q.length,
        G = A.getMilliseconds(),
        Z = Math.trunc(G * Math.pow(10, B - 3));
      return x7(Z, Q.length)
    }
  }
})
// @from(Start 13677916, End 13678112)
function jG9(A, Q = "") {
  let B = A > 0 ? "-" : "+",
    G = Math.abs(A),
    Z = Math.trunc(G / 60),
    I = G % 60;
  if (I === 0) return B + String(Z);
  return B + String(Z) + Q + x7(I, 2)
}
// @from(Start 13678114, End 13678229)
function SG9(A, Q) {
  if (A % 60 === 0) return (A > 0 ? "-" : "+") + x7(Math.abs(A) / 60, 2);
  return vQA(A, Q)
}
// @from(Start 13678231, End 13678389)
function vQA(A, Q = "") {
  let B = A > 0 ? "-" : "+",
    G = Math.abs(A),
    Z = x7(Math.trunc(G / 60), 2),
    I = x7(G % 60, 2);
  return B + Z + Q + I
}
// @from(Start 13678394, End 13678397)
IVA
// @from(Start 13678399, End 13678402)
gX0
// @from(Start 13678408, End 13691028)
_G9 = L(() => {
  vX0();
  bX0();
  rI1();
  hX0();
  eI1();
  PG9();
  IVA = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }, gX0 = {
    G: function(A, Q, B) {
      let G = A.getFullYear() > 0 ? 1 : 0;
      switch (Q) {
        case "G":
        case "GG":
        case "GGG":
          return B.era(G, {
            width: "abbreviated"
          });
        case "GGGGG":
          return B.era(G, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return B.era(G, {
            width: "wide"
          })
      }
    },
    y: function(A, Q, B) {
      if (Q === "yo") {
        let G = A.getFullYear(),
          Z = G > 0 ? G : 1 - G;
        return B.ordinalNumber(Z, {
          unit: "year"
        })
      }
      return dg.y(A, Q)
    },
    Y: function(A, Q, B, G) {
      let Z = tI1(A, G),
        I = Z > 0 ? Z : 1 - Z;
      if (Q === "YY") {
        let Y = I % 100;
        return x7(Y, 2)
      }
      if (Q === "Yo") return B.ordinalNumber(I, {
        unit: "year"
      });
      return x7(I, Q.length)
    },
    R: function(A, Q) {
      let B = sI1(A);
      return x7(B, Q.length)
    },
    u: function(A, Q) {
      let B = A.getFullYear();
      return x7(B, Q.length)
    },
    Q: function(A, Q, B) {
      let G = Math.ceil((A.getMonth() + 1) / 3);
      switch (Q) {
        case "Q":
          return String(G);
        case "QQ":
          return x7(G, 2);
        case "Qo":
          return B.ordinalNumber(G, {
            unit: "quarter"
          });
        case "QQQ":
          return B.quarter(G, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return B.quarter(G, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return B.quarter(G, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    q: function(A, Q, B) {
      let G = Math.ceil((A.getMonth() + 1) / 3);
      switch (Q) {
        case "q":
          return String(G);
        case "qq":
          return x7(G, 2);
        case "qo":
          return B.ordinalNumber(G, {
            unit: "quarter"
          });
        case "qqq":
          return B.quarter(G, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return B.quarter(G, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return B.quarter(G, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    M: function(A, Q, B) {
      let G = A.getMonth();
      switch (Q) {
        case "M":
        case "MM":
          return dg.M(A, Q);
        case "Mo":
          return B.ordinalNumber(G + 1, {
            unit: "month"
          });
        case "MMM":
          return B.month(G, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return B.month(G, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return B.month(G, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    L: function(A, Q, B) {
      let G = A.getMonth();
      switch (Q) {
        case "L":
          return String(G + 1);
        case "LL":
          return x7(G + 1, 2);
        case "Lo":
          return B.ordinalNumber(G + 1, {
            unit: "month"
          });
        case "LLL":
          return B.month(G, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return B.month(G, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return B.month(G, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    w: function(A, Q, B, G) {
      let Z = TG9(A, G);
      if (Q === "wo") return B.ordinalNumber(Z, {
        unit: "week"
      });
      return x7(Z, Q.length)
    },
    I: function(A, Q, B) {
      let G = OG9(A);
      if (Q === "Io") return B.ordinalNumber(G, {
        unit: "week"
      });
      return x7(G, Q.length)
    },
    d: function(A, Q, B) {
      if (Q === "do") return B.ordinalNumber(A.getDate(), {
        unit: "date"
      });
      return dg.d(A, Q)
    },
    D: function(A, Q, B) {
      let G = MG9(A);
      if (Q === "Do") return B.ordinalNumber(G, {
        unit: "dayOfYear"
      });
      return x7(G, Q.length)
    },
    E: function(A, Q, B) {
      let G = A.getDay();
      switch (Q) {
        case "E":
        case "EE":
        case "EEE":
          return B.day(G, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return B.day(G, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return B.day(G, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return B.day(G, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    e: function(A, Q, B, G) {
      let Z = A.getDay(),
        I = (Z - G.weekStartsOn + 8) % 7 || 7;
      switch (Q) {
        case "e":
          return String(I);
        case "ee":
          return x7(I, 2);
        case "eo":
          return B.ordinalNumber(I, {
            unit: "day"
          });
        case "eee":
          return B.day(Z, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return B.day(Z, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return B.day(Z, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return B.day(Z, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    c: function(A, Q, B, G) {
      let Z = A.getDay(),
        I = (Z - G.weekStartsOn + 8) % 7 || 7;
      switch (Q) {
        case "c":
          return String(I);
        case "cc":
          return x7(I, Q.length);
        case "co":
          return B.ordinalNumber(I, {
            unit: "day"
          });
        case "ccc":
          return B.day(Z, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return B.day(Z, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return B.day(Z, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return B.day(Z, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    i: function(A, Q, B) {
      let G = A.getDay(),
        Z = G === 0 ? 7 : G;
      switch (Q) {
        case "i":
          return String(Z);
        case "ii":
          return x7(Z, Q.length);
        case "io":
          return B.ordinalNumber(Z, {
            unit: "day"
          });
        case "iii":
          return B.day(G, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return B.day(G, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return B.day(G, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return B.day(G, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    a: function(A, Q, B) {
      let Z = A.getHours() / 12 >= 1 ? "pm" : "am";
      switch (Q) {
        case "a":
        case "aa":
          return B.dayPeriod(Z, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return B.dayPeriod(Z, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return B.dayPeriod(Z, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return B.dayPeriod(Z, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    b: function(A, Q, B) {
      let G = A.getHours(),
        Z;
      if (G === 12) Z = IVA.noon;
      else if (G === 0) Z = IVA.midnight;
      else Z = G / 12 >= 1 ? "pm" : "am";
      switch (Q) {
        case "b":
        case "bb":
          return B.dayPeriod(Z, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return B.dayPeriod(Z, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return B.dayPeriod(Z, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return B.dayPeriod(Z, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    B: function(A, Q, B) {
      let G = A.getHours(),
        Z;
      if (G >= 17) Z = IVA.evening;
      else if (G >= 12) Z = IVA.afternoon;
      else if (G >= 4) Z = IVA.morning;
      else Z = IVA.night;
      switch (Q) {
        case "B":
        case "BB":
        case "BBB":
          return B.dayPeriod(Z, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return B.dayPeriod(Z, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return B.dayPeriod(Z, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    h: function(A, Q, B) {
      if (Q === "ho") {
        let G = A.getHours() % 12;
        if (G === 0) G = 12;
        return B.ordinalNumber(G, {
          unit: "hour"
        })
      }
      return dg.h(A, Q)
    },
    H: function(A, Q, B) {
      if (Q === "Ho") return B.ordinalNumber(A.getHours(), {
        unit: "hour"
      });
      return dg.H(A, Q)
    },
    K: function(A, Q, B) {
      let G = A.getHours() % 12;
      if (Q === "Ko") return B.ordinalNumber(G, {
        unit: "hour"
      });
      return x7(G, Q.length)
    },
    k: function(A, Q, B) {
      let G = A.getHours();
      if (G === 0) G = 24;
      if (Q === "ko") return B.ordinalNumber(G, {
        unit: "hour"
      });
      return x7(G, Q.length)
    },
    m: function(A, Q, B) {
      if (Q === "mo") return B.ordinalNumber(A.getMinutes(), {
        unit: "minute"
      });
      return dg.m(A, Q)
    },
    s: function(A, Q, B) {
      if (Q === "so") return B.ordinalNumber(A.getSeconds(), {
        unit: "second"
      });
      return dg.s(A, Q)
    },
    S: function(A, Q) {
      return dg.S(A, Q)
    },
    X: function(A, Q, B) {
      let G = A.getTimezoneOffset();
      if (G === 0) return "Z";
      switch (Q) {
        case "X":
          return SG9(G);
        case "XXXX":
        case "XX":
          return vQA(G);
        case "XXXXX":
        case "XXX":
        default:
          return vQA(G, ":")
      }
    },
    x: function(A, Q, B) {
      let G = A.getTimezoneOffset();
      switch (Q) {
        case "x":
          return SG9(G);
        case "xxxx":
        case "xx":
          return vQA(G);
        case "xxxxx":
        case "xxx":
        default:
          return vQA(G, ":")
      }
    },
    O: function(A, Q, B) {
      let G = A.getTimezoneOffset();
      switch (Q) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + jG9(G, ":");
        case "OOOO":
        default:
          return "GMT" + vQA(G, ":")
      }
    },
    z: function(A, Q, B) {
      let G = A.getTimezoneOffset();
      switch (Q) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + jG9(G, ":");
        case "zzzz":
        default:
          return "GMT" + vQA(G, ":")
      }
    },
    t: function(A, Q, B) {
      let G = Math.trunc(+A / 1000);
      return x7(G, Q.length)
    },
    T: function(A, Q, B) {
      return x7(+A, Q.length)
    }
  }
})
// @from(Start 13691034, End 13691405)
kG9 = (A, Q) => {
    switch (A) {
      case "P":
        return Q.date({
          width: "short"
        });
      case "PP":
        return Q.date({
          width: "medium"
        });
      case "PPP":
        return Q.date({
          width: "long"
        });
      case "PPPP":
      default:
        return Q.date({
          width: "full"
        })
    }
  }
// @from(Start 13691409, End 13691780)
yG9 = (A, Q) => {
    switch (A) {
      case "p":
        return Q.time({
          width: "short"
        });
      case "pp":
        return Q.time({
          width: "medium"
        });
      case "ppp":
        return Q.time({
          width: "long"
        });
      case "pppp":
      default:
        return Q.time({
          width: "full"
        })
    }
  }
// @from(Start 13691784, End 13692407)
eS3 = (A, Q) => {
    let B = A.match(/(P+)(p+)?/) || [],
      G = B[1],
      Z = B[2];
    if (!Z) return kG9(A, Q);
    let I;
    switch (G) {
      case "P":
        I = Q.dateTime({
          width: "short"
        });
        break;
      case "PP":
        I = Q.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        I = Q.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        I = Q.dateTime({
          width: "full"
        });
        break
    }
    return I.replace("{{date}}", kG9(G, Q)).replace("{{time}}", yG9(Z, Q))
  }
// @from(Start 13692411, End 13692414)
xG9
// @from(Start 13692420, End 13692475)
vG9 = L(() => {
  xG9 = {
    p: yG9,
    P: eS3
  }
})
// @from(Start 13692478, End 13692518)
function bG9(A) {
  return A_3.test(A)
}
// @from(Start 13692520, End 13692560)
function fG9(A) {
  return Q_3.test(A)
}
// @from(Start 13692562, End 13692671)
function hG9(A, Q, B) {
  let G = G_3(A, Q, B);
  if (console.warn(G), B_3.includes(A)) throw RangeError(G)
}
// @from(Start 13692673, End 13692945)
function G_3(A, Q, B) {
  let G = A[0] === "Y" ? "years" : "days of the month";
  return `Use \`${A.toLowerCase()}\` instead of \`${A}\` (in \`${Q}\`) for formatting ${G} to the input \`${B}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
// @from(Start 13692950, End 13692953)
A_3
// @from(Start 13692955, End 13692958)
Q_3
// @from(Start 13692960, End 13692963)
B_3
// @from(Start 13692969, End 13693049)
gG9 = L(() => {
  A_3 = /^D+$/, Q_3 = /^Y+$/, B_3 = ["D", "DD", "YY", "YYYY"]
})
// @from(Start 13693052, End 13694505)
function uG9(A, Q, B) {
  let G = $a(),
    Z = B?.locale ?? G.locale ?? xX0,
    I = B?.firstWeekContainsDate ?? B?.locale?.options?.firstWeekContainsDate ?? G.firstWeekContainsDate ?? G.locale?.options?.firstWeekContainsDate ?? 1,
    Y = B?.weekStartsOn ?? B?.locale?.options?.weekStartsOn ?? G.weekStartsOn ?? G.locale?.options?.weekStartsOn ?? 0,
    J = sJ(A, B?.in);
  if (!z79(J)) throw RangeError("Invalid time value");
  let W = Q.match(I_3).map((V) => {
    let F = V[0];
    if (F === "p" || F === "P") {
      let K = xG9[F];
      return K(V, Z.formatLong)
    }
    return V
  }).join("").match(Z_3).map((V) => {
    if (V === "''") return {
      isToken: !1,
      value: "'"
    };
    let F = V[0];
    if (F === "'") return {
      isToken: !1,
      value: X_3(V)
    };
    if (gX0[F]) return {
      isToken: !0,
      value: V
    };
    if (F.match(W_3)) throw RangeError("Format string contains an unescaped latin alphabet character `" + F + "`");
    return {
      isToken: !1,
      value: V
    }
  });
  if (Z.localize.preprocessor) W = Z.localize.preprocessor(J, W);
  let X = {
    firstWeekContainsDate: I,
    weekStartsOn: Y,
    locale: Z
  };
  return W.map((V) => {
    if (!V.isToken) return V.value;
    let F = V.value;
    if (!B?.useAdditionalWeekYearTokens && fG9(F) || !B?.useAdditionalDayOfYearTokens && bG9(F)) hG9(F, Q, String(A));
    let K = gX0[F[0]];
    return K(J, F, Z.localize, X)
  }).join("")
}
// @from(Start 13694507, End 13694602)
function X_3(A) {
  let Q = A.match(Y_3);
  if (!Q) return A;
  return Q[1].replace(J_3, "'")
}
// @from(Start 13694607, End 13694610)
Z_3
// @from(Start 13694612, End 13694615)
I_3
// @from(Start 13694617, End 13694620)
Y_3
// @from(Start 13694622, End 13694625)
J_3
// @from(Start 13694627, End 13694630)
W_3
// @from(Start 13694636, End 13694876)
mG9 = L(() => {
  LG9();
  rjA();
  _G9();
  vG9();
  gG9();
  kX0();
  GN();
  Z_3 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, I_3 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Y_3 = /^'([^]*?)'?$/, J_3 = /''/g, W_3 = /[a-zA-Z]/
})
// @from(Start 13694882, End 13694896)
dG9 = () => {}
// @from(Start 13694902, End 13694916)
cG9 = () => {}
// @from(Start 13694922, End 13694936)
pG9 = () => {}
// @from(Start 13694942, End 13694956)
lG9 = () => {}
// @from(Start 13694962, End 13694976)
iG9 = () => {}
// @from(Start 13694982, End 13694996)
nG9 = () => {}
// @from(Start 13695002, End 13695016)
aG9 = () => {}
// @from(Start 13695022, End 13695036)
sG9 = () => {}
// @from(Start 13695042, End 13695056)
rG9 = () => {}
// @from(Start 13695062, End 13695076)
oG9 = () => {}
// @from(Start 13695082, End 13695096)
tG9 = () => {}
// @from(Start 13695102, End 13695116)
eG9 = () => {}
// @from(Start 13695122, End 13695136)
AZ9 = () => {}
// @from(Start 13695142, End 13695156)
QZ9 = () => {}
// @from(Start 13695162, End 13695176)
BZ9 = () => {}
// @from(Start 13695182, End 13695196)
GZ9 = () => {}
// @from(Start 13695202, End 13695216)
ZZ9 = () => {}
// @from(Start 13695222, End 13695236)
IZ9 = () => {}
// @from(Start 13695242, End 13695256)
YZ9 = () => {}
// @from(Start 13695262, End 13695276)
JZ9 = () => {}
// @from(Start 13695282, End 13695296)
WZ9 = () => {}
// @from(Start 13695302, End 13695316)
XZ9 = () => {}
// @from(Start 13695322, End 13695336)
VZ9 = () => {}
// @from(Start 13695342, End 13695356)
FZ9 = () => {}
// @from(Start 13695362, End 13695376)
KZ9 = () => {}
// @from(Start 13695382, End 13695396)
DZ9 = () => {}
// @from(Start 13695402, End 13695416)
HZ9 = () => {}
// @from(Start 13695422, End 13695436)
CZ9 = () => {}
// @from(Start 13695442, End 13695456)
EZ9 = () => {}
// @from(Start 13695462, End 13695476)
zZ9 = () => {}
// @from(Start 13695482, End 13695496)
UZ9 = () => {}
// @from(Start 13695502, End 13695516)
$Z9 = () => {}
// @from(Start 13695522, End 13695536)
wZ9 = () => {}
// @from(Start 13695542, End 13695556)
qZ9 = () => {}
// @from(Start 13695562, End 13695576)
NZ9 = () => {}
// @from(Start 13695582, End 13695596)
LZ9 = () => {}
// @from(Start 13695602, End 13695616)
MZ9 = () => {}
// @from(Start 13695622, End 13695636)
OZ9 = () => {}
// @from(Start 13695642, End 13695656)
RZ9 = () => {}
// @from(Start 13695662, End 13695676)
TZ9 = () => {}
// @from(Start 13695682, End 13695696)
PZ9 = () => {}
// @from(Start 13695702, End 13695716)
jZ9 = () => {}
// @from(Start 13695722, End 13695736)
SZ9 = () => {}
// @from(Start 13695742, End 13695756)
_Z9 = () => {}
// @from(Start 13695762, End 13695776)
kZ9 = () => {}
// @from(Start 13695782, End 13695796)
yZ9 = () => {}
// @from(Start 13695802, End 13695816)
xZ9 = () => {}
// @from(Start 13695822, End 13695836)
vZ9 = () => {}
// @from(Start 13695842, End 13695856)
bZ9 = () => {}
// @from(Start 13695862, End 13695876)
fZ9 = () => {}
// @from(Start 13695882, End 13695896)
hZ9 = () => {}
// @from(Start 13695902, End 13695916)
gZ9 = () => {}
// @from(Start 13695922, End 13695936)
uZ9 = () => {}
// @from(Start 13695942, End 13695956)
mZ9 = () => {}
// @from(Start 13695962, End 13695976)
dZ9 = () => {}
// @from(Start 13695982, End 13695996)
cZ9 = () => {}
// @from(Start 13696002, End 13696016)
pZ9 = () => {}
// @from(Start 13696022, End 13696036)
lZ9 = () => {}
// @from(Start 13696042, End 13696056)
iZ9 = () => {}
// @from(Start 13696062, End 13696076)
nZ9 = () => {}
// @from(Start 13696082, End 13696096)
aZ9 = () => {}
// @from(Start 13696102, End 13696116)
sZ9 = () => {}
// @from(Start 13696122, End 13696136)
rZ9 = () => {}
// @from(Start 13696142, End 13696156)
oZ9 = () => {}
// @from(Start 13696162, End 13696176)
tZ9 = () => {}
// @from(Start 13696182, End 13696196)
eZ9 = () => {}
// @from(Start 13696202, End 13696216)
AI9 = () => {}
// @from(Start 13696222, End 13696236)
QI9 = () => {}
// @from(Start 13696242, End 13696256)
BI9 = () => {}
// @from(Start 13696262, End 13696276)
GI9 = () => {}
// @from(Start 13696282, End 13696296)
ZI9 = () => {}
// @from(Start 13696302, End 13696316)
II9 = () => {}
// @from(Start 13696322, End 13696336)
YI9 = () => {}
// @from(Start 13696342, End 13696356)
JI9 = () => {}
// @from(Start 13696362, End 13696376)
WI9 = () => {}
// @from(Start 13696382, End 13696396)
XI9 = () => {}
// @from(Start 13696402, End 13696416)
VI9 = () => {}
// @from(Start 13696422, End 13696436)
FI9 = () => {}
// @from(Start 13696442, End 13696456)
KI9 = () => {}
// @from(Start 13696462, End 13696476)
DI9 = () => {}
// @from(Start 13696482, End 13696496)
HI9 = () => {}
// @from(Start 13696502, End 13696516)
CI9 = () => {}
// @from(Start 13696522, End 13696536)
EI9 = () => {}
// @from(Start 13696542, End 13696556)
zI9 = () => {}
// @from(Start 13696562, End 13696576)
UI9 = () => {}
// @from(Start 13696582, End 13696596)
$I9 = () => {}
// @from(Start 13696602, End 13696616)
wI9 = () => {}
// @from(Start 13696622, End 13696636)
qI9 = () => {}
// @from(Start 13696642, End 13696656)
NI9 = () => {}
// @from(Start 13696662, End 13696676)
LI9 = () => {}
// @from(Start 13696682, End 13696696)
MI9 = () => {}
// @from(Start 13696702, End 13696716)
OI9 = () => {}
// @from(Start 13696722, End 13696736)
RI9 = () => {}
// @from(Start 13696742, End 13696756)
TI9 = () => {}
// @from(Start 13696762, End 13696776)
PI9 = () => {}
// @from(Start 13696782, End 13696796)
jI9 = () => {}
// @from(Start 13696802, End 13696816)
SI9 = () => {}
// @from(Start 13696822, End 13696836)
_I9 = () => {}
// @from(Start 13696842, End 13696856)
kI9 = () => {}
// @from(Start 13696862, End 13696876)
yI9 = () => {}
// @from(Start 13696882, End 13696896)
xI9 = () => {}
// @from(Start 13696902, End 13696916)
vI9 = () => {}
// @from(Start 13696922, End 13696936)
bI9 = () => {}
// @from(Start 13696942, End 13696956)
fI9 = () => {}
// @from(Start 13696962, End 13696976)
hI9 = () => {}
// @from(Start 13696982, End 13696996)
gI9 = () => {}
// @from(Start 13697002, End 13697016)
uI9 = () => {}
// @from(Start 13697022, End 13697036)
mI9 = () => {}
// @from(Start 13697042, End 13697056)
dI9 = () => {}
// @from(Start 13697062, End 13697076)
cI9 = () => {}
// @from(Start 13697082, End 13697096)
pI9 = () => {}
// @from(Start 13697102, End 13697116)
lI9 = () => {}
// @from(Start 13697122, End 13697136)
iI9 = () => {}
// @from(Start 13697142, End 13697156)
nI9 = () => {}
// @from(Start 13697162, End 13697176)
aI9 = () => {}
// @from(Start 13697182, End 13697196)
sI9 = () => {}
// @from(Start 13697202, End 13697216)
rI9 = () => {}
// @from(Start 13697222, End 13697236)
oI9 = () => {}
// @from(Start 13697242, End 13697256)
tI9 = () => {}
// @from(Start 13697262, End 13697276)
eI9 = () => {}
// @from(Start 13697282, End 13697296)
AY9 = () => {}
// @from(Start 13697302, End 13697316)
QY9 = () => {}
// @from(Start 13697322, End 13697336)
BY9 = () => {}
// @from(Start 13697342, End 13697356)
GY9 = () => {}
// @from(Start 13697362, End 13697376)
ZY9 = () => {}
// @from(Start 13697382, End 13697396)
IY9 = () => {}
// @from(Start 13697402, End 13697416)
YY9 = () => {}
// @from(Start 13697422, End 13697436)
JY9 = () => {}
// @from(Start 13697442, End 13697456)
WY9 = () => {}
// @from(Start 13697462, End 13697476)
XY9 = () => {}
// @from(Start 13697482, End 13697496)
VY9 = () => {}
// @from(Start 13697502, End 13697516)
FY9 = () => {}
// @from(Start 13697522, End 13697536)
KY9 = () => {}
// @from(Start 13697542, End 13697556)
DY9 = () => {}
// @from(Start 13697562, End 13697576)
HY9 = () => {}
// @from(Start 13697582, End 13697596)
CY9 = () => {}
// @from(Start 13697602, End 13697616)
EY9 = () => {}
// @from(Start 13697622, End 13697636)
zY9 = () => {}
// @from(Start 13697642, End 13697656)
UY9 = () => {}
// @from(Start 13697662, End 13697676)
$Y9 = () => {}
// @from(Start 13697682, End 13697696)
wY9 = () => {}
// @from(Start 13697702, End 13697716)
qY9 = () => {}
// @from(Start 13697722, End 13697736)
NY9 = () => {}
// @from(Start 13697742, End 13697756)
LY9 = () => {}
// @from(Start 13697762, End 13697776)
MY9 = () => {}
// @from(Start 13697782, End 13697796)
OY9 = () => {}
// @from(Start 13697802, End 13697816)
RY9 = () => {}
// @from(Start 13697822, End 13697836)
TY9 = () => {}
// @from(Start 13697842, End 13697856)
PY9 = () => {}
// @from(Start 13697862, End 13697876)
jY9 = () => {}
// @from(Start 13697882, End 13697896)
SY9 = () => {}
// @from(Start 13697902, End 13697916)
_Y9 = () => {}
// @from(Start 13697922, End 13697936)
kY9 = () => {}
// @from(Start 13697942, End 13697956)
yY9 = () => {}
// @from(Start 13697962, End 13697976)
xY9 = () => {}
// @from(Start 13697982, End 13700202)
vY9 = L(() => {
  u39();
  p39();
  h39();
  i39();
  e39();
  l39();
  A79();
  g39();
  Q79();
  B79();
  G79();
  Z79();
  I79();
  W79();
  X79();
  V79();
  F79();
  K79();
  Ua();
  D79();
  H79();
  U79();
  jX0();
  $79();
  w79();
  q79();
  L79();
  M79();
  O79();
  R79();
  T79();
  j79();
  S79();
  _79();
  v79();
  b79();
  f79();
  h79();
  g79();
  u79();
  m79();
  d79();
  c79();
  l79();
  i79();
  n79();
  s79();
  t79();
  e79();
  k79();
  AG9();
  QG9();
  GG9();
  ZG9();
  IG9();
  y79();
  YG9();
  JG9();
  WG9();
  XG9();
  BG9();
  r79();
  VG9();
  mG9();
  dG9();
  cG9();
  pG9();
  lG9();
  iG9();
  nG9();
  aG9();
  sG9();
  rG9();
  oG9();
  tG9();
  eG9();
  AZ9();
  QZ9();
  vX0();
  BZ9();
  ZZ9();
  IZ9();
  YZ9();
  JZ9();
  WZ9();
  bX0();
  rI1();
  XZ9();
  VZ9();
  FZ9();
  KZ9();
  DZ9();
  N79();
  HZ9();
  CZ9();
  EZ9();
  hX0();
  zZ9();
  eI1();
  $Z9();
  wZ9();
  qZ9();
  NZ9();
  LZ9();
  MZ9();
  OZ9();
  RZ9();
  TZ9();
  PZ9();
  jZ9();
  _X0();
  SZ9();
  _Z9();
  kZ9();
  yZ9();
  xZ9();
  x79();
  GZ9();
  mZ9();
  dZ9();
  cZ9();
  C79();
  lZ9();
  nZ9();
  aZ9();
  rZ9();
  oZ9();
  tZ9();
  AI9();
  iZ9();
  QI9();
  m39();
  d39();
  BI9();
  GI9();
  ZI9();
  II9();
  YI9();
  JI9();
  WI9();
  XI9();
  VI9();
  FI9();
  KI9();
  DI9();
  kX0();
  HI9();
  c39();
  CI9();
  zI9();
  UI9();
  wI9();
  qI9();
  UZ9();
  NI9();
  $I9();
  LI9();
  MI9();
  Y79();
  OI9();
  RI9();
  TI9();
  PI9();
  J79();
  jI9();
  SI9();
  _I9();
  kI9();
  yI9();
  xI9();
  vI9();
  bI9();
  fI9();
  hI9();
  gI9();
  uI9();
  mI9();
  uZ9();
  dI9();
  cI9();
  pI9();
  lI9();
  iI9();
  nI9();
  aI9();
  sI9();
  rI9();
  oI9();
  tI9();
  eI9();
  AY9();
  QY9();
  BY9();
  GY9();
  ZY9();
  YY9();
  JY9();
  hZ9();
  WY9();
  XY9();
  VY9();
  gZ9();
  fZ9();
  t39();
  FY9();
  KY9();
  IY9();
  DY9();
  HY9();
  bZ9();
  CY9();
  EY9();
  PX0();
  zY9();
  pZ9();
  ojA();
  SX0();
  sZ9();
  a79();
  p79();
  eZ9();
  UY9();
  $Y9();
  BVA();
  fX0();
  yX0();
  wY9();
  NY9();
  LY9();
  EI9();
  MY9();
  P79();
  OY9();
  RY9();
  qY9();
  TY9();
  PY9();
  jY9();
  SY9();
  GN();
  vZ9();
  _Y9();
  kY9();
  yY9();
  xY9()
})
// @from(Start 13700205, End 13701177)
function bY9() {
  let [A, Q] = tjA.useState([]), [B, G] = tjA.useState(0);
  if (tjA.useEffect(() => {
      let Z = nQ.getSandboxViolationStore();
      return Z.subscribe((Y) => {
        Q(Y.slice(-10)), G(Z.getTotalCount())
      })
    }, []), !nQ.isSandboxingEnabled() || dQ() === "linux") return null;
  if (B === 0) return null;
  return Qz.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, Qz.createElement(S, {
    marginLeft: 0
  }, Qz.createElement($, {
    color: "permission"
  }, "⧈ Sandbox blocked ", B, " total", " ", B === 1 ? "operation" : "operations")), A.map((Z, I) => Qz.createElement(S, {
    key: `${Z.timestamp.getTime()}-${I}`,
    paddingLeft: 2
  }, Qz.createElement($, {
    dimColor: !0
  }, uG9(Z.timestamp, "h:mm:ssa"), Z.command ? ` ${Z.command}:` : "", " ", Z.line))), Qz.createElement(S, {
    paddingLeft: 2
  }, Qz.createElement($, {
    dimColor: !0
  }, "… showing last ", Math.min(10, A.length), " of ", B)))
}
// @from(Start 13701182, End 13701184)
Qz
// @from(Start 13701186, End 13701189)
tjA
// @from(Start 13701195, End 13701284)
fY9 = L(() => {
  hA();
  $J();
  vY9();
  Q3();
  Qz = BA(VA(), 1), tjA = BA(VA(), 1)
})
// @from(Start 13701287, End 13701837)
function AY1() {
  let {
    addNotification: A
  } = vZ(), [Q, B] = YVA.useState(() => {
    let {
      errors: Z
    } = wa();
    return Z
  }), G = YVA.useCallback(() => {
    let {
      errors: Z
    } = wa();
    B(Z)
  }, []);
  return t7A(G), YVA.useEffect(() => {
    if (Q.length > 0) A({
      key: "settings-errors",
      jsx: uX0.createElement($, {
        dimColor: !0
      }, "Found ", Q.length, " invalid settings", " ", Q.length === 1 ? "file" : "files", " · /doctor for details"),
      priority: "high"
    })
  }, [Q, A]), Q
}
// @from(Start 13701842, End 13701845)
YVA
// @from(Start 13701847, End 13701850)
uX0
// @from(Start 13701856, End 13701946)
mX0 = L(() => {
  MB();
  YrA();
  EU();
  hA();
  YVA = BA(VA(), 1), uX0 = BA(VA(), 1)
})
// @from(Start 13701949, End 13702964)
function gY9({
  mcpClients: A = []
}) {
  let {
    addNotification: Q
  } = vZ();
  hY9.useEffect(() => {
    let B = A.filter((Z) => Z.type === "failed" && Z.config.type !== "sse-ide" && Z.config.type !== "ws-ide"),
      G = A.filter((Z) => Z.type === "needs-auth");
    if (B.length === 0 && G.length === 0) return;
    if (B.length > 0) Q({
      key: "mcp-failed",
      jsx: NK.createElement(NK.Fragment, null, NK.createElement($, {
        color: "error"
      }, B.length, " MCP", " ", B.length === 1 ? "server" : "servers", " failed"), NK.createElement($, {
        dimColor: !0
      }, " · /mcp for info")),
      priority: "medium"
    });
    if (G.length) Q({
      key: "mcp-needs-auth",
      jsx: NK.createElement(NK.Fragment, null, NK.createElement($, {
        color: "warning"
      }, G.length, " MCP", " ", G.length === 1 ? "server needs" : "servers need", " ", "auth"), NK.createElement($, {
        dimColor: !0
      }, " · /mcp for info")),
      priority: "medium"
    })
  }, [Q, A])
}
// @from(Start 13702969, End 13702971)
NK
// @from(Start 13702973, End 13702976)
hY9
// @from(Start 13702982, End 13703054)
uY9 = L(() => {
  hA();
  EU();
  NK = BA(VA(), 1), hY9 = BA(VA(), 1)
})
// @from(Start 13703057, End 13704284)
function mY9() {
  let {
    addNotification: A
  } = vZ(), [Q] = OQ(), {
    installationStatus: B
  } = Q.plugins, {
    totalFailed: G,
    failedMarketplacesCount: Z,
    failedPluginsCount: I
  } = QY1.useMemo(() => {
    if (!B) return {
      totalFailed: 0,
      failedMarketplacesCount: 0,
      failedPluginsCount: 0
    };
    let Y = B.marketplaces.filter((W) => W.status === "failed"),
      J = B.plugins.filter((W) => W.status === "failed");
    return {
      totalFailed: Y.length + J.length,
      failedMarketplacesCount: Y.length,
      failedPluginsCount: J.length
    }
  }, [B]);
  QY1.useEffect(() => {
    if (!B) {
      g("No installation status to monitor");
      return
    }
    if (G === 0) return;
    if (g(`Plugin installation status: ${Z} failed marketplaces, ${I} failed plugins`), G === 0) return;
    g(`Adding notification for ${G} failed installations`), A({
      key: "plugin-install-failed",
      jsx: Vx.createElement(Vx.Fragment, null, Vx.createElement($, {
        color: "error"
      }, G, " plugin", G === 1 ? "" : "s", " failed to install"), Vx.createElement($, {
        dimColor: !0
      }, " · /plugin for details")),
      priority: "medium"
    })
  }, [A, G, Z, I])
}
// @from(Start 13704289, End 13704291)
Vx
// @from(Start 13704293, End 13704296)
QY1
// @from(Start 13704302, End 13704390)
dY9 = L(() => {
  hA();
  EU();
  z9();
  V0();
  Vx = BA(VA(), 1), QY1 = BA(VA(), 1)
})
// @from(Start 13704392, End 13704570)
async function cY9() {
  let A = l0(),
    Q = new Map;
  if (A.extraKnownMarketplaces)
    for (let [B, G] of Object.entries(A.extraKnownMarketplaces)) Q.set(B, G);
  return Q
}
// @from(Start 13704571, End 13704787)
async function pY9(A) {
  try {
    let Q = await pZ(),
      B = [];
    for (let [G] of A)
      if (!Q[G]) B.push(G);
    return B
  } catch (Q) {
    return AA(Q instanceof Error ? Q : Error(String(Q))), []
  }
}
// @from(Start 13704792, End 13704833)
lY9 = L(() => {
  MB();
  oH();
  g1()
})
// @from(Start 13704836, End 13704888)
function V_3() {
  return new Date().toISOString()
}
// @from(Start 13704889, End 13705324)
async function Bj(A, Q) {
  if (typeof Q.source === "string") throw Error("cacheAndRegisterPlugin should only be used for external plugins");
  let B = await SIA(Q.source, {
      manifest: Q
    }),
    G = await mI1(B.path),
    Z = V_3();
  return M39(A, {
    version: B.manifest.version || Q.version || "unknown",
    installedAt: Z,
    lastUpdated: Z,
    installPath: B.path,
    gitCommitSha: G,
    isLocal: !1
  }), B.path
}
// @from(Start 13705329, End 13705362)
ejA = L(() => {
  za();
  fV()
})
// @from(Start 13705364, End 13705556)
async function dX0() {
  let A = l0(),
    Q = [];
  if (A.enabledPlugins) {
    for (let [B, G] of Object.entries(A.enabledPlugins))
      if (B.includes("@") && G) Q.push(B)
  }
  return Q
}
// @from(Start 13705557, End 13705953)
async function cX0() {
  if (qX0().catch((B) => {
      AA(B instanceof Error ? B : Error(String(B)))
    }), o2("tengu_enable_versioned_plugins")) {
    let B = wX0(),
      G = Object.keys(B.plugins);
    return g(`Found ${G.length} installed plugins (V2 format, versioned plugins enabled)`), G
  }
  let A = QVA(),
    Q = Object.keys(A);
  return g(`Found ${Q.length} installed plugins`), Q
}
// @from(Start 13705954, End 13706298)
async function iY9(A) {
  try {
    let Q = await cX0(),
      B = [];
    for (let G of A)
      if (!Q.includes(G)) try {
        if (await nl(G)) B.push(G)
      } catch (Z) {
        g(`Failed to check plugin ${G} in marketplace: ${Z}`)
      }
    return B
  } catch (Q) {
    return AA(Q instanceof Error ? Q : Error(String(Q))), []
  }
}
// @from(Start 13706303, End 13706401)
nY9 = L(() => {
  MB();
  oH();
  g1();
  V0();
  u2();
  fV();
  MB();
  AQ();
  ejA();
  za()
})
// @from(Start 13706404, End 13706743)
function pX0(A, Q, B, G) {
  A((Z) => ({
    ...Z,
    plugins: {
      ...Z.plugins,
      installationStatus: {
        ...Z.plugins.installationStatus,
        marketplaces: Z.plugins.installationStatus.marketplaces.map((I) => I.name === Q ? {
          ...I,
          status: B,
          error: G
        } : I)
      }
    }
  }))
}
// @from(Start 13706745, End 13707072)
function lX0(A, Q, B, G) {
  A((Z) => ({
    ...Z,
    plugins: {
      ...Z.plugins,
      installationStatus: {
        ...Z.plugins.installationStatus,
        plugins: Z.plugins.installationStatus.plugins.map((I) => I.id === Q ? {
          ...I,
          status: B,
          error: G
        } : I)
      }
    }
  }))
}
// @from(Start 13707073, End 13707588)
async function F_3(A, Q, B) {
  let G = [],
    Z = [];
  for (let I of A) {
    let Y = Q.get(I);
    if (!Y) continue;
    pX0(B, I, "installing");
    try {
      await rAA(Y.source), G.push(I), pX0(B, I, "installed"), d22(), _IA(), await K_3(I, B)
    } catch (J) {
      let W = J instanceof Error ? J.message : String(J);
      Z.push({
        name: I,
        error: W
      }), pX0(B, I, "failed", W), AA(J instanceof Error ? J : Error(String(J)))
    }
  }
  return {
    installed: G,
    failed: Z
  }
}
// @from(Start 13707589, End 13707930)
async function K_3(A, Q) {
  try {
    let G = (await dX0()).filter((Z) => Z.endsWith(`@${A}`));
    if (G.length > 0) {
      let Z = await iY9(G);
      if (Z.length > 0) g(`Installing ${Z.length} plugins from newly installed marketplace ${A}`), await aY9(Z, Q)
    }
  } catch (B) {
    AA(B instanceof Error ? B : Error(String(B)))
  }
}
// @from(Start 13707931, End 13708822)
async function aY9(A, Q) {
  let G = {
      ...OB("userSettings")?.enabledPlugins
    },
    Z = [],
    I = [];
  for (let Y of A) {
    lX0(Q, Y, "installing");
    try {
      let J = await nl(Y);
      if (!J) throw Error("Plugin not found in any marketplace");
      let {
        entry: W
      } = J;
      if (typeof W.source !== "string" || !W.source.startsWith("./")) await Bj(Y, W);
      if (l0().enabledPlugins?.[Y] !== !0) G[Y] = !0;
      Z.push(Y), lX0(Q, Y, "installed")
    } catch (J) {
      let W = J instanceof Error ? J.message : String(J);
      I.push({
        name: Y,
        error: W
      }), lX0(Q, Y, "failed", W), AA(J instanceof Error ? J : Error(String(J)))
    }
  }
  if (Object.keys(G).length > 0) {
    let Y = OB("userSettings");
    cB("userSettings", {
      ...Y,
      enabledPlugins: G
    })
  }
  return {
    installed: Z,
    failed: I
  }
}
// @from(Start 13708823, End 13711549)
async function BY1(A) {
  g("performBackgroundPluginInstallations called");
  try {
    let Q = [],
      B = [],
      G = await pZ(),
      Z = await cY9();
    if (Z.size > 0) {
      g(`Found ${Z.size} extra marketplaces in settings`);
      let J = await pY9(Z);
      if (J.length > 0) {
        g(`Installing ${J.length} marketplaces automatically`);
        for (let W of J) {
          let X = Z.get(W);
          if (X) Q.push({
            name: W,
            marketplace: X
          })
        }
      }
    }
    let I = await dX0(),
      Y = [];
    if (I.length > 0) {
      g(`Found ${I.length} enabled plugins`);
      let J = await cX0(),
        W = I.filter((V) => !J.includes(V));
      g(`Found ${W.length} missing plugins (not installed): ${W.join(", ")}`);
      let X = [];
      for (let V of W) {
        let [, F] = V.split("@");
        if (!F) X.push(V);
        else if (F in G || Z.has(F) || Q.some((K) => K.name === F)) X.push(V);
        else Y.push(V)
      }
      if (Y.length > 0) {
        let V = [...new Set(Y.map((F) => F.split("@")[1]))];
        g(`Cannot install ${Y.length} plugins because their marketplaces are not installed or configured: ${V.join(", ")}`), g(`Uninstallable plugins: ${Y.join(", ")}`)
      }
      if (X.length > 0) g(`Installing ${X.length} plugins automatically`), B.push(...X)
    }
    if (g(`Setting installation status: ${Q.length} marketplaces, ${B.length} installable plugins, ${Y.length} uninstallable plugins`), A((J) => ({
        ...J,
        plugins: {
          ...J.plugins,
          installationStatus: {
            marketplaces: Q.map(({
              name: W
            }) => ({
              name: W,
              status: "pending"
            })),
            plugins: [...B.map((W) => {
              let [X] = W.split("@");
              return {
                id: W,
                name: X || W,
                status: "pending"
              }
            }), ...Y.map((W) => {
              let [X, V] = W.split("@");
              return {
                id: W,
                name: X || W,
                status: "failed",
                error: `Marketplace '${V}' is not installed or configured`
              }
            })]
          }
        }
      })), Q.length > 0) F_3(Q.map((J) => J.name), Z, A).catch((J) => {
      AA(J instanceof Error ? J : Error(String(J)))
    });
    if (B.length > 0) {
      let J = B.filter((W) => {
        let [, X] = W.split("@");
        return !Q.some((V) => V.name === X)
      });
      if (J.length > 0) aY9(J, A).catch((W) => {
        AA(W instanceof Error ? W : Error(String(W)))
      })
    }
  } catch (Q) {
    AA(Q instanceof Error ? Q : Error(String(Q)))
  }
}
// @from(Start 13711554, End 13711646)
iX0 = L(() => {
  V0();
  g1();
  lY9();
  nY9();
  oH();
  oH();
  fV();
  ejA();
  MB()
})
// @from(Start 13711648, End 13711978)
async function sY9(A) {
  if (g("performStartupChecks called"), !TJ(!0)) {
    g("Trust not accepted for current directory - skipping plugin installations");
    return
  }
  try {
    g("Starting background plugin installations"), await BY1(A)
  } catch (Q) {
    g(`Error initiating background plugin installations: ${Q}`)
  }
}
// @from(Start 13711983, End 13712025)
rY9 = L(() => {
  V0();
  iX0();
  jQ()
})
// @from(Start 13712028, End 13712638)
function tY9() {
  let {
    addNotification: A
  } = vZ(), [{
    thinkingEnabled: Q
  }] = OQ();
  oY9.useEffect(() => {
    A({
      key: "toggled-thinking-initial",
      jsx: Q ? cg.createElement($, {
        color: "suggestion"
      }, "Thinking on", " ", cg.createElement(E4, {
        shortcut: "tab",
        action: "toggle",
        parens: !0
      })) : cg.createElement($, {
        dimColor: !0
      }, "Thinking off", " ", cg.createElement(E4, {
        shortcut: "tab",
        action: "toggle",
        parens: !0
      })),
      priority: "low",
      timeoutMs: 20000
    })
  }, [A])
}
// @from(Start 13712643, End 13712645)
cg
// @from(Start 13712647, End 13712650)
oY9
// @from(Start 13712656, End 13712744)
eY9 = L(() => {
  EU();
  hA();
  z9();
  dF();
  cg = BA(VA(), 1), oY9 = BA(VA(), 1)
})
// @from(Start 13712747, End 13713367)
function AJ9(A) {
  let {
    addNotification: Q
  } = vZ(), B = w91(), G = o00(B, A), Z = t00(B), I = bQA.useRef(null), [Y, J] = bQA.useState(!1);
  bQA.useEffect(() => {
    if (B.isUsingOverage && !Y) Q({
      key: "limit-reached",
      text: Z,
      priority: "immediate"
    }), J(!0);
    else if (!B.isUsingOverage && Y) J(!1)
  }, [B.isUsingOverage, Z, Y, Q]), bQA.useEffect(() => {
    if (G && G !== I.current) I.current = G, Q({
      key: "rate-limit-warning",
      jsx: ASA.createElement($, null, ASA.createElement($, {
        color: "warning"
      }, G)),
      priority: "high"
    })
  }, [G, Q])
}
// @from(Start 13713372, End 13713375)
ASA
// @from(Start 13713377, End 13713380)
bQA
// @from(Start 13713386, End 13713467)
QJ9 = L(() => {
  EU();
  Pi();
  hA();
  ASA = BA(VA(), 1), bQA = BA(VA(), 1)
})
// @from(Start 13713470, End 13715177)
function GJ9({
  ideSelection: A,
  mcpClients: Q,
  ideInstallationStatus: B
}) {
  let {
    addNotification: G
  } = vZ(), Z = yXA(Q), I = B ? oT(B?.ideType) : !1, Y = B?.error || I, J = Z === "connected" && (A?.filePath || A?.text && A.lineCount > 0), W = Z === "connected" && !J, X = Y && !I && !W && !J, V = Y && I && !W && !J;
  BJ9.useEffect(() => {
    if (bV() || Z !== null) return;
    HLA(!0).then((F) => {
      if (F.length > 0) {
        let K = F[0]?.name;
        if (K && !V) G({
          key: "ide-status-hint",
          jsx: Gj.createElement($, {
            dimColor: !0
          }, H1.circle, " /ide for ", D_3(K)),
          priority: "low"
        });
        else if (!X && Z === "disconnected") G({
          key: "ide-status-disconnected",
          jsx: Gj.createElement($, {
            color: "error",
            key: "ide-status"
          }, H1.circle, " IDE disconnected"),
          priority: "medium"
        });
        else if (V) G({
          key: "ide-status-jetbrains-disconnected",
          jsx: Gj.createElement($, {
            dimColor: !0
          }, "IDE plugin not connected · /status for info"),
          priority: "medium"
        });
        else if (W) G({
          key: "ide-status-connected",
          jsx: Gj.createElement($, {
            color: "ide",
            key: "ide-status"
          }, H1.circle, "IDE connected"),
          priority: "low"
        });
        else if (X) G({
          key: "ide-status-install-error",
          jsx: Gj.createElement($, {
            color: "error"
          }, "IDE extension install failed (see /status for info)"),
          priority: "medium"
        })
      }
    })
  }, [G, Z, W, X, V])
}
// @from(Start 13715179, End 13715261)
function D_3(A) {
  if (A === "Visual Studio Code") return "VS Code";
  return A
}
// @from(Start 13715266, End 13715269)
BJ9
// @from(Start 13715271, End 13715273)
Gj
// @from(Start 13715279, End 13715376)
ZJ9 = L(() => {
  EU();
  nY();
  qZ1();
  hA();
  V9();
  BJ9 = BA(VA(), 1), Gj = BA(VA(), 1)
})
// @from(Start 13715379, End 13715742)
function YJ9() {
  let {
    addNotification: A
  } = vZ();
  IJ9.useEffect(() => {
    let B = N1().sonnet45MigrationTimestamp;
    if (B) {
      if (Date.now() - B < 3000) A({
        key: "sonnet-4.5-update",
        text: "Model updated to Sonnet 4.5",
        color: "suggestion",
        priority: "high",
        timeoutMs: 3000
      })
    }
  }, [A])
}
// @from(Start 13715747, End 13715750)
IJ9
// @from(Start 13715756, End 13715810)
JJ9 = L(() => {
  EU();
  jQ();
  IJ9 = BA(VA(), 1)
})
// @from(Start 13715813, End 13716529)
function XJ9() {
  let {
    addNotification: A
  } = vZ();
  WJ9.useEffect(() => {
    if (N1().subscriptionNoticeCount ?? 0 >= H_3) return;
    C_3().then((Q) => {
      if (Q === null) return;
      let B = N1();
      c0({
        ...B,
        subscriptionNoticeCount: (B.subscriptionNoticeCount ?? 0) + 1
      }), GA("tengu_switch_to_subscription_notice_shown", {}), A({
        key: "switch-to-subscription",
        jsx: QSA.createElement($, {
          color: "suggestion"
        }, "Use your existing Claude ", Q, " plan with Claude Code", QSA.createElement($, {
          color: "text",
          dimColor: !0
        }, " ", "· /login to activate")),
        priority: "low"
      })
    })
  }, [A])
}
// @from(Start 13716530, End 13716731)
async function C_3() {
  if (BB()) return null;
  let A = await dbA();
  if (!A) return null;
  if (A.account.has_claude_max) return "Max";
  if (A.account.has_claude_pro) return "Pro";
  return null
}
// @from(Start 13716736, End 13716739)
QSA
// @from(Start 13716741, End 13716744)
WJ9
// @from(Start 13716746, End 13716753)
H_3 = 3
// @from(Start 13716759, End 13716865)
VJ9 = L(() => {
  hA();
  kDA();
  jQ();
  q0();
  gB();
  EU();
  QSA = BA(VA(), 1), WJ9 = BA(VA(), 1)
})
// @from(Start 13716868, End 13717473)
function FJ9({
  onRun: A,
  onCancel: Q,
  reason: B
}) {
  let G = JVA.useRef(!1);
  return f1(JVA.useCallback((Z, I) => {
    if (I.escape) Q()
  }, [Q])), JVA.useEffect(() => {
    if (!G.current) G.current = !0, A()
  }, [A]), Bz.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, Bz.createElement(S, null, Bz.createElement($, {
    bold: !0
  }, "Running /issue to capture feedback...")), Bz.createElement(S, null, Bz.createElement($, {
    dimColor: !0
  }, "Press Esc anytime to cancel")), Bz.createElement(S, null, Bz.createElement($, {
    dimColor: !0
  }, "Reason: ", B)))
}
// @from(Start 13717475, End 13717637)
function nX0(A) {
  return !1;
  switch (A) {
    case "feedback_survey_bad":
      return !0;
    case "feedback_survey_good":
    default:
      return !1
  }
}
// @from(Start 13717639, End 13717904)
function KJ9(A) {
  switch (A) {
    case "feedback_survey_bad":
      return 'You responded "Bad" to the feedback survey';
    case "feedback_survey_good":
      return 'You responded "Good" to the feedback survey';
    default:
      return "Unknown reason"
  }
}
// @from(Start 13717909, End 13717911)
Bz
// @from(Start 13717913, End 13717916)
JVA
// @from(Start 13717922, End 13717986)
DJ9 = L(() => {
  hA();
  Bz = BA(VA(), 1), JVA = BA(VA(), 1)
})
// @from(Start 13718035, End 13718369)
function HJ9({
  mainThreadAgentDefinition: A,
  toolUseContext: Q,
  customSystemPrompt: B,
  defaultSystemPrompt: G,
  appendSystemPrompt: Z
}) {
  let I = A ? $O(A) ? A.getSystemPrompt({
    toolUseContext: {
      options: Q.options
    }
  }) : A.getSystemPrompt() : void 0;
  return [...I ? [I] : B ? [B] : G, ...Z ? [Z] : []]
}
// @from(Start 13718371, End 13743708)
function WVA({
  commands: A,
  debug: Q,
  initialPrompt: B,
  initialTools: G,
  initialMessages: Z,
  initialFileHistorySnapshots: I,
  mcpClients: Y,
  dynamicMcpConfig: J,
  mcpCliEndpoint: W,
  autoConnectIdeFlag: X,
  strictMcpConfig: V = !1,
  systemPrompt: F,
  appendSystemPrompt: K,
  onBeforeQuery: D,
  onTurnComplete: H,
  disabled: C = !1,
  mainThreadAgentDefinition: E
}) {
  let [U, q] = OQ(), {
    toolPermissionContext: w,
    verbose: N,
    mcp: R,
    plugins: T,
    agentDefinitions: y
  } = U, v = Ja(), x = QB.useMemo(() => LC(w), [w]);
  S39();
  let [p, u] = QB.useState(J), e = QB.useCallback((a0) => {
    u(a0)
  }, [u]), [l, k] = QB.useState("prompt"), [m, o] = QB.useState(1), [IA, FA] = QB.useState(!1), {
    addNotification: zA
  } = vZ(), NA = P69(Y, R.clients), [OA, mA] = QB.useState(void 0), [wA, qA] = QB.useState(null), [KA, yA] = QB.useState(null), [oA, X1] = QB.useState(!1);
  YJ9(), XJ9(), GJ9({
    ideSelection: OA,
    mcpClients: NA,
    ideInstallationStatus: KA
  }), gY9({
    mcpClients: NA
  }), mY9(), AY1(), tY9(), AJ9(v), E39();
  let WA = QB.useMemo(() => {
    return [...x, ...G]
  }, [x, G]);
  $I1(), QB.useEffect(() => {
    sY9(q)
  }, [q]);
  let EA = CI1(WA, R.tools),
    MA = QB.useMemo(() => {
      if (!E) return EA;
      let {
        resolvedTools: a0
      } = Sn(E, EA, !1);
      return a0
    }, [E, EA]),
    DA = lW0(A, T.commands),
    $A = lW0(DA, R.commands);
  Lf2(R.clients), p59(R.clients, mA);
  let [TA, rA] = QB.useState("responding"), [iA, J1] = QB.useState([]), [w1, jA] = QB.useState(null), [eA, t1] = QB.useState(!1), [v1, F0] = QB.useState(0), [g0, p0] = QB.useState(void 0), n0 = QB.useCallback((a0) => {
    if (t1(a0), a0) F0(0)
  }, []);
  CI(() => {
    if (eA && iQ !== "tool-permission") F0((a0) => a0 + 100)
  }, 100);
  let [_1, zQ] = QB.useState(null);
  QB.useEffect(() => {
    if (_1?.notifications) _1.notifications.forEach((a0) => {
      zA({
        key: "auto-updater-notification",
        text: a0,
        priority: "low"
      })
    })
  }, [_1, zA]);
  let [W1, O1] = QB.useState(null), [a1, C0] = QB.useState([]), [v0, k0] = QB.useState([]), [f0, G0] = QB.useState(Z ?? []), [yQ, aQ] = QB.useState([]), [sQ, K0] = QB.useState(""), [mB, e2] = QB.useState("prompt"), [s8, K5] = QB.useState({}), [g6, c3] = QB.useState(0), [tZ, H7] = QB.useState(0), [H8, r5] = QB.useState(0), [nG, aG] = QB.useState(null), [U1, sA] = QB.useState(null), [E1, M1] = QB.useState(null), [k1, O0] = QB.useState(!1), [oQ, tB] = QB.useState(!1), [y9, Y6] = QB.useState(aX0()), [u9, r8] = QB.useState(N1().hasAcknowledgedCostThreshold), [$6, T8] = QB.useState(new Set), [i9, J6] = QB.useState("INSERT"), [N4, QG] = QB.useState(!1), [w6, b5] = QB.useState(!1), n9 = QB.useRef(!1), I8 = QB.useRef(null), [f5] = qB(), Y8 = QB.useCallback(() => {
    R39().then(async (a0) => {
      if (a0) {
        let eB = await a0.content({
          theme: f5
        });
        q((IB) => ({
          ...IB,
          spinnerTip: eB
        })), T39(a0)
      } else q((eB) => ({
        ...eB,
        spinnerTip: void 0
      }))
    })
  }, [q, f5]), d4 = QB.useCallback(() => {
    n0(!1), p0(void 0), H7(0), J1([]), aG(null), sA(null), M1(null), Y8(), X61()
  }, [n0, Y8]), a9 = q69(sQ), L4 = (!W1 || W1.showSpinner === !0) && a1.length === 0 && eA, o5 = W39(f0, eA, g6), m9 = QB.useMemo(() => ({
    ...o5,
    handleSelect: (a0) => {
      if (o5.handleSelect(a0), a0 === "bad" && nX0("feedback_survey_bad") || a0 === "good" && nX0("feedback_survey_good")) T1(a0 === "bad" ? "feedback_survey_bad" : "feedback_survey_good")
    }
  }), [o5]), d9 = V39(f0, eA);
  Q39({
    autoConnectIdeFlag: X,
    ideToInstallExtension: wA,
    setDynamicMcpConfig: u,
    setShowIdeOnboarding: X1,
    setIDEInstallationState: yA
  }), y39(I, U.fileHistory, (a0) => q((eB) => ({
    ...eB,
    fileHistory: a0
  })));
  let cA = QB.useCallback(async (a0, eB, IB) => {
      GA("tengu_session_resumed", {
        entrypoint: IB
      });
      let $9 = nMA(eB.messages),
        q6 = await wq("resume", a0);
      if ($9.push(...q6), Z91(eB), A01(eB), eB.fileHistorySnapshots) xYA(eB.fileHistorySnapshots, (C8) => {
        q((x4) => ({
          ...x4,
          fileHistory: C8
        }))
      }), p91(eB);
      if (xA($9, eB.projectPath ?? uQ()), d4(), jA(null), !gH()) await kJ();
      Y6(a0), zR(a0), await Fx(), G0(() => $9), O1(null), K0(""), aQ([])
    }, [d4, q]),
    YA = e1(),
    ZA = QB.useMemo(() => Ri(e1()), []),
    SA = QB.useRef((() => {
      let a0 = Gh(GY1);
      return a0.set(ZA, {
        content: JSON.stringify(U.todos[YA] || []),
        timestamp: 0,
        offset: void 0,
        limit: void 0
      }), a0
    })()),
    xA = QB.useCallback((a0, eB) => {
      let IB = xI1(a0, eB, GY1);
      SA.current = X01(SA.current, IB)
    }, []);
  QB.useEffect(() => {
    if (Z && Z.length > 0) xA(Z, uQ())
  }, []);
  let {
    status: dA,
    reverify: C1
  } = W69(), [j1, T1] = QB.useState(null), [m1, p1] = QB.useState(null), [D0, GQ] = QB.useState(!1), lQ = !eA && oQ;

  function lB() {
    if (D0 || m1) return;
    if (k1) return "message-selector";
    if (v0[0]) return "sandbox-permission";
    let a0 = !W1 || W1.shouldContinueAnimation;
    if (a0 && a1[0]) return "tool-permission";
    if (a0 && U.elicitation.queue[0]) return "elicitation";
    if (a0 && lQ) return "cost";
    if (a0 && oA) return "ide-onboarding";
    return
  }
  let iQ = lB();

  function s2() {
    if (iQ === "elicitation") return;
    if (d4(), iQ === "tool-permission") a1[0]?.onAbort(), C0([]);
    else w1?.abort()
  }
  let P8 = QB.useCallback(async () => {
    let a0 = await VI1(sQ, 0, async () => new Promise((eB) => q((IB) => {
      return eB(IB), IB
    })), q);
    if (!a0) return;
    K0(a0.text), e2("prompt")
  }, [q, K0, e2, sQ]);
  D69(C0, s2, k1 || N4, l, w1?.signal, P8, i9, W1?.isLocalJSXCommand, w6), QB.useEffect(() => {
    if (hK() >= 5 && !oQ && !u9) {
      if (GA("tengu_cost_threshold_reached", {}), jiA()) tB(!0)
    }
  }, [f0, oQ, u9]);
  let C7 = QB.useCallback(async (a0) => {
    return new Promise((eB) => {
      k0((IB) => [...IB, {
        hostPattern: a0,
        resolvePromise: eB
      }])
    })
  }, []);
  if (nQ.isSandboxingEnabled()) nQ.initialize(C7).catch((a0) => {
    process.stderr.write(`
❌ Sandbox Error: ${a0 instanceof Error?a0.message:String(a0)}
`), l5(1, "other")
  });
  let D5 = QB.useCallback((a0) => {
      q((eB) => ({
        ...eB,
        toolPermissionContext: a0
      })), setImmediate(() => {
        C0((eB) => {
          return eB.forEach((IB) => {
            IB.recheckPermission()
          }), eB
        })
      })
    }, [q, C0]),
    AW = U69(C0, D5),
    u6 = QB.useCallback((a0, eB, IB, $9, q6, C8) => {
      return {
        abortController: IB,
        options: {
          commands: $A,
          tools: MA,
          debug: Q,
          verbose: N,
          mainLoopModel: C8,
          maxThinkingTokens: q6 ?? (U.thinkingEnabled ? Xf(eB, void 0) : 0),
          mcpClients: NA,
          mcpResources: R.resources,
          ideInstallationStatus: KA,
          isNonInteractiveSession: !1,
          hasAppendSystemPrompt: !1,
          dynamicMcpConfig: p,
          theme: f5,
          agentDefinitions: y
        },
        getAppState() {
          return new Promise((x4) => {
            q((J8) => {
              return x4(J8), {
                ...J8,
                toolPermissionContext: {
                  ...J8.toolPermissionContext,
                  alwaysAllowRules: {
                    ...J8.toolPermissionContext.alwaysAllowRules,
                    command: $9
                  }
                }
              }
            })
          })
        },
        setAppState: q,
        messages: a0,
        setMessages: G0,
        updateFileHistoryState(x4) {
          q((J8) => ({
            ...J8,
            fileHistory: x4(J8.fileHistory)
          }))
        },
        openMessageSelector: () => {
          if (!C) O0(!0)
        },
        onChangeAPIKey: C1,
        readFileState: SA.current,
        setToolJSX: O1,
        addNotification: zA,
        onChangeDynamicMcpConfig: e,
        onInstallIDEExtension: qA,
        nestedMemoryAttachmentTriggers: new Set,
        setResponseLength: H7,
        setStreamMode: rA,
        setSpinnerMessage: aG,
        setSpinnerColor: sA,
        setSpinnerShimmerColor: M1,
        setInProgressToolUseIDs: T8,
        agentId: YA,
        resume: cA
      }
    }, [$A, MA, Q, N, NA, R.resources, KA, p, f5, y, q, C1, zA, e, YA, cA, U.thinkingEnabled, C]),
    QW = QB.useCallback((a0) => {
      K0(a0)
    }, [sQ, q]),
    NY = QB.useCallback(async (a0, eB, IB, $9, q6, C8, x4) => {
      let J8 = eB.filter((W8) => W8.type === "user" || W8.type === "assistant").pop();
      if ($9) {
        Oh.handleQueryStart(NA);
        let W8 = uU(NA);
        if (W8) JB2(W8)
      }
      if (n7A(), J8?.type === "user" && typeof J8.message.content === "string") yeB(J8.message.content);
      if (!$9) {
        d4(), jA(null);
        return
      }
      let x9 = u6(a0, eB, IB, q6, x4, C8);
      s7("query_context_loading_start");
      let [, T4, N3, KV] = await Promise.all([LX0(w, q), Tn(MA, C8, Array.from(w.additionalWorkingDirectories.keys()), NA, w), DK(), iD()]);
      s7("query_context_loading_end");
      let IF = HJ9({
        mainThreadAgentDefinition: E,
        toolUseContext: x9,
        customSystemPrompt: F,
        defaultSystemPrompt: T4,
        appendSystemPrompt: K
      });
      s7("query_query_start");
      for await (let W8 of O$({
        messages: a0,
        systemPrompt: IF,
        userContext: N3,
        systemContext: KV,
        canUseTool: AW,
        toolUseContext: x9,
        querySource: MjA()
      })) fQA(W8, (BG) => {
        G0((tW) => [...tW, BG])
      }, (BG) => H7((tW) => tW + BG.length), rA, J1);
      s7("query_end"), d4(), oP2(), H?.()
    }, [NA, d4, u6, w, q, MA, F, H, K, AW, E]),
    G4 = QB.useCallback(async (a0, eB, IB, $9, q6, C8, x4, J8) => {
      if (n9.current) return GA("tengu_concurrent_onquery_detected", {}), a0.filter((x9) => x9.type === "user").map((x9) => QWA(x9.message.content)).filter((x9) => x9 !== null).forEach((x9, T4) => {
        if (XI1({
            value: x9,
            mode: "prompt"
          }, q), T4 === 0) GA("tengu_concurrent_onquery_enqueued", {})
      }), n0(!1), {
        status: "skipped",
        reason: "already_running"
      };
      n9.current = !0, I8.current = a0;
      try {
        if (n0(!0), G0((T4) => [...T4, ...a0]), p0(void 0), H7(0), J1([]), x4 && J8) {
          let T4 = [...f0, ...a0];
          if (!await x4(J8, T4)) return {
            status: "skipped",
            reason: "blocked_by_callback"
          }
        }
        let x9 = await new Promise((T4) => {
          G0((N3) => {
            return T4(N3), N3
          })
        });
        await NY(x9, a0, eB, IB, $9, q6, C8)
      } finally {
        n9.current = !1, r5(Date.now()), d4()
      }
      return {
        status: "completed"
      }
    }, [f0, NY, n0, q, d4]),
    BJ = QB.useCallback(async (a0, eB, IB) => {
      await dW0({
        input: a0,
        memoryPath: eB,
        helpers: IB,
        isLoading: eA,
        mode: mB,
        commands: $A,
        onInputChange: K0,
        onModeChange: e2,
        setPastedContents: K5,
        onSubmitCountChange: c3,
        setIDESelection: mA,
        setIsLoading: n0,
        setToolJSX: O1,
        getToolUseContext: u6,
        messages: f0,
        mainLoopModel: v,
        pastedContents: s8,
        ideSelection: OA,
        setUserInputOnProcessing: p0,
        setAbortController: jA,
        onQuery: G4,
        resetLoadingState: d4,
        thinkingTokens: a9.tokens,
        thinkingEnabled: U.thinkingEnabled,
        getAppState: () => new Promise(($9) => q((q6) => {
          return $9(q6), q6
        })),
        setAppState: q,
        querySource: MjA(),
        onBeforeQuery: D
      })
    }, [eA, mB, $A, K0, e2, K5, c3, mA, n0, O1, u6, f0, v, s8, OA, p0, jA, G4, d4, a9.tokens, U.thinkingEnabled, q, D]),
    sG = QB.useCallback(() => {
      T1(null), BJ("/issue", void 0, {
        setCursorOffset: () => {},
        clearBuffer: () => {},
        resetHistory: () => {}
      })
    }, [BJ]),
    jK = QB.useCallback(() => {
      T1(null)
    }, []),
    oW = QB.useCallback(() => {
      BJ("/rate-limit-options", void 0, {
        setCursorOffset: () => {},
        clearBuffer: () => {},
        resetHistory: () => {}
      })
    }, [BJ]);
  async function ZF() {
    C1();
    let a0 = gV();
    for (let IB of a0) SA.current.set(IB.path, {
      content: IB.content,
      timestamp: Date.now(),
      offset: void 0,
      limit: void 0
    });
    if (!B) return;
    n0(!0), H7(0), J1([]);
    let eB = YU0();
    jA(eB);
    try {
      let {
        messages: IB,
        shouldQuery: $9,
        allowedTools: q6
      } = await TP({
        input: B,
        mode: "prompt",
        setIsLoading: n0,
        setToolJSX: O1,
        context: u6(f0, f0, eB, [], void 0, v),
        ideSelection: OA,
        messages: f0,
        setUserInputOnProcessing: p0,
        querySource: MjA()
      });
      if (EG()) IB.filter(yn).forEach((C8) => {
        yYA((x4) => {
          q((J8) => ({
            ...J8,
            fileHistory: x4(J8.fileHistory)
          }))
        }, C8.uuid)
      });
      if (IB.length) {
        for (let KV of IB)
          if (KV.type === "user") Jf(B);
        if (G0((KV) => [...KV, ...IB]), !$9) {
          jA(null);
          return
        }
        let [C8, x4, J8] = await Promise.all([Tn(MA, v, Array.from(w.additionalWorkingDirectories.keys()), NA, w), DK(), iD()]), x9 = u6([...f0, ...IB], IB, eB, [], void 0, v), T4 = HJ9({
          mainThreadAgentDefinition: E,
          toolUseContext: x9,
          customSystemPrompt: F,
          defaultSystemPrompt: C8,
          appendSystemPrompt: K
        }), N3 = q6 ? {
          ...x9,
          async getAppState() {
            return {
              ...U,
              toolPermissionContext: {
                ...U.toolPermissionContext,
                alwaysAllowRules: {
                  ...U.toolPermissionContext.alwaysAllowRules,
                  command: q6
                }
              }
            }
          }
        } : x9;
        for await (let KV of O$({
          messages: [...f0, ...IB],
          systemPrompt: T4,
          userContext: x4,
          systemContext: J8,
          canUseTool: AW,
          toolUseContext: N3,
          querySource: MjA()
        })) fQA(KV, (IF) => {
          G0((W8) => [...W8, IF])
        }, (IF) => H7((W8) => W8 + IF.length), rA, J1);
        H?.()
      } else Jf(B);
      r8(N1().hasAcknowledgedCostThreshold || !1)
    } finally {
      d4()
    }
  }
  X8B(), Ef2(f0, f0.length === Z?.length), Y69(), QB.useEffect(() => {
    if (U.queuedCommands.length < 1) return;
    let a0 = N1();
    c0({
      ...a0,
      promptQueueUseCount: (a0.promptQueueUseCount ?? 0) + 1
    })
  }, [U.queuedCommands.length]), QB.useEffect(() => {
    DRA.recordUserActivity(), UFA()
  }, [sQ, g6]);
  let q3 = QB.useRef(new Set);
  QB.useEffect(() => {
    let a0 = new Set(f0.filter((IB) => lh(IB)).map((IB) => IB.uuid));
    if (Array.from(a0).some((IB) => !q3.current.has(IB))) {
      if (q3.current = a0, !gH()) kJ();
      Y6(aX0())
    }
  }, [f0]), QB.useEffect(() => {
    if (eA) return;
    if (g6 === 0) return;
    if (H8 === 0) return;
    let a0 = setTimeout(() => {
      if (zkA() > H8) return;
      let IB = Date.now() - H8;
      if (!eA && !W1 && iQ === void 0 && IB >= N1().messageIdleNotifThresholdMs) E0A({
        message: "Claude is waiting for your input",
        notificationType: "idle_prompt"
      })
    }, N1().messageIdleNotifThresholdMs);
    return () => clearTimeout(a0)
  }, [eA, W1, g6, iQ, H8]), t59(eA, H8), QB.useEffect(() => {
    return ZF(), () => {
      Oh.shutdown()
    }
  }, []);
  let {
    internal_eventEmitter: GJ
  } = Yp(), [BW, DN] = QB.useState(0);
  QB.useEffect(() => {
    let a0 = () => {
        process.stdout.write(`
Claude Code has been suspended. Run \`fg\` to bring Claude Code back.
Note: ctrl + z now suspends Claude Code, ctrl + _ undoes input.
`)
      },
      eB = () => {
        DN((IB) => IB + 1)
      };
    return GJ?.on("suspend", a0), GJ?.on("resume", eB), () => {
      GJ?.off("suspend", a0), GJ?.off("resume", eB)
    }
  }, [GJ]);
  let x$ = QB.useMemo(() => nJ(yQ).filter(ujA), [yQ]),
    H5 = QB.useMemo(() => {
      if (!eA) return null;
      let a0 = f0.filter((T4) => T4.type === "progress" && T4.data.type === "hook_progress" && (T4.data.hookEvent === "Stop" || T4.data.hookEvent === "SubagentStop"));
      if (a0.length === 0) return null;
      let eB = [...new Set(a0.map((T4) => T4.toolUseID))],
        IB = eB[eB.length - 1];
      if (!IB) return null;
      if (f0.some((T4) => T4.type === "system" && T4.subtype === "stop_hook_summary" && T4.toolUseID === IB)) return null;
      let q6 = a0.filter((T4) => T4.toolUseID === IB),
        C8 = q6.length,
        x4 = f0.filter((T4) => {
          if (T4.type !== "attachment") return !1;
          let N3 = T4.attachment;
          return "hookEvent" in N3 && (N3.hookEvent === "Stop" || N3.hookEvent === "SubagentStop") && "toolUseID" in N3 && N3.toolUseID === IB
        }).length,
        J8 = q6.find((T4) => T4.data.statusMessage)?.data.statusMessage;
      if (J8) return C8 === 1 ? `${J8}…` : `${J8}… ${x4}/${C8}`;
      let x9 = q6[0]?.data.hookEvent === "SubagentStop" ? "subagent stop" : "stop";
      return C8 === 1 ? `running ${x9} hook` : `running stop hooks… ${x4}/${C8}`
    }, [f0, eA]);
  d59(l, k, o, FA, kJ);
  let M4 = U.todos[YA];
  if (F69(M4), l === "transcript") return I9.createElement(I9.Fragment, null, I9.createElement(_QA, {
    messages: f0,
    normalizedMessageHistory: x$,
    tools: MA,
    verbose: !0,
    toolJSX: null,
    toolUseConfirmQueue: [],
    inProgressToolUseIDs: $6,
    isMessageSelectorVisible: !1,
    conversationId: y9,
    screen: l,
    agentDefinitions: y,
    screenToggleId: m,
    streamingToolUses: iA,
    showAllInTranscript: IA,
    onOpenRateLimitOptions: oW
  }), W1 && I9.createElement(S, {
    flexDirection: "column",
    width: "100%"
  }, W1.jsx), I9.createElement(bY9, null), I9.createElement(S, {
    alignItems: "center",
    alignSelf: "center",
    borderTopDimColor: !0,
    borderBottom: !1,
    borderLeft: !1,
    borderRight: !1,
    borderStyle: "single",
    marginTop: 1,
    paddingLeft: 2,
    width: "100%"
  }, I9.createElement($, {
    dimColor: !0
  }, "Showing detailed transcript · ctrl+o to toggle")));
  return I9.createElement(_Z1, {
    key: BW,
    dynamicMcpConfig: p,
    isStrictMcpConfig: V,
    mcpCliEndpoint: W
  }, I9.createElement(_QA, {
    messages: f0,
    normalizedMessageHistory: x$,
    tools: MA,
    verbose: N,
    toolJSX: W1,
    toolUseConfirmQueue: a1,
    inProgressToolUseIDs: $6,
    isMessageSelectorVisible: k1,
    conversationId: y9,
    screen: l,
    screenToggleId: m,
    streamingToolUses: iA,
    showAllInTranscript: IA,
    agentDefinitions: y,
    onOpenRateLimitOptions: oW
  }), I9.createElement(I39, null), W1 && I9.createElement(S, {
    flexDirection: "column",
    width: "100%"
  }, W1.jsx), I9.createElement(S, {
    flexDirection: "column",
    width: "100%"
  }, !C && g0 && I9.createElement(LQA, {
    param: {
      text: g0,
      type: "text"
    },
    addMargin: !0,
    verbose: N
  }), !1, L4 && I9.createElement(OO2, {
    mode: TA,
    spinnerTip: U.spinnerTip,
    currentResponseLength: tZ,
    overrideMessage: nG,
    spinnerSuffix: H5,
    verbose: N,
    elapsedTimeMs: v1,
    todos: M4,
    overrideColor: U1,
    overrideShimmerColor: E1,
    hasActiveTools: $6.size > 0
  }), !L4 && U.showExpandedTodos && I9.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, I9.createElement(Yn, {
    todos: M4 || [],
    isStandalone: !0
  })), iQ === "sandbox-permission" && I9.createElement(v39, {
    key: v0[0].hostPattern.host,
    hostPattern: v0[0].hostPattern,
    onUserResponse: (a0) => {
      let {
        allow: eB,
        persistToSettings: IB
      } = a0, $9 = v0[0];
      if (!$9) return;
      let q6 = $9.hostPattern.host;
      if (IB) {
        let C8 = {
          type: "addRules",
          rules: [{
            toolName: $X,
            ruleContent: `domain:${q6}`
          }],
          behavior: eB ? "allow" : "deny",
          destination: "localSettings"
        };
        q((x4) => ({
          ...x4,
          toolPermissionContext: UF(x4.toolPermissionContext, C8)
        })), Iv(C8), nQ.refreshConfig()
      }
      k0((C8) => {
        return C8.filter((x4) => x4.hostPattern.host === q6).forEach((x4) => x4.resolvePromise(eB)), C8.filter((x4) => x4.hostPattern.host !== q6)
      })
    }
  }), iQ === "tool-permission" && I9.createElement(cd2, {
    key: a1[0]?.toolUseID,
    onDone: () => C0(([a0, ...eB]) => eB),
    onReject: P8,
    toolUseConfirm: a1[0],
    toolUseContext: u6(f0, f0, w1 ?? o9(), [], void 0, v),
    verbose: N
  }), iQ === "elicitation" && I9.createElement(ad2, {
    serverName: U.elicitation.queue[0].serverName,
    request: U.elicitation.queue[0].request,
    onResponse: (a0, eB) => {
      let IB = U.elicitation.queue[0];
      if (IB) q(($9) => ({
        ...$9,
        elicitation: {
          queue: $9.elicitation.queue.slice(1)
        }
      })), IB.respond({
        action: a0,
        content: eB
      })
    },
    signal: U.elicitation.queue[0].signal
  }), iQ === "cost" && I9.createElement(Df2, {
    onDone: () => {
      tB(!1), r8(!0);
      let a0 = N1();
      c0({
        ...a0,
        hasAcknowledgedCostThreshold: !0
      }), GA("tengu_cost_threshold_acknowledged", {})
    }
  }), iQ === "ide-onboarding" && I9.createElement(iQ2, {
    onDone: () => X1(!1),
    installationStatus: KA
  }), m1, !W1?.shouldHidePromptInput && !iQ && !D0 && !C && I9.createElement(I9.Fragment, null, j1 && I9.createElement(FJ9, {
    onRun: sG,
    onCancel: jK,
    reason: KJ9(j1)
  }), d9.state !== "closed" ? I9.createElement(CX0, {
    state: d9.state,
    handleSelect: d9.handleSelect,
    inputValue: sQ,
    setInputValue: K0,
    message: "How did that compaction go? (optional)"
  }) : I9.createElement(CX0, {
    state: m9.state,
    handleSelect: m9.handleSelect,
    inputValue: sQ,
    setInputValue: K0
  }), I9.createElement(G69, {
    debug: Q,
    ideSelection: OA,
    getToolUseContext: u6,
    toolPermissionContext: w,
    setToolPermissionContext: D5,
    apiKeyStatus: dA,
    commands: $A,
    agents: y.activeAgents,
    isLoading: eA,
    onExit: async () => {
      GQ(!0);
      let a0 = await hI1.call(() => {});
      p1(a0)
    },
    verbose: N,
    messages: f0,
    onAutoUpdaterResult: zQ,
    autoUpdaterResult: _1,
    input: sQ,
    onInputChange: QW,
    mode: mB,
    onModeChange: e2,
    submitCount: g6,
    onShowMessageSelector: () => O0((a0) => !a0),
    mcpClients: NA,
    pastedContents: s8,
    setPastedContents: K5,
    vimMode: i9,
    setVimMode: J6,
    showBashesDialog: N4,
    setShowBashesDialog: QG,
    onSubmit: BJ,
    isSearchingHistory: w6,
    setIsSearchingHistory: b5
  }))), iQ === "message-selector" && I9.createElement($f2, {
    messages: f0,
    onPreRestore: s2,
    onRestoreCode: async (a0) => {
      await iMA((eB) => {
        q((IB) => ({
          ...IB,
          fileHistory: eB(IB.fileHistory)
        }))
      }, a0.uuid)
    },
    onRestoreMessage: async (a0) => {
      let eB = f0.indexOf(a0),
        IB = f0.slice(0, eB);
      setImmediate(async () => {
        if (!gH()) await kJ();
        if (G0([...IB]), Y6(aX0()), q(($9) => ({
            ...$9,
            todos: {
              ...$9.todos,
              [YA]: a0.todos ?? []
            },
            promptSuggestion: {
              text: null,
              shownAt: 0
            }
          })), UYA(a0.todos ?? [], YA), typeof a0.message.content === "string") {
          let $9 = a0.message.content,
            q6 = B9($9, "bash-input"),
            C8 = B9($9, "command-name");
          if (q6) K0(q6), e2("bash");
          else if (C8) {
            let x4 = B9($9, "command-args") || "";
            K0(`${C8} ${x4}`), e2("prompt")
          } else K0($9), e2("prompt")
        } else if (Array.isArray(a0.message.content) && a0.message.content.length >= 2 && a0.message.content.some(($9) => $9.type === "image") && a0.message.content.some(($9) => $9.type === "text")) {
          let $9 = a0.message.content.find((C8) => C8.type === "text");
          if ($9 && $9.type === "text") K0($9.text), e2("prompt");
          let q6 = a0.message.content.filter((C8) => C8.type === "image");
          if (q6.length > 0) {
            let C8 = {};
            q6.forEach((x4, J8) => {
              if (x4.source.type === "base64") C8[J8 + 1] = {
                id: J8 + 1,
                type: "image",
                content: x4.source.data,
                mediaType: x4.source.media_type
              }
            }), K5(C8)
          }
        }
      })
    },
    onClose: () => O0(!1)
  }))
}
// @from(Start 13743713, End 13743715)
I9
// @from(Start 13743717, End 13743719)
QB
// @from(Start 13743721, End 13743730)
GY1 = 100
// @from(Start 13743736, End 13744589)
ZY1 = L(() => {
  hA();
  Hf2();
  JE();
  EU();
  h61();
  vM();
  _0();
  F0A();
  zf2();
  zTA();
  Mf2();
  pd2();
  sd2();
  Z69();
  DY();
  Pn();
  Ty();
  gE();
  M_();
  J69();
  zp();
  X69();
  K69();
  H69();
  $69();
  N69();
  cK();
  jQ();
  q0();
  cQ();
  Bh();
  nt();
  CU();
  kW();
  R69();
  fRA();
  Ca();
  j69();
  cW0();
  pW0();
  y69();
  nW0();
  _I1();
  HRA();
  N$A();
  c59();
  k1A();
  l59();
  yq();
  fP();
  S0A();
  ePA();
  z9();
  AWA();
  Ti();
  NE();
  S7();
  vYA();
  XX0();
  sU();
  e59();
  nY();
  B39();
  KX0();
  RQA();
  R1A();
  Ke1();
  L80();
  OZ();
  $QA();
  Y39();
  X39();
  F39();
  H39();
  z39();
  P39();
  _39();
  $J();
  x39();
  b39();
  fY9();
  mX0();
  uY9();
  dY9();
  rY9();
  II1();
  eY9();
  QJ9();
  ZJ9();
  JJ9();
  VJ9();
  DJ9();
  I9 = BA(VA(), 1), QB = BA(VA(), 1)
})
// @from(Start 13744638, End 13744848)
function IY1(A) {
  return {
    systemPrompt: A.systemPrompt,
    userContext: A.userContext,
    systemContext: A.systemContext,
    toolUseContext: A.toolUseContext,
    forkContextMessages: A.messages
  }
}
// @from(Start 13744850, End 13746460)
function BSA(A, Q) {
  let B = Q?.abortController ?? (Q?.shareAbortController ? A.abortController : JU0(A.abortController)),
    G = Q?.getAppState ? Q.getAppState : Q?.shareAbortController ? A.getAppState : async () => {
      let Z = await A.getAppState();
      if (Z.toolPermissionContext.shouldAvoidPermissionPrompts) return Z;
      return {
        ...Z,
        toolPermissionContext: {
          ...Z.toolPermissionContext,
          shouldAvoidPermissionPrompts: !0
        }
      }
    };
  return {
    readFileState: kAA(Q?.readFileState ?? A.readFileState),
    nestedMemoryAttachmentTriggers: new Set,
    toolDecisions: void 0,
    pendingSteeringAttachments: void 0,
    abortController: B,
    getAppState: G,
    setAppState: Q?.shareSetAppState ? A.setAppState : () => {},
    setMessages: () => {},
    setInProgressToolUseIDs: () => {},
    setResponseLength: Q?.shareSetResponseLength ? A.setResponseLength : () => {},
    updateFileHistoryState: () => {},
    addNotification: void 0,
    setToolJSX: void 0,
    setStreamMode: void 0,
    setSpinnerMessage: void 0,
    setSpinnerColor: void 0,
    setSpinnerShimmerColor: void 0,
    setSDKStatus: void 0,
    openMessageSelector: void 0,
    options: Q?.options ?? A.options,
    messages: Q?.messages ?? A.messages,
    agentId: Q?.agentId ?? SWA(),
    isSubAgent: !0,
    queryTracking: {
      chainId: E_3(),
      depth: (A.queryTracking?.depth ?? -1) + 1
    },
    fileReadingLimits: A.fileReadingLimits,
    userModified: A.userModified,
    criticalSystemReminder_EXPERIMENTAL: Q?.criticalSystemReminder_EXPERIMENTAL
  }
}
// @from(Start 13746461, End 13748129)
async function YY1({
  promptMessages: A,
  cacheSafeParams: Q,
  canUseTool: B,
  querySource: G,
  forkLabel: Z,
  overrides: I
}) {
  let Y = Date.now(),
    J = [],
    W = {
      ...bO
    },
    {
      systemPrompt: X,
      userContext: V,
      systemContext: F,
      toolUseContext: K,
      forkContextMessages: D
    } = Q,
    H = BSA(K, I),
    C = [...sX0(D), ...A];
  for await (let U of O$({
    messages: C,
    systemPrompt: X,
    userContext: V,
    systemContext: F,
    canUseTool: B,
    toolUseContext: H,
    querySource: G
  })) {
    if (U.type === "stream_event" || U.type === "stream_request_start") continue;
    if (U.type === "assistant") {
      let w = U.message.usage;
      if (w) W = vI1(W, {
        input_tokens: w.input_tokens ?? 0,
        cache_creation_input_tokens: w.cache_creation_input_tokens ?? 0,
        cache_read_input_tokens: w.cache_read_input_tokens ?? 0,
        output_tokens: w.output_tokens ?? 0,
        server_tool_use: {
          web_search_requests: w.server_tool_use?.web_search_requests ?? 0,
          web_fetch_requests: w.server_tool_use?.web_fetch_requests ?? 0
        },
        service_tier: w.service_tier ?? "standard",
        cache_creation: {
          ephemeral_1h_input_tokens: w.cache_creation?.ephemeral_1h_input_tokens ?? 0,
          ephemeral_5m_input_tokens: w.cache_creation?.ephemeral_5m_input_tokens ?? 0
        }
      })
    }
    J.push(U)
  }
  let E = Date.now() - Y;
  return z_3({
    forkLabel: Z,
    querySource: G,
    durationMs: E,
    messageCount: J.length,
    totalUsage: W,
    queryTracking: K.queryTracking
  }), {
    messages: J,
    totalUsage: W
  }
}
// @from(Start 13748131, End 13748988)
function z_3({
  forkLabel: A,
  querySource: Q,
  durationMs: B,
  messageCount: G,
  totalUsage: Z,
  queryTracking: I
}) {
  let Y = Z.input_tokens + Z.cache_creation_input_tokens + Z.cache_read_input_tokens,
    J = Y > 0 ? Z.cache_read_input_tokens / Y : 0;
  GA("tengu_fork_agent_query", {
    forkLabel: A,
    querySource: Q,
    durationMs: B,
    messageCount: G,
    inputTokens: Z.input_tokens,
    outputTokens: Z.output_tokens,
    cacheReadInputTokens: Z.cache_read_input_tokens,
    cacheCreationInputTokens: Z.cache_creation_input_tokens,
    serviceTier: Z.service_tier,
    cacheCreationEphemeral1hTokens: Z.cache_creation.ephemeral_1h_input_tokens,
    cacheCreationEphemeral5mTokens: Z.cache_creation.ephemeral_5m_input_tokens,
    cacheHitRate: J,
    ...I ? {
      queryChainId: I.chainId,
      queryDepth: I.depth
    } : {}
  })
}
// @from(Start 13748993, End 13749076)
JY1 = L(() => {
  Ca();
  fZ();
  cjA();
  q0();
  WY1();
  vM();
  Sy();
  OZ()
})
// @from(Start 13749124, End 13752974)
async function* XY1({
  agentDefinition: A,
  promptMessages: Q,
  toolUseContext: B,
  canUseTool: G,
  isAsync: Z,
  forkContextMessages: I,
  querySource: Y,
  override: J,
  model: W
}) {
  let X = await B.getAppState(),
    V = X.toolPermissionContext.mode,
    F = inA(A.model, B.options.mainLoopModel, W, V),
    K = J?.agentId ? J.agentId : SWA(),
    H = [...I ? sX0(I) : [], ...Q],
    C = I !== void 0 ? kAA(B.readFileState) : Gh(GY1),
    [E, U] = await Promise.all([J?.userContext ?? DK(), J?.systemContext ?? iD()]),
    q = A.permissionMode,
    N = q !== void 0 || Z ? async () => {
      let o = await B.getAppState(),
        IA = o.toolPermissionContext;
      if (q && o.toolPermissionContext.mode !== "bypassPermissions") IA = {
        ...IA,
        mode: q
      };
      if (Z) IA = {
        ...IA,
        shouldAvoidPermissionPrompts: !0
      };
      if (IA === o.toolPermissionContext) return o;
      return {
        ...o,
        toolPermissionContext: IA
      }
    }: B.getAppState, T = Sn(A, B.options.tools, Z).resolvedTools, y = Array.from(X.toolPermissionContext.additionalWorkingDirectories.keys()), v = J?.systemPrompt ? J.systemPrompt : await $_3(A, B, F, y), x = [], p, u = J?.abortController ? J.abortController : Z ? new AbortController : B.abortController, e = [];
  for await (let o of rX0(K, A.agentType, u.signal)) if (o.additionalContexts && o.additionalContexts.length > 0) e.push(...o.additionalContexts);
  if (e.length > 0) {
    let o = l9({
      type: "hook_additional_context",
      content: e,
      hookName: "SubagentStart",
      toolUseID: U_3(),
      hookEvent: "SubagentStart"
    });
    H.push(o)
  }
  let l = A.skills ?? [];
  if (l.length > 0) {
    let o = await OWA(),
      IA = [];
    for (let FA of l) {
      if (!ph(FA, o)) {
        g(`[Agent: ${A.agentType}] Warning: Skill '${FA}' specified in frontmatter was not found`, {
          level: "warn"
        });
        continue
      }
      let zA = Pq(FA, o);
      if (zA.type !== "prompt") {
        g(`[Agent: ${A.agentType}] Warning: Skill '${FA}' is not a prompt-based skill`, {
          level: "warn"
        });
        continue
      }
      IA.push({
        skillName: FA,
        skill: zA
      })
    }
    for (let {
        skillName: FA,
        skill: zA
      }
      of IA) {
      let NA = await zA.getPromptForCommand("", B);
      g(`[Agent: ${A.agentType}] Preloaded skill '${FA}'`);
      let OA = U60(FA, zA.progressMessage);
      H.push(R0({
        content: [{
          type: "text",
          text: OA
        }, ...NA]
      }))
    }
  }
  let k = {
      isNonInteractiveSession: Z ? !0 : B.options.isNonInteractiveSession ?? !1,
      hasAppendSystemPrompt: B.options.hasAppendSystemPrompt,
      tools: T,
      commands: [],
      debug: B.options.debug,
      verbose: B.options.verbose,
      mainLoopModel: F,
      maxThinkingTokens: Xf(H),
      mcpClients: B.options.mcpClients,
      mcpResources: B.options.mcpResources,
      agentDefinitions: B.options.agentDefinitions
    },
    m = BSA(B, {
      options: k,
      agentId: K,
      messages: H,
      readFileState: C,
      abortController: u,
      getAppState: N,
      shareSetAppState: !Z,
      shareSetResponseLength: !0,
      criticalSystemReminder_EXPERIMENTAL: A.criticalSystemReminder_EXPERIMENTAL
    });
  for await (let o of O$({
    messages: H,
    systemPrompt: v,
    userContext: E,
    systemContext: U,
    canUseTool: G,
    toolUseContext: m,
    querySource: Y
  })) if (o.type === "assistant" || o.type === "user" || o.type === "progress" || o.type === "system" && o.subtype === "compact_boundary") x.push(o), p = EJ9(x, K).catch((IA) => g(`Failed to record sidechain transcript: ${IA}`)), yield o;
  if (await p, u.signal.aborted) throw new WW;
  if ($O(A) && A.callback) A.callback()
}
// @from(Start 13752976, End 13753458)
function sX0(A) {
  let Q = new Set;
  for (let B of A)
    if (B?.type === "user") {
      let Z = B.message.content;
      if (Array.isArray(Z)) {
        for (let I of Z)
          if (I.type === "tool_result" && I.tool_use_id) Q.add(I.tool_use_id)
      }
    } return A.filter((B) => {
    if (B?.type === "assistant") {
      let Z = B.message.content;
      if (Array.isArray(Z)) return !Z.some((Y) => Y.type === "tool_use" && Y.id && !Q.has(Y.id))
    }
    return !0
  })
}
// @from(Start 13753459, End 13753651)
async function $_3(A, Q, B, G) {
  try {
    let Z = A.getSystemPrompt({
      toolUseContext: Q
    });
    return await GSA([Z], B, G)
  } catch (Z) {
    return await GSA([CJ9], B, G)
  }
}
// @from(Start 13753656, End 13753846)
WY1 = L(() => {
  Ca();
  RZ();
  Sy();
  Ty();
  Pn();
  t2();
  CU();
  S0A();
  fP();
  vM();
  ZY1();
  YO();
  IO();
  S7();
  V0();
  bjA();
  R9();
  cE();
  cQ();
  vRA();
  JY1()
})
// @from(Start 13753849, End 13755111)
function zJ9({
  agentType: A,
  description: Q,
  toolUseCount: B,
  tokens: G,
  color: Z,
  isLast: I,
  isResolved: Y,
  isError: J,
  isAsync: W = !1,
  shouldAnimate: X,
  lastToolInfo: V,
  hideType: F = !1
}) {
  let K = I ? "└─" : "├─",
    D = () => {
      if (!Y) return V || "Initializing…";
      return W ? "Launched" : "Done"
    };
  return b6.createElement(S, {
    flexDirection: "column"
  }, b6.createElement(S, {
    paddingLeft: 3
  }, b6.createElement($, {
    dimColor: !Y
  }, K, " ", F ? b6.createElement($, {
    bold: !0
  }, Q || A) : b6.createElement(b6.Fragment, null, b6.createElement($, {
    bold: !0,
    backgroundColor: Z,
    color: Z ? "inverseText" : void 0
  }, A), Q && b6.createElement($, null, " (", Q, ")")), " · ", W && Y ? b6.createElement($, null, "Running in background") : b6.createElement(b6.Fragment, null, b6.createElement($, {
    bold: !0
  }, B), " tool", " ", B === 1 ? "use" : "uses"), G !== null && b6.createElement(b6.Fragment, null, " · ", JZ(G), " tokens"))), b6.createElement(S, {
    paddingLeft: 3,
    flexDirection: "row"
  }, b6.createElement($, {
    dimColor: !Y
  }, I ? "   " : "│  "), b6.createElement($, {
    dimColor: !0
  }, "⎿ "), b6.createElement($, {
    dimColor: !0
  }, D())))
}
// @from(Start 13755116, End 13755118)
b6
// @from(Start 13755124, End 13755169)
UJ9 = L(() => {
  hA();
  b6 = BA(VA(), 1)
})
// @from(Start 13755172, End 13755479)
function VY1({
  prompt: A,
  theme: Q,
  dim: B = !1
}) {
  return BQ.createElement(S, {
    flexDirection: "column"
  }, BQ.createElement($, {
    color: "success",
    bold: !0
  }, "Prompt:"), BQ.createElement(S, {
    paddingLeft: 2
  }, BQ.createElement($, {
    dimColor: B
  }, Q ? fD(A, Q) : A)))
}
// @from(Start 13755481, End 13755830)
function $J9({
  content: A,
  theme: Q
}) {
  return BQ.createElement(S, {
    flexDirection: "column"
  }, BQ.createElement($, {
    color: "success",
    bold: !0
  }, "Response:"), A.map((B, G) => BQ.createElement(S, {
    key: G,
    paddingLeft: 2,
    marginTop: G === 0 ? 0 : 1
  }, BQ.createElement($, null, Q ? fD(B.text, Q) : B.text))))
}
// @from(Start 13755832, End 13757798)
function wJ9(A, Q, {
  tools: B,
  verbose: G,
  theme: Z
}) {
  if (A.status === "async_launched") {
    let {
      prompt: C
    } = A;
    return BQ.createElement(S, {
      flexDirection: "column"
    }, BQ.createElement(S0, {
      height: 1
    }, BQ.createElement($, null, "Backgrounded agent", !G && tA.dim(C ? " (down arrow ↓ to manage · ctrl+o to expand)" : " (down arrow ↓ to manage)"))), G && C && BQ.createElement(S0, null, BQ.createElement(VY1, {
      prompt: C,
      theme: Z
    })))
  }
  if (A.status !== "completed") return null;
  let {
    agentId: I,
    totalDurationMs: Y,
    totalToolUseCount: J,
    totalTokens: W,
    usage: X,
    content: V,
    prompt: F
  } = A, D = `Done (${[J===1?"1 tool use":`${J} tool uses`,JZ(W)+" tokens",eC(Y)].join(" · ")})`, H = uD({
    content: D,
    usage: X
  });
  return BQ.createElement(S, {
    flexDirection: "column"
  }, !1, G && F && BQ.createElement(S0, null, BQ.createElement(VY1, {
    prompt: F,
    theme: Z
  })), G ? BQ.createElement(Bo1, null, Q.map((C) => BQ.createElement(S0, {
    key: C.uuid
  }, BQ.createElement(xg, {
    message: C.data.message,
    messages: C.data.normalizedMessages,
    addMargin: !1,
    tools: B,
    verbose: G,
    erroredToolUseIDs: new Set,
    inProgressToolUseIDs: new Set,
    resolvedToolUseIDs: new Set,
    progressMessagesForMessage: Q,
    shouldAnimate: !1,
    shouldShowDot: !1,
    isTranscriptMode: !1,
    isStatic: !0
  })))) : null, G && V && V.length > 0 && BQ.createElement(S0, null, BQ.createElement($J9, {
    content: V,
    theme: Z
  })), BQ.createElement(S0, {
    height: 1
  }, BQ.createElement(xg, {
    message: H,
    messages: nJ([H]),
    addMargin: !1,
    tools: B,
    verbose: G,
    erroredToolUseIDs: new Set,
    inProgressToolUseIDs: new Set,
    resolvedToolUseIDs: new Set,
    progressMessagesForMessage: [],
    shouldAnimate: !1,
    shouldShowDot: !1,
    isTranscriptMode: !1,
    isStatic: !0
  })))
}
// @from(Start 13757800, End 13757891)
function qJ9({
  description: A,
  prompt: Q
}) {
  if (!A || !Q) return null;
  return A
}
// @from(Start 13757893, End 13760285)
function FY1(A, {
  tools: Q,
  verbose: B,
  terminalSize: G,
  inProgressToolCallCount: Z
}) {
  if (!A.length) return BQ.createElement(S0, {
    height: 1
  }, BQ.createElement($, {
    dimColor: !0
  }, N_3));
  let I = (Z ?? 1) * w_3 + q_3,
    Y = !B && G && G.rows && G.rows < I,
    J = () => {
      let D = A.filter((E) => {
          return E.data.message.message.content.some((q) => q.type === "tool_use")
        }).length,
        H = [...A].reverse().find((E) => E.data.message.type === "assistant"),
        C = null;
      if (H?.data.message.type === "assistant") {
        let E = H.data.message.message.usage;
        C = (E.cache_creation_input_tokens ?? 0) + (E.cache_read_input_tokens ?? 0) + E.input_tokens + E.output_tokens
      }
      return {
        toolUseCount: D,
        tokens: C
      }
    };
  if (Y) {
    let {
      toolUseCount: D,
      tokens: H
    } = J();
    return BQ.createElement(S0, {
      height: 1
    }, BQ.createElement($, {
      dimColor: !0
    }, "In progress… · ", BQ.createElement($, {
      bold: !0
    }, D), " tool", " ", D === 1 ? "use" : "uses", H && ` · ${JZ(H)} tokens`, " · (ctrl+o to expand)"))
  }
  let W = A.filter((D) => {
      return D.data.message.message.content.some((C) => C.type === "tool_use")
    }).length,
    X = B ? A : A.slice(-oX0),
    V = X.filter((D) => {
      return D.data.message.message.content.some((C) => C.type === "tool_use")
    }).length,
    F = W - V;
  if (!B && A.length > oX0) X = A.slice(-oX0 + 1);
  let K = A[0]?.data.prompt;
  return BQ.createElement(S0, null, BQ.createElement(S, {
    flexDirection: "column"
  }, BQ.createElement(Bo1, null, B && K && BQ.createElement(S, {
    marginBottom: 1
  }, BQ.createElement(VY1, {
    prompt: K
  })), X.map((D) => BQ.createElement(S, {
    key: D.uuid,
    height: 1,
    overflow: "hidden"
  }, BQ.createElement(xg, {
    message: D.data.message,
    messages: D.data.normalizedMessages,
    addMargin: !1,
    tools: Q,
    verbose: B,
    erroredToolUseIDs: new Set,
    inProgressToolUseIDs: new Set,
    resolvedToolUseIDs: BV0(A),
    progressMessagesForMessage: A,
    shouldAnimate: !1,
    shouldShowDot: !1,
    style: "condensed",
    isTranscriptMode: !1,
    isStatic: !0
  })))), F > 0 && BQ.createElement($, {
    dimColor: !0
  }, "+", F, " more tool ", F === 1 ? "use" : "uses", " ", BQ.createElement(Tl, null))))
}
// @from(Start 13760287, End 13760521)
function NJ9(A, {
  progressMessagesForMessage: Q,
  tools: B,
  verbose: G
}) {
  let Z = Q[0]?.data?.agentId;
  return BQ.createElement(BQ.Fragment, null, !1, FY1(Q, {
    tools: B,
    verbose: G
  }), BQ.createElement(k5, null))
}
// @from(Start 13760523, End 13760753)
function LJ9(A, {
  progressMessagesForMessage: Q,
  tools: B,
  verbose: G
}) {
  return BQ.createElement(BQ.Fragment, null, FY1(Q, {
    tools: B,
    verbose: G
  }), BQ.createElement(Q6, {
    result: A,
    verbose: G
  }))
}
// @from(Start 13760755, End 13761283)
function L_3(A) {
  let Q = A.filter((Z) => {
      let I = Z.data.message;
      return I.type === "user" && I.message.content.some((Y) => Y.type === "tool_result")
    }).length,
    B = [...A].reverse().find((Z) => Z.data.message.type === "assistant"),
    G = null;
  if (B?.data.message.type === "assistant") {
    let Z = B.data.message.message.usage;
    G = (Z.cache_creation_input_tokens ?? 0) + (Z.cache_read_input_tokens ?? 0) + Z.input_tokens + Z.output_tokens
  }
  return {
    toolUseCount: Q,
    tokens: G
  }
}
// @from(Start 13761285, End 13763205)
function MJ9(A, Q) {
  let {
    shouldAnimate: B,
    tools: G
  } = Q, Z = A.map(({
    param: F,
    isResolved: K,
    isError: D,
    progressMessages: H
  }) => {
    let C = L_3(H),
      E = M_3(H, G),
      U = QV0.safeParse(F.input),
      q = U.success ? tX0(U.data) : "Task",
      w = U.success ? U.data.description : void 0,
      N = U.success ? eX0(U.data) : void 0,
      R = U.success && "run_in_background" in U.data && U.data.run_in_background === !0;
    return {
      id: F.id,
      agentType: q,
      description: w,
      toolUseCount: C.toolUseCount,
      tokens: C.tokens,
      isResolved: K,
      isError: D,
      isAsync: R,
      color: N,
      lastToolInfo: E
    }
  }), I = A.some((F) => !F.isResolved), Y = A.some((F) => F.isError), J = !I, W = Z.length > 0 && Z.every((F) => F.agentType === Z[0]?.agentType), X = W ? Z[0]?.agentType : null, V = Z.every((F) => F.isAsync);
  return BQ.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, BQ.createElement(S, {
    flexDirection: "row"
  }, BQ.createElement(dZ1, {
    shouldAnimate: B && I,
    isUnresolved: I,
    isError: Y
  }), BQ.createElement($, null, J ? BQ.createElement(BQ.Fragment, null, BQ.createElement($, {
    bold: !0
  }, A.length), " ", X ? `${X} agents` : "agents", " ", V ? "launched" : "finished") : BQ.createElement(BQ.Fragment, null, "Running ", BQ.createElement($, {
    bold: !0
  }, A.length), " ", X ? `${X} agents` : "agents", "…")), BQ.createElement($, {
    dimColor: !0
  }, " (ctrl+o to expand)")), Z.map((F, K) => BQ.createElement(zJ9, {
    key: F.id,
    agentType: F.agentType,
    description: F.description,
    toolUseCount: F.toolUseCount,
    tokens: F.tokens,
    color: F.color,
    isLast: K === Z.length - 1,
    isResolved: F.isResolved,
    isError: F.isError,
    isAsync: F.isAsync,
    shouldAnimate: B,
    lastToolInfo: F.lastToolInfo,
    hideType: W
  })))
}
// @from(Start 13763207, End 13763327)
function tX0(A) {
  if (A?.subagent_type && A.subagent_type !== o51.agentType) return A.subagent_type;
  return "Task"
}
// @from(Start 13763329, End 13763411)
function eX0(A) {
  if (!A?.subagent_type) return;
  return PWA(A.subagent_type)
}
// @from(Start 13763413, End 13764594)
function M_3(A, Q) {
  let B = [...A].reverse().find((G) => {
    let Z = G.data.message;
    return Z.type === "user" && Z.message.content.some((I) => I.type === "tool_result")
  });
  if (B?.data.message.type === "user") {
    let G = B.data.message.message.content.find((Z) => Z.type === "tool_result");
    if (G?.type === "tool_result") {
      let Z = G.tool_use_id,
        I = A.find((Y) => {
          let J = Y.data.message;
          return J.type === "assistant" && J.message.content.some((W) => W.type === "tool_use" && W.id === Z)
        });
      if (I?.data.message.type === "assistant") {
        let Y = I.data.message.message.content.find((J) => J.type === "tool_use" && J.id === Z);
        if (Y?.type === "tool_use") {
          let J = Q.find((F) => F.name === Y.name);
          if (!J) return Y.name;
          let W = Y.input,
            X = J.inputSchema.safeParse(W),
            V = J.userFacingName(X.success ? X.data : void 0);
          if (J.getToolUseSummary) {
            let F = J.getToolUseSummary(X.success ? X.data : void 0);
            if (F) return `${V}: ${F}`
          }
          return V
        }
      }
    }
  }
  return null
}
// @from(Start 13764599, End 13764601)
BQ
// @from(Start 13764603, End 13764610)
oX0 = 3
// @from(Start 13764614, End 13764621)
w_3 = 9
// @from(Start 13764625, End 13764632)
q_3 = 7
// @from(Start 13764636, End 13764657)
N_3 = "Initializing…"
// @from(Start 13764663, End 13764843)
AV0 = L(() => {
  F9();
  hA();
  iX();
  yJ();
  wh();
  q8();
  UjA();
  cQ();
  cQ();
  q70();
  jy();
  AIA();
  oJ0();
  UJ9();
  DTA();
  bjA();
  R9();
  BQ = BA(VA(), 1)
})
// @from(Start 13764849, End 13764852)
O_3
// @from(Start 13764854, End 13764857)
VtZ
// @from(Start 13764863, End 13765243)
GV0 = L(() => {
  Q2();
  hA();
  JI1();
  RZ();
  iX();
  AV0();
  O_3 = BA(VA(), 1), VtZ = j.strictObject({
    agentId: j.string().describe("The agent ID to retrieve results for"),
    block: j.boolean().default(!0).describe("Whether to block until results are ready"),
    wait_up_to: j.number().min(0).max(300).default(150).describe("Maximum time to wait in seconds")
  })
})
// @from(Start 13765246, End 13765439)
function __3(A) {
  let Q = 0,
    B = nJ(A);
  for (let G of B)
    if (G.type === "assistant") {
      for (let Z of G.message.content)
        if (Z.type === "tool_use") Q++
    } return Q
}
// @from(Start 13765441, End 13766171)
function k_3(A, Q, B) {
  let {
    prompt: G,
    resolvedAgentModel: Z,
    isBuiltInAgent: I,
    startTime: Y
  } = B, J = AVA(A);
  if (J === void 0) throw Error("No assistant messages found");
  let W = J.message.content.filter((F) => F.type === "text"),
    X = E91(J.message.usage),
    V = __3(A);
  return GA("tengu_agent_tool_completed", {
    model: Z,
    prompt_char_count: G.length,
    response_char_count: W.length,
    assistant_message_count: A.length,
    total_tool_uses: V,
    duration_ms: Date.now() - Y,
    total_tokens: X,
    is_built_in_agent: I
  }), {
    agentId: Q,
    content: W,
    totalDurationMs: Date.now() - Y,
    totalTokens: X,
    totalToolUseCount: V,
    usage: J.message.usage
  }
}
// @from(Start 13766176, End 13766179)
R_3
// @from(Start 13766181, End 13766184)
OJ9
// @from(Start 13766186, End 13766189)
mtZ
// @from(Start 13766191, End 13766194)
QV0
// @from(Start 13766196, End 13766199)
T_3
// @from(Start 13766201, End 13766204)
P_3
// @from(Start 13766206, End 13766209)
j_3
// @from(Start 13766211, End 13766214)
S_3
// @from(Start 13766216, End 13766218)
jn
// @from(Start 13766224, End 13774792)
DTA = L(() => {
  E9A();
  Q2();
  cQ();
  tb2();
  jy();
  t2();
  RZ();
  q0();
  WY1();
  GO();
  cQ();
  AV0();
  JI1();
  fP();
  S0A();
  GV0();
  cW0();
  Sy();
  S7();
  L00();
  V0();
  Pn();
  R_3 = BA(VA(), 1), OJ9 = j.object({
    description: j.string().describe("A short (3-5 word) description of the task"),
    prompt: j.string().describe("The task for the agent to perform"),
    subagent_type: j.string().describe("The type of specialized agent to use for this task"),
    model: j.enum(["sonnet", "opus", "haiku"]).optional().describe("Optional model to use for this agent. If not specified, inherits from parent. Prefer haiku for quick, straightforward tasks to minimize cost and latency."),
    resume: j.string().optional().describe("Optional agent ID to resume from. If provided, the agent will continue from the previous execution transcript.")
  }), mtZ = OJ9.extend({
    run_in_background: j.boolean().optional().describe("Set to true to run this agent in the background. Use AgentOutputTool to read the output later.")
  }), QV0 = OJ9, T_3 = j.object({
    agentId: j.string(),
    content: j.array(j.object({
      type: j.literal("text"),
      text: j.string()
    })),
    totalToolUseCount: j.number(),
    totalDurationMs: j.number(),
    totalTokens: j.number(),
    usage: j.object({
      input_tokens: j.number(),
      output_tokens: j.number(),
      cache_creation_input_tokens: j.number().nullable(),
      cache_read_input_tokens: j.number().nullable(),
      server_tool_use: j.object({
        web_search_requests: j.number(),
        web_fetch_requests: j.number()
      }).nullable(),
      service_tier: j.enum(["standard", "priority", "batch"]).nullable(),
      cache_creation: j.object({
        ephemeral_1h_input_tokens: j.number(),
        ephemeral_5m_input_tokens: j.number()
      }).nullable()
    })
  }), P_3 = T_3.extend({
    status: j.literal("completed"),
    prompt: j.string()
  }), j_3 = j.object({
    status: j.literal("async_launched"),
    agentId: j.string().describe("The ID of the async agent"),
    description: j.string().describe("The description of the task"),
    prompt: j.string().describe("The prompt for the agent")
  }), S_3 = j.union([P_3, j_3, eb2]);
  jn = {
    async prompt({
      agents: A
    }) {
      return await ob2(A)
    },
    name: A6,
    async description() {
      return "Launch a new task"
    },
    inputSchema: QV0,
    outputSchema: S_3,
    async call({
      prompt: A,
      subagent_type: Q,
      description: B,
      model: G,
      resume: Z,
      run_in_background: I
    }, Y, J, W, X) {
      let V = Date.now(),
        F = Y.options.agentDefinitions.activeAgents,
        K = F.find((T) => T.agentType === Q);
      if (!K) throw Error(`Agent type '${Q}' not found. Available agents: ${F.map((T)=>T.agentType).join(", ")}`);
      if (K.color) jWA(Q, K.color);
      let D = await Y.getAppState(),
        H = D.toolPermissionContext.mode,
        C = inA(K.model, Y.options.mainLoopModel, G, H);
      GA("tengu_agent_tool_selected", {
        agent_type: K.agentType,
        model: C,
        source: K.source,
        color: K.color,
        is_built_in_agent: $O(K)
      });
      let E;
      if (Z) {
        let T = await KY1(Z);
        if (!T) throw Error(`No transcript found for agent ID: ${Z}`);
        E = T
      }
      let U = K?.forkContext ? Y.messages : void 0,
        q;
      try {
        let T = Array.from(D.toolPermissionContext.additionalWorkingDirectories.keys()),
          y = K.getSystemPrompt({
            toolUseContext: Y
          });
        q = await GSA([y], C, T)
      } catch (T) {
        g(`Failed to get system prompt for agent ${K.agentType}: ${T instanceof Error?T.message:String(T)}`)
      }
      let w = K?.forkContext ? Af2(A, W) : [R0({
          content: A
        })],
        N = {
          prompt: A,
          resolvedAgentModel: C,
          isBuiltInAgent: $O(K),
          startTime: V
        },
        R = {
          agentDefinition: K,
          promptMessages: E ? [...E, ...w] : w,
          toolUseContext: Y,
          canUseTool: J,
          forkContextMessages: U,
          isAsync: I === !0,
          querySource: S69(K.agentType, $O(K)),
          model: G,
          override: q ? {
            systemPrompt: q
          } : void 0
        };
      {
        let T = Z || SWA(),
          y = [],
          v = Date.now();
        if (w[0] && w[0].type === "user") {
          let FA = nJ(w),
            zA = FA.find((NA) => NA.type === "user");
          if (zA && zA.type === "user" && X) X({
            toolUseID: `agent_${W.message.id}`,
            data: {
              message: zA,
              normalizedMessages: FA,
              type: "agent_progress",
              prompt: A,
              resume: Z,
              agentId: T
            }
          })
        }
        let x, p = new Promise((FA) => {
            x = FA
          }),
          u = () => {
            x()
          },
          e = !1,
          k = setInterval(() => {
            let FA = Date.now() - v
          }, 100),
          m = XY1({
            ...R,
            override: {
              ...R.override,
              agentId: T
            }
          })[Symbol.asyncIterator]();
        try {
          while (!0) {
            let FA = m.next(),
              zA = await Promise.race([FA.then((wA) => ({
                type: "message",
                result: wA
              })), p.then(() => ({
                type: "background"
              }))]);
            zA.type;
            let {
              result: NA
            } = zA;
            if (NA.done) break;
            let OA = NA.value;
            if (y.push(OA), OA.type !== "assistant" && OA.type !== "user") continue;
            fQA(OA, () => {}, (wA) => Y.setResponseLength((qA) => qA + wA.length), () => {}, () => {});
            let mA = nJ(y);
            for (let wA of nJ([OA]))
              for (let qA of wA.message.content) {
                if (qA.type !== "tool_use" && qA.type !== "tool_result") continue;
                if (X) X({
                  toolUseID: `agent_${W.message.id}`,
                  data: {
                    message: wA,
                    normalizedMessages: mA,
                    type: "agent_progress",
                    prompt: A,
                    resume: Z,
                    agentId: T
                  }
                })
              }
          }
        } finally {
          if (k) clearInterval(k);
          if (Y.setToolJSX) Y.setToolJSX(null)
        }
        let o = dC(y.filter((FA) => FA.type !== "system" && FA.type !== "progress"));
        if (o && Q31(o)) throw new WW;
        let IA = k_3(y, T, N);
        return {
          data: {
            status: "completed",
            prompt: A,
            ...IA
          }
        }
      }
    },
    isReadOnly() {
      return !0
    },
    isConcurrencySafe() {
      return !0
    },
    isEnabled() {
      return !0
    },
    userFacingName: tX0,
    userFacingNameBackgroundColor: eX0,
    async checkPermissions(A) {
      return {
        behavior: "allow",
        updatedInput: A
      }
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      if (A.status === "async_launched") return {
        tool_use_id: Q,
        type: "tool_result",
        content: [{
          type: "text",
          text: `Async agent launched successfully.
agentId: ${A.agentId} (This is an internal ID for your use, do not mention it to the user. Use this ID to retrieve results with ${Wa} when the agent finishes). 
The agent is currently working in the background. If you have other tasks you you should continue working on them now. Wait to call ${Wa} until either:
- If you want to check on the agent's progress - call ${Wa} with block=false to get an immediate update on the agent's status
- If you run out of things to do and the agent is still running - call ${Wa} with block=true to idle and wait for the agent's result (do not use block=true unless you completely run out of things to do as it will waste time).`
        }]
      };
      if (A.status === "completed") return {
        tool_use_id: Q,
        type: "tool_result",
        content: A.content
      };
      throw Error(`Unexpected agent tool result status: ${A.status}`)
    },
    renderToolResultMessage: wJ9,
    renderToolUseMessage: qJ9,
    renderToolUseProgressMessage: FY1,
    renderToolUseRejectedMessage: NJ9,
    renderToolUseErrorMessage: LJ9,
    renderGroupedToolUse: MJ9
  }
})
// @from(Start 13774798, End 13774815)
DY1 = "KillShell"
// @from(Start 13774819, End 13775090)
RJ9 = `
- Kills a running background bash shell by its ID
- Takes a shell_id parameter identifying the shell to kill
- Returns a success or failure status 
- Use this tool when you need to terminate a long-running shell
- Shell IDs can be found using the /tasks command
`
// @from(Start 13775093, End 13775179)
function TJ9({
  shell_id: A
}) {
  if (!A) return null;
  return `Kill shell: ${A}`
}
// @from(Start 13775181, End 13775213)
function PJ9() {
  return null
}
// @from(Start 13775215, End 13775278)
function jJ9() {
  return XVA.default.createElement(k5, null)
}
// @from(Start 13775280, End 13775393)
function SJ9(A, {
  verbose: Q
}) {
  return XVA.default.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 13775395, End 13775572)
function _J9(A) {
  return XVA.default.createElement(S, null, XVA.default.createElement($, null, "  ⎿  "), XVA.default.createElement($, null, "Shell ", A.shell_id, " killed"))
}
// @from(Start 13775577, End 13775580)
XVA
// @from(Start 13775586, End 13775648)
kJ9 = L(() => {
  hA();
  iX();
  yJ();
  XVA = BA(VA(), 1)
})
// @from(Start 13775654, End 13775657)
y_3
// @from(Start 13775659, End 13775662)
x_3
// @from(Start 13775664, End 13775667)
HY1
// @from(Start 13775673, End 13777940)
ZV0 = L(() => {
  Q2();
  _AA();
  kJ9();
  y_3 = j.strictObject({
    shell_id: j.string().describe("The ID of the background shell to kill")
  }), x_3 = j.object({
    message: j.string().describe("Status message about the operation"),
    shell_id: j.string().describe("The ID of the shell that was killed")
  }), HY1 = {
    name: DY1,
    userFacingName: () => "Kill Shell",
    inputSchema: y_3,
    outputSchema: x_3,
    isEnabled() {
      return !0
    },
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !1
    },
    async checkPermissions(A) {
      return {
        behavior: "allow",
        updatedInput: A
      }
    },
    async validateInput({
      shell_id: A
    }, {
      getAppState: Q
    }) {
      let G = (await Q()).backgroundTasks[A];
      if (!G) return {
        result: !1,
        message: `No shell found with ID: ${A}`,
        errorCode: 1
      };
      if (G.type !== "shell") return {
        result: !1,
        message: `Shell ${A} is not a shell`,
        errorCode: 2
      };
      return {
        result: !0
      }
    },
    async description() {
      return "Kill a background bash shell by ID"
    },
    async prompt() {
      return RJ9
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      return {
        tool_use_id: Q,
        type: "tool_result",
        content: JSON.stringify(A)
      }
    },
    renderToolUseMessage: TJ9,
    renderToolUseProgressMessage: PJ9,
    renderToolUseRejectedMessage: jJ9,
    renderToolUseErrorMessage: SJ9,
    renderToolResultMessage: _J9,
    async call({
      shell_id: A
    }, {
      getAppState: Q,
      setAppState: B
    }) {
      let Z = (await Q()).backgroundTasks[A];
      if (!Z) throw Error(`No shell found with ID: ${A}`);
      if (Z.type !== "shell") throw Error(`Shell ${A} is not a shell`);
      if (Z.status !== "running") throw Error(`Shell ${A} is not running, so cannot be killed (status: ${Z.status})`);
      let I = W01(Z);
      return B((Y) => ({
        ...Y,
        backgroundTasks: {
          ...Y.backgroundTasks,
          [A]: I
        }
      })), {
        data: {
          message: `Successfully killed shell: ${A} (${Z.command})`,
          shell_id: A
        }
      }
    }
  }
})
// @from(Start 13777943, End 13778416)
function yJ9() {
  return `
- Retrieves output from a running or completed background bash shell
- Takes a shell_id parameter identifying the shell
- Always returns only new output since the last check
- Returns stdout and stderr output along with shell status
- Supports optional regex filtering to show only lines matching a pattern
- Use this tool when you need to monitor or check the output of a long-running shell
- Shell IDs can be found using the /tasks command
`
}
// @from(Start 13778418, End 13778736)
function IV0(A) {
  let Q = Ge();
  if (A.length <= Q) return {
    totalLines: A.split(`
`).length,
    truncatedContent: A
  };
  let B = A.slice(0, Q),
    G = A.slice(Q).split(`
`).length,
    Z = `${B}

... [${G} lines truncated] ...`;
  return {
    totalLines: A.split(`
`).length,
    truncatedContent: Z
  }
}
// @from(Start 13778741, End 13778775)
xJ9 = L(() => {
  IGA();
  Np()
})
// @from(Start 13778778, End 13779042)
function vJ9(A, Q, B) {
  let G = {
    stdout: A.stdout,
    stderr: A.stderr,
    isImage: !1,
    dangerouslyDisableSandbox: !0,
    returnCodeInterpretation: A.error || void 0
  };
  return hQA.createElement(L1A, {
    content: G,
    verbose: B.verbose
  })
}
// @from(Start 13779044, End 13779167)
function bJ9(A) {
  if (A?.filter) return `Reading shell output (filtered: ${A.filter})`;
  return "Reading shell output"
}
// @from(Start 13779169, End 13779201)
function fJ9() {
  return null
}
// @from(Start 13779203, End 13779258)
function hJ9() {
  return hQA.createElement(k5, null)
}
// @from(Start 13779260, End 13779365)
function gJ9(A, {
  verbose: Q
}) {
  return hQA.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 13779370, End 13779373)
hQA
// @from(Start 13779379, End 13779442)
uJ9 = L(() => {
  iX();
  yJ();
  l21();
  hQA = BA(VA(), 1)
})
// @from(Start 13779445, End 13779587)
function mJ9(A, Q) {
  if (!Q || !A.trim()) return A;
  let B = new RegExp(Q, "i");
  return A.split(`
`).filter((I) => B.test(I)).join(`
`)
}
// @from(Start 13779592, End 13779595)
v_3
// @from(Start 13779597, End 13779600)
b_3
// @from(Start 13779602, End 13779605)
CY1
// @from(Start 13779611, End 13783935)
YV0 = L(() => {
  Q2();
  _AA();
  xJ9();
  uJ9();
  v_3 = j.object({
    shellId: j.string().describe("The ID of the background shell"),
    command: j.string().describe("The command that was run in the shell"),
    status: j.enum(["running", "completed", "failed", "killed"]).describe("The current status of the shell command"),
    exitCode: j.number().nullable().describe("The exit code of the command, if available"),
    stdout: j.string().describe("The standard output of the command"),
    stderr: j.string().describe("The standard error output of the command"),
    stdoutLines: j.number().describe("Total number of lines in original stdout, even if truncated or filtered"),
    stderrLines: j.number().describe("Total number of lines in original stderr, even if truncated or filtered"),
    error: j.string().optional().describe("Error message if the shell command failed"),
    filterPattern: j.string().optional().describe("The regex pattern used for filtering (only present when filter is applied)"),
    timestamp: j.string().describe("The current timestamp when the output was retrieved")
  }), b_3 = j.strictObject({
    bash_id: j.string().describe("The ID of the background shell to retrieve output from"),
    filter: j.string().optional().describe("Optional regular expression to filter the output lines. Only lines matching this regex will be included in the result. Any lines that do not match will no longer be available to read.")
  }), CY1 = {
    name: "BashOutput",
    async description() {
      return "Retrieves output from a background bash shell"
    },
    async prompt() {
      return yJ9()
    },
    userFacingName() {
      return "BashOutput"
    },
    isEnabled() {
      return !0
    },
    inputSchema: b_3,
    outputSchema: v_3,
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    async checkPermissions(A) {
      return {
        behavior: "allow",
        updatedInput: A
      }
    },
    async validateInput({
      bash_id: A,
      filter: Q
    }, {
      getAppState: B
    }) {
      if (Q) try {
        new RegExp(Q, "i")
      } catch (I) {
        return {
          result: !1,
          message: `Invalid regex pattern "${Q}": ${I instanceof Error?I.message:String(I)}`,
          errorCode: 1
        }
      }
      let Z = (await B()).backgroundTasks[A];
      if (!Z) return {
        result: !1,
        message: `No shell found with ID: ${A}`,
        errorCode: 2
      };
      if (Z.type !== "shell") return {
        result: !1,
        message: `Shell ${A} is not a shell`,
        errorCode: 3
      };
      return {
        result: !0
      }
    },
    async call({
      bash_id: A,
      filter: Q
    }, {
      getAppState: B
    }) {
      let I = (await B()).backgroundTasks[A];
      if (!I) throw Error(`No shell found with ID: ${A}`);
      if (I.type !== "shell") throw Error(`Shell ${A} is not a shell`);
      let Y = J01(I),
        J = mJ9(Y.stdout, Q),
        W = mJ9(Y.stderr, Q),
        {
          truncatedContent: X
        } = IV0(Ff(J)),
        {
          truncatedContent: V
        } = IV0(Ff(W)),
        F = Y.stdout.split(`
`).length,
        K = Y.stderr.split(`
`).length;
      return {
        data: {
          shellId: I.id,
          command: I.command,
          status: I.status,
          exitCode: I.result?.code ?? null,
          stdout: X,
          stderr: V,
          stdoutLines: F,
          stderrLines: K,
          timestamp: new Date().toISOString(),
          ...Q && {
            filterPattern: Q
          }
        }
      }
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      let B = [];
      if (B.push(`<status>${A.status}</status>`), A.exitCode !== null && A.exitCode !== void 0) B.push(`<exit_code>${A.exitCode}</exit_code>`);
      if (A.stdout.trim()) B.push(`<stdout>
${A.stdout.trimEnd()}
</stdout>`);
      if (A.stderr.trim()) B.push(`<stderr>
${A.stderr.trim()}
</stderr>`);
      return B.push(`<timestamp>${A.timestamp}</timestamp>`), {
        tool_use_id: Q,
        type: "tool_result",
        content: B.join(`

`)
      }
    },
    renderToolUseProgressMessage: fJ9,
    renderToolResultMessage: vJ9,
    renderToolUseMessage: bJ9,
    renderToolUseRejectedMessage: hJ9,
    renderToolUseErrorMessage: gJ9
  }
})
// @from(Start 13783938, End 13784118)
function f_3(A) {
  let Q = 0,
    B = 0;
  for (let G of A)
    if (typeof G !== "string") Q++, B += G.content.length;
  return {
    searchCount: Q,
    totalResultCount: B
  }
}
// @from(Start 13784120, End 13784447)
function dJ9({
  query: A,
  allowed_domains: Q,
  blocked_domains: B
}, {
  verbose: G
}) {
  if (!A) return null;
  let Z = "";
  if (A) Z += `"${A}"`;
  if (G) {
    if (Q && Q.length > 0) Z += `, only allowing domains: ${Q.join(", ")}`;
    if (B && B.length > 0) Z += `, blocking domains: ${B.join(", ")}`
  }
  return Z
}
// @from(Start 13784449, End 13784511)
function cJ9() {
  return Kx.default.createElement(k5, null)
}
// @from(Start 13784513, End 13784625)
function pJ9(A, {
  verbose: Q
}) {
  return Kx.default.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 13784627, End 13785172)
function lJ9(A) {
  if (A.length === 0) return null;
  let Q = A[A.length - 1];
  if (!Q?.data) return null;
  let B = Q.data;
  switch (B.type) {
    case "query_update":
      return Kx.default.createElement(S0, null, Kx.default.createElement($, {
        dimColor: !0
      }, "Searching: ", B.query));
    case "search_results_received":
      return Kx.default.createElement(S0, null, Kx.default.createElement($, {
        dimColor: !0
      }, "Found ", B.resultCount, ' results for "', B.query, '"'));
    default:
      return null
  }
}
// @from(Start 13785174, End 13785591)
function iJ9(A) {
  let {
    searchCount: Q
  } = f_3(A.results), B = A.durationSeconds >= 1 ? `${Math.round(A.durationSeconds)}s` : `${Math.round(A.durationSeconds*1000)}ms`;
  return Kx.default.createElement(S, {
    justifyContent: "space-between",
    width: "100%"
  }, Kx.default.createElement(S0, {
    height: 1
  }, Kx.default.createElement($, null, "Did ", Q, " search", Q !== 1 ? "es" : "", " in ", B)))
}
// @from(Start 13785593, End 13785667)
function nJ9(A) {
  if (!A?.query) return null;
  return J7(A.query, $k)
}
// @from(Start 13785672, End 13785674)
Kx
// @from(Start 13785680, End 13785749)
aJ9 = L(() => {
  hA();
  q8();
  iX();
  yJ();
  Kx = BA(VA(), 1)
})
// @from(Start 13785752, End 13786565)
function c_3(A, Q, B) {
  let G = [],
    Z = "",
    I = !0;
  for (let Y of A) {
    if (Y.type === "server_tool_use") {
      if (I) {
        if (I = !1, Z.trim().length > 0) G.push(Z.trim());
        Z = ""
      }
      continue
    }
    if (Y.type === "web_search_tool_result") {
      if (!Array.isArray(Y.content)) {
        let W = `Web search error: ${Y.content.error_code}`;
        AA(Error(W)), G.push(W);
        continue
      }
      let J = Y.content.map((W) => ({
        title: W.title,
        url: W.url
      }));
      G.push({
        tool_use_id: Y.tool_use_id,
        content: J
      })
    }
    if (Y.type === "text")
      if (I) Z += Y.text;
      else I = !0, Z = Y.text
  }
  if (Z.length) G.push(Z.trim());
  return {
    query: Q,
    results: G,
    durationSeconds: B
  }
}
// @from(Start 13786570, End 13786573)
h_3
// @from(Start 13786575, End 13786578)
g_3
// @from(Start 13786580, End 13786583)
u_3
// @from(Start 13786585, End 13786588)
m_3
// @from(Start 13786590, End 13786790)
d_3 = (A) => {
    return {
      type: "web_search_20250305",
      name: "web_search",
      allowed_domains: A.allowed_domains,
      blocked_domains: A.blocked_domains,
      max_uses: 8
    }
  }
// @from(Start 13786794, End 13786797)
ZSA
// @from(Start 13786803, End 13792828)
JV0 = L(() => {
  Q2();
  c9A();
  fZ();
  cQ();
  t2();
  lK();
  g1();
  aJ9();
  h_3 = j.strictObject({
    query: j.string().min(2).describe("The search query to use"),
    allowed_domains: j.array(j.string()).optional().describe("Only include search results from these domains"),
    blocked_domains: j.array(j.string()).optional().describe("Never include search results from these domains")
  }), g_3 = j.object({
    title: j.string().describe("The title of the search result"),
    url: j.string().describe("The URL of the search result")
  }), u_3 = j.object({
    tool_use_id: j.string().describe("ID of the tool use"),
    content: j.array(g_3).describe("Array of search hits")
  }), m_3 = j.object({
    query: j.string().describe("The search query that was executed"),
    results: j.array(j.union([u_3, j.string()])).describe("Search results and/or text commentary from the model"),
    durationSeconds: j.number().describe("Time taken to complete the search operation")
  });
  ZSA = {
    name: WS,
    async description(A) {
      return `Claude wants to search the web for: ${A.query}`
    },
    userFacingName() {
      return "Web Search"
    },
    getToolUseSummary: nJ9,
    isEnabled() {
      let A = V6(),
        Q = k3();
      if (A === "firstParty") return !0;
      if (A === "vertex") return Q.includes("claude-opus-4") || Q.includes("claude-sonnet-4") || Q.includes("claude-haiku-4");
      if (A === "foundry") return !0;
      return !1
    },
    inputSchema: h_3,
    outputSchema: m_3,
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    async checkPermissions(A) {
      return {
        behavior: "passthrough",
        message: "WebSearchTool requires permission."
      }
    },
    async prompt() {
      return Nc0()
    },
    renderToolUseMessage: dJ9,
    renderToolUseRejectedMessage: cJ9,
    renderToolUseErrorMessage: pJ9,
    renderToolUseProgressMessage: lJ9,
    renderToolResultMessage: iJ9,
    async validateInput(A) {
      let {
        query: Q,
        allowed_domains: B,
        blocked_domains: G
      } = A;
      if (!Q.length) return {
        result: !1,
        message: "Error: Missing query",
        errorCode: 1
      };
      if (B && G) return {
        result: !1,
        message: "Error: Cannot specify both allowed_domains and blocked_domains in the same request",
        errorCode: 2
      };
      return {
        result: !0
      }
    },
    async call(A, Q, B, G, Z) {
      let I = performance.now(),
        {
          query: Y
        } = A,
        J = R0({
          content: "Perform a web search for the query: " + Y
        }),
        W = d_3(A),
        X = RYA({
          messages: [J],
          systemPrompt: ["You are an assistant for performing a web search tool use"],
          maxThinkingTokens: Q.options.maxThinkingTokens,
          tools: [],
          signal: Q.abortController.signal,
          options: {
            getToolPermissionContext: async () => {
              return (await Q.getAppState()).toolPermissionContext
            },
            model: k3(),
            toolChoice: void 0,
            isNonInteractiveSession: Q.options.isNonInteractiveSession,
            hasAppendSystemPrompt: Q.options.hasAppendSystemPrompt,
            extraToolSchemas: [W],
            querySource: "web_search_tool",
            agents: Q.options.agentDefinitions.activeAgents,
            mcpTools: [],
            agentIdOrSessionId: Q.agentId
          }
        }),
        V = [],
        F = null,
        K = "",
        D = 0,
        H = new Map;
      for await (let N of X) {
        if (V.push(N), N.type === "stream_event" && N.event?.type === "content_block_start") {
          let R = N.event.content_block;
          if (R && R.type === "server_tool_use") {
            F = R.id, K = "";
            continue
          }
        }
        if (F && N.type === "stream_event" && N.event?.type === "content_block_delta") {
          let R = N.event.delta;
          if (R?.type === "input_json_delta" && R.partial_json) {
            K += R.partial_json;
            try {
              let T = K.match(/"query"\s*:\s*"((?:[^"\\]|\\.)*)"/);
              if (T && T[1]) {
                let y = JSON.parse('"' + T[1] + '"');
                if (!H.has(F) || H.get(F) !== y) {
                  if (H.set(F, y), D++, Z) Z({
                    toolUseID: `search-progress-${D}`,
                    data: {
                      type: "query_update",
                      query: y
                    }
                  })
                }
              }
            } catch {}
          }
        }
        if (N.type === "stream_event" && N.event?.type === "content_block_start") {
          let R = N.event.content_block;
          if (R && R.type === "web_search_tool_result") {
            let T = R.tool_use_id,
              y = H.get(T) || Y,
              v = R.content;
            if (D++, Z) Z({
              toolUseID: T || `search-progress-${D}`,
              data: {
                type: "search_results_received",
                resultCount: Array.isArray(v) ? v.length : 0,
                query: y
              }
            })
          }
        }
      }
      let E = V.filter((N) => N.type === "assistant").flatMap((N) => N.message.content),
        q = (performance.now() - I) / 1000;
      return {
        data: c_3(E, Y, q)
      }
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      let {
        query: B,
        results: G
      } = A, Z = `Web search results for query: "${B}"

`;
      return G.forEach((I) => {
        if (typeof I === "string") Z += I + `

`;
        else if (I.content.length > 0) Z += `Links: ${JSON.stringify(I.content)}

`;
        else Z += `No links found.

`
      }), Z += `
REMINDER: You MUST include the sources above in your response to the user using markdown hyperlinks.`, {
        tool_use_id: Q,
        type: "tool_result",
        content: Z.trim()
      }
    }
  }
})
// @from(Start 13792834, End 13792837)
SeZ
// @from(Start 13792843, End 13792896)
sJ9 = L(() => {
  Q2();
  SeZ = j.strictObject({})
})
// @from(Start 13792902, End 13792905)
geZ
// @from(Start 13792911, End 13792979)
rJ9 = L(() => {
  _8();
  V0();
  jy();
  geZ = Promise.resolve()
})
// @from(Start 13792985, End 13792988)
i_3
// @from(Start 13792994, End 13793073)
oJ9 = L(() => {
  hA();
  saA();
  iX();
  yJ();
  jy();
  i_3 = BA(VA(), 1)
})
// @from(Start 13793079, End 13793082)
qAI
// @from(Start 13793088, End 13795305)
tJ9 = L(() => {
  Q2();
  rJ9();
  _8();
  dK();
  U2();
  PV();
  g91();
  oJ9();
  qAI = j.strictObject({
    operation: j.enum(["spawn", "spawnTeam", "read", "write"]).describe("Operation: spawn a teammate, spawnTeam to create a team, read messages from mailbox, or write a message to a teammate"),
    name: j.string().optional().describe("Name for the teammate (required for spawn, used in tmux window title)"),
    prompt: j.string().optional().describe("Initial prompt to send to the spawned Claude Code instance (required for spawn)"),
    cwd: j.string().optional().describe("Working directory for the teammate (defaults to current)"),
    use_worktree: j.boolean().optional().describe("If true and in a git repo, creates a git worktree for the teammate. Use worktrees when the teammate needs to make independent changes (e.g., parallel feature development, testing destructive changes). Do NOT use worktrees when the teammate needs to see/modify the same files as you (e.g., running tests on your changes, code review)."),
    use_splitpane: j.boolean().optional().describe("If true (default), spawns the teammate in a split-pane view with the leader. All teammates appear in a single window with the leader on the left and teammates equally divided on the right. Set to false for separate windows."),
    key: j.string().optional().describe("Key for the data being stored (write)"),
    value: j.string().optional().describe("Value to store - JSON string for complex data (write)"),
    target_agent_id: j.string().optional().describe("Agent ID of the recipient (required for write operation)"),
    agent_type: j.string().optional().describe('Type/role of the spawned agent (e.g., "code-reviewer", "test-runner"). Used for team file and inter-agent coordination.'),
    agent_id: j.string().optional().describe("Your registered agent ID (for read/write operations, or unique identifier for spawn). Use this to identify yourself as a registered agent."),
    team_name: j.string().optional().describe("For spawn: Name of existing team to join. For spawnTeam: Name for the new team to create."),
    description: j.string().optional().describe("Team description/purpose (only used with spawnTeam).")
  })
})
// @from(Start 13795311, End 13795314)
n_3
// @from(Start 13795316, End 13795319)
a_3
// @from(Start 13795321, End 13795324)
s_3
// @from(Start 13795326, End 13795329)
r_3
// @from(Start 13795331, End 13795334)
o_3
// @from(Start 13795336, End 13795339)
eJ9
// @from(Start 13795345, End 13797182)
AW9 = L(() => {
  Q2();
  n_3 = j.strictObject({
    operation: j.literal("goToDefinition"),
    filePath: j.string().describe("The absolute or relative path to the file"),
    line: j.number().int().nonnegative().describe("The line number (0-indexed) in the file"),
    character: j.number().int().nonnegative().describe("The character offset (0-indexed) on the line")
  }), a_3 = j.strictObject({
    operation: j.literal("findReferences"),
    filePath: j.string().describe("The absolute or relative path to the file"),
    line: j.number().int().nonnegative().describe("The line number (0-indexed) in the file"),
    character: j.number().int().nonnegative().describe("The character offset (0-indexed) on the line")
  }), s_3 = j.strictObject({
    operation: j.literal("hover"),
    filePath: j.string().describe("The absolute or relative path to the file"),
    line: j.number().int().nonnegative().describe("The line number (0-indexed) in the file"),
    character: j.number().int().nonnegative().describe("The character offset (0-indexed) on the line")
  }), r_3 = j.strictObject({
    operation: j.literal("documentSymbol"),
    filePath: j.string().describe("The absolute or relative path to the file"),
    line: j.number().int().nonnegative().describe("The line number (0-indexed) in the file"),
    character: j.number().int().nonnegative().describe("The character offset (0-indexed) on the line")
  }), o_3 = j.strictObject({
    operation: j.literal("workspaceSymbol"),
    filePath: j.string().describe("The absolute or relative path to the file"),
    line: j.number().int().nonnegative().describe("The line number (0-indexed) in the file"),
    character: j.number().int().nonnegative().describe("The character offset (0-indexed) on the line")
  }), eJ9 = j.discriminatedUnion("operation", [n_3, a_3, s_3, r_3, o_3])
})
// @from(Start 13797227, End 13797769)
function GW9(A, Q) {
  if (!A) return g("formatUri called with undefined URI - indicates malformed LSP server response", {
    level: "warn"
  }), "<unknown location>";
  let B = A.replace(/^file:\/\//, "");
  try {
    B = decodeURIComponent(B)
  } catch (G) {
    let Z = G instanceof Error ? G.message : String(G);
    g(`Failed to decode LSP URI '${A}': ${Z}. Using un-decoded path: ${B}`, {
      level: "warn"
    })
  }
  if (Q) {
    let G = t_3(Q, B);
    if (G.length < B.length && !G.startsWith("../../")) return G
  }
  return B
}
// @from(Start 13797771, End 13797983)
function ZW9(A, Q) {
  let B = new Map;
  for (let G of A) {
    let Z = "uri" in G ? G.uri : G.location.uri,
      I = GW9(Z, Q),
      Y = B.get(I);
    if (Y) Y.push(G);
    else B.set(I, [G])
  }
  return B
}
// @from(Start 13797985, End 13798127)
function EY1(A, Q) {
  let B = GW9(A.uri, Q),
    G = A.range.start.line + 1,
    Z = A.range.start.character + 1;
  return `${B}:${G}:${Z}`
}
// @from(Start 13798129, End 13798236)
function QW9(A) {
  return {
    uri: A.targetUri,
    range: A.targetSelectionRange || A.targetRange
  }
}
// @from(Start 13798238, End 13798283)
function BW9(A) {
  return "targetUri" in A
}
// @from(Start 13798285, End 13798957)
function IW9(A, Q) {
  if (!A) return "No definition found";
  if (Array.isArray(A)) {
    let G = A.map((J) => BW9(J) ? QW9(J) : J),
      Z = G.filter((J) => !J || !J.uri);
    if (Z.length > 0) g(`formatGoToDefinitionResult: Filtering out ${Z.length} invalid location(s) - this should have been caught earlier`, {
      level: "warn"
    });
    let I = G.filter((J) => J && J.uri);
    if (I.length === 0) return "No definition found";
    if (I.length === 1) return `Defined in ${EY1(I[0],Q)}`;
    let Y = I.map((J) => `  ${EY1(J,Q)}`).join(`
`);
    return `Found ${I.length} definitions:
${Y}`
  }
  let B = BW9(A) ? QW9(A) : A;
  return `Defined in ${EY1(B,Q)}`
}
// @from(Start 13798959, End 13799704)
function YW9(A, Q) {
  if (!A || A.length === 0) return "No references found";
  let B = A.filter((Y) => !Y || !Y.uri);
  if (B.length > 0) g(`formatFindReferencesResult: Filtering out ${B.length} invalid location(s) - this should have been caught earlier`, {
    level: "warn"
  });
  let G = A.filter((Y) => Y && Y.uri);
  if (G.length === 0) return "No references found";
  if (G.length === 1) return `Found 1 reference:
  ${EY1(G[0],Q)}`;
  let Z = ZW9(G, Q),
    I = [`Found ${G.length} references across ${Z.size} files:`];
  for (let [Y, J] of Z) {
    I.push(`
${Y}:`);
    for (let W of J) {
      let X = W.range.start.line + 1,
        V = W.range.start.character + 1;
      I.push(`  Line ${X}:${V}`)
    }
  }
  return I.join(`
`)
}
// @from(Start 13799706, End 13799939)
function e_3(A) {
  if (Array.isArray(A)) return A.map((Q) => {
    if (typeof Q === "string") return Q;
    return Q.value
  }).join(`

`);
  if (typeof A === "string") return A;
  if ("kind" in A) return A.value;
  return A.value
}
// @from(Start 13799941, End 13800192)
function JW9(A, Q) {
  if (!A) return "No hover information available";
  let B = e_3(A.contents);
  if (A.range) {
    let G = A.range.start.line + 1,
      Z = A.range.start.character + 1;
    return `Hover info at ${G}:${Z}:

${B}`
  }
  return B
}
// @from(Start 13800194, End 13800776)
function WW9(A) {
  return {
    [1]: "File",
    [2]: "Module",
    [3]: "Namespace",
    [4]: "Package",
    [5]: "Class",
    [6]: "Method",
    [7]: "Property",
    [8]: "Field",
    [9]: "Constructor",
    [10]: "Enum",
    [11]: "Interface",
    [12]: "Function",
    [13]: "Variable",
    [14]: "Constant",
    [15]: "String",
    [16]: "Number",
    [17]: "Boolean",
    [18]: "Array",
    [19]: "Object",
    [20]: "Key",
    [21]: "Null",
    [22]: "EnumMember",
    [23]: "Struct",
    [24]: "Event",
    [25]: "Operator",
    [26]: "TypeParameter"
  } [A] || "Unknown"
}
// @from(Start 13800778, End 13801108)
function XW9(A, Q = 0) {
  let B = [],
    G = "  ".repeat(Q),
    Z = WW9(A.kind),
    I = `${G}${A.name} (${Z})`;
  if (A.detail) I += ` ${A.detail}`;
  let Y = A.range.start.line + 1;
  if (I += ` - Line ${Y}`, B.push(I), A.children && A.children.length > 0)
    for (let J of A.children) B.push(...XW9(J, Q + 1));
  return B
}
// @from(Start 13801110, End 13801291)
function VW9(A, Q) {
  if (!A || A.length === 0) return "No symbols found in document";
  let B = ["Document symbols:"];
  for (let G of A) B.push(...XW9(G));
  return B.join(`
`)
}
// @from(Start 13801293, End 13802124)
function FW9(A, Q) {
  if (!A || A.length === 0) return "No symbols found in workspace";
  let B = A.filter((Y) => !Y || !Y.location || !Y.location.uri);
  if (B.length > 0) g(`formatWorkspaceSymbolResult: Filtering out ${B.length} invalid symbol(s) - this should have been caught earlier`, {
    level: "warn"
  });
  let G = A.filter((Y) => Y && Y.location && Y.location.uri);
  if (G.length === 0) return "No symbols found in workspace";
  let Z = [`Found ${G.length} symbol${G.length===1?"":"s"} in workspace:`],
    I = ZW9(G, Q);
  for (let [Y, J] of I) {
    Z.push(`
${Y}:`);
    for (let W of J) {
      let X = WW9(W.kind),
        V = W.location.range.start.line + 1,
        F = `  ${W.name} (${X}) - Line ${V}`;
      if (W.containerName) F += ` in ${W.containerName}`;
      Z.push(F)
    }
  }
  return Z.join(`
`)
}
// @from(Start 13802129, End 13802154)
KW9 = L(() => {
  V0()
})
// @from(Start 13802160, End 13802171)
DW9 = "LSP"
// @from(Start 13802175, End 13802874)
WV0 = `Interact with Language Server Protocol (LSP) servers to get code intelligence features.

Supported operations:
- goToDefinition: Find where a symbol is defined
- findReferences: Find all references to a symbol
- hover: Get hover information (documentation, type info) for a symbol
- documentSymbol: Get all symbols (functions, classes, variables) in a document
- workspaceSymbol: Search for symbols across the entire workspace

All operations require:
- filePath: The file to operate on
- line: The line number (0-indexed)
- character: The character offset (0-indexed) on the line

Note: LSP servers must be configured for the file type. If no server is available, an error will be returned.`
// @from(Start 13802877, End 13803611)
function HW9(A, Q, B) {
  try {
    let G = RA(),
      Z = b9(A);
    if (!G.existsSync(Z)) return null;
    let Y = G.readFileSync(Z, {
      encoding: "utf-8"
    }).split(`
`);
    if (Q < 0 || Q >= Y.length) return null;
    let J = Y[Q];
    if (!J || B < 0 || B >= J.length) return null;
    let W = /[\w$'!]+|[+\-*/%&|^~<>=]+/g,
      X;
    while ((X = W.exec(J)) !== null) {
      let V = X.index,
        F = V + X[0].length;
      if (B >= V && B < F) {
        let K = X[0];
        return K.length > 30 ? K.slice(0, 27) + "..." : K
      }
    }
    return null
  } catch (G) {
    if (G instanceof Error) g(`Symbol extraction failed for ${A}:${Q}:${B}: ${G.message}`, {
      level: "warn"
    });
    return null
  }
}
// @from(Start 13803616, End 13803657)
CW9 = L(() => {
  AQ();
  yI();
  V0()
})
// @from(Start 13803660, End 13804726)
function Qk3({
  operation: A,
  resultCount: Q,
  fileCount: B,
  content: G,
  verbose: Z
}) {
  let I = Ak3[A] || {
      singular: "result",
      plural: "results"
    },
    Y = Q === 1 ? I.singular : I.plural,
    J = A === "hover" && Q > 0 && I.special ? zY.default.createElement(zY.default.Fragment, null, "Hover info ", I.special) : zY.default.createElement(zY.default.Fragment, null, "Found ", zY.default.createElement($, {
      bold: !0
    }, Q, " "), Y),
    W = B > 1 ? zY.default.createElement(zY.default.Fragment, null, " ", "across ", zY.default.createElement($, {
      bold: !0
    }, B, " "), "files") : null;
  if (Z) return zY.default.createElement(S, {
    flexDirection: "column"
  }, zY.default.createElement(S, {
    flexDirection: "row"
  }, zY.default.createElement($, null, "  ⎿  ", J, W)), zY.default.createElement(S, {
    marginLeft: 5
  }, zY.default.createElement($, null, G)));
  return zY.default.createElement(S0, {
    height: 1
  }, zY.default.createElement($, null, J, W, " ", Q > 0 && zY.default.createElement(Tl, null)))
}
// @from(Start 13804728, End 13804761)
function EW9() {
  return "LSP"
}
// @from(Start 13804763, End 13805509)
function zW9(A, {
  verbose: Q
}) {
  if (!A.operation) return null;
  let B = [];
  if ((A.operation === "goToDefinition" || A.operation === "findReferences" || A.operation === "hover") && A.filePath && A.line !== void 0 && A.character !== void 0) {
    let G = HW9(A.filePath, A.line, A.character),
      Z = Q ? A.filePath : Q5(A.filePath);
    if (G) B.push(`operation: "${A.operation}"`), B.push(`symbol: "${G}"`), B.push(`in: "${Z}"`);
    else B.push(`operation: "${A.operation}"`), B.push(`file: "${Z}"`), B.push(`position: ${A.line}:${A.character}`);
    return B.join(", ")
  }
  if (B.push(`operation: "${A.operation}"`), A.filePath) {
    let G = Q ? A.filePath : Q5(A.filePath);
    B.push(`file: "${G}"`)
  }
  return B.join(", ")
}
// @from(Start 13805511, End 13805573)
function UW9() {
  return zY.default.createElement(k5, null)
}
// @from(Start 13805575, End 13805871)
function $W9(A, {
  verbose: Q
}) {
  if (!Q && typeof A === "string" && B9(A, "tool_use_error")) return zY.default.createElement(S0, null, zY.default.createElement($, {
    color: "error"
  }, "LSP operation failed"));
  return zY.default.createElement(Q6, {
    result: A,
    verbose: Q
  })
}
// @from(Start 13805873, End 13805905)
function wW9() {
  return null
}
// @from(Start 13805907, End 13806265)
function qW9(A, Q, {
  verbose: B
}) {
  if (A.resultCount !== void 0 && A.fileCount !== void 0) return zY.default.createElement(Qk3, {
    operation: A.operation,
    resultCount: A.resultCount,
    fileCount: A.fileCount,
    content: A.result,
    verbose: B
  });
  return zY.default.createElement(S0, null, zY.default.createElement($, null, A.result))
}
// @from(Start 13806270, End 13806272)
zY
// @from(Start 13806274, End 13806277)
Ak3
// @from(Start 13806283, End 13806834)
NW9 = L(() => {
  hA();
  iX();
  yJ();
  q8();
  AIA();
  cQ();
  R9();
  CW9();
  zY = BA(VA(), 1), Ak3 = {
    goToDefinition: {
      singular: "definition",
      plural: "definitions"
    },
    findReferences: {
      singular: "reference",
      plural: "references"
    },
    documentSymbol: {
      singular: "symbol",
      plural: "symbols"
    },
    workspaceSymbol: {
      singular: "symbol",
      plural: "symbols"
    },
    hover: {
      singular: "hover info",
      plural: "hover info",
      special: "available"
    }
  }
})
// @from(Start 13806912, End 13807991)
function Ik3(A, Q) {
  let B = Bk3(Q).href,
    G = {
      line: A.line,
      character: A.character
    };
  switch (A.operation) {
    case "goToDefinition":
      return {
        method: "textDocument/definition", params: {
          textDocument: {
            uri: B
          },
          position: G
        }
      };
    case "findReferences":
      return {
        method: "textDocument/references", params: {
          textDocument: {
            uri: B
          },
          position: G,
          context: {
            includeDeclaration: !0
          }
        }
      };
    case "hover":
      return {
        method: "textDocument/hover", params: {
          textDocument: {
            uri: B
          },
          position: G
        }
      };
    case "documentSymbol":
      return {
        method: "textDocument/documentSymbol", params: {
          textDocument: {
            uri: B
          }
        }
      };
    case "workspaceSymbol":
      return {
        method: "workspace/symbol", params: {
          query: ""
        }
      }
  }
}
// @from(Start 13807993, End 13808129)
function LW9(A) {
  let Q = A.length;
  for (let B of A)
    if (B.children && B.children.length > 0) Q += LW9(B.children);
  return Q
}
// @from(Start 13808131, End 13808193)
function XV0(A) {
  return new Set(A.map((Q) => Q.uri)).size
}
// @from(Start 13808195, End 13808240)
function Yk3(A) {
  return "targetUri" in A
}
// @from(Start 13808242, End 13808373)
function Jk3(A) {
  if (Yk3(A)) return {
    uri: A.targetUri,
    range: A.targetSelectionRange || A.targetRange
  };
  return A
}
// @from(Start 13808375, End 13810185)
function Wk3(A, Q, B) {
  switch (A) {
    case "goToDefinition": {
      let Z = (Array.isArray(Q) ? Q : Q ? [Q] : []).map(Jk3),
        I = Z.filter((J) => !J || !J.uri);
      if (I.length > 0) AA(Error(`LSP server returned ${I.length} location(s) with undefined URI for goToDefinition on ${B}. This indicates malformed data from the LSP server.`));
      let Y = Z.filter((J) => J && J.uri);
      return {
        formatted: IW9(Q, B),
        resultCount: Y.length,
        fileCount: XV0(Y)
      }
    }
    case "findReferences": {
      let G = Q || [],
        Z = G.filter((Y) => !Y || !Y.uri);
      if (Z.length > 0) AA(Error(`LSP server returned ${Z.length} location(s) with undefined URI for findReferences on ${B}. This indicates malformed data from the LSP server.`));
      let I = G.filter((Y) => Y && Y.uri);
      return {
        formatted: YW9(Q, B),
        resultCount: I.length,
        fileCount: XV0(I)
      }
    }
    case "hover":
      return {
        formatted: JW9(Q, B), resultCount: Q ? 1 : 0, fileCount: Q ? 1 : 0
      };
    case "documentSymbol": {
      let G = Q || [],
        Z = G.length > 0 ? LW9(G) : 0;
      return {
        formatted: VW9(Q, B),
        resultCount: Z,
        fileCount: G.length > 0 ? 1 : 0
      }
    }
    case "workspaceSymbol": {
      let G = Q || [],
        Z = G.filter((J) => !J || !J.location || !J.location.uri);
      if (Z.length > 0) AA(Error(`LSP server returned ${Z.length} symbol(s) with undefined location URI for workspaceSymbol on ${B}. This indicates malformed data from the LSP server.`));
      let I = G.filter((J) => J && J.location && J.location.uri),
        Y = I.map((J) => J.location);
      return {
        formatted: FW9(Q, B),
        resultCount: I.length,
        fileCount: XV0(Y)
      }
    }
  }
}
// @from(Start 13810190, End 13810193)
Gk3
// @from(Start 13810195, End 13810198)
Zk3
// @from(Start 13810200, End 13810203)
FV0
// @from(Start 13904554, End 13913491)
async function* qa({
  hookInput: A,
  toolUseID: Q,
  matchQuery: B,
  signal: G,
  timeoutMs: Z = ZN,
  toolUseContext: I,
  messages: Y
}) {
  if (l0().disableAllHooks) return;
  let J = A.hook_event_name,
    W = B ? `${J}:${B}` : J;
  if (rX9()) {
    g(`Skipping ${W} hook execution - workspace trust not accepted`);
    return
  }
  let X = I ? await I.getAppState() : void 0,
    V = _V0(X, J, A);
  if (V.length === 0) return;
  if (G?.aborted) return;
  GA("tengu_run_hook", {
    hookName: W,
    numCommands: V.length
  });
  for (let H of V) yield {
    message: {
      type: "progress",
      data: {
        type: "hook_progress",
        hookEvent: J,
        hookName: W,
        command: hE(H),
        promptText: H.type === "prompt" ? H.prompt : void 0,
        statusMessage: "statusMessage" in H ? H.statusMessage : void 0
      },
      parentToolUseID: Q,
      toolUseID: Q,
      timestamp: new Date().toISOString(),
      uuid: HVA()
    }
  };
  let F = V.map(async function*(H, C) {
      if (H.type === "callback") {
        let w = H.timeout ? H.timeout * 1000 : Z,
          {
            signal: N,
            cleanup: R
          } = ck(AbortSignal.timeout(w), G);
        yield Qy3({
          toolUseID: Q,
          hook: H,
          hookEvent: J,
          hookInput: A,
          signal: N,
          hookIndex: C
        }).finally(R);
        return
      }
      if (H.type === "function") {
        if (!Y) {
          yield {
            message: l9({
              type: "hook_error_during_execution",
              hookName: W,
              toolUseID: Q,
              hookEvent: J,
              content: "Messages not provided for function hook"
            }),
            outcome: "non_blocking_error",
            hook: H
          };
          return
        }
        yield Ay3({
          hook: H,
          messages: Y,
          hookName: W,
          toolUseID: Q,
          hookEvent: J,
          timeoutMs: Z,
          signal: G
        });
        return
      }
      let E = H.timeout ? H.timeout * 1000 : Z,
        {
          signal: U,
          cleanup: q
        } = ck(AbortSignal.timeout(E), G);
      try {
        let w;
        try {
          w = JSON.stringify(A)
        } catch (v) {
          AA(Error(`Failed to stringify hook ${W} input`, {
            cause: v
          })), yield {
            message: l9({
              type: "hook_error_during_execution",
              hookName: W,
              toolUseID: Q,
              hookEvent: J,
              content: `Failed to prepare hook input: ${v instanceof Error?v.message:String(v)}`
            }),
            outcome: "non_blocking_error",
            hook: H
          };
          return
        }
        if (H.type === "prompt") {
          if (!I) throw Error("ToolUseContext is required for prompt hooks. This is a bug.");
          yield await eP2(H, W, J, w, U, I, Y, Q), q?.();
          return
        }
        if (H.type === "agent") {
          if (!I) throw Error("ToolUseContext is required for agent hooks. This is a bug.");
          if (!Y) throw Error("Messages are required for agent hooks. This is a bug.");
          yield await aX9(H, W, J, w, U, I, Q, Y), q?.();
          return
        }
        let N = await SV0(H, J, W, w, U, C);
        if (q?.(), N.aborted) {
          yield {
            message: l9({
              type: "hook_cancelled",
              hookName: W,
              toolUseID: Q,
              hookEvent: J
            }),
            outcome: "cancelled",
            hook: H
          };
          return
        }
        let {
          json: R,
          plainText: T,
          validationError: y
        } = oX9(N.stdout);
        if (y) {
          yield {
            message: l9({
              type: "hook_non_blocking_error",
              hookName: W,
              toolUseID: Q,
              hookEvent: J,
              stderr: `JSON validation failed: ${y}`,
              stdout: N.stdout,
              exitCode: 1
            }),
            outcome: "non_blocking_error",
            hook: H
          };
          return
        }
        if (R) {
          if (zYA(R)) {
            yield {
              outcome: "success",
              hook: H
            };
            return
          }
          let v = tX9({
            json: R,
            command: H.type === "command" ? H.command : "prompt",
            hookName: W,
            toolUseID: Q,
            hookEvent: J,
            expectedHookEvent: J,
            stdout: N.stdout,
            stderr: N.stderr,
            exitCode: N.status
          });
          if (kZ2(R) && !R.suppressOutput && T && N.status === 0) {
            let x = `${tA.bold(W)} completed`;
            yield {
              ...v,
              message: v.message || l9({
                type: "hook_success",
                hookName: W,
                toolUseID: Q,
                hookEvent: J,
                content: x,
                stdout: N.stdout,
                stderr: N.stderr,
                exitCode: N.status
              }),
              outcome: "success",
              hook: H
            };
            return
          }
          yield {
            ...v,
            outcome: "success",
            hook: H
          };
          return
        }
        if (N.status === 0) {
          yield {
            message: l9({
              type: "hook_success",
              hookName: W,
              toolUseID: Q,
              hookEvent: J,
              content: N.stdout.trim(),
              stdout: N.stdout,
              stderr: N.stderr,
              exitCode: N.status
            }),
            outcome: "success",
            hook: H
          };
          return
        }
        if (N.status === 2) {
          yield {
            blockingError: {
              blockingError: `[${H.command}]: ${N.stderr||"No stderr output"}`,
              command: H.command
            },
            outcome: "blocking",
            hook: H
          };
          return
        }
        yield {
          message: l9({
            type: "hook_non_blocking_error",
            hookName: W,
            toolUseID: Q,
            hookEvent: J,
            stderr: `Failed with non-blocking status code: ${N.stderr.trim()||"No stderr output"}`,
            stdout: N.stdout,
            exitCode: N.status
          }),
          outcome: "non_blocking_error",
          hook: H
        };
        return
      } catch (w) {
        q?.();
        let N = w instanceof Error ? w.message : String(w);
        yield {
          message: l9({
            type: "hook_non_blocking_error",
            hookName: W,
            toolUseID: Q,
            hookEvent: J,
            stderr: `Failed to run: ${N}`,
            stdout: "",
            exitCode: 1
          }),
          outcome: "non_blocking_error",
          hook: H
        };
        return
      }
    }),
    K = {
      success: 0,
      blocking: 0,
      non_blocking_error: 0,
      cancelled: 0
    },
    D;
  for await (let H of SYA(F)) {
    if (K[H.outcome]++, H.preventContinuation) yield {
      preventContinuation: !0,
      stopReason: H.stopReason
    };
    if (H.blockingError) yield {
      blockingError: H.blockingError
    };
    if (H.message) yield {
      message: H.message
    };
    if (H.systemMessage) yield {
      message: l9({
        type: "hook_system_message",
        content: H.systemMessage,
        hookName: W,
        toolUseID: Q,
        hookEvent: J
      })
    };
    if (H.additionalContext) yield {
      additionalContexts: [H.additionalContext]
    };
    if (H.updatedMCPToolOutput) yield {
      updatedMCPToolOutput: H.updatedMCPToolOutput
    };
    if (H.permissionBehavior) switch (H.permissionBehavior) {
      case "deny":
        D = "deny";
        break;
      case "ask":
        if (D !== "deny") D = "ask";
        break;
      case "allow":
        if (!D) D = "allow";
        break;
      case "passthrough":
        break
    }
    if (D !== void 0) yield {
      permissionBehavior: D,
      hookPermissionDecisionReason: H.hookPermissionDecisionReason,
      updatedInput: H.updatedInput && H.permissionBehavior === "allow" ? H.updatedInput : void 0
    };
    if (H.permissionRequestResult) yield {
      permissionRequestResult: H.permissionRequestResult
    };
    if (X && H.hook.type !== "callback") {
      let C = e1(),
        U = NZ2(X, C, J, B ?? "", H.hook);
      if (U?.onHookSuccess && H.outcome === "success") try {
        U.onHookSuccess(H.hook, H)
      } catch (q) {
        AA(Error("Session hook success callback failed", {
          cause: q
        }))
      }
    }
  }
  GA("tengu_repl_hook_finished", {
    hookName: W,
    numCommands: V.length,
    numSuccess: K.success,
    numBlocking: K.blocking,
    numNonBlockingError: K.non_blocking_error,
    numCancelled: K.cancelled
  })
}
// @from(Start 13913492, End 13916985)
async function kV0({
  getAppState: A,
  hookInput: Q,
  matchQuery: B,
  signal: G,
  timeoutMs: Z = ZN
}) {
  let I = Q.hook_event_name,
    Y = B ? `${I}:${B}` : I;
  if (l0().disableAllHooks) return g(`Skipping hooks for ${Y} due to 'disableAllHooks' setting`), [];
  if (rX9()) return g(`Skipping ${Y} hook execution - workspace trust not accepted`), [];
  let J = A ? await A() : void 0,
    W = _V0(J, I, Q);
  if (W.length === 0) return [];
  if (G?.aborted) return [];
  GA("tengu_run_hook", {
    hookName: Y,
    numCommands: W.length
  });
  let X;
  try {
    X = JSON.stringify(Q)
  } catch (F) {
    return AA(F instanceof Error ? F : Error(String(F))), []
  }
  let V = W.map(async (F, K) => {
    if (F.type === "callback") {
      let E = F.timeout ? F.timeout * 1000 : Z,
        {
          signal: U,
          cleanup: q
        } = ck(AbortSignal.timeout(E), G);
      try {
        let w = HVA(),
          N = await F.callback(Q, w, U, K);
        if (q?.(), zYA(N)) return g(`${Y} [callback] returned async response, returning empty output`), {
          command: "callback",
          succeeded: !0,
          output: ""
        };
        let R = N.systemMessage || "";
        return g(`${Y} [callback] completed successfully`), {
          command: "callback",
          succeeded: !0,
          output: R
        }
      } catch (w) {
        q?.();
        let N = w instanceof Error ? w.message : String(w);
        return g(`${Y} [callback] failed to run: ${N}`, {
          level: "error"
        }), {
          command: "callback",
          succeeded: !1,
          output: N
        }
      }
    }
    if (F.type === "prompt") return {
      command: F.prompt,
      succeeded: !1,
      output: "Prompt stop hooks are not yet supported outside REPL"
    };
    if (F.type === "agent") return {
      command: F.prompt([]),
      succeeded: !1,
      output: "Agent stop hooks are not yet supported outside REPL"
    };
    if (F.type === "function") return AA(Error(`Function hook reached executeHooksOutsideREPL for ${I}. Function hooks should only be used in REPL context (Stop hooks).`)), {
      command: "function",
      succeeded: !1,
      output: "Internal error: function hook executed outside REPL context"
    };
    let D = F.timeout ? F.timeout * 1000 : Z,
      {
        signal: H,
        cleanup: C
      } = ck(AbortSignal.timeout(D), G);
    try {
      let E = await SV0(F, I, Y, X, H, K);
      if (C?.(), E.aborted) return g(`${Y} [${F.command}] cancelled`), {
        command: F.command,
        succeeded: !1,
        output: "Hook cancelled"
      };
      g(`${Y} [${F.command}] completed with status ${E.status}`);
      let {
        json: U,
        validationError: q
      } = oX9(E.stdout);
      if (q) throw Sj(`${tA.bold(Y)} [${F.command}] ${tA.yellow("Hook JSON output validation failed")}`), Error(q);
      if (U && !zYA(U)) {
        if (g(`Parsed JSON output from hook: ${JSON.stringify(U)}`), U.systemMessage) L9(U.systemMessage)
      }
      let w = E.status === 0 ? E.stdout || "" : E.stderr || "";
      return {
        command: F.command,
        succeeded: E.status === 0,
        output: w
      }
    } catch (E) {
      C?.();
      let U = E instanceof Error ? E.message : String(E);
      return g(`${Y} [${F.command}] failed to run: ${U}`, {
        level: "error"
      }), {
        command: F.command,
        succeeded: !1,
        output: U
      }
    }
  });
  return await Promise.all(V)
}
// @from(Start 13916986, End 13917336)
async function* OV0(A, Q, B, G, Z, I, Y = ZN) {
  g(`executePreToolHooks called for tool: ${A}`);
  let J = {
    ...tE(Z),
    hook_event_name: "PreToolUse",
    tool_name: A,
    tool_input: B,
    tool_use_id: Q
  };
  yield* qa({
    hookInput: J,
    toolUseID: Q,
    matchQuery: A,
    signal: I,
    timeoutMs: Y,
    toolUseContext: G
  })
}
// @from(Start 13917337, End 13917663)
async function* RV0(A, Q, B, G, Z, I, Y, J = ZN) {
  let W = {
    ...tE(I),
    hook_event_name: "PostToolUse",
    tool_name: A,
    tool_input: B,
    tool_response: G,
    tool_use_id: Q
  };
  yield* qa({
    hookInput: W,
    toolUseID: Q,
    matchQuery: A,
    signal: Y,
    timeoutMs: J,
    toolUseContext: Z
  })
}
// @from(Start 13917664, End 13918013)
async function* TV0(A, Q, B, G, Z, I, Y, J, W = ZN) {
  let X = {
    ...tE(Y),
    hook_event_name: "PostToolUseFailure",
    tool_name: A,
    tool_input: B,
    tool_use_id: Q,
    error: G,
    is_interrupt: I
  };
  yield* qa({
    hookInput: X,
    toolUseID: Q,
    matchQuery: A,
    signal: J,
    timeoutMs: W,
    toolUseContext: Z
  })
}
// @from(Start 13918014, End 13918313)
async function B60(A, Q = ZN) {
  let {
    message: B,
    title: G,
    notificationType: Z
  } = A, I = {
    ...tE(void 0),
    hook_event_name: "Notification",
    message: B,
    title: G,
    notification_type: Z
  };
  await kV0({
    hookInput: I,
    timeoutMs: Q,
    matchQuery: Z
  })
}
// @from(Start 13918314, End 13918722)
async function* PV0(A, Q, B = ZN, G = !1, Z, I, Y) {
  let J = Z ? {
    ...tE(A),
    hook_event_name: "SubagentStop",
    stop_hook_active: G,
    agent_id: Z,
    agent_transcript_path: DVA(Z)
  } : {
    ...tE(A),
    hook_event_name: "Stop",
    stop_hook_active: G
  };
  yield* qa({
    hookInput: J,
    toolUseID: HVA(),
    signal: Q,
    timeoutMs: B,
    toolUseContext: I,
    messages: Y
  })
}
// @from(Start 13918723, End 13918979)
async function* k60(A, Q, B) {
  let G = {
    ...tE(Q),
    hook_event_name: "UserPromptSubmit",
    prompt: A
  };
  yield* qa({
    hookInput: G,
    toolUseID: HVA(),
    signal: B.abortController.signal,
    timeoutMs: ZN,
    toolUseContext: B
  })
}
// @from(Start 13918980, End 13919220)
async function* WQ0(A, Q, B, G = ZN) {
  let Z = {
    ...tE(void 0, Q),
    hook_event_name: "SessionStart",
    source: A
  };
  yield* qa({
    hookInput: Z,
    toolUseID: HVA(),
    matchQuery: A,
    signal: B,
    timeoutMs: G
  })
}
// @from(Start 13919221, End 13919480)
async function* rX0(A, Q, B, G = ZN) {
  let Z = {
    ...tE(void 0),
    hook_event_name: "SubagentStart",
    agent_id: A,
    agent_type: Q
  };
  yield* qa({
    hookInput: Z,
    toolUseID: HVA(),
    matchQuery: Q,
    signal: B,
    timeoutMs: G
  })
}
// @from(Start 13919481, End 13920425)
async function FQ0(A, Q, B = ZN) {
  let G = {
      ...tE(void 0),
      hook_event_name: "PreCompact",
      trigger: A.trigger,
      custom_instructions: A.customInstructions
    },
    Z = await kV0({
      hookInput: G,
      matchQuery: A.trigger,
      signal: Q,
      timeoutMs: B
    });
  if (Z.length === 0) return {};
  let I = Z.filter((J) => J.succeeded && J.output.trim().length > 0).map((J) => J.output.trim()),
    Y = [];
  for (let J of Z)
    if (J.succeeded)
      if (J.output.trim()) Y.push(`PreCompact [${J.command}] completed successfully: ${J.output.trim()}`);
      else Y.push(`PreCompact [${J.command}] completed successfully`);
  else if (J.output.trim()) Y.push(`PreCompact [${J.command}] failed: ${J.output.trim()}`);
  else Y.push(`PreCompact [${J.command}] failed`);
  return {
    newCustomInstructions: I.length > 0 ? I.join(`

`) : void 0,
    userDisplayMessage: Y.length > 0 ? Y.join(`
`) : void 0
  }
}
// @from(Start 13920426, End 13920799)
async function yV0(A, Q) {
  let {
    getAppState: B,
    setAppState: G,
    signal: Z,
    timeoutMs: I = ZN
  } = Q || {}, Y = {
    ...tE(void 0),
    hook_event_name: "SessionEnd",
    reason: A
  };
  if (await kV0({
      getAppState: B,
      hookInput: Y,
      matchQuery: A,
      signal: Z,
      timeoutMs: I
    }), G) {
    let J = e1();
    o21(G, J)
  }
}
// @from(Start 13920800, End 13921181)
async function* mW0(A, Q, B, G, Z, I, Y, J = ZN) {
  g(`executePermissionRequestHooks called for tool: ${A}`);
  let W = {
    ...tE(Z),
    hook_event_name: "PermissionRequest",
    tool_name: A,
    tool_input: B,
    permission_suggestions: I
  };
  yield* qa({
    hookInput: W,
    toolUseID: Q,
    matchQuery: A,
    signal: Y,
    timeoutMs: J,
    toolUseContext: G
  })
}
// @from(Start 13921182, End 13921749)
async function cJ0(A, Q, B = 5000) {
  let G = l0(),
    Z = G?.statusLine;
  if (G?.disableAllHooks === !0) return;
  if (!Z || Z.type !== "command") return;
  let I = Q || AbortSignal.timeout(B);
  try {
    let Y = JSON.stringify(A),
      J = await SV0(Z, "StatusLine", "statusLine", Y, I);
    if (J.aborted) return;
    if (J.status === 0) {
      let W = J.stdout.trim().split(`
`).flatMap((X) => X.trim() || []).join(`
`);
      if (W) return W
    }
    return
  } catch (Y) {
    g(`Status hook failed: ${Y}`, {
      level: "error"
    });
    return
  }
}
// @from(Start 13921750, End 13923148)
async function Ay3({
  hook: A,
  messages: Q,
  hookName: B,
  toolUseID: G,
  hookEvent: Z,
  timeoutMs: I,
  signal: Y
}) {
  let J = A.timeout ?? I,
    {
      signal: W,
      cleanup: X
    } = ck(AbortSignal.timeout(J), Y);
  try {
    if (W.aborted) return X(), {
      outcome: "cancelled",
      hook: A
    };
    let V = await new Promise((F, K) => {
      let D = () => K(Error("Function hook cancelled"));
      W.addEventListener("abort", D), Promise.resolve(A.callback(Q, W)).then((H) => {
        W.removeEventListener("abort", D), F(H)
      }).catch((H) => {
        W.removeEventListener("abort", D), K(H)
      })
    });
    if (X(), V) return {
      outcome: "success",
      hook: A
    };
    return {
      blockingError: {
        blockingError: A.errorMessage,
        command: "function"
      },
      outcome: "blocking",
      hook: A
    }
  } catch (V) {
    if (X(), V instanceof Error && (V.message === "Function hook cancelled" || V.name === "AbortError")) return {
      outcome: "cancelled",
      hook: A
    };
    return AA(V instanceof Error ? V : Error(String(V))), {
      message: l9({
        type: "hook_error_during_execution",
        hookName: B,
        toolUseID: G,
        hookEvent: Z,
        content: V instanceof Error ? V.message : "Function hook execution error"
      }),
      outcome: "non_blocking_error",
      hook: A
    }
  }
}
// @from(Start 13923149, End 13923649)
async function Qy3({
  toolUseID: A,
  hook: Q,
  hookEvent: B,
  hookInput: G,
  signal: Z,
  hookIndex: I
}) {
  let Y = await Q.callback(G, A, Z, I);
  if (zYA(Y)) return {
    outcome: "success",
    hook: Q
  };
  return {
    ...tX9({
      json: Y,
      command: "callback",
      hookName: `${B}:Callback`,
      toolUseID: A,
      hookEvent: B,
      expectedHookEvent: B,
      stdout: void 0,
      stderr: void 0,
      exitCode: void 0
    }),
    outcome: "success",
    hook: Q
  }
}
// @from(Start 13923654, End 13923664)
ZN = 60000
// @from(Start 13923670, End 13923872)
YO = L(() => {
  fu1();
  U2();
  hu1();
  D$A();
  _0();
  jQ();
  CYA();
  S7();
  MB();
  q0();
  k00();
  F9();
  dk();
  V0();
  g1();
  B91();
  y00();
  IO();
  _i();
  Aj2();
  sX9();
  jMA()
})
// @from(Start 13923875, End 13924045)
function By3() {
  try {
    if (process.stdin.isTTY && typeof process.stdin.setRawMode === "function") process.stdin.setRawMode(!1), process.stdin.unref()
  } catch {}
}
// @from(Start 13924047, End 13924228)
function l5(A = 0, Q = "other", B) {
  process.exitCode = A, v6(A, Q, B).catch((G) => {
    g(`Graceful shutdown failed: ${G}`, {
      level: "error"
    }), process.exit(A)
  })
}
// @from(Start 13924229, End 13924719)
async function v6(A = 0, Q = "other", B) {
  process.exitCode = A, By3();
  try {
    let {
      executeSessionEndHooks: G
    } = await Promise.resolve().then(() => (YO(), eX9));
    await G(Q, B)
  } catch {}
  try {
    let G = (async () => {
      try {
        await Vz0()
      } catch {}
    })();
    await Promise.race([G, new Promise((Z, I) => setTimeout(() => I(Error("Cleanup timeout")), 2000))]), await Bh1(), process.exit(A)
  } catch {
    await Bh1(), process.exit(A)
  }
}
// @from(Start 13924724, End 13924727)
AV9
// @from(Start 13924733, End 13924911)
kW = L(() => {
  l2();
  V0();
  HH();
  CUA();
  AV9 = s1(() => {
    process.on("SIGINT", () => {
      v6(0)
    }), process.on("SIGTERM", () => {
      v6(143)
    })
  })
})
// @from(Start 13924914, End 13925314)
function EQ(A) {
  let [Q, B] = QV9.useState({
    pending: !1,
    keyName: null
  }), G = Bf((I) => B({
    pending: I,
    keyName: "Ctrl-C"
  }), A ? A : async () => {
    await v6(0)
  }), Z = Bf((I) => B({
    pending: I,
    keyName: "Ctrl-D"
  }), A ? A : async () => {
    await v6(0)
  });
  return f1((I, Y) => {
    if (Y.ctrl && I === "c") G();
    if (Y.ctrl && I === "d") Z()
  }), Q
}
// @from(Start 13925319, End 13925322)
QV9
// @from(Start 13925328, End 13925390)
Q4 = L(() => {
  hA();
  wsA();
  kW();
  QV9 = BA(VA(), 1)
})
// @from(Start 13925393, End 13925569)
function BV9() {
  return u4.createElement($, {
    dimColor: !0
  }, "Claude Code will be able to read files in this directory and make edits when auto-accept edits is on.")
}
// @from(Start 13925571, End 13925779)
function Zy3({
  path: A
}) {
  return u4.createElement(S, {
    flexDirection: "column",
    paddingX: 2,
    gap: 1
  }, u4.createElement($, {
    color: "permission"
  }, A), u4.createElement(BV9, null))
}
// @from(Start 13925781, End 13926376)
function Iy3({
  value: A,
  onChange: Q,
  onSubmit: B,
  error: G
}) {
  return u4.createElement(S, {
    flexDirection: "column"
  }, u4.createElement($, null, "Enter the path to the directory:"), u4.createElement(S, {
    borderDimColor: !0,
    borderStyle: "round",
    marginY: 1,
    paddingLeft: 1
  }, u4.createElement(s4, {
    showCursor: !0,
    placeholder: `Directory path${H1.ellipsis}`,
    value: A,
    onChange: Q,
    onSubmit: B,
    columns: 80,
    cursorOffset: A.length,
    onChangeCursorOffset: () => {}
  })), G && u4.createElement($, {
    color: "error"
  }, G))
}
// @from(Start 13926378, End 13928048)
function SY1({
  onAddDirectory: A,
  onCancel: Q,
  permissionContext: B,
  directoryPath: G
}) {
  let [Z, I] = ig.useState(""), [Y, J] = ig.useState(null), W = EQ(), X = ig.useMemo(() => Gy3, []);
  f1(ig.useCallback((K, D) => {
    if (D.escape || D.ctrl && K === "c") Q()
  }, [Q]));
  let V = ig.useCallback((K) => {
      let D = XSA(K, B);
      if (D.resultType === "success") A(D.absolutePath, !1);
      else J(VSA(D))
    }, [B, A]),
    F = ig.useCallback((K) => {
      if (!G) return;
      switch (K) {
        case "yes-session":
          A(G, !1);
          break;
        case "yes-remember":
          A(G, !0);
          break;
        case "no":
          Q();
          break
      }
    }, [G, A, Q]);
  return u4.createElement(u4.Fragment, null, u4.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    gap: 1,
    borderColor: "permission"
  }, u4.createElement($, {
    bold: !0,
    color: "permission"
  }, "Add directory to workspace"), G ? u4.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, u4.createElement(Zy3, {
    path: G
  }), u4.createElement(M0, {
    options: X,
    onChange: F,
    onCancel: () => F("no")
  })) : u4.createElement(S, {
    flexDirection: "column",
    gap: 1,
    marginX: 2
  }, u4.createElement(BV9, null), u4.createElement(Iy3, {
    value: Z,
    onChange: I,
    onSubmit: V,
    error: Y
  }))), !G && u4.createElement(S, {
    marginLeft: 3
  }, W.pending ? u4.createElement($, {
    dimColor: !0
  }, "Press ", W.keyName, " again to exit") : u4.createElement($, {
    dimColor: !0
  }, "Enter to add · Esc to cancel")))
}
// @from(Start 13928053, End 13928055)
u4
// @from(Start 13928057, End 13928059)
ig
// @from(Start 13928061, End 13928064)
Gy3
// @from(Start 13928070, End 13928370)
xV0 = L(() => {
  hA();
  Q4();
  ZY();
  _Y1();
  V9();
  S5();
  u4 = BA(VA(), 1), ig = BA(VA(), 1), Gy3 = [{
    value: "yes-session",
    label: "Yes, for this session"
  }, {
    value: "yes-remember",
    label: "Yes, and remember this directory"
  }, {
    value: "no",
    label: "No"
  }]
})
// @from(Start 13928373, End 13930002)
function GV9({
  onCancel: A,
  onSubmit: Q,
  ruleBehavior: B
}) {
  let [G, Z] = vV0.useState(""), [I, Y] = vV0.useState(0), J = EQ();
  f1((F, K) => {
    if (K.escape) A()
  });
  let {
    columns: W
  } = WB(), X = W - 6, V = (F) => {
    let K = F.trim();
    if (K.length === 0) return;
    let D = nN(K);
    Q(D, B)
  };
  return F7.createElement(F7.Fragment, null, F7.createElement(S, {
    flexDirection: "column",
    gap: 1,
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "permission"
  }, F7.createElement($, {
    bold: !0,
    color: "permission"
  }, "Add ", B, " permission rule"), F7.createElement(S, {
    flexDirection: "column"
  }, F7.createElement($, null, "Permission rules are a tool name, optionally followed by a specifier in parentheses.", F7.createElement(bF, null), "e.g.,", " ", F7.createElement($, {
    bold: !0
  }, B3({
    toolName: nV.name
  })), F7.createElement($, {
    bold: !1
  }, " or "), F7.createElement($, {
    bold: !0
  }, B3({
    toolName: D9.name,
    ruleContent: "ls:*"
  }))), F7.createElement(S, {
    borderDimColor: !0,
    borderStyle: "round",
    marginY: 1,
    paddingLeft: 1
  }, F7.createElement(s4, {
    showCursor: !0,
    value: G,
    onChange: Z,
    onSubmit: V,
    placeholder: `Enter permission rule${H1.ellipsis}`,
    columns: X,
    cursorOffset: I,
    onChangeCursorOffset: Y
  })))), F7.createElement(S, {
    marginLeft: 3
  }, J.pending ? F7.createElement($, {
    dimColor: !0
  }, "Press ", J.keyName, " again to exit") : F7.createElement($, {
    dimColor: !0
  }, "Enter to submit · Esc to cancel")))
}
// @from(Start 13930007, End 13930009)
F7
// @from(Start 13930011, End 13930014)
vV0
// @from(Start 13930020, End 13930141)
ZV9 = L(() => {
  hA();
  Q4();
  AZ();
  i8();
  oWA();
  pF();
  ZY();
  V9();
  F7 = BA(VA(), 1), vV0 = BA(VA(), 1)
})
// @from(Start 13930144, End 13931445)
function YV9({
  onExit: A,
  getToolPermissionContext: Q,
  onRequestAddDirectory: B,
  onRequestRemoveDirectory: G
}) {
  let Z = Q(),
    I = j$.useMemo(() => {
      return Array.from(Z.additionalWorkingDirectories.keys()).map((W) => ({
        path: W,
        isCurrent: !1,
        isDeletable: !0
      }))
    }, [Z.additionalWorkingDirectories]),
    Y = IV9.useCallback((W) => {
      if (W === "add-directory") {
        B();
        return
      }
      let X = I.find((V) => V.path === W);
      if (X && X.isDeletable) G(X.path)
    }, [I, B, G]),
    J = j$.useMemo(() => {
      let W = I.map((X) => ({
        label: X.path,
        value: X.path
      }));
      return W.push({
        label: `Add directory${H1.ellipsis}`,
        value: "add-directory"
      }), W
    }, [I]);
  return j$.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, j$.createElement(S, {
    flexDirection: "row",
    marginTop: 1,
    marginLeft: 2,
    gap: 1
  }, j$.createElement($, null, `-  ${uQ()}`), j$.createElement($, {
    dimColor: !0
  }, "(Original working directory)")), j$.createElement(M0, {
    options: J,
    onChange: Y,
    onCancel: () => A("Workspace dialog dismissed", {
      display: "system"
    }),
    visibleOptionCount: Math.min(10, J.length)
  }))
}
// @from(Start 13931450, End 13931452)
j$
// @from(Start 13931454, End 13931457)
IV9
// @from(Start 13931463, End 13931551)
JV9 = L(() => {
  hA();
  S5();
  V9();
  _0();
  j$ = BA(VA(), 1), IV9 = BA(VA(), 1)
})
// @from(Start 13931554, End 13932998)
function WV9({
  directoryPath: A,
  onRemove: Q,
  onCancel: B,
  permissionContext: G,
  setPermissionContext: Z
}) {
  let I = EQ();
  f1((W, X) => {
    if (X.escape) B()
  });
  let Y = bV0.useCallback(() => {
      let W = UF(G, {
        type: "removeDirectories",
        directories: [A],
        destination: "session"
      });
      Z(W), Q()
    }, [A, G, Z, Q]),
    J = bV0.useCallback((W) => {
      if (W === "yes") Y();
      else B()
    }, [Y, B]);
  return rZ.createElement(rZ.Fragment, null, rZ.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "error"
  }, rZ.createElement($, {
    bold: !0,
    color: "error"
  }, "Remove directory from workspace?"), rZ.createElement(S, {
    marginY: 1,
    marginX: 2,
    flexDirection: "column"
  }, rZ.createElement($, {
    bold: !0
  }, A)), rZ.createElement($, null, "Claude Code will no longer have access to files in this directory."), rZ.createElement(S, {
    marginY: 1
  }, rZ.createElement(M0, {
    onChange: J,
    onCancel: B,
    options: [{
      label: "Yes",
      value: "yes"
    }, {
      label: "No",
      value: "no"
    }]
  }))), rZ.createElement(S, {
    marginLeft: 3
  }, I.pending ? rZ.createElement($, {
    dimColor: !0
  }, "Press ", I.keyName, " again to exit") : rZ.createElement($, {
    dimColor: !0
  }, "↑/↓ to select · Enter to confirm · Esc to cancel")))
}
// @from(Start 13933003, End 13933005)
rZ
// @from(Start 13933007, End 13933010)
bV0
// @from(Start 13933016, End 13933104)
XV9 = L(() => {
  hA();
  Q4();
  S5();
  cK();
  rZ = BA(VA(), 1), bV0 = BA(VA(), 1)
})
// @from(Start 13933107, End 13934184)
function Na({
  title: A,
  color: Q,
  defaultTab: B,
  children: G,
  hidden: Z
}) {
  let I = G.map((X) => [X.props.id ?? X.props.title, X.props.title]),
    Y = B ? I.findIndex((X) => B === X[0]) : 0,
    [J, W] = Gz.useState(Y !== -1 ? Y : 0);
  return f1((X, V) => {
    if (V.tab) {
      let F = V.shift ? -1 : 1;
      W((J + I.length + F) % I.length)
    }
  }, {
    isActive: !Z
  }), Gz.default.createElement(VV9.Provider, {
    value: I[J][0]
  }, Gz.default.createElement(S, {
    flexDirection: "column"
  }, !Z && Gz.default.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, A !== void 0 && Gz.default.createElement($, {
    bold: !0,
    color: Q
  }, A), I.map(([X, V], F) => Gz.default.createElement($, {
    key: X,
    backgroundColor: Q && J === F ? Q : void 0,
    color: Q && J === F ? "inverseText" : void 0,
    bold: J === F
  }, " ", V, " ")), Gz.default.createElement($, {
    dimColor: !0
  }, " ", Gz.default.createElement(E4, {
    shortcut: "tab",
    action: "cycle",
    parens: !0
  }))), Gz.default.createElement(S, null, G)))
}
// @from(Start 13934186, End 13934304)
function eD({
  title: A,
  id: Q,
  children: B
}) {
  if (Gz.useContext(VV9) !== (Q ?? A)) return null;
  return B
}
// @from(Start 13934309, End 13934311)
Gz
// @from(Start 13934313, End 13934316)
VV9
// @from(Start 13934322, End 13934407)
FSA = L(() => {
  hA();
  dF();
  Gz = BA(VA(), 1), VV9 = Gz.createContext(void 0)
})
// @from(Start 13934410, End 13934519)
function Yy3({
  rule: A
}) {
  return UQ.createElement($, {
    dimColor: !0
  }, `From ${hV0(A.source)}`)
}
// @from(Start 13934521, End 13934676)
function Jy3(A) {
  switch (A) {
    case "allow":
      return "allowed";
    case "deny":
      return "denied";
    case "ask":
      return "ask"
  }
}
// @from(Start 13934678, End 13936394)
function Wy3({
  rule: A,
  onDelete: Q,
  onCancel: B
}) {
  let G = EQ();
  f1((Y, J) => {
    if (J.escape) B()
  });
  let Z = UQ.createElement(S, {
      flexDirection: "column",
      marginX: 2
    }, UQ.createElement($, {
      bold: !0
    }, B3(A.ruleValue)), UQ.createElement(n21, {
      ruleValue: A.ruleValue
    }), UQ.createElement(Yy3, {
      rule: A
    })),
    I = UQ.createElement(S, {
      marginLeft: 3
    }, G.pending ? UQ.createElement($, {
      dimColor: !0
    }, "Press ", G.keyName, " again to exit") : UQ.createElement($, {
      dimColor: !0
    }, "Esc to cancel"));
  if (A.source === "policySettings") return UQ.createElement(UQ.Fragment, null, UQ.createElement(S, {
    flexDirection: "column",
    gap: 1,
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "permission"
  }, UQ.createElement($, {
    bold: !0,
    color: "permission"
  }, "Rule details"), Z, UQ.createElement($, {
    italic: !0
  }, "This rule is configured by managed settings and cannot be modified.", `
`, "Contact your system administrator for more information.")), I);
  return UQ.createElement(UQ.Fragment, null, UQ.createElement(S, {
    flexDirection: "column",
    gap: 1,
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "error"
  }, UQ.createElement($, {
    bold: !0,
    color: "error"
  }, "Delete ", Jy3(A.ruleBehavior), " tool?"), Z, UQ.createElement($, null, "Are you sure you want to delete this permission rule?"), UQ.createElement(M0, {
    onChange: (Y) => Y === "yes" ? Q() : B(),
    onCancel: B,
    options: [{
      label: "Yes",
      value: "yes"
    }, {
      label: "No",
      value: "no"
    }]
  })), I)
}
// @from(Start 13936396, End 13942660)
function kY1({
  onExit: A,
  initialTab: Q = "allow"
}) {
  let [B, G] = LK.useState([]), [{
    toolPermissionContext: Z
  }, I] = OQ(), [Y, J] = LK.useState(), [W, X] = LK.useState(null), [V, F] = LK.useState(null), [K, D] = LK.useState(!1), [H, C] = LK.useState(null), E = LK.useMemo(() => {
    let k = new Map;
    return CVA(Z).forEach((m) => {
      k.set(JSON.stringify(m), m)
    }), k
  }, [Z]), U = LK.useMemo(() => {
    let k = new Map;
    return KVA(Z).forEach((m) => {
      k.set(JSON.stringify(m), m)
    }), k
  }, [Z]), q = LK.useMemo(() => {
    let k = new Map;
    return yY1(Z).forEach((m) => {
      k.set(JSON.stringify(m), m)
    }), k
  }, [Z]), w = LK.useCallback((k) => {
    let m = (() => {
        switch (k) {
          case "allow":
            return E;
          case "deny":
            return U;
          case "ask":
            return q;
          case "workspace":
            return new Map
        }
      })(),
      o = [];
    if (k !== "workspace") o.push({
      label: `Add a new rule${H1.ellipsis}`,
      value: "add-new-rule"
    });
    let IA = Array.from(m.keys()).sort((FA, zA) => {
      let NA = m.get(FA),
        OA = m.get(zA);
      if (NA && OA) {
        let mA = B3(NA.ruleValue).toLowerCase(),
          wA = B3(OA.ruleValue).toLowerCase();
        return mA.localeCompare(wA)
      }
      return 0
    });
    for (let FA of IA) {
      let zA = m.get(FA);
      if (zA) o.push({
        label: B3(zA.ruleValue),
        value: FA
      })
    }
    return {
      options: o,
      rulesByKey: m
    }
  }, [E, U, q]), N = EQ(), R = LK.useCallback((k, m) => {
    let {
      rulesByKey: o
    } = w(m);
    if (k === "add-new-rule") {
      X(m);
      return
    } else {
      J(o.get(k));
      return
    }
  }, [w]), T = LK.useCallback(() => {
    X(null)
  }, []), y = LK.useCallback((k, m) => {
    F({
      ruleValue: k,
      ruleBehavior: m
    }), X(null)
  }, []), v = LK.useCallback((k) => {
    F(null);
    for (let m of k) G((o) => [...o, `Added ${m.ruleBehavior} rule ${tA.bold(B3(m.ruleValue))}`])
  }, []), x = LK.useCallback(() => {
    F(null)
  }, []), p = () => {
    if (!Y) return;
    FV9({
      rule: Y,
      initialContext: Z,
      setToolPermissionContext(k) {
        I((m) => ({
          ...m,
          toolPermissionContext: k
        }))
      }
    }), G((k) => [...k, `Deleted ${Y.ruleBehavior} rule ${tA.bold(B3(Y.ruleValue))}`]), J(void 0)
  };
  if (Y) return UQ.createElement(Wy3, {
    rule: Y,
    onDelete: p,
    onCancel: () => J(void 0)
  });
  if (W && W !== "workspace") return UQ.createElement(GV9, {
    onCancel: T,
    onSubmit: y,
    ruleBehavior: W
  });
  if (V) return UQ.createElement(wZ2, {
    onAddRules: v,
    onCancel: x,
    ruleValues: [V.ruleValue],
    ruleBehavior: V.ruleBehavior,
    initialContext: Z,
    setToolPermissionContext: (k) => {
      I((m) => ({
        ...m,
        toolPermissionContext: k
      }))
    }
  });
  if (K) return UQ.createElement(SY1, {
    onAddDirectory: (k, m) => {
      let IA = {
          type: "addDirectories",
          directories: [k],
          destination: m ? "localSettings" : "session"
        },
        FA = UF(Z, IA);
      if (I((zA) => ({
          ...zA,
          toolPermissionContext: FA
        })), m) Iv(IA);
      G((zA) => [...zA, `Added directory ${tA.bold(k)} to workspace${m?" and saved to local settings":" for this session"}`]), D(!1)
    },
    onCancel: () => D(!1),
    permissionContext: Z
  });
  if (H) return UQ.createElement(WV9, {
    directoryPath: H,
    onRemove: () => {
      G((k) => [...k, `Removed directory ${tA.bold(H)} from workspace`]), C(null)
    },
    onCancel: () => C(null),
    permissionContext: Z,
    setPermissionContext: (k) => {
      I((m) => ({
        ...m,
        toolPermissionContext: k
      }))
    }
  });

  function u(k) {
    switch (k) {
      case "allow":
        return "Claude Code won't ask before using allowed tools.";
      case "deny":
        return "Claude Code will always reject requests to use denied tools.";
      case "ask":
        return "Claude Code will always ask for confirmation before using these tools.";
      case "workspace":
        return "Claude Code can read files in the workspace, and make edits when auto-accept edits is on."
    }
  }

  function e(k) {
    if (k === "workspace") return UQ.createElement(YV9, {
      onExit: A,
      getToolPermissionContext: () => Z,
      onRequestAddDirectory: () => D(!0),
      onRequestRemoveDirectory: (o) => C(o)
    });
    let {
      options: m
    } = w(k);
    return UQ.createElement(S, {
      marginY: 1
    }, UQ.createElement(M0, {
      options: m,
      onChange: (o) => R(o, k),
      onCancel: () => {
        if (B.length > 0) A(B.join(`
`));
        else A("Permissions dialog dismissed", {
          display: "system"
        })
      },
      visibleOptionCount: Math.min(10, m.length)
    }))
  }
  return UQ.createElement(S, {
    flexDirection: "column"
  }, UQ.createElement(D3, {
    dividerColor: "permission"
  }), UQ.createElement(S, {
    paddingX: 1,
    flexDirection: "column"
  }, UQ.createElement(Na, {
    title: "Permissions:",
    color: "permission",
    defaultTab: Q,
    hidden: !!Y || !!W || !!V || K || !!H
  }, UQ.createElement(eD, {
    id: "allow",
    title: "Allow"
  }, UQ.createElement(S, {
    flexDirection: "column"
  }, UQ.createElement($, null, u("allow")), e("allow"))), UQ.createElement(eD, {
    id: "ask",
    title: "Ask"
  }, UQ.createElement(S, {
    flexDirection: "column"
  }, UQ.createElement($, null, u("ask")), e("ask"))), UQ.createElement(eD, {
    id: "deny",
    title: "Deny"
  }, UQ.createElement(S, {
    flexDirection: "column"
  }, UQ.createElement($, null, u("deny")), e("deny"))), UQ.createElement(eD, {
    id: "workspace",
    title: "Workspace"
  }, UQ.createElement(S, {
    flexDirection: "column"
  }, UQ.createElement($, null, u("workspace")), e("workspace")))), UQ.createElement(S, {
    marginTop: 1
  }, UQ.createElement($, {
    dimColor: !0
  }, N.pending ? UQ.createElement(UQ.Fragment, null, "Press ", N.keyName, " again to exit") : UQ.createElement(UQ.Fragment, null, "Press ↑↓ to navigate · Enter to select · Esc to exit")))))
}
// @from(Start 13942665, End 13942667)
UQ
// @from(Start 13942669, End 13942671)
LK
// @from(Start 13942677, End 13942867)
fV0 = L(() => {
  hA();
  S5();
  Q4();
  AZ();
  V9();
  O00();
  a21();
  ZV9();
  F9();
  JV9();
  xV0();
  XV9();
  cK();
  z9();
  FSA();
  BK();
  UQ = BA(VA(), 1), LK = BA(VA(), 1)
})
// @from(Start 13942911, End 13943281)
function Vy3({
  message: A,
  args: Q,
  onDone: B
}) {
  return Hx.useEffect(() => {
    let G = setTimeout(B, 0);
    return () => clearTimeout(G)
  }, [B]), Hx.default.createElement(S, {
    flexDirection: "column"
  }, Hx.default.createElement($, {
    dimColor: !0
  }, "> /add-dir ", Q), Hx.default.createElement(S0, null, Hx.default.createElement($, null, A)))
}
// @from(Start 13943283, End 13943849)
function XSA(A, Q) {
  if (!A) return {
    resultType: "emptyPath"
  };
  let B = b9(A),
    G = RA();
  if (!G.existsSync(B)) return {
    resultType: "pathNotFound",
    directoryPath: A,
    absolutePath: B
  };
  if (!G.statSync(B).isDirectory()) return {
    resultType: "notADirectory",
    directoryPath: A,
    absolutePath: B
  };
  let Z = JIA(Q);
  for (let I of Z)
    if (Mh(B, I)) return {
      resultType: "alreadyInWorkingDirectory",
      directoryPath: A,
      workingDir: I
    };
  return {
    resultType: "success",
    absolutePath: B
  }
}
// @from(Start 13943851, End 13944507)
function VSA(A) {
  switch (A.resultType) {
    case "emptyPath":
      return "Please provide a directory path.";
    case "pathNotFound":
      return `Path ${tA.bold(A.absolutePath)} was not found.`;
    case "notADirectory": {
      let Q = Xy3(A.absolutePath);
      return `${tA.bold(A.directoryPath)} is not a directory. Did you mean to add the parent directory ${tA.bold(Q)}?`
    }
    case "alreadyInWorkingDirectory":
      return `${tA.bold(A.directoryPath)} is already accessible within the existing working directory ${tA.bold(A.workingDir)}.`;
    case "success":
      return `Added ${tA.bold(A.absolutePath)} as a working directory.`
  }
}
// @from(Start 13944512, End 13944514)
Hx
// @from(Start 13944516, End 13944519)
Fy3
// @from(Start 13944521, End 13944524)
KV9
// @from(Start 13944530, End 13946469)
_Y1 = L(() => {
  F9();
  hA();
  EJ();
  AQ();
  yI();
  xV0();
  q8();
  fV0();
  cK();
  Hx = BA(VA(), 1);
  Fy3 = {
    type: "local-jsx",
    name: "add-dir",
    description: "Add a new working directory",
    argumentHint: "<path>",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q, B) {
      let G = B.trim();
      if (!G) return Hx.default.createElement(kY1, {
        onExit: A,
        initialTab: "workspace"
      });
      let Z = await Q.getAppState(),
        I = XSA(G, Z.toolPermissionContext);
      if (I.resultType !== "success") {
        let Y = VSA(I);
        return Hx.default.createElement(Vy3, {
          message: Y,
          args: B,
          onDone: () => A(Y)
        })
      }
      return Hx.default.createElement(SY1, {
        directoryPath: I.absolutePath,
        permissionContext: Z.toolPermissionContext,
        onAddDirectory: async (Y, J) => {
          let X = {
              type: "addDirectories",
              directories: [Y],
              destination: J ? "localSettings" : "session"
            },
            V = await Q.getAppState(),
            F = UF(V.toolPermissionContext, X);
          Q.setAppState((H) => ({
            ...H,
            toolPermissionContext: F
          }));
          let K;
          if (J) try {
            Iv(X), K = `Added ${tA.bold(Y)} as a working directory and saved to local settings`
          } catch (H) {
            K = `Added ${tA.bold(Y)} as a working directory. Failed to save to local settings: ${H instanceof Error?H.message:"Unknown error"}`
          } else K = `Added ${tA.bold(Y)} as a working directory for this session`;
          let D = `${K} ${tA.dim("· /permissions to manage")}`;
          A(D)
        },
        onCancel: () => {
          A(`Did not add ${tA.bold(I.absolutePath)} as a working directory.`)
        }
      })
    },
    userFacingName() {
      return "add-dir"
    }
  }, KV9 = Fy3
})
// @from(Start 13946472, End 13947575)
function uQA(A) {
  let Q = A;
  return Q = Q.replace(/"(sk-ant[^\s"']{24,})"/g, '"[REDACTED_API_KEY]"'), Q = Q.replace(/(?<![A-Za-z0-9"'])(sk-ant-?[A-Za-z0-9_-]{10,})(?![A-Za-z0-9"'])/g, "[REDACTED_API_KEY]"), Q = Q.replace(/AWS key: "(AWS[A-Z0-9]{20,})"/g, 'AWS key: "[REDACTED_AWS_KEY]"'), Q = Q.replace(/(AKIA[A-Z0-9]{16})/g, "[REDACTED_AWS_KEY]"), Q = Q.replace(/(?<![A-Za-z0-9])(AIza[A-Za-z0-9_-]{35})(?![A-Za-z0-9])/g, "[REDACTED_GCP_KEY]"), Q = Q.replace(/(?<![A-Za-z0-9])([a-z0-9-]+@[a-z0-9-]+\.iam\.gserviceaccount\.com)(?![A-Za-z0-9])/g, "[REDACTED_GCP_SERVICE_ACCOUNT]"), Q = Q.replace(/(["']?x-api-key["']?\s*[:=]\s*["']?)[^"',\s)}\]]+/gi, "$1[REDACTED_API_KEY]"), Q = Q.replace(/(["']?authorization["']?\s*[:=]\s*["']?(bearer\s+)?)[^"',\s)}\]]+/gi, "$1[REDACTED_TOKEN]"), Q = Q.replace(/(AWS[_-][A-Za-z0-9_]+\s*[=:]\s*)["']?[^"',\s)}\]]+["']?/gi, "$1[REDACTED_AWS_VALUE]"), Q = Q.replace(/(GOOGLE[_-][A-Za-z0-9_]+\s*[=:]\s*)["']?[^"',\s)}\]]+["']?/gi, "$1[REDACTED_GCP_VALUE]"), Q = Q.replace(/((API[-_]?KEY|TOKEN|SECRET|PASSWORD)\s*[=:]\s*)["']?[^"',\s)}\]]+["']?/gi, "$1[REDACTED]"), Q
}
// @from(Start 13947577, End 13948280)
function Dy3(A) {
  let Q = [];
  for (let B of A) {
    if (B.type !== "user") continue;
    let G = B.message.content;
    if (!Array.isArray(G)) continue;
    for (let Z of G) {
      if (Z.type !== "tool_result") continue;
      let I = Z.content;
      if (typeof I === "string") try {
        let Y = JSON.parse(I);
        if (Y && typeof Y.agentId === "string") Q.push(Y.agentId)
      } catch {} else if (Array.isArray(I)) {
        for (let Y of I)
          if (Y.type === "text" && typeof Y.text === "string") try {
            let J = JSON.parse(Y.text);
            if (J && typeof J.agentId === "string") Q.push(J.agentId)
          } catch {}
      }
    }
  }
  return [...new Set(Q)]
}
// @from(Start 13948281, End 13948649)
async function Hy3(A) {
  let Q = await Promise.all(A.map(async (G) => {
      try {
        let Z = await KY1(G);
        if (Z && Z.length > 0) return {
          agentId: G,
          transcript: Z
        };
        return null
      } catch {
        return null
      }
    })),
    B = {};
  for (let G of Q)
    if (G) B[G.agentId] = G.transcript;
  return B
}
// @from(Start 13948651, End 13948813)
function HV9() {
  return z2A().map((A) => {
    let Q = {
      ...A
    };
    if (Q && typeof Q.error === "string") Q.error = uQA(Q.error);
    return Q
  })
}
// @from(Start 13948815, End 13955081)
function EV9({
  abortSignal: A,
  messages: Q,
  initialDescription: B,
  onDone: G
}) {
  let [Z, I] = fO.useState("userInput"), [Y, J] = fO.useState(0), [W, X] = fO.useState(B ?? ""), [V, F] = fO.useState(null), [K, D] = fO.useState(null), [H, C] = fO.useState({
    isGit: !1,
    gitState: null
  }), [E, U] = fO.useState(null), q = WB().columns - 4;
  fO.useEffect(() => {
    async function R() {
      let T = await rw(),
        y = null;
      if (T) y = await wh1();
      C({
        isGit: T,
        gitState: y
      })
    }
    R()
  }, []);
  let w = EQ(),
    N = fO.useCallback(async () => {
      I("submitting"), D(null), F(null);
      let R = HV9(),
        y = AVA(Q)?.requestId ?? null,
        v = Dy3(Q),
        x = await Hy3(v),
        p = {
          latestAssistantMessageId: y,
          message_count: Q.length,
          datetime: new Date().toISOString(),
          description: W,
          platform: d0.platform,
          gitRepo: H.isGit,
          terminal: d0.terminal,
          version: {
            ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
            PACKAGE_URL: "@anthropic-ai/claude-code",
            README_URL: "https://code.claude.com/docs/en/overview",
            VERSION: "2.0.59",
            FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
          }.VERSION,
          transcript: WZ(Q),
          errors: R,
          lastApiRequest: NkA(),
          ...Object.keys(x).length > 0 && {
            subagentTranscripts: x
          }
        },
        [u, e] = await Promise.all([zy3(p), Ey3(W, A)]);
      if (U(e), u.success) {
        if (u.feedbackId) F(u.feedbackId), GA("tengu_bug_report_submitted", {
          feedback_id: u.feedbackId,
          last_assistant_message_id: y
        });
        I("done")
      } else {
        if (u.isZdrOrg) D("Feedback collection is not available for organizations with custom data retention policies.");
        else D("Could not submit feedback. Please try again later.");
        I("done")
      }
    }, [W, H.isGit, Q]);
  return f1((R, T) => {
    if (Z === "done") {
      if (T.return && E) {
        let y = Cy3(V ?? "", E, W, HV9());
        cZ(y)
      }
      if (K) G("Error submitting feedback / bug report", {
        display: "system"
      });
      else G("Feedback / bug report submitted", {
        display: "system"
      });
      return
    }
    if (K) {
      G("Error submitting feedback / bug report", {
        display: "system"
      });
      return
    }
    if (T.escape) {
      G("Feedback / bug report cancelled", {
        display: "system"
      });
      return
    }
    if (Z === "consent" && (T.return || R === " ")) N()
  }), mQ.createElement(mQ.Fragment, null, mQ.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "permission",
    paddingX: 1,
    paddingBottom: 1,
    gap: 1
  }, mQ.createElement($, {
    bold: !0,
    color: "permission"
  }, "Submit Feedback / Bug Report"), Z === "userInput" && mQ.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, mQ.createElement($, null, "Describe the issue below:"), mQ.createElement(s4, {
    value: W,
    onChange: X,
    columns: q,
    onSubmit: () => I("consent"),
    onExitMessage: () => G("Feedback cancelled", {
      display: "system"
    }),
    cursorOffset: Y,
    onChangeCursorOffset: J
  }), K && mQ.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, mQ.createElement($, {
    color: "error"
  }, K), mQ.createElement($, {
    dimColor: !0
  }, "Press any key to close"))), Z === "consent" && mQ.createElement(S, {
    flexDirection: "column"
  }, mQ.createElement($, null, "This report will include:"), mQ.createElement(S, {
    marginLeft: 2,
    flexDirection: "column"
  }, mQ.createElement($, null, "- Your feedback / bug description:", " ", mQ.createElement($, {
    dimColor: !0
  }, W)), mQ.createElement($, null, "- Environment info:", " ", mQ.createElement($, {
    dimColor: !0
  }, d0.platform, ", ", d0.terminal, ", v", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION)), H.gitState && mQ.createElement($, null, "- Git repo metadata:", " ", mQ.createElement($, {
    dimColor: !0
  }, H.gitState.branchName, H.gitState.commitHash ? `, ${H.gitState.commitHash.slice(0,7)}` : "", H.gitState.remoteUrl ? ` @ ${H.gitState.remoteUrl}` : "", !H.gitState.isHeadOnRemote && ", not synced", !H.gitState.isClean && ", has local changes")), mQ.createElement($, null, "- Current session transcript")), mQ.createElement(S, {
    marginTop: 1
  }, mQ.createElement($, {
    wrap: "wrap",
    dimColor: !0
  }, "We will use your feedback to debug related issues or to improve", " ", "Claude Code's functionality (eg. to reduce the risk of bugs occurring in the future).")), mQ.createElement(S, {
    marginTop: 1
  }, mQ.createElement($, null, "Press ", mQ.createElement($, {
    bold: !0
  }, "Enter"), " to confirm and submit."))), Z === "submitting" && mQ.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, mQ.createElement($, null, "Submitting report…")), Z === "done" && mQ.createElement(S, {
    flexDirection: "column"
  }, K ? mQ.createElement($, {
    color: "error"
  }, K) : mQ.createElement($, {
    color: "success"
  }, "Thank you for your report!"), V && mQ.createElement($, {
    dimColor: !0
  }, "Feedback ID: ", V), mQ.createElement(S, {
    marginTop: 1
  }, mQ.createElement($, null, "Press "), mQ.createElement($, {
    bold: !0
  }, "Enter "), mQ.createElement($, null, "to open your browser and draft a GitHub issue, or any other key to close.")))), mQ.createElement(S, {
    marginLeft: 1
  }, mQ.createElement($, {
    dimColor: !0
  }, w.pending ? mQ.createElement(mQ.Fragment, null, "Press ", w.keyName, " again to exit") : Z === "userInput" ? mQ.createElement(mQ.Fragment, null, "Enter to continue · Esc to cancel") : Z === "consent" ? mQ.createElement(mQ.Fragment, null, "Enter to submit · Esc to cancel") : null)))
}
// @from(Start 13955083, End 13956133)
function Cy3(A, Q, B, G) {
  let Z = uQA(Q),
    I = uQA(B),
    Y = encodeURIComponent(`**Bug Description**
${I}

**Environment Info**
- Platform: ${d0.platform}
- Terminal: ${d0.terminal}
- Version: ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION||"unknown"}
- Feedback ID: ${A}

**Errors**
\`\`\`json
`),
    J = encodeURIComponent("\n```\n"),
    W = encodeURIComponent(`
**Note:** Error logs were truncated.
`),
    X = JSON.stringify(G),
    V = encodeURIComponent(X),
    F = `${DV9}/new?title=${encodeURIComponent(Z)}&labels=user-reported,bug&body=`,
    K = Ky3 - F.length - Y.length - J.length - W.length,
    D = "";
  if (V.length <= K) D = Y + V + J;
  else {
    let H = V.substring(0, K);
    D = Y + H + J + W
  }
  return `${DV9}/new?title=${encodeURIComponent(Z)}&body=${D}&labels=user-reported,bug`
}
// @from(Start 13956134, End 13957847)
async function Ey3(A, Q) {
  try {
    let B = await uX({
        systemPrompt: ["Generate a concise, technical issue title (max 80 chars) for a public GitHub issue based on this bug report for Claude Code.", "Claude Code is an agentic coding CLI based on the Anthropic API.", "The title should:", "- Include the type of issue [Bug] or [Feature Request] as the first thing in the title", "- Be concise, specific and descriptive of the actual problem", "- Use technical terminology appropriate for a software issue", '- For error messages, extract the key error (e.g., "Missing Tool Result Block" rather than the full message)', "- Be direct and clear for developers to understand the problem", '- If you cannot determine a clear issue, use "Bug Report: [brief description]"', "- Any LLM API errors are from the Anthropic API, not from any other model provider", "Your response will be directly used as the title of the Github issue, and as such should not contain any other commentary or explaination", 'Examples of good titles include: "[Bug] Auto-Compact triggers to soon", "[Bug] Anthropic API Error: Missing Tool Result Block", "[Bug] Error: Invalid Model Name for Opus"'],
        userPrompt: A,
        signal: Q,
        options: {
          hasAppendSystemPrompt: !1,
          toolChoice: void 0,
          isNonInteractiveSession: !1,
          agents: [],
          querySource: "feedback",
          mcpTools: [],
          agentIdOrSessionId: e1()
        }
      }),
      G = B.message.content[0]?.type === "text" ? B.message.content[0].text : "Bug Report";
    if (G.startsWith(uV)) return CV9(A);
    return G
  } catch (B) {
    return AA(B instanceof Error ? B : Error(String(B))), CV9(A)
  }
}
// @from(Start 13957849, End 13958126)
function CV9(A) {
  let Q = A.split(`
`)[0] || "";
  if (Q.length <= 60 && Q.length > 5) return Q;
  let B = Q.slice(0, 60);
  if (Q.length > 60) {
    let G = B.lastIndexOf(" ");
    if (G > 30) B = B.slice(0, G);
    B += "..."
  }
  return B.length < 10 ? "Bug Report" : B
}
// @from(Start 13958128, End 13958321)
function xY1(A) {
  if (A instanceof Error) {
    let Q = Error(uQA(A.message));
    if (A.stack) Q.stack = uQA(A.stack);
    AA(Q)
  } else {
    let Q = uQA(String(A));
    AA(Error(Q))
  }
}
// @from(Start 13958322, End 13959483)
async function zy3(A) {
  try {
    let Q = DI();
    if (Q.error) return {
      success: !1
    };
    let B = {
        "Content-Type": "application/json",
        "User-Agent": fc(),
        ...Q.headers
      },
      G = await YQ.post("https://api.anthropic.com/api/claude_cli_feedback", {
        content: JSON.stringify(A)
      }, {
        headers: B
      });
    if (G.status === 200) {
      let Z = G.data;
      if (Z?.feedback_id) return {
        success: !0,
        feedbackId: Z.feedback_id
      };
      return xY1(Error("Failed to submit feedback: request did not return feedback_id")), {
        success: !1
      }
    }
    return xY1(Error("Failed to submit feedback:" + G.status)), {
      success: !1
    }
  } catch (Q) {
    if (YQ.isAxiosError(Q) && Q.response?.status === 403) {
      let B = Q.response.data;
      if (B?.error?.type === "permission_error" && B?.error?.message?.includes("Custom data retention settings")) return xY1(Error("Cannot submit feedback because custom data retention settings are enabled")), {
        success: !1,
        isZdrOrg: !0
      }
    }
    return xY1(Q), {
      success: !1
    }
  }
}
// @from(Start 13959488, End 13959490)
mQ
// @from(Start 13959492, End 13959494)
fO
// @from(Start 13959496, End 13959506)
Ky3 = 7250
// @from(Start 13959510, End 13959566)
DV9 = "https://github.com/anthropics/claude-code/issues"
// @from(Start 13959572, End 13959755)
gV0 = L(() => {
  hA();
  ZY();
  g1();
  c5();
  PV();
  i8();
  AE();
  q0();
  fZ();
  ZO();
  gM();
  Q4();
  O3();
  cQ();
  _0();
  S7();
  mQ = BA(VA(), 1), fO = BA(VA(), 1)
})
// @from(Start 13959761, End 13959802)
zV9 = L(() => {
  _0();
  g1();
  gB()
})
// @from(Start 13959808, End 13959811)
UV9
// @from(Start 13959813, End 13959816)
vY1
// @from(Start 13959822, End 13960034)
$V9 = L(() => {
  hA();
  ZY();
  g1();
  c5();
  PV();
  i8();
  q0();
  Q4();
  gV0();
  BK();
  sU();
  _8();
  zV9();
  cQ();
  UjA();
  _0();
  Pn();
  yq();
  V0();
  UV9 = BA(VA(), 1), vY1 = BA(VA(), 1)
})
// @from(Start 13960040, End 13960043)
Uy3
// @from(Start 13960049, End 13960096)
wV9 = L(() => {
  $V9();
  Uy3 = BA(VA(), 1)
})
// @from(Start 13960099, End 13960249)
function $y3(A, Q, B, G = "") {
  return uV0.createElement(EV9, {
    abortSignal: Q,
    messages: B,
    initialDescription: G,
    onDone: A
  })
}
// @from(Start 13960254, End 13960257)
uV0
// @from(Start 13960259, End 13960262)
wy3
// @from(Start 13960264, End 13960267)
qV9
// @from(Start 13960273, End 13960999)
NV9 = L(() => {
  gV0();
  hQ();
  uV0 = BA(VA(), 1);
  wy3 = {
    aliases: ["bug"],
    type: "local-jsx",
    name: "feedback",
    description: "Submit feedback about Claude Code",
    argumentHint: "[report]",
    isEnabled: () => !(Y0(process.env.CLAUDE_CODE_USE_BEDROCK) || Y0(process.env.CLAUDE_CODE_USE_VERTEX) || Y0(process.env.CLAUDE_CODE_USE_FOUNDRY) || process.env.DISABLE_FEEDBACK_COMMAND || process.env.DISABLE_BUG_COMMAND || process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC),
    isHidden: !1,
    async call(A, {
      abortController: Q,
      messages: B
    }, G) {
      let Z = G || "";
      return $y3(A, Q.signal, B, Z)
    },
    userFacingName() {
      return "feedback"
    }
  }, qV9 = wy3
})
// @from(Start 13961001, End 13961600)
async function qy3({
  setMessages: A,
  readFileState: Q,
  getAppState: B,
  setAppState: G
}) {
  if (await yV0("clear", {
      getAppState: B,
      setAppState: G
    }), !gH()) await kJ();
  if (A(() => []), DK.cache.clear?.(), iD.cache.clear?.(), F70.cache.clear?.(), gV.cache.clear?.(), Bq(uQ()), Q.clear(), G) G((I) => ({
    ...I,
    fileHistory: {
      snapshots: [],
      trackedFiles: new Set
    },
    mcp: {
      clients: [],
      tools: [],
      commands: [],
      resources: {}
    }
  }));
  qE0(), await Fx();
  let Z = await wq("clear");
  if (Z.length > 0) A(() => Z)
}
// @from(Start 13961605, End 13961608)
Ny3
// @from(Start 13961610, End 13961613)
LV9
// @from(Start 13961619, End 13962103)
MV9 = L(() => {
  Ty();
  gE();
  Bh();
  nt();
  _0();
  u_();
  S7();
  k1A();
  YO();
  Ny3 = {
    type: "local",
    name: "clear",
    description: "Clear conversation history and free up context",
    aliases: ["reset", "new"],
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    async call(A, Q) {
      return await qy3(Q), {
        type: "text",
        value: ""
      }
    },
    userFacingName() {
      return "clear"
    }
  }, LV9 = Ny3
})
// @from(Start 13962109, End 13962112)
Ly3
// @from(Start 13962114, End 13962117)
OV9
// @from(Start 13962123, End 13964021)
RV9 = L(() => {
  Ty();
  gE();
  lMA();
  y1A();
  h91();
  g1();
  F9();
  wZ1();
  hQ();
  Ly3 = {
    type: "local",
    name: "compact",
    description: "Clear conversation history but keep a summary in context. Optional: /compact [instructions for summarization]",
    isEnabled: () => !Y0(process.env.DISABLE_COMPACT),
    isHidden: !1,
    supportsNonInteractive: !0,
    argumentHint: "<optional custom summarization instructions>",
    async call(A, Q) {
      let {
        abortController: B,
        messages: G
      } = Q;
      if (G.length === 0) throw Error("No messages to compact");
      let Z = A.trim();
      try {
        if (!Z) {
          let V = await f91(G, Q.agentId);
          if (V) {
            DK.cache.clear?.(), gV.cache.clear?.();
            let F = EQA("tip"),
              K = [...Q.options.verbose ? [] : ["(ctrl+o to see full summary)"], ...F ? [F] : []];
            return {
              type: "compact",
              compactionResult: V,
              displayText: tA.dim("Compacted " + K.join(`
`))
            }
          }
        }
        let Y = (await Si(G, void 0, Q)).messages,
          J = await j91(Y, Q, !1, Z);
        DK.cache.clear?.(), gV.cache.clear?.();
        let W = EQA("tip"),
          X = [...Q.options.verbose ? [] : ["(ctrl+o to see full summary)"], ...J.userDisplayMessage ? [J.userDisplayMessage] : [], ...W ? [W] : []];
        return {
          type: "compact",
          compactionResult: J,
          displayText: tA.dim("Compacted " + X.join(`
`))
        }
      } catch (I) {
        if (B.signal.aborted) throw Error("Compaction canceled.");
        else if (I instanceof Error && I.message === cMA) throw Error(cMA);
        else throw AA(I instanceof Error ? I : Error(String(I))), Error(`Error during compaction: ${I}`)
      }
    },
    userFacingName() {
      return "compact"
    }
  }, OV9 = Ly3
})
// @from(Start 13964024, End 13965501)
function TV9({
  context: A,
  flat: Q
} = {}) {
  let B = gV(),
    G = [];
  if (A?.readFileState) _l(A.readFileState).forEach((Y) => {
    let J = A.readFileState.get(Y);
    if (J && Y.endsWith("/CLAUDE.md") && !B.some((W) => W.path === Y)) G.push({
      path: Y,
      content: J.content,
      type: "Project",
      isNested: !0
    })
  });
  let Z = [...B, ...G];
  if (Z.length === 0) return null;
  if (Q) return nW.createElement(S, {
    flexDirection: "row",
    columnGap: 1,
    flexWrap: "wrap"
  }, Z.map((Y, J) => {
    let W = Q5(Y.path),
      X = Y.isNested ? "nested" : YQ0(Y.type),
      V = J < Z.length - 1 ? "," : "";
    return nW.createElement(S, {
      key: J,
      flexDirection: "row",
      flexShrink: 0
    }, nW.createElement($, null, X, " "), nW.createElement($, {
      dimColor: !0
    }, "(", W, ")"), nW.createElement($, null, V))
  }));
  let I = new Map;
  return nW.createElement(S, {
    flexDirection: "column"
  }, Z.map((Y, J) => {
    let W = Q5(Y.path),
      X = Y.isNested ? "nested: " : `${YQ0(Y.type)}: `,
      V = Y.parent ? (I.get(Y.parent) ?? 0) + 1 : 0;
    if (I.set(Y.path, V), V === 0) return nW.createElement($, {
      key: J
    }, nW.createElement($, {
      dimColor: !0
    }, " L "), `${X}${W}`);
    else {
      let F = "  ".repeat(V - 1);
      return nW.createElement($, {
        key: J
      }, " ".repeat(X.length + 2), F, nW.createElement($, {
        dimColor: !0
      }, " L "), W)
    }
  }))
}
// @from(Start 13965506, End 13965508)
nW
// @from(Start 13965514, End 13965592)
PV9 = L(() => {
  hA();
  gE();
  R9();
  JQ0();
  vM();
  nW = BA(VA(), 1)
})
// @from(Start 13965595, End 13965625)
function jV9() {
  return []
}
// @from(Start 13965627, End 13966784)
function SV9(A, Q = null, B) {
  let G = A?.find((Z) => Z.name === "ide");
  if (Q) {
    let Z = aF(Q.ideType),
      I = oT(Q.ideType) ? "plugin" : "extension";
    if (Q.error) return [{
      label: "IDE",
      value: mQA.createElement($, null, ZB("error", B)(H1.cross), " Error installing ", Z, " ", I, ": ", Q.error, `
`, "Please restart your IDE and try again.")
    }];
    if (Q.installed)
      if (G && G.type === "connected")
        if (Q.installedVersion !== G.serverInfo?.version) return [{
          label: "IDE",
          value: `Connected to ${Z} ${I} version ${Q.installedVersion} (server version: ${G.serverInfo?.version})`
        }];
        else return [{
          label: "IDE",
          value: `Connected to ${Z} ${I} version ${Q.installedVersion}`
        }];
    else return [{
      label: "IDE",
      value: `Installed ${Z} ${I}`
    }]
  } else if (G) {
    let Z = ze1(G) ?? "IDE";
    if (G.type === "connected") return [{
      label: "IDE",
      value: `Connected to ${Z} extension`
    }];
    else return [{
      label: "IDE",
      value: `${ZB("error",B)(H1.cross)} Not connected to ${Z}`
    }]
  }
  return []
}
// @from(Start 13966786, End 13967492)
function _V9(A = [], Q) {
  let B = A.filter((G) => G.name !== "ide");
  if (!B.length) return [];
  return [{
    label: "MCP servers",
    value: mQA.createElement(S, {
      flexDirection: "row"
    }, B.map((G, Z) => {
      let I = "";
      if (G.type === "connected") I = ZB("success", Q)(H1.tick);
      else if (G.type === "pending") I = ZB("inactive", Q)(H1.radioOff);
      else if (G.type === "needs-auth") I = ZB("warning", Q)(H1.triangleUpOutline);
      else if (G.type === "failed") I = ZB("error", Q)(H1.cross);
      else I = ZB("error", Q)(H1.cross);
      let Y = Z < B.length - 1 ? "," : "";
      return mQA.createElement($, {
        key: Z
      }, G.name, " ", I, Y)
    }))
  }]
}
// @from(Start 13967494, End 13967860)
function kV9() {
  let A = M1A(),
    Q = O1A(),
    B = [];
  if (A.forEach((G) => {
      let Z = Q5(G.path);
      B.push(`Large ${Z} will impact performance (${JZ(G.content.length)} chars > ${JZ(Lh)})`)
    }), Q && Q.content.length > wYA) B.push(`CLAUDE.md entries marked as IMPORTANT exceed ${JZ(wYA)} characters (${JZ(Q.content.length)} chars)`);
  return B
}
// @from(Start 13967862, End 13968335)
function yV9() {
  return [{
    label: "Setting sources",
    value: ls().map((B) => {
      switch (B) {
        case "userSettings":
          return "User settings";
        case "projectSettings":
          return "Shared project settings";
        case "localSettings":
          return "Local";
        case "policySettings":
          return "Enterprise managed policies";
        case "flagSettings":
          return "Command line arguments"
      }
    })
  }]
}
// @from(Start 13968336, End 13968404)
async function xV9() {
  return (await gy()).map((Q) => Q.message)
}
// @from(Start 13968405, End 13969347)
async function vV9() {
  let A = await YIA(),
    Q = [],
    {
      errors: B
    } = wa();
  if (B.length > 0) {
    let Z = Array.from(new Set(B.map((I) => I.file))).join(", ");
    Q.push(`Found invalid settings files: ${Z}. They will be ignored.`)
  }
  if (A.multipleInstallations.length > 1) Q.push(`Multiple installations detected (${A.multipleInstallations.length} found)`);
  if (A.warnings.forEach((G) => {
      Q.push(G.issue)
    }), A.hasUpdatePermissions === !1) Q.push("No write permissions for auto-updates (requires sudo)");
  if (A.configInstallMethod !== "not set") {
    let Z = {
      "npm-local": "local",
      "npm-global": "global",
      native: "native",
      development: "development",
      unknown: "unknown"
    } [A.installationType];
    if (Z && Z !== A.configInstallMethod) Q.push(`Installation config mismatch: running ${A.installationType} but config says ${A.configInstallMethod}`)
  }
  return Q
}
// @from(Start 13969349, End 13969863)
function bV9() {
  let A = RiA();
  if (!A) return [];
  let Q = [];
  if (A.subscription) Q.push({
    label: "Login method",
    value: `${A.subscription} Account`
  });
  if (A.tokenSource) Q.push({
    label: "Auth token",
    value: A.tokenSource
  });
  if (A.apiKeySource) Q.push({
    label: "API key",
    value: A.apiKeySource
  });
  if (A.organization) Q.push({
    label: "Organization",
    value: A.organization
  });
  if (A.email) Q.push({
    label: "Email",
    value: A.email
  });
  return Q
}
// @from(Start 13969865, End 13972027)
function fV9() {
  let A = V6(),
    Q = [];
  if (A !== "firstParty") {
    let Z = {
      bedrock: "AWS Bedrock",
      vertex: "Google Vertex AI",
      foundry: "Microsoft Foundry"
    } [A];
    Q.push({
      label: "API provider",
      value: Z
    })
  }
  if (A === "firstParty") {
    let Z = process.env.ANTHROPIC_BASE_URL;
    if (Z) Q.push({
      label: "Anthropic base URL",
      value: Z
    })
  } else if (A === "bedrock") {
    let Z = process.env.BEDROCK_BASE_URL;
    if (Z) Q.push({
      label: "Bedrock base URL",
      value: Z
    });
    if (Q.push({
        label: "AWS region",
        value: hBA()
      }), Y0(process.env.CLAUDE_CODE_SKIP_BEDROCK_AUTH)) Q.push({
      value: "AWS auth skipped"
    })
  } else if (A === "vertex") {
    let Z = process.env.VERTEX_BASE_URL;
    if (Z) Q.push({
      label: "Vertex base URL",
      value: Z
    });
    let I = process.env.ANTHROPIC_VERTEX_PROJECT_ID;
    if (I) Q.push({
      label: "GCP project",
      value: I
    });
    if (Q.push({
        label: "Default region",
        value: ER()
      }), Y0(process.env.CLAUDE_CODE_SKIP_VERTEX_AUTH)) Q.push({
      value: "GCP auth skipped"
    })
  } else if (A === "foundry") {
    let Z = process.env.ANTHROPIC_FOUNDRY_BASE_URL;
    if (Z) Q.push({
      label: "Microsoft Foundry base URL",
      value: Z
    });
    let I = process.env.ANTHROPIC_FOUNDRY_RESOURCE;
    if (I) Q.push({
      label: "Microsoft Foundry resource",
      value: I
    });
    if (Y0(process.env.CLAUDE_CODE_SKIP_FOUNDRY_AUTH)) Q.push({
      value: "Microsoft Foundry auth skipped"
    })
  }
  let B = Sc();
  if (B) Q.push({
    label: "Proxy",
    value: B
  });
  let G = XT();
  if (process.env.NODE_EXTRA_CA_CERTS) Q.push({
    label: "Additional CA cert(s)",
    value: process.env.NODE_EXTRA_CA_CERTS
  });
  if (G) {
    if (G.cert && process.env.CLAUDE_CODE_CLIENT_CERT) Q.push({
      label: "mTLS client cert",
      value: process.env.CLAUDE_CODE_CLIENT_CERT
    });
    if (G.key && process.env.CLAUDE_CODE_CLIENT_KEY) Q.push({
      label: "mTLS client key",
      value: process.env.CLAUDE_CODE_CLIENT_KEY
    })
  }
  return Q
}
// @from(Start 13972029, End 13972216)
function hV9(A) {
  let Q = YM(A);
  if (A === null && BB()) {
    let B = pnA();
    if (pw()) Q = `${tA.bold("Default")} ${B}`;
    else Q = `${tA.bold("Sonnet")} ${B}`
  }
  return Q
}
// @from(Start 13972221, End 13972224)
mQA
// @from(Start 13972230, End 13972413)
gV9 = L(() => {
  hA();
  uy();
  gB();
  nY();
  gE();
  R9();
  lK();
  t2();
  F9();
  Zh();
  hQ();
  _c();
  v3A();
  MB();
  $J();
  V9();
  gB();
  LV();
  mQA = BA(VA(), 1)
})
// @from(Start 13972416, End 13972915)
function My3() {
  return [{
    label: "Version",
    value: {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION
  }, {
    label: "Session ID",
    value: e1()
  }, {
    label: "cwd",
    value: W0()
  }, ...bV9(), ...fV9()]
}
// @from(Start 13972917, End 13973255)
function Oy3({
  appState: A,
  theme: Q,
  context: B
}) {
  return [{
    label: "Model",
    value: hV9(A.mainLoopModel)
  }, ...SV9(A.mcp.clients, B.options.ideInstallationStatus, Q), ..._V9(A.mcp.clients, Q), {
    label: "Memory",
    value: f6.createElement(TV9, {
      context: B,
      flat: !0
    })
  }, ...jV9(), ...yV9()]
}
// @from(Start 13973256, End 13973351)
async function Ry3() {
  return [...await nTA() ? await xV9() : [], ...await vV9(), ...kV9()]
}
// @from(Start 13973353, End 13973689)
function Ty3({
  value: A
}) {
  if (Array.isArray(A)) return f6.createElement(S, {
    flexWrap: "wrap",
    columnGap: 1,
    flexShrink: 99
  }, A.map((Q, B) => {
    return f6.createElement($, {
      key: B
    }, Q, B < A.length - 1 ? "," : "")
  }));
  if (typeof A === "string") return f6.createElement($, null, A);
  return A
}
// @from(Start 13973691, End 13975053)
function uV9({
  context: A
}) {
  let [Q] = OQ(), [B, G] = f6.useState([]), [Z, I] = f6.useState([]), Y = A.options.ideInstallationStatus, [J] = qB();
  return f6.useEffect(() => {
    async function W() {
      let X = [My3(), Oy3({
          appState: Q,
          theme: J,
          context: A
        })],
        V = await Ry3();
      G(X), I(V)
    }
    W()
  }, [Q, J, Y, A]), f6.createElement(S, {
    flexDirection: "column"
  }, f6.createElement(S, {
    flexDirection: "column",
    gap: 1,
    marginTop: 1
  }, B.map((W, X) => W.length > 0 && f6.createElement(S, {
    key: X,
    flexDirection: "column"
  }, W.map(({
    label: V,
    value: F
  }, K) => f6.createElement(S, {
    key: K,
    flexDirection: "row",
    gap: 1,
    flexShrink: 0
  }, V !== void 0 && f6.createElement($, {
    bold: !0
  }, V, ":"), f6.createElement(Ty3, {
    value: F
  }))))), Z.length > 0 && f6.createElement(S, {
    flexDirection: "column",
    paddingBottom: 1
  }, f6.createElement($, {
    bold: !0
  }, "System Diagnostics"), Z.map((W, X) => f6.createElement(S, {
    key: X,
    flexDirection: "row",
    gap: 1,
    paddingX: 1
  }, f6.createElement($, {
    color: "error"
  }, H1.warning), typeof W === "string" ? f6.createElement($, {
    wrap: "wrap"
  }, W) : W)))), f6.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Esc to exit"))
}
// @from(Start 13975058, End 13975060)
f6
// @from(Start 13975066, End 13975169)
mV9 = L(() => {
  hA();
  V9();
  z9();
  _0();
  PV9();
  uy();
  gV9();
  U2();
  f6 = BA(VA(), 1)
})
// @from(Start 13975172, End 13977753)
function bY1({
  onThemeSelect: A,
  showIntroText: Q = !1,
  helpText: B = "",
  showHelpTextBelow: G = !1,
  hideEscToCancel: Z = !1,
  skipExitHandling: I = !1
}) {
  let [Y] = qB(), {
    setPreviewTheme: J,
    savePreview: W
  } = tg1(), X = EQ(I ? () => {} : void 0), F = m4.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, m4.createElement(S, {
    flexDirection: "column",
    gap: 1,
    marginX: 1
  }, Q ? m4.createElement($, null, "Let's get started.") : m4.createElement($, {
    bold: !0,
    color: "permission"
  }, "Theme"), m4.createElement(S, {
    flexDirection: "column"
  }, m4.createElement($, {
    bold: !0
  }, "Choose the text style that looks best with your terminal"), B && !G && m4.createElement($, {
    dimColor: !0
  }, B)), m4.createElement(M0, {
    options: [{
      label: "Dark mode",
      value: "dark"
    }, {
      label: "Light mode",
      value: "light"
    }, {
      label: "Dark mode (colorblind-friendly)",
      value: "dark-daltonized"
    }, {
      label: "Light mode (colorblind-friendly)",
      value: "light-daltonized"
    }, {
      label: "Dark mode (ANSI colors only)",
      value: "dark-ansi"
    }, {
      label: "Light mode (ANSI colors only)",
      value: "light-ansi"
    }],
    onFocus: (K) => {
      J(K)
    },
    onChange: (K) => {
      W(), A(K)
    },
    onCancel: I ? () => {
      W()
    } : async () => {
      W(), await v6(0)
    },
    visibleOptionCount: 6,
    defaultValue: Y
  })), m4.createElement(S, {
    flexDirection: "column",
    width: "100%",
    marginBottom: 1,
    borderTop: !0,
    borderBottom: !0,
    borderLeft: !1,
    borderRight: !1,
    borderStyle: "dashed",
    borderColor: "subtle",
    borderDimColor: !0
  }, m4.createElement(J$, {
    patch: {
      oldStart: 1,
      newStart: 1,
      oldLines: 3,
      newLines: 3,
      lines: [" function greet() {", '-  console.log("Hello, World!");', '+  console.log("Hello, Claude!");', " }"]
    },
    dim: !1,
    filePath: "demo.js",
    skipHighlighting: !0
  })));
  if (!Q) return m4.createElement(m4.Fragment, null, m4.createElement(S, {
    flexDirection: "column"
  }, F), m4.createElement(S, {
    marginX: 1
  }, G && B && m4.createElement(S, {
    marginLeft: 3,
    marginTop: 1
  }, m4.createElement($, {
    dimColor: !0
  }, B)), !Z && m4.createElement(S, {
    marginLeft: 3
  }, m4.createElement($, {
    dimColor: !0
  }, X.pending ? m4.createElement(m4.Fragment, null, "Press ", X.keyName, " again to exit") : m4.createElement(m4.Fragment, null, "Esc to cancel")))));
  return F
}
// @from(Start 13977758, End 13977760)
m4
// @from(Start 13977766, End 13977851)
mV0 = L(() => {
  hA();
  J5();
  En();
  Q4();
  kW();
  hA();
  m4 = BA(VA(), 1)
})
// @from(Start 13977854, End 13980386)
function hY1({
  initial: A,
  sessionModel: Q,
  onSelect: B,
  isStandaloneCommand: G
}) {
  let Z = A === null ? dV0 : A,
    [I, Y] = fY1.useState(Z),
    J = fY1.useMemo(() => lnA(), []),
    W = EQ(),
    X = t6(),
    V = BB() && f4() === "pro",
    F = X?.hasExtraUsageEnabled === !0,
    K = 10,
    D = Math.min(10, J.length),
    H = Math.max(0, J.length - D);
  return V4.createElement(S, {
    flexDirection: "column",
    width: "100%"
  }, G && V4.createElement(D3, {
    dividerColor: "permission"
  }), V4.createElement(S, {
    flexDirection: "column",
    paddingX: G ? 1 : 0
  }, V4.createElement(S, {
    flexDirection: "column"
  }, V4.createElement(S, {
    marginBottom: 1,
    flexDirection: "column"
  }, V4.createElement($, {
    color: "remember",
    bold: !0
  }, "Select model"), V4.createElement($, {
    dimColor: !0
  }, "Switch between Claude models. Applies to this session and future Claude Code sessions. For other/previous model names, specify with --model.")), Q && V4.createElement(S, {
    marginBottom: 1,
    flexDirection: "column"
  }, V4.createElement($, {
    dimColor: !0
  }, "Currently using ", YM(Q), " for this session (set by plan mode). Selecting a model will undo this.")), V4.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, V4.createElement(S, {
    flexDirection: "column"
  }, V4.createElement(M0, {
    defaultValue: I,
    focusValue: J.some((C) => C.value === I) ? I : J[0]?.value ?? void 0,
    options: J.map((C) => ({
      ...C,
      value: C.value === null ? dV0 : C.value
    })),
    onFocus: (C) => Y(C),
    onChange: (C) => B(C === dV0 ? null : C),
    onCancel: () => {},
    visibleOptionCount: D
  })), H > 0 && V4.createElement(S, {
    paddingLeft: 3
  }, V4.createElement($, {
    dimColor: !0
  }, "and ", H, " more…"))), V && o2("tengu_backstage_only") && V4.createElement(S, {
    marginBottom: 1,
    flexDirection: "column"
  }, F ? V4.createElement($, {
    dimColor: !0
  }, "You now have access to Opus 4.5 by paying with your extra usage") : V4.createElement($, {
    dimColor: !0
  }, "Want Opus 4.5? Run ", V4.createElement($, {
    color: "remember"
  }, "/upgrade"), " to get the Max plan or ", V4.createElement($, {
    color: "remember"
  }, "/extra-usage"), " ", "to pay per use"))), G && V4.createElement($, {
    dimColor: !0,
    italic: !0
  }, W.pending ? V4.createElement(V4.Fragment, null, "Press ", W.keyName, " again to exit") : V4.createElement(V4.Fragment, null, "Enter to confirm · Esc to exit"))))
}
// @from(Start 13980391, End 13980393)
V4
// @from(Start 13980395, End 13980398)
fY1
// @from(Start 13980400, End 13980425)
dV0 = "__NO_PREFERENCE__"
// @from(Start 13980431, End 13980543)
cV0 = L(() => {
  hA();
  t2();
  J5();
  Q4();
  gB();
  BK();
  u2();
  V4 = BA(VA(), 1), fY1 = BA(VA(), 1)
})
// @from(Start 13980546, End 13982690)
function gY1({
  onDone: A,
  isStandaloneDialog: Q
}) {
  MC.default.useEffect(() => {
    GA("tengu_claude_md_includes_dialog_shown", {})
  }, []);

  function B(Z) {
    let I = j5();
    if (Z === "no") GA("tengu_claude_md_external_includes_dialog_declined", {}), AY({
      ...I,
      hasClaudeMdExternalIncludesApproved: !1,
      hasClaudeMdExternalIncludesWarningShown: !0
    });
    else GA("tengu_claude_md_external_includes_dialog_accepted", {}), AY({
      ...I,
      hasClaudeMdExternalIncludesApproved: !0,
      hasClaudeMdExternalIncludesWarningShown: !0
    });
    A()
  }
  let G = EQ();
  return f1((Z, I) => {
    if (I.escape) {
      B("no");
      return
    }
  }), MC.default.createElement(MC.default.Fragment, null, MC.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    paddingX: Q ? 1 : 0,
    marginBottom: 1,
    borderStyle: Q ? "round" : void 0,
    borderTop: Q,
    borderLeft: !1,
    borderRight: !1,
    borderBottom: !1,
    borderColor: "warning"
  }, MC.default.createElement($, {
    bold: !0,
    color: "warning"
  }, "Allow external CLAUDE.md file imports?"), MC.default.createElement($, null, "This project's CLAUDE.md imports files outside the current working directory. Never allow this for third-party repositories."), MC.default.createElement($, {
    dimColor: !0
  }, "Important: Only use Claude Code with files you trust. Accessing untrusted files may pose security risks", " ", MC.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/security"
  }), " "), MC.default.createElement(M0, {
    options: [{
      label: "Yes, allow external imports",
      value: "yes"
    }, {
      label: "No, disable external imports",
      value: "no"
    }],
    onChange: (Z) => B(Z),
    onCancel: () => B("no")
  })), Q && MC.default.createElement(S, {
    marginLeft: 1
  }, MC.default.createElement($, {
    dimColor: !0,
    italic: !0
  }, G.pending ? MC.default.createElement(MC.default.Fragment, null, "Press ", G.keyName, " again to exit") : MC.default.createElement(MC.default.Fragment, null, "Enter to confirm · Esc to disable external includes"))))
}
// @from(Start 13982695, End 13982697)
MC
// @from(Start 13982703, End 13982788)
pV0 = L(() => {
  hA();
  J5();
  jQ();
  q0();
  Q4();
  hA();
  MC = BA(VA(), 1)
})
// @from(Start 13982791, End 13982942)
function dV9(A) {
  return Object.entries(A).map(([Q, B]) => ({
    label: B?.name ?? Py3,
    value: Q,
    description: B?.description ?? jy3
  }))
}
// @from(Start 13982944, End 13983897)
function uY1({
  initialStyle: A,
  onComplete: Q,
  onCancel: B,
  isStandaloneCommand: G
}) {
  let [Z, I] = dQA.useState([]), [Y, J] = dQA.useState(!0);
  dQA.useEffect(() => {
    cQA().then((X) => {
      let V = dV9(X);
      I(V), J(!1)
    }).catch(() => {
      let X = dV9(TQA);
      I(X), J(!1)
    })
  }, []);
  let W = dQA.useCallback((X) => {
    Q(X)
  }, [Q]);
  return IN.createElement(hD, {
    title: "Preferred output style",
    onCancel: B,
    borderDimColor: !0,
    hideInputGuide: !G,
    hideBorder: !G
  }, IN.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, IN.createElement(S, {
    marginTop: 1
  }, IN.createElement($, {
    dimColor: !0
  }, "This changes how Claude Code communicates with you")), Y ? IN.createElement($, {
    dimColor: !0
  }, "Loading output styles…") : IN.createElement(M0, {
    options: Z,
    onChange: W,
    onCancel: B,
    visibleOptionCount: 10,
    defaultValue: A
  })))
}
// @from(Start 13983902, End 13983904)
IN
// @from(Start 13983906, End 13983909)
dQA
// @from(Start 13983911, End 13983926)
Py3 = "Default"
// @from(Start 13983930, End 13984010)
jy3 = "Claude completes coding tasks efficiently and provides concise responses"
// @from(Start 13984016, End 13984104)
lV0 = L(() => {
  hA();
  S5();
  Gx();
  Mi();
  IN = BA(VA(), 1), dQA = BA(VA(), 1)
})
// @from(Start 13984107, End 13998643)
function cV9({
  onClose: A,
  context: Q,
  setTabsHidden: B,
  setIsWarning: G,
  setHideMargin: Z
}) {
  let [I, Y] = qB(), [J, W] = pQA.useState(N1()), X = vQ.useRef(N1()), [V, F] = pQA.useState(l0()), [K, D] = pQA.useState(V?.outputStyle || wK), H = vQ.useRef(K), [C, E] = pQA.useState(0), [{
    mainLoopModel: U,
    verbose: q
  }, w] = OQ(), [N, R] = pQA.useState({}), [T, y] = pQA.useState(null), v = SQ1(Q.options.mcpClients), x = !Y0(process.env.CLAUDE_CODE_DISABLE_FILE_CHECKPOINTING), p = b00();
  async function u(k) {
    GA("tengu_config_model_changed", {
      from_model: U,
      to_model: k
    }), w((o) => ({
      ...o,
      mainLoopModel: k
    })), R((o) => {
      let IA = YM(k);
      if ("model" in o) {
        let {
          model: FA,
          ...zA
        } = o;
        return {
          ...zA,
          model: IA
        }
      }
      return {
        ...o,
        model: IA
      }
    })
  }

  function e(k) {
    let m = {
      ...N1(),
      verbose: k
    };
    c0(m), W(m), w((o) => ({
      ...o,
      verbose: k
    })), R((o) => {
      if ("verbose" in o) {
        let {
          verbose: IA,
          ...FA
        } = o;
        return FA
      }
      return {
        ...o,
        verbose: k
      }
    })
  }
  let l = [{
    id: "autoCompactEnabled",
    label: "Auto-compact",
    value: J.autoCompactEnabled,
    type: "boolean",
    onChange(k) {
      let m = {
        ...N1(),
        autoCompactEnabled: k
      };
      c0(m), W(m), GA("tengu_auto_compact_setting_changed", {
        enabled: k
      })
    }
  }, {
    id: "spinnerTipsEnabled",
    label: "Show tips",
    value: V?.spinnerTipsEnabled ?? !0,
    type: "boolean",
    onChange(k) {
      cB("localSettings", {
        spinnerTipsEnabled: k
      }), F((m) => ({
        ...m,
        spinnerTipsEnabled: k
      })), GA("tengu_tips_setting_changed", {
        enabled: k
      })
    }
  }, ...x ? [{
    id: "fileCheckpointingEnabled",
    label: "Rewind code (checkpoints)",
    value: J.fileCheckpointingEnabled,
    type: "boolean",
    onChange(k) {
      let m = {
        ...N1(),
        fileCheckpointingEnabled: k
      };
      c0(m), W(m), GA("tengu_file_history_snapshots_setting_changed", {
        enabled: k
      })
    }
  }] : [], {
    id: "verbose",
    label: "Verbose output",
    value: q,
    type: "boolean",
    onChange: e
  }, {
    id: "terminalProgressBarEnabled",
    label: "Terminal progress bar",
    value: J.terminalProgressBarEnabled,
    type: "boolean",
    onChange(k) {
      let m = {
        ...N1(),
        terminalProgressBarEnabled: k
      };
      c0(m), W(m), GA("tengu_terminal_progress_bar_setting_changed", {
        enabled: k
      })
    }
  }, {
    id: "defaultPermissionMode",
    label: "Default permission mode",
    value: V?.permissions?.defaultMode || "default",
    options: (() => {
      let k = ["default", "plan"],
        m = ["bypassPermissions"];
      return [...k, ...kR.filter((o) => !k.includes(o) && !m.includes(o))]
    })(),
    type: "enum",
    onChange(k) {
      let m = nxA(k),
        o = cB("userSettings", {
          permissions: {
            ...V?.permissions,
            defaultMode: m
          }
        });
      if (o.error) {
        AA(o.error);
        return
      }
      F((IA) => ({
        ...IA,
        permissions: {
          ...IA?.permissions,
          defaultMode: m
        }
      })), R((IA) => ({
        ...IA,
        defaultPermissionMode: k
      })), GA("tengu_config_changed", {
        setting: "defaultPermissionMode",
        value: k
      })
    }
  }, {
    id: "respectGitignore",
    label: "Respect .gitignore in file picker",
    value: J.respectGitignore,
    type: "boolean",
    onChange(k) {
      let m = {
        ...N1(),
        respectGitignore: k
      };
      c0(m), W(m), GA("tengu_respect_gitignore_setting_changed", {
        enabled: k
      })
    }
  }, {
    id: "theme",
    label: "Theme",
    value: I,
    type: "managedEnum",
    onChange: Y
  }, {
    id: "notifChannel",
    label: "Notifications",
    value: J.preferredNotifChannel,
    options: ["auto", "iterm2", "terminal_bell", "iterm2_with_bell", "kitty", "ghostty", "notifications_disabled"],
    type: "enum",
    onChange(k) {
      let m = {
        ...N1(),
        preferredNotifChannel: k
      };
      c0(m), W(m)
    }
  }, {
    id: "outputStyle",
    label: "Output style",
    value: K,
    type: "managedEnum",
    onChange: () => {}
  }, {
    id: "editorMode",
    label: "Editor mode",
    value: J.editorMode === "emacs" ? "normal" : J.editorMode || "normal",
    options: ["normal", "vim"],
    type: "enum",
    onChange(k) {
      let m = {
        ...N1(),
        editorMode: k
      };
      c0(m), W(m), GA("tengu_editor_mode_changed", {
        mode: k,
        source: "config_panel"
      })
    }
  }, {
    id: "model",
    label: "Model",
    value: U === null ? "Default (recommended)" : U,
    type: "managedEnum",
    onChange: u
  }, ...v ? [{
    id: "diffTool",
    label: "Diff tool",
    value: J.diffTool ?? "auto",
    options: ["terminal", "auto"],
    type: "enum",
    onChange(k) {
      let m = {
        ...N1(),
        diffTool: k
      };
      c0(m), W(m), GA("tengu_diff_tool_changed", {
        tool: k,
        source: "config_panel"
      })
    }
  }] : [], ...!bV() ? [{
    id: "autoConnectIde",
    label: "Auto-connect to IDE (external terminal)",
    value: J.autoConnectIde ?? !1,
    type: "boolean",
    onChange(k) {
      let m = {
        ...N1(),
        autoConnectIde: k
      };
      c0(m), W(m), GA("tengu_auto_connect_ide_changed", {
        enabled: k,
        source: "config_panel"
      })
    }
  }] : [], ...bV() ? [{
    id: "autoInstallIdeExtension",
    label: "Auto-install IDE extension",
    value: J.autoInstallIdeExtension ?? !0,
    type: "boolean",
    onChange(k) {
      let m = {
        ...N1(),
        autoInstallIdeExtension: k
      };
      c0(m), W(m), GA("tengu_auto_install_ide_extension_changed", {
        enabled: k,
        source: "config_panel"
      })
    }
  }] : [], ...p ? [{
    id: "showExternalIncludesDialog",
    label: "External CLAUDE.md includes",
    value: (() => {
      if (j5().hasClaudeMdExternalIncludesApproved) return "true";
      else return "false"
    })(),
    type: "managedEnum",
    onChange() {}
  }] : [], ...process.env.ANTHROPIC_API_KEY ? [{
    id: "apiKey",
    label: `Use custom API key: ${tA.bold(dw(process.env.ANTHROPIC_API_KEY))}`,
    value: Boolean(process.env.ANTHROPIC_API_KEY && J.customApiKeyResponses?.approved?.includes(dw(process.env.ANTHROPIC_API_KEY))),
    type: "boolean",
    onChange(k) {
      let m = {
        ...N1()
      };
      if (!m.customApiKeyResponses) m.customApiKeyResponses = {
        approved: [],
        rejected: []
      };
      if (!m.customApiKeyResponses.approved) m.customApiKeyResponses.approved = [];
      if (!m.customApiKeyResponses.rejected) m.customApiKeyResponses.rejected = [];
      if (process.env.ANTHROPIC_API_KEY) {
        let o = dw(process.env.ANTHROPIC_API_KEY);
        if (k) m.customApiKeyResponses.approved = [...m.customApiKeyResponses.approved.filter((IA) => IA !== o), o], m.customApiKeyResponses.rejected = m.customApiKeyResponses.rejected.filter((IA) => IA !== o);
        else m.customApiKeyResponses.approved = m.customApiKeyResponses.approved.filter((IA) => IA !== o), m.customApiKeyResponses.rejected = [...m.customApiKeyResponses.rejected.filter((IA) => IA !== o), o]
      }
      c0(m), W(m)
    }
  }] : []];
  return f1((k, m) => {
    if (m.escape) {
      if (T !== null) {
        B(!1), G(!1), Z(!1), y(null);
        return
      }
      let IA = Object.entries(N).map(([NA, OA]) => {
          return GA("tengu_config_changed", {
            key: NA,
            value: OA
          }), `Set ${NA} to ${tA.bold(OA)}`
        }),
        FA = Boolean(process.env.ANTHROPIC_API_KEY && X.current.customApiKeyResponses?.approved?.includes(dw(process.env.ANTHROPIC_API_KEY))),
        zA = Boolean(process.env.ANTHROPIC_API_KEY && J.customApiKeyResponses?.approved?.includes(dw(process.env.ANTHROPIC_API_KEY)));
      if (FA !== zA) IA.push(`${zA?"Enabled":"Disabled"} custom API key`), GA("tengu_config_changed", {
        key: "env.ANTHROPIC_API_KEY",
        value: zA
      });
      if (J.theme !== X.current.theme) IA.push(`Set theme to ${tA.bold(J.theme)}`);
      if (J.preferredNotifChannel !== X.current.preferredNotifChannel) IA.push(`Set notifications to ${tA.bold(J.preferredNotifChannel)}`);
      if (K !== H.current) IA.push(`Set output style to ${tA.bold(K)}`);
      if (J.editorMode !== X.current.editorMode) IA.push(`Set editor mode to ${tA.bold(J.editorMode||"emacs")}`);
      if (J.diffTool !== X.current.diffTool) IA.push(`Set diff tool to ${tA.bold(J.diffTool)}`);
      if (J.autoConnectIde !== X.current.autoConnectIde) IA.push(`${J.autoConnectIde?"Enabled":"Disabled"} auto-connect to IDE`);
      if (J.autoInstallIdeExtension !== X.current.autoInstallIdeExtension) IA.push(`${J.autoInstallIdeExtension?"Enabled":"Disabled"} auto-install IDE extension`);
      if (J.autoCompactEnabled !== X.current.autoCompactEnabled) IA.push(`${J.autoCompactEnabled?"Enabled":"Disabled"} auto-compact`);
      if (J.respectGitignore !== X.current.respectGitignore) IA.push(`${J.respectGitignore?"Enabled":"Disabled"} respect .gitignore in file picker`);
      if (J.terminalProgressBarEnabled !== X.current.terminalProgressBarEnabled) IA.push(`${J.terminalProgressBarEnabled?"Enabled":"Disabled"} terminal progress bar`);
      if (IA.length > 0) A(IA.join(`
`));
      else A("Config dialog dismissed", {
        display: "system"
      });
      return
    }
    if (T !== null) return;

    function o() {
      let IA = l[C];
      if (!IA || !IA.onChange) return;
      if (IA.type === "boolean") {
        IA.onChange(!IA.value);
        return
      }
      if (IA.id === "theme" && m.return) {
        y(0), B(!0), Z(!0);
        return
      }
      if (IA.id === "model" && m.return) {
        y(1), B(!0);
        return
      }
      if (IA.id === "showExternalIncludesDialog" && m.return) {
        y(2), B(!0), G(!0);
        return
      }
      if (IA.id === "outputStyle" && m.return) {
        y(3), B(!0);
        return
      }
      if (IA.type === "enum") {
        let zA = (IA.options.indexOf(IA.value) + 1) % IA.options.length;
        IA.onChange(IA.options[zA]);
        return
      }
    }
    if (m.return || k === " ") {
      o();
      return
    }
    if (m.upArrow) E((IA) => Math.max(0, IA - 1));
    if (m.downArrow) E((IA) => Math.min(l.length - 1, IA + 1))
  }), vQ.createElement(S, {
    flexDirection: "column",
    width: "100%"
  }, T === 0 ? vQ.createElement(vQ.Fragment, null, vQ.createElement(bY1, {
    initialTheme: I,
    onThemeSelect: (k) => {
      Y(k), y(null), Z(!1), B(!1)
    },
    hideEscToCancel: !0,
    skipExitHandling: !0
  }), vQ.createElement(S, {
    marginLeft: 1
  }, vQ.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Esc to exit"))) : T === 1 ? vQ.createElement(vQ.Fragment, null, vQ.createElement(hY1, {
    initial: U,
    onSelect: (k) => {
      u(k), y(null), B(!1)
    }
  }), vQ.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Enter to confirm · Esc to exit")) : T === 2 ? vQ.createElement(vQ.Fragment, null, vQ.createElement(gY1, {
    onDone: () => {
      y(null), B(!1), G(!1)
    }
  }), vQ.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Enter to confirm · Esc to disable external includes")) : T === 3 ? vQ.createElement(vQ.Fragment, null, vQ.createElement(uY1, {
    initialStyle: K,
    onComplete: (k) => {
      D(k ?? wK), y(null), B(!1), cB("localSettings", {
        outputStyle: k
      }), GA("tengu_output_style_changed", {
        style: k ?? wK,
        source: "config_panel",
        settings_source: "localSettings"
      })
    },
    onCancel: () => {
      y(null), B(!1)
    }
  }), vQ.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Enter to confirm · Esc to exit")) : vQ.createElement(S, {
    flexDirection: "column",
    marginY: 1,
    gap: 1
  }, vQ.createElement($, null, "Configure Claude Code preferences"), vQ.createElement(S, {
    flexDirection: "column"
  }, l.map((k, m) => {
    let o = m === C;
    return vQ.createElement(S, {
      key: k.id
    }, vQ.createElement(S, {
      width: 44
    }, vQ.createElement($, {
      color: o ? "suggestion" : void 0
    }, o ? H1.pointer : " ", " ", k.label)), vQ.createElement(S, null, k.type === "boolean" ? vQ.createElement($, {
      color: o ? "suggestion" : void 0
    }, k.value.toString()) : k.id === "theme" ? vQ.createElement($, {
      color: o ? "suggestion" : void 0
    }, (() => {
      return {
        dark: "Dark mode",
        light: "Light mode",
        "dark-daltonized": "Dark mode (colorblind-friendly)",
        "light-daltonized": "Light mode (colorblind-friendly)",
        "dark-ansi": "Dark mode (ANSI colors only)",
        "light-ansi": "Light mode (ANSI colors only)"
      } [k.value.toString()] || k.value.toString()
    })()) : k.id === "notifChannel" ? vQ.createElement($, {
      color: o ? "suggestion" : void 0
    }, (() => {
      switch (k.value.toString()) {
        case "auto":
          return "Auto";
        case "iterm2":
          return vQ.createElement(vQ.Fragment, null, "iTerm2 ", vQ.createElement($, {
            dimColor: !0
          }, "(OSC 9)"));
        case "terminal_bell":
          return vQ.createElement(vQ.Fragment, null, "Terminal Bell ", vQ.createElement($, {
            dimColor: !0
          }, "(\\a)"));
        case "kitty":
          return vQ.createElement(vQ.Fragment, null, "Kitty ", vQ.createElement($, {
            dimColor: !0
          }, "(OSC 99)"));
        case "ghostty":
          return vQ.createElement(vQ.Fragment, null, "Ghostty ", vQ.createElement($, {
            dimColor: !0
          }, "(OSC 777)"));
        case "iterm2_with_bell":
          return "iTerm2 w/ Bell";
        case "notifications_disabled":
          return "Disabled";
        default:
          return k.value.toString()
      }
    })()) : k.id === "defaultPermissionMode" ? vQ.createElement($, {
      color: o ? "suggestion" : void 0
    }, Fv(k.value)) : vQ.createElement($, {
      color: o ? "suggestion" : void 0
    }, k.value.toString())))
  })), vQ.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Enter/Space to change · Esc to exit")))
}
// @from(Start 13998648, End 13998650)
vQ
// @from(Start 13998652, End 13998655)
pQA
// @from(Start 13998661, End 13998882)
pV9 = L(() => {
  hA();
  V9();
  jQ();
  vzA();
  jQ();
  F9();
  Zw();
  g1();
  q0();
  mV0();
  z9();
  cV0();
  t2();
  pV0();
  lV0();
  gE();
  nY();
  MB();
  Gx();
  hQ();
  vQ = BA(VA(), 1), pQA = BA(VA(), 1)
})
// @from(Start 13998884, End 13999286)
async function iV0() {
  if (!BB()) return {};
  let A = M6();
  if (A && Ad(A.expiresAt)) return null;
  let Q = DI();
  if (Q.error) throw Error(`Auth error: ${Q.error}`);
  let B = {
      "Content-Type": "application/json",
      "User-Agent": TV(),
      ...Q.headers
    },
    G = `${e9().BASE_API_URL}/api/oauth/usage`;
  return (await YQ.get(G, {
    headers: B,
    timeout: 5000
  })).data
}
// @from(Start 13999291, End 13999348)
nV0 = L(() => {
  O3();
  AE();
  NX();
  gB();
  AL()
})
// @from(Start 13999351, End 13999792)
function aV0({
  ratio: A,
  width: Q,
  fillColor: B,
  emptyColor: G
}) {
  let Z = Math.min(1, Math.max(0, A)),
    I = Math.floor(Z * Q),
    Y = [KSA[KSA.length - 1].repeat(I)];
  if (I < Q) {
    let J = Z * Q - I,
      W = Math.floor(J * KSA.length);
    Y.push(KSA[W]);
    let X = Q - I - 1;
    if (X > 0) Y.push(KSA[0].repeat(X))
  }
  return lV9.default.createElement($, {
    color: B,
    backgroundColor: G
  }, Y.join(""))
}
// @from(Start 13999797, End 13999800)
lV9
// @from(Start 13999802, End 13999805)
KSA
// @from(Start 13999811, End 13999910)
iV9 = L(() => {
  hA();
  lV9 = BA(VA(), 1), KSA = [" ", "▏", "▎", "▍", "▌", "▋", "▊", "▉", "█"]
})
// @from(Start 13999913, End 14001091)
function nV9({
  title: A,
  limit: Q,
  maxWidth: B,
  showTimeInReset: G = !0,
  extraSubtext: Z
}) {
  let {
    utilization: I,
    resets_at: Y
  } = Q;
  if (I === null) return null;
  let J = `${Math.floor(I)}% used`,
    W;
  if (Y) W = `Resets ${J8B(Y,!0,G)}`;
  if (Z)
    if (W) W = `${Z} · ${W}`;
    else W = Z;
  let X = 50;
  if (B >= X + 12) return VB.createElement(S, {
    flexDirection: "column"
  }, VB.createElement($, {
    bold: !0
  }, A), VB.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, VB.createElement(aV0, {
    ratio: I / 100,
    width: X,
    fillColor: "rate_limit_fill",
    emptyColor: "rate_limit_empty"
  }), VB.createElement($, null, J)), W && VB.createElement($, {
    dimColor: !0
  }, W));
  else return VB.createElement(S, {
    flexDirection: "column"
  }, VB.createElement($, null, VB.createElement($, {
    bold: !0
  }, A), W && VB.createElement(VB.Fragment, null, VB.createElement($, null, " "), VB.createElement($, {
    dimColor: !0
  }, "· ", W))), VB.createElement(aV0, {
    ratio: I / 100,
    width: B,
    fillColor: "rate_limit_fill",
    emptyColor: "rate_limit_empty"
  }), VB.createElement($, null, J))
}
// @from(Start 14001093, End 14003008)
function aV9() {
  let [A, Q] = EVA.useState(null), [B, G] = EVA.useState(null), [Z, I] = EVA.useState(!0), {
    columns: Y
  } = WB(), J = Y - 2, W = Math.min(J, 80), X = VB.useCallback(async () => {
    I(!0), G(null);
    try {
      let F = await iV0();
      Q(F)
    } catch (F) {
      AA(F);
      let K = F,
        D = K.response?.data ? JSON.stringify(K.response.data) : void 0;
      G(D ? `Failed to load usage data: ${D}` : "Failed to load usage data")
    } finally {
      I(!1)
    }
  }, []);
  if (EVA.useEffect(() => {
      X()
    }, [X]), f1((F) => {
      if (F === "r" && B && !Z) X()
    }), B) return VB.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1
  }, VB.createElement($, {
    color: "error"
  }, "Error: ", B), VB.createElement($, {
    dimColor: !0,
    italic: !0
  }, "r to retry · Esc to exit"));
  if (!A) return VB.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1
  }, VB.createElement($, {
    dimColor: !0
  }, "Loading usage data…"), VB.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Esc to exit"));
  let V = [{
    title: "Current session",
    limit: A.five_hour
  }, {
    title: "Current week (all models)",
    limit: A.seven_day
  }, {
    title: "Current week (Sonnet only)",
    limit: A.seven_day_sonnet
  }];
  return VB.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1,
    width: "100%"
  }, V.some(({
    limit: F
  }) => F) || VB.createElement($, {
    dimColor: !0
  }, "/usage is only available for subscription plans."), V.map(({
    title: F,
    limit: K
  }) => K && VB.createElement(nV9, {
    key: F,
    title: F,
    limit: K,
    maxWidth: W
  })), A.extra_usage && VB.createElement(Sy3, {
    extraUsage: A.extra_usage,
    maxWidth: W
  }), VB.createElement(_y3, null), VB.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Esc to exit"))
}
// @from(Start 14003010, End 14004148)
function Sy3({
  extraUsage: A,
  maxWidth: Q
}) {
  if (!o2("tengu_show_extra_usage_bar")) return;
  let B = f4();
  if (!(B === "pro" || B === "max")) return !1;
  if (!A.is_enabled) {
    if (jW0() !== "control" && Yx.isEnabled()) return VB.createElement(S, {
      flexDirection: "column"
    }, VB.createElement($, {
      bold: !0
    }, sV0), VB.createElement($, {
      dimColor: !0
    }, "Extra usage not enabled • /extra-usage to enable"));
    return null
  }
  if (A.monthly_limit === null) return VB.createElement(S, {
    flexDirection: "column"
  }, VB.createElement($, {
    bold: !0
  }, sV0), VB.createElement($, {
    dimColor: !0
  }, "Unlimited"));
  if (typeof A.used_credits !== "number" || typeof A.utilization !== "number") return null;
  let Z = dzA(A.used_credits / 100, 2),
    I = dzA(A.monthly_limit / 100, 2),
    Y = new Date,
    J = new Date(Y.getFullYear(), Y.getMonth() + 1, 1);
  return VB.createElement(nV9, {
    title: sV0,
    limit: {
      utilization: A.utilization,
      resets_at: J.toISOString()
    },
    showTimeInReset: !1,
    extraSubtext: `${Z} / ${I} spent`,
    maxWidth: Q
  })
}
// @from(Start 14004150, End 14005157)
function _y3() {
  let A = f4();
  if (!A) return null;
  let Q = null;
  if (A === "pro" && o2("tengu_backstage_only")) Q = "Pro users can now use /extra-usage for access to Opus 4.5 in Claude Code. Opus models are still included with your plan on claude.ai";
  else if (A === "enterprise") Q = "We've removed the Opus cap so you can use Opus 4.5 up to your overall limit. We may continue to adjust limits as we learn how usage patterns evolve over time.";
  else if (A === "max" || A === "team") Q = "We've increased your limits and removed the Opus cap, so you can use Opus 4.5 up to your overall limit. Sonnet now has its own limit—it's set to match your previous overall limit, so you can use just as much as before. We may continue to adjust limits as we learn how usage patterns evolve over time.";
  if (!Q) return null;
  return VB.createElement(S, {
    flexDirection: "column"
  }, VB.createElement($, {
    bold: !0
  }, "Nov 24, 2025 update:"), VB.createElement($, {
    dimColor: !0
  }, Q))
}
// @from(Start 14005162, End 14005164)
VB
// @from(Start 14005166, End 14005169)
EVA
// @from(Start 14005171, End 14005190)
sV0 = "Extra usage"
// @from(Start 14005196, End 14005336)
sV9 = L(() => {
  hA();
  i8();
  nV0();
  g1();
  iV9();
  DjA();
  M_();
  gB();
  SW0();
  u2();
  VB = BA(VA(), 1), EVA = BA(VA(), 1)
})
// @from(Start 14005339, End 14006361)
function zVA({
  onClose: A,
  context: Q,
  defaultTab: B
}) {
  let [G, Z] = mY1.useState(!1), [I, Y] = mY1.useState(!1), [J, W] = mY1.useState(!1);
  return f1((V, F) => {
    if (F.escape || F.ctrl && (V === "c" || V === "d")) A("Status dialog dismissed", {
      display: "system"
    })
  }), aW.createElement(S, {
    flexDirection: "column"
  }, aW.createElement(D3, {
    dividerColor: I ? "warning" : "permission",
    dividerDimColor: !I
  }), aW.createElement(S, {
    marginX: J ? 0 : 1
  }, aW.createElement(Na, {
    title: "Settings:",
    color: "permission",
    defaultTab: B,
    hidden: G
  }, [aW.createElement(eD, {
    key: "status",
    title: "Status"
  }, aW.createElement(uV9, {
    context: Q
  })), aW.createElement(eD, {
    key: "config",
    title: "Config"
  }, aW.createElement(cV9, {
    context: Q,
    onClose: A,
    setTabsHidden: Z,
    setIsWarning: Y,
    setHideMargin: W
  })), aW.createElement(eD, {
    key: "usage",
    title: "Usage"
  }, aW.createElement(aV9, null))])))
}
// @from(Start 14006366, End 14006368)
aW
// @from(Start 14006370, End 14006373)
mY1
// @from(Start 14006379, End 14006487)
dY1 = L(() => {
  hA();
  BK();
  FSA();
  mV9();
  pV9();
  sV9();
  aW = BA(VA(), 1), mY1 = BA(VA(), 1)
})
// @from(Start 14006493, End 14006496)
rV0
// @from(Start 14006498, End 14006501)
ky3
// @from(Start 14006503, End 14006506)
rV9
// @from(Start 14006512, End 14006928)
oV9 = L(() => {
  dY1();
  rV0 = BA(VA(), 1), ky3 = {
    aliases: ["theme"],
    type: "local-jsx",
    name: "config",
    description: "Open config panel",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q) {
      return rV0.createElement(zVA, {
        onClose: A,
        context: Q,
        defaultTab: "Config"
      })
    },
    userFacingName() {
      return "config"
    }
  }, rV9 = ky3
})
// @from(Start 14006931, End 14006984)
function yy3(A) {
  return `${Math.round(A/1000)}k`
}
// @from(Start 14006986, End 14012025)
function tV9({
  data: A
}) {
  let {
    categories: Q,
    totalTokens: B,
    rawMaxTokens: G,
    percentage: Z,
    gridRows: I,
    model: Y,
    memoryFiles: J,
    mcpTools: W,
    agents: X,
    slashCommands: V,
    skills: F,
    messageBreakdown: K
  } = A, {
    columns: D
  } = WB(), H = D < 80, C = Q.filter((U) => U.tokens > 0 && U.name !== "Free space" && U.name !== cY1), E = Q.find((U) => U.name === cY1);
  return VQ.createElement(S, {
    flexDirection: "column",
    padding: H ? 0 : 1
  }, VQ.createElement($, {
    bold: !0
  }, "Context Usage"), VQ.createElement(S, {
    flexDirection: "row",
    gap: 2
  }, VQ.createElement(S, {
    flexDirection: "column",
    flexShrink: 0
  }, I.map((U, q) => VQ.createElement(S, {
    key: q,
    flexDirection: "row",
    marginLeft: -1
  }, U.map((w, N) => {
    if (w.categoryName === "Free space") return VQ.createElement($, {
      key: N,
      dimColor: !0
    }, "⛶ ");
    if (w.categoryName === cY1) return VQ.createElement($, {
      key: N,
      color: w.color
    }, "⛝ ");
    return VQ.createElement($, {
      key: N,
      color: w.color
    }, w.squareFullness >= 0.7 ? "⛁ " : "⛀ ")
  })))), VQ.createElement(S, {
    flexDirection: "column",
    gap: 0,
    flexShrink: 0
  }, VQ.createElement($, {
    dimColor: !0
  }, Y, " · ", Math.round(B / 1000), "k/", Math.round(G / 1000), "k tokens (", Z, "%)"), VQ.createElement($, null, " "), C.map((U, q) => {
    let w = U.tokens < 1000 ? `${U.tokens}` : `${(U.tokens/1000).toFixed(1)}k`,
      N = (U.tokens / G * 100).toFixed(1),
      R = U.name === cY1,
      T = U.name,
      y = R ? "⛝" : "⛁";
    return VQ.createElement(S, {
      key: q
    }, VQ.createElement($, {
      color: U.color
    }, y), VQ.createElement($, null, " ", T, ": "), VQ.createElement($, {
      dimColor: !0
    }, w, " tokens (", N, "%)"))
  }), (Q.find((U) => U.name === "Free space")?.tokens ?? 0) > 0 && VQ.createElement(S, null, VQ.createElement($, {
    dimColor: !0
  }, "⛶"), VQ.createElement($, null, " Free space: "), VQ.createElement($, {
    dimColor: !0
  }, yy3(Q.find((U) => U.name === "Free space")?.tokens || 0), " ", "(", ((Q.find((U) => U.name === "Free space")?.tokens || 0) / G * 100).toFixed(1), "%)")), E && E.tokens > 0 && VQ.createElement(S, null, VQ.createElement($, {
    color: E.color
  }, "⛝"), VQ.createElement($, {
    dimColor: !0
  }, " ", E.name, ": "), VQ.createElement($, {
    dimColor: !0
  }, E.tokens < 1000 ? `${E.tokens}` : `${(E.tokens/1000).toFixed(1)}k`, " ", "tokens (", (E.tokens / G * 100).toFixed(1), "%)")))), VQ.createElement(S, {
    flexDirection: "column",
    marginLeft: -1
  }, W.length > 0 && VQ.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, VQ.createElement(S, null, VQ.createElement($, {
    bold: !0
  }, "MCP tools"), VQ.createElement($, {
    dimColor: !0
  }, " · /mcp")), W.map((U, q) => VQ.createElement(S, {
    key: q
  }, VQ.createElement($, null, "└ ", U.name, " (", U.serverName, "):", " "), VQ.createElement($, {
    dimColor: !0
  }, U.tokens < 1000 ? `${U.tokens}` : `${(U.tokens/1000).toFixed(1)}k`, " ", "tokens")))), X.length > 0 && VQ.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, VQ.createElement(S, null, VQ.createElement($, {
    bold: !0
  }, "Custom agents"), VQ.createElement($, {
    dimColor: !0
  }, " · /agents")), X.map((U, q) => {
    let w = U.source === "projectSettings" ? "Project" : U.source === "userSettings" ? "User" : U.source === "localSettings" ? "Local" : U.source === "flagSettings" ? "Flag" : U.source === "policySettings" ? "Policy" : U.source === "plugin" ? "Plugin" : U.source === "built-in" ? "Built-in" : String(U.source);
    return VQ.createElement(S, {
      key: q
    }, VQ.createElement($, null, "└ ", U.agentType, " (", w, "):", " "), VQ.createElement($, {
      dimColor: !0
    }, U.tokens < 1000 ? `${U.tokens}` : `${(U.tokens/1000).toFixed(1)}k`, " ", "tokens"))
  })), J.length > 0 && VQ.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, VQ.createElement(S, null, VQ.createElement($, {
    bold: !0
  }, "Memory files"), VQ.createElement($, {
    dimColor: !0
  }, " · /memory")), J.map((U, q) => VQ.createElement(S, {
    key: q
  }, VQ.createElement($, null, "└ ", U.type, " (", U.path, "):", " "), VQ.createElement($, {
    dimColor: !0
  }, U.tokens < 1000 ? `${U.tokens}` : `${(U.tokens/1000).toFixed(1)}k`, " ", "tokens")))), V && V.tokens > 0 && VQ.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, VQ.createElement(S, null, VQ.createElement($, {
    bold: !0
  }, "SlashCommand Tool"), VQ.createElement($, {
    dimColor: !0
  }, " ", "·", " ", V.includedCommands < V.totalCommands ? `${V.includedCommands} of ${V.totalCommands} commands` : `${V.totalCommands} commands`)), VQ.createElement(S, null, VQ.createElement($, null, "└ Total: "), VQ.createElement($, {
    dimColor: !0
  }, V.tokens < 1000 ? `${V.tokens}` : `${(V.tokens/1000).toFixed(1)}k`, " ", "tokens"))), F && F.tokens > 0 && !1, K && !1))
}
// @from(Start 14012030, End 14012032)
VQ
// @from(Start 14012034, End 14012060)
cY1 = "Autocompact buffer"
// @from(Start 14012066, End 14012119)
eV9 = L(() => {
  hA();
  i8();
  VQ = BA(VA(), 1)
})
// @from(Start 14012169, End 14012387)
function vy3({
  children: A
}) {
  let {
    exit: Q
  } = ku1();
  return lQA.useLayoutEffect(() => {
    let B = setTimeout(Q, 0);
    return () => clearTimeout(B)
  }, [Q]), hO.createElement(hO.Fragment, null, A)
}
// @from(Start 14012389, End 14012638)
function AF9(A) {
  return new Promise(async (Q) => {
    let B = "",
      G = new xy3;
    G.on("data", (I) => {
      B += I.toString()
    }), await (await VG(hO.createElement(vy3, null, A), {
      stdout: G
    })).waitUntilExit(), Q(B)
  })
}
// @from(Start 14012639, End 14012703)
async function UVA(A) {
  let Q = await AF9(A);
  return cY(Q)
}
// @from(Start 14012705, End 14013019)
function $VA({
  children: A,
  onComplete: Q
}) {
  let B = lQA.useContext(k_),
    G = lQA.useRef(!1);
  if (lQA.useLayoutEffect(() => {
      if (G.current) return;
      G.current = !0, AF9(A).then((Z) => {
        Q(Z)
      })
    }, [A, Q]), B) return hO.createElement(hO.Fragment, null, A);
  return null
}
// @from(Start 14013024, End 14013026)
hO
// @from(Start 14013028, End 14013031)
lQA
// @from(Start 14013037, End 14013118)
DSA = L(() => {
  hA();
  k7A();
  ET();
  hO = BA(VA(), 1), lQA = BA(VA(), 1)
})
// @from(Start 14013121, End 14013194)
function ng(A) {
  return A < 1000 ? `${A}` : `${(A/1000).toFixed(1)}k`
}
// @from(Start 14013196, End 14015834)
function fy3(A) {
  let {
    categories: Q,
    totalTokens: B,
    rawMaxTokens: G,
    percentage: Z,
    model: I,
    memoryFiles: Y,
    mcpTools: J,
    agents: W,
    slashCommands: X,
    skills: V,
    messageBreakdown: F
  } = A, K = `## Context Usage

`;
  K += `**Model:** ${I}  
`, K += `**Tokens:** ${ng(B)} / ${ng(G)} (${Z}%)

`;
  let D = Q.filter((H) => H.tokens > 0 && H.name !== "Free space" && H.name !== "Autocompact buffer");
  if (D.length > 0) {
    K += `### Categories

`, K += `| Category | Tokens | Percentage |
`, K += `|----------|--------|------------|
`;
    for (let E of D) {
      let U = (E.tokens / G * 100).toFixed(1);
      K += `| ${E.name} | ${ng(E.tokens)} | ${U}% |
`
    }
    let H = Q.find((E) => E.name === "Free space");
    if (H && H.tokens > 0) {
      let E = (H.tokens / G * 100).toFixed(1);
      K += `| Free space | ${ng(H.tokens)} | ${E}% |
`
    }
    let C = Q.find((E) => E.name === "Autocompact buffer");
    if (C && C.tokens > 0) {
      let E = (C.tokens / G * 100).toFixed(1);
      K += `| Autocompact buffer | ${ng(C.tokens)} | ${E}% |
`
    }
    K += `
`
  }
  if (J.length > 0) {
    K += `### MCP Tools

`, K += `| Tool | Server | Tokens |
`, K += `|------|--------|--------|
`;
    for (let H of J) K += `| ${H.name} | ${H.serverName} | ${ng(H.tokens)} |
`;
    K += `
`
  }
  if (W.length > 0) {
    K += `### Custom Agents

`, K += `| Agent Type | Source | Tokens |
`, K += `|------------|--------|--------|
`;
    for (let H of W) {
      let C;
      switch (H.source) {
        case "projectSettings":
          C = "Project";
          break;
        case "userSettings":
          C = "User";
          break;
        case "localSettings":
          C = "Local";
          break;
        case "flagSettings":
          C = "Flag";
          break;
        case "policySettings":
          C = "Policy";
          break;
        case "plugin":
          C = "Plugin";
          break;
        case "built-in":
          C = "Built-in";
          break;
        default:
          C = String(H.source)
      }
      K += `| ${H.agentType} | ${C} | ${ng(H.tokens)} |
`
    }
    K += `
`
  }
  if (Y.length > 0) {
    K += `### Memory Files

`, K += `| Type | Path | Tokens |
`, K += `|------|------|--------|
`;
    for (let H of Y) K += `| ${H.type} | ${H.path} | ${ng(H.tokens)} |
`;
    K += `
`
  }
  if (X && X.tokens > 0) K += `### SlashCommand Tool

`, K += `**Commands:** ${X.includedCommands<X.totalCommands?`${X.includedCommands} of ${X.totalCommands}`:X.totalCommands}  
`, K += `**Total tokens:** ${ng(X.tokens)}

`;
  return V && V.tokens > 0, K
}
// @from(Start 14015839, End 14015842)
HSA
// @from(Start 14015844, End 14015847)
by3
// @from(Start 14015849, End 14015852)
QF9
// @from(Start 14015858, End 14016784)
BF9 = L(() => {
  eV9();
  s51();
  DSA();
  y1A();
  cQ();
  HSA = BA(VA(), 1), by3 = {
    name: "context",
    description: "Visualize current context usage as a colored grid",
    isEnabled: () => !0,
    isHidden: !1,
    type: "local-jsx",
    userFacingName() {
      return this.name
    },
    async call(A, {
      messages: Q,
      getAppState: B,
      options: {
        mainLoopModel: G,
        tools: Z,
        isNonInteractiveSession: I
      }
    }) {
      let Y = nk(Q),
        {
          messages: J
        } = await Si(Y),
        W = process.stdout.columns || 80,
        X = await B(),
        V = await xb2(J, G, async () => X.toolPermissionContext, Z, X.agentDefinitions, W);
      if (I) {
        let F = fy3(V);
        return A(F), null
      }
      return HSA.createElement($VA, {
        onComplete: A
      }, HSA.createElement(tV9, {
        data: V
      }))
    }
  };
  QF9 = by3
})
// @from(Start 14016790, End 14016793)
hy3
// @from(Start 14016795, End 14016798)
GF9
// @from(Start 14016804, End 14017629)
ZF9 = L(() => {
  M_();
  gB();
  Pi();
  hy3 = {
    type: "local",
    name: "cost",
    description: "Show the total cost and duration of the current session",
    isEnabled: () => !0,
    get isHidden() {
      return BB()
    },
    supportsNonInteractive: !0,
    async call() {
      if (BB()) {
        let A;
        if (ik.isUsingOverage) A = "You are currently using your overages to power your Claude Code usage. We will automatically switch you back to your subscription rate limits when they reset";
        else A = "You are currently using your subscription to power your Claude Code usage";
        return {
          type: "text",
          value: A
        }
      }
      return {
        type: "text",
        value: rv1()
      }
    },
    userFacingName() {
      return "cost"
    }
  }, GF9 = hy3
})
// @from(Start 14017635, End 14017649)
IF9 = () => {}
// @from(Start 14017652, End 14017809)
function pY1() {
  return CSA.createElement($, {
    color: "permission"
  }, "Press ", CSA.createElement($, {
    bold: !0
  }, "Enter"), " to continue…")
}
// @from(Start 14017814, End 14017817)
CSA
// @from(Start 14017823, End 14017869)
oV0 = L(() => {
  hA();
  CSA = BA(VA(), 1)
})
// @from(Start 14017872, End 14019920)
function YF9(A, Q = {}) {
  let {
    showValues: B = !0,
    hideFunctions: G = !1,
    themeName: Z = "dark",
    treeCharColors: I = {}
  } = Q, Y = [], J = new WeakSet;

  function W(F, K) {
    if (!K) return F;
    return ZB(K, Z)(F)
  }

  function X(F, K, D, H = 0) {
    if (typeof F === "string") {
      Y.push(K + W(F, I.value));
      return
    }
    if (typeof F !== "object" || F === null) {
      if (B) {
        let E = String(F);
        Y.push(K + W(E, I.value))
      }
      return
    }
    if (J.has(F)) {
      Y.push(K + W("[Circular]", I.value));
      return
    }
    J.add(F);
    let C = Object.keys(F).filter((E) => {
      let U = F[E];
      if (G && typeof U === "function") return !1;
      return !0
    });
    C.forEach((E, U) => {
      let q = F[E],
        w = U === C.length - 1,
        N = H === 0 && U === 0 ? "" : K,
        R = w ? ESA.lastBranch : ESA.branch,
        T = W(R, I.treeChar),
        y = E.trim() === "" ? "" : W(E, I.key),
        v = N + T + (y ? " " + y : ""),
        x = E.trim() !== "";
      if (q && typeof q === "object" && J.has(q)) {
        let p = W("[Circular]", I.value);
        Y.push(v + (x ? ": " : v ? " " : "") + p)
      } else if (q && typeof q === "object" && !Array.isArray(q)) {
        Y.push(v);
        let p = w ? ESA.empty : ESA.line,
          u = W(p, I.treeChar),
          e = N + u + " ";
        X(q, e, w, H + 1)
      } else if (Array.isArray(q)) Y.push(v + (x ? ": " : v ? " " : "") + "[Array(" + q.length + ")]");
      else if (B) {
        let p = typeof q === "function" ? "[Function]" : String(q),
          u = W(p, I.value);
        v += (x ? ": " : v ? " " : "") + u, Y.push(v)
      } else Y.push(v)
    })
  }
  let V = Object.keys(A);
  if (V.length === 0) return W("(empty)", I.value);
  if (V.length === 1 && V[0] !== void 0 && V[0].trim() === "" && typeof A[V[0]] === "string") {
    let F = V[0],
      K = W(ESA.lastBranch, I.treeChar),
      D = W(A[F], I.value);
    return K + " " + D
  }
  return X(A, "", !0), Y.join(`
`)
}
// @from(Start 14019925, End 14019928)
ESA
// @from(Start 14019934, End 14020088)
JF9 = L(() => {
  V9();
  hA();
  ESA = {
    branch: H1.lineUpDownRight,
    lastBranch: H1.lineUpRight,
    line: H1.lineVertical,
    empty: " "
  }
})
// @from(Start 14020091, End 14020911)
function gy3(A) {
  let Q = {};
  return A.forEach((B) => {
    if (!B.path) {
      Q[""] = B.message;
      return
    }
    let G = B.path.split("."),
      Z = B.path;
    if (B.invalidValue !== null && B.invalidValue !== void 0 && G.length > 0) {
      let I = [];
      for (let Y = 0; Y < G.length; Y++) {
        let J = G[Y];
        if (!J) continue;
        let W = parseInt(J, 10);
        if (!isNaN(W) && Y === G.length - 1) {
          let X;
          if (typeof B.invalidValue === "string") X = `"${B.invalidValue}"`;
          else if (B.invalidValue === null) X = "null";
          else if (B.invalidValue === void 0) X = "undefined";
          else X = String(B.invalidValue);
          I.push(X)
        } else I.push(J)
      }
      Z = I.join(".")
    }
    ou0(Q, Z, B.message, Object)
  }), Q
}
// @from(Start 14020913, End 14022690)
function WF9({
  errors: A
}) {
  let [Q] = qB();
  if (A.length === 0) return null;
  let B = A.reduce((Z, I) => {
      let Y = I.file || "(file not specified)";
      if (!Z[Y]) Z[Y] = [];
      return Z[Y].push(I), Z
    }, {}),
    G = Object.keys(B).sort();
  return sW.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    marginBottom: 1
  }, sW.createElement($, {
    bold: !0
  }, "Invalid Settings"), G.map((Z) => {
    let I = B[Z] || [];
    I.sort((X, V) => {
      if (!X.path && V.path) return -1;
      if (X.path && !V.path) return 1;
      return (X.path || "").localeCompare(V.path || "")
    });
    let Y = gy3(I),
      J = new Map;
    I.forEach((X) => {
      if (X.suggestion || X.docLink) {
        let V = `${X.suggestion||""}|${X.docLink||""}`;
        if (!J.has(V)) J.set(V, {
          suggestion: X.suggestion,
          docLink: X.docLink
        })
      }
    });
    let W = YF9(Y, {
      showValues: !0,
      themeName: Q,
      treeCharColors: {
        treeChar: "inactive",
        key: "text",
        value: "inactive"
      }
    });
    return sW.createElement(S, {
      key: Z,
      flexDirection: "column"
    }, sW.createElement($, null, Z), sW.createElement(S, {
      marginLeft: 1
    }, sW.createElement($, {
      dimColor: !0
    }, W)), J.size > 0 && sW.createElement(S, {
      flexDirection: "column",
      marginTop: 1
    }, Array.from(J.values()).map((X, V) => sW.createElement(S, {
      key: `suggestion-pair-${V}`,
      flexDirection: "column",
      marginBottom: 1
    }, X.suggestion && sW.createElement($, {
      dimColor: !0,
      wrap: "wrap"
    }, X.suggestion), X.docLink && sW.createElement($, {
      dimColor: !0,
      wrap: "wrap"
    }, "Learn more: ", X.docLink)))))
  }))
}
// @from(Start 14022695, End 14022697)
sW
// @from(Start 14022703, End 14022766)
XF9 = L(() => {
  hA();
  tu0();
  JF9();
  sW = BA(VA(), 1)
})
// @from(Start 14022769, End 14024359)
function tV0({
  scope: A,
  parsingErrors: Q,
  warnings: B
}) {
  let G = Q.length > 0,
    Z = B.length > 0;
  if (!G && !Z) return null;
  return qZ.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, qZ.default.createElement(S, null, (G || Z) && qZ.default.createElement($, {
    color: G ? "error" : "warning"
  }, "[", G ? "Failed to parse" : "Contains warnings", "]", " "), qZ.default.createElement($, null, iQA(A))), qZ.default.createElement(S, null, qZ.default.createElement($, {
    dimColor: !0
  }, "Location: "), qZ.default.createElement($, {
    dimColor: !0
  }, YN(A))), qZ.default.createElement(S, {
    marginLeft: 1,
    flexDirection: "column"
  }, Q.map((I, Y) => {
    let J = I.mcpErrorMetadata?.serverName;
    return qZ.default.createElement(S, {
      key: `error-${Y}`
    }, qZ.default.createElement($, null, qZ.default.createElement($, {
      dimColor: !0
    }, "└ "), qZ.default.createElement($, {
      color: "error"
    }, "[Error]"), qZ.default.createElement($, {
      dimColor: !0
    }, " ", J && `[${J}] `, I.path && I.path !== "" ? `${I.path}: ` : "", I.message)))
  }), B.map((I, Y) => {
    let J = I.mcpErrorMetadata?.serverName;
    return qZ.default.createElement(S, {
      key: `warning-${Y}`
    }, qZ.default.createElement($, null, qZ.default.createElement($, {
      dimColor: !0
    }, "└ "), qZ.default.createElement($, {
      color: "warning"
    }, "[Warning]"), qZ.default.createElement($, {
      dimColor: !0
    }, " ", J && `[${J}] `, I.path && I.path !== "" ? `${I.path}: ` : "", I.message)))
  })))
}
// @from(Start 14024361, End 14026049)
function lY1() {
  let A = sX("user"),
    Q = sX("project"),
    B = sX("local"),
    G = {
      user: A.errors.filter((J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "fatal"),
      project: Q.errors.filter((J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "fatal"),
      local: B.errors.filter((J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "fatal")
    },
    Z = {
      user: A.errors.filter((J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "warning"),
      project: Q.errors.filter((J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "warning"),
      local: B.errors.filter((J) => J.mcpErrorMetadata && J.mcpErrorMetadata.severity === "warning")
    },
    I = G.user.length > 0 || G.project.length > 0 || G.local.length > 0,
    Y = Z.user.length > 0 || Z.project.length > 0 || Z.local.length > 0;
  if (!I && !Y) return null;
  return qZ.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    marginBottom: 1
  }, qZ.default.createElement($, {
    bold: !0
  }, "MCP Config Diagnostics"), qZ.default.createElement(S, {
    marginTop: 1
  }, qZ.default.createElement($, {
    dimColor: !0
  }, "For help configuring MCP servers, see:", " ", qZ.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/mcp"
  }, "https://code.claude.com/docs/en/mcp"))), qZ.default.createElement(tV0, {
    scope: "user",
    parsingErrors: G.user,
    warnings: Z.user
  }), qZ.default.createElement(tV0, {
    scope: "project",
    parsingErrors: G.project,
    warnings: Z.project
  }), qZ.default.createElement(tV0, {
    scope: "local",
    parsingErrors: G.local,
    warnings: Z.local
  }))
}
// @from(Start 14026054, End 14026056)
qZ
// @from(Start 14026062, End 14026131)
eV0 = L(() => {
  hA();
  tM();
  nX();
  hA();
  qZ = BA(VA(), 1)
})
// @from(Start 14026134, End 14026312)
function VF9() {
  return oE0().map((Q) => ({
    name: Q.name,
    value: process.env[Q.name],
    ...Q.validate(process.env[Q.name])
  })).filter((Q) => Q.status !== "valid")
}
// @from(Start 14026317, End 14026342)
FF9 = L(() => {
  _0()
})
// @from(Start 14026344, End 14026904)
async function uy3() {
  let A = M1A();
  if (A.length === 0) return null;
  let Q = A.sort((G, Z) => Z.content.length - G.content.length).map((G) => `${G.path}: ${G.content.length.toLocaleString()} chars`);
  return {
    type: "claudemd_files",
    severity: "warning",
    message: A.length === 1 ? `Large CLAUDE.md file detected (${A[0].content.length.toLocaleString()} chars > ${Lh.toLocaleString()})` : `${A.length} large CLAUDE.md files detected (each > ${Lh.toLocaleString()} chars)`,
    details: Q,
    currentValue: A.length,
    threshold: Lh
  }
}
// @from(Start 14026905, End 14027619)
async function my3(A) {
  if (!A) return null;
  let Q = jjA(A);
  if (Q <= jQA) return null;
  let B = A.activeAgents.filter((Z) => Z.source !== "built-in").map((Z) => {
      let I = `${Z.agentType}: ${Z.whenToUse}`;
      return {
        name: Z.agentType,
        tokens: gG(I)
      }
    }).sort((Z, I) => I.tokens - Z.tokens),
    G = B.slice(0, 5).map((Z) => `${Z.name}: ~${Z.tokens.toLocaleString()} tokens`);
  if (B.length > 5) G.push(`(${B.length-5} more custom agents)`);
  return {
    type: "agent_descriptions",
    severity: "warning",
    message: `Large agent descriptions (~${Q.toLocaleString()} tokens > ${jQA.toLocaleString()})`,
    details: G,
    currentValue: Q,
    threshold: jQA
  }
}
// @from(Start 14027620, End 14029108)
async function dy3(A, Q, B) {
  let G = A.filter((Z) => Z.isMcp);
  if (G.length === 0) return null;
  if (bZ()) return null;
  try {
    let {
      mcpToolTokens: Z,
      mcpToolDetails: I
    } = await XTA(A, Q, B);
    if (Z <= wVA) return null;
    let Y = new Map;
    for (let X of I) {
      let F = X.name.split("__")[1] || "unknown",
        K = Y.get(F) || {
          count: 0,
          tokens: 0
        };
      Y.set(F, {
        count: K.count + 1,
        tokens: K.tokens + X.tokens
      })
    }
    let J = Array.from(Y.entries()).sort((X, V) => V[1].tokens - X[1].tokens),
      W = J.slice(0, 5).map(([X, V]) => `${X}: ${V.count} tools (~${V.tokens.toLocaleString()} tokens)`);
    if (J.length > 5) W.push(`(${J.length-5} more servers)`);
    return {
      type: "mcp_tools",
      severity: "warning",
      message: `Large MCP tools context (~${Z.toLocaleString()} tokens > ${wVA.toLocaleString()})`,
      details: W,
      currentValue: Z,
      threshold: wVA
    }
  } catch (Z) {
    let I = G.reduce((Y, J) => {
      let W = (J.name?.length || 0) + J.description.length;
      return Y + gG(W.toString())
    }, 0);
    if (I <= wVA) return null;
    return {
      type: "mcp_tools",
      severity: "warning",
      message: `Large MCP tools context (~${I.toLocaleString()} tokens estimated > ${wVA.toLocaleString()})`,
      details: [`${G.length} MCP tools detected (token count estimated)`],
      currentValue: I,
      threshold: wVA
    }
  }
}
// @from(Start 14029109, End 14029286)
async function KF9(A, Q, B) {
  let [G, Z, I] = await Promise.all([uy3(), my3(Q), dy3(A, B, Q)]);
  return {
    claudeMdWarning: G,
    agentWarning: Z,
    mcpWarning: I
  }
}
// @from(Start 14029291, End 14029302)
wVA = 25000
// @from(Start 14029308, End 14029367)
DF9 = L(() => {
  gE();
  rW0();
  s51();
  xM();
  dH()
})
// @from(Start 14029408, End 14035989)
function iY1({
  onDone: A
}) {
  let [Q] = OQ(), B = Q.agentDefinitions, G = FB.useMemo(() => {
    return Q?.mcp?.tools || []
  }, [Q?.mcp?.tools]), [Z, I] = FB.useState(null), [Y, J] = FB.useState(null), [W, X] = FB.useState(null), F = AY1().filter((D) => D.mcpErrorMetadata === void 0), K = FB.useMemo(() => VF9(), []);
  if (FB.useEffect(() => {
      YIA().then(I), (async () => {
        let D = RA(),
          H = HF9(MQ(), "agents"),
          C = HF9(uQ(), ".claude", "agents"),
          {
            activeAgents: E,
            allAgents: U,
            failedFiles: q
          } = B,
          w = {
            activeAgents: E.map((R) => ({
              agentType: R.agentType,
              source: R.source
            })),
            userAgentsDir: H,
            projectAgentsDir: C,
            userDirExists: D.existsSync(H),
            projectDirExists: D.existsSync(C),
            failedFiles: q
          };
        J(w);
        let N = await KF9(G, {
          activeAgents: E,
          allAgents: U,
          failedFiles: q
        }, async () => Q.toolPermissionContext);
        X(N)
      })()
    }, [Q.toolPermissionContext, G, B]), f1((D, H) => {
      if (H.return || H.escape || H.ctrl && D === "c") A("Claude Code diagnostics dismissed", {
        display: "system"
      })
    }), !Z) return FB.default.createElement(S, {
    paddingX: 1,
    paddingTop: 1
  }, FB.default.createElement($, {
    dimColor: !0
  }, "Checking installation status…"));
  return FB.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    paddingX: 1,
    paddingTop: 1
  }, FB.default.createElement(S, {
    flexDirection: "column"
  }, FB.default.createElement($, {
    bold: !0
  }, "Diagnostics"), FB.default.createElement($, null, "└ Currently running: ", Z.installationType, " (", Z.version, ")"), Z.packageManager && FB.default.createElement($, null, "└ Package manager: ", Z.packageManager), FB.default.createElement($, null, "└ Path: ", Z.installationPath), FB.default.createElement($, null, "└ Invoked: ", Z.invokedBinary), FB.default.createElement($, null, "└ Config install method: ", Z.configInstallMethod), FB.default.createElement($, null, "└ Auto-updates:", " ", Z.packageManager ? "Managed by package manager" : Z.autoUpdates), Z.hasUpdatePermissions !== null && FB.default.createElement($, null, "└ Update permissions:", " ", Z.hasUpdatePermissions ? "Yes" : "No (requires sudo)"), FB.default.createElement($, null, "└ Search: ", Z.ripgrepStatus.working ? "OK" : "Not working", " (", Z.ripgrepStatus.mode === "builtin" ? UX() ? "bundled" : "vendor" : Z.ripgrepStatus.systemPath || "system", ")"), Z.recommendation && FB.default.createElement(FB.default.Fragment, null, FB.default.createElement($, null), FB.default.createElement($, {
    color: "warning"
  }, "Recommendation: ", Z.recommendation.split(`
`)[0]), FB.default.createElement($, {
    dimColor: !0
  }, Z.recommendation.split(`
`)[1])), Z.multipleInstallations.length > 1 && FB.default.createElement(FB.default.Fragment, null, FB.default.createElement($, null), FB.default.createElement($, {
    color: "warning"
  }, "Warning: Multiple installations found"), Z.multipleInstallations.map((D, H) => FB.default.createElement($, {
    key: H
  }, "└ ", D.type, " at ", D.path))), Z.warnings.length > 0 && FB.default.createElement(FB.default.Fragment, null, FB.default.createElement($, null), Z.warnings.map((D, H) => FB.default.createElement(S, {
    key: H,
    flexDirection: "column"
  }, FB.default.createElement($, {
    color: "warning"
  }, "Warning: ", D.issue), FB.default.createElement($, null, "Fix: ", D.fix)))), F.length > 0 && FB.default.createElement(FB.default.Fragment, null, FB.default.createElement($, null), FB.default.createElement(WF9, {
    errors: F
  }))), FB.default.createElement(lY1, null), K.length > 0 && FB.default.createElement(S, {
    flexDirection: "column"
  }, FB.default.createElement($, {
    bold: !0
  }, "Environment Variables"), K.map((D, H) => FB.default.createElement($, {
    key: H
  }, "└ ", D.name, ":", " ", FB.default.createElement($, {
    color: D.status === "capped" ? "warning" : "error"
  }, D.message)))), Y?.failedFiles && Y.failedFiles.length > 0 && FB.default.createElement(S, {
    flexDirection: "column"
  }, FB.default.createElement($, {
    bold: !0,
    color: "error"
  }, "Agent Parse Errors"), FB.default.createElement($, {
    color: "error"
  }, "└ Failed to parse ", Y.failedFiles.length, " agent file(s):"), Y.failedFiles.map((D, H) => FB.default.createElement($, {
    key: H,
    dimColor: !0
  }, "  ", "└ ", D.path, ": ", D.error))), Q.plugins.errors.length > 0 && FB.default.createElement(S, {
    flexDirection: "column"
  }, FB.default.createElement($, {
    bold: !0,
    color: "error"
  }, "Plugin Errors"), FB.default.createElement($, {
    color: "error"
  }, "└ ", Q.plugins.errors.length, " plugin error(s) detected:"), Q.plugins.errors.map((D, H) => FB.default.createElement($, {
    key: H,
    dimColor: !0
  }, "  ", "└ ", D.source || "unknown", "plugin" in D && D.plugin ? ` [${D.plugin}]` : "", ":", " ", oM(D)))), W && (W.claudeMdWarning || W.agentWarning || W.mcpWarning) && FB.default.createElement(S, {
    flexDirection: "column"
  }, FB.default.createElement($, {
    bold: !0
  }, "Context Usage Warnings"), W.claudeMdWarning && FB.default.createElement(FB.default.Fragment, null, FB.default.createElement($, null, "└", " ", FB.default.createElement($, {
    color: "warning"
  }, H1.warning, " ", W.claudeMdWarning.message)), FB.default.createElement($, null, "  ", "└ Files:"), W.claudeMdWarning.details.map((D, H) => FB.default.createElement($, {
    key: H,
    dimColor: !0
  }, "    ", "└ ", D))), W.agentWarning && FB.default.createElement(FB.default.Fragment, null, FB.default.createElement($, null, "└", " ", FB.default.createElement($, {
    color: "warning"
  }, H1.warning, " ", W.agentWarning.message)), FB.default.createElement($, null, "  ", "└ Top contributors:"), W.agentWarning.details.map((D, H) => FB.default.createElement($, {
    key: H,
    dimColor: !0
  }, "    ", "└ ", D))), W.mcpWarning && FB.default.createElement(FB.default.Fragment, null, FB.default.createElement($, null, "└", " ", FB.default.createElement($, {
    color: "warning"
  }, H1.warning, " ", W.mcpWarning.message)), FB.default.createElement($, null, "  ", "└ MCP servers:"), W.mcpWarning.details.map((D, H) => FB.default.createElement($, {
    key: H,
    dimColor: !0
  }, "    ", "└ ", D)))), FB.default.createElement(S, null, FB.default.createElement(pY1, null)))
}
// @from(Start 14035994, End 14035996)
FB
// @from(Start 14036002, End 14036149)
AF0 = L(() => {
  hA();
  V9();
  Zh();
  oV0();
  mX0();
  XF9();
  eV0();
  _0();
  AQ();
  hQ();
  FF9();
  DF9();
  z9();
  FB = BA(VA(), 1)
})
// @from(Start 14036155, End 14036158)
CF9
// @from(Start 14036160, End 14036163)
cy3
// @from(Start 14036165, End 14036168)
EF9
// @from(Start 14036174, End 14036621)
zF9 = L(() => {
  AF0();
  CF9 = BA(VA(), 1), cy3 = {
    name: "doctor",
    description: "Diagnose and verify your Claude Code installation and settings",
    isEnabled: () => !process.env.DISABLE_DOCTOR_COMMAND,
    isHidden: !1,
    userFacingName() {
      return "doctor"
    },
    type: "local-jsx",
    call(A, Q, B) {
      return new Promise((G) => G(CF9.default.createElement(iY1, {
        onDone: A
      })))
    }
  }, EF9 = cy3
})
// @from(Start 14036627, End 14036652)
QF0 = L(() => {
  hQ()
})
// @from(Start 14036658, End 14036718)
BF0 = L(() => {
  AMA();
  V0();
  AQ();
  QMA();
  QF0()
})
// @from(Start 14036724, End 14036819)
GF0 = L(() => {
  AMA();
  V0();
  g1();
  q10();
  $10();
  QF0();
  AQ();
  QMA();
  BF0()
})
// @from(Start 14036825, End 14036828)
iy3
// @from(Start 14036834, End 14036904)
UF9 = L(() => {
  hA();
  J5();
  Q4();
  hA();
  iy3 = BA(VA(), 1)
})
// @from(Start 14036910, End 14036913)
$F9
// @from(Start 14036919, End 14036965)
wF9 = L(() => {
  hA();
  $F9 = BA(VA(), 1)
})
// @from(Start 14036971, End 14036974)
ZF0
// @from(Start 14036980, End 14037059)
qF9 = L(() => {
  hA();
  ZY();
  DY();
  BF0();
  V0();
  ZF0 = BA(VA(), 1)
})
// @from(Start 14037065, End 14037068)
nY1
// @from(Start 14037074, End 14037172)
NF9 = L(() => {
  hA();
  DY();
  GF0();
  UF9();
  wF9();
  qF9();
  V0();
  nY1 = BA(VA(), 1)
})
// @from(Start 14037178, End 14037181)
IF0
// @from(Start 14037187, End 14037283)
LF9 = L(() => {
  hA();
  DY();
  GF0();
  V0();
  AQ();
  yI();
  NF9();
  IF0 = BA(VA(), 1)
})
// @from(Start 14037286, End 14038829)
function ay3({
  onDone: A
}) {
  YF0.useState(() => {
    gV.cache.clear?.()
  });
  let {
    columns: Q
  } = WB(), B = async (W) => {
    try {
      if (W.includes(MQ())) {
        let D = MQ();
        if (!RA().existsSync(D)) RA().mkdirSync(D)
      }
      if (!RA().existsSync(W)) RA().writeFileSync(W, "", {
        encoding: "utf8",
        flush: !0
      });
      await cn(W);
      let X = "default",
        V = "";
      if (process.env.VISUAL) X = "$VISUAL", V = process.env.VISUAL;
      else if (process.env.EDITOR) X = "$EDITOR", V = process.env.EDITOR;
      let F = X !== "default" ? `Using ${X}="${V}".` : "",
        K = F ? `> ${F} To change editor, set $EDITOR or $VISUAL environment variable.` : "> To use a different editor, set the $EDITOR or $VISUAL environment variable.";
      A(`Opened memory file at ${w60(W)}

${K}`, {
        display: "system"
      })
    } catch (X) {
      AA(X instanceof Error ? X : Error(String(X))), A(`Error opening memory file: ${X}`)
    }
  }, G = () => {
    A("Cancelled memory editing", {
      display: "system"
    })
  }, I = [].length, [Y, J] = YF0.useState(!1);
  return f1((W, X) => {}), JN.createElement(S, {
    flexDirection: "column"
  }, JN.createElement(S, {
    marginTop: 1,
    marginBottom: 1
  }, JN.createElement($, {
    dimColor: !0
  }, "Learn more: ", JN.createElement(h4, {
    url: "https://code.claude.com/docs/en/memory"
  }))), !1, !1, !1, !Y && JN.createElement(hZ1, {
    title: "Select memory to edit:",
    onSelect: B,
    onCancel: G
  }))
}
// @from(Start 14038834, End 14038836)
JN
// @from(Start 14038838, End 14038841)
YF0
// @from(Start 14038843, End 14038846)
ny3
// @from(Start 14038848, End 14038851)
MF9
// @from(Start 14038857, End 14039295)
OF9 = L(() => {
  hQ();
  g1();
  pn();
  AQ();
  nJ0();
  q60();
  hA();
  hA();
  gE();
  i8();
  JN = BA(VA(), 1), YF0 = BA(VA(), 1), ny3 = {
    type: "local-jsx",
    name: "memory",
    description: "Edit Claude memory files",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A) {
      return JN.createElement(ay3, {
        onDone: A
      })
    },
    userFacingName() {
      return this.name
    }
  };
  MF9 = ny3
})
// @from(Start 14039298, End 14039822)
function RF9({
  onCancel: A
}) {
  return f1((Q, B) => {
    if (B.escape) A()
  }), Zz.createElement(S, {
    flexDirection: "column",
    paddingY: 1,
    gap: 1
  }, Zz.createElement(S, null, Zz.createElement($, null, "Claude understands your codebase, makes edits with your permission, and executes commands — right from your terminal.")), Zz.createElement(S, {
    flexDirection: "column"
  }, Zz.createElement(S, null, Zz.createElement($, {
    bold: !0
  }, "Shortcuts")), Zz.createElement(bZ1, {
    gap: 2
  })))
}
// @from(Start 14039827, End 14039829)
Zz
// @from(Start 14039835, End 14039889)
TF9 = L(() => {
  hA();
  iJ0();
  Zz = BA(VA(), 1)
})
// @from(Start 14039892, End 14040606)
function JF0({
  commands: A,
  maxHeight: Q,
  title: B,
  onCancel: G,
  emptyMessage: Z
}) {
  let I = Math.max(1, Q - 8),
    Y = PF9.useMemo(() => [...A].sort((J, W) => J.name.localeCompare(W.name)).map((J) => ({
      label: `/${J.name}`,
      value: J.name,
      description: J.description
    })), [A]);
  return OC.createElement(S, {
    flexDirection: "column",
    paddingY: 1
  }, A.length === 0 && Z ? OC.createElement($, {
    dimColor: !0
  }, Z) : OC.createElement(OC.Fragment, null, OC.createElement($, null, B), OC.createElement(S, {
    marginTop: 1
  }, OC.createElement(M0, {
    options: Y,
    visibleOptionCount: I,
    onCancel: G,
    disableSelection: !0,
    hideIndexes: !0
  }))))
}
// @from(Start 14040611, End 14040613)
OC
// @from(Start 14040615, End 14040618)
PF9
// @from(Start 14040624, End 14040696)
jF9 = L(() => {
  hA();
  S5();
  OC = BA(VA(), 1), PF9 = BA(VA(), 1)
})
// @from(Start 14040699, End 14042601)
function SF9({
  onClose: A,
  commands: Q
}) {
  let {
    rows: B
  } = WB(), G = Math.floor(B / 2), Z = () => A("Help dialog dismissed", {
    display: "system"
  }), I = EQ(Z), Y = Ny(), J = Q.filter((F) => Y.has(F.name) && !F.isHidden), W = [], X = Q.filter((F) => !Y.has(F.name) && !F.isHidden), V = [h6.createElement(eD, {
    key: "general",
    title: "general"
  }, h6.createElement(RF9, {
    onCancel: Z
  }))];
  return V.push(h6.createElement(eD, {
    key: "commands",
    title: "commands"
  }, h6.createElement(JF0, {
    commands: J,
    maxHeight: G,
    title: "Browse default commands:",
    onCancel: Z
  }))), V.push(h6.createElement(eD, {
    key: "custom",
    title: "custom-commands"
  }, h6.createElement(JF0, {
    commands: X,
    maxHeight: G,
    title: "Browse custom commands:",
    emptyMessage: "No custom commands found",
    onCancel: Z
  }))), h6.createElement(S, {
    flexDirection: "column",
    height: G
  }, h6.createElement(D3, {
    dividerColor: "professionalBlue"
  }), h6.createElement(S, {
    paddingX: 1,
    flexDirection: "column"
  }, h6.createElement(Na, {
    title: `Claude Code v${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION}`,
    color: "professionalBlue",
    defaultTab: "general"
  }, V), h6.createElement(S, {
    marginTop: 1
  }, h6.createElement($, null, "For more help:", " ", h6.createElement(h4, {
    url: "https://code.claude.com/docs/en/overview"
  }))), h6.createElement(S, {
    marginTop: 1
  }, h6.createElement($, {
    dimColor: !0
  }, I.pending ? h6.createElement(h6.Fragment, null, "Press ", I.keyName, " again to exit") : h6.createElement($, {
    italic: !0
  }, "Esc to exit")))))
}
// @from(Start 14042606, End 14042608)
h6
// @from(Start 14042614, End 14042726)
_F9 = L(() => {
  hA();
  BK();
  FSA();
  TF9();
  jF9();
  cE();
  i8();
  Q4();
  hA();
  h6 = BA(VA(), 1)
})
// @from(Start 14042732, End 14042735)
WF0
// @from(Start 14042737, End 14042740)
sy3
// @from(Start 14042742, End 14042745)
kF9
// @from(Start 14042751, End 14043176)
yF9 = L(() => {
  _F9();
  WF0 = BA(VA(), 1), sy3 = {
    type: "local-jsx",
    name: "help",
    description: "Show help and available commands",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, {
      options: {
        commands: Q
      }
    }) {
      return WF0.createElement(SF9, {
        commands: Q,
        onClose: A
      })
    },
    userFacingName() {
      return "help"
    }
  }, kF9 = sy3
})
// @from(Start 14043179, End 14044588)
function xF9({
  onComplete: A
}) {
  let Q = EQ(),
    B = Iz.useCallback(async (Z) => {
      let I = Z === "yes",
        Y = N1();
      c0({
        ...Y,
        autoConnectIde: I,
        hasIdeAutoConnectDialogBeenShown: !0
      }), A()
    }, [A]);
  return f1((Z, I) => {
    if (I.escape) A()
  }), Iz.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, Iz.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "ide",
    paddingX: 2,
    paddingY: 1,
    width: "100%"
  }, Iz.default.createElement(S, {
    marginBottom: 1
  }, Iz.default.createElement($, {
    color: "ide"
  }, "Do you wish to enable auto-connect to IDE?")), Iz.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, Iz.default.createElement(M0, {
    options: [{
      label: "Yes",
      value: "yes"
    }, {
      label: "No",
      value: "no"
    }],
    onChange: B,
    defaultValue: "yes",
    onCancel: () => A()
  })), Iz.default.createElement(S, {
    marginTop: 1
  }, Iz.default.createElement($, {
    dimColor: !0
  }, "You can also configure this in /config or with the --ide flag"))), Iz.default.createElement(S, {
    paddingX: 1
  }, Iz.default.createElement($, {
    dimColor: !0
  }, Q.pending ? Iz.default.createElement(Iz.default.Fragment, null, "Press ", Q.keyName, " again to exit") : "Enter to confirm")))
}
// @from(Start 14044590, End 14044711)
function vF9() {
  let A = N1();
  return !bV() && A.autoConnectIde !== !0 && A.hasIdeAutoConnectDialogBeenShown !== !0
}
// @from(Start 14044716, End 14044718)
Iz
// @from(Start 14044724, End 14044809)
bF9 = L(() => {
  hA();
  jQ();
  hA();
  J5();
  Q4();
  nY();
  Iz = BA(VA(), 1)
})
// @from(Start 14044841, End 14047983)
function ry3({
  availableIDEs: A,
  unavailableIDEs: Q,
  selectedIDE: B,
  onClose: G,
  onSelect: Z
}) {
  let I = EQ(),
    [Y, J] = q4.useState(B?.port?.toString() ?? "None"),
    [W, X] = q4.useState(!1),
    V = q4.useCallback((D) => {
      if (D !== "None" && vF9()) X(!0);
      else Z(A.find((H) => H.port === parseInt(D)))
    }, [A, Z]),
    F = A.reduce((D, H) => {
      return D[H.name] = (D[H.name] || 0) + 1, D
    }, {}),
    K = A.map((D) => {
      let C = (F[D.name] || 0) > 1 && D.workspaceFolders.length > 0;
      return {
        label: D.name,
        value: D.port.toString(),
        description: C ? fF9(D.workspaceFolders) : void 0
      }
    }).concat([{
      label: "None",
      value: "None",
      description: void 0
    }]);
  return f1((D, H) => {
    if (H.escape) G()
  }), W ? q4.default.createElement(xF9, {
    onComplete: () => V(Y)
  }) : q4.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, q4.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "ide",
    paddingX: 2,
    paddingY: 1,
    width: "100%"
  }, q4.default.createElement(S, {
    flexDirection: "column"
  }, q4.default.createElement($, {
    color: "ide",
    bold: !0
  }, "Select IDE"), q4.default.createElement($, {
    dimColor: !0
  }, "Connect to an IDE for integrated development features."), A.length === 0 && q4.default.createElement(S, {
    marginTop: 1
  }, q4.default.createElement($, {
    dimColor: !0
  }, DLA() ? `No available IDEs detected. Please install the plugin and restart your IDE:
https://docs.claude.com/s/claude-code-jetbrains` : "No available IDEs detected. Make sure your IDE has the Claude Code extension or plugin installed and is running."))), A.length !== 0 && q4.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    marginTop: 1
  }, q4.default.createElement(M0, {
    defaultValue: Y,
    focusValue: Y,
    options: K,
    onFocus: (D) => J(D),
    onChange: (D) => {
      J(D), V(D)
    },
    onCancel: () => G()
  })), A.length !== 0 && !bV() && q4.default.createElement(S, {
    marginTop: 1
  }, q4.default.createElement($, {
    dimColor: !0
  }, "※ Tip: You can enable auto-connect to IDE in /config or with the --ide flag")), Q.length > 0 && q4.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, q4.default.createElement($, {
    dimColor: !0
  }, "Found ", Q.length, " other running IDE(s). However, their workspace/project directories do not match the current cwd."), q4.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, Q.map((D, H) => q4.default.createElement(S, {
    key: H,
    paddingLeft: 3
  }, q4.default.createElement($, {
    dimColor: !0
  }, "• ", D.name, ": ", fF9(D.workspaceFolders))))))), q4.default.createElement(S, {
    paddingX: 1
  }, q4.default.createElement($, {
    dimColor: !0
  }, I.pending ? q4.default.createElement(q4.default.Fragment, null, "Press ", I.keyName, " again to exit") : q4.default.createElement(q4.default.Fragment, null, A.length !== 0 && "Enter to confirm · ", "Esc to exit"))))
}
// @from(Start 14047984, End 14048168)
async function oy3(A, Q) {
  let B = Q?.ide;
  if (!B || B.type !== "sse-ide" && B.type !== "ws-ide") return null;
  for (let G of A)
    if (G.url === B.url) return G;
  return null
}
// @from(Start 14048170, End 14049519)
function ty3({
  runningIDEs: A,
  onSelectIDE: Q,
  onDone: B
}) {
  let G = EQ(),
    [Z, I] = q4.useState(A[0] ?? ""),
    Y = q4.useCallback((W) => {
      Q(W)
    }, [Q]),
    J = A.map((W) => ({
      label: aF(W),
      value: W
    }));
  return f1((W, X) => {
    if (X.escape) B("IDE selection cancelled", {
      display: "system"
    })
  }), q4.default.createElement(q4.default.Fragment, null, q4.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "ide",
    marginTop: 1,
    paddingX: 2,
    paddingY: 1,
    width: "100%"
  }, q4.default.createElement(S, {
    marginBottom: 1
  }, q4.default.createElement($, {
    color: "ide"
  }, "Select IDE to install extension:")), q4.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, q4.default.createElement(M0, {
    focusValue: Z,
    options: J,
    onFocus: (W) => I(W),
    onChange: (W) => {
      I(W), Y(W)
    },
    onCancel: () => B("IDE selection cancelled", {
      display: "system"
    })
  }))), q4.default.createElement(S, {
    paddingLeft: 3
  }, q4.default.createElement($, {
    dimColor: !0
  }, G.pending ? q4.default.createElement(q4.default.Fragment, null, "Press ", G.keyName, " again to exit") : q4.default.createElement(q4.default.Fragment, null, "Enter to confirm · Esc to cancel"))))
}
// @from(Start 14049521, End 14049953)
function fF9(A, Q = 100) {
  if (A.length === 0) return "";
  let B = W0(),
    G = A.slice(0, 2),
    Z = A.length > 2,
    I = Z ? 3 : 0,
    Y = (G.length - 1) * 2,
    J = Q - Y - I,
    W = Math.floor(J / G.length),
    V = G.map((F) => {
      if (F.startsWith(B + hF9.sep)) F = F.slice(B.length + 1);
      if (F.length <= W) return F;
      return "…" + F.slice(-(W - 1))
    }).join(", ");
  if (Z) V += ", …";
  return V
}
// @from(Start 14049958, End 14049960)
q4
// @from(Start 14049962, End 14049965)
ey3
// @from(Start 14049967, End 14049970)
gF9
// @from(Start 14049976, End 14052586)
uF9 = L(() => {
  hA();
  J5();
  bF9();
  nY();
  q0();
  Q4();
  ijA();
  U2();
  _8();
  F9();
  q4 = BA(VA(), 1);
  ey3 = {
    type: "local-jsx",
    name: "ide",
    description: "Manage IDE integrations and show status",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[open]",
    async call(A, Q, B) {
      GA("tengu_ext_ide_command", {});
      let {
        options: {
          dynamicMcpConfig: G
        },
        onChangeDynamicMcpConfig: Z
      } = Q, I = await HLA(!0);
      if (I.length === 0 && Q.onInstallIDEExtension && !bV()) {
        let V = _Q1(),
          F = (K) => {
            if (Q.onInstallIDEExtension)
              if (Q.onInstallIDEExtension(K), oT(K)) A(`Installed plugin to ${tA.bold(aF(K))}
Please ${tA.bold("restart your IDE")} completely for it to take effect`);
              else A(`Installed extension to ${tA.bold(aF(K))}`)
          };
        if (V.length > 1) return q4.default.createElement(ty3, {
          runningIDEs: V,
          onSelectIDE: F,
          onDone: () => {
            A("No IDE selected.", {
              display: "system"
            })
          }
        });
        else if (V.length === 1) {
          let K = V[0];
          return q4.default.createElement(() => {
            return q4.useEffect(() => {
              F(K)
            }, []), null
          }, null)
        }
      }
      let Y = I.filter((V) => V.isValid),
        J = I.filter((V) => !V.isValid),
        W = await oy3(Y, G);
      return q4.default.createElement(ry3, {
        availableIDEs: Y,
        unavailableIDEs: J,
        selectedIDE: W,
        onClose: () => A("IDE selection cancelled", {
          display: "system"
        }),
        onSelect: async (V) => {
          try {
            if (!Z) {
              A("Error connecting to IDE.");
              return
            }
            let F = {
              ...G || {}
            };
            if (W) delete F.ide;
            if (!V) A(W ? `Disconnected from ${W.name}.` : "No IDE selected.");
            else {
              let K = V.url;
              F.ide = {
                type: K.startsWith("ws:") ? "ws-ide" : "sse-ide",
                url: K,
                ideName: V.name,
                authToken: V.authToken,
                ideRunningInWindows: V.ideRunningInWindows,
                scope: "dynamic"
              }, A(`Connected to ${V.name}.`)
            }
            Z(F)
          } catch (F) {
            A("Error connecting to IDE.")
          }
        }
      })
    },
    userFacingName() {
      return "ide"
    }
  }, gF9 = ey3
})
// @from(Start 14052592, End 14052595)
Ax3
// @from(Start 14052597, End 14052600)
mF9
// @from(Start 14052606, End 14054649)
dF9 = L(() => {
  N$A();
  Ax3 = {
    type: "prompt",
    name: "init",
    description: "Initialize a new CLAUDE.md file with codebase documentation",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "analyzing your codebase",
    userFacingName() {
      return "init"
    },
    source: "builtin",
    async getPromptForCommand() {
      return n7A(), [{
        type: "text",
        text: `Please analyze this codebase and create a CLAUDE.md file, which will be given to future instances of Claude Code to operate in this repository.

What to add:
1. Commands that will be commonly used, such as how to build, lint, and run tests. Include the necessary commands to develop in this codebase, such as how to run a single test.
2. High-level code architecture and structure so that future instances can be productive more quickly. Focus on the "big picture" architecture that requires reading multiple files to understand.

Usage notes:
- If there's already a CLAUDE.md, suggest improvements to it.
- When you make the initial CLAUDE.md, do not repeat yourself and do not include obvious instructions like "Provide helpful error messages to users", "Write unit tests for all new utilities", "Never include sensitive information (API keys, tokens) in code or commits".
- Avoid listing every component or file structure that can be easily discovered.
- Don't include generic development practices.
- If there are Cursor rules (in .cursor/rules/ or .cursorrules) or Copilot rules (in .github/copilot-instructions.md), make sure to include the important parts.
- If there is a README.md, make sure to include the important parts.
- Do not make up information such as "Common Development Tasks", "Tips for Development", "Support and Documentation" unless this is expressly included in other files that you read.
- Be sure to prefix the file with the following text:

\`\`\`
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
\`\`\``
      }]
    }
  }, mF9 = Ax3
})
// @from(Start 14054652, End 14054751)
function pF9() {
  return cF9.default.createElement($, null, "Checking GitHub CLI installation…")
}
// @from(Start 14054756, End 14054759)
cF9
// @from(Start 14054765, End 14054811)
lF9 = L(() => {
  hA();
  cF9 = BA(VA(), 1)
})
// @from(Start 14054814, End 14056823)
function iF9({
  currentRepo: A,
  useCurrentRepo: Q,
  repoUrl: B,
  onRepoUrlChange: G,
  onSubmit: Z,
  onToggleUseCurrentRepo: I
}) {
  let [Y, J] = WV.useState(0), [W, X] = WV.useState(!1), F = WB().columns, K = () => {
    if (!(Q ? A : B)?.trim()) {
      X(!0);
      return
    }
    Z()
  };
  return f1((D, H) => {
    if (H.upArrow) I(!0), X(!1);
    else if (H.downArrow) I(!1), X(!1);
    else if (H.return) K()
  }), WV.default.createElement(WV.default.Fragment, null, WV.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, WV.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, WV.default.createElement($, {
    bold: !0
  }, "Install GitHub App"), WV.default.createElement($, {
    dimColor: !0
  }, "Select GitHub repository")), A && WV.default.createElement(S, {
    marginBottom: 1
  }, WV.default.createElement($, {
    bold: Q,
    color: Q ? "permission" : void 0
  }, Q ? "> " : "  ", "Use current repository: ", A)), WV.default.createElement(S, {
    marginBottom: 1
  }, WV.default.createElement($, {
    bold: !Q || !A,
    color: !Q || !A ? "permission" : void 0
  }, !Q || !A ? "> " : "  ", A ? "Enter a different repository" : "Enter repository")), (!Q || !A) && WV.default.createElement(S, {
    marginLeft: 2,
    marginBottom: 1
  }, WV.default.createElement(s4, {
    value: B,
    onChange: (D) => {
      G(D), X(!1)
    },
    onSubmit: K,
    focus: !0,
    placeholder: "Enter a repo as owner/repo or https://github.com/owner/repo…",
    columns: F,
    cursorOffset: Y,
    onChangeCursorOffset: J,
    showCursor: !0
  }))), W && WV.default.createElement(S, {
    marginLeft: 3,
    marginBottom: 1
  }, WV.default.createElement($, {
    color: "error"
  }, "Please enter a repository name to continue")), WV.default.createElement(S, {
    marginLeft: 3
  }, WV.default.createElement($, {
    dimColor: !0
  }, A ? "↑/↓ to select · " : "", "Enter to continue")))
}
// @from(Start 14056828, End 14056830)
WV
// @from(Start 14056836, End 14056897)
nF9 = L(() => {
  hA();
  ZY();
  i8();
  WV = BA(VA(), 1)
})
// @from(Start 14056903, End 14056942)
aF9 = "Add Claude Code GitHub Workflow"
// @from(Start 14056946, End 14057025)
Cx = "https://github.com/anthropics/claude-code-action/blob/main/docs/setup.md"
// @from(Start 14057029, End 14058912)
sF9 = `name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}

          # This is an optional setting that allows Claude to read CI results on PRs
          additional_permissions: |
            actions: read

          # Optional: Give a custom prompt to Claude. If this is not specified, Claude will perform the instructions specified in the comment that tagged it.
          # prompt: 'Update the pull request description to include a summary of changes.'

          # Optional: Add claude_args to customize behavior and configuration
          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://code.claude.com/docs/en/cli-reference for available options
          # claude_args: '--allowed-tools Bash(gh pr:*)'

`
// @from(Start 14058916, End 14060682)
rF9 = `## \uD83E\uDD16 Installing Claude Code GitHub App

This PR adds a GitHub Actions workflow that enables Claude Code integration in our repository.

### What is Claude Code?

[Claude Code](https://claude.com/claude-code) is an AI coding agent that can help with:
- Bug fixes and improvements  
- Documentation updates
- Implementing new features
- Code reviews and suggestions
- Writing tests
- And more!

### How it works

Once this PR is merged, we'll be able to interact with Claude by mentioning @claude in a pull request or issue comment.
Once the workflow is triggered, Claude will analyze the comment and surrounding context, and execute on the request in a GitHub action.

### Important Notes

- **This workflow won't take effect until this PR is merged**
- **@claude mentions won't work until after the merge is complete**
- The workflow runs automatically whenever Claude is mentioned in PR or issue comments
- Claude gets access to the entire PR or issue context including files, diffs, and previous comments

### Security

- Our Anthropic API key is securely stored as a GitHub Actions secret
- Only users with write access to the repository can trigger the workflow
- All Claude runs are stored in the GitHub Actions run history
- Claude's default tools are limited to reading/writing files and interacting with our repo by creating comments, branches, and commits.
- We can add more allowed tools by adding them to the workflow file like:

\`\`\`
allowed_tools: Bash(npm install),Bash(npm run build),Bash(npm run lint),Bash(npm run test)
\`\`\`

There's more information in the [Claude Code action repo](https://github.com/anthropics/claude-code-action).

After merging this PR, let's try mentioning @claude in a comment on any PR to get started!`
// @from(Start 14060686, End 14062639)
oF9 = `name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'

    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}
          prompt: |
            REPO: \${{ github.repository }}
            PR NUMBER: \${{ github.event.pull_request.number }}

            Please review this pull request and provide feedback on:
            - Code quality and best practices
            - Potential bugs or issues
            - Performance considerations
            - Security concerns
            - Test coverage

            Use the repository's CLAUDE.md for guidance on style and conventions. Be constructive and helpful in your feedback.

            Use \`gh pr comment\` with your Bash tool to leave your review as a comment on the PR.

          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://code.claude.com/docs/en/cli-reference for available options
          claude_args: '--allowed-tools "Bash(gh issue view:*),Bash(gh search:*),Bash(gh issue list:*),Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh pr list:*)"'

`
// @from(Start 14062643, End 14064075)
tF9 = `name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'

    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: \${{ secrets.ANTHROPIC_API_KEY }}
          plugin_marketplaces: 'https://github.com/anthropics/claude-code.git'
          plugins: 'code-review@claude-code-plugins'
          prompt: '/code-review:code-review \${{ github.repository }}/pull/\${{ github.event.pull_request.number }}'
          # See https://github.com/anthropics/claude-code-action/blob/main/docs/usage.md
          # or https://code.claude.com/docs/en/cli-reference for available options

`
// @from(Start 14064078, End 14065663)
function eF9({
  repoUrl: A,
  onSubmit: Q
}) {
  return f1((B, G) => {
    if (G.return) Q()
  }), XV.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, XV.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, XV.default.createElement($, {
    bold: !0
  }, "Install the Claude GitHub App")), XV.default.createElement(S, {
    marginBottom: 1
  }, XV.default.createElement($, null, "Opening browser to install the Claude GitHub App…")), XV.default.createElement(S, {
    marginBottom: 1
  }, XV.default.createElement($, null, "If your browser doesn't open automatically, visit:")), XV.default.createElement(S, {
    marginBottom: 1
  }, XV.default.createElement($, {
    underline: !0
  }, "https://github.com/apps/claude")), XV.default.createElement(S, {
    marginBottom: 1
  }, XV.default.createElement($, null, "Please install the app for repository: ", XV.default.createElement($, {
    bold: !0
  }, A))), XV.default.createElement(S, {
    marginBottom: 1
  }, XV.default.createElement($, {
    dimColor: !0
  }, "Important: Make sure to grant access to this specific repository")), XV.default.createElement(S, null, XV.default.createElement($, {
    bold: !0,
    color: "permission"
  }, "Press Enter once you've installed the app", H1.ellipsis)), XV.default.createElement(S, {
    marginTop: 1
  }, XV.default.createElement($, {
    dimColor: !0
  }, "Having trouble? See manual setup instructions at:", " ", XV.default.createElement($, {
    color: "claude"
  }, Cx))))
}
// @from(Start 14065668, End 14065670)
XV
// @from(Start 14065676, End 14065729)
AK9 = L(() => {
  hA();
  V9();
  XV = BA(VA(), 1)
})
// @from(Start 14065732, End 14067647)
function QK9({
  useExistingSecret: A,
  secretName: Q,
  onToggleUseExistingSecret: B,
  onSecretNameChange: G,
  onSubmit: Z
}) {
  let [I, Y] = UY.useState(0), J = WB(), [W] = qB();
  return f1((X, V) => {
    if (V.upArrow) B(!0);
    else if (V.downArrow) B(!1);
    else if (V.return) Z()
  }), UY.default.createElement(UY.default.Fragment, null, UY.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, UY.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, UY.default.createElement($, {
    bold: !0
  }, "Install GitHub App"), UY.default.createElement($, {
    dimColor: !0
  }, "Setup API key secret")), UY.default.createElement(S, {
    marginBottom: 1
  }, UY.default.createElement($, {
    color: "warning"
  }, "ANTHROPIC_API_KEY already exists in repository secrets!")), UY.default.createElement(S, {
    marginBottom: 1
  }, UY.default.createElement($, null, "Would you like to:")), UY.default.createElement(S, {
    marginBottom: 1
  }, UY.default.createElement($, null, A ? ZB("success", W)("> ") : "  ", "Use the existing API key")), UY.default.createElement(S, {
    marginBottom: 1
  }, UY.default.createElement($, null, !A ? ZB("success", W)("> ") : "  ", "Create a new secret with a different name")), !A && UY.default.createElement(UY.default.Fragment, null, UY.default.createElement(S, {
    marginBottom: 1
  }, UY.default.createElement($, null, "Enter new secret name (alphanumeric with underscores):")), UY.default.createElement(s4, {
    value: Q,
    onChange: G,
    onSubmit: Z,
    focus: !0,
    placeholder: "e.g., CLAUDE_API_KEY",
    columns: J.columns,
    cursorOffset: I,
    onChangeCursorOffset: Y,
    showCursor: !0
  }))), UY.default.createElement(S, {
    marginLeft: 3
  }, UY.default.createElement($, {
    dimColor: !0
  }, "↑/↓ to select · Enter to continue")))
}
// @from(Start 14067652, End 14067654)
UY
// @from(Start 14067660, End 14067721)
BK9 = L(() => {
  hA();
  ZY();
  i8();
  UY = BA(VA(), 1)
})
// @from(Start 14067724, End 14069806)
function GK9({
  existingApiKey: A,
  apiKeyOrOAuthToken: Q,
  onApiKeyChange: B,
  onSubmit: G,
  onToggleUseExistingKey: Z,
  onCreateOAuthToken: I,
  selectedOption: Y = A ? "existing" : I ? "oauth" : "new",
  onSelectOption: J
}) {
  let [W, X] = MK.useState(0), V = WB(), [F] = qB();
  return f1((K, D) => {
    if (D.upArrow) {
      if (Y === "new" && I) J?.("oauth");
      else if (Y === "oauth" && A) J?.("existing"), Z(!0)
    } else if (D.downArrow) {
      if (Y === "existing") J?.(I ? "oauth" : "new"), Z(!1);
      else if (Y === "oauth") J?.("new")
    }
    if (D.return)
      if (Y === "oauth" && I) I();
      else G()
  }), MK.default.createElement(MK.default.Fragment, null, MK.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, MK.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, MK.default.createElement($, {
    bold: !0
  }, "Install GitHub App"), MK.default.createElement($, {
    dimColor: !0
  }, "Choose API key")), A && MK.default.createElement(S, {
    marginBottom: 1
  }, MK.default.createElement($, null, Y === "existing" ? ZB("success", F)("> ") : "  ", "Use your existing Claude Code API key")), I && MK.default.createElement(S, {
    marginBottom: 1
  }, MK.default.createElement($, null, Y === "oauth" ? ZB("success", F)("> ") : "  ", "Create a long-lived token with your Claude subscription")), MK.default.createElement(S, {
    marginBottom: 1
  }, MK.default.createElement($, null, Y === "new" ? ZB("success", F)("> ") : "  ", "Enter a new API key")), Y === "new" && MK.default.createElement(s4, {
    value: Q,
    onChange: B,
    onSubmit: G,
    onPaste: B,
    focus: !0,
    placeholder: "sk-ant… (Create a new key at https://console.anthropic.com/settings/keys)",
    mask: "*",
    columns: V.columns,
    cursorOffset: W,
    onChangeCursorOffset: X,
    showCursor: !0
  })), MK.default.createElement(S, {
    marginLeft: 3
  }, MK.default.createElement($, {
    dimColor: !0
  }, "↑/↓ to select · Enter to continue")))
}
// @from(Start 14069811, End 14069813)
MK
// @from(Start 14069819, End 14069880)
ZK9 = L(() => {
  hA();
  ZY();
  i8();
  MK = BA(VA(), 1)
})
// @from(Start 14069883, End 14071192)
function IK9({
  currentWorkflowInstallStep: A,
  secretExists: Q,
  useExistingSecret: B,
  secretName: G,
  skipWorkflow: Z = !1,
  selectedWorkflows: I
}) {
  let Y = Z ? ["Getting repository information", Q && B ? "Using existing API key secret" : `Setting up ${G} secret`] : ["Getting repository information", "Creating branch", I.length > 1 ? "Creating workflow files" : "Creating workflow file", Q && B ? "Using existing API key secret" : `Setting up ${G} secret`, "Opening pull request page"];
  return ag.default.createElement(ag.default.Fragment, null, ag.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, ag.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, ag.default.createElement($, {
    bold: !0
  }, "Install GitHub App"), ag.default.createElement($, {
    dimColor: !0
  }, "Create GitHub Actions workflow")), Y.map((J, W) => {
    let X = "pending";
    if (W < A) X = "completed";
    else if (W === A) X = "in-progress";
    return ag.default.createElement(S, {
      key: W
    }, ag.default.createElement($, {
      color: X === "completed" ? "success" : X === "in-progress" ? "warning" : void 0
    }, X === "completed" ? "✓ " : "", J, X === "in-progress" ? "…" : ""))
  })))
}
// @from(Start 14071197, End 14071199)
ag
// @from(Start 14071205, End 14071250)
YK9 = L(() => {
  hA();
  ag = BA(VA(), 1)
})
// @from(Start 14071253, End 14073053)
function JK9({
  secretExists: A,
  useExistingSecret: Q,
  secretName: B,
  skipWorkflow: G = !1
}) {
  return oZ.default.createElement(oZ.default.Fragment, null, oZ.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, oZ.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, oZ.default.createElement($, {
    bold: !0
  }, "Install GitHub App"), oZ.default.createElement($, {
    dimColor: !0
  }, "Success")), !G && oZ.default.createElement($, {
    color: "success"
  }, "✓ GitHub Actions workflow created!"), A && Q && oZ.default.createElement(S, {
    marginTop: 1
  }, oZ.default.createElement($, {
    color: "success"
  }, "✓ Using existing ANTHROPIC_API_KEY secret")), (!A || !Q) && oZ.default.createElement(S, {
    marginTop: 1
  }, oZ.default.createElement($, {
    color: "success"
  }, "✓ API key saved as ", B, " secret")), oZ.default.createElement(S, {
    marginTop: 1
  }, oZ.default.createElement($, null, "Next steps:")), G ? oZ.default.createElement(oZ.default.Fragment, null, oZ.default.createElement($, null, "1. Install the Claude GitHub App if you haven't already"), oZ.default.createElement($, null, "2. Your workflow file was kept unchanged"), oZ.default.createElement($, null, "3. API key is configured and ready to use")) : oZ.default.createElement(oZ.default.Fragment, null, oZ.default.createElement($, null, "1. A pre-filled PR page has been created"), oZ.default.createElement($, null, "2. Install the Claude GitHub App if you haven't already"), oZ.default.createElement($, null, "3. Merge the PR to enable Claude PR assistance"))), oZ.default.createElement(S, {
    marginLeft: 3
  }, oZ.default.createElement($, {
    dimColor: !0
  }, "Press any key to exit")))
}
// @from(Start 14073058, End 14073060)
oZ
// @from(Start 14073066, End 14073111)
WK9 = L(() => {
  hA();
  oZ = BA(VA(), 1)
})
// @from(Start 14073114, End 14074424)
function XK9({
  error: A,
  errorReason: Q,
  errorInstructions: B
}) {
  return tV.default.createElement(tV.default.Fragment, null, tV.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, tV.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, tV.default.createElement($, {
    bold: !0
  }, "Install GitHub App")), tV.default.createElement($, {
    color: "error"
  }, "Error: ", A), Q && tV.default.createElement(S, {
    marginTop: 1
  }, tV.default.createElement($, {
    dimColor: !0
  }, "Reason: ", Q)), B && B.length > 0 && tV.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, tV.default.createElement($, {
    dimColor: !0
  }, "How to fix:"), B.map((G, Z) => tV.default.createElement(S, {
    key: Z,
    marginLeft: 2
  }, tV.default.createElement($, {
    dimColor: !0
  }, "• "), tV.default.createElement($, null, G)))), tV.default.createElement(S, {
    marginTop: 1
  }, tV.default.createElement($, {
    dimColor: !0
  }, "For manual setup instructions, see:", " ", tV.default.createElement($, {
    color: "claude"
  }, Cx)))), tV.default.createElement(S, {
    marginLeft: 3
  }, tV.default.createElement($, {
    dimColor: !0
  }, "Press any key to exit")))
}
// @from(Start 14074429, End 14074431)
tV
// @from(Start 14074437, End 14074482)
VK9 = L(() => {
  hA();
  tV = BA(VA(), 1)
})
// @from(Start 14074485, End 14075996)
function FK9({
  repoName: A,
  onSelectAction: Q
}) {
  return S$.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, S$.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, S$.default.createElement($, {
    bold: !0
  }, "Existing Workflow Found"), S$.default.createElement($, {
    dimColor: !0
  }, "Repository: ", A)), S$.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, S$.default.createElement($, null, "A Claude workflow file already exists at", " ", S$.default.createElement($, {
    color: "claude"
  }, ".github/workflows/claude.yml")), S$.default.createElement($, {
    dimColor: !0
  }, "What would you like to do?")), S$.default.createElement(S, {
    flexDirection: "column"
  }, S$.default.createElement(M0, {
    options: [{
      label: "Update workflow file with latest version",
      value: "update"
    }, {
      label: "Skip workflow update (configure secrets only)",
      value: "skip"
    }, {
      label: "Exit without making changes",
      value: "exit"
    }],
    onChange: (I) => {
      Q(I)
    },
    onCancel: () => {
      Q("exit")
    }
  })), S$.default.createElement(S, {
    marginTop: 1
  }, S$.default.createElement($, {
    dimColor: !0
  }, "View the latest workflow template at:", " ", S$.default.createElement($, {
    color: "claude"
  }, "https://github.com/anthropics/claude-code-action/blob/main/examples/claude.yml"))))
}
// @from(Start 14076001, End 14076003)
S$
// @from(Start 14076009, End 14076062)
KK9 = L(() => {
  hA();
  J5();
  S$ = BA(VA(), 1)
})
// @from(Start 14076065, End 14077527)
function DK9({
  warnings: A,
  onContinue: Q
}) {
  return f1((B, G) => {
    if (G.return) Q()
  }), AH.default.createElement(AH.default.Fragment, null, AH.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1
  }, AH.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, AH.default.createElement($, {
    bold: !0
  }, H1.warning, " Setup Warnings"), AH.default.createElement($, {
    dimColor: !0
  }, "We found some potential issues, but you can continue anyway")), A.map((B, G) => AH.default.createElement(S, {
    key: G,
    flexDirection: "column",
    marginBottom: 1
  }, AH.default.createElement($, {
    color: "warning",
    bold: !0
  }, B.title), AH.default.createElement($, null, B.message), B.instructions.length > 0 && AH.default.createElement(S, {
    flexDirection: "column",
    marginLeft: 2,
    marginTop: 1
  }, B.instructions.map((Z, I) => AH.default.createElement($, {
    key: I,
    dimColor: !0
  }, "• ", Z))))), AH.default.createElement(S, {
    marginTop: 1
  }, AH.default.createElement($, {
    bold: !0,
    color: "permission"
  }, "Press Enter to continue anyway, or Ctrl+C to exit and fix issues")), AH.default.createElement(S, {
    marginTop: 1
  }, AH.default.createElement($, {
    dimColor: !0
  }, "You can also try the manual setup steps if needed:", " ", AH.default.createElement($, {
    color: "claude"
  }, Cx)))))
}
// @from(Start 14077532, End 14077534)
AH
// @from(Start 14077540, End 14077593)
HK9 = L(() => {
  hA();
  V9();
  AH = BA(VA(), 1)
})
// @from(Start 14077596, End 14080255)
function CK9({
  onSubmit: A,
  defaultSelections: Q
}) {
  let [B, G] = OI.useState(new Set(Q)), [Z, I] = OI.useState(0), [Y, J] = OI.useState(!1), W = [{
    value: "claude",
    label: "@Claude Code",
    description: "Tag @claude in issues and PR comments"
  }, {
    value: "claude-review",
    label: "Claude Code Review",
    description: "Automated code review on new PRs"
  }];
  return f1((X, V) => {
    if (V.upArrow) I((F) => F > 0 ? F - 1 : W.length - 1), J(!1);
    else if (V.downArrow) I((F) => F < W.length - 1 ? F + 1 : 0), J(!1);
    else if (X === " ") {
      let F = W[Z]?.value;
      if (F) G((K) => {
        let D = new Set(K);
        if (D.has(F)) D.delete(F);
        else D.add(F);
        return D
      })
    } else if (V.return)
      if (B.size === 0) J(!0);
      else A(Array.from(B))
  }), OI.default.createElement(OI.default.Fragment, null, OI.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderDimColor: !0,
    paddingX: 1,
    width: "100%"
  }, OI.default.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, OI.default.createElement($, {
    bold: !0
  }, "Select GitHub workflows to install"), OI.default.createElement($, {
    dimColor: !0
  }, "We'll create a workflow file in your repository for each one you select."), OI.default.createElement(S, {
    marginTop: 1
  }, OI.default.createElement($, {
    dimColor: !0
  }, "More workflow examples (issue triage, CI fixes, etc.) at:", " ", OI.default.createElement(h4, {
    url: "https://github.com/anthropics/claude-code-action/blob/main/examples/"
  }, "https://github.com/anthropics/claude-code-action/blob/main/examples/")))), OI.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, W.map((X, V) => {
    let F = B.has(X.value),
      K = V === Z;
    return OI.default.createElement(S, {
      key: X.value,
      flexDirection: "row",
      marginBottom: V < W.length - 1 ? 1 : 0
    }, OI.default.createElement(S, {
      marginRight: 1,
      minWidth: 2
    }, OI.default.createElement($, {
      bold: K
    }, F ? "✓" : " ")), OI.default.createElement(S, {
      flexDirection: "column"
    }, OI.default.createElement($, {
      bold: K
    }, X.label), OI.default.createElement($, {
      dimColor: !0
    }, X.description)))
  }))), OI.default.createElement(S, {
    marginLeft: 2
  }, OI.default.createElement($, {
    dimColor: !0
  }, "↑↓ Navigate · Space to toggle · Enter to confirm")), Y && OI.default.createElement(S, {
    marginLeft: 1
  }, OI.default.createElement($, {
    color: "error"
  }, "You must select at least one workflow to continue")))
}
// @from(Start 14080260, End 14080262)
OI
// @from(Start 14080268, End 14080321)
EK9 = L(() => {
  hA();
  hA();
  OI = BA(VA(), 1)
})
// @from(Start 14080323, End 14081981)
async function Qx3(A, Q, B, G, Z, I, Y) {
  let J = await QQ("gh", ["api", `repos/${A}/contents/${B}`, "--jq", ".sha"]),
    W = null;
  if (J.code === 0) W = J.stdout.trim();
  let X = G;
  if (Z === "CLAUDE_CODE_OAUTH_TOKEN") X = G.replace(/anthropic_api_key: \$\{\{ secrets\.ANTHROPIC_API_KEY \}\}/g, "claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}");
  else if (Z !== "ANTHROPIC_API_KEY") X = G.replace(/anthropic_api_key: \$\{\{ secrets\.ANTHROPIC_API_KEY \}\}/g, `anthropic_api_key: \${{ secrets.${Z} }}`);
  let V = Buffer.from(X).toString("base64"),
    F = ["api", "--method", "PUT", `repos/${A}/contents/${B}`, "-f", `message=${W?`"Update ${I}"`:`"${I}"`}`, "-f", `content=${V}`, "-f", `branch=${Q}`];
  if (W) F.push("-f", `sha=${W}`);
  let K = await QQ("gh", F);
  if (K.code !== 0) {
    if (K.stderr.includes("422") && K.stderr.includes("sha")) throw GA("tengu_setup_github_actions_failed", {
      reason: "failed_to_create_workflow_file",
      exit_code: K.code,
      ...Y
    }), Error(`Failed to create workflow file ${B}: A Claude workflow file already exists in this repository. Please remove it first or update it manually.`);
    GA("tengu_setup_github_actions_failed", {
      reason: "failed_to_create_workflow_file",
      exit_code: K.code,
      ...Y
    });
    let D = `

Need help? Common issues:
` + `• Permission denied → Run: gh auth refresh -h github.com -s repo,workflow
` + `• Not authorized → Ensure you have admin access to the repository
` + "• For manual setup → Visit: https://github.com/anthropics/claude-code-action";
    throw Error(`Failed to create workflow file ${B}: ${K.stderr}${D}`)
  }
}
// @from(Start 14081982, End 14085703)
async function zK9(A, Q, B, G, Z = !1, I, Y, J) {
  try {
    GA("tengu_setup_github_actions_started", {
      skip_workflow: Z,
      has_api_key: !!Q,
      using_default_secret_name: B === "ANTHROPIC_API_KEY",
      selected_claude_workflow: I.includes("claude"),
      selected_claude_review_workflow: I.includes("claude-review"),
      ...J
    });
    let W = await QQ("gh", ["api", `repos/${A}`, "--jq", ".id"]);
    if (W.code !== 0) throw GA("tengu_setup_github_actions_failed", {
      reason: "repo_not_found",
      exit_code: W.code,
      ...J
    }), Error(`Failed to access repository ${A}`);
    let X = await QQ("gh", ["api", `repos/${A}`, "--jq", ".default_branch"]);
    if (X.code !== 0) throw GA("tengu_setup_github_actions_failed", {
      reason: "failed_to_get_default_branch",
      exit_code: X.code,
      ...J
    }), Error(`Failed to get default branch: ${X.stderr}`);
    let V = X.stdout.trim(),
      F = await QQ("gh", ["api", `repos/${A}/git/ref/heads/${V}`, "--jq", ".object.sha"]);
    if (F.code !== 0) throw GA("tengu_setup_github_actions_failed", {
      reason: "failed_to_get_branch_sha",
      exit_code: F.code,
      ...J
    }), Error(`Failed to get branch SHA: ${F.stderr}`);
    let K = F.stdout.trim(),
      D = null;
    if (!Z) {
      G(), D = `add-claude-github-actions-${Date.now()}`;
      let H = await QQ("gh", ["api", "--method", "POST", `repos/${A}/git/refs`, "-f", `ref=refs/heads/${D}`, "-f", `sha=${K}`]);
      if (H.code !== 0) throw GA("tengu_setup_github_actions_failed", {
        reason: "failed_to_create_branch",
        exit_code: H.code,
        ...J
      }), Error(`Failed to create branch: ${H.stderr}`);
      G();
      let C = [];
      if (I.includes("claude")) C.push({
        path: ".github/workflows/claude.yml",
        content: sF9,
        message: "Claude PR Assistant workflow"
      });
      if (I.includes("claude-review")) {
        let E = o2("tengu_gha_plugin_code_review");
        C.push({
          path: ".github/workflows/claude-code-review.yml",
          content: E ? tF9 : oF9,
          message: "Claude Code Review workflow"
        })
      }
      for (let E of C) await Qx3(A, D, E.path, E.content, B, E.message, J)
    }
    if (G(), Q) {
      let H = await QQ("gh", ["secret", "set", B, "--body", Q, "--repo", A]);
      if (H.code !== 0) {
        GA("tengu_setup_github_actions_failed", {
          reason: "failed_to_set_api_key_secret",
          exit_code: H.code,
          ...J
        });
        let C = `

Need help? Common issues:
` + `• Permission denied → Run: gh auth refresh -h github.com -s repo
` + `• Not authorized → Ensure you have admin access to the repository
` + "• For manual setup → Visit: https://github.com/anthropics/claude-code-action";
        throw Error(`Failed to set API key secret: ${H.stderr||"Unknown error"}${C}`)
      }
    }
    if (!Z && D) {
      G();
      let H = `https://github.com/${A}/compare/${V}...${D}?quick_pull=1&title=${encodeURIComponent(aF9)}&body=${encodeURIComponent(rF9)}`;
      await cZ(H)
    }
    GA("tengu_setup_github_actions_completed", {
      skip_workflow: Z,
      has_api_key: !!Q,
      auth_type: Y,
      using_default_secret_name: B === "ANTHROPIC_API_KEY",
      selected_claude_workflow: I.includes("claude"),
      selected_claude_review_workflow: I.includes("claude-review"),
      ...J
    }), c0({
      ...N1(),
      githubActionSetupCount: (N1().githubActionSetupCount ?? 0) + 1
    })
  } catch (W) {
    if (!W || !(W instanceof Error) || !W.message.includes("Failed to")) GA("tengu_setup_github_actions_failed", {
      reason: "unexpected_error",
      ...J
    });
    if (W instanceof Error) AA(W);
    throw W
  }
}
// @from(Start 14085708, End 14085773)
UK9 = L(() => {
  _8();
  gM();
  u2();
  q0();
  g1();
  jQ()
})
// @from(Start 14085776, End 14092028)
function wK9({
  onSuccess: A,
  onCancel: Q
}) {
  let [B, G] = F4.useState({
    state: "starting"
  }), [Z] = F4.useState(() => new KRA), [I, Y] = F4.useState(""), [J, W] = F4.useState(0), [X, V] = F4.useState(!1), F = F4.useRef(new Set), K = WB(), D = Math.max(50, K.columns - $K9.length - 4);
  f1((U, q) => {
    if (B.state === "error")
      if (q.return && B.toRetry) Y(""), W(0), G({
        state: "about_to_retry",
        nextState: B.toRetry
      });
      else Q()
  });
  async function H(U, q) {
    try {
      let [w, N] = U.split("#");
      if (!w || !N) {
        G({
          state: "error",
          message: "Invalid code. Please make sure the full code was copied",
          toRetry: {
            state: "waiting_for_login",
            url: q
          }
        });
        return
      }
      GA("tengu_oauth_manual_entry", {}), Z.handleManualAuthCodeInput({
        authorizationCode: w,
        state: N
      })
    } catch (w) {
      AA(w instanceof Error ? w : Error(String(w))), G({
        state: "error",
        message: w.message,
        toRetry: {
          state: "waiting_for_login",
          url: q
        }
      })
    }
  }
  let C = F4.useCallback(async () => {
    F.current.forEach((U) => clearTimeout(U)), F.current.clear();
    try {
      let U = await Z.startOAuthFlow(async (N) => {
        G({
          state: "waiting_for_login",
          url: N
        });
        let R = setTimeout(() => V(!0), 3000);
        F.current.add(R)
      }, {
        loginWithClaudeAi: !0,
        inferenceOnly: !0,
        expiresIn: 31536000
      });
      if (!gH()) await kJ();
      G({
        state: "processing"
      });
      let q = gzA(U);
      if (q.warning) GA("tengu_oauth_storage_warning", {
        warning: q.warning
      });
      let w = setTimeout(() => {
        G({
          state: "success",
          token: U.accessToken
        });
        let N = setTimeout(() => {
          A(U.accessToken)
        }, 1000);
        F.current.add(N)
      }, 100);
      F.current.add(w)
    } catch (U) {
      let q = U.message;
      if (!gH()) await kJ();
      G({
        state: "error",
        message: q,
        toRetry: {
          state: "starting"
        }
      }), AA(U instanceof Error ? U : Error(String(U))), GA("tengu_oauth_error", {
        error: q
      })
    }
  }, [Z, A]);
  F4.useEffect(() => {
    if (B.state === "starting") C()
  }, [B.state, C]), F4.useEffect(() => {
    if (B.state === "about_to_retry") {
      if (!gH()) kJ();
      let U = setTimeout(() => {
        if (B.nextState.state === "waiting_for_login") V(!0);
        else V(!1);
        G(B.nextState)
      }, 500);
      F.current.add(U)
    }
  }, [B]), F4.useEffect(() => {
    let U = F.current;
    return () => {
      Z.cleanup(), U.forEach((q) => clearTimeout(q)), U.clear()
    }
  }, [Z]);

  function E() {
    switch (B.state) {
      case "starting":
        return F4.default.createElement(S, null, F4.default.createElement(g4, null), F4.default.createElement($, null, "Starting authentication…"));
      case "waiting_for_login":
        return F4.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, !X && F4.default.createElement(S, null, F4.default.createElement(g4, null), F4.default.createElement($, null, "Opening browser to sign in with your Claude account…")), X && F4.default.createElement(S, null, F4.default.createElement($, null, $K9), F4.default.createElement(s4, {
          value: I,
          onChange: Y,
          onSubmit: (U) => H(U, B.url),
          cursorOffset: J,
          onChangeCursorOffset: W,
          columns: D
        })));
      case "processing":
        return F4.default.createElement(S, null, F4.default.createElement(g4, null), F4.default.createElement($, null, "Processing authentication…"));
      case "success":
        return F4.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, F4.default.createElement($, {
          color: "success"
        }, "✓ Authentication token created successfully!"), F4.default.createElement($, {
          dimColor: !0
        }, "Using token for GitHub Actions setup…"));
      case "error":
        return F4.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, F4.default.createElement($, {
          color: "error"
        }, "OAuth error: ", B.message), B.toRetry ? F4.default.createElement($, {
          dimColor: !0
        }, "Press Enter to try again, or any other key to cancel") : F4.default.createElement($, {
          dimColor: !0
        }, "Press any key to return to API key selection"));
      case "about_to_retry":
        return F4.default.createElement(S, {
          flexDirection: "column",
          gap: 1
        }, F4.default.createElement($, {
          color: "permission"
        }, "Retrying…"));
      default:
        return null
    }
  }
  return F4.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, B.state === "starting" && F4.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    paddingBottom: 1
  }, F4.default.createElement($, {
    bold: !0
  }, "Create Authentication Token"), F4.default.createElement($, {
    dimColor: !0
  }, "Creating a long-lived token for GitHub Actions")), B.state !== "success" && B.state !== "starting" && B.state !== "processing" && F4.default.createElement(S, {
    key: "header",
    flexDirection: "column",
    gap: 1,
    paddingBottom: 1
  }, F4.default.createElement($, {
    bold: !0
  }, "Create Authentication Token"), F4.default.createElement($, {
    dimColor: !0
  }, "Creating a long-lived token for GitHub Actions")), B.state === "waiting_for_login" && X && F4.default.createElement(S, {
    flexDirection: "column",
    key: "urlToCopy",
    gap: 1,
    paddingBottom: 1
  }, F4.default.createElement(S, {
    paddingX: 1
  }, F4.default.createElement($, {
    dimColor: !0
  }, "Browser didn't open? Use the url below to sign in:")), F4.default.createElement(S, {
    width: 1000
  }, F4.default.createElement($, {
    dimColor: !0
  }, B.url))), F4.default.createElement(S, {
    paddingLeft: 1,
    flexDirection: "column",
    gap: 1
  }, E()))
}
// @from(Start 14092033, End 14092035)
F4
// @from(Start 14092037, End 14092075)
$K9 = "Paste code here if prompted > "
// @from(Start 14092081, End 14092199)
qK9 = L(() => {
  hA();
  ZY();
  q80();
  gB();
  q0();
  DY();
  g1();
  i8();
  Bh();
  nt();
  F4 = BA(VA(), 1)
})
// @from(Start 14092253, End 14107407)
function Gx3(A) {
  let [Q] = RI.useState(() => Kw()), [B, G] = RI.useState({
    ...Bx3,
    useExistingKey: !!Q,
    selectedApiKeyOption: Q ? "existing" : JU() ? "oauth" : "new"
  });
  EQ(), RI.default.useEffect(() => {
    GA("tengu_install_github_app_started", {})
  }, []);
  let Z = RI.useCallback(async () => {
    let T = [];
    try {
      aY1("gh --version", {
        stdio: "ignore"
      })
    } catch {
      T.push({
        title: "GitHub CLI not found",
        message: "GitHub CLI (gh) does not appear to be installed or accessible.",
        instructions: ["Install GitHub CLI from https://cli.github.com/", "macOS: brew install gh", "Windows: winget install --id GitHub.cli", "Linux: See installation instructions at https://github.com/cli/cli#installation"]
      })
    }
    try {
      let x = aY1("gh auth status -a", {
        encoding: "utf8"
      }).match(/Token scopes:.*$/m);
      if (x) {
        let p = x[0],
          u = [];
        if (!p.includes("repo")) u.push("repo");
        if (!p.includes("workflow")) u.push("workflow");
        if (u.length > 0) {
          G((e) => ({
            ...e,
            step: "error",
            error: `GitHub CLI is missing required permissions: ${u.join(", ")}.`,
            errorReason: "Missing required scopes",
            errorInstructions: [`Your GitHub CLI authentication is missing the "${u.join('" and "')}" scope${u.length>1?"s":""} needed to manage GitHub Actions and secrets.`, "", "To fix this, run:", "  gh auth refresh -h github.com -s repo,workflow", "", "This will add the necessary permissions to manage workflows and secrets."]
          }));
          return
        }
      }
    } catch {
      T.push({
        title: "GitHub CLI not authenticated",
        message: "GitHub CLI does not appear to be authenticated.",
        instructions: ["Run: gh auth login", "Follow the prompts to authenticate with GitHub", "Or set up authentication using environment variables or other methods"]
      })
    }
    let y = "";
    try {
      aY1("git rev-parse --is-inside-work-tree", {
        stdio: "ignore"
      });
      let x = aY1("git remote get-url origin", {
        encoding: "utf8"
      }).trim().match(/github\.com[:/]([^/]+\/[^/]+)(\.git)?$/);
      if (x) y = x[1]?.replace(/\.git$/, "") || ""
    } catch {}
    GA("tengu_install_github_app_step_completed", {
      step: "check-gh"
    }), G((v) => ({
      ...v,
      warnings: T,
      currentRepo: y,
      selectedRepoName: y,
      useCurrentRepo: !!y,
      step: T.length > 0 ? "warnings" : "choose-repo"
    }))
  }, []);
  RI.default.useEffect(() => {
    if (B.step === "check-gh") Z()
  }, [B.step, Z]);
  let I = RI.useCallback(async (T, y) => {
    G((v) => ({
      ...v,
      step: "creating",
      currentWorkflowInstallStep: 0
    }));
    try {
      await zK9(B.selectedRepoName, T, y, () => {
        G((v) => ({
          ...v,
          currentWorkflowInstallStep: v.currentWorkflowInstallStep + 1
        }))
      }, B.workflowAction === "skip", B.selectedWorkflows, B.authType, {
        useCurrentRepo: B.useCurrentRepo,
        workflowExists: B.workflowExists,
        secretExists: B.secretExists
      }), GA("tengu_install_github_app_step_completed", {
        step: "creating"
      }), G((v) => ({
        ...v,
        step: "success"
      }))
    } catch (v) {
      let x = v instanceof Error ? v.message : "Failed to set up GitHub Actions";
      if (x.includes("workflow file already exists")) GA("tengu_install_github_app_error", {
        reason: "workflow_file_exists"
      }), G((p) => ({
        ...p,
        step: "error",
        error: "A Claude workflow file already exists in this repository.",
        errorReason: "Workflow file conflict",
        errorInstructions: ["The file .github/workflows/claude.yml already exists", "You can either:", "  1. Delete the existing file and run this command again", "  2. Update the existing file manually using the template from:", `     ${Cx}`]
      }));
      else GA("tengu_install_github_app_error", {
        reason: "setup_github_actions_failed"
      }), G((p) => ({
        ...p,
        step: "error",
        error: x,
        errorReason: "GitHub Actions setup failed",
        errorInstructions: []
      }))
    }
  }, [B.selectedRepoName, B.workflowAction, B.selectedWorkflows, B.useCurrentRepo, B.workflowExists, B.secretExists, B.authType]);
  async function Y() {
    await cZ("https://github.com/apps/claude")
  }
  async function J(T) {
    try {
      let y = await QQ("gh", ["api", `repos/${T}`, "--jq", ".permissions.admin"]);
      if (y.code === 0) return {
        hasAccess: y.stdout.trim() === "true"
      };
      if (y.stderr.includes("404") || y.stderr.includes("Not Found")) return {
        hasAccess: !1,
        error: "repository_not_found"
      };
      return {
        hasAccess: !1
      }
    } catch {
      return {
        hasAccess: !1
      }
    }
  }
  async function W(T) {
    return (await QQ("gh", ["api", `repos/${T}/contents/.github/workflows/claude.yml`, "--jq", ".sha"])).code === 0
  }
  async function X() {
    let T = await QQ("gh", ["secret", "list", "--app", "actions", "--repo", B.selectedRepoName]);
    if (T.code === 0)
      if (T.stdout.split(`
`).some((x) => {
          return /^ANTHROPIC_API_KEY\s+/.test(x)
        })) G((x) => ({
        ...x,
        secretExists: !0,
        step: "check-existing-secret"
      }));
      else if (Q) G((x) => ({
      ...x,
      apiKeyOrOAuthToken: Q,
      useExistingKey: !0
    })), await I(Q, B.secretName);
    else G((x) => ({
      ...x,
      step: "api-key"
    }));
    else if (Q) G((y) => ({
      ...y,
      apiKeyOrOAuthToken: Q,
      useExistingKey: !0
    })), await I(Q, B.secretName);
    else G((y) => ({
      ...y,
      step: "api-key"
    }))
  }
  let V = async () => {
    if (B.step === "warnings") GA("tengu_install_github_app_step_completed", {
      step: "warnings"
    }), G((T) => ({
      ...T,
      step: "install-app"
    })), setTimeout(() => {
      Y()
    }, 0);
    else if (B.step === "choose-repo") {
      let T = B.useCurrentRepo ? B.currentRepo : B.selectedRepoName;
      if (!T.trim()) return;
      let y = [];
      if (T.includes("github.com")) {
        let p = T.match(/github\.com[:/]([^/]+\/[^/]+)(\.git)?$/);
        if (!p) y.push({
          title: "Invalid GitHub URL format",
          message: "The repository URL format appears to be invalid.",
          instructions: ["Use format: owner/repo or https://github.com/owner/repo", "Example: anthropics/claude-cli"]
        });
        else T = p[1]?.replace(/\.git$/, "") || ""
      }
      if (!T.includes("/")) y.push({
        title: "Repository format warning",
        message: 'Repository should be in format "owner/repo"',
        instructions: ["Use format: owner/repo", "Example: anthropics/claude-cli"]
      });
      let v = await J(T);
      if (v.error === "repository_not_found") y.push({
        title: "Repository not found",
        message: `Repository ${T} was not found or you don't have access.`,
        instructions: [`Check that the repository name is correct: ${T}`, "Ensure you have access to this repository", 'For private repositories, make sure your GitHub token has the "repo" scope', "You can add the repo scope with: gh auth refresh -h github.com -s repo,workflow"]
      });
      else if (!v.hasAccess) y.push({
        title: "Admin permissions required",
        message: `You might need admin permissions on ${T} to set up GitHub Actions.`,
        instructions: ["Repository admins can install GitHub Apps and set secrets", "Ask a repository admin to run this command if setup fails", "Alternatively, you can use the manual setup instructions"]
      });
      let x = await W(T);
      if (y.length > 0) {
        let p = [...B.warnings, ...y];
        G((u) => ({
          ...u,
          selectedRepoName: T,
          workflowExists: x,
          warnings: p,
          step: "warnings"
        }))
      } else GA("tengu_install_github_app_step_completed", {
        step: "choose-repo"
      }), G((p) => ({
        ...p,
        selectedRepoName: T,
        workflowExists: x,
        step: "install-app"
      })), setTimeout(() => {
        Y()
      }, 0)
    } else if (B.step === "install-app")
      if (GA("tengu_install_github_app_step_completed", {
          step: "install-app"
        }), B.workflowExists) G((T) => ({
        ...T,
        step: "check-existing-workflow"
      }));
      else G((T) => ({
        ...T,
        step: "select-workflows"
      }));
    else if (B.step === "check-existing-workflow") return;
    else if (B.step === "select-workflows") return;
    else if (B.step === "check-existing-secret")
      if (GA("tengu_install_github_app_step_completed", {
          step: "check-existing-secret"
        }), B.useExistingSecret) await I(null, B.secretName);
      else await I(B.apiKeyOrOAuthToken, B.secretName);
    else if (B.step === "api-key") {
      if (B.selectedApiKeyOption === "oauth") return;
      let T = B.selectedApiKeyOption === "existing" ? Q : B.apiKeyOrOAuthToken;
      if (!T) {
        GA("tengu_install_github_app_error", {
          reason: "api_key_missing"
        }), G((v) => ({
          ...v,
          step: "error",
          error: "API key is required"
        }));
        return
      }
      G((v) => ({
        ...v,
        apiKeyOrOAuthToken: T,
        useExistingKey: B.selectedApiKeyOption === "existing"
      }));
      let y = await QQ("gh", ["secret", "list", "--app", "actions", "--repo", B.selectedRepoName]);
      if (y.code === 0)
        if (y.stdout.split(`
`).some((p) => {
            return /^ANTHROPIC_API_KEY\s+/.test(p)
          })) GA("tengu_install_github_app_step_completed", {
          step: "api-key"
        }), G((p) => ({
          ...p,
          secretExists: !0,
          step: "check-existing-secret"
        }));
        else GA("tengu_install_github_app_step_completed", {
          step: "api-key"
        }), await I(T, B.secretName);
      else GA("tengu_install_github_app_step_completed", {
        step: "api-key"
      }), await I(T, B.secretName)
    }
  }, F = (T) => {
    G((y) => ({
      ...y,
      selectedRepoName: T
    }))
  }, K = (T) => {
    G((y) => ({
      ...y,
      apiKeyOrOAuthToken: T
    }))
  }, D = (T) => {
    G((y) => ({
      ...y,
      selectedApiKeyOption: T
    }))
  }, H = RI.useCallback(() => {
    GA("tengu_install_github_app_step_completed", {
      step: "api-key"
    }), G((T) => ({
      ...T,
      step: "oauth-flow"
    }))
  }, []), C = RI.useCallback((T) => {
    GA("tengu_install_github_app_step_completed", {
      step: "oauth-flow"
    }), G((y) => ({
      ...y,
      apiKeyOrOAuthToken: T,
      useExistingKey: !1,
      secretName: "CLAUDE_CODE_OAUTH_TOKEN",
      authType: "oauth_token"
    })), I(T, "CLAUDE_CODE_OAUTH_TOKEN")
  }, [I]), E = RI.useCallback(() => {
    G((T) => ({
      ...T,
      step: "api-key"
    }))
  }, []), U = (T) => {
    if (T && !/^[a-zA-Z0-9_]+$/.test(T)) return;
    G((y) => ({
      ...y,
      secretName: T
    }))
  }, q = (T) => {
    G((y) => ({
      ...y,
      useCurrentRepo: T,
      selectedRepoName: T ? y.currentRepo : ""
    }))
  }, w = (T) => {
    G((y) => ({
      ...y,
      useExistingKey: T
    }))
  }, N = (T) => {
    G((y) => ({
      ...y,
      useExistingSecret: T,
      secretName: T ? "ANTHROPIC_API_KEY" : ""
    }))
  }, R = async (T) => {
    if (T === "exit") {
      A.onDone("Installation cancelled by user");
      return
    }
    if (GA("tengu_install_github_app_step_completed", {
        step: "check-existing-workflow"
      }), G((y) => ({
        ...y,
        workflowAction: T
      })), T === "skip" || T === "update")
      if (Q) await X();
      else G((y) => ({
        ...y,
        step: "api-key"
      }))
  };
  switch (f1(() => {
      if (B.step === "success" || B.step === "error") {
        if (B.step === "success") GA("tengu_install_github_app_completed", {});
        A.onDone(B.step === "success" ? "GitHub Actions setup complete!" : B.error ? `Couldn't install GitHub App: ${B.error}
For manual setup instructions, see: ${Cx}` : `GitHub App installation failed
For manual setup instructions, see: ${Cx}`)
      }
    }), B.step) {
    case "check-gh":
      return RI.default.createElement(pF9, null);
    case "warnings":
      return RI.default.createElement(DK9, {
        warnings: B.warnings,
        onContinue: V
      });
    case "choose-repo":
      return RI.default.createElement(iF9, {
        currentRepo: B.currentRepo,
        useCurrentRepo: B.useCurrentRepo,
        repoUrl: B.selectedRepoName,
        onRepoUrlChange: F,
        onToggleUseCurrentRepo: q,
        onSubmit: V
      });
    case "install-app":
      return RI.default.createElement(eF9, {
        repoUrl: B.selectedRepoName,
        onSubmit: V
      });
    case "check-existing-workflow":
      return RI.default.createElement(FK9, {
        repoName: B.selectedRepoName,
        onSelectAction: R
      });
    case "check-existing-secret":
      return RI.default.createElement(QK9, {
        useExistingSecret: B.useExistingSecret,
        secretName: B.secretName,
        onToggleUseExistingSecret: N,
        onSecretNameChange: U,
        onSubmit: V
      });
    case "api-key":
      return RI.default.createElement(GK9, {
        existingApiKey: Q,
        useExistingKey: B.useExistingKey,
        apiKeyOrOAuthToken: B.apiKeyOrOAuthToken,
        onApiKeyChange: K,
        onToggleUseExistingKey: w,
        onSubmit: V,
        onCreateOAuthToken: JU() ? H : void 0,
        selectedOption: B.selectedApiKeyOption,
        onSelectOption: D
      });
    case "creating":
      return RI.default.createElement(IK9, {
        currentWorkflowInstallStep: B.currentWorkflowInstallStep,
        secretExists: B.secretExists,
        useExistingSecret: B.useExistingSecret,
        secretName: B.secretName,
        skipWorkflow: B.workflowAction === "skip",
        selectedWorkflows: B.selectedWorkflows
      });
    case "success":
      return RI.default.createElement(JK9, {
        secretExists: B.secretExists,
        useExistingSecret: B.useExistingSecret,
        secretName: B.secretName,
        skipWorkflow: B.workflowAction === "skip"
      });
    case "error":
      return RI.default.createElement(XK9, {
        error: B.error,
        errorReason: B.errorReason,
        errorInstructions: B.errorInstructions
      });
    case "select-workflows":
      return RI.default.createElement(CK9, {
        defaultSelections: B.selectedWorkflows,
        onSubmit: (T) => {
          if (GA("tengu_install_github_app_step_completed", {
              step: "select-workflows"
            }), G((y) => ({
              ...y,
              selectedWorkflows: T
            })), Q) X();
          else G((y) => ({
            ...y,
            step: "api-key"
          }))
        }
      });
    case "oauth-flow":
      return RI.default.createElement(wK9, {
        onSuccess: C,
        onCancel: E
      })
  }
}
// @from(Start 14107412, End 14107414)
RI
// @from(Start 14107416, End 14107419)
Bx3
// @from(Start 14107421, End 14107424)
Zx3
// @from(Start 14107426, End 14107429)
NK9
// @from(Start 14107435, End 14108473)
LK9 = L(() => {
  hA();
  gB();
  Q4();
  _8();
  gM();
  lF9();
  nF9();
  AK9();
  BK9();
  ZK9();
  YK9();
  WK9();
  VK9();
  KK9();
  HK9();
  EK9();
  UK9();
  qK9();
  q0();
  RI = BA(VA(), 1), Bx3 = {
    step: "check-gh",
    selectedRepoName: "",
    currentRepo: "",
    useCurrentRepo: !1,
    apiKeyOrOAuthToken: "",
    useExistingKey: !0,
    currentWorkflowInstallStep: 0,
    warnings: [],
    secretExists: !1,
    secretName: "ANTHROPIC_API_KEY",
    useExistingSecret: !0,
    workflowExists: !1,
    selectedWorkflows: ["claude", "claude-review"],
    selectedApiKeyOption: "new",
    authType: "api_key"
  };
  Zx3 = {
    type: "local-jsx",
    name: "install-github-app",
    description: "Set up Claude GitHub Actions for a repository",
    isEnabled: () => !process.env.DISABLE_INSTALL_GITHUB_APP_COMMAND && !N_(),
    isHidden: !1,
    async call(A) {
      return RI.default.createElement(Gx3, {
        onDone: A
      })
    },
    userFacingName() {
      return "install-github-app"
    }
  }, NK9 = Zx3
})
// @from(Start 14108476, End 14111772)
function XF0({
  servers: A,
  onSelectServer: Q,
  onComplete: B
}) {
  let [G] = qB(), Z = EQ();
  if (A.length === 0) return null;
  let I = F2A(),
    Y = A.some((W) => W.client.type === "failed"),
    J = A.map((W) => {
      let X = "",
        V = "",
        F = "";
      if (W.client.type === "disabled") V = ZB("inactive", G)(H1.radioOff), X = "disabled · Enter to view details", F = `${V} ${X}`;
      else if (W.client.type === "connected") V = ZB("success", G)(H1.tick), X = "connected · Enter to view details", F = `${V} ${X}`;
      else if (W.client.type === "pending") {
        V = ZB("inactive", G)(H1.radioOff);
        let {
          reconnectAttempt: K,
          maxReconnectAttempts: D
        } = W.client;
        if (K && D) X = `reconnecting (${K}/${D})…`;
        else X = "connecting…";
        F = `${V} ${X}`
      } else if (W.client.type === "needs-auth") V = ZB("warning", G)(H1.triangleUpOutline), X = "needs authentication · Enter to login", F = `${V} ${X}`;
      else if (W.client.type === "failed") V = ZB("error", G)(H1.cross), X = "failed · Enter to view details", F = `${V} ${X}`;
      else V = ZB("error", G)(H1.cross), X = "failed", F = `${V} ${X}`;
      return {
        label: tA.bold(W.name),
        value: W.name,
        description: F,
        dimDescription: !1
      }
    });
  return $Y.default.createElement(S, {
    flexDirection: "column"
  }, $Y.default.createElement(lY1, null), $Y.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round",
    borderDimColor: !0
  }, $Y.default.createElement(S, {
    marginBottom: 1
  }, $Y.default.createElement($, {
    bold: !0
  }, "Manage MCP servers")), $Y.default.createElement(M0, {
    options: J,
    onChange: (W) => {
      let X = A.find((V) => V.name === W);
      if (X) Q(X)
    },
    onCancel: () => B("MCP dialog dismissed", {
      display: "system"
    })
  }), Y && $Y.default.createElement(S, {
    marginTop: 1
  }, $Y.default.createElement($, {
    dimColor: !0
  }, "※ Tip:", " ", I ? `Error logs will be shown inline. Log files are also saved in
  ${mj.baseLogs()}` : `Run claude --debug to see logs inline, or view log files in
  ${mj.baseLogs()}`)), $Y.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, $Y.default.createElement($, {
    dimColor: !0
  }, "MCP Config locations (by scope):"), ["user", "project", "local"].map((W) => $Y.default.createElement(S, {
    key: W,
    flexDirection: "column",
    marginLeft: 1
  }, $Y.default.createElement($, {
    dimColor: !0
  }, "• ", iQA(W), ":"), $Y.default.createElement(S, {
    marginLeft: 2
  }, $Y.default.createElement($, {
    dimColor: !0
  }, "• ", YN(W)))))), $Y.default.createElement(S, {
    marginTop: 1,
    marginLeft: 0
  }, $Y.default.createElement($, {
    dimColor: !0
  }, "For help configuring MCP servers, see:", " ", $Y.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/mcp"
  }, "https://code.claude.com/docs/en/mcp")))), $Y.default.createElement(S, {
    marginLeft: 3
  }, $Y.default.createElement($, {
    dimColor: !0
  }, Z.pending ? $Y.default.createElement($Y.default.Fragment, null, "Press ", Z.keyName, " again to exit") : $Y.default.createElement($Y.default.Fragment, null, "Esc to exit"))))
}
// @from(Start 14111777, End 14111779)
$Y
// @from(Start 14111785, End 14111903)
VF0 = L(() => {
  hA();
  R9();
  V0();
  J5();
  Q4();
  V9();
  F9();
  eV0();
  nX();
  hA();
  $Y = BA(VA(), 1)
})
// @from(Start 14111906, End 14112317)
function rY1({
  serverToolsCount: A,
  serverPromptsCount: Q,
  serverResourcesCount: B
}) {
  let G = [];
  if (A > 0) G.push("tools");
  if (B > 0) G.push("resources");
  if (Q > 0) G.push("prompts");
  return sY1.default.createElement(S, null, sY1.default.createElement($, {
    bold: !0
  }, "Capabilities: "), sY1.default.createElement($, {
    color: "text"
  }, G.length > 0 ? G.join(" · ") : "none"))
}
// @from(Start 14112322, End 14112325)
sY1
// @from(Start 14112331, End 14112377)
FF0 = L(() => {
  hA();
  sY1 = BA(VA(), 1)
})
// @from(Start 14112380, End 14112886)
function oY1(A, Q) {
  switch (A.client.type) {
    case "connected":
      return {
        message: `Reconnected to ${Q}.`, success: !0
      };
    case "needs-auth":
      return {
        message: `${Q} requires authentication. Use the 'Authenticate' option.`, success: !1
      };
    case "failed":
      return {
        message: `Failed to reconnect to ${Q}.`, success: !1
      };
    default:
      return {
        message: `Unknown result when reconnecting to ${Q}.`, success: !1
      }
  }
}
// @from(Start 14112888, End 14113008)
function tY1(A, Q) {
  let B = A instanceof Error ? A.message : String(A);
  return `Error reconnecting to ${Q}: ${B}`
}
// @from(Start 14113010, End 14117272)
function KF0({
  server: A,
  serverToolsCount: Q,
  onViewTools: B,
  onCancel: G,
  onComplete: Z
}) {
  let [I] = qB(), Y = EQ(), [J] = OQ(), W = gXA(), X = uXA(), [V, F] = k4.useState(!1), K = k4.default.useCallback(async () => {
    let E = A.client.type !== "disabled";
    try {
      await X(A.name), G()
    } catch (U) {
      Z(`Failed to ${E?"disable":"enable"} MCP server '${A.name}': ${U instanceof Error?U.message:String(U)}`)
    }
  }, [A.client.type, A.name, X, G, Z]), D = String(A.name).charAt(0).toUpperCase() + String(A.name).slice(1), H = eY1(J.mcp.commands, A.name).length, C = [];
  if (A.client.type !== "disabled" && Q > 0) C.push({
    label: "View tools",
    value: "tools"
  });
  if (A.client.type !== "disabled") C.push({
    label: "Reconnect",
    value: "reconnectMcpServer"
  });
  if (C.push({
      label: A.client.type !== "disabled" ? "Disable" : "Enable",
      value: "toggle-enabled"
    }), C.length === 0) C.push({
    label: "Back",
    value: "back"
  });
  if (V) return k4.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1
  }, k4.default.createElement($, {
    color: "text"
  }, "Reconnecting to ", k4.default.createElement($, {
    bold: !0
  }, A.name)), k4.default.createElement(S, null, k4.default.createElement(g4, null), k4.default.createElement($, null, " Restarting MCP server process")), k4.default.createElement($, {
    dimColor: !0
  }, "This may take a few moments."));
  return k4.default.createElement(k4.default.Fragment, null, k4.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, k4.default.createElement(S, {
    marginBottom: 1
  }, k4.default.createElement($, {
    bold: !0
  }, D, " MCP Server")), k4.default.createElement(S, {
    flexDirection: "column",
    gap: 0
  }, k4.default.createElement(S, null, k4.default.createElement($, {
    bold: !0
  }, "Status: "), A.client.type === "disabled" ? k4.default.createElement($, null, ZB("inactive", I)(H1.radioOff), " disabled") : A.client.type === "connected" ? k4.default.createElement($, null, ZB("success", I)(H1.tick), " connected") : A.client.type === "pending" ? k4.default.createElement(k4.default.Fragment, null, k4.default.createElement($, {
    dimColor: !0
  }, H1.radioOff), k4.default.createElement($, null, " connecting…")) : k4.default.createElement($, null, ZB("error", I)(H1.cross), " failed")), k4.default.createElement(S, null, k4.default.createElement($, {
    bold: !0
  }, "Command: "), k4.default.createElement($, {
    dimColor: !0
  }, A.config.command)), A.config.args && A.config.args.length > 0 && k4.default.createElement(S, null, k4.default.createElement($, {
    bold: !0
  }, "Args: "), k4.default.createElement($, {
    dimColor: !0
  }, A.config.args.join(" "))), k4.default.createElement(S, null, k4.default.createElement($, {
    bold: !0
  }, "Config location: "), k4.default.createElement($, {
    dimColor: !0
  }, YN(GYA(A.name)?.scope ?? "dynamic"))), A.client.type === "connected" && k4.default.createElement(rY1, {
    serverToolsCount: Q,
    serverPromptsCount: H,
    serverResourcesCount: J.mcp.resources[A.name]?.length || 0
  }), A.client.type === "connected" && Q > 0 && k4.default.createElement(S, null, k4.default.createElement($, {
    bold: !0
  }, "Tools: "), k4.default.createElement($, {
    dimColor: !0
  }, Q, " tools"))), C.length > 0 && k4.default.createElement(S, {
    marginTop: 1
  }, k4.default.createElement(M0, {
    options: C,
    onChange: async (E) => {
      if (E === "tools") B();
      else if (E === "reconnectMcpServer") {
        F(!0);
        try {
          let U = await W(A.name),
            {
              message: q
            } = oY1(U, A.name);
          Z?.(q)
        } catch (U) {
          Z?.(tY1(U, A.name))
        } finally {
          F(!1)
        }
      } else if (E === "toggle-enabled") await K();
      else if (E === "back") G()
    },
    onCancel: G
  }))), k4.default.createElement(S, {
    marginLeft: 3
  }, k4.default.createElement($, {
    dimColor: !0
  }, Y.pending ? k4.default.createElement(k4.default.Fragment, null, "Press ", Y.keyName, " again to exit") : k4.default.createElement(k4.default.Fragment, null, "Esc to go back"))))
}
// @from(Start 14117277, End 14117279)
k4
// @from(Start 14117285, End 14117404)
DF0 = L(() => {
  hA();
  J5();
  Q4();
  V9();
  z9();
  nX();
  tM();
  FF0();
  $QA();
  DY();
  k4 = BA(VA(), 1)
})
// @from(Start 14117407, End 14125399)
function HF0({
  server: A,
  serverToolsCount: Q,
  onViewTools: B,
  onCancel: G,
  onComplete: Z
}) {
  let [I] = qB(), Y = EQ(), [J, W] = L2.default.useState(!1), [X, V] = L2.default.useState(null), [F, K] = OQ(), [D, H] = L2.default.useState(null), [C, E] = L2.useState(!1), [U, q] = L2.useState(null);
  f1((u, e) => {
    if (e.escape && J) {
      if (U) U.abort();
      W(!1), H(null), q(null)
    }
  });
  let w = String(A.name).charAt(0).toUpperCase() + String(A.name).slice(1),
    N = eY1(F.mcp.commands, A.name).length,
    R = gXA(),
    T = uXA(),
    y = L2.default.useCallback(async () => {
      let u = A.client.type !== "disabled";
      try {
        await T(A.name), G()
      } catch (e) {
        Z?.(`Failed to ${u?"disable":"enable"} MCP server '${A.name}': ${e instanceof Error?e.message:String(e)}`)
      }
    }, [A.client.type, A.name, T, G, Z]),
    v = L2.default.useCallback(async () => {
      W(!0), V(null);
      let u = new AbortController;
      q(u);
      try {
        if (A.isAuthenticated && A.config) await Te1(A.name, A.config);
        if (A.config) {
          await M22(A.name, A.config, H, u.signal), GA("tengu_mcp_auth_config_authenticate", {
            wasAuthenticated: A.isAuthenticated
          });
          let e = await R(A.name);
          if (e.client.type === "connected") {
            let l = A.isAuthenticated ? `Authentication successful. Reconnected to ${A.name}.` : `Authentication successful. Connected to ${A.name}.`;
            Z?.(l)
          } else if (e.client.type === "needs-auth") Z?.("Authentication successful, but server still requires authentication. You may need to manually restart Claude Code.");
          else y0(A.name, "Reconnection failed after authentication"), Z?.("Authentication successful, but server reconnection failed. You may need to manually restart Claude Code for the changes to take effect.")
        }
      } catch (e) {
        if (e instanceof Error && !(e instanceof sQ1)) V(e.message)
      } finally {
        W(!1), q(null)
      }
    }, [A.isAuthenticated, A.config, A.name, Z, R, H]),
    x = async () => {
      if (A.config) await Te1(A.name, A.config), GA("tengu_mcp_auth_config_clear", {}), await IYA(A.name, {
        ...A.config,
        scope: A.scope
      }), K((u) => {
        let e = u.mcp.clients.map((o) => o.name === A.name ? {
            ...o,
            type: "failed"
          } : o),
          l = MK9(u.mcp.tools, A.name),
          k = OK9(u.mcp.commands, A.name),
          m = RK9(u.mcp.resources, A.name);
        return {
          ...u,
          mcp: {
            clients: e,
            tools: l,
            commands: k,
            resources: m
          }
        }
      }), Z?.(`Authentication cleared for ${A.name}.`)
    };
  if (J) return L2.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1
  }, L2.default.createElement($, {
    color: "claude"
  }, "Authenticating with ", A.name, "…"), L2.default.createElement(S, null, L2.default.createElement(g4, null), L2.default.createElement($, null, " A browser window will open for authentication")), D && L2.default.createElement(S, {
    flexDirection: "column"
  }, L2.default.createElement($, {
    dimColor: !0
  }, "If your browser doesn't open automatically, copy this URL manually:"), L2.default.createElement(h4, {
    url: D
  })), L2.default.createElement(S, {
    marginLeft: 3
  }, L2.default.createElement($, {
    dimColor: !0
  }, "Return here after authenticating in your browser. Press Esc to go back.")));
  if (C) return L2.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1
  }, L2.default.createElement($, {
    color: "text"
  }, "Reconnecting to ", L2.default.createElement($, {
    bold: !0
  }, A.name), "…"), L2.default.createElement(S, null, L2.default.createElement(g4, null), L2.default.createElement($, null, " Establishing connection to MCP server")), L2.default.createElement($, {
    dimColor: !0
  }, "This may take a few moments."));
  let p = [];
  if (A.client.type === "connected" && Q > 0) p.push({
    label: "View tools",
    value: "tools"
  });
  if (A.isAuthenticated) p.push({
    label: "Re-authenticate",
    value: "reauth"
  }), p.push({
    label: "Clear authentication",
    value: "clear-auth"
  });
  if (!A.isAuthenticated) p.push({
    label: "Authenticate",
    value: "auth"
  });
  if (A.client.type !== "needs-auth" && A.client.type !== "disabled") p.push({
    label: "Reconnect",
    value: "reconnectMcpServer"
  });
  if (p.push({
      label: A.client.type !== "disabled" ? "Disable" : "Enable",
      value: "toggle-enabled"
    }), p.length === 0) p.push({
    label: "Back",
    value: "back"
  });
  return L2.default.createElement(L2.default.Fragment, null, L2.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, L2.default.createElement(S, {
    marginBottom: 1
  }, L2.default.createElement($, {
    bold: !0
  }, w, " MCP Server")), L2.default.createElement(S, {
    flexDirection: "column",
    gap: 0
  }, L2.default.createElement(S, null, L2.default.createElement($, {
    bold: !0
  }, "Status: "), A.client.type === "disabled" ? L2.default.createElement($, null, ZB("inactive", I)(H1.radioOff), " disabled") : A.client.type === "connected" ? L2.default.createElement(L2.default.Fragment, null, L2.default.createElement($, null, ZB("success", I)(H1.tick), " connected"), A.isAuthenticated && L2.default.createElement($, null, "  ", ZB("success", I)(H1.tick), " authenticated")) : A.client.type === "pending" ? L2.default.createElement(L2.default.Fragment, null, L2.default.createElement($, {
    dimColor: !0
  }, H1.radioOff), L2.default.createElement($, null, " connecting…")) : A.client.type === "needs-auth" ? L2.default.createElement($, null, ZB("warning", I)(H1.triangleUpOutline), " needs authentication") : L2.default.createElement($, null, ZB("error", I)(H1.cross), " failed")), L2.default.createElement(S, null, L2.default.createElement($, {
    bold: !0
  }, "URL: "), L2.default.createElement($, {
    dimColor: !0
  }, A.config.url)), L2.default.createElement(S, null, L2.default.createElement($, {
    bold: !0
  }, "Config location: "), L2.default.createElement($, {
    dimColor: !0
  }, YN(GYA(A.name)?.scope ?? "dynamic"))), A.client.type === "connected" && L2.default.createElement(rY1, {
    serverToolsCount: Q,
    serverPromptsCount: N,
    serverResourcesCount: F.mcp.resources[A.name]?.length || 0
  }), A.client.type === "connected" && Q > 0 && L2.default.createElement(S, null, L2.default.createElement($, {
    bold: !0
  }, "Tools: "), L2.default.createElement($, {
    dimColor: !0
  }, Q, " tools"))), X && L2.default.createElement(S, {
    marginTop: 1
  }, L2.default.createElement($, {
    color: "error"
  }, "Error: ", X)), p.length > 0 && L2.default.createElement(S, {
    marginTop: 1
  }, L2.default.createElement(M0, {
    options: p,
    onChange: async (u) => {
      switch (u) {
        case "tools":
          B();
          break;
        case "auth":
        case "reauth":
          await v();
          break;
        case "clear-auth":
          await x();
          break;
        case "reconnectMcpServer":
          E(!0);
          try {
            let e = await R(A.name),
              {
                message: l
              } = oY1(e, A.name);
            Z?.(l)
          } catch (e) {
            Z?.(tY1(e, A.name))
          } finally {
            E(!1)
          }
          break;
        case "toggle-enabled":
          await y();
          break;
        case "back":
          G();
          break
      }
    },
    onCancel: G
  }))), L2.default.createElement(S, {
    marginLeft: 3
  }, L2.default.createElement($, {
    dimColor: !0
  }, Y.pending ? L2.default.createElement(L2.default.Fragment, null, "Press ", Y.keyName, " again to exit") : L2.default.createElement(L2.default.Fragment, null, "Esc to go back"))))
}
// @from(Start 14125404, End 14125406)
L2
// @from(Start 14125412, End 14125572)
CF0 = L(() => {
  hA();
  J5();
  q0();
  Q4();
  V9();
  rQ1();
  DY();
  Ok();
  z9();
  g1();
  nX();
  tM();
  FF0();
  hA();
  $QA();
  L2 = BA(VA(), 1)
})
// @from(Start 14125575, End 14127327)
function EF0({
  server: A,
  onSelectTool: Q,
  onBack: B
}) {
  let G = EQ(),
    [Z] = OQ(),
    I = Yz.default.useMemo(() => {
      if (A.client.type !== "connected") return [];
      return zSA(Z.mcp.tools, A.name)
    }, [A, Z.mcp.tools]),
    Y = I.map((J, W) => {
      let X = AJ1(J.name, A.name),
        V = J.userFacingName ? J.userFacingName({}) : X,
        F = QJ1(V),
        K = J.isReadOnly?.({}) ?? !1,
        D = J.isDestructive?.({}) ?? !1,
        H = J.isOpenWorld?.({}) ?? !1,
        C = [];
      if (K) C.push("read-only");
      if (D) C.push("destructive");
      if (H) C.push("open-world");
      return {
        label: F,
        value: W.toString(),
        description: C.length > 0 ? C.join(", ") : void 0,
        descriptionColor: D ? "error" : K ? "success" : void 0
      }
    });
  return Yz.default.createElement(S, {
    flexDirection: "column"
  }, Yz.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, Yz.default.createElement(S, {
    marginBottom: 1
  }, Yz.default.createElement($, {
    bold: !0
  }, "Tools for ", A.name), Yz.default.createElement($, {
    dimColor: !0
  }, " (", I.length, " tools)")), I.length === 0 ? Yz.default.createElement($, {
    dimColor: !0
  }, "No tools available") : Yz.default.createElement(M0, {
    options: Y,
    onChange: (J) => {
      let W = parseInt(J),
        X = I[W];
      if (X) Q(X, W)
    },
    onCancel: B
  })), Yz.default.createElement(S, {
    marginLeft: 3
  }, Yz.default.createElement($, {
    dimColor: !0
  }, G.pending ? Yz.default.createElement(Yz.default.Fragment, null, "Press ", G.keyName, " again to exit") : Yz.default.createElement(Yz.default.Fragment, null, "Esc to go back"))))
}
// @from(Start 14127332, End 14127334)
Yz
// @from(Start 14127340, End 14127417)
zF0 = L(() => {
  hA();
  J5();
  nX();
  z9();
  Q4();
  Yz = BA(VA(), 1)
})
// @from(Start 14127420, End 14130689)
function UF0({
  tool: A,
  server: Q,
  onBack: B
}) {
  let G = EQ(),
    [Z, I] = $3.default.useState("");
  f1((K, D) => {
    if (D.escape) B()
  });
  let Y = AJ1(A.name, Q.name),
    J = A.userFacingName ? A.userFacingName({}) : Y,
    W = QJ1(J),
    X = A.isReadOnly?.({}) ?? !1,
    V = A.isDestructive?.({}) ?? !1,
    F = A.isOpenWorld?.({}) ?? !1;
  return $3.default.useEffect(() => {
    async function K() {
      try {
        let D = await A.description({}, {
          isNonInteractiveSession: !1,
          toolPermissionContext: {
            mode: "default",
            additionalWorkingDirectories: new Map,
            alwaysAllowRules: {},
            alwaysDenyRules: {},
            alwaysAskRules: {},
            isBypassPermissionsModeAvailable: !1
          },
          tools: []
        });
        I(D)
      } catch {
        I("Failed to load description")
      }
    }
    K()
  }, [A]), $3.default.createElement(S, {
    flexDirection: "column"
  }, $3.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, $3.default.createElement(S, {
    marginBottom: 1
  }, $3.default.createElement($, {
    bold: !0
  }, W, $3.default.createElement($, {
    dimColor: !0
  }, " (", Q.name, ")"), X && $3.default.createElement($, {
    color: "success"
  }, " [read-only]"), V && $3.default.createElement($, {
    color: "error"
  }, " [destructive]"), F && $3.default.createElement($, {
    dimColor: !0
  }, " [open-world]"))), $3.default.createElement(S, {
    flexDirection: "column"
  }, $3.default.createElement(S, null, $3.default.createElement($, {
    bold: !0
  }, "Tool name: "), $3.default.createElement($, {
    dimColor: !0
  }, Y)), $3.default.createElement(S, null, $3.default.createElement($, {
    bold: !0
  }, "Full name: "), $3.default.createElement($, {
    dimColor: !0
  }, A.name)), Z && $3.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, $3.default.createElement($, {
    bold: !0
  }, "Description:"), $3.default.createElement($, {
    wrap: "wrap"
  }, Z)), A.inputJSONSchema && A.inputJSONSchema.properties && Object.keys(A.inputJSONSchema.properties).length > 0 && $3.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, $3.default.createElement($, {
    bold: !0
  }, "Parameters:"), $3.default.createElement(S, {
    marginLeft: 2,
    flexDirection: "column"
  }, Object.entries(A.inputJSONSchema.properties).map(([K, D]) => {
    let C = A.inputJSONSchema?.required?.includes(K);
    return $3.default.createElement($, {
      key: K
    }, "• ", K, C && $3.default.createElement($, {
      dimColor: !0
    }, " (required)"), ":", " ", $3.default.createElement($, {
      dimColor: !0
    }, typeof D === "object" && D && "type" in D ? String(D.type) : "unknown"), typeof D === "object" && D && "description" in D && $3.default.createElement($, {
      dimColor: !0
    }, " ", "- ", String(D.description)))
  }))))), $3.default.createElement(S, {
    marginLeft: 3
  }, $3.default.createElement($, {
    dimColor: !0
  }, G.pending ? $3.default.createElement($3.default.Fragment, null, "Press ", G.keyName, " again to exit") : $3.default.createElement($3.default.Fragment, null, "Esc to go back"))))
}
// @from(Start 14130694, End 14130696)
$3
// @from(Start 14130702, End 14130771)
$F0 = L(() => {
  hA();
  hA();
  Q4();
  nX();
  $3 = BA(VA(), 1)
})
// @from(Start 14130774, End 14133986)
function wF0({
  onComplete: A
}) {
  let [Q] = OQ(), B = Q.mcp.clients, [G, Z] = gO.default.useState({
    type: "list"
  }), [I, Y] = gO.default.useState([]), J = gO.default.useMemo(() => B.filter((W) => W.name !== "ide").sort((W, X) => W.name.localeCompare(X.name)), [B]);
  switch (gO.default.useEffect(() => {
      async function W() {
        let X = await Promise.all(J.map(async (V) => {
          let F = V.config.scope,
            K = V.config.type === "sse",
            D = V.config.type === "http",
            H = void 0;
          if (K || D) {
            let U = await new lAA(V.name, V.config).tokens();
            H = Boolean(U)
          }
          let C = {
            name: V.name,
            client: V,
            scope: F
          };
          if (K) return {
            ...C,
            transport: "sse",
            isAuthenticated: H,
            config: V.config
          };
          else if (D) return {
            ...C,
            transport: "http",
            isAuthenticated: H,
            config: V.config
          };
          else return {
            ...C,
            transport: "stdio",
            config: V.config
          }
        }));
        Y(X)
      }
      W()
    }, [J]), gO.useEffect(() => {
      if (I.length === 0 && J.length > 0) return;
      if (I.length === 0) A("No MCP servers configured. Please run /doctor if this is unexpected. Otherwise, run `claude mcp` or visit https://code.claude.com/docs/en/mcp to learn more.")
    }, [I.length, J.length, A]), G.type) {
    case "list":
      return gO.default.createElement(XF0, {
        servers: I,
        onSelectServer: (W) => Z({
          type: "server-menu",
          server: W
        }),
        onComplete: A
      });
    case "server-menu": {
      let W = zSA(Q.mcp.tools, G.server.name);
      if (G.server.transport === "stdio") return gO.default.createElement(KF0, {
        server: G.server,
        serverToolsCount: W.length,
        onViewTools: () => Z({
          type: "server-tools",
          server: G.server
        }),
        onCancel: () => Z({
          type: "list"
        }),
        onComplete: A
      });
      else return gO.default.createElement(HF0, {
        server: G.server,
        serverToolsCount: W.length,
        onViewTools: () => Z({
          type: "server-tools",
          server: G.server
        }),
        onCancel: () => Z({
          type: "list"
        }),
        onComplete: A
      })
    }
    case "server-tools":
      return gO.default.createElement(EF0, {
        server: G.server,
        onSelectTool: (W, X) => Z({
          type: "server-tool-detail",
          server: G.server,
          toolIndex: X
        }),
        onBack: () => Z({
          type: "server-menu",
          server: G.server
        })
      });
    case "server-tool-detail": {
      let X = zSA(Q.mcp.tools, G.server.name)[G.toolIndex];
      if (!X) return Z({
        type: "server-tools",
        server: G.server
      }), null;
      return gO.default.createElement(UF0, {
        tool: X,
        server: G.server,
        onBack: () => Z({
          type: "server-tools",
          server: G.server
        })
      })
    }
  }
}
// @from(Start 14133991, End 14133993)
gO
// @from(Start 14133999, End 14134106)
TK9 = L(() => {
  rQ1();
  z9();
  nX();
  VF0();
  DF0();
  CF0();
  zF0();
  $F0();
  gO = BA(VA(), 1)
})
// @from(Start 14134109, End 14135930)
function qF0({
  serverName: A,
  onComplete: Q
}) {
  let [B] = qB(), [G] = OQ(), Z = gXA(), [I, Y] = QH.useState(!0), [J, W] = QH.useState(null);
  if (QH.useEffect(() => {
      async function X() {
        try {
          if (!G.mcp.clients.find((K) => K.name === A)) {
            W(`MCP server "${A}" not found`), Y(!1);
            return
          }
          switch ((await Z(A)).client.type) {
            case "connected":
              Q(`Successfully reconnected to ${A}`);
              break;
            case "needs-auth":
              W(`${A} requires authentication`), Y(!1), Q(`${A} requires authentication. Use /mcp to authenticate.`);
              break;
            case "pending":
            case "failed":
            case "disabled":
              W(`Failed to reconnect to ${A}`), Y(!1), Q(`Failed to reconnect to ${A}`);
              break
          }
        } catch (V) {
          let F = V instanceof Error ? V.message : String(V);
          W(F), Y(!1), Q(`Error: ${F}`)
        }
      }
      X()
    }, [A, Z, G.mcp.clients, Q]), I) return QH.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1
  }, QH.default.createElement($, {
    color: "text"
  }, "Reconnecting to ", QH.default.createElement($, {
    bold: !0
  }, A)), QH.default.createElement(S, null, QH.default.createElement(g4, null), QH.default.createElement($, null, " Establishing connection to MCP server")));
  if (J) return QH.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1
  }, QH.default.createElement(S, null, QH.default.createElement($, null, ZB("error", B)(H1.cross), " "), QH.default.createElement($, {
    color: "error"
  }, "Failed to reconnect to ", A)), QH.default.createElement($, {
    dimColor: !0
  }, "Error: ", J));
  return null
}
// @from(Start 14135935, End 14135937)
QH
// @from(Start 14135943, End 14136029)
NF0 = L(() => {
  hA();
  DY();
  $QA();
  z9();
  hA();
  V9();
  QH = BA(VA(), 1)
})
// @from(Start 14136035, End 14136115)
PK9 = L(() => {
  TK9();
  VF0();
  DF0();
  CF0();
  zF0();
  $F0();
  NF0()
})
// @from(Start 14136121, End 14136124)
LF0
// @from(Start 14136126, End 14136129)
Ix3
// @from(Start 14136131, End 14136134)
jK9
// @from(Start 14136140, End 14136819)
SK9 = L(() => {
  PK9();
  NF0();
  LF0 = BA(VA(), 1), Ix3 = {
    type: "local-jsx",
    name: "mcp",
    description: "Manage MCP servers",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[reconnect <server-name>]",
    async call(A, Q, B) {
      if (B) {
        let G = B.trim().split(/\s+/);
        if (G[0] === "reconnect" && G[1]) {
          let Z = G.slice(1).join(" ");
          return LF0.default.createElement(qF0, {
            serverName: Z,
            onComplete: A
          })
        }
      }
      return LF0.default.createElement(wF0, {
        onComplete: A
      })
    },
    userFacingName() {
      return "mcp"
    }
  }, jK9 = Ix3
})
// @from(Start 14136825, End 14136839)
_K9 = () => {}
// @from(Start 14136845, End 14136859)
kK9 = () => {}
// @from(Start 14136865, End 14136868)
yK9
// @from(Start 14136874, End 14138706)
xK9 = L(() => {
  yK9 = {
    type: "prompt",
    name: "pr-comments",
    description: "Get comments from a GitHub pull request",
    progressMessage: "fetching PR comments",
    useSmallFastModel: !0,
    isEnabled: () => !0,
    isHidden: !1,
    userFacingName() {
      return "pr-comments"
    },
    source: "builtin",
    async getPromptForCommand(A) {
      return [{
        type: "text",
        text: `You are an AI assistant integrated into a git-based version control system. Your task is to fetch and display comments from a GitHub pull request.

Follow these steps:

1. Use \`gh pr view --json number,headRepository\` to get the PR number and repository info
2. Use \`gh api /repos/{owner}/{repo}/issues/{number}/comments\` to get PR-level comments
3. Use \`gh api /repos/{owner}/{repo}/pulls/{number}/comments\` to get review comments. Pay particular attention to the following fields: \`body\`, \`diff_hunk\`, \`path\`, \`line\`, etc. If the comment references some code, consider fetching it using eg \`gh api /repos/{owner}/{repo}/contents/{path}?ref={branch} | jq .content -r | base64 -d\`
4. Parse and format all comments in a readable way
5. Return ONLY the formatted comments, with no additional text

Format the comments as:

## Comments

[For each comment thread:]
- @author file.ts#line:
  \`\`\`diff
  [diff_hunk from the API response]
  \`\`\`
  > quoted comment text
  
  [any replies indented]

If there are no comments, return "No comments found."

Remember:
1. Only show the actual comments, no explanatory text
2. Include both PR-level and code review comments
3. Preserve the threading/nesting of comment replies
4. Show the file and line number context for code review comments
5. Use jq to parse the JSON responses from the GitHub API

${A?"Additional user input: "+A:""}
`
      }]
    }
  }
})
// @from(Start 14138709, End 14138869)
function vK9(A) {
  return A.map(([Q, B]) => {
    let G = `Version ${Q}:`,
      Z = B.map((I) => `• ${I}`).join(`
`);
    return `${G}
${Z}`
  }).join(`

`)
}
// @from(Start 14138874, End 14138877)
Yx3
// @from(Start 14138879, End 14138882)
bK9
// @from(Start 14138888, End 14139680)
fK9 = L(() => {
  tXA();
  Yx3 = {
    description: "View release notes",
    isEnabled: () => !0,
    isHidden: !1,
    name: "release-notes",
    userFacingName() {
      return "release-notes"
    },
    type: "local",
    supportsNonInteractive: !0,
    async call() {
      let A = [];
      try {
        let B = new Promise((G, Z) => {
          setTimeout(() => Z(Error("Timeout")), 500)
        });
        await Promise.race([eW0(), B]), A = AX0(SQA())
      } catch {}
      if (A.length > 0) return {
        type: "text",
        value: vK9(A)
      };
      let Q = AX0();
      if (Q.length > 0) return {
        type: "text",
        value: vK9(Q)
      };
      return {
        type: "text",
        value: `See the full changelog at: ${t69}`
      }
    }
  }, bK9 = Yx3
})
// @from(Start 14139686, End 14139689)
Jx3
// @from(Start 14139691, End 14139694)
hK9
// @from(Start 14139700, End 14140320)
gK9 = L(() => {
  S7();
  _0();
  Jx3 = {
    type: "local",
    name: "rename",
    description: "Rename the current conversation",
    isEnabled: () => !1,
    isHidden: !1,
    supportsNonInteractive: !1,
    argumentHint: "<name>",
    async call(A) {
      if (!A || A.trim() === "") return {
        type: "text",
        value: "Please provide a name for the session. Usage: /rename <name>"
      };
      let Q = e1();
      return await BJ1(Q, A.trim()), {
        type: "text",
        value: `Session renamed to: ${A.trim()}`
      }
    },
    userFacingName() {
      return "rename"
    }
  }, hK9 = Jx3
})
// @from(Start 14140323, End 14143273)
function uK9({
  nodes: A,
  onSelect: Q,
  onCancel: B,
  onFocus: G,
  focusNodeId: Z,
  visibleOptionCount: I,
  layout: Y = "expanded",
  isDisabled: J = !1,
  hideIndexes: W = !1,
  isNodeExpanded: X,
  onExpand: V,
  onCollapse: F,
  getParentPrefix: K,
  getChildPrefix: D
}) {
  let [H, C] = RC.default.useState(new Set), E = RC.default.useRef(!1), U = RC.default.useRef(null), q = RC.default.useCallback((m) => {
    if (X) return X(m);
    return H.has(m)
  }, [X, H]), w = RC.default.useMemo(() => {
    let m = [];

    function o(IA, FA, zA) {
      let NA = !!IA.children && IA.children.length > 0,
        OA = q(IA.id);
      if (m.push({
          node: IA,
          depth: FA,
          isExpanded: OA,
          hasChildren: NA,
          parentId: zA
        }), NA && OA && IA.children)
        for (let mA of IA.children) o(mA, FA + 1, IA.id)
    }
    for (let IA of A) o(IA, 0);
    return m
  }, [A, q]), N = RC.default.useCallback((m) => m ? "▼ " : "▶ ", []), R = RC.default.useCallback((m) => "  ▸ ", []), T = K ?? N, y = D ?? R, v = RC.default.useCallback((m) => {
    let o = "";
    if (m.hasChildren) o = T(m.isExpanded);
    else if (m.depth > 0) o = y(m.depth);
    return o + m.node.label
  }, [T, y]), x = RC.default.useMemo(() => {
    return w.map((m) => ({
      label: v(m),
      description: m.node.description,
      dimDescription: m.node.dimDescription ?? !0,
      value: m.node.id
    }))
  }, [w, v]), p = RC.default.useMemo(() => {
    let m = new Map;
    return w.forEach((o) => m.set(o.node.id, o.node)), m
  }, [w]), u = RC.default.useCallback((m) => {
    return w.find((o) => o.node.id === m)
  }, [w]), e = RC.default.useCallback((m, o) => {
    let IA = u(m);
    if (!IA || !IA.hasChildren) return;
    if (o)
      if (V) V(m);
      else C((FA) => new Set([...FA, m]));
    else if (F) F(m);
    else C((FA) => {
      let zA = new Set(FA);
      return zA.delete(m), zA
    })
  }, [u, V, F]);
  f1((m, o) => {
    if (!Z || J) return;
    let IA = u(Z);
    if (!IA) return;
    if (o.rightArrow && IA.hasChildren) e(Z, !0);
    else if (o.leftArrow) {
      if (IA.hasChildren && IA.isExpanded) e(Z, !1);
      else if (IA.parentId !== void 0) {
        if (E.current = !0, e(IA.parentId, !1), G) {
          let FA = p.get(IA.parentId);
          if (FA) G(FA)
        }
      }
    }
  }, {
    isActive: !J
  });
  let l = RC.default.useCallback((m) => {
      let o = p.get(m);
      if (!o) return;
      Q(o)
    }, [p, Q]),
    k = RC.default.useCallback((m) => {
      if (E.current) {
        E.current = !1;
        return
      }
      if (U.current === m) return;
      if (U.current = m, G) {
        let o = p.get(m);
        if (o) G(o)
      }
    }, [G, p]);
  return RC.default.createElement(M0, {
    options: x,
    onChange: l,
    onFocus: k,
    onCancel: B,
    focusValue: Z,
    visibleOptionCount: I,
    layout: Y,
    isDisabled: J,
    hideIndexes: W
  })
}
// @from(Start 14143278, End 14143280)
RC
// @from(Start 14143286, End 14143339)
mK9 = L(() => {
  S5();
  hA();
  RC = BA(VA(), 1)
})
// @from(Start 14143342, End 14144459)
function dK9({
  log: A,
  onExit: Q,
  onSelect: B
}) {
  let G = A.messages[0]?.sessionId || "",
    Z = wY1();
  return f1((I, Y) => {
    if (Y.escape || Y.ctrl && I === "c") Q();
    else if (Y.return) B(A)
  }, {
    isActive: !0
  }), qVA.default.createElement(S, {
    flexDirection: "column"
  }, qVA.default.createElement(_QA, {
    messages: A.messages,
    normalizedMessageHistory: [],
    tools: Z,
    verbose: !0,
    toolJSX: null,
    toolUseConfirmQueue: [],
    inProgressToolUseIDs: new Set,
    isMessageSelectorVisible: !1,
    conversationId: G,
    screen: "transcript",
    screenToggleId: 1,
    streamingToolUses: [],
    showAllInTranscript: !0
  }), qVA.default.createElement(S, {
    flexShrink: 0,
    flexDirection: "column",
    borderTopDimColor: !0,
    borderBottom: !1,
    borderLeft: !1,
    borderRight: !1,
    borderStyle: "single",
    paddingLeft: 2
  }, qVA.default.createElement($, null, Yt(A.modified), " · ", A.messageCount, " messages", A.gitBranch ? ` · ${A.gitBranch}` : ""), qVA.default.createElement($, {
    dimColor: !0
  }, "Enter to resume · Esc to exit")))
}
// @from(Start 14144464, End 14144467)
qVA
// @from(Start 14144473, End 14144536)
cK9 = L(() => {
  hA();
  _I1();
  yq();
  qVA = BA(VA(), 1)
})
// @from(Start 14144539, End 14144669)
function pK9(A, Q) {
  let B = A.replace(/\s+/g, " ").trim();
  if (B.length <= Q) return B;
  return B.slice(0, Q).trim() + "…"
}
// @from(Start 14144671, End 14145004)
function MF0(A, Q, B) {
  let {
    isGroupHeader: G = !1,
    isChild: Z = !1,
    forkCount: I = 0
  } = B || {}, Y = G && I > 0 ? Wx3 : Z ? Xx3 : 0, J = G && I > 0 ? ` (+${I} other ${I===1?"session":"sessions"})` : "", W = A.isSidechain ? " (sidechain)" : "", X = Q - Y - W.length - J.length;
  return `${pK9(PFA(A),X)}${W}${J}`
}
// @from(Start 14145006, End 14145205)
function OF0(A, Q) {
  let {
    isChild: B = !1,
    showProjectPath: G = !1
  } = Q || {}, Z = B ? "    " : "", I = mzA(A), Y = G && A.projectPath ? ` · ${A.projectPath}` : "";
  return Z + I + Y
}
// @from(Start 14145207, End 14154585)
function USA({
  logs: A,
  maxHeight: Q = 1 / 0,
  forceWidth: B,
  onCancel: G,
  onSelect: Z,
  onLogsChanged: I,
  initialSearchQuery: Y,
  showAllProjects: J = !1,
  onToggleAllProjects: W
}) {
  let X = WB(),
    V = B === void 0 ? X.columns : B,
    F = EQ(G),
    {
      isFocused: K,
      filterFocusSequences: D
    } = HrA(),
    H = ug(),
    [C, E] = G8.default.useState(null),
    [U, q] = G8.default.useState(!1),
    [w, N] = G8.default.useState(Y || ""),
    [R, T] = G8.default.useState(""),
    [y, v] = G8.default.useState(0),
    [x, p] = G8.default.useState(new Set),
    [u, e] = G8.default.useState(null),
    [l, k] = G8.default.useState(Y ? "search" : "list"),
    [m, o] = G8.default.useState(null),
    IA = G8.default.useRef(null);
  G8.default.useEffect(() => {
    sb().then((DA) => E(DA))
  }, []);
  let FA = G8.default.useMemo(() => {
      let DA = A;
      if (H) DA = A.filter(($A) => {
        let TA = e1(),
          rA = TA && $A.messages[0]?.sessionId === TA,
          iA = RF0($A.messages);
        return rA || iA
      });
      if (U && C) DA = DA.filter(($A) => $A.gitBranch === C);
      if (w) {
        let $A = w.toLowerCase();
        DA = DA.filter((TA) => {
          let rA = PFA(TA).toLowerCase(),
            iA = (TA.gitBranch || "").toLowerCase();
          return rA.includes($A) || iA.includes($A)
        })
      }
      return DA
    }, [A, H, U, C, w]),
    zA = Math.max(30, V - 4),
    NA = G8.default.useMemo(() => {
      if (!H) return [];
      let DA = Vx3(FA);
      return Array.from(DA.entries()).map(([$A, TA]) => {
        let rA = TA[0],
          iA = FA.indexOf(rA);
        if (TA.length === 1) return {
          id: `log:${$A}:0`,
          value: {
            log: rA,
            indexInFiltered: iA
          },
          label: MF0(rA, zA),
          description: OF0(rA, {
            showProjectPath: J
          }),
          dimDescription: !0
        };
        let J1 = TA.length - 1,
          w1 = TA.slice(1).map((jA, eA) => {
            let t1 = FA.indexOf(jA);
            return {
              id: `log:${$A}:${eA+1}`,
              value: {
                log: jA,
                indexInFiltered: t1
              },
              label: MF0(jA, zA, {
                isChild: !0
              }),
              description: OF0(jA, {
                isChild: !0,
                showProjectPath: J
              }),
              dimDescription: !0
            }
          });
        return {
          id: `group:${$A}`,
          value: {
            log: rA,
            indexInFiltered: iA
          },
          label: MF0(rA, zA, {
            isGroupHeader: !0,
            forkCount: J1
          }),
          description: OF0(rA, {
            showProjectPath: J
          }),
          dimDescription: !0,
          children: w1
        }
      })
    }, [H, FA, zA, J]),
    OA = G8.default.useMemo(() => {
      if (H) return [];
      return FA.map((DA, $A) => {
        let rA = PFA(DA) + (DA.isSidechain ? " (sidechain)" : ""),
          iA = pK9(rA, zA),
          J1 = mzA(DA),
          w1 = J && DA.projectPath ? ` · ${DA.projectPath}` : "";
        return {
          label: iA,
          description: J1 + w1,
          dimDescription: !0,
          value: $A.toString()
        }
      })
    }, [H, FA, zA, J]),
    mA = u?.value.log ?? null,
    wA = () => {
      if (!H || !mA) return "";
      let DA = mA.messages[0]?.sessionId;
      if (!DA) return "";
      let $A = FA.filter((J1) => J1.messages[0]?.sessionId === DA);
      if (!($A.length > 1)) return "";
      let rA = x.has(DA);
      if ($A.indexOf(mA) > 0) return " · ← to collapse";
      return rA ? " · ← to collapse" : " · → to expand"
    },
    qA = G8.default.useCallback(async () => {
      let DA = mA?.messages[0];
      if (!mA || !DA) {
        k("list"), T("");
        return
      }
      if (R.trim()) {
        let $A = DA.sessionId;
        if (await BJ1($A, R.trim()), H && I) I()
      }
      k("list"), T("")
    }, [mA, R, I, H]),
    KA = G8.default.useCallback((DA) => {
      let $A = parseInt(DA, 10),
        TA = FA[$A];
      if (!TA || IA.current === $A.toString()) return;
      IA.current = $A.toString(), e({
        id: $A.toString(),
        value: {
          log: TA,
          indexInFiltered: $A
        },
        label: ""
      })
    }, [FA]),
    yA = G8.default.useCallback((DA) => {
      e(DA)
    }, []);
  if (f1((DA, $A) => {
      if (l === "preview") return;
      if (l === "rename") {
        if ($A.escape) k("list"), T("")
      } else if (l === "search")
        if ($A.escape || $A.return) k("list"), GA("tengu_session_search_toggled", {
          enabled: !1
        });
        else if ($A.backspace || $A.delete) N((TA) => TA.slice(0, -1));
      else {
        let TA = D(DA, $A);
        if (TA && !$A.ctrl && !$A.meta) N((rA) => rA + TA)
      } else {
        let TA = !$A.ctrl && !$A.meta,
          rA = DA.toLowerCase();
        if (rA === "a" && TA && W) W(), GA("tengu_session_all_projects_toggled", {
          enabled: !J
        });
        else if (rA === "b" && TA) {
          let iA = !U;
          q(iA), GA("tengu_session_branch_filter_toggled", {
            enabled: iA
          })
        } else if (rA === "/" && TA) k("search"), GA("tengu_session_search_toggled", {
          enabled: !0
        });
        else if (rA === "r" && TA && mA && H) k("rename"), T(""), GA("tengu_session_rename_started", {});
        else if (rA === "p" && TA && mA && H) o(mA), k("preview"), GA("tengu_session_preview_opened", {
          messageCount: mA.messageCount
        })
      }
    }, {
      isActive: !0
    }), A.length === 0) return null;
  if (l === "preview" && m && H) return G8.default.createElement(dK9, {
    log: m,
    onExit: () => {
      k("list"), o(null)
    },
    onSelect: Z
  });
  let oA = [];
  if (U && C) oA.push(C);
  if (w && l !== "search") oA.push(`/${w}`);
  let X1 = oA.length > 0 || l === "search",
    WA = 5 + (X1 ? 1 : 0),
    EA = 2,
    MA = Math.max(1, Math.floor((Q - WA - EA) / 3));
  return G8.default.createElement(S, {
    flexDirection: "column",
    height: Q - 1
  }, G8.default.createElement(S, {
    flexShrink: 0
  }, G8.default.createElement($, {
    color: "suggestion"
  }, "─".repeat(V))), G8.default.createElement(S, {
    flexShrink: 0
  }, G8.default.createElement($, null, " ")), G8.default.createElement(S, {
    flexShrink: 0
  }, G8.default.createElement($, {
    bold: !0,
    color: "suggestion"
  }, "Resume Session", J ? " (All Projects)" : "")), X1 && G8.default.createElement(S, {
    flexShrink: 0,
    paddingLeft: 2
  }, l === "search" ? G8.default.createElement($, null, oA.length > 0 && G8.default.createElement($, {
    dimColor: !0
  }, oA.join(" · "), " · "), "/", G8.default.createElement($, {
    bold: !0
  }, w), K && G8.default.createElement($, {
    dimColor: !0
  }, "█")) : G8.default.createElement($, {
    dimColor: !0
  }, oA.join(" · "))), G8.default.createElement(S, {
    flexShrink: 0
  }, G8.default.createElement($, null, " ")), l === "rename" && mA ? G8.default.createElement(S, {
    paddingLeft: 2,
    flexDirection: "column"
  }, G8.default.createElement($, {
    bold: !0
  }, "Rename session:"), G8.default.createElement(S, {
    paddingTop: 1
  }, G8.default.createElement(s4, {
    value: R,
    onChange: T,
    onSubmit: qA,
    placeholder: PFA(mA, "Enter new session name"),
    columns: V,
    cursorOffset: y,
    onChangeCursorOffset: v,
    showCursor: !0
  }))) : H ? G8.default.createElement(uK9, {
    nodes: NA,
    onSelect: (DA) => {
      Z(DA.value.log)
    },
    onFocus: yA,
    onCancel: G,
    focusNodeId: u?.id,
    visibleOptionCount: MA,
    layout: "expanded",
    isDisabled: l === "search",
    hideIndexes: !1,
    isNodeExpanded: (DA) => {
      if (l === "search" || U) return !0;
      let $A = typeof DA === "string" && DA.startsWith("group:") ? DA.substring(6) : null;
      return $A ? x.has($A) : !1
    },
    onExpand: (DA) => {
      let $A = typeof DA === "string" && DA.startsWith("group:") ? DA.substring(6) : null;
      if ($A) p((TA) => new Set([...TA, $A])), GA("tengu_session_group_expanded", {})
    },
    onCollapse: (DA) => {
      let $A = typeof DA === "string" && DA.startsWith("group:") ? DA.substring(6) : null;
      if ($A) p((TA) => {
        let rA = new Set(TA);
        return rA.delete($A), rA
      })
    }
  }) : G8.default.createElement(M0, {
    options: OA,
    onChange: (DA) => {
      let $A = parseInt(DA, 10),
        TA = FA[$A];
      if (TA) Z(TA)
    },
    visibleOptionCount: MA,
    onCancel: G,
    onFocus: KA,
    focusValue: u?.id.toString(),
    layout: "expanded",
    isDisabled: l === "search"
  }), G8.default.createElement(S, {
    paddingLeft: 2
  }, F.pending ? G8.default.createElement($, {
    dimColor: !0
  }, "Press ", F.keyName, " again to exit") : l === "rename" ? G8.default.createElement($, {
    dimColor: !0
  }, "Enter to save · Esc to cancel") : l === "search" ? G8.default.createElement($, {
    dimColor: !0
  }, "Enter or Esc to finish · type to filter") : G8.default.createElement($, {
    dimColor: !0
  }, (W ? `A to show ${J?"current dir":"all projects"} · ` : "") + (C ? "B to toggle branch · " : "") + (H ? "P to preview · R to rename · " : "") + "/ to search · Esc to exit" + wA())))
}
// @from(Start 14154587, End 14154890)
function Vx3(A) {
  let Q = A.reduce((B, G) => {
    let Z = G.messages[0]?.sessionId;
    if (Z) {
      let I = B.get(Z) || [];
      B.set(Z, [...I, G])
    }
    return B
  }, new Map);
  return Q.forEach((B) => B.sort((G, Z) => new Date(Z.modified).getTime() - new Date(G.modified).getTime())), Q
}
// @from(Start 14154895, End 14154897)
G8
// @from(Start 14154899, End 14154906)
Wx3 = 2
// @from(Start 14154910, End 14154917)
Xx3 = 4
// @from(Start 14154923, End 14155067)
GJ1 = L(() => {
  hA();
  i8();
  S5();
  mK9();
  Q4();
  PV();
  CrA();
  ZY();
  S7();
  _0();
  q0();
  cK9();
  g1();
  G8 = BA(VA(), 1)
})
// @from(Start 14155069, End 14155591)
async function La(A) {
  let Q = dQ(),
    G = {
      macos: ["pbcopy"],
      linux: ["xclip -selection clipboard", "wl-copy"],
      wsl: ["clip.exe"],
      windows: ["clip"],
      unknown: ["xclip -selection clipboard", "wl-copy"]
    } [Q];
  for (let Z of G) try {
    return await us(Z, {
      input: A,
      shell: !0,
      reject: !0
    }), !0
  } catch (I) {
    AA(Error(`Failed to execute clipboard command "${Z}": ${I}`));
    continue
  }
  return AA(Error(`Failed to copy to clipboard on ${Q}`)), !1
}
// @from(Start 14155593, End 14156241)
function ZJ1() {
  let A = dQ();
  return {
    macos: "Failed to copy to clipboard. Make sure the `pbcopy` command is available on your system and try again.",
    windows: "Failed to copy to clipboard. Make sure the `clip` command is available on your system and try again.",
    wsl: "Failed to copy to clipboard. Make sure the `clip.exe` command is available in your WSL environment and try again.",
    linux: "Failed to copy to clipboard. Make sure `xclip` or `wl-copy` is installed on your system and try again.",
    unknown: "Failed to copy to clipboard. Make sure `xclip` or `wl-copy` is installed on your system and try again."
  } [A]
}
// @from(Start 14156246, End 14156288)
$SA = L(() => {
  sFA();
  g1();
  Q3()
})
// @from(Start 14156291, End 14156628)
function IJ1(A, Q) {
  let B = uQ();
  if (Q && A.projectPath && A.projectPath !== B) {
    let G = A.messages.find((I) => I.sessionId)?.sessionId;
    return {
      isCrossProject: !0,
      command: `cd ${z8([A.projectPath])} && claude --resume ${G}`,
      projectPath: A.projectPath
    }
  }
  return {
    isCrossProject: !1
  }
}
// @from(Start 14156633, End 14156666)
TF0 = L(() => {
  _0();
  dK()
})
// @from(Start 14156669, End 14156947)
function lK9(A) {
  switch (A.resultType) {
    case "sessionNotFound":
      return `Session ${tA.bold(A.arg)} was not found.`;
    case "multipleMatches":
      return `Found ${A.count} sessions matching ${tA.bold(A.arg)}. Please use /resume to pick a specific session.`
  }
}
// @from(Start 14156949, End 14157286)
function PF0({
  message: A,
  args: Q,
  onDone: B
}) {
  return s5.useEffect(() => {
    let G = setTimeout(B, 0);
    return () => clearTimeout(G)
  }, [B]), s5.createElement(S, {
    flexDirection: "column"
  }, s5.createElement($, {
    dimColor: !0
  }, "> /resume ", Q), s5.createElement(S0, null, s5.createElement($, null, A)))
}
// @from(Start 14157288, End 14158771)
function Fx3({
  onDone: A,
  onResume: Q
}) {
  let [B, G] = s5.useState([]), [Z, I] = s5.useState(!0), [Y, J] = s5.useState(!1), {
    rows: W
  } = WB(), X = s5.useCallback(async (H) => {
    try {
      let C = H ? await YJ1() : await eP();
      if (C.length === 0) {
        A("No conversations found to resume");
        return
      }
      G(C)
    } catch (C) {
      A("Failed to load conversations")
    } finally {
      I(!1)
    }
  }, [A]);
  s5.useEffect(() => {
    I(!0), G([]), X(Y)
  }, [Y]);
  let V = s5.useCallback(() => {
    J((H) => !H)
  }, []);
  async function F(H) {
    let C = nE(VP(H));
    if (!C) {
      A("Failed to resume conversation");
      return
    }
    let E = IJ1(H, Y);
    if (E.isCrossProject) {
      await La(E.command);
      let U = ["", "This conversation is from a different directory.", "", "To resume, run:", `  ${E.command}`, "", "(Command copied to clipboard)", ""].join(`
`);
      A(U, {
        display: "user"
      });
      return
    }
    Q(C, H, "slash_command_picker")
  }

  function K() {
    A("Resume cancelled", {
      display: "system"
    })
  }
  if (Z) return s5.createElement(S, null, s5.createElement(g4, null), s5.createElement($, null, " Loading conversations…"));
  let D = B.filter((H) => !H.isSidechain);
  return s5.createElement(USA, {
    logs: D,
    maxHeight: W - 2,
    onCancel: K,
    onSelect: F,
    onLogsChanged: () => X(Y),
    showAllProjects: Y,
    onToggleAllProjects: V
  })
}
// @from(Start 14158776, End 14158778)
s5
// @from(Start 14158780, End 14158783)
Kx3
// @from(Start 14158785, End 14158788)
iK9
// @from(Start 14158794, End 14160688)
nK9 = L(() => {
  F9();
  hA();
  DY();
  GJ1();
  q8();
  S7();
  Sy();
  i8();
  $SA();
  TF0();
  s5 = BA(VA(), 1);
  Kx3 = {
    type: "local-jsx",
    name: "resume",
    description: "Resume a conversation",
    get argumentHint() {
      return ug() ? "[session-id or title]" : "[session-id]"
    },
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q, B) {
      let G = async (W, X, V) => {
        await Q.resume?.(W, X, V), A(void 0, {
          display: "skip"
        })
      }, Z = B?.trim();
      if (!Z) return s5.createElement(Fx3, {
        key: Date.now(),
        onDone: A,
        onResume: G
      });
      let I = await eP();
      if (I.length === 0) return s5.createElement(PF0, {
        message: "No conversations found to resume.",
        args: Z,
        onDone: () => A("No conversations found to resume.")
      });
      let Y = nE(Z);
      if (Y) {
        let W = I.filter((X) => VP(X) === Y).sort((X, V) => V.modified.getTime() - X.modified.getTime());
        if (W.length > 0) return G(Y, W[0], "slash_command_session_id"), null
      }
      if (ug()) {
        let W = await mXA(Z, {
          exact: !0
        });
        if (W.length === 1) {
          let X = W[0],
            V = VP(X);
          if (V) return G(V, X, "slash_command_title"), null
        }
        if (W.length > 1) {
          let X = lK9({
            resultType: "multipleMatches",
            arg: Z,
            count: W.length
          });
          return s5.createElement(PF0, {
            message: X,
            args: Z,
            onDone: () => A(X)
          })
        }
      }
      let J = lK9({
        resultType: "sessionNotFound",
        arg: Z
      });
      return s5.createElement(PF0, {
        message: J,
        args: Z,
        onDone: () => A(J)
      })
    },
    userFacingName() {
      return "resume"
    }
  }, iK9 = Kx3
})
// @from(Start 14160694, End 14160697)
JJ1
// @from(Start 14160703, End 14161967)
jF0 = L(() => {
  pF();
  JJ1 = {
    type: "prompt",
    name: "review",
    description: "Review a pull request",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "reviewing pull request",
    userFacingName() {
      return "review"
    },
    source: "builtin",
    async getPromptForCommand(A) {
      return [{
        type: "text",
        text: `
      You are an expert code reviewer. Follow these steps:

      1. If no PR number is provided in the args, use ${D9.name}("gh pr list") to show open PRs
      2. If a PR number is provided, use ${D9.name}("gh pr view <number>") to get PR details
      3. Use ${D9.name}("gh pr diff <number>") to get the diff
      4. Analyze the changes and provide a thorough code review that includes:
         - Overview of what the PR does
         - Analysis of code quality and style
         - Specific suggestions for improvements
         - Any potential issues or risks
      
      Keep your review concise but thorough. Focus on:
      - Code correctness
      - Following project conventions
      - Performance implications
      - Test coverage
      - Security considerations

      Format your review with clear sections and bullet points.

      PR number: ${A}
    `
      }]
    }
  }
})
// @from(Start 14161973, End 14161987)
aK9 = () => {}
// @from(Start 14161993, End 14161996)
SF0
// @from(Start 14161998, End 14162001)
Dx3
// @from(Start 14162003, End 14162006)
sK9
// @from(Start 14162012, End 14162481)
rK9 = L(() => {
  dY1();
  SF0 = BA(VA(), 1), Dx3 = {
    type: "local-jsx",
    name: "status",
    description: "Show Claude Code status including version, model, account, API connectivity, and tool statuses",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q) {
      return SF0.createElement(zVA, {
        onClose: A,
        context: Q,
        defaultTab: "Status"
      })
    },
    userFacingName() {
      return "status"
    }
  }, sK9 = Dx3
})
// @from(Start 14162487, End 14162490)
_F0
// @from(Start 14162492, End 14162495)
Hx3
// @from(Start 14162497, End 14162500)
oK9
// @from(Start 14162506, End 14162912)
tK9 = L(() => {
  fW0();
  _F0 = BA(VA(), 1), Hx3 = {
    type: "local-jsx",
    name: "tasks",
    aliases: ["bashes"],
    description: "List and manage background tasks",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q) {
      return _F0.createElement(WI1, {
        toolUseContext: Q,
        onDone: A
      })
    },
    userFacingName() {
      return "tasks"
    }
  }, oK9 = Hx3
})
// @from(Start 14162918, End 14162932)
eK9 = () => {}
// @from(Start 14162935, End 14163427)
function AD9() {
  let A = e1(),
    Q = Nh(A);
  if (Q.length === 0) return Zj.default.createElement($, null, "No todos currently tracked");
  return Zj.default.createElement(S, {
    flexDirection: "column"
  }, Zj.default.createElement($, null, Zj.default.createElement($, {
    bold: !0
  }, Q.length, " ", Q.length === 1 ? "todo" : "todos"), Zj.default.createElement($, null, ":")), Zj.default.createElement(S, {
    marginTop: 1
  }, Zj.default.createElement(Yn, {
    todos: Q
  })))
}
// @from(Start 14163432, End 14163434)
Zj
// @from(Start 14163436, End 14163439)
Cx3
// @from(Start 14163441, End 14163444)
QD9
// @from(Start 14163450, End 14164056)
BD9 = L(() => {
  Ti();
  _0();
  hA();
  DSA();
  HRA();
  Zj = BA(VA(), 1);
  Cx3 = {
    type: "local-jsx",
    name: "todos",
    description: "List current todo items",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, {
      options: {
        isNonInteractiveSession: Q
      }
    }) {
      if (Q) {
        let B = await UVA(Zj.default.createElement(AD9, null));
        return A(B), null
      }
      return Zj.default.createElement($VA, {
        onComplete: A
      }, Zj.default.createElement(AD9, null))
    },
    userFacingName() {
      return "todos"
    }
  }, QD9 = Cx3
})
// @from(Start 14164062, End 14174947)
Ex3 = `---
allowed-tools: Bash(git diff:*), Bash(git status:*), Bash(git log:*), Bash(git show:*), Bash(git remote show:*), Read, Glob, Grep, LS, Task
description: Complete a security review of the pending changes on the current branch
---

You are a senior security engineer conducting a focused security review of the changes on this branch.

GIT STATUS:

\`\`\`
!\`git status\`
\`\`\`

FILES MODIFIED:

\`\`\`
!\`git diff --name-only origin/HEAD...\`
\`\`\`

COMMITS:

\`\`\`
!\`git log --no-decorate origin/HEAD...\`
\`\`\`

DIFF CONTENT:

\`\`\`
!\`git diff --merge-base origin/HEAD\`
\`\`\`

Review the complete diff above. This contains all code changes in the PR.


OBJECTIVE:
Perform a security-focused code review to identify HIGH-CONFIDENCE security vulnerabilities that could have real exploitation potential. This is not a general code review - focus ONLY on security implications newly added by this PR. Do not comment on existing security concerns.

CRITICAL INSTRUCTIONS:
1. MINIMIZE FALSE POSITIVES: Only flag issues where you're >80% confident of actual exploitability
2. AVOID NOISE: Skip theoretical issues, style concerns, or low-impact findings
3. FOCUS ON IMPACT: Prioritize vulnerabilities that could lead to unauthorized access, data breaches, or system compromise
4. EXCLUSIONS: Do NOT report the following issue types:
   - Denial of Service (DOS) vulnerabilities, even if they allow service disruption
   - Secrets or sensitive data stored on disk (these are handled by other processes)
   - Rate limiting or resource exhaustion issues

SECURITY CATEGORIES TO EXAMINE:

**Input Validation Vulnerabilities:**
- SQL injection via unsanitized user input
- Command injection in system calls or subprocesses
- XXE injection in XML parsing
- Template injection in templating engines
- NoSQL injection in database queries
- Path traversal in file operations

**Authentication & Authorization Issues:**
- Authentication bypass logic
- Privilege escalation paths
- Session management flaws
- JWT token vulnerabilities
- Authorization logic bypasses

**Crypto & Secrets Management:**
- Hardcoded API keys, passwords, or tokens
- Weak cryptographic algorithms or implementations
- Improper key storage or management
- Cryptographic randomness issues
- Certificate validation bypasses

**Injection & Code Execution:**
- Remote code execution via deseralization
- Pickle injection in Python
- YAML deserialization vulnerabilities
- Eval injection in dynamic code execution
- XSS vulnerabilities in web applications (reflected, stored, DOM-based)

**Data Exposure:**
- Sensitive data logging or storage
- PII handling violations
- API endpoint data leakage
- Debug information exposure

Additional notes:
- Even if something is only exploitable from the local network, it can still be a HIGH severity issue

ANALYSIS METHODOLOGY:

Phase 1 - Repository Context Research (Use file search tools):
- Identify existing security frameworks and libraries in use
- Look for established secure coding patterns in the codebase
- Examine existing sanitization and validation patterns
- Understand the project's security model and threat model

Phase 2 - Comparative Analysis:
- Compare new code changes against existing security patterns
- Identify deviations from established secure practices
- Look for inconsistent security implementations
- Flag code that introduces new attack surfaces

Phase 3 - Vulnerability Assessment:
- Examine each modified file for security implications
- Trace data flow from user inputs to sensitive operations
- Look for privilege boundaries being crossed unsafely
- Identify injection points and unsafe deserialization

REQUIRED OUTPUT FORMAT:

You MUST output your findings in markdown. The markdown output should contain the file, line number, severity, category (e.g. \`sql_injection\` or \`xss\`), description, exploit scenario, and fix recommendation. 

For example:

# Vuln 1: XSS: \`foo.py:42\`

* Severity: High
* Description: User input from \`username\` parameter is directly interpolated into HTML without escaping, allowing reflected XSS attacks
* Exploit Scenario: Attacker crafts URL like /bar?q=<script>alert(document.cookie)</script> to execute JavaScript in victim's browser, enabling session hijacking or data theft
* Recommendation: Use Flask's escape() function or Jinja2 templates with auto-escaping enabled for all user inputs rendered in HTML

SEVERITY GUIDELINES:
- **HIGH**: Directly exploitable vulnerabilities leading to RCE, data breach, or authentication bypass
- **MEDIUM**: Vulnerabilities requiring specific conditions but with significant impact
- **LOW**: Defense-in-depth issues or lower-impact vulnerabilities

CONFIDENCE SCORING:
- 0.9-1.0: Certain exploit path identified, tested if possible
- 0.8-0.9: Clear vulnerability pattern with known exploitation methods
- 0.7-0.8: Suspicious pattern requiring specific conditions to exploit
- Below 0.7: Don't report (too speculative)

FINAL REMINDER:
Focus on HIGH and MEDIUM findings only. Better to miss some theoretical issues than flood the report with false positives. Each finding should be something a security engineer would confidently raise in a PR review.

FALSE POSITIVE FILTERING:

> You do not need to run commands to reproduce the vulnerability, just read the code to determine if it is a real vulnerability. Do not use the bash tool or write to any files.
>
> HARD EXCLUSIONS - Automatically exclude findings matching these patterns:
> 1. Denial of Service (DOS) vulnerabilities or resource exhaustion attacks.
> 2. Secrets or credentials stored on disk if they are otherwise secured.
> 3. Rate limiting concerns or service overload scenarios.
> 4. Memory consumption or CPU exhaustion issues.
> 5. Lack of input validation on non-security-critical fields without proven security impact.
> 6. Input sanitization concerns for GitHub Action workflows unless they are clearly triggerable via untrusted input.
> 7. A lack of hardening measures. Code is not expected to implement all security best practices, only flag concrete vulnerabilities.
> 8. Race conditions or timing attacks that are theoretical rather than practical issues. Only report a race condition if it is concretely problematic.
> 9. Vulnerabilities related to outdated third-party libraries. These are managed separately and should not be reported here.
> 10. Memory safety issues such as buffer overflows or use-after-free-vulnerabilities are impossible in rust. Do not report memory safety issues in rust or any other memory safe languages.
> 11. Files that are only unit tests or only used as part of running tests.
> 12. Log spoofing concerns. Outputting un-sanitized user input to logs is not a vulnerability.
> 13. SSRF vulnerabilities that only control the path. SSRF is only a concern if it can control the host or protocol.
> 14. Including user-controlled content in AI system prompts is not a vulnerability.
> 15. Regex injection. Injecting untrusted content into a regex is not a vulnerability.
> 16. Regex DOS concerns.
> 16. Insecure documentation. Do not report any findings in documentation files such as markdown files.
> 17. A lack of audit logs is not a vulnerability.
> 
> PRECEDENTS -
> 1. Logging high value secrets in plaintext is a vulnerability. Logging URLs is assumed to be safe.
> 2. UUIDs can be assumed to be unguessable and do not need to be validated.
> 3. Environment variables and CLI flags are trusted values. Attackers are generally not able to modify them in a secure environment. Any attack that relies on controlling an environment variable is invalid.
> 4. Resource management issues such as memory or file descriptor leaks are not valid.
> 5. Subtle or low impact web vulnerabilities such as tabnabbing, XS-Leaks, prototype pollution, and open redirects should not be reported unless they are extremely high confidence.
> 6. React and Angular are generally secure against XSS. These frameworks do not need to sanitize or escape user input unless it is using dangerouslySetInnerHTML, bypassSecurityTrustHtml, or similar methods. Do not report XSS vulnerabilities in React or Angular components or tsx files unless they are using unsafe methods.
> 7. Most vulnerabilities in github action workflows are not exploitable in practice. Before validating a github action workflow vulnerability ensure it is concrete and has a very specific attack path.
> 8. A lack of permission checking or authentication in client-side JS/TS code is not a vulnerability. Client-side code is not trusted and does not need to implement these checks, they are handled on the server-side. The same applies to all flows that send untrusted data to the backend, the backend is responsible for validating and sanitizing all inputs.
> 9. Only include MEDIUM findings if they are obvious and concrete issues.
> 10. Most vulnerabilities in ipython notebooks (*.ipynb files) are not exploitable in practice. Before validating a notebook vulnerability ensure it is concrete and has a very specific attack path where untrusted input can trigger the vulnerability.
> 11. Logging non-PII data is not a vulnerability even if the data may be sensitive. Only report logging vulnerabilities if they expose sensitive information such as secrets, passwords, or personally identifiable information (PII).
> 12. Command injection vulnerabilities in shell scripts are generally not exploitable in practice since shell scripts generally do not run with untrusted user input. Only report command injection vulnerabilities in shell scripts if they are concrete and have a very specific attack path for untrusted input.
> 
> SIGNAL QUALITY CRITERIA - For remaining findings, assess:
> 1. Is there a concrete, exploitable vulnerability with a clear attack path?
> 2. Does this represent a real security risk vs theoretical best practice?
> 3. Are there specific code locations and reproduction steps?
> 4. Would this finding be actionable for a security team?
> 
> For each finding, assign a confidence score from 1-10:
> - 1-3: Low confidence, likely false positive or noise
> - 4-6: Medium confidence, needs investigation
> - 7-10: High confidence, likely true vulnerability

START ANALYSIS:

Begin your analysis now. Do this in 3 steps:

1. Use a sub-task to identify vulnerabilities. Use the repository exploration tools to understand the codebase context, then analyze the PR changes for security implications. In the prompt for this sub-task, include all of the above.
2. Then for each vulnerability identified by the above sub-task, create a new sub-task to filter out false-positives. Launch these sub-tasks as parallel sub-tasks. In the prompt for these sub-tasks, include everything in the "FALSE POSITIVE FILTERING" instructions.
3. Filter out any vulnerabilities where the sub-task reported a confidence less than 8.

Your final reply must contain the markdown report and nothing else.`
// @from(Start 14174951, End 14174954)
GD9
// @from(Start 14174960, End 14175974)
ZD9 = L(() => {
  OjA();
  _y();
  GD9 = {
    type: "prompt",
    name: "security-review",
    description: "Complete a security review of the pending changes on the current branch",
    isEnabled: () => !0,
    isHidden: !1,
    progressMessage: "analyzing code changes for security risks",
    userFacingName() {
      return "security-review"
    },
    source: "builtin",
    async getPromptForCommand(A, Q) {
      let B = NV(Ex3),
        G = UO(B.frontmatter["allowed-tools"]);
      return [{
        type: "text",
        text: await Fa(B.content, {
          ...Q,
          async getAppState() {
            let I = await Q.getAppState();
            return {
              ...I,
              toolPermissionContext: {
                ...I.toolPermissionContext,
                alwaysAllowRules: {
                  ...I.toolPermissionContext.alwaysAllowRules,
                  command: G
                }
              }
            }
          }
        }, "security-review")
      }]
    }
  }
})
// @from(Start 14175980, End 14175983)
kF0
// @from(Start 14175985, End 14175988)
ID9
// @from(Start 14175994, End 14176377)
YD9 = L(() => {
  dY1();
  kF0 = BA(VA(), 1), ID9 = {
    type: "local-jsx",
    name: "usage",
    description: "Show plan usage limits",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q) {
      return kF0.createElement(zVA, {
        onClose: A,
        context: Q,
        defaultTab: "Usage"
      })
    },
    userFacingName() {
      return "usage"
    }
  }
})
// @from(Start 14176380, End 14176850)
function zx3() {
  let A = N1(),
    Q = A.editorMode || "normal";
  if (Q === "emacs") Q = "normal";
  let B = Q === "normal" ? "vim" : "normal";
  return c0({
    ...A,
    editorMode: B
  }), GA("tengu_editor_mode_changed", {
    mode: B,
    source: "command"
  }), Promise.resolve({
    type: "text",
    value: `Editor mode set to ${B}. ${B==="vim"?"Use Escape key to toggle between INSERT and NORMAL modes.":"Using standard (readline) keyboard bindings."}`
  })
}
// @from(Start 14176855, End 14176858)
Ux3
// @from(Start 14176860, End 14176863)
JD9
// @from(Start 14176869, End 14177150)
WD9 = L(() => {
  jQ();
  q0();
  Ux3 = {
    name: "vim",
    description: "Toggle between Vim and Normal editing modes",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    type: "local",
    userFacingName: () => "vim",
    call: zx3
  }, JD9 = Ux3
})
// @from(Start 14177156, End 14177159)
yF0
// @from(Start 14177161, End 14177164)
$x3
// @from(Start 14177166, End 14177169)
XD9
// @from(Start 14177175, End 14177579)
VD9 = L(() => {
  fV0();
  yF0 = BA(VA(), 1), $x3 = {
    type: "local-jsx",
    name: "permissions",
    aliases: ["allowed-tools"],
    description: "Manage allow & deny tool permission rules",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A) {
      return yF0.createElement(kY1, {
        onExit: A
      })
    },
    userFacingName() {
      return "permissions"
    }
  }, XD9 = $x3
})
// @from(Start 14177582, End 14178140)
function wx3({
  planContent: A,
  planPath: Q,
  editorName: B
}) {
  return QJ.createElement(S, {
    flexDirection: "column"
  }, QJ.createElement($, {
    bold: !0
  }, "Current Plan"), QJ.createElement($, {
    dimColor: !0
  }, Q), QJ.createElement(S, {
    marginTop: 1
  }, QJ.createElement($, null, A)), B && QJ.createElement(S, {
    marginTop: 1
  }, QJ.createElement($, {
    dimColor: !0
  }, '"/plan open"'), QJ.createElement($, {
    dimColor: !0
  }, " to edit this plan in "), QJ.createElement($, {
    bold: !0,
    dimColor: !0
  }, B)))
}
// @from(Start 14178145, End 14178147)
QJ
// @from(Start 14178149, End 14178152)
qx3
// @from(Start 14178154, End 14178157)
FD9
// @from(Start 14178163, End 14179251)
KD9 = L(() => {
  hA();
  _0();
  NE();
  pn();
  nY();
  DSA();
  QJ = BA(VA(), 1);
  qx3 = {
    type: "local-jsx",
    name: "plan",
    description: "View or open the current session plan",
    argumentHint: "[open]",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, {
      options: {
        isNonInteractiveSession: Q
      }
    }, B) {
      let G = e1(),
        Z = xU(G),
        I = yU(G);
      if (!Z) return A("No plan found for current session"), null;
      if (B.trim().split(/\s+/)[0] === "open") try {
        return await cn(I), A(`Opened plan in editor: ${I}`), null
      } catch (V) {
        return A(`Failed to open plan in editor: ${V}`), null
      }
      let J = Jg(),
        W = J ? aF(J) : void 0,
        X = QJ.createElement(wx3, {
          planContent: Z,
          planPath: I,
          editorName: W
        });
      if (Q) {
        let V = await UVA(X);
        return A(V), null
      }
      return QJ.createElement($VA, {
        onComplete: A
      }, X)
    },
    userFacingName() {
      return "plan"
    }
  }, FD9 = qx3
})
// @from(Start 14179254, End 14182929)
function DD9({
  onDone: A
}) {
  let [Q, B] = nQA.useState(!0), [G, Z] = nQA.useState([]), [I, Y] = nQA.useState(!1), [J, W] = nQA.useState(null), X = EQ(() => A("Guest passes dialog dismissed", {
    display: "system"
  }));
  if (f1((D, H) => {
      if (H.escape) A("Guest passes dialog dismissed", {
        display: "system"
      });
      if (H.return && J)(async () => {
        if (await La(J)) A("Referral link copied to clipboard!");
        else A(ZJ1(), {
          display: "system"
        })
      })()
    }), nQA.useEffect(() => {
      async function D() {
        try {
          let H = await xjA();
          if (!H || !H.eligible) {
            Y(!1), B(!1);
            return
          }
          if (Y(!0), H.referral_code_details?.referral_link) W(H.referral_code_details.referral_link);
          let C;
          try {
            C = await w59()
          } catch (w) {
            AA(w), Y(!1), B(!1);
            return
          }
          let E = C.redemptions || [],
            U = C.limit || 3,
            q = [];
          for (let w = 0; w < U; w++) {
            let N = E[w];
            q.push({
              passNumber: w + 1,
              isAvailable: !N
            })
          }
          Z(q), B(!1)
        } catch (H) {
          AA(H), Y(!1), B(!1)
        }
      }
      D()
    }, []), Q) return SB.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1
  }, SB.createElement($, {
    dimColor: !0
  }, "Loading guest pass information…"), SB.createElement($, {
    dimColor: !0,
    italic: !0
  }, X.pending ? SB.createElement(SB.Fragment, null, "Press ", X.keyName, " again to exit") : SB.createElement(SB.Fragment, null, "Esc to exit")));
  if (!I) return SB.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1
  }, SB.createElement($, null, "Guest passes are not currently available."), SB.createElement($, {
    dimColor: !0,
    italic: !0
  }, X.pending ? SB.createElement(SB.Fragment, null, "Press ", X.keyName, " again to exit") : SB.createElement(SB.Fragment, null, "Esc to exit")));
  let V = G.filter((D) => D.isAvailable).length,
    F = [...G].sort((D, H) => +H.isAvailable - +D.isAvailable),
    K = (D) => {
      if (!D.isAvailable) return SB.createElement(S, {
        key: D.passNumber,
        flexDirection: "column",
        marginRight: 1
      }, SB.createElement($, {
        dimColor: !0
      }, "┌─────────╱"), SB.createElement($, {
        dimColor: !0
      }, " ) CC ✻ ┊╱"), SB.createElement($, {
        dimColor: !0
      }, "└───────╱"));
      return SB.createElement(S, {
        key: D.passNumber,
        flexDirection: "column",
        marginRight: 1
      }, SB.createElement($, null, "┌─────────┐"), SB.createElement($, null, " ) CC ", SB.createElement($, {
        color: "claude"
      }, "✻"), " ┊( "), SB.createElement($, null, "└─────────┘"))
    };
  return SB.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1
  }, SB.createElement($, {
    color: "permission"
  }, "Guest passes · ", V, " left"), SB.createElement(S, {
    flexDirection: "row",
    marginLeft: 2
  }, F.map((D) => K(D))), J && SB.createElement(S, {
    marginLeft: 2
  }, SB.createElement($, null, J)), SB.createElement(S, {
    flexDirection: "column",
    marginLeft: 2
  }, SB.createElement($, {
    dimColor: !0
  }, "Share a free week of Claude Code with friends.")), SB.createElement(S, null, SB.createElement($, {
    dimColor: !0,
    italic: !0
  }, X.pending ? SB.createElement(SB.Fragment, null, "Press ", X.keyName, " again to exit") : SB.createElement(SB.Fragment, null, "Enter to copy link · Esc to exit"))))
}
// @from(Start 14182934, End 14182936)
SB
// @from(Start 14182938, End 14182941)
nQA
// @from(Start 14182947, End 14183045)
HD9 = L(() => {
  hA();
  vjA();
  g1();
  $SA();
  Q4();
  SB = BA(VA(), 1), nQA = BA(VA(), 1)
})
// @from(Start 14183051, End 14183054)
xF0
// @from(Start 14183056, End 14183059)
CD9
// @from(Start 14183065, End 14183631)
ED9 = L(() => {
  HD9();
  jQ();
  q0();
  xF0 = BA(VA(), 1), CD9 = {
    type: "local-jsx",
    name: "passes",
    description: "Share a free week of Claude Code with friends",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A) {
      let Q = N1(),
        B = !Q.hasVisitedPasses;
      if (B) c0({
        ...Q,
        hasVisitedPasses: !0
      });
      return GA("tengu_guest_passes_visited", {
        is_first_visit: B
      }), xF0.createElement(DD9, {
        onDone: A
      })
    },
    userFacingName() {
      return "passes"
    }
  }
})
// @from(Start 14183634, End 14184083)
function zD9(A, Q, B) {
  if (A !== null && A.grove_enabled !== null) return !1;
  if (B) return !0;
  if (Q !== null && !Q.notice_is_grace_period) return !0;
  let Z = Q?.notice_reminder_frequency;
  if (Z !== null && Z !== void 0 && A?.grove_notice_viewed_at) return Math.floor((Date.now() - new Date(A.grove_notice_viewed_at).getTime()) / 86400000) >= Z;
  else {
    let I = A?.grove_notice_viewed_at;
    return I === null || I === void 0
  }
}
// @from(Start 14184085, End 14185932)
function Lx3() {
  return _Q.default.createElement(_Q.default.Fragment, null, _Q.default.createElement(S, {
    flexDirection: "column"
  }, _Q.default.createElement($, {
    bold: !0,
    color: "professionalBlue"
  }, "Updates to Consumer Terms and Policies"), _Q.default.createElement($, null, "An update to our Consumer Terms and Privacy Policy will take effect on", " ", _Q.default.createElement($, {
    bold: !0
  }, "October 8, 2025"), ". You can accept the updated terms today.")), _Q.default.createElement(S, {
    flexDirection: "column"
  }, _Q.default.createElement($, null, "What's changing?"), _Q.default.createElement(S, {
    paddingLeft: 1
  }, _Q.default.createElement($, null, _Q.default.createElement($, null, "• "), _Q.default.createElement($, {
    bold: !0
  }, "You can help improve Claude "), _Q.default.createElement($, null, "— Allow the use of your chats and coding sessions to train and improve Anthropic AI models. Change anytime in your Privacy Settings (", _Q.default.createElement(h4, {
    url: "https://claude.ai/settings/data-privacy-controls"
  }), ")."))), _Q.default.createElement(S, {
    paddingLeft: 1
  }, _Q.default.createElement($, null, _Q.default.createElement($, null, "• "), _Q.default.createElement($, {
    bold: !0
  }, "Updates to data retention "), _Q.default.createElement($, null, "— To help us improve our AI models and safety protections, we're extending data retention to 5 years.")))), _Q.default.createElement($, null, "Learn more (", _Q.default.createElement(h4, {
    url: "https://www.anthropic.com/news/updates-to-our-consumer-terms"
  }), ") or read the updated Consumer Terms (", _Q.default.createElement(h4, {
    url: "https://anthropic.com/legal/terms"
  }), ") and Privacy Policy (", _Q.default.createElement(h4, {
    url: "https://anthropic.com/legal/privacy"
  }), ")"))
}
// @from(Start 14185934, End 14187578)
function Mx3() {
  return _Q.default.createElement(_Q.default.Fragment, null, _Q.default.createElement(S, {
    flexDirection: "column"
  }, _Q.default.createElement($, {
    bold: !0,
    color: "professionalBlue"
  }, "Updates to Consumer Terms and Policies"), _Q.default.createElement($, null, "We've updated our Consumer Terms and Privacy Policy.")), _Q.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, _Q.default.createElement($, null, "What's changing?"), _Q.default.createElement(S, {
    flexDirection: "column"
  }, _Q.default.createElement($, {
    bold: !0
  }, "Help improve Claude"), _Q.default.createElement($, null, "Allow the use of your chats and coding sessions to train and improve Anthropic AI models. You can change this anytime in Privacy Settings"), _Q.default.createElement(h4, {
    url: "https://claude.ai/settings/data-privacy-controls"
  })), _Q.default.createElement(S, {
    flexDirection: "column"
  }, _Q.default.createElement($, {
    bold: !0
  }, "How this affects data retention"), _Q.default.createElement($, null, "Turning ON the improve Claude setting extends data retention from 30 days to 5 years. Turning it OFF keeps the default 30-day data retention. Delete data anytime."))), _Q.default.createElement($, null, "Learn more (", _Q.default.createElement(h4, {
    url: "https://www.anthropic.com/news/updates-to-our-consumer-terms"
  }), ") or read the updated Consumer Terms (", _Q.default.createElement(h4, {
    url: "https://anthropic.com/legal/terms"
  }), ") and Privacy Policy (", _Q.default.createElement(h4, {
    url: "https://anthropic.com/legal/privacy"
  }), ")"))
}
// @from(Start 14187580, End 14190819)
function WJ1({
  showIfAlreadyViewed: A,
  location: Q,
  onDone: B
}) {
  let [G, Z] = _Q.useState(null), [I, Y] = _Q.useState(null), J = EQ();
  if (_Q.useEffect(() => {
      async function V() {
        let [F, K] = await Promise.all([bYA(), yi()]);
        Y(K);
        let D = zD9(F, K, A);
        if (Z(D), !D) {
          B("skip_rendering");
          return
        }
        _Q0(), GA("tengu_grove_policy_viewed", {
          location: Q,
          dismissable: K?.notice_is_grace_period
        })
      }
      V()
    }, [A, Q, B]), G === null) return null;
  if (!G) return null;
  async function W(V) {
    switch (V) {
      case "accept_opt_in": {
        await i91(!0), GA("tengu_grove_policy_submitted", {
          state: !0,
          dismissable: I?.notice_is_grace_period
        });
        break
      }
      case "accept_opt_out": {
        await i91(!1), GA("tengu_grove_policy_submitted", {
          state: !1,
          dismissable: I?.notice_is_grace_period
        });
        break
      }
      case "defer":
        GA("tengu_grove_policy_dismissed", {
          state: !0
        });
        break;
      case "escape":
        GA("tengu_grove_policy_escaped", {});
        break
    }
    B(V)
  }
  let X = I?.domain_excluded ? [{
    label: "Accept terms • Help improve Claude: OFF (for emails with your domain)",
    value: "accept_opt_out"
  }] : [{
    label: "Accept terms • Help improve Claude: ON",
    value: "accept_opt_in"
  }, {
    label: "Accept terms • Help improve Claude: OFF",
    value: "accept_opt_out"
  }];
  return _Q.default.createElement(_Q.default.Fragment, null, _Q.default.createElement(S, {
    flexDirection: "column",
    width: 100,
    gap: 1,
    paddingTop: 1,
    paddingLeft: 1,
    paddingRight: 1,
    borderStyle: "round",
    borderColor: "professionalBlue"
  }, _Q.default.createElement(S, {
    flexDirection: "row"
  }, _Q.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    flexGrow: 1
  }, I?.notice_is_grace_period ? _Q.default.createElement(Lx3, null) : _Q.default.createElement(Mx3, null)), _Q.default.createElement(S, {
    flexShrink: 0
  }, _Q.default.createElement($, {
    color: "professionalBlue"
  }, Nx3))), _Q.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "professionalBlue"
  }, _Q.default.createElement(S, {
    flexDirection: "column"
  }, _Q.default.createElement($, {
    bold: !0
  }, "Please select how you'd like to continue"), _Q.default.createElement($, null, "Your choice takes effect immediately upon confirmation.")), _Q.default.createElement(M0, {
    options: [...X, ...I?.notice_is_grace_period ? [{
      label: "Not now",
      value: "defer"
    }] : []],
    onChange: (V) => W(V),
    onCancel: () => {
      if (I?.notice_is_grace_period) {
        W("defer");
        return
      }
      W("escape")
    }
  }))), _Q.default.createElement(S, {
    marginLeft: 1
  }, _Q.default.createElement($, {
    dimColor: !0
  }, J.pending ? _Q.default.createElement(_Q.default.Fragment, null, "Press ", J.keyName, " again to exit") : _Q.default.createElement(_Q.default.Fragment, null, "Enter to confirm · Esc to exit"))))
}
// @from(Start 14190821, End 14192758)
function UD9({
  settings: A,
  domainExcluded: Q,
  onDone: B
}) {
  let G = EQ(),
    [Z, I] = _Q.useState(A.grove_enabled);
  _Q.default.useEffect(() => {
    GA("tengu_grove_privacy_settings_viewed", {})
  }, []), f1(async (J, W) => {
    if (W.escape) B();
    if (!Q && (W.tab || W.return || J === " ")) {
      let X = !Z;
      I(X), await i91(X)
    }
  });
  let Y = _Q.default.createElement($, {
    color: "error"
  }, "false");
  if (Q) Y = _Q.default.createElement($, {
    color: "error"
  }, "false (for emails with your domain)");
  else if (Z) Y = _Q.default.createElement($, {
    color: "success"
  }, "true");
  return _Q.default.createElement(_Q.default.Fragment, null, _Q.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "professionalBlue"
  }, _Q.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, _Q.default.createElement($, {
    bold: !0,
    color: "professionalBlue"
  }, "Data Privacy"), _Q.default.createElement($, null, "Review and manage your privacy settings at", " ", _Q.default.createElement(h4, {
    url: "https://claude.ai/settings/data-privacy-controls"
  })), _Q.default.createElement(S, null, _Q.default.createElement(S, {
    width: 44
  }, _Q.default.createElement($, {
    bold: !0
  }, "Help improve Claude")), _Q.default.createElement(S, null, Y)))), _Q.default.createElement(S, {
    marginLeft: 1
  }, Q ? _Q.default.createElement($, {
    dimColor: !0
  }, G.pending ? _Q.default.createElement(_Q.default.Fragment, null, "Press ", G.keyName, " again to exit") : _Q.default.createElement(_Q.default.Fragment, null, "Esc to exit")) : _Q.default.createElement($, {
    dimColor: !0
  }, G.pending ? _Q.default.createElement(_Q.default.Fragment, null, "Press ", G.keyName, " again to exit") : _Q.default.createElement(_Q.default.Fragment, null, "Enter/Tab/Space to toggle · Esc to exit"))))
}
// @from(Start 14192759, End 14193336)
async function $D9() {
  let [A, Q] = await Promise.all([bYA(), yi()]);
  if (zD9(A, Q, !1))
    if (GA("tengu_grove_print_viewed", {
        dismissable: Q?.notice_is_grace_period
      }), Q === null || Q.notice_is_grace_period) Sj(`
An update to our Consumer Terms and Privacy Policy will take effect on October 8, 2025. Run \`claude\` to review the updated terms.

`), await _Q0();
    else Sj(`
[ACTION REQUIRED] An update to our Consumer Terms and Privacy Policy has taken effect on October 8, 2025. You must run \`claude\` to review the updated terms.

`), await v6(1)
}
// @from(Start 14193341, End 14193343)
_Q
// @from(Start 14193345, End 14193550)
Nx3 = ` _____________
 |          \\  \\
 | NEW TERMS \\__\\
 |              |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |  ----------  |
 |              |
 |______________|`
// @from(Start 14193556, End 14193650)
XJ1 = L(() => {
  hA();
  J5();
  q0();
  Q4();
  hYA();
  kW();
  hA();
  _Q = BA(VA(), 1)
})
// @from(Start 14193656, End 14193659)
wSA
// @from(Start 14193661, End 14193760)
wD9 = "Review and manage your privacy settings at https://claude.ai/settings/data-privacy-controls"
// @from(Start 14193764, End 14193767)
Ox3
// @from(Start 14193769, End 14193772)
qD9
// @from(Start 14193778, End 14195310)
ND9 = L(() => {
  XJ1();
  hYA();
  q0();
  gB();
  wSA = BA(VA(), 1), Ox3 = {
    type: "local-jsx",
    name: "privacy-settings",
    description: "View and update your privacy settings",
    isEnabled: () => {
      return OiA()
    },
    isHidden: !1,
    async call(A) {
      if (!await fYA()) return A(wD9), null;
      let [B, G] = await Promise.all([bYA(), yi()]);
      if (B === null) return A(wD9), null;
      async function Z(Y) {
        if (Y === "escape" || Y === "defer") {
          A("Privacy settings dialog dismissed", {
            display: "system"
          });
          return
        }
        await I()
      }
      async function I() {
        let Y = await bYA();
        if (Y === null) {
          A("Unable to retrieve updated privacy settings", {
            display: "system"
          });
          return
        }
        let J = Y.grove_enabled ? "true" : "false";
        if (A(`"Help improve Claude" set to ${J}.`), B !== null && B.grove_enabled !== null && B.grove_enabled !== Y.grove_enabled) GA("tengu_grove_policy_toggled", {
          state: Y.grove_enabled,
          location: "settings"
        })
      }
      if (B.grove_enabled !== null) return wSA.createElement(UD9, {
        settings: B,
        domainExcluded: G?.domain_excluded,
        onDone: I
      });
      return wSA.createElement(WJ1, {
        showIfAlreadyViewed: !0,
        onDone: Z,
        location: "settings"
      })
    },
    userFacingName() {
      return "privacy-settings"
    }
  }, qD9 = Ox3
})
// @from(Start 14195313, End 14197026)
function LD9({
  event: A,
  eventSummary: Q,
  config: B,
  matcher: G,
  onSuccess: Z,
  onCancel: I
}) {
  let [Y, J] = vF0.useState(!1), [W, X] = vF0.useState(null), V = HYA.map(R00), F = async (K) => {
    J(!0), X(null);
    try {
      await MZ2(A, B, G, K), Z()
    } catch (D) {
      X(D instanceof Error ? D.message : "Failed to add hook"), J(!1)
    }
  };
  if (Y) return m3.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, m3.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, m3.createElement(g4, null), m3.createElement($, null, "Adding hook configuration...")));
  if (W) return m3.createElement(S, {
    flexDirection: "column",
    gap: 1,
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "error"
  }, m3.createElement($, {
    bold: !0,
    color: "error"
  }, "Failed to add hook"), m3.createElement($, null, W), m3.createElement(M0, {
    options: [{
      label: "OK",
      value: "ok"
    }],
    onChange: I,
    onCancel: I
  }));
  return m3.createElement(S, {
    flexDirection: "column",
    gap: 1,
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "success"
  }, m3.createElement($, {
    bold: !0,
    color: "success"
  }, "Save hook configuration"), m3.createElement(S, {
    flexDirection: "column",
    marginX: 2
  }, m3.createElement($, null, "Event: ", A, " - ", Q), m3.createElement($, null, "Matcher: ", G), m3.createElement($, null, B.type === "command" ? "Command" : "Prompt", ":", " ", hE(B))), m3.createElement($, null, "Where should this hook be saved?"), m3.createElement(M0, {
    options: V,
    onChange: (K) => F(K),
    onCancel: I,
    visibleOptionCount: 3
  }))
}
// @from(Start 14197031, End 14197033)
m3
// @from(Start 14197035, End 14197038)
vF0
// @from(Start 14197044, End 14197141)
MD9 = L(() => {
  hA();
  dk();
  S5();
  DY();
  a21();
  m3 = BA(VA(), 1), vF0 = BA(VA(), 1)
})
// @from(Start 14197144, End 14200556)
function OD9({
  hookEventMetadata: A,
  exitStatePending: Q,
  exitStateKeyName: B,
  configDifference: G,
  restrictedByPolicy: Z,
  onSelectEvent: I
}) {
  return XB.createElement(XB.Fragment, null, XB.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "warning"
  }, XB.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, XB.createElement(S, null, XB.createElement($, {
    bold: !0,
    color: "warning"
  }, "Hook Configuration")), XB.createElement(S, {
    flexDirection: "column"
  }, XB.createElement(S, {
    marginY: 1
  }, XB.createElement($, null, tA.bold("Hooks"), " are shell commands you can register to run during Claude Code processing.", " ", XB.createElement(h4, {
    url: "https://code.claude.com/docs/en/hooks"
  }, "Docs"))), XB.createElement(S, {
    flexDirection: "column",
    paddingTop: 1
  }, XB.createElement($, null, "• Each hook event has its own input and output behavior"), XB.createElement($, null, "• Multiple hooks can be registered per event, executed in parallel"), XB.createElement($, null, "• Any changes to hooks outside of /hooks require a restart"), XB.createElement($, null, "• Timeout: 60 seconds"))), XB.createElement(S, {
    flexDirection: "column",
    marginY: 1
  }, XB.createElement($, null, H1.warning, " Hooks execute shell commands with your full user permissions. This can pose security risks, so only use hooks from trusted sources."), XB.createElement($, {
    dimColor: !0
  }, "Learn more:", " ", XB.createElement(h4, {
    url: "https://code.claude.com/docs/en/hooks"
  }, "https://code.claude.com/docs/en/hooks"))), Z && XB.createElement(S, {
    borderStyle: "round",
    borderColor: "suggestion",
    paddingX: 1,
    marginY: 1
  }, XB.createElement(S, {
    flexDirection: "column"
  }, XB.createElement($, {
    bold: !0,
    color: "suggestion"
  }, H1.info, " Hooks Restricted by Policy"), XB.createElement($, null, "Only hooks from managed settings can run. User-defined hooks from ~/.claude/settings.json, .claude/settings.json, and .claude/settings.local.json are blocked."))), G && XB.createElement(S, {
    borderStyle: "round",
    borderColor: "warning",
    paddingX: 1,
    marginY: 1
  }, XB.createElement(S, {
    flexDirection: "column"
  }, XB.createElement($, {
    bold: !0,
    color: "warning"
  }, H1.warning, " Settings Changed"), XB.createElement($, null, "Hook settings have been modified outside of this menu. Review the following changes carefully:"), XB.createElement($, {
    dimColor: !0
  }, G)))), XB.createElement(S, {
    flexDirection: "column"
  }, XB.createElement($, {
    bold: !0
  }, "Select hook event:"), XB.createElement(M0, {
    onChange: (Y) => {
      if (Y === "disable-all") I("disable-all");
      else I(Y)
    },
    onCancel: () => {},
    options: [...Object.entries(A).map(([Y, J]) => ({
      label: `${Y} - ${J.summary}`,
      value: Y
    })), {
      label: tA.red("Disable all hooks"),
      value: "disable-all"
    }]
  }))), XB.createElement(S, {
    marginLeft: 3
  }, XB.createElement($, {
    dimColor: !0
  }, Q ? XB.createElement(XB.Fragment, null, "Press ", B, " again to exit") : XB.createElement(XB.Fragment, null, XB.createElement(E4, {
    shortcut: "Enter",
    action: "select"
  }), " · ", XB.createElement(E4, {
    shortcut: "Esc",
    action: "exit"
  })))))
}
// @from(Start 14200561, End 14200563)
XB
// @from(Start 14200569, End 14200654)
RD9 = L(() => {
  hA();
  S5();
  F9();
  V9();
  hA();
  dF();
  XB = BA(VA(), 1)
})
// @from(Start 14200657, End 14202310)
function TD9({
  selectedEvent: A,
  matchersForSelectedEvent: Q,
  hooksByEventAndMatcher: B,
  eventDescription: G,
  onSelect: Z,
  onCancel: I
}) {
  let Y = K7.useMemo(() => {
    return Q.map((J) => {
      let W = B[A]?.[J] || [],
        X = Array.from(new Set(W.map((V) => V.source)));
      return {
        matcher: J,
        sources: X,
        hookCount: W.length
      }
    })
  }, [Q, B, A]);
  return K7.createElement(K7.Fragment, null, K7.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "suggestion"
  }, K7.createElement($, {
    bold: !0,
    color: "suggestion"
  }, A, " - Tool Matchers"), G && K7.createElement(S, {
    marginTop: 1
  }, K7.createElement($, {
    dimColor: !0
  }, G)), K7.createElement(S, {
    marginY: 1
  }, K7.createElement(M0, {
    options: [{
      label: `+ Add new matcher${H1.ellipsis}`,
      value: "add-new"
    }, ...Y.map((J) => {
      return {
        label: `[${J.sources.map(TZ2).join(", ")}] ${J.matcher}`,
        value: J.matcher,
        description: `${J.hookCount} hook${J.hookCount!==1?"s":""}`
      }
    })],
    onChange: (J) => {
      if (J === "add-new") Z(null);
      else Z(J)
    },
    onCancel: I
  }), Q.length === 0 && K7.createElement(S, {
    marginLeft: 2
  }, K7.createElement($, {
    dimColor: !0
  }, "No matchers configured yet")))), K7.createElement(S, {
    marginLeft: 3
  }, K7.createElement($, {
    dimColor: !0
  }, K7.createElement(E4, {
    shortcut: "Enter",
    action: "select"
  }), " · ", K7.createElement(E4, {
    shortcut: "Esc",
    action: "go back"
  }))))
}
// @from(Start 14202315, End 14202317)
K7
// @from(Start 14202323, End 14202400)
PD9 = L(() => {
  hA();
  V9();
  dk();
  S5();
  dF();
  K7 = BA(VA(), 1)
})
// @from(Start 14202403, End 14204028)
function jD9({
  selectedEvent: A,
  newMatcher: Q,
  onChangeNewMatcher: B,
  eventDescription: G,
  matcherMetadata: Z
}) {
  let [I, Y] = y8.useState(Q.length);
  return y8.createElement(y8.Fragment, null, y8.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "success",
    gap: 1
  }, y8.createElement($, {
    bold: !0,
    color: "success"
  }, "Add new matcher for ", A), G && y8.createElement(S, {
    marginBottom: 1
  }, y8.createElement($, {
    dimColor: !0
  }, G)), y8.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, y8.createElement($, null, "Possible matcher values for field ", Z.fieldToMatch, ":"), y8.createElement($, {
    dimColor: !0
  }, Z.values.join(", "))), y8.createElement(S, {
    flexDirection: "column"
  }, y8.createElement($, null, "Tool matcher:"), y8.createElement(S, {
    borderStyle: "round",
    borderDimColor: !0,
    paddingLeft: 1,
    paddingRight: 1
  }, y8.createElement(s4, {
    value: Q,
    onChange: B,
    columns: 78,
    showCursor: !0,
    cursorOffset: I,
    onChangeCursorOffset: Y
  }))), y8.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, y8.createElement($, {
    dimColor: !0
  }, "Example Matchers:", `
`, "• Write (single tool)", `
`, "• Write|Edit (multiple tools)", `
`, "• Web.* (regex pattern)"))), y8.createElement(S, {
    marginLeft: 3
  }, y8.createElement($, {
    dimColor: !0
  }, y8.createElement(E4, {
    shortcut: "Enter",
    action: "confirm"
  }), " · ", y8.createElement(E4, {
    shortcut: "Esc",
    action: "cancel"
  }))))
}
// @from(Start 14204033, End 14204035)
y8
// @from(Start 14204041, End 14204102)
SD9 = L(() => {
  hA();
  ZY();
  dF();
  y8 = BA(VA(), 1)
})
// @from(Start 14204105, End 14206871)
function _D9({
  selectedEvent: A,
  selectedMatcher: Q,
  eventDescription: B,
  fullDescription: G,
  supportsMatcher: Z,
  command: I,
  onChangeCommand: Y
}) {
  let [J, W] = f2.useState(I.length), {
    columns: X
  } = WB(), V = I.trim().split(/\s+/)[0] || "", F = V && !V.startsWith("/") && !V.startsWith("~") && V.includes("/"), K = /\bsudo\b/.test(I);
  return f2.createElement(f2.Fragment, null, f2.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "success",
    gap: 1
  }, f2.createElement($, {
    bold: !0,
    color: "success"
  }, "Add new hook"), f2.createElement(S, {
    flexDirection: "column"
  }, f2.createElement($, null, H1.warning, " Hooks execute shell commands with your full user permissions. This can pose security risks, so only use hooks from trusted sources."), f2.createElement($, {
    dimColor: !0
  }, "Learn more:", " ", f2.createElement(h4, {
    url: "https://code.claude.com/docs/en/hooks"
  }, "https://code.claude.com/docs/en/hooks"))), f2.createElement($, null, "Event: ", f2.createElement($, {
    bold: !0
  }, A), " - ", B), G && f2.createElement(S, null, f2.createElement($, {
    dimColor: !0
  }, G)), Z && f2.createElement($, null, "Matcher: ", f2.createElement($, {
    bold: !0
  }, Q)), f2.createElement($, null, "Command:"), f2.createElement(S, {
    borderStyle: "round",
    borderDimColor: !0,
    paddingLeft: 1,
    paddingRight: 1
  }, f2.createElement(s4, {
    value: I,
    onChange: Y,
    columns: X - 8,
    showCursor: !0,
    cursorOffset: J,
    onChangeCursorOffset: W,
    multiline: !0
  })), (F || K) && f2.createElement(S, {
    flexDirection: "column",
    gap: 0
  }, F && f2.createElement($, {
    color: "warning"
  }, H1.warning, " Warning: Using a relative path for the executable may be insecure. Consider using an absolute path instead."), K && f2.createElement($, {
    color: "warning"
  }, H1.warning, " Warning: Using sudo in hooks can be dangerous and may expose your system to security risks.")), f2.createElement($, {
    dimColor: !0
  }, "Examples:", f2.createElement(bF, null), `• jq -r '.tool_input.file_path | select(endswith(".go"))' | xargs -r gofmt -w`, f2.createElement(bF, null), `• jq -r '"\\(.tool_input.command) - \\(.tool_input.description // "No description")"' >> ~/.claude/bash-command-log.txt`, f2.createElement(bF, null), "• /usr/local/bin/security_check.sh", f2.createElement(bF, null), "• python3 ~/hooks/validate_changes.py")), f2.createElement(S, {
    marginLeft: 3
  }, f2.createElement($, {
    dimColor: !0
  }, f2.createElement(E4, {
    shortcut: "Enter",
    action: "confirm"
  }), " · ", f2.createElement(E4, {
    shortcut: "Esc",
    action: "cancel"
  }))))
}
// @from(Start 14206876, End 14206878)
f2
// @from(Start 14206884, End 14206969)
kD9 = L(() => {
  hA();
  ZY();
  V9();
  hA();
  i8();
  dF();
  f2 = BA(VA(), 1)
})
// @from(Start 14206972, End 14208048)
function yD9({
  selectedMatcher: A,
  selectedEvent: Q,
  onDelete: B,
  onCancel: G
}) {
  return iG.createElement(iG.Fragment, null, iG.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "error",
    gap: 1
  }, iG.createElement($, {
    bold: !0,
    color: "error"
  }, "Delete matcher?"), iG.createElement(S, {
    flexDirection: "column",
    marginX: 2
  }, iG.createElement($, {
    bold: !0
  }, A), iG.createElement($, {
    color: "text"
  }, "Event: ", Q)), iG.createElement($, null, "This matcher has no hooks configured. Delete it?"), iG.createElement(M0, {
    onChange: (Z) => Z === "yes" ? B() : G(),
    onCancel: G,
    options: [{
      label: "Yes",
      value: "yes"
    }, {
      label: "No",
      value: "no"
    }]
  })), iG.createElement(S, {
    marginLeft: 3
  }, iG.createElement($, {
    dimColor: !0
  }, iG.createElement(E4, {
    shortcut: "Enter",
    action: "confirm"
  }), " · ", iG.createElement(E4, {
    shortcut: "Esc",
    action: "cancel"
  }))))
}
// @from(Start 14208053, End 14208055)
iG
// @from(Start 14208061, End 14208122)
xD9 = L(() => {
  hA();
  S5();
  dF();
  iG = BA(VA(), 1)
})
// @from(Start 14208125, End 14209758)
function vD9({
  selectedEvent: A,
  selectedMatcher: Q,
  hooksForSelectedMatcher: B,
  hookEventMetadata: G,
  onSelect: Z,
  onCancel: I
}) {
  return e7.createElement(e7.Fragment, null, e7.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "success"
  }, e7.createElement($, {
    bold: !0,
    color: "success"
  }, A, G.matcherMetadata !== void 0 ? ` - Matcher: ${Q}` : ""), G.description && e7.createElement(S, {
    marginTop: 1
  }, e7.createElement($, {
    dimColor: !0
  }, G.description)), e7.createElement(S, {
    marginY: 1
  }, e7.createElement(M0, {
    options: [{
      label: `+ Add new hook${H1.ellipsis}`,
      value: "add-new"
    }, ...B.map((Y, J) => ({
      label: Y.source === "pluginHook" ? `${hE(Y.config)} (read-only)` : hE(Y.config),
      value: J.toString(),
      description: Y.source === "pluginHook" ? `${T00(Y.source)} - disable ${Y.pluginName?Y.pluginName:"plugin"} to remove` : T00(Y.source),
      disabled: Y.source === "pluginHook"
    }))],
    onChange: (Y) => {
      if (Y === "add-new") Z(null);
      else {
        let J = parseInt(Y, 10),
          W = B[J];
        if (W) Z(W)
      }
    },
    onCancel: I
  }), B.length === 0 && e7.createElement(S, {
    marginLeft: 2
  }, e7.createElement($, {
    dimColor: !0
  }, "No hooks configured yet")))), e7.createElement(S, {
    marginLeft: 3
  }, e7.createElement($, {
    dimColor: !0
  }, e7.createElement(E4, {
    shortcut: "Enter",
    action: "select"
  }), " · ", e7.createElement(E4, {
    shortcut: "Esc",
    action: "go back"
  }))))
}
// @from(Start 14209763, End 14209765)
e7
// @from(Start 14209771, End 14209848)
bD9 = L(() => {
  V9();
  hA();
  dk();
  S5();
  dF();
  e7 = BA(VA(), 1)
})
// @from(Start 14209851, End 14211089)
function fD9({
  selectedHook: A,
  eventSupportsMatcher: Q,
  onDelete: B,
  onCancel: G
}) {
  return D7.createElement(D7.Fragment, null, D7.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "error",
    gap: 1
  }, D7.createElement($, {
    bold: !0,
    color: "error"
  }, "Delete hook?"), D7.createElement(S, {
    flexDirection: "column",
    marginX: 2
  }, D7.createElement($, {
    bold: !0
  }, hE(A.config)), D7.createElement($, {
    dimColor: !0
  }, "Event: ", A.event), Q && D7.createElement($, {
    dimColor: !0
  }, "Matcher: ", A.matcher), D7.createElement($, {
    dimColor: !0
  }, RZ2(A.source))), D7.createElement($, null, "This will remove the hook configuration from your settings."), D7.createElement(M0, {
    onChange: (Z) => Z === "yes" ? B() : G(),
    onCancel: G,
    options: [{
      label: "Yes",
      value: "yes"
    }, {
      label: "No",
      value: "no"
    }]
  })), D7.createElement(S, {
    marginLeft: 3
  }, D7.createElement($, {
    dimColor: !0
  }, D7.createElement(E4, {
    shortcut: "Enter",
    action: "confirm"
  }), " · ", D7.createElement(E4, {
    shortcut: "Esc",
    action: "cancel"
  }))))
}
// @from(Start 14211094, End 14211096)
D7
// @from(Start 14211102, End 14211171)
hD9 = L(() => {
  hA();
  dk();
  S5();
  dF();
  D7 = BA(VA(), 1)
})
// @from(Start 14211174, End 14212284)
function gD9(A, Q) {
  let B = {
      PreToolUse: {},
      PostToolUse: {},
      PostToolUseFailure: {},
      Notification: {},
      UserPromptSubmit: {},
      SessionStart: {},
      SessionEnd: {},
      Stop: {},
      SubagentStart: {},
      SubagentStop: {},
      PreCompact: {},
      PermissionRequest: {}
    },
    G = qSA(Q);
  LZ2(A).forEach((I) => {
    let Y = B[I.event];
    if (Y) {
      let J = G[I.event].matcherMetadata !== void 0 ? I.matcher || "" : "";
      if (!Y[J]) Y[J] = [];
      Y[J].push(I)
    }
  });
  let Z = MkA();
  if (Z)
    for (let [I, Y] of Object.entries(Z)) {
      let J = I,
        W = B[J];
      if (!W) continue;
      for (let X of Y) {
        let V = X.matcher || "";
        if (!W[V]) W[V] = [];
        for (let F of X.hooks)
          if (F.type === "callback") W[V].push({
            event: J,
            config: {
              type: "command",
              command: "[Plugin Hook]"
            },
            matcher: X.matcher,
            source: "pluginHook",
            pluginName: X.pluginName
          })
      }
    }
  return B
}
// @from(Start 14212286, End 14212365)
function uD9(A, Q) {
  let B = Object.keys(A[Q] || {});
  return PZ2(B, A, Q)
}
// @from(Start 14212367, End 14212436)
function mD9(A, Q, B) {
  let G = B ?? "";
  return A[Q]?.[G] ?? []
}
// @from(Start 14212438, End 14212494)
function sg(A, Q) {
  return qSA(Q)[A].matcherMetadata
}
// @from(Start 14212496, End 14212545)
function dD9(A, Q) {
  return qSA(Q)[A].summary
}
// @from(Start 14212550, End 14212553)
qSA
// @from(Start 14212559, End 14217271)
cD9 = L(() => {
  l2();
  dk();
  _0();
  qSA = s1(function(A) {
    return {
      PreToolUse: {
        summary: "Before tool execution",
        description: `Input to command is JSON of tool call arguments.
Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to model and block tool call
Other exit codes - show stderr to user only but continue with tool call`,
        matcherMetadata: {
          fieldToMatch: "tool_name",
          values: A
        }
      },
      PostToolUse: {
        summary: "After tool execution",
        description: `Input to command is JSON with fields "inputs" (tool call arguments) and "response" (tool call response).
Exit code 0 - stdout shown in transcript mode (ctrl+o)
Exit code 2 - show stderr to model immediately
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "tool_name",
          values: A
        }
      },
      PostToolUseFailure: {
        summary: "After tool execution fails",
        description: `Input to command is JSON with tool_name, tool_input, tool_use_id, error, error_type, is_interrupt, and is_timeout.
Exit code 0 - stdout shown in transcript mode (ctrl+o)
Exit code 2 - show stderr to model immediately
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "tool_name",
          values: A
        }
      },
      Notification: {
        summary: "When notifications are sent",
        description: `Input to command is JSON with notification message and type.
Exit code 0 - stdout/stderr not shown
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "notification_type",
          values: ["permission_prompt", "idle_prompt", "auth_success", "elicitation_dialog"]
        }
      },
      UserPromptSubmit: {
        summary: "When the user submits a prompt",
        description: `Input to command is JSON with original user prompt text.
Exit code 0 - stdout shown to Claude
Exit code 2 - block processing, erase original prompt, and show stderr to user only
Other exit codes - show stderr to user only`
      },
      SessionStart: {
        summary: "When a new session is started",
        description: `Input to command is JSON with session start source.
Exit code 0 - stdout shown to Claude
Blocking errors are ignored
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "source",
          values: ["startup", "resume", "clear", "compact"]
        }
      },
      Stop: {
        summary: "Right before Claude concludes its response",
        description: `Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to model and continue conversation
Other exit codes - show stderr to user only`
      },
      SubagentStart: {
        summary: "When a subagent (Task tool call) is started",
        description: `Input to command is JSON with agent_id and agent_type.
Exit code 0 - stdout shown to subagent
Blocking errors are ignored
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "agent_type",
          values: []
        }
      },
      SubagentStop: {
        summary: "Right before a subagent (Task tool call) concludes its response",
        description: `Exit code 0 - stdout/stderr not shown
Exit code 2 - show stderr to subagent and continue having it run
Other exit codes - show stderr to user only`
      },
      PreCompact: {
        summary: "Before conversation compaction",
        description: `Input to command is JSON with compaction details.
Exit code 0 - stdout appended as custom compact instructions
Exit code 2 - block compaction
Other exit codes - show stderr to user only but continue with compaction`,
        matcherMetadata: {
          fieldToMatch: "trigger",
          values: ["manual", "auto"]
        }
      },
      SessionEnd: {
        summary: "When a session is ending",
        description: `Input to command is JSON with session end reason.
Exit code 0 - command completes successfully
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "reason",
          values: ["clear", "logout", "prompt_input_exit", "other"]
        }
      },
      PermissionRequest: {
        summary: "When a permission dialog is displayed",
        description: `Input to command is JSON with tool_name, tool_input, and tool_use_id.
Output JSON with hookSpecificOutput containing decision to allow or deny.
Exit code 0 - use hook decision if provided
Other exit codes - show stderr to user only`,
        matcherMetadata: {
          fieldToMatch: "tool_name",
          values: A
        }
      }
    }
  })
})
// @from(Start 14217274, End 14228912)
function pD9({
  toolNames: A,
  onExit: Q
}) {
  let [B, G] = rJ.useState([]), [Z, I] = rJ.useState({
    mode: "select-event"
  }), [Y, J] = rJ.useState(0), [W, X] = rJ.useState(() => {
    return l0()?.disableAllHooks === !0 && OB("policySettings")?.disableAllHooks === !0
  }), [V, F] = rJ.useState(() => {
    return OB("policySettings")?.allowManagedHooksOnly === !0
  });
  t7A((NA) => {
    if (NA === "policySettings") {
      let mA = l0()?.disableAllHooks === !0;
      X(mA && OB("policySettings")?.disableAllHooks === !0), F(OB("policySettings")?.allowManagedHooksOnly === !0)
    }
  });
  let [K, D] = rJ.useState(""), [H, C] = rJ.useState(""), E = Z.mode, U = "event" in Z ? Z.event : "PreToolUse", q = "matcher" in Z ? Z.matcher : null, [w] = OQ(), {
    mcp: N
  } = w, R = rJ.useMemo(() => [...A, ...N.tools.map((NA) => NA.name)], [A, N.tools]), T = rJ.useMemo(() => gD9(w, R), [R, Y, w]), y = rJ.useMemo(() => uD9(T, U), [T, U]), v = rJ.useMemo(() => mD9(T, U, q), [T, U, q]), x = EQ();
  f1((NA, OA) => {
    if (E === "save-hook") return;
    if (OA.escape) {
      switch (E) {
        case "select-event":
          if (B.length > 0) Q(B.join(`
`));
          else Q("Hooks dialog dismissed", {
            display: "system"
          });
          break;
        case "select-matcher":
          I({
            mode: "select-event"
          });
          break;
        case "add-matcher":
          if ("event" in Z) I({
            mode: "select-matcher",
            event: Z.event,
            matcherMetadata: Z.matcherMetadata
          });
          C("");
          break;
        case "delete-matcher":
          if ("event" in Z) I({
            mode: "select-matcher",
            event: Z.event,
            matcherMetadata: Z.matcherMetadata
          });
          break;
        case "select-hook":
          if ("event" in Z) {
            let mA = sg(Z.event, R);
            if (mA !== void 0) I({
              mode: "select-matcher",
              event: Z.event,
              matcherMetadata: mA
            });
            else I({
              mode: "select-event"
            })
          }
          break;
        case "add-hook":
          if ("event" in Z && "matcher" in Z) I({
            mode: "select-hook",
            event: Z.event,
            matcher: Z.matcher
          });
          D("");
          break;
        case "delete-hook":
          if ("event" in Z && Z.mode === "delete-hook") {
            let {
              hook: mA
            } = Z;
            I({
              mode: "select-hook",
              event: Z.event,
              matcher: mA.matcher || ""
            })
          }
          break
      }
      return
    }
    switch (E) {
      case "select-event":
        if (OA.return) {
          let mA = U,
            wA = sg(mA, R);
          if (wA !== void 0) I({
            mode: "select-matcher",
            event: mA,
            matcherMetadata: wA
          });
          else I({
            mode: "select-hook",
            event: mA,
            matcher: ""
          })
        }
        break;
      case "add-matcher":
        if (OA.return && H.trim() && "event" in Z) I({
          mode: "select-hook",
          event: Z.event,
          matcher: H.trim()
        });
        break;
      case "add-hook":
        if (OA.return && K.trim() && "event" in Z && "matcher" in Z) {
          let mA = {
            event: Z.event,
            config: {
              type: "command",
              command: K.trim()
            },
            matcher: sg(Z.event, R) !== void 0 ? Z.matcher : ""
          };
          I({
            mode: "save-hook",
            event: Z.event,
            hookToSave: mA
          })
        }
        break;
      case "delete-matcher":
      case "delete-hook":
      case "select-matcher":
      case "select-hook":
        break
    }
  });
  let p = rJ.useCallback(() => {
      if (Z.mode === "save-hook") {
        let {
          hookToSave: NA
        } = Z;
        G((OA) => [...OA, `Added ${NA.event} hook: ${tA.bold(hE(NA.config))}`]), I({
          mode: "select-hook",
          event: NA.event,
          matcher: NA.matcher
        })
      }
      D(""), J((NA) => NA + 1)
    }, [Z]),
    u = rJ.useCallback(() => {
      if (Z.mode === "save-hook") {
        let {
          hookToSave: NA
        } = Z;
        I({
          mode: "select-hook",
          event: NA.event,
          matcher: NA.matcher
        })
      }
      D("")
    }, [Z]),
    e = rJ.useCallback(async () => {
      if (Z.mode !== "delete-hook") return;
      let {
        hook: NA,
        event: OA
      } = Z;
      await OZ2(NA), G((qA) => [...qA, `Deleted ${NA.event} hook: ${tA.bold(hE(NA.config))}`]), J((qA) => qA + 1);
      let mA = NA.matcher || "",
        wA = T[OA]?.[mA]?.filter((qA) => !SMA(qA.config, NA.config));
      if (!wA || wA.length === 0) {
        let qA = sg(OA, R);
        if (qA !== void 0) I({
          mode: "select-matcher",
          event: OA,
          matcherMetadata: qA
        });
        else I({
          mode: "select-event"
        })
      } else I({
        mode: "select-hook",
        event: OA,
        matcher: mA
      })
    }, [Z, T, R]),
    l = rJ.useCallback(() => {
      if (Z.mode === "delete-matcher") {
        let {
          matcher: NA,
          event: OA
        } = Z;
        G((mA) => [...mA, `Deleted matcher: ${tA.bold(NA)}`]), I({
          mode: "select-matcher",
          event: OA,
          matcherMetadata: Z.matcherMetadata
        })
      }
    }, [Z]),
    k = qSA(R),
    m = jZ2();
  rJ.useEffect(() => {
    _MA()
  }, []);
  let IA = l0()?.disableAllHooks === !0,
    FA = rJ.useCallback(() => {
      Q(B.length > 0 ? B.join(`
`) : "Hooks dialog dismissed", {
        display: B.length === 0 ? "system" : void 0
      })
    }, [B, Q]),
    zA = rJ.useMemo(() => Object.values(T).reduce((NA, OA) => {
      return NA + Object.values(OA).reduce((mA, wA) => mA + wA.length, 0)
    }, 0), [T]);
  if (IA) return k9.createElement(k9.Fragment, null, k9.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    paddingLeft: 1,
    paddingRight: 1,
    borderColor: "warning"
  }, k9.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, k9.createElement(S, null, k9.createElement($, {
    bold: !0,
    color: "warning"
  }, "Hook Configuration - Disabled")), k9.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, k9.createElement($, null, "All hooks are currently ", tA.red("disabled"), W && " by a managed settings file", ". You have", " ", tA.bold(zA), " configured hook", zA !== 1 ? "s" : "", " that", " ", zA !== 1 ? "are" : "is", " not running."), k9.createElement(S, {
    marginTop: 1
  }, k9.createElement($, null, "When hooks are disabled:")), k9.createElement($, null, "• No hook commands will execute"), k9.createElement($, null, "• StatusLine will not be displayed"), k9.createElement($, null, "• Tool operations will proceed without hook validation"))), !W && k9.createElement(S, {
    flexDirection: "column"
  }, k9.createElement($, {
    bold: !0
  }, "Options:"), k9.createElement(M0, {
    options: [{
      label: "Re-enable all hooks",
      value: "enable"
    }, {
      label: "Exit",
      value: "exit"
    }],
    onChange: (NA) => {
      if (NA === "enable") cB("localSettings", {
        disableAllHooks: !1
      }), Q("Re-enabled all hooks");
      else FA()
    },
    onCancel: FA
  }))), k9.createElement(S, {
    marginLeft: 3
  }, k9.createElement($, {
    dimColor: !0
  }, W ? "Esc to exit" : "Enter to select · Esc to exit")));
  switch (Z.mode) {
    case "save-hook":
      return k9.createElement(LD9, {
        event: Z.hookToSave.event,
        eventSummary: k[Z.hookToSave.event].summary,
        config: Z.hookToSave.config,
        matcher: Z.hookToSave.matcher,
        onSuccess: p,
        onCancel: u
      });
    case "select-event":
      return k9.createElement(OD9, {
        hookEventMetadata: k,
        exitStatePending: x.pending,
        exitStateKeyName: x.keyName || void 0,
        configDifference: m,
        restrictedByPolicy: V,
        onSelectEvent: (NA) => {
          if (NA === "disable-all") cB("localSettings", {
            disableAllHooks: !0
          }), Q("All hooks have been disabled");
          else {
            let OA = sg(NA, R);
            if (OA !== void 0) I({
              mode: "select-matcher",
              event: NA,
              matcherMetadata: OA
            });
            else I({
              mode: "select-hook",
              event: NA,
              matcher: ""
            })
          }
        }
      });
    case "select-matcher":
      return k9.createElement(TD9, {
        selectedEvent: Z.event,
        matchersForSelectedEvent: y,
        hooksByEventAndMatcher: T,
        eventDescription: k[Z.event].description,
        onSelect: (NA) => {
          if (NA === null) I({
            mode: "add-matcher",
            event: Z.event,
            matcherMetadata: Z.matcherMetadata
          });
          else if ((T[Z.event]?.[NA] || []).length === 0) I({
            mode: "delete-matcher",
            event: Z.event,
            matcher: NA,
            matcherMetadata: Z.matcherMetadata
          });
          else I({
            mode: "select-hook",
            event: Z.event,
            matcher: NA
          })
        },
        onCancel: () => {
          I({
            mode: "select-event"
          })
        }
      });
    case "add-matcher":
      return k9.createElement(jD9, {
        selectedEvent: Z.event,
        newMatcher: H,
        onChangeNewMatcher: C,
        eventDescription: k[Z.event].description,
        matcherMetadata: Z.matcherMetadata
      });
    case "delete-matcher":
      return k9.createElement(yD9, {
        selectedMatcher: Z.matcher,
        selectedEvent: Z.event,
        onDelete: l,
        onCancel: () => I({
          mode: "select-matcher",
          event: Z.event,
          matcherMetadata: Z.matcherMetadata
        })
      });
    case "select-hook":
      return k9.createElement(vD9, {
        selectedEvent: Z.event,
        selectedMatcher: Z.matcher,
        hooksForSelectedMatcher: v,
        hookEventMetadata: k[Z.event],
        onSelect: (NA) => {
          if (NA === null) I({
            mode: "add-hook",
            event: Z.event,
            matcher: Z.matcher
          });
          else I({
            mode: "delete-hook",
            event: Z.event,
            hook: NA
          })
        },
        onCancel: () => {
          let NA = sg(Z.event, R);
          if (NA !== void 0) I({
            mode: "select-matcher",
            event: Z.event,
            matcherMetadata: NA
          });
          else I({
            mode: "select-event"
          })
        }
      });
    case "add-hook":
      return k9.createElement(_D9, {
        selectedEvent: Z.event,
        selectedMatcher: Z.matcher,
        eventDescription: dD9(Z.event, R),
        fullDescription: k[Z.event].description,
        supportsMatcher: sg(Z.event, R) !== void 0,
        command: K,
        onChangeCommand: D
      });
    case "delete-hook":
      return k9.createElement(fD9, {
        selectedHook: Z.hook,
        eventSupportsMatcher: sg(Z.event, R) !== void 0,
        onDelete: e,
        onCancel: () => {
          let {
            event: NA,
            hook: OA
          } = Z;
          I({
            mode: "select-hook",
            event: NA,
            matcher: OA.matcher || ""
          })
        }
      })
  }
}
// @from(Start 14228917, End 14228919)
k9
// @from(Start 14228921, End 14228923)
rJ
// @from(Start 14228929, End 14229139)
lD9 = L(() => {
  F9();
  hA();
  Q4();
  dk();
  MD9();
  RD9();
  PD9();
  SD9();
  kD9();
  xD9();
  bD9();
  hD9();
  J5();
  cD9();
  CYA();
  z9();
  MB();
  YrA();
  k9 = BA(VA(), 1), rJ = BA(VA(), 1)
})
// @from(Start 14229145, End 14229148)
bF0
// @from(Start 14229150, End 14229153)
Rx3
// @from(Start 14229155, End 14229158)
iD9
// @from(Start 14229164, End 14229657)
nD9 = L(() => {
  lD9();
  yq();
  bF0 = BA(VA(), 1), Rx3 = {
    type: "local-jsx",
    name: "hooks",
    description: "Manage hook configurations for tool events",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q) {
      let G = (await Q.getAppState()).toolPermissionContext,
        Z = LC(G).map((I) => I.name);
      return bF0.createElement(pD9, {
        toolNames: Z,
        onExit: A
      })
    },
    userFacingName() {
      return "hooks"
    }
  }, iD9 = Rx3
})
// @from(Start 14229705, End 14229708)
Px3
// @from(Start 14229710, End 14229713)
aD9
// @from(Start 14229719, End 14230305)
sD9 = L(() => {
  U2();
  vM();
  Px3 = {
    type: "local",
    name: "files",
    description: "List all files currently in context",
    isEnabled: () => !1,
    isHidden: !1,
    supportsNonInteractive: !0,
    async call(A, Q) {
      let B = Q.readFileState ? _l(Q.readFileState) : [];
      if (B.length === 0) return {
        type: "text",
        value: "No files in context"
      };
      return {
        type: "text",
        value: `Files in context:
${B.map((Z)=>Tx3(W0(),Z)).join(`
`)}`
      }
    },
    userFacingName() {
      return "files"
    }
  }, aD9 = Px3
})
// @from(Start 14230311, End 14230313)
Ex
// @from(Start 14230319, End 14230403)
rD9 = L(() => {
  Ex = {
    FOLDER_NAME: ".claude",
    AGENTS_DIR: "agents"
  }
})
// @from(Start 14230443, End 14230734)
function oD9(A, Q, B, G, Z, I) {
  let Y = Q.replace(/\n/g, "\\n"),
    W = B === void 0 || B.length === 1 && B[0] === "*" ? "" : `
tools: ${B.join(", ")}`,
    X = I ? `
model: ${I}` : "",
    V = Z ? `
color: ${Z}` : "";
  return `---
name: ${A}
description: ${Y}${W}${X}${V}
---

${G}
`
}
// @from(Start 14230736, End 14231168)
function VJ1(A) {
  switch (A) {
    case "flagSettings":
      throw Error(`Cannot get directory path for ${A} agents`);
    case "userSettings":
      return rg(MQ(), Ex.AGENTS_DIR);
    case "projectSettings":
      return rg(W0(), Ex.FOLDER_NAME, Ex.AGENTS_DIR);
    case "policySettings":
      return rg(iw(), Ex.FOLDER_NAME, Ex.AGENTS_DIR);
    case "localSettings":
      return rg(W0(), Ex.FOLDER_NAME, Ex.AGENTS_DIR)
  }
}
// @from(Start 14231170, End 14231322)
function tD9(A) {
  switch (A) {
    case "projectSettings":
      return rg(".", Ex.FOLDER_NAME, Ex.AGENTS_DIR);
    default:
      return VJ1(A)
  }
}
// @from(Start 14231324, End 14231404)
function fF0(A) {
  let Q = VJ1(A.source);
  return rg(Q, `${A.agentType}.md`)
}
// @from(Start 14231406, End 14231645)
function FJ1(A) {
  if (A.source === "built-in") return "Built-in";
  if (A.source === "plugin") throw Error("Cannot get file path for plugin agents");
  let Q = VJ1(A.source),
    B = A.filename || A.agentType;
  return rg(Q, `${B}.md`)
}
// @from(Start 14231647, End 14231777)
function eD9(A) {
  if (A.source === "built-in") return "Built-in";
  let Q = tD9(A.source);
  return rg(Q, `${A.agentType}.md`)
}
// @from(Start 14231779, End 14231971)
function AH9(A) {
  if ($O(A)) return "Built-in";
  if (e51(A)) return `Plugin: ${A.plugin||"Unknown"}`;
  let Q = tD9(A.source),
    B = A.filename || A.agentType;
  return rg(Q, `${B}.md`)
}
// @from(Start 14231973, End 14232075)
function jx3(A) {
  let Q = VJ1(A),
    B = RA();
  if (!B.existsSync(Q)) B.mkdirSync(Q);
  return Q
}
// @from(Start 14232076, End 14232456)
async function hF0(A, Q, B, G, Z, I = !0, Y, J) {
  if (A === "built-in") throw Error("Cannot save built-in agents");
  jx3(A);
  let W = fF0({
      source: A,
      agentType: Q
    }),
    X = RA();
  if (I && X.existsSync(W)) throw Error(`Agent file already exists: ${W}`);
  let V = oD9(Q, B, G, Z, Y, J);
  X.writeFileSync(W, V, {
    encoding: "utf-8",
    flush: !0
  })
}
// @from(Start 14232457, End 14232715)
async function QH9(A, Q, B, G, Z, I) {
  if (A.source === "built-in") throw Error("Cannot update built-in agents");
  let Y = RA(),
    J = FJ1(A),
    W = oD9(A.agentType, Q, B, G, Z, I);
  Y.writeFileSync(J, W, {
    encoding: "utf-8",
    flush: !0
  })
}
// @from(Start 14232716, End 14232889)
async function BH9(A) {
  if (A.source === "built-in") throw Error("Cannot delete built-in agents");
  let Q = RA(),
    B = FJ1(A);
  if (Q.existsSync(B)) Q.unlinkSync(B)
}
// @from(Start 14232894, End 14232960)
NVA = L(() => {
  AQ();
  U2();
  hQ();
  fP();
  rD9();
  MB()
})
// @from(Start 14232963, End 14233453)
function Ma({
  title: A,
  titleColor: Q = "text",
  borderColor: B = "suggestion",
  children: G,
  subtitle: Z
}) {
  return Ij.createElement(S, {
    borderStyle: "round",
    borderColor: B,
    flexDirection: "column"
  }, Ij.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, Ij.createElement($, {
    bold: !0,
    color: Q
  }, A), Z && Ij.createElement($, {
    dimColor: !0
  }, Z)), Ij.createElement(S, {
    paddingX: 1,
    flexDirection: "column"
  }, G))
}
// @from(Start 14233458, End 14233460)
Ij
// @from(Start 14233466, End 14233511)
gF0 = L(() => {
  hA();
  Ij = BA(VA(), 1)
})
// @from(Start 14233514, End 14233685)
function LVA(A) {
  if (A === "all") return "Agents";
  if (A === "built-in") return "Built-in agents";
  if (A === "plugin") return "Plugin agents";
  return IKA(Pm(A))
}
// @from(Start 14233690, End 14233724)
KJ1 = L(() => {
  WH1();
  LV()
})
// @from(Start 14233727, End 14239291)
function GH9({
  source: A,
  agents: Q,
  onBack: B,
  onSelect: G,
  onCreateNew: Z,
  changes: I
}) {
  let [Y, J] = RQ.useState(null), [W, X] = RQ.useState(!0), V = (q) => {
    return {
      isOverridden: !!q.overriddenBy,
      overriddenBy: q.overriddenBy || null
    }
  }, F = () => {
    return RQ.createElement(S, null, RQ.createElement($, {
      color: W ? "suggestion" : void 0
    }, W ? `${H1.pointer} ` : "  "), RQ.createElement($, {
      color: W ? "suggestion" : void 0
    }, "Create new agent"))
  }, K = (q) => {
    let w = q.source === "built-in",
      N = !w && !W && Y?.agentType === q.agentType && Y?.source === q.source,
      {
        isOverridden: R,
        overriddenBy: T
      } = V(q),
      y = w || R,
      v = !w && N ? "suggestion" : void 0,
      x = q.model || Jh1;
    return RQ.createElement(S, {
      key: `${q.agentType}-${q.source}`
    }, RQ.createElement($, {
      dimColor: y && !N,
      color: v
    }, w ? "" : N ? `${H1.pointer} ` : "  "), RQ.createElement($, {
      dimColor: y && !N,
      color: v
    }, q.agentType), x && RQ.createElement($, {
      dimColor: !0,
      color: v
    }, " · ", x === "inherit" ? "inherit" : x), T && RQ.createElement($, {
      dimColor: !N,
      color: N ? "warning" : void 0
    }, " ", H1.warning, " overridden by ", T))
  }, D = RQ.useMemo(() => {
    let q = Q.filter((w) => w.source !== "built-in");
    if (A === "all") return [...q.filter((w) => w.source === "userSettings"), ...q.filter((w) => w.source === "projectSettings"), ...q.filter((w) => w.source === "policySettings")];
    return q
  }, [Q, A]);
  RQ.useEffect(() => {
    if (!Y && !W && D.length > 0)
      if (Z) X(!0);
      else J(D[0] || null)
  }, [D, Y, W, Z]), f1((q, w) => {
    if (w.escape) {
      B();
      return
    }
    if (w.return) {
      if (W && Z) Z();
      else if (Y) G(Y);
      return
    }
    if (!w.upArrow && !w.downArrow) return;
    let N = !!Z,
      R = D.length + (N ? 1 : 0);
    if (R === 0) return;
    let T = 0;
    if (!W && Y) {
      let v = D.findIndex((x) => x.agentType === Y.agentType && x.source === Y.source);
      if (v >= 0) T = N ? v + 1 : v
    }
    let y = w.upArrow ? T === 0 ? R - 1 : T - 1 : T === R - 1 ? 0 : T + 1;
    if (N && y === 0) X(!0), J(null);
    else {
      let v = N ? y - 1 : y,
        x = D[v];
      if (x) X(!1), J(x)
    }
  });
  let H = (q = "Built-in (always available):") => {
      let w = Q.filter((N) => N.source === "built-in");
      return RQ.createElement(S, {
        flexDirection: "column",
        marginBottom: 1,
        paddingLeft: 2
      }, RQ.createElement($, {
        bold: !0,
        dimColor: !0
      }, q), w.map(K))
    },
    C = (q, w) => {
      if (!w.length) return null;
      let N = w[0]?.baseDir;
      return RQ.createElement(S, {
        flexDirection: "column",
        marginBottom: 1
      }, RQ.createElement(S, {
        paddingLeft: 2
      }, RQ.createElement($, {
        bold: !0,
        dimColor: !0
      }, q), N && RQ.createElement($, {
        dimColor: !0
      }, " (", N, ")")), w.map((R) => K(R)))
    },
    E = LVA(A);
  if (!Q.length || A !== "built-in" && !Q.some((q) => q.source !== "built-in")) return RQ.createElement(Ma, {
    title: E,
    subtitle: "No agents found"
  }, Z && RQ.createElement(S, {
    marginY: 1
  }, F()), RQ.createElement($, {
    dimColor: !0
  }, "No agents found. Create specialized subagents that Claude can delegate to."), RQ.createElement($, {
    dimColor: !0
  }, "Each subagent has its own context window, custom system prompt, and specific tools."), RQ.createElement($, {
    dimColor: !0
  }, "Try creating: Code Reviewer, Code Simplifier, Security Reviewer, Tech Lead, or UX Reviewer."), A !== "built-in" && Q.some((q) => q.source === "built-in") && RQ.createElement(RQ.Fragment, null, RQ.createElement(S, {
    marginTop: 1
  }, RQ.createElement(D3, null)), H()));
  return RQ.createElement(Ma, {
    title: E,
    subtitle: `${Q.filter((q)=>!q.overriddenBy).length} agents`
  }, I && I.length > 0 && RQ.createElement(S, {
    marginTop: 1
  }, RQ.createElement($, {
    dimColor: !0
  }, I[I.length - 1])), RQ.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, Z && RQ.createElement(S, {
    marginBottom: 1
  }, F()), A === "all" ? RQ.createElement(RQ.Fragment, null, C("User agents", Q.filter((q) => q.source === "userSettings")), C("Project agents", Q.filter((q) => q.source === "projectSettings")), C("Managed agents", Q.filter((q) => q.source === "policySettings")), C("Plugin agents", Q.filter((q) => q.source === "plugin")), C("CLI arg agents", Q.filter((q) => q.source === "flagSettings")), (() => {
    let q = Q.filter((w) => w.source === "built-in");
    return q.length > 0 ? RQ.createElement(S, {
      flexDirection: "column",
      marginBottom: 1,
      paddingLeft: 2
    }, RQ.createElement($, {
      dimColor: !0
    }, RQ.createElement($, {
      bold: !0
    }, "Built-in agents"), " (always available)"), q.map(K)) : null
  })()) : A === "built-in" ? RQ.createElement(RQ.Fragment, null, RQ.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Built-in agents are provided by default and cannot be modified."), RQ.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, Q.map((q) => K(q)))) : RQ.createElement(RQ.Fragment, null, Q.filter((q) => q.source !== "built-in").map((q) => K(q)), Q.some((q) => q.source === "built-in") && RQ.createElement(RQ.Fragment, null, RQ.createElement(S, {
    marginTop: 1
  }, RQ.createElement(D3, null)), H()))))
}
// @from(Start 14239296, End 14239298)
RQ
// @from(Start 14239304, End 14239399)
ZH9 = L(() => {
  hA();
  hA();
  V9();
  BK();
  gF0();
  t2();
  KJ1();
  RQ = BA(VA(), 1)
})
// @from(Start 14239402, End 14240874)
function mF0({
  steps: A,
  initialData: Q = {},
  onComplete: B,
  onCancel: G,
  children: Z,
  title: I,
  showStepCounter: Y = !0
}) {
  let [J, W] = VV.useState(0), [X, V] = VV.useState(Q), [F, K] = VV.useState(!1), [D, H] = VV.useState([]);
  EQ(), VV.useEffect(() => {
    if (F) H([]), B(X)
  }, [F, X, B]);
  let C = VV.useCallback(() => {
      if (J < A.length - 1) {
        if (D.length > 0) H((T) => [...T, J]);
        W((T) => T + 1)
      } else K(!0)
    }, [J, A.length, D]),
    E = VV.useCallback(() => {
      if (D.length > 0) {
        let T = D[D.length - 1];
        if (T !== void 0) H((y) => y.slice(0, -1)), W(T)
      } else if (J > 0) W((T) => T - 1);
      else if (G) G()
    }, [J, D, G]),
    U = VV.useCallback((T) => {
      if (T >= 0 && T < A.length) H((y) => [...y, J]), W(T)
    }, [J, A.length]),
    q = VV.useCallback(() => {
      if (H([]), G) G()
    }, [G]),
    w = VV.useCallback((T) => {
      V((y) => ({
        ...y,
        ...T
      }))
    }, []),
    N = VV.useMemo(() => ({
      currentStepIndex: J,
      totalSteps: A.length,
      wizardData: X,
      setWizardData: V,
      updateWizardData: w,
      goNext: C,
      goBack: E,
      goToStep: U,
      cancel: q,
      title: I,
      showStepCounter: Y
    }), [J, A.length, X, w, C, E, U, q, I, Y]),
    R = A[J];
  if (!R || F) return null;
  return VV.default.createElement(uF0.Provider, {
    value: N
  }, Z || VV.default.createElement(R, null))
}
// @from(Start 14240879, End 14240881)
VV
// @from(Start 14240883, End 14240886)
uF0
// @from(Start 14240892, End 14240967)
dF0 = L(() => {
  Q4();
  VV = BA(VA(), 1), uF0 = VV.createContext(null)
})
// @from(Start 14240970, End 14241102)
function TI() {
  let A = IH9.useContext(uF0);
  if (!A) throw Error("useWizard must be used within a WizardProvider");
  return A
}
// @from(Start 14241107, End 14241110)
IH9
// @from(Start 14241116, End 14241163)
cF0 = L(() => {
  dF0();
  IH9 = BA(VA(), 1)
})
// @from(Start 14241166, End 14241697)
function pF0({
  instructions: A = Oa.default.createElement(Oa.default.Fragment, null, Oa.default.createElement(E4, {
    shortcut: "↑↓",
    action: "navigate"
  }), " · ", Oa.default.createElement(E4, {
    shortcut: "Enter",
    action: "select"
  }), " · ", Oa.default.createElement(E4, {
    shortcut: "Esc",
    action: "go back"
  }))
}) {
  let Q = EQ();
  return Oa.default.createElement(S, {
    marginLeft: 3
  }, Oa.default.createElement($, {
    dimColor: !0
  }, Q.pending ? `Press ${Q.keyName} again to exit` : A))
}
// @from(Start 14241702, End 14241704)
Oa
// @from(Start 14241710, End 14241771)
lF0 = L(() => {
  hA();
  Q4();
  dF();
  Oa = BA(VA(), 1)
})
// @from(Start 14241774, End 14242580)
function oJ({
  title: A,
  titleColor: Q = "text",
  borderColor: B = "suggestion",
  children: G,
  subtitle: Z,
  footerText: I
}) {
  let {
    currentStepIndex: Y,
    totalSteps: J,
    title: W,
    showStepCounter: X
  } = TI();
  return og.default.createElement(og.default.Fragment, null, og.default.createElement(S, {
    borderStyle: "round",
    borderColor: B,
    flexDirection: "column"
  }, og.default.createElement(S, {
    flexDirection: "column",
    paddingX: 1
  }, og.default.createElement($, {
    bold: !0,
    color: Q
  }, A || W || "Wizard", X !== !1 && ` (${Y+1}/${J})`), Z && og.default.createElement($, {
    dimColor: !0
  }, Z)), og.default.createElement(S, {
    paddingX: 1,
    flexDirection: "column"
  }, G)), og.default.createElement(pF0, {
    instructions: I
  }))
}
// @from(Start 14242585, End 14242587)
og
// @from(Start 14242593, End 14242655)
uO = L(() => {
  hA();
  cF0();
  lF0();
  og = BA(VA(), 1)
})
// @from(Start 14242661, End 14242712)
WN = L(() => {
  dF0();
  cF0();
  uO();
  lF0()
})
// @from(Start 14242715, End 14243356)
function YH9() {
  let {
    goNext: A,
    updateWizardData: Q,
    cancel: B
  } = TI();
  return DJ1.default.createElement(oJ, {
    subtitle: "Choose location",
    footerText: "Press ↑↓ to navigate · Enter to select · Esc to cancel"
  }, DJ1.default.createElement(S, {
    marginTop: 1
  }, DJ1.default.createElement(M0, {
    key: "location-select",
    options: [{
      label: "Project (.claude/agents/)",
      value: "projectSettings"
    }, {
      label: "Personal (~/.claude/agents/)",
      value: "userSettings"
    }],
    onChange: (Z) => {
      Q({
        location: Z
      }), A()
    },
    onCancel: () => B()
  })))
}
// @from(Start 14243361, End 14243364)
DJ1
// @from(Start 14243370, End 14243440)
JH9 = L(() => {
  hA();
  S5();
  uO();
  WN();
  DJ1 = BA(VA(), 1)
})
// @from(Start 14243443, End 14244188)
function WH9() {
  let {
    goNext: A,
    goBack: Q,
    updateWizardData: B,
    goToStep: G
  } = TI();
  return HJ1.default.createElement(oJ, {
    subtitle: "Creation method",
    footerText: "Press ↑↓ to navigate · Enter to select · Esc to go back"
  }, HJ1.default.createElement(S, {
    marginTop: 1
  }, HJ1.default.createElement(M0, {
    key: "method-select",
    options: [{
      label: "Generate with Claude (recommended)",
      value: "generate"
    }, {
      label: "Manual configuration",
      value: "manual"
    }],
    onChange: (I) => {
      let Y = I;
      if (B({
          method: Y,
          wasGenerated: Y === "generate"
        }), Y === "generate") A();
      else G(3)
    },
    onCancel: () => Q()
  })))
}
// @from(Start 14244193, End 14244196)
HJ1
// @from(Start 14244202, End 14244272)
XH9 = L(() => {
  hA();
  S5();
  uO();
  WN();
  HJ1 = BA(VA(), 1)
})
// @from(Start 14244274, End 14245641)
async function VH9(A, Q, B, G) {
  let Z = B.length > 0 ? `

IMPORTANT: The following identifiers already exist and must NOT be used: ${B.join(", ")}` : "",
    I = `Create an agent configuration based on this request: "${A}".${Z}
  Return ONLY the JSON object, no other text.`,
    Y = R0({
      content: I
    }),
    J = await DK(),
    W = gQA([Y], J),
    F = (await wy({
      messages: WZ(W),
      systemPrompt: [Sx3],
      maxThinkingTokens: 0,
      tools: [],
      signal: G,
      options: {
        getToolPermissionContext: async () => ZE(),
        model: Q,
        toolChoice: void 0,
        agents: [],
        isNonInteractiveSession: !1,
        hasAppendSystemPrompt: !1,
        querySource: "agent_creation",
        mcpTools: [],
        agentIdOrSessionId: e1()
      }
    })).message.content.filter((D) => D.type === "text").map((D) => D.text).join(`
`),
    K;
  try {
    K = JSON.parse(F.trim())
  } catch {
    let D = F.match(/\{[\s\S]*\}/);
    if (!D) throw Error("No JSON object found in response");
    K = JSON.parse(D[0])
  }
  if (!K.identifier || !K.whenToUse || !K.systemPrompt) throw Error("Invalid agent configuration generated");
  return GA("tengu_agent_definition_generated", {
    agent_identifier: K.identifier
  }), {
    identifier: K.identifier,
    whenToUse: K.whenToUse,
    systemPrompt: K.systemPrompt
  }
}
// @from(Start 14245646, End 14245649)
Sx3
// @from(Start 14245655, End 14250740)
FH9 = L(() => {
  fZ();
  cQ();
  Ty();
  q0();
  th();
  _0();
  Sx3 = `You are an elite AI agent architect specializing in crafting high-performance agent configurations. Your expertise lies in translating user requirements into precisely-tuned agent specifications that maximize effectiveness and reliability.

**Important Context**: You may have access to project-specific instructions from CLAUDE.md files and other context that may include coding standards, project structure, and custom requirements. Consider this context when creating agents to ensure they align with the project's established patterns and practices.

When a user describes what they want an agent to do, you will:

1. **Extract Core Intent**: Identify the fundamental purpose, key responsibilities, and success criteria for the agent. Look for both explicit requirements and implicit needs. Consider any project-specific context from CLAUDE.md files. For agents that are meant to review code, you should assume that the user is asking to review recently written code and not the whole codebase, unless the user has explicitly instructed you otherwise.

2. **Design Expert Persona**: Create a compelling expert identity that embodies deep domain knowledge relevant to the task. The persona should inspire confidence and guide the agent's decision-making approach.

3. **Architect Comprehensive Instructions**: Develop a system prompt that:
   - Establishes clear behavioral boundaries and operational parameters
   - Provides specific methodologies and best practices for task execution
   - Anticipates edge cases and provides guidance for handling them
   - Incorporates any specific requirements or preferences mentioned by the user
   - Defines output format expectations when relevant
   - Aligns with project-specific coding standards and patterns from CLAUDE.md

4. **Optimize for Performance**: Include:
   - Decision-making frameworks appropriate to the domain
   - Quality control mechanisms and self-verification steps
   - Efficient workflow patterns
   - Clear escalation or fallback strategies

5. **Create Identifier**: Design a concise, descriptive identifier that:
   - Uses lowercase letters, numbers, and hyphens only
   - Is typically 2-4 words joined by hyphens
   - Clearly indicates the agent's primary function
   - Is memorable and easy to type
   - Avoids generic terms like "helper" or "assistant"

6 **Example agent descriptions**:
  - in the 'whenToUse' field of the JSON object, you should include examples of when this agent should be used.
  - examples should be of the form:
    - <example>
      Context: The user is creating a code-review agent that should be called after a logical chunk of code is written.
      user: "Please write a function that checks if a number is prime"
      assistant: "Here is the relevant function: "
      <function call omitted for brevity only for this example>
      <commentary>
      Since the user is greeting, use the ${A6} tool to launch the greeting-responder agent to respond with a friendly joke. 
      </commentary>
      assistant: "Now let me use the code-reviewer agent to review the code"
    </example>
    - <example>
      Context: User is creating an agent to respond to the word "hello" with a friendly jok.
      user: "Hello"
      assistant: "I'm going to use the ${A6} tool to launch the greeting-responder agent to respond with a friendly joke"
      <commentary>
      Since the user is greeting, use the greeting-responder agent to respond with a friendly joke. 
      </commentary>
    </example>
  - If the user mentioned or implied that the agent should be used proactively, you should include examples of this.
- NOTE: Ensure that in the examples, you are making the assistant use the Agent tool and not simply respond directly to the task.

Your output must be a valid JSON object with exactly these fields:
{
  "identifier": "A unique, descriptive identifier using lowercase letters, numbers, and hyphens (e.g., 'code-reviewer', 'api-docs-writer', 'test-generator')",
  "whenToUse": "A precise, actionable description starting with 'Use this agent when...' that clearly defines the triggering conditions and use cases. Ensure you include examples as described above.",
  "systemPrompt": "The complete system prompt that will govern the agent's behavior, written in second person ('You are...', 'You will...') and structured for maximum clarity and effectiveness"
}

Key principles for your system prompts:
- Be specific rather than generic - avoid vague instructions
- Include concrete examples when they would clarify behavior
- Balance comprehensiveness with clarity - every instruction should add value
- Ensure the agent has enough context to handle variations of the core task
- Make the agent proactive in seeking clarification when needed
- Build in quality assurance and self-correction mechanisms

Remember: The agents you create should be autonomous experts capable of handling their designated tasks with minimal additional guidance. Your system prompts are their complete operational manual.
`
})
// @from(Start 14250743, End 14253158)
function KH9() {
  let {
    updateWizardData: A,
    goBack: Q,
    goToStep: B,
    wizardData: G
  } = TI(), [Z, I] = BH.useState(G.generationPrompt || ""), [Y, J] = BH.useState(!1), [W, X] = BH.useState(null), [V, F] = BH.useState(Z.length), K = Ja(), D = BH.useRef(null);
  f1((E, U) => {
    if (U.escape) {
      if (Y && D.current) D.current.abort(), D.current = null, J(!1), X("Generation cancelled");
      else if (!Y) A({
        generationPrompt: "",
        agentType: "",
        systemPrompt: "",
        whenToUse: "",
        generatedAgent: void 0,
        wasGenerated: !1
      }), I(""), X(null), Q()
    }
  });
  let H = async () => {
    let E = Z.trim();
    if (!E) {
      X("Please describe what the agent should do");
      return
    }
    X(null), J(!0), A({
      generationPrompt: E,
      isGenerating: !0
    });
    let U = o9();
    D.current = U;
    try {
      let q = await VH9(E, K, [], U.signal);
      A({
        agentType: q.identifier,
        whenToUse: q.whenToUse,
        systemPrompt: q.systemPrompt,
        generatedAgent: q,
        isGenerating: !1,
        wasGenerated: !0
      }), B(6)
    } catch (q) {
      if (q instanceof Error && !q.message.includes("No assistant message found")) X(q.message || "Failed to generate agent");
      A({
        isGenerating: !1
      })
    } finally {
      J(!1), D.current = null
    }
  }, C = "Describe what this agent should do and when it should be used (be comprehensive for best results)";
  if (Y) return BH.default.createElement(oJ, {
    subtitle: C,
    footerText: "Esc to cancel"
  }, BH.default.createElement(S, {
    marginTop: 1,
    flexDirection: "row",
    alignItems: "center"
  }, BH.default.createElement(g4, null), BH.default.createElement($, {
    color: "suggestion"
  }, " Generating agent from description...")));
  return BH.default.createElement(oJ, {
    subtitle: C,
    footerText: "Press Enter to submit · Esc to go back"
  }, BH.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, W && BH.default.createElement(S, {
    marginBottom: 1
  }, BH.default.createElement($, {
    color: "error"
  }, W)), BH.default.createElement(s4, {
    value: Z,
    onChange: I,
    onSubmit: H,
    placeholder: "e.g., Help me write unit tests for my code...",
    columns: 80,
    cursorOffset: V,
    onChangeCursorOffset: F,
    focus: !0,
    showCursor: !0
  })))
}
// @from(Start 14253163, End 14253165)
BH
// @from(Start 14253171, End 14253282)
DH9 = L(() => {
  hA();
  hA();
  ZY();
  uO();
  WN();
  DY();
  FH9();
  ePA();
  OZ();
  BH = BA(VA(), 1)
})
// @from(Start 14253285, End 14253683)
function iF0(A) {
  if (!A) return "Agent type is required";
  if (!/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$/.test(A)) return "Agent type must start and end with alphanumeric characters and contain only letters, numbers, and hyphens";
  if (A.length < 3) return "Agent type must be at least 3 characters long";
  if (A.length > 50) return "Agent type must be less than 50 characters";
  return null
}
// @from(Start 14253685, End 14255020)
function HH9(A, Q, B) {
  let G = [],
    Z = [];
  if (!A.agentType) G.push("Agent type is required");
  else {
    let Y = iF0(A.agentType);
    if (Y) G.push(Y);
    let J = B.find((W) => W.agentType === A.agentType && W.source !== A.source);
    if (J) G.push(`Agent type "${A.agentType}" already exists in ${LVA(J.source)}`)
  }
  if (!A.whenToUse) G.push("Description (description) is required");
  else if (A.whenToUse.length < 10) Z.push("Description should be more descriptive (at least 10 characters)");
  else if (A.whenToUse.length > 5000) Z.push("Description is very long (over 5000 characters)");
  if (A.tools !== void 0 && !Array.isArray(A.tools)) G.push("Tools must be an array");
  else {
    if (A.tools === void 0) Z.push("Agent has access to all tools");
    else if (A.tools.length === 0) Z.push("No tools selected - agent will have very limited capabilities");
    let Y = Sn(A, Q, !1);
    if (Y.invalidTools.length > 0) G.push(`Invalid tools: ${Y.invalidTools.join(", ")}`)
  }
  let I = A.getSystemPrompt();
  if (!I) G.push("System prompt is required");
  else if (I.length < 20) G.push("System prompt is too short (minimum 20 characters)");
  else if (I.length > 1e4) Z.push("System prompt is very long (over 10,000 characters)");
  return {
    isValid: G.length === 0,
    errors: G,
    warnings: Z
  }
}
// @from(Start 14255025, End 14255060)
nF0 = L(() => {
  S0A();
  KJ1()
})
// @from(Start 14255063, End 14256215)
function CH9(A) {
  let {
    goNext: Q,
    goBack: B,
    updateWizardData: G,
    wizardData: Z
  } = TI(), [I, Y] = mO.useState(Z.agentType || ""), [J, W] = mO.useState(null), [X, V] = mO.useState(I.length);
  return f1((K, D) => {
    if (D.escape) B()
  }), mO.default.createElement(oJ, {
    subtitle: "Agent type (identifier)",
    footerText: "Type to enter text · Enter to continue · Esc to go back"
  }, mO.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, mO.default.createElement($, null, "Enter a unique identifier for your agent:"), mO.default.createElement(S, {
    marginTop: 1
  }, mO.default.createElement(s4, {
    value: I,
    onChange: Y,
    onSubmit: (K) => {
      let D = K.trim(),
        H = iF0(D);
      if (H) {
        W(H);
        return
      }
      W(null), G({
        agentType: D
      }), Q()
    },
    placeholder: "e.g., code-reviewer, tech-lead, etc",
    columns: 60,
    cursorOffset: X,
    onChangeCursorOffset: V,
    focus: !0,
    showCursor: !0
  })), J && mO.default.createElement(S, {
    marginTop: 1
  }, mO.default.createElement($, {
    color: "error"
  }, J))))
}
// @from(Start 14256220, End 14256222)
mO
// @from(Start 14256228, End 14256314)
EH9 = L(() => {
  hA();
  hA();
  ZY();
  uO();
  WN();
  nF0();
  mO = BA(VA(), 1)
})
// @from(Start 14256317, End 14257561)
function zH9() {
  let {
    goNext: A,
    goBack: Q,
    updateWizardData: B,
    wizardData: G
  } = TI(), [Z, I] = XN.useState(G.systemPrompt || ""), [Y, J] = XN.useState(Z.length), [W, X] = XN.useState(null);
  return f1((F, K) => {
    if (K.escape) Q()
  }), XN.default.createElement(oJ, {
    subtitle: "System prompt",
    footerText: "Type to enter text · Enter to continue · Esc to go back"
  }, XN.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, XN.default.createElement($, null, "Enter the system prompt for your agent:"), XN.default.createElement($, {
    dimColor: !0
  }, "Be comprehensive for best results"), XN.default.createElement(S, {
    marginTop: 1
  }, XN.default.createElement(s4, {
    value: Z,
    onChange: I,
    onSubmit: () => {
      let F = Z.trim();
      if (!F) {
        X("System prompt is required");
        return
      }
      X(null), B({
        systemPrompt: F
      }), A()
    },
    placeholder: "You are a helpful code reviewer who...",
    columns: 80,
    cursorOffset: Y,
    onChangeCursorOffset: J,
    focus: !0,
    showCursor: !0
  })), W && XN.default.createElement(S, {
    marginTop: 1
  }, XN.default.createElement($, {
    color: "error"
  }, W))))
}
// @from(Start 14257566, End 14257568)
XN
// @from(Start 14257574, End 14257651)
UH9 = L(() => {
  hA();
  hA();
  ZY();
  uO();
  WN();
  XN = BA(VA(), 1)
})
// @from(Start 14257654, End 14258847)
function $H9() {
  let {
    goNext: A,
    goBack: Q,
    updateWizardData: B,
    wizardData: G
  } = TI(), [Z, I] = dO.useState(G.whenToUse || ""), [Y, J] = dO.useState(Z.length), [W, X] = dO.useState(null);
  return f1((F, K) => {
    if (K.escape) Q()
  }), dO.default.createElement(oJ, {
    subtitle: "Description (tell Claude when to use this agent)",
    footerText: "Type to enter text · Enter to continue · Esc to go back"
  }, dO.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, dO.default.createElement($, null, "When should Claude use this agent?"), dO.default.createElement(S, {
    marginTop: 1
  }, dO.default.createElement(s4, {
    value: Z,
    onChange: I,
    onSubmit: (F) => {
      let K = F.trim();
      if (!K) {
        X("Description is required");
        return
      }
      X(null), B({
        whenToUse: K
      }), A()
    },
    placeholder: "e.g., use this agent after you're done writing code...",
    columns: 80,
    cursorOffset: Y,
    onChangeCursorOffset: J,
    focus: !0,
    showCursor: !0
  })), W && dO.default.createElement(S, {
    marginTop: 1
  }, dO.default.createElement($, {
    color: "error"
  }, W))))
}
// @from(Start 14258852, End 14258854)
dO
// @from(Start 14258860, End 14258937)
wH9 = L(() => {
  hA();
  hA();
  ZY();
  uO();
  WN();
  dO = BA(VA(), 1)
})
// @from(Start 14258940, End 14259319)
function _x3(A) {
  let Q = new Map;
  return A.forEach((B) => {
    if (lg(B)) {
      let G = mU(B.name);
      if (G?.serverName) {
        let Z = Q.get(G.serverName) || [];
        Z.push(B), Q.set(G.serverName, Z)
      }
    }
  }), Array.from(Q.entries()).map(([B, G]) => ({
    serverName: B,
    tools: G
  })).sort((B, G) => B.serverName.localeCompare(G.serverName))
}
// @from(Start 14259321, End 14264681)
function CJ1({
  tools: A,
  initialTools: Q,
  onComplete: B,
  onCancel: G
}) {
  let Z = FV.useMemo(() => w70({
      tools: A,
      isBuiltIn: !1,
      isAsync: !1
    }), [A]),
    I = !Q || Q.includes("*") ? Z.map((x) => x.name) : Q,
    [Y, J] = FV.useState(I),
    [W, X] = FV.useState(0),
    [V, F] = FV.useState(!1),
    K = FV.useMemo(() => {
      let x = new Set(Z.map((p) => p.name));
      return Y.filter((p) => x.has(p))
    }, [Y, Z]),
    D = new Set(K),
    H = K.length === Z.length && Z.length > 0,
    C = (x) => {
      if (!x) return;
      J((p) => p.includes(x) ? p.filter((u) => u !== x) : [...p, x])
    },
    E = (x, p) => {
      J((u) => {
        if (p) {
          let e = x.filter((l) => !u.includes(l));
          return [...u, ...e]
        } else return u.filter((e) => !x.includes(e))
      })
    },
    U = () => {
      let x = Z.map((e) => e.name),
        u = K.length === x.length && x.every((e) => K.includes(e)) ? void 0 : K;
      B(u)
    },
    q = FV.useMemo(() => {
      let x = qH9(),
        p = {
          readOnly: [],
          edit: [],
          execution: [],
          mcp: [],
          other: []
        };
      return Z.forEach((u) => {
        if (lg(u)) p.mcp.push(u);
        else if (x.READ_ONLY.toolNames.has(u.name)) p.readOnly.push(u);
        else if (x.EDIT.toolNames.has(u.name)) p.edit.push(u);
        else if (x.EXECUTION.toolNames.has(u.name)) p.execution.push(u);
        else if (u.name !== A6) p.other.push(u)
      }), p
    }, [Z]),
    w = (x) => {
      let u = x.filter((e) => D.has(e.name)).length < x.length;
      return () => {
        let e = x.map((l) => l.name);
        E(e, u)
      }
    },
    N = [];
  N.push({
    id: "continue",
    label: "Continue",
    action: U,
    isContinue: !0
  }), N.push({
    id: "bucket-all",
    label: `${H?H1.checkboxOn:H1.checkboxOff} All tools`,
    action: () => {
      let x = Z.map((p) => p.name);
      E(x, !H)
    }
  });
  let R = qH9();
  [{
    id: "bucket-readonly",
    name: R.READ_ONLY.name,
    tools: q.readOnly
  }, {
    id: "bucket-edit",
    name: R.EDIT.name,
    tools: q.edit
  }, {
    id: "bucket-execution",
    name: R.EXECUTION.name,
    tools: q.execution
  }, {
    id: "bucket-mcp",
    name: R.MCP.name,
    tools: q.mcp
  }, {
    id: "bucket-other",
    name: R.OTHER.name,
    tools: q.other
  }].forEach(({
    id: x,
    name: p,
    tools: u
  }) => {
    if (u.length === 0) return;
    let l = u.filter((k) => D.has(k.name)).length === u.length;
    N.push({
      id: x,
      label: `${l?H1.checkboxOn:H1.checkboxOff} ${p}`,
      action: w(u)
    })
  });
  let y = N.length;
  N.push({
    id: "toggle-individual",
    label: V ? "Hide advanced options" : "Show advanced options",
    action: () => {
      if (F(!V), V && W > y) X(y)
    },
    isToggle: !0
  });
  let v = FV.useMemo(() => _x3(Z), [Z]);
  if (V) {
    if (v.length > 0) N.push({
      id: "mcp-servers-header",
      label: "MCP Servers:",
      action: () => {},
      isHeader: !0
    }), v.forEach(({
      serverName: x,
      tools: p
    }) => {
      let e = p.filter((l) => D.has(l.name)).length === p.length;
      N.push({
        id: `mcp-server-${x}`,
        label: `${e?H1.checkboxOn:H1.checkboxOff} ${x} (${p.length} tool${p.length===1?"":"s"})`,
        action: () => {
          let l = p.map((k) => k.name);
          E(l, !e)
        }
      })
    }), N.push({
      id: "tools-header",
      label: "Individual Tools:",
      action: () => {},
      isHeader: !0
    });
    Z.forEach((x) => {
      let p = x.name;
      if (x.name.startsWith("mcp__")) {
        let u = mU(x.name);
        p = u ? `${u.toolName} (${u.serverName})` : x.name
      }
      N.push({
        id: `tool-${x.name}`,
        label: `${D.has(x.name)?H1.checkboxOn:H1.checkboxOff} ${p}`,
        action: () => C(x.name)
      })
    })
  }
  return f1((x, p) => {
    if (p.return) {
      let u = N[W];
      if (u && !u.isHeader) u.action()
    } else if (p.escape)
      if (G) G();
      else B(Q);
    else if (p.upArrow) {
      let u = W - 1;
      while (u > 0 && N[u]?.isHeader) u--;
      X(Math.max(0, u))
    } else if (p.downArrow) {
      let u = W + 1;
      while (u < N.length - 1 && N[u]?.isHeader) u++;
      X(Math.min(N.length - 1, u))
    }
  }), FV.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, FV.default.createElement($, {
    color: W === 0 ? "suggestion" : void 0,
    bold: W === 0
  }, W === 0 ? `${H1.pointer} ` : "  ", "[ Continue ]"), FV.default.createElement($, {
    dimColor: !0
  }, "─".repeat(40)), N.slice(1).map((x, p) => {
    let u = p + 1 === W,
      e = x.isToggle,
      l = x.isHeader;
    return FV.default.createElement(FV.default.Fragment, {
      key: x.id
    }, e && FV.default.createElement($, {
      dimColor: !0
    }, "─".repeat(40)), l && p > 0 && FV.default.createElement(S, {
      marginTop: 1
    }), FV.default.createElement($, {
      color: l ? void 0 : u ? "suggestion" : void 0,
      dimColor: l,
      bold: e && u
    }, l ? "" : u ? `${H1.pointer} ` : "  ", e ? `[ ${x.label} ]` : x.label))
  }), FV.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, FV.default.createElement($, {
    dimColor: !0
  }, H ? "All tools selected" : `${D.size} of ${Z.length} tools selected`)))
}
// @from(Start 14264686, End 14264688)
FV
// @from(Start 14264690, End 14265219)
qH9 = () => ({
  READ_ONLY: {
    name: "Read-only tools",
    toolNames: new Set([zO.name, Py.name, gq.name, n8.name, nV.name, BY.name, ZSA.name, HY1.name, CY1.name, Wh.name, Xh.name])
  },
  EDIT: {
    name: "Edit tools",
    toolNames: new Set([lD.name, QV.name, kP.name])
  },
  EXECUTION: {
    name: "Execution tools",
    toolNames: new Set([D9.name, void 0].filter(Boolean))
  },
  MCP: {
    name: "MCP tools",
    toolNames: new Set,
    isMcp: !0
  },
  OTHER: {
    name: "Other tools",
    toolNames: new Set
  }
})
// @from(Start 14265225, End 14265433)
aF0 = L(() => {
  hA();
  hA();
  V9();
  nX();
  KTA();
  VTA();
  dTA();
  Dq();
  oWA();
  kt();
  JV0();
  ZV0();
  YV0();
  fQ1();
  hQ1();
  zn();
  rh();
  DWA();
  pF();
  S0A();
  FV = BA(VA(), 1)
})
// @from(Start 14265436, End 14265912)
function NH9({
  tools: A
}) {
  let {
    goNext: Q,
    goBack: B,
    updateWizardData: G,
    wizardData: Z
  } = TI(), I = (J) => {
    G({
      selectedTools: J
    }), Q()
  }, Y = Z.selectedTools;
  return sF0.default.createElement(oJ, {
    subtitle: "Select tools",
    footerText: "Press Enter to toggle selection · ↑↓ to navigate · Esc to go back"
  }, sF0.default.createElement(CJ1, {
    tools: A,
    initialTools: Y,
    onComplete: I,
    onCancel: B
  }))
}
// @from(Start 14265917, End 14265920)
sF0
// @from(Start 14265926, End 14265989)
LH9 = L(() => {
  aF0();
  uO();
  WN();
  sF0 = BA(VA(), 1)
})
// @from(Start 14265992, End 14266587)
function EJ1({
  initialModel: A,
  onComplete: Q,
  onCancel: B
}) {
  let G = cO.useMemo(() => qCB(), []),
    Z = cO.useMemo(() => {
      if (A && G.some((I) => I.value === A)) return A;
      return "sonnet"
    }, [A, G]);
  return cO.createElement(S, {
    flexDirection: "column"
  }, cO.createElement(S, {
    marginBottom: 1
  }, cO.createElement($, {
    dimColor: !0
  }, "Model determines the agent's reasoning capabilities and speed.")), cO.createElement(M0, {
    options: G,
    defaultValue: Z,
    onChange: (I) => {
      Q(I)
    },
    onCancel: () => B ? B() : Q(A)
  }))
}
// @from(Start 14266592, End 14266594)
cO
// @from(Start 14266600, End 14266661)
rF0 = L(() => {
  hA();
  S5();
  t2();
  cO = BA(VA(), 1)
})
// @from(Start 14266664, End 14267095)
function MH9() {
  let {
    goNext: A,
    goBack: Q,
    updateWizardData: B,
    wizardData: G
  } = TI(), Z = (I) => {
    B({
      selectedModel: I
    }), A()
  };
  return oF0.default.createElement(oJ, {
    subtitle: "Select model",
    footerText: "Press ↑↓ to navigate · Enter to select · Esc to go back"
  }, oF0.default.createElement(EJ1, {
    initialModel: G.selectedModel,
    onComplete: Z,
    onCancel: Q
  }))
}
// @from(Start 14267100, End 14267103)
oF0
// @from(Start 14267109, End 14267172)
OH9 = L(() => {
  rF0();
  uO();
  WN();
  oF0 = BA(VA(), 1)
})
// @from(Start 14267175, End 14268662)
function zJ1({
  agentName: A,
  currentColor: Q = "automatic",
  onConfirm: B
}) {
  let [G, Z] = Jz.useState(Math.max(0, MVA.findIndex((Y) => Y === Q)));
  f1((Y, J) => {
    if (J.upArrow) Z((W) => W > 0 ? W - 1 : MVA.length - 1);
    else if (J.downArrow) Z((W) => W < MVA.length - 1 ? W + 1 : 0);
    else if (J.return) {
      let W = MVA[G];
      B(W === "automatic" ? void 0 : W)
    }
  });
  let I = MVA[G];
  return Jz.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, Jz.default.createElement(S, {
    flexDirection: "column"
  }, MVA.map((Y, J) => {
    let W = J === G;
    return Jz.default.createElement(S, {
      key: Y,
      flexDirection: "row",
      gap: 1
    }, Jz.default.createElement($, {
      color: W ? "suggestion" : void 0
    }, W ? H1.pointer : " "), Y === "automatic" ? Jz.default.createElement($, {
      bold: W
    }, "Automatic color") : Jz.default.createElement(S, {
      gap: 1
    }, Jz.default.createElement($, {
      backgroundColor: HTA[Y],
      color: "inverseText"
    }, " "), Jz.default.createElement($, {
      bold: W
    }, Y.charAt(0).toUpperCase() + Y.slice(1))))
  })), Jz.default.createElement(S, {
    marginTop: 1
  }, Jz.default.createElement($, null, "Preview: "), I === void 0 || I === "automatic" ? Jz.default.createElement($, {
    inverse: !0,
    bold: !0
  }, " ", A, " ") : Jz.default.createElement($, {
    backgroundColor: HTA[I],
    color: "inverseText",
    bold: !0
  }, " ", A, " ")))
}
// @from(Start 14268667, End 14268669)
Jz
// @from(Start 14268671, End 14268674)
MVA
// @from(Start 14268680, End 14268770)
tF0 = L(() => {
  hA();
  jy();
  V9();
  Jz = BA(VA(), 1), MVA = ["automatic", ...j0A]
})
// @from(Start 14268773, End 14269668)
function RH9() {
  let {
    goNext: A,
    goBack: Q,
    updateWizardData: B,
    wizardData: G
  } = TI();
  f1((I, Y) => {
    if (Y.escape) Q()
  });
  let Z = (I) => {
    B({
      selectedColor: I,
      finalAgent: {
        agentType: G.agentType,
        whenToUse: G.whenToUse,
        getSystemPrompt: () => G.systemPrompt,
        tools: G.selectedTools,
        ...G.selectedModel ? {
          model: G.selectedModel
        } : {},
        ...I ? {
          color: I
        } : {},
        source: G.location
      }
    }), A()
  };
  return UJ1.default.createElement(oJ, {
    subtitle: "Choose background color",
    footerText: "Press ↑↓ to navigate · Enter to select · Esc to go back"
  }, UJ1.default.createElement(S, {
    marginTop: 1
  }, UJ1.default.createElement(zJ1, {
    agentName: G.agentType || "agent",
    currentColor: "automatic",
    onConfirm: Z
  })))
}
// @from(Start 14269673, End 14269676)
UJ1
// @from(Start 14269682, End 14269761)
TH9 = L(() => {
  hA();
  hA();
  tF0();
  uO();
  WN();
  UJ1 = BA(VA(), 1)
})
// @from(Start 14269764, End 14272850)
function PH9({
  tools: A,
  existingAgents: Q,
  onSave: B,
  onSaveAndEdit: G,
  error: Z
}) {
  let {
    goBack: I,
    wizardData: Y
  } = TI();
  f1((V, F) => {
    if (F.escape) I();
    else if (V === "s" || F.return) B();
    else if (V === "e") G()
  });
  let J = Y.finalAgent,
    W = HH9(J, A, Q),
    X = (V) => {
      if (V === void 0) return "All tools";
      if (V.length === 0) return "None";
      if (V.length === 1) return V[0] || "None";
      if (V.length === 2) return V.join(" and ");
      return `${V.slice(0,-1).join(", ")}, and ${V[V.length-1]}`
    };
  return w3.default.createElement(oJ, {
    subtitle: "Confirm and save",
    footerText: "Press s/Enter to save · e to edit in your editor · Esc to cancel"
  }, w3.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, w3.default.createElement($, null, w3.default.createElement($, {
    bold: !0
  }, "Name"), ": ", J.agentType), w3.default.createElement($, null, w3.default.createElement($, {
    bold: !0
  }, "Location"), ":", " ", eD9({
    source: Y.location,
    agentType: J.agentType
  })), w3.default.createElement($, null, w3.default.createElement($, {
    bold: !0
  }, "Tools"), ": ", X(J.tools)), w3.default.createElement($, null, w3.default.createElement($, {
    bold: !0
  }, "Model"), ": ", nnA(J.model)), w3.default.createElement(S, {
    marginTop: 1
  }, w3.default.createElement($, null, w3.default.createElement($, {
    bold: !0
  }, "Description"), " (tells Claude when to use this agent):")), w3.default.createElement(S, {
    marginLeft: 2,
    marginTop: 1
  }, w3.default.createElement($, null, J.whenToUse.length > 240 ? J.whenToUse.slice(0, 240) + "…" : J.whenToUse)), w3.default.createElement(S, {
    marginTop: 1
  }, w3.default.createElement($, null, w3.default.createElement($, {
    bold: !0
  }, "System prompt"), ":")), w3.default.createElement(S, {
    marginLeft: 2,
    marginTop: 1
  }, w3.default.createElement($, null, (() => {
    let V = J.getSystemPrompt();
    return V.length > 240 ? V.slice(0, 240) + "…" : V
  })())), W.warnings.length > 0 && w3.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, w3.default.createElement($, {
    color: "warning"
  }, "Warnings:"), W.warnings.map((V, F) => w3.default.createElement($, {
    key: F,
    dimColor: !0
  }, " ", "• ", V))), W.errors.length > 0 && w3.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, w3.default.createElement($, {
    color: "error"
  }, "Errors:"), W.errors.map((V, F) => w3.default.createElement($, {
    key: F,
    color: "error"
  }, " ", "• ", V))), Z && w3.default.createElement(S, {
    marginTop: 1
  }, w3.default.createElement($, {
    color: "error"
  }, Z)), w3.default.createElement(S, {
    marginTop: 2
  }, w3.default.createElement($, {
    color: "success"
  }, "Press ", w3.default.createElement($, {
    bold: !0
  }, "s"), " or ", w3.default.createElement($, {
    bold: !0
  }, "Enter"), " to save,", " ", w3.default.createElement($, {
    bold: !0
  }, "e"), " to save and edit"))))
}
// @from(Start 14272855, End 14272857)
w3
// @from(Start 14272863, End 14272958)
jH9 = L(() => {
  hA();
  hA();
  uO();
  WN();
  nF0();
  NVA();
  t2();
  w3 = BA(VA(), 1)
})
// @from(Start 14272961, End 14275558)
function SH9({
  tools: A,
  existingAgents: Q,
  onComplete: B
}) {
  let {
    wizardData: G
  } = TI(), [Z, I] = aQA.useState(null), [, Y] = OQ(), J = aQA.useCallback(async () => {
    if (!G?.finalAgent) return;
    try {
      await hF0(G.location, G.finalAgent.agentType, G.finalAgent.whenToUse, G.finalAgent.tools, G.finalAgent.getSystemPrompt(), !0, G.finalAgent.color, G.finalAgent.model), Y((X) => {
        if (!G.finalAgent) return X;
        let V = X.agentDefinitions.allAgents.concat(G.finalAgent);
        return {
          ...X,
          agentDefinitions: {
            ...X.agentDefinitions,
            activeAgents: ky(V),
            allAgents: V
          }
        }
      }), GA("tengu_agent_created", {
        agent_type: G.finalAgent.agentType,
        generation_method: G.wasGenerated ? "generated" : "manual",
        source: G.location,
        tool_count: G.finalAgent.tools?.length ?? "all",
        has_custom_model: !!G.finalAgent.model,
        has_custom_color: !!G.finalAgent.color
      }), B(`Created agent: ${tA.bold(G.finalAgent.agentType)}`)
    } catch (X) {
      I(X instanceof Error ? X.message : "Failed to save agent")
    }
  }, [G, B, Y]), W = aQA.useCallback(async () => {
    if (!G?.finalAgent) return;
    try {
      await hF0(G.location, G.finalAgent.agentType, G.finalAgent.whenToUse, G.finalAgent.tools, G.finalAgent.getSystemPrompt(), !0, G.finalAgent.color, G.finalAgent.model), Y((V) => {
        if (!G.finalAgent) return V;
        let F = V.agentDefinitions.allAgents.concat(G.finalAgent);
        return {
          ...V,
          agentDefinitions: {
            ...V.agentDefinitions,
            activeAgents: ky(F),
            allAgents: F
          }
        }
      });
      let X = fF0({
        source: G.location,
        agentType: G.finalAgent.agentType
      });
      await cn(X), GA("tengu_agent_created", {
        agent_type: G.finalAgent.agentType,
        generation_method: G.wasGenerated ? "generated" : "manual",
        source: G.location,
        tool_count: G.finalAgent.tools?.length ?? "all",
        has_custom_model: !!G.finalAgent.model,
        has_custom_color: !!G.finalAgent.color,
        opened_in_editor: !0
      }), B(`Created agent: ${tA.bold(G.finalAgent.agentType)} and opened in editor. If you made edits, restart to load the latest version.`)
    } catch (X) {
      I(X instanceof Error ? X.message : "Failed to save agent")
    }
  }, [G, B, Y]);
  return aQA.default.createElement(PH9, {
    tools: A,
    existingAgents: Q,
    onSave: J,
    onSaveAndEdit: W,
    error: Z
  })
}
// @from(Start 14275563, End 14275566)
aQA
// @from(Start 14275572, End 14275676)
_H9 = L(() => {
  F9();
  WN();
  jH9();
  NVA();
  fP();
  pn();
  q0();
  z9();
  aQA = BA(VA(), 1)
})
// @from(Start 14275679, End 14276219)
function kH9({
  tools: A,
  existingAgents: Q,
  onComplete: B,
  onCancel: G
}) {
  return NSA.default.createElement(mF0, {
    steps: [YH9, WH9, KH9, () => NSA.default.createElement(CH9, {
      existingAgents: Q
    }), zH9, $H9, () => NSA.default.createElement(NH9, {
      tools: A
    }), MH9, RH9, () => NSA.default.createElement(SH9, {
      tools: A,
      existingAgents: Q,
      onComplete: B
    })],
    initialData: {},
    onComplete: () => {},
    onCancel: G,
    title: "Create new agent",
    showStepCounter: !1
  })
}
// @from(Start 14276224, End 14276227)
NSA
// @from(Start 14276233, End 14276369)
yH9 = L(() => {
  WN();
  JH9();
  XH9();
  DH9();
  EH9();
  UH9();
  wH9();
  LH9();
  OH9();
  TH9();
  _H9();
  NSA = BA(VA(), 1)
})
// @from(Start 14276372, End 14279784)
function xH9({
  agent: A,
  tools: Q,
  onSaved: B,
  onBack: G
}) {
  let [, Z] = OQ(), [I, Y] = pO.useState("menu"), [J, W] = pO.useState(0), [X, V] = pO.useState(null), [F, K] = pO.useState(A.color), D = pO.useCallback(async () => {
    try {
      let w = FJ1(A);
      await cn(w), B(`Opened ${A.agentType} in editor. If you made edits, restart to load the latest version.`)
    } catch (w) {
      V(w instanceof Error ? w.message : "Failed to open editor")
    }
  }, [A, B]), H = pO.useCallback(async (w = {}) => {
    let {
      tools: N,
      color: R,
      model: T
    } = w, y = R ?? F, v = N !== void 0, x = T !== void 0, p = y !== A.color;
    if (!v && !x && !p) return !1;
    try {
      if (!Ff2(A) && !e51(A)) return !1;
      if (await QH9(A, A.whenToUse, N ?? A.tools, A.getSystemPrompt(), y, T ?? A.model), p && y) jWA(A.agentType, y);
      return Z((u) => {
        let e = u.agentDefinitions.allAgents.map((l) => l.agentType === A.agentType ? {
          ...l,
          tools: N ?? l.tools,
          color: y,
          model: T ?? l.model
        } : l);
        return {
          ...u,
          agentDefinitions: {
            ...u.agentDefinitions,
            activeAgents: ky(e),
            allAgents: e
          }
        }
      }), B(`Updated agent: ${tA.bold(A.agentType)}`), !0
    } catch (u) {
      return V(u instanceof Error ? u.message : "Failed to save agent"), !1
    }
  }, [A, F, B, Z]), C = pO.useMemo(() => [{
    label: "Open in editor",
    action: D
  }, {
    label: "Edit tools",
    action: () => Y("edit-tools")
  }, {
    label: "Edit model",
    action: () => Y("edit-model")
  }, {
    label: "Edit color",
    action: () => Y("edit-color")
  }], [D]), E = pO.useCallback(() => {
    if (V(null), I === "menu") G();
    else Y("menu")
  }, [I, G]), U = pO.useCallback((w) => {
    if (w.upArrow) W((N) => Math.max(0, N - 1));
    else if (w.downArrow) W((N) => Math.min(C.length - 1, N + 1));
    else if (w.return) {
      let N = C[J];
      if (N) N.action()
    }
  }, [C, J]);
  f1((w, N) => {
    if (N.escape) {
      E();
      return
    }
    if (I === "menu") U(N)
  });
  let q = () => eV.createElement(S, {
    flexDirection: "column"
  }, eV.createElement($, {
    dimColor: !0
  }, "Source: ", LVA(A.source)), eV.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, C.map((w, N) => eV.createElement($, {
    key: w.label,
    color: N === J ? "suggestion" : void 0
  }, N === J ? `${H1.pointer} ` : "  ", w.label))), X && eV.createElement(S, {
    marginTop: 1
  }, eV.createElement($, {
    color: "error"
  }, X)));
  switch (I) {
    case "menu":
      return q();
    case "edit-tools":
      return eV.createElement(CJ1, {
        tools: Q,
        initialTools: A.tools,
        onComplete: async (w) => {
          Y("menu"), await H({
            tools: w
          })
        }
      });
    case "edit-color":
      return eV.createElement(zJ1, {
        agentName: A.agentType,
        currentColor: F || A.color || "automatic",
        onConfirm: async (w) => {
          K(w), Y("menu"), await H({
            color: w
          })
        }
      });
    case "edit-model":
      return eV.createElement(EJ1, {
        initialModel: A.model,
        onComplete: async (w) => {
          Y("menu"), await H({
            model: w
          })
        }
      });
    default:
      return null
  }
}
// @from(Start 14279789, End 14279791)
eV
// @from(Start 14279793, End 14279795)
pO
// @from(Start 14279801, End 14279957)
vH9 = L(() => {
  hA();
  F9();
  fP();
  aF0();
  tF0();
  rF0();
  NVA();
  pn();
  jy();
  V9();
  KJ1();
  z9();
  eV = BA(VA(), 1), pO = BA(VA(), 1)
})
// @from(Start 14279960, End 14281702)
function bH9({
  agent: A,
  tools: Q,
  onBack: B
}) {
  let [G] = qB(), Z = Sn(A, Q, !1), I = AH9(A), Y = PWA(A.agentType);
  f1((W, X) => {
    if (X.escape || X.return) B()
  });

  function J() {
    if (Z.hasWildcard) return a2.createElement($, null, "All tools");
    if (!A.tools || A.tools.length === 0) return a2.createElement($, null, "None");
    return a2.createElement(a2.Fragment, null, Z.validTools.length > 0 && a2.createElement($, null, Z.validTools.join(", ")), Z.invalidTools.length > 0 && a2.createElement($, {
      color: "warning"
    }, H1.warning, " Unrecognized:", " ", Z.invalidTools.join(", ")))
  }
  return a2.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, a2.createElement($, {
    dimColor: !0
  }, I), a2.createElement(S, {
    flexDirection: "column"
  }, a2.createElement($, null, a2.createElement($, {
    bold: !0
  }, "Description"), " (tells Claude when to use this agent):"), a2.createElement(S, {
    marginLeft: 2
  }, a2.createElement($, null, A.whenToUse))), a2.createElement(S, null, a2.createElement($, null, a2.createElement($, {
    bold: !0
  }, "Tools"), ":", " "), J()), a2.createElement($, null, a2.createElement($, {
    bold: !0
  }, "Model"), ": ", nnA(A.model)), Y && a2.createElement(S, null, a2.createElement($, null, a2.createElement($, {
    bold: !0
  }, "Color"), ":", " ", a2.createElement($, {
    backgroundColor: Y,
    color: "inverseText"
  }, " ", A.agentType, " "))), !$O(A) && a2.createElement(a2.Fragment, null, a2.createElement(S, null, a2.createElement($, null, a2.createElement($, {
    bold: !0
  }, "System prompt"), ":")), a2.createElement(S, {
    marginLeft: 2,
    marginRight: 2
  }, a2.createElement($, null, fD(A.getSystemPrompt(), G)))))
}
// @from(Start 14281707, End 14281709)
a2
// @from(Start 14281715, End 14281818)
fH9 = L(() => {
  hA();
  V9();
  fP();
  S0A();
  wh();
  NVA();
  jy();
  t2();
  a2 = BA(VA(), 1)
})
// @from(Start 14281821, End 14282089)
function OVA({
  instructions: A = "Press ↑↓ to navigate · Enter to select · Esc to go back"
}) {
  let Q = EQ();
  return LSA.createElement(S, {
    marginLeft: 3
  }, LSA.createElement($, {
    dimColor: !0
  }, Q.pending ? `Press ${Q.keyName} again to exit` : A))
}
// @from(Start 14282094, End 14282097)
LSA
// @from(Start 14282103, End 14282157)
hH9 = L(() => {
  hA();
  Q4();
  LSA = BA(VA(), 1)
})
// @from(Start 14282160, End 14289244)
function gH9({
  tools: A,
  onExit: Q
}) {
  let [B, G] = Ra.useState({
    mode: "list-agents",
    source: "all"
  }), [Z, I] = OQ(), {
    allAgents: Y,
    activeAgents: J
  } = Z.agentDefinitions, [W, X] = Ra.useState([]), V = CI1(A, Z.mcp.tools);
  EQ();
  let F = Ra.useMemo(() => ({
    "built-in": Y.filter((H) => H.source === "built-in"),
    userSettings: Y.filter((H) => H.source === "userSettings"),
    projectSettings: Y.filter((H) => H.source === "projectSettings"),
    policySettings: Y.filter((H) => H.source === "policySettings"),
    localSettings: Y.filter((H) => H.source === "localSettings"),
    flagSettings: Y.filter((H) => H.source === "flagSettings"),
    plugin: Y.filter((H) => H.source === "plugin"),
    all: Y
  }), [Y]);
  f1((H, C) => {
    if (!C.escape) return;
    let E = W.length > 0 ? `Agent changes:
${W.join(`
`)}` : void 0;
    switch (B.mode) {
      case "list-agents":
        Q(E ?? "Agents dialog dismissed", {
          display: W.length === 0 ? "system" : void 0
        });
        break;
      case "create-agent":
        return;
      case "view-agent":
        return;
      default:
        if ("previousMode" in B) G(B.previousMode)
    }
  });
  let K = Ra.useCallback((H) => {
      X((C) => [...C, H]), G({
        mode: "list-agents",
        source: "all"
      })
    }, []),
    D = Ra.useCallback(async (H) => {
      try {
        await BH9(H), I((C) => {
          let E = C.agentDefinitions.allAgents.filter((U) => !(U.agentType === H.agentType && U.source === H.source));
          return {
            ...C,
            agentDefinitions: {
              ...C.agentDefinitions,
              allAgents: E,
              activeAgents: ky(E)
            }
          }
        }), X((C) => [...C, `Deleted agent: ${tA.bold(H.agentType)}`]), G({
          mode: "list-agents",
          source: "all"
        })
      } catch (C) {
        AA(C instanceof Error ? C : Error("Failed to delete agent"))
      }
    }, []);
  switch (B.mode) {
    case "list-agents": {
      let H = B.source === "all" ? [...F["built-in"], ...F.userSettings, ...F.projectSettings, ...F.policySettings, ...F.flagSettings, ...F.plugin] : F[B.source],
        C = new Map;
      J.forEach((U) => C.set(U.agentType, U));
      let E = H.map((U) => {
        let q = C.get(U.agentType),
          w = q && q.source !== U.source ? q.source : void 0;
        return {
          ...U,
          overriddenBy: w
        }
      });
      return oB.createElement(oB.Fragment, null, oB.createElement(GH9, {
        source: B.source,
        agents: E,
        onBack: () => {
          let U = W.length > 0 ? `Agent changes:
${W.join(`
`)}` : void 0;
          Q(U ?? "Agents dialog dismissed", {
            display: W.length === 0 ? "system" : void 0
          })
        },
        onSelect: (U) => G({
          mode: "agent-menu",
          agent: U,
          previousMode: B
        }),
        onCreateNew: () => G({
          mode: "create-agent"
        }),
        changes: W
      }), oB.createElement(OVA, null))
    }
    case "create-agent":
      return oB.createElement(kH9, {
        tools: V,
        existingAgents: J,
        onComplete: K,
        onCancel: () => G({
          mode: "list-agents",
          source: "all"
        })
      });
    case "agent-menu": {
      let C = Y.find((w) => w.agentType === B.agent.agentType && w.source === B.agent.source) || B.agent,
        E = C.source === "built-in",
        U = [{
          label: "View agent",
          value: "view"
        }, ...!E ? [{
          label: "Edit agent",
          value: "edit"
        }, {
          label: "Delete agent",
          value: "delete"
        }] : [], {
          label: "Back",
          value: "back"
        }],
        q = (w) => {
          switch (w) {
            case "view":
              G({
                mode: "view-agent",
                agent: C,
                previousMode: B.previousMode
              });
              break;
            case "edit":
              G({
                mode: "edit-agent",
                agent: C,
                previousMode: B
              });
              break;
            case "delete":
              G({
                mode: "delete-confirm",
                agent: C,
                previousMode: B
              });
              break;
            case "back":
              G(B.previousMode);
              break
          }
        };
      return oB.createElement(oB.Fragment, null, oB.createElement(Ma, {
        title: B.agent.agentType
      }, oB.createElement(S, {
        flexDirection: "column",
        marginTop: 1
      }, oB.createElement(M0, {
        options: U,
        onChange: q,
        onCancel: () => G(B.previousMode)
      }), W.length > 0 && oB.createElement(S, {
        marginTop: 1
      }, oB.createElement($, {
        dimColor: !0
      }, W[W.length - 1])))), oB.createElement(OVA, null))
    }
    case "view-agent": {
      let C = Y.find((E) => E.agentType === B.agent.agentType && E.source === B.agent.source) || B.agent;
      return oB.createElement(oB.Fragment, null, oB.createElement(Ma, {
        title: C.agentType
      }, oB.createElement(bH9, {
        agent: C,
        tools: V,
        allAgents: Y,
        onBack: () => G({
          mode: "agent-menu",
          agent: C,
          previousMode: B.previousMode
        })
      })), oB.createElement(OVA, {
        instructions: "Press Enter or Esc to go back"
      }))
    }
    case "delete-confirm": {
      let H = [{
        label: "Yes, delete",
        value: "yes"
      }, {
        label: "No, cancel",
        value: "no"
      }];
      return oB.createElement(oB.Fragment, null, oB.createElement(Ma, {
        title: "Delete agent",
        titleColor: "error",
        borderColor: "error"
      }, oB.createElement($, null, "Are you sure you want to delete the agent", " ", oB.createElement($, {
        bold: !0
      }, B.agent.agentType), "?"), oB.createElement(S, {
        marginTop: 1
      }, oB.createElement($, {
        dimColor: !0
      }, "Source: ", B.agent.source)), oB.createElement(S, {
        marginTop: 1
      }, oB.createElement(M0, {
        options: H,
        onChange: (C) => {
          if (C === "yes") D(B.agent);
          else if ("previousMode" in B) G(B.previousMode)
        },
        onCancel: () => {
          if ("previousMode" in B) G(B.previousMode)
        }
      }))), oB.createElement(OVA, {
        instructions: "Press ↑↓ to navigate, Enter to select, Esc to cancel"
      }))
    }
    case "edit-agent": {
      let C = Y.find((E) => E.agentType === B.agent.agentType && E.source === B.agent.source) || B.agent;
      return oB.createElement(oB.Fragment, null, oB.createElement(Ma, {
        title: `Edit agent: ${C.agentType}`
      }, oB.createElement(xH9, {
        agent: C,
        tools: V,
        onSaved: (E) => {
          K(E), G(B.previousMode)
        },
        onBack: () => G(B.previousMode)
      })), oB.createElement(OVA, null))
    }
    default:
      return null
  }
}
// @from(Start 14289249, End 14289251)
oB
// @from(Start 14289253, End 14289255)
Ra
// @from(Start 14289261, End 14289452)
uH9 = L(() => {
  hA();
  hA();
  F9();
  Q4();
  fP();
  NVA();
  S5();
  ZH9();
  yH9();
  vH9();
  fH9();
  g1();
  hH9();
  gF0();
  z9();
  pW0();
  oB = BA(VA(), 1), Ra = BA(VA(), 1)
})
// @from(Start 14289458, End 14289461)
eF0
// @from(Start 14289463, End 14289466)
kx3
// @from(Start 14289468, End 14289471)
mH9
// @from(Start 14289477, End 14289934)
dH9 = L(() => {
  uH9();
  yq();
  eF0 = BA(VA(), 1), kx3 = {
    type: "local-jsx",
    name: "agents",
    description: "Manage agent configurations",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q) {
      let G = (await Q.getAppState()).toolPermissionContext,
        Z = LC(G);
      return eF0.createElement(gH9, {
        tools: Z,
        onExit: A
      })
    },
    userFacingName() {
      return "agents"
    }
  }, mH9 = kx3
})
// @from(Start 14289937, End 14291782)
function cH9({
  setViewState: A,
  onComplete: Q,
  exitState: B
}) {
  let [G] = OQ(), {
    installationStatus: Z,
    errors: I
  } = G.plugins, Y = Z.marketplaces.length > 0 || Z.plugins.length > 0, J = Z.marketplaces.some((F) => F.status === "failed") || Z.plugins.some((F) => F.status === "failed"), W = I.length > 0, V = [{
    value: "browse-marketplace",
    label: "Browse and install plugins"
  }, {
    value: "manage-plugins",
    label: "Manage and uninstall plugins"
  }, {
    value: "add-marketplace",
    label: "Add marketplace"
  }, {
    value: "manage-marketplaces",
    label: "Manage marketplaces"
  }, ...Y || W ? [{
    value: "installation-status",
    label: `View installation status${J||W?" (errors)":""}`
  }] : []];
  return wY.createElement(S, {
    flexDirection: "column"
  }, wY.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, wY.createElement(S, {
    marginBottom: 1
  }, wY.createElement($, {
    bold: !0
  }, "Plugins")), wY.createElement(M0, {
    options: V,
    onChange: (F) => {
      if (F === "add-marketplace") A({
        type: "add-marketplace"
      });
      else if (F === "manage-marketplaces") A({
        type: "manage-marketplaces"
      });
      else if (F === "browse-marketplace") A({
        type: "browse-marketplace"
      });
      else if (F === "manage-plugins") A({
        type: "manage-plugins"
      });
      else if (F === "installation-status") A({
        type: "installation-status"
      })
    },
    onCancel: () => Q()
  })), wY.createElement(S, {
    marginLeft: 3
  }, wY.createElement($, {
    dimColor: !0,
    italic: !0
  }, B.pending ? wY.createElement(wY.Fragment, null, "Press ", B.keyName, " again to exit") : wY.createElement(wY.Fragment, null, "Press ↑↓ to navigate · Enter to select · Esc to exit"))))
}
// @from(Start 14291787, End 14291789)
wY
// @from(Start 14291795, End 14291856)
pH9 = L(() => {
  hA();
  S5();
  z9();
  wY = BA(VA(), 1)
})
// @from(Start 14291916, End 14292390)
function lH9(A, Q) {
  let B = [],
    G = RA();

  function Z(I) {
    try {
      let Y = G.readdirSync(I);
      for (let J of Y) {
        let W = yx3(I, J.name);
        if (J.isDirectory()) Z(W);
        else if (J.isFile() && J.name.endsWith(".md")) {
          let X = iH9(W, Q);
          if (X) B.push(X)
        }
      }
    } catch (Y) {
      g(`Failed to scan output-styles directory ${I}: ${Y}`, {
        level: "error"
      })
    }
  }
  return Z(A), B
}
// @from(Start 14292392, End 14292931)
function iH9(A, Q) {
  let B = RA();
  try {
    let G = B.readFileSync(A, {
        encoding: "utf-8"
      }),
      {
        frontmatter: Z,
        content: I
      } = NV(G),
      Y = xx3(A, ".md"),
      J = Z.name || Y,
      W = `${Q}:${J}`,
      X = Z.description || Wx(I, `Output style from ${Q} plugin`);
    return {
      name: W,
      description: X,
      prompt: I.trim(),
      source: "plugin"
    }
  } catch (G) {
    return g(`Failed to load output style from ${A}: ${G}`, {
      level: "error"
    }), null
  }
}
// @from(Start 14292933, End 14292974)
function QK0() {
  AK0.cache?.clear?.()
}
// @from(Start 14292979, End 14292982)
AK0
// @from(Start 14292988, End 14294352)
$J1 = L(() => {
  l2();
  AQ();
  fV();
  V0();
  _y();
  AK0 = s1(async () => {
    let {
      enabled: A,
      errors: Q
    } = await l7(), B = [];
    if (Q.length > 0) g(`Plugin loading errors: ${Q.map((G)=>oM(G)).join(", ")}`);
    for (let G of A) {
      if (G.outputStylesPath) try {
        let Z = lH9(G.outputStylesPath, G.name);
        if (B.push(...Z), Z.length > 0) g(`Loaded ${Z.length} output styles from plugin ${G.name} default directory`)
      } catch (Z) {
        g(`Failed to load output styles from plugin ${G.name} default directory: ${Z}`, {
          level: "error"
        })
      }
      if (G.outputStylesPaths)
        for (let Z of G.outputStylesPaths) try {
          let Y = RA().statSync(Z);
          if (Y.isDirectory()) {
            let J = lH9(Z, G.name);
            if (B.push(...J), J.length > 0) g(`Loaded ${J.length} output styles from plugin ${G.name} custom path: ${Z}`)
          } else if (Y.isFile() && Z.endsWith(".md")) {
            let J = iH9(Z, G.name);
            if (J) B.push(J), g(`Loaded output style from plugin ${G.name} custom file: ${Z}`)
          }
        } catch (I) {
          g(`Failed to load output styles from plugin ${G.name} custom path ${Z}: ${I}`, {
            level: "error"
          })
        }
    }
    return g(`Total plugin output styles loaded: ${B.length}`), B
  })
})
// @from(Start 14294355, End 14294409)
function vx3() {
  _IA(), zI1(), Xf2(), bI2(), QK0()
}
// @from(Start 14294411, End 14294443)
function AF() {
  vx3(), nH9()
}
// @from(Start 14294448, End 14294517)
sQA = L(() => {
  fV();
  TjA();
  ETA();
  dMA();
  $J1();
  cE()
})
// @from(Start 14294600, End 14296675)
function wJ1(A) {
  let Q = A.trim(),
    B = RA(),
    G = Q.match(/^(git@[^:]+:.+\.git)(#(.+))?$/);
  if (G?.[1]) {
    let Z = G[1],
      I = G[3];
    return I ? {
      source: "git",
      url: Z,
      ref: I
    } : {
      source: "git",
      url: Z
    }
  }
  if (Q.startsWith("http://") || Q.startsWith("https://")) {
    let Z = Q.match(/^([^#]+)(#(.+))?$/),
      I = Z?.[1] || Q,
      Y = Z?.[3];
    if (I.endsWith(".git")) return Y ? {
      source: "git",
      url: I,
      ref: Y
    } : {
      source: "git",
      url: I
    };
    let J;
    try {
      J = new URL(I)
    } catch (W) {
      return {
        source: "url",
        url: I
      }
    }
    if (J.hostname === "github.com" || J.hostname === "www.github.com") {
      if (J.pathname.match(/^\/([^/]+\/[^/]+?)(\/|\.git|$)/)?.[1]) {
        let X = I.endsWith(".git") ? I : `${I}.git`;
        return Y ? {
          source: "git",
          url: X,
          ref: Y
        } : {
          source: "git",
          url: X
        }
      }
    }
    return {
      source: "url",
      url: I
    }
  }
  if (Q.startsWith("./") || Q.startsWith("../") || Q.startsWith("/") || Q.startsWith("~")) {
    let Z = bx3(Q.startsWith("~") ? Q.replace(/^~/, fx3()) : Q);
    if (!B.existsSync(Z)) return {
      error: `Path does not exist: ${Z}`
    };
    let I = B.statSync(Z);
    if (I.isFile())
      if (Z.endsWith(".json")) return {
        source: "file",
        path: Z
      };
      else return {
        error: `File path must point to a .json file (marketplace.json), but got: ${Z}`
      };
    else if (I.isDirectory()) return {
      source: "directory",
      path: Z
    };
    else return {
      error: `Path is neither a file nor a directory: ${Z}`
    }
  }
  if (Q.includes("/") && !Q.startsWith("@")) {
    if (Q.includes(":")) return null;
    let Z = Q.match(/^([^#]+)(#(.+))?$/),
      I = Z?.[1] || Q,
      Y = Z?.[3];
    return Y ? {
      source: "github",
      repo: I,
      ref: Y
    } : {
      source: "github",
      repo: I
    }
  }
  return null
}
// @from(Start 14296680, End 14296705)
BK0 = L(() => {
  AQ()
})
// @from(Start 14296708, End 14299589)
function aH9({
  inputValue: A,
  setInputValue: Q,
  cursorOffset: B,
  setCursorOffset: G,
  error: Z,
  setError: I,
  result: Y,
  setResult: J,
  setViewState: W,
  onAddComplete: X,
  cliMode: V = !1
}) {
  let F = rQA.useRef(!1),
    [K, D] = rQA.useState(!1),
    [H, C] = rQA.useState(""),
    E = async () => {
      let U = A.trim();
      if (!U) {
        I("Please enter a marketplace source");
        return
      }
      let q = wJ1(U);
      if (!q) {
        I("Invalid marketplace source format. Try: owner/repo, https://..., or ./path");
        return
      }
      if ("error" in q) {
        I(q.error);
        return
      }
      I(null);
      try {
        D(!0), C("");
        let {
          name: w
        } = await rAA(q, (R) => {
          C(R)
        });
        AF();
        let N = q.source;
        if (q.source === "github") N = q.repo;
        if (GA("tengu_marketplace_added", {
            source_type: N
          }), X) await X();
        if (C(""), D(!1), V) J(`Successfully added marketplace: ${w}`);
        else W({
          type: "browse-marketplace",
          targetMarketplace: w
        })
      } catch (w) {
        let N = w instanceof Error ? w : Error(String(w));
        if (AA(N), I(N.message), C(""), D(!1), V) J(`Error: ${N.message}`);
        else J(null)
      }
    };
  return rQA.useEffect(() => {
    if (A && !F.current && !Z && !Y) F.current = !0, E()
  }, []), Z8.createElement(S, {
    flexDirection: "column"
  }, Z8.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, Z8.createElement(S, {
    marginBottom: 1
  }, Z8.createElement($, {
    bold: !0
  }, "Add Marketplace")), Z8.createElement(S, {
    flexDirection: "column"
  }, Z8.createElement($, null, "Enter marketplace source:"), Z8.createElement($, {
    dimColor: !0
  }, "Examples:"), Z8.createElement($, {
    dimColor: !0
  }, " • owner/repo (GitHub)"), Z8.createElement($, {
    dimColor: !0
  }, " • git@github.com:owner/repo.git (SSH)"), Z8.createElement($, {
    dimColor: !0
  }, " • https://example.com/marketplace.json"), Z8.createElement($, {
    dimColor: !0
  }, " • ./path/to/marketplace"), Z8.createElement(S, {
    marginTop: 1
  }, Z8.createElement(s4, {
    value: A,
    onChange: Q,
    onSubmit: E,
    columns: 80,
    cursorOffset: B,
    onChangeCursorOffset: G,
    focus: !0,
    showCursor: !0
  }))), K && Z8.createElement(S, {
    marginTop: 1
  }, Z8.createElement(g4, null), Z8.createElement($, null, H || "Adding marketplace to configuration…")), Z && Z8.createElement(S, {
    marginTop: 1
  }, Z8.createElement($, {
    color: "error"
  }, Z)), Y && Z8.createElement(S, {
    marginTop: 1
  }, Z8.createElement($, null, Y))), Z8.createElement(S, {
    marginLeft: 3
  }, Z8.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Enter to add · Esc to cancel")))
}
// @from(Start 14299594, End 14299596)
Z8
// @from(Start 14299598, End 14299601)
rQA
// @from(Start 14299607, End 14299729)
sH9 = L(() => {
  hA();
  ZY();
  oH();
  sQA();
  q0();
  BK0();
  DY();
  g1();
  Z8 = BA(VA(), 1), rQA = BA(VA(), 1)
})
// @from(Start 14299732, End 14313808)
function rH9({
  setViewState: A,
  error: Q,
  setError: B,
  setResult: G,
  exitState: Z,
  onManageComplete: I,
  targetMarketplace: Y,
  action: J
}) {
  let [W, X] = Wz.useState([]), [V, F] = Wz.useState(!0), [K, D] = Wz.useState(0), [H, C] = Wz.useState(!1), [E, U] = Wz.useState(null), [q, w] = Wz.useState(null), [N, R] = Wz.useState(null), [T, y] = Wz.useState("list"), [v, x] = Wz.useState(null), [p, u] = Wz.useState(0), e = Wz.useRef(!1);
  Wz.useEffect(() => {
    async function zA() {
      try {
        let NA = await pZ(),
          {
            enabled: OA,
            disabled: mA
          } = await l7(),
          wA = [...OA, ...mA],
          {
            marketplaces: qA,
            failures: KA
          } = await NLA(NA),
          yA = [];
        for (let {
            name: WA,
            config: EA,
            data: MA
          }
          of qA) {
          let DA = wA.filter(($A) => $A.source.endsWith(`@${WA}`));
          yA.push({
            name: WA,
            source: qLA(EA.source),
            lastUpdated: EA.lastUpdated,
            pluginCount: MA?.plugins.length,
            installedPlugins: DA,
            pendingUpdate: !1,
            pendingRemove: !1
          })
        }
        yA.sort((WA, EA) => WA.name.localeCompare(EA.name)), X(yA);
        let oA = qA.filter((WA) => WA.data !== null).length,
          X1 = BB1(KA, oA);
        if (X1)
          if (X1.type === "warning") U(X1.message);
          else throw Error(X1.message);
        if (Y && J && !e.current && !Q) {
          e.current = !0;
          let WA = yA.findIndex((EA) => EA.name === Y);
          if (WA >= 0) {
            D(WA);
            let EA = [...yA];
            if (J === "update") EA[WA].pendingUpdate = !0;
            else if (J === "remove") EA[WA].pendingRemove = !0;
            X(EA), setTimeout(() => {
              m(EA)
            }, 100)
          } else if (B) B(`Marketplace not found: ${Y}`)
        }
      } catch (NA) {
        if (B) B(NA instanceof Error ? NA.message : "Failed to load marketplaces");
        U(NA instanceof Error ? NA.message : "Failed to load marketplaces")
      } finally {
        F(!1)
      }
    }
    zA()
  }, [Y, J, Q]);
  let l = () => {
      return W.some((zA) => zA.pendingUpdate || zA.pendingRemove)
    },
    k = () => {
      let zA = W.filter((OA) => OA.pendingUpdate).length,
        NA = W.filter((OA) => OA.pendingRemove).length;
      return {
        updateCount: zA,
        removeCount: NA
      }
    },
    m = async (zA) => {
      let NA = zA || W,
        OA = T === "details";
      C(!0), U(null), w(null), R(null);
      try {
        let mA = OB("userSettings"),
          wA = 0,
          qA = 0;
        for (let DA of NA) {
          if (DA.pendingRemove) {
            if (DA.installedPlugins && DA.installedPlugins.length > 0) {
              let $A = {
                ...mA?.enabledPlugins
              };
              for (let TA of DA.installedPlugins) {
                let rA = jIA(TA.name, DA.name);
                $A[rA] = !1
              }
              cB("userSettings", {
                enabledPlugins: $A
              })
            }
            await ZB1(DA.name), qA++, GA("tengu_marketplace_removed", {
              marketplace_name: DA.name,
              plugins_uninstalled: DA.installedPlugins?.length || 0
            });
            continue
          }
          if (DA.pendingUpdate) await IB1(DA.name, ($A) => {
            R($A)
          }), wA++, GA("tengu_marketplace_updated", {
            marketplace_name: DA.name
          })
        }
        if (AF(), I) await I();
        let KA = await pZ(),
          {
            enabled: yA,
            disabled: oA
          } = await l7(),
          X1 = [...yA, ...oA],
          {
            marketplaces: WA
          } = await NLA(KA),
          EA = [];
        for (let {
            name: DA,
            config: $A,
            data: TA
          }
          of WA) {
          let rA = X1.filter((iA) => iA.source.endsWith(`@${DA}`));
          EA.push({
            name: DA,
            source: qLA($A.source),
            lastUpdated: $A.lastUpdated,
            pluginCount: TA?.plugins.length,
            installedPlugins: rA,
            pendingUpdate: !1,
            pendingRemove: !1
          })
        }
        if (EA.sort((DA, $A) => DA.name.localeCompare($A.name)), X(EA), OA && v) {
          let DA = EA.find(($A) => $A.name === v.name);
          if (DA) x(DA)
        }
        let MA = [];
        if (wA > 0) MA.push(`Updated ${wA} marketplace${wA>1?"s":""}`);
        if (qA > 0) MA.push(`Removed ${qA} marketplace${qA>1?"s":""}`);
        if (MA.length > 0) {
          let DA = `${H1.tick} ${MA.join(", ")}`;
          if (OA) w(DA);
          else G(DA), setTimeout(() => {
            A({
              type: "menu"
            })
          }, 2000)
        } else if (!OA) A({
          type: "menu"
        })
      } catch (mA) {
        let wA = mA instanceof Error ? mA.message : String(mA);
        if (U(wA), B) B(wA)
      } finally {
        C(!1), R(null)
      }
    }, o = async () => {
      if (!v) return;
      let zA = W.map((NA) => NA.name === v.name ? {
        ...NA,
        pendingRemove: !0
      } : NA);
      X(zA), await m(zA)
    };
  if (f1((zA, NA) => {
      if (H) return;
      if (NA.escape) {
        if (T === "details" || T === "confirm-remove") {
          y("list"), u(0);
          return
        }
        if (l()) X((OA) => OA.map((mA) => ({
          ...mA,
          pendingUpdate: !1,
          pendingRemove: !1
        }))), D(0);
        else A({
          type: "menu"
        });
        return
      }
      if (T === "list") {
        if (NA.upArrow || zA === "k") D((OA) => Math.max(0, OA - 1));
        else if (NA.downArrow || zA === "j") D((OA) => Math.min(W.length - 1, OA + 1));
        else if (zA === "u" || zA === "U") X((OA) => OA.map((mA, wA) => wA === K ? {
          ...mA,
          pendingUpdate: !mA.pendingUpdate,
          pendingRemove: mA.pendingUpdate ? mA.pendingRemove : !1
        } : mA));
        else if (zA === "r" || zA === "R") {
          let OA = W[K];
          if (OA) x(OA), y("confirm-remove")
        } else if (NA.return) {
          let OA = W[K];
          if (OA && !l()) x(OA), y("details"), u(0);
          else if (l()) m()
        }
      } else if (T === "details") {
        let mA = v?.source.startsWith("http") ? 2 : 1;
        if (NA.upArrow || zA === "k") u((wA) => Math.max(0, wA - 1));
        else if (NA.downArrow || zA === "j") u((wA) => Math.min(mA, wA + 1));
        else if (NA.return && v) {
          if (p === 0) {
            let wA = W.map((qA) => qA.name === v.name ? {
              ...qA,
              pendingUpdate: !0
            } : qA);
            X(wA), m(wA)
          } else if (p === 1) y("confirm-remove");
          else if (p === 2) {
            if (v.source.startsWith("http")) cZ(v.source)
          }
        }
      } else if (T === "confirm-remove") {
        if (zA === "y" || zA === "Y") o();
        else if (zA === "n" || zA === "N") y("list"), x(null)
      }
    }), V) return r1.createElement(S, {
    flexDirection: "column"
  }, r1.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, r1.createElement($, null, "Loading marketplaces…")));
  if (W.length === 0) return r1.createElement(S, {
    flexDirection: "column"
  }, r1.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, r1.createElement($, null, "No marketplaces configured.")), r1.createElement(S, {
    marginLeft: 3,
    marginTop: 1
  }, r1.createElement($, {
    dimColor: !0
  }, Z.pending ? r1.createElement(r1.Fragment, null, "Press ", Z.keyName, " again to go back") : r1.createElement(r1.Fragment, null, "Esc to go back"))));
  if (T === "confirm-remove" && v) {
    let zA = v.installedPlugins?.length || 0;
    return r1.createElement(S, {
      flexDirection: "column"
    }, r1.createElement(S, {
      flexDirection: "column",
      paddingX: 1,
      borderStyle: "round"
    }, r1.createElement($, {
      bold: !0,
      color: "warning"
    }, "Remove marketplace ", r1.createElement($, {
      italic: !0
    }, v.name), "?"), r1.createElement(S, {
      flexDirection: "column"
    }, zA > 0 && r1.createElement(S, {
      marginTop: 1
    }, r1.createElement($, {
      color: "warning"
    }, "This will also uninstall ", zA, " plugin", zA !== 1 ? "s" : "", " from this marketplace:")), v.installedPlugins && v.installedPlugins.length > 0 && r1.createElement(S, {
      flexDirection: "column",
      marginTop: 1,
      marginLeft: 2
    }, v.installedPlugins.map((NA) => r1.createElement($, {
      key: NA.name,
      dimColor: !0
    }, "• ", NA.name))), r1.createElement(S, {
      marginTop: 1
    }, r1.createElement($, null, "Press ", r1.createElement($, {
      bold: !0
    }, "y"), " to confirm or ", r1.createElement($, {
      bold: !0
    }, "n"), " to cancel")))))
  }
  if (T === "details" && v) {
    let zA = v.pendingUpdate || H,
      NA = [{
        label: "Update marketplace",
        value: "update"
      }, {
        label: "Remove marketplace",
        value: "remove"
      }, v.source.startsWith("http") && {
        label: "Open in browser",
        value: "browser"
      }].filter(Boolean);
    return r1.createElement(S, {
      flexDirection: "column"
    }, r1.createElement(S, {
      flexDirection: "column",
      paddingX: 1,
      borderStyle: "round"
    }, r1.createElement($, {
      bold: !0
    }, v.name), r1.createElement($, {
      dimColor: !0
    }, v.source), v.lastUpdated && r1.createElement($, {
      dimColor: !0
    }, "Last updated:", " ", new Date(v.lastUpdated).toLocaleDateString()), r1.createElement(S, {
      marginTop: 1
    }, r1.createElement($, null, v.pluginCount || 0, " available plugin", v.pluginCount !== 1 ? "s" : "")), v.installedPlugins && v.installedPlugins.length > 0 && r1.createElement(S, {
      flexDirection: "column",
      marginTop: 1
    }, r1.createElement($, {
      bold: !0
    }, "Installed plugins (", v.installedPlugins.length, "):"), r1.createElement(S, {
      flexDirection: "column",
      marginLeft: 1
    }, v.installedPlugins.map((OA) => r1.createElement(S, {
      key: OA.name,
      flexDirection: "row",
      gap: 1
    }, r1.createElement($, null, H1.bullet), r1.createElement(S, {
      flexDirection: "column"
    }, r1.createElement($, null, OA.name), r1.createElement($, {
      dimColor: !0
    }, OA.manifest.description)))))), zA && r1.createElement(S, {
      marginTop: 1,
      flexDirection: "column"
    }, r1.createElement($, {
      color: "claude"
    }, "Updating marketplace…"), N && r1.createElement($, {
      dimColor: !0
    }, N)), !zA && q && r1.createElement(S, {
      marginTop: 1
    }, r1.createElement($, {
      color: "claude"
    }, q)), !zA && E && r1.createElement(S, {
      marginTop: 1
    }, r1.createElement($, {
      color: "error"
    }, E)), !zA && r1.createElement(S, {
      flexDirection: "column",
      marginTop: 1
    }, NA.map((OA, mA) => {
      if (!OA) return null;
      let wA = mA === p;
      return r1.createElement(S, {
        key: OA.value
      }, r1.createElement($, {
        color: wA ? "claude" : void 0
      }, wA ? H1.pointer : " ", " ", OA.label))
    }))), r1.createElement(S, {
      marginLeft: 3
    }, r1.createElement($, {
      dimColor: !0,
      italic: !0
    }, zA ? r1.createElement(r1.Fragment, null, "Please wait…") : r1.createElement(r1.Fragment, null, H1.arrowUp, H1.arrowDown, " · enter to select · Esc to go back"))))
  }
  let {
    updateCount: IA,
    removeCount: FA
  } = k();
  return r1.createElement(S, {
    flexDirection: "column"
  }, r1.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, r1.createElement(S, {
    marginBottom: 1
  }, r1.createElement($, {
    bold: !0
  }, "Manage marketplaces")), r1.createElement(S, {
    flexDirection: "column"
  }, W.map((zA, NA) => {
    let OA = NA === K,
      mA = [];
    if (zA.pendingUpdate) mA.push("UPDATE");
    if (zA.pendingRemove) mA.push("REMOVE");
    return r1.createElement(S, {
      key: zA.name,
      flexDirection: "row",
      gap: 1,
      marginBottom: 1
    }, r1.createElement($, {
      color: OA ? "claude" : void 0
    }, OA ? H1.pointer : " ", " ", zA.pendingRemove ? H1.cross : H1.bullet), r1.createElement(S, {
      flexDirection: "column",
      flexGrow: 1
    }, r1.createElement(S, {
      flexDirection: "row",
      gap: 1
    }, r1.createElement($, {
      bold: !0,
      strikethrough: zA.pendingRemove,
      dimColor: zA.pendingRemove
    }, zA.name), mA.length > 0 && r1.createElement($, {
      color: "warning"
    }, "[", mA.join(", "), "]")), r1.createElement($, {
      dimColor: !0
    }, zA.source), r1.createElement($, {
      dimColor: !0
    }, zA.pluginCount !== void 0 && r1.createElement(r1.Fragment, null, zA.pluginCount, " available"), zA.installedPlugins && zA.installedPlugins.length > 0 && r1.createElement(r1.Fragment, null, " • ", zA.installedPlugins.length, " installed"), zA.lastUpdated && r1.createElement(r1.Fragment, null, " ", "• Updated", " ", new Date(zA.lastUpdated).toLocaleDateString()))))
  })), l() && r1.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, r1.createElement($, null, r1.createElement($, {
    bold: !0
  }, "Pending changes:"), " ", r1.createElement($, {
    dimColor: !0
  }, "Enter to apply")), IA > 0 && r1.createElement($, null, "• Update ", IA, " marketplace", IA > 1 ? "s" : ""), FA > 0 && r1.createElement($, {
    color: "warning"
  }, "• Remove ", FA, " marketplace", FA > 1 ? "s" : "")), H && r1.createElement(S, {
    marginTop: 1
  }, r1.createElement($, {
    color: "claude"
  }, "Processing changes…")), E && r1.createElement(S, {
    marginTop: 1
  }, r1.createElement($, {
    color: "error"
  }, E))), r1.createElement(hx3, {
    exitState: Z,
    hasPendingActions: l()
  }))
}
// @from(Start 14313810, End 14314305)
function hx3({
  exitState: A,
  hasPendingActions: Q
}) {
  let B = [];
  if (A.pending) B.push(`Press ${A.keyName} again to go back`);
  else {
    if (B.push(`${H1.arrowUp}${H1.arrowDown}`), Q) B.push("Enter to apply changes");
    else B.push("Enter for details"), B.push("u update"), B.push("r remove");
    B.push(Q ? "Esc to cancel" : "Esc to go back")
  }
  return r1.createElement(S, {
    marginLeft: 3
  }, r1.createElement($, {
    dimColor: !0,
    italic: !0
  }, B.join(" · ")))
}
// @from(Start 14314310, End 14314312)
r1
// @from(Start 14314314, End 14314316)
Wz
// @from(Start 14314322, End 14314459)
oH9 = L(() => {
  hA();
  hA();
  V9();
  oH();
  sQA();
  q0();
  fV();
  OLA();
  gM();
  MB();
  r1 = BA(VA(), 1), Wz = BA(VA(), 1)
})
// @from(Start 14314462, End 14330424)
function tH9({
  error: A,
  setError: Q,
  result: B,
  setResult: G,
  setViewState: Z,
  onInstallComplete: I,
  targetMarketplace: Y,
  targetPlugin: J
}) {
  let [W, X] = OK.useState("marketplace-list"), [V, F] = OK.useState(null), [K, D] = OK.useState(null), [H, C] = OK.useState([]), [E, U] = OK.useState([]), [q, w] = OK.useState(!0), [N, R] = OK.useState(0), [T, y] = OK.useState(new Set), [v, x] = OK.useState(new Set), [p, u] = OK.useState(0), [e, l] = OK.useState(!1), [k, m] = OK.useState(null), [o, IA] = OK.useState(null);
  OK.useEffect(() => {
    async function NA() {
      try {
        let OA = await pZ(),
          {
            marketplaces: mA,
            failures: wA
          } = await NLA(OA),
          qA = [];
        for (let {
            name: oA,
            config: X1,
            data: WA
          }
          of mA)
          if (WA) {
            let EA = WA.plugins.filter((MA) => gg(jIA(MA.name, oA))).length;
            qA.push({
              name: oA,
              totalPlugins: WA.plugins.length,
              installedCount: EA,
              source: qLA(X1.source)
            })
          } C(qA);
        let KA = mA.filter((oA) => oA.data !== null).length,
          yA = BB1(wA, KA);
        if (yA)
          if (yA.type === "warning") IA(yA.message + ". Showing available marketplaces.");
          else throw Error(yA.message);
        if (qA.length === 1 && !Y && !J) {
          let oA = qA[0];
          if (oA) F(oA.name), X("plugin-list")
        }
        if (J) {
          let oA = null,
            X1 = null;
          for (let [WA] of Object.entries(OA)) {
            let EA = await _D(WA);
            if (EA) {
              let MA = EA.plugins.find((DA) => DA.name === J);
              if (MA) {
                oA = {
                  entry: MA,
                  marketplaceName: WA,
                  pluginId: jIA(MA.name, WA)
                }, X1 = WA;
                break
              }
            }
          }
          if (oA && X1) {
            let WA = oA.pluginId;
            if (gg(WA)) Q(`Plugin '${WA}' is already installed. Use '/plugin' to manage existing plugins.`);
            else F(X1), D(oA), X("plugin-details")
          } else Q(`Plugin "${J}" not found in any marketplace`)
        } else if (Y)
          if (qA.some((X1) => X1.name === Y)) F(Y), X("plugin-list");
          else Q(`Marketplace "${Y}" not found`)
      } catch (OA) {
        Q(OA instanceof Error ? OA.message : "Failed to load marketplaces")
      } finally {
        w(!1)
      }
    }
    NA()
  }, [Q, Y, J]), OK.useEffect(() => {
    if (!V) return;
    async function NA(OA) {
      w(!0);
      try {
        let mA = await _D(OA);
        if (!mA) throw Error(`Failed to load marketplace: ${OA}`);
        let wA = [];
        for (let qA of mA.plugins) {
          let KA = jIA(qA.name, OA);
          if (!gg(KA)) wA.push({
            entry: qA,
            marketplaceName: OA,
            pluginId: KA
          })
        }
        U(wA), R(0), y(new Set)
      } catch (mA) {
        Q(mA instanceof Error ? mA.message : "Failed to load plugins")
      } finally {
        w(!1)
      }
    }
    NA(V)
  }, [V, Q]);
  let FA = async () => {
    if (T.size === 0) return;
    let NA = E.filter((qA) => T.has(qA.pluginId));
    x(new Set(NA.map((qA) => qA.pluginId)));
    let OA = 0,
      mA = 0,
      wA = [];
    for (let qA of NA) try {
      if (typeof qA.entry.source !== "string") await Bj(qA.pluginId, qA.entry);
      let yA = {
        ...OB("userSettings")?.enabledPlugins,
        [qA.pluginId]: !0
      };
      cB("userSettings", {
        enabledPlugins: yA
      }), OA++, GA("tengu_plugin_installed", {
        plugin_id: qA.pluginId,
        marketplace_name: qA.marketplaceName
      })
    } catch (KA) {
      mA++;
      let yA = KA instanceof Error ? KA.message : String(KA);
      wA.push({
        name: qA.entry.name,
        reason: yA
      }), AA(KA instanceof Error ? KA : Error(`Failed to install ${qA.entry.name}: ${KA}`))
    }
    if (x(new Set), y(new Set), AF(), mA === 0) {
      let qA = `✓ Installed ${OA} plugin${OA!==1?"s":""}. Restart Claude Code to load new plugins.`;
      G(qA)
    } else if (OA === 0) Q(`Failed to install: ${xe1(wA,!0)}`);
    else {
      let qA = `✓ Installed ${OA} of ${OA+mA} plugins. Failed: ${xe1(wA,!1)}. Restart Claude Code to load successfully installed plugins.`;
      G(qA)
    }
    if (OA > 0) {
      if (I) await I()
    }
    Z({
      type: "menu"
    })
  }, zA = async (NA) => {
    l(!0), m(null);
    try {
      if (typeof NA.entry.source !== "string") await Bj(NA.pluginId, NA.entry);
      let mA = {
        ...OB("userSettings")?.enabledPlugins,
        [NA.pluginId]: !0
      };
      cB("userSettings", {
        enabledPlugins: mA
      }), GA("tengu_plugin_installed", {
        plugin_id: NA.pluginId,
        marketplace_name: NA.marketplaceName
      }), AF();
      let wA = `✓ Installed ${NA.entry.name}. Restart Claude Code to load new plugins.`;
      if (G(wA), I) await I();
      Z({
        type: "menu"
      })
    } catch (OA) {
      l(!1);
      let mA = OA instanceof Error ? OA.message : String(OA);
      m(`Failed to install: ${mA}`), AA(OA instanceof Error ? OA : Error(`Failed to install plugin: ${String(OA)}`))
    }
  };
  if (OK.useEffect(() => {
      if (A) G(A)
    }, [A, G]), f1((NA, OA) => {
      if (OA.escape) {
        if (W === "plugin-list") X("marketplace-list"), F(null), y(new Set);
        else if (W === "plugin-details") X("plugin-list"), D(null);
        return
      }
      if (W === "marketplace-list") {
        if ((OA.upArrow || NA === "k") && N > 0) R(N - 1);
        else if ((OA.downArrow || NA === "j") && N < H.length - 1) R(N + 1);
        else if (OA.return) {
          let mA = H[N];
          if (mA) F(mA.name), X("plugin-list")
        }
      } else if (W === "plugin-list") {
        let mA = E.length;
        if ((OA.upArrow || NA === "k") && N > 0) R(N - 1);
        else if ((OA.downArrow || NA === "j") && N < mA - 1) R(N + 1);
        else if (NA === " ") {
          if (N < E.length) {
            let wA = E[N];
            if (wA) {
              let qA = new Set(T);
              if (qA.has(wA.pluginId)) qA.delete(wA.pluginId);
              else qA.add(wA.pluginId);
              y(qA)
            }
          }
        } else if (OA.return) {
          if (N === E.length && T.size > 0) FA();
          else if (N < E.length) {
            let wA = E[N];
            if (wA) D(wA), X("plugin-details"), u(0), m(null)
          }
        } else if (NA === "i" && T.size > 0) FA()
      } else if (W === "plugin-details" && K) {
        let mA = K.entry.homepage,
          qA = K.entry.source && typeof K.entry.source === "object" && "source" in K.entry.source && K.entry.source.source === "github" && typeof K.entry.source === "object" && "repo" in K.entry.source ? K.entry.source.repo : null,
          KA = [];
        if (KA.push({
            label: "Install now",
            action: "install"
          }), mA) KA.push({
          label: "Open homepage",
          action: "homepage"
        });
        if (qA) KA.push({
          label: "View on GitHub",
          action: "github"
        });
        if (KA.push({
            label: "Back to plugin list",
            action: "back"
          }), (OA.upArrow || NA === "k") && p > 0) u(p - 1);
        else if ((OA.downArrow || NA === "j") && p < KA.length - 1) u(p + 1);
        else if (OA.return) {
          let yA = KA[p]?.action;
          if (yA === "mark") {
            let oA = new Set(T);
            if (oA.has(K.pluginId)) oA.delete(K.pluginId);
            else oA.add(K.pluginId);
            y(oA), X("plugin-list"), D(null)
          } else if (yA === "install") zA(K);
          else if (yA === "homepage" && mA) cZ(mA);
          else if (yA === "github" && qA) cZ(`https://github.com/${qA}`);
          else if (yA === "back") X("plugin-list"), D(null)
        }
      }
    }), q) return A0.createElement(S, {
    flexDirection: "column"
  }, A0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, A0.createElement($, null, "Loading…")));
  if (A) return A0.createElement(S, {
    flexDirection: "column"
  }, A0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, A0.createElement($, {
    color: "error"
  }, A)));
  if (W === "marketplace-list") {
    if (H.length === 0) return A0.createElement(S, {
      flexDirection: "column"
    }, A0.createElement(S, {
      flexDirection: "column",
      paddingX: 1,
      borderStyle: "round"
    }, A0.createElement(S, {
      marginBottom: 1
    }, A0.createElement($, {
      bold: !0
    }, "Select marketplace")), A0.createElement($, null, "No marketplaces configured."), A0.createElement($, {
      dimColor: !0
    }, "Add a marketplace first using ", "'Add marketplace'", ".")), A0.createElement(S, {
      marginTop: 1,
      paddingLeft: 1
    }, A0.createElement($, {
      dimColor: !0
    }, "Esc to go back")));
    return A0.createElement(S, {
      flexDirection: "column"
    }, A0.createElement(S, {
      flexDirection: "column",
      paddingX: 1,
      borderStyle: "round"
    }, A0.createElement(S, {
      marginBottom: 1
    }, A0.createElement($, {
      bold: !0
    }, "Select marketplace")), o && A0.createElement(S, {
      marginBottom: 1,
      flexDirection: "column"
    }, A0.createElement($, {
      color: "warning"
    }, H1.warning, " ", o)), H.map((NA, OA) => A0.createElement(S, {
      key: NA.name,
      flexDirection: "column",
      marginBottom: OA < H.length - 1 ? 1 : 0
    }, A0.createElement(S, null, A0.createElement($, {
      color: N === OA ? "suggestion" : void 0
    }, N === OA ? H1.pointer : " ", " ", NA.name)), A0.createElement(S, {
      marginLeft: 2
    }, A0.createElement($, {
      dimColor: !0
    }, NA.totalPlugins, " plugin", NA.totalPlugins !== 1 ? "s" : "", " available", NA.installedCount > 0 && ` · ${NA.installedCount} already installed`, NA.source && ` · ${NA.source}`))))), A0.createElement(S, {
      paddingLeft: 1
    }, A0.createElement($, {
      dimColor: !0,
      italic: !0
    }, "Enter to select · esc to go back")))
  }
  if (W === "plugin-details" && K) {
    let NA = K.entry.homepage,
      mA = K.entry.source && typeof K.entry.source === "object" && "source" in K.entry.source && K.entry.source.source === "github" && typeof K.entry.source === "object" && "repo" in K.entry.source ? K.entry.source.repo : null,
      wA = [];
    if (wA.push({
        label: "Install now",
        action: "install"
      }), NA) wA.push({
      label: "Open homepage",
      action: "homepage"
    });
    if (mA) wA.push({
      label: "View on GitHub",
      action: "github"
    });
    return wA.push({
      label: "Back to plugin list",
      action: "back"
    }), A0.createElement(S, {
      flexDirection: "column"
    }, A0.createElement(S, {
      flexDirection: "column",
      paddingX: 1,
      borderStyle: "round"
    }, A0.createElement(S, {
      marginBottom: 1
    }, A0.createElement($, {
      bold: !0
    }, "Plugin Details")), A0.createElement(S, {
      flexDirection: "column",
      marginBottom: 1
    }, A0.createElement($, {
      bold: !0
    }, K.entry.name), K.entry.version && A0.createElement($, {
      dimColor: !0
    }, "Version: ", K.entry.version), K.entry.description && A0.createElement(S, {
      marginTop: 1
    }, A0.createElement($, null, K.entry.description)), K.entry.author && A0.createElement(S, {
      marginTop: 1
    }, A0.createElement($, {
      dimColor: !0
    }, "By:", " ", typeof K.entry.author === "string" ? K.entry.author : K.entry.author.name))), A0.createElement(S, {
      flexDirection: "column",
      marginBottom: 1
    }, A0.createElement($, {
      bold: !0
    }, "Will install:"), K.entry.commands && A0.createElement($, {
      dimColor: !0
    }, "• Commands:", " ", Array.isArray(K.entry.commands) ? K.entry.commands.join(", ") : Object.keys(K.entry.commands).join(", ")), K.entry.agents && A0.createElement($, {
      dimColor: !0
    }, "• Agents:", " ", Array.isArray(K.entry.agents) ? K.entry.agents.join(", ") : Object.keys(K.entry.agents).join(", ")), K.entry.hooks && A0.createElement($, {
      dimColor: !0
    }, "• Hooks: ", Object.keys(K.entry.hooks).join(", ")), K.entry.mcpServers && A0.createElement($, {
      dimColor: !0
    }, "• MCP Servers:", " ", Array.isArray(K.entry.mcpServers) ? K.entry.mcpServers.join(", ") : typeof K.entry.mcpServers === "object" ? Object.keys(K.entry.mcpServers).join(", ") : "configured"), !K.entry.commands && !K.entry.agents && !K.entry.hooks && !K.entry.mcpServers && A0.createElement(A0.Fragment, null, typeof K.entry.source === "object" && "source" in K.entry.source && (K.entry.source.source === "github" || K.entry.source.source === "url" || K.entry.source.source === "npm" || K.entry.source.source === "pip") ? A0.createElement($, {
      dimColor: !0
    }, "• Component summary not available for remote plugin") : A0.createElement($, {
      dimColor: !0
    }, "• Components will be discovered at installation"))), k && A0.createElement(S, {
      marginBottom: 1
    }, A0.createElement($, {
      color: "error"
    }, "Error: ", k)), A0.createElement(S, {
      flexDirection: "column"
    }, wA.map((qA, KA) => A0.createElement(S, {
      key: qA.action
    }, p === KA && A0.createElement($, null, "> "), p !== KA && A0.createElement($, null, "  "), A0.createElement($, {
      bold: p === KA
    }, e && qA.action === "install" ? "Installing…" : qA.label))))), A0.createElement(S, {
      marginTop: 1,
      paddingLeft: 1
    }, A0.createElement($, {
      dimColor: !0
    }, A0.createElement($, {
      bold: !0
    }, "Select:"), " Enter", " • ", A0.createElement($, {
      bold: !0
    }, "Back:"), " Esc")))
  }
  if (E.length === 0) return A0.createElement(S, {
    flexDirection: "column"
  }, A0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, A0.createElement(S, {
    marginBottom: 1
  }, A0.createElement($, {
    bold: !0
  }, V, " ", H1.pointerSmall, " Install plugins")), A0.createElement($, {
    dimColor: !0
  }, "No new plugins available to install."), A0.createElement($, {
    dimColor: !0
  }, "All plugins from this marketplace are already installed.")), A0.createElement(S, {
    marginLeft: 3
  }, A0.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Esc to go back")));
  return A0.createElement(S, {
    flexDirection: "column"
  }, A0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, A0.createElement(S, {
    marginBottom: 1
  }, A0.createElement($, {
    bold: !0
  }, V, " ", H1.pointerSmall, " Install plugins")), E.map((NA, OA) => {
    let mA = N === OA,
      wA = T.has(NA.pluginId),
      qA = v.has(NA.pluginId),
      KA = OA === E.length - 1;
    return A0.createElement(S, {
      key: NA.pluginId,
      flexDirection: "column",
      marginBottom: KA && !A ? 0 : 1
    }, A0.createElement(S, null, A0.createElement($, {
      color: mA ? "suggestion" : void 0
    }, mA ? H1.pointer : " ", " "), A0.createElement($, null, qA ? H1.ellipsis : wA ? H1.radioOn : H1.radioOff, " ", NA.entry.name, NA.entry.category && A0.createElement($, {
      dimColor: !0
    }, " [", NA.entry.category, "]"))), NA.entry.description && A0.createElement(S, {
      marginLeft: 4
    }, A0.createElement($, {
      dimColor: !0
    }, NA.entry.description.length > 60 ? NA.entry.description.substring(0, 57) + "..." : NA.entry.description), NA.entry.version && A0.createElement($, {
      dimColor: !0
    }, " · v", NA.entry.version)))
  }), A && A0.createElement(S, {
    marginTop: 1
  }, A0.createElement($, {
    color: "error"
  }, H1.cross, " ", A))), A0.createElement(gx3, {
    hasSelection: T.size > 0
  }))
}
// @from(Start 14330426, End 14330857)
function gx3({
  hasSelection: A
}) {
  let Q = [];
  return Q.push("Space to (de)select"), Q.push("Enter for details"), Q.push("Esc to go back"), A0.createElement(S, {
    marginLeft: 3
  }, A0.createElement($, {
    italic: !0
  }, A && A0.createElement($, {
    bold: !0,
    color: "suggestion"
  }, "Press i to install ·", " "), A0.createElement($, {
    dimColor: !0
  }, "Space: (de)select · Enter: details · Esc: back")))
}
// @from(Start 14330862, End 14330864)
A0
// @from(Start 14330866, End 14330868)
OK
// @from(Start 14330874, End 14331028)
eH9 = L(() => {
  hA();
  hA();
  V9();
  oH();
  OLA();
  MB();
  sQA();
  q0();
  g1();
  gM();
  ejA();
  za();
  A0 = BA(VA(), 1), OK = BA(VA(), 1)
})
// @from(Start 14331031, End 14333970)
function AC9({
  pluginName: A,
  serverName: Q,
  configSchema: B,
  onSave: G,
  onCancel: Z
}) {
  let I = Object.keys(B),
    [Y, J] = AG.useState(0),
    [W, X] = AG.useState({}),
    [V, F] = AG.useState(""),
    K = I[Y],
    D = K ? B[K] : null,
    H = EQ(Z);
  if (f1((q, w) => {
      if (w.escape) {
        Z();
        return
      }
      if (w.tab && Y < I.length - 1) {
        if (K) X({
          ...W,
          [K]: V
        });
        J(Y + 1), F("");
        return
      }
      if (w.return) {
        if (K) {
          let N = {
            ...W,
            [K]: V
          };
          if (Y === I.length - 1) {
            let R = {};
            for (let T of I) {
              let y = N[T] || "",
                v = B[T];
              if (v?.type === "number") {
                let x = Number(y);
                R[T] = isNaN(x) ? y : x
              } else if (v?.type === "boolean") R[T] = y.toLowerCase() === "true" || y === "1";
              else R[T] = y
            }
            G(R)
          } else X(N), J(Y + 1), F("")
        }
        return
      }
      if (w.backspace || w.delete) {
        F(V.slice(0, -1));
        return
      }
      if (q && !w.ctrl && !w.meta) F(V + q)
    }), !D || !K) return null;
  let C = D.sensitive === !0,
    E = D.required === !0,
    U = C ? "*".repeat(V.length) : V;
  return AG.default.createElement(S, {
    flexDirection: "column"
  }, AG.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round"
  }, AG.default.createElement($, {
    bold: !0
  }, "Configure ", Q), AG.default.createElement(S, {
    marginLeft: 1
  }, AG.default.createElement($, {
    dimColor: !0
  }, "Plugin: ", A)), AG.default.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, AG.default.createElement($, {
    bold: !0
  }, D.title || K, E && AG.default.createElement($, {
    color: "error"
  }, " *")), D.description && AG.default.createElement($, {
    dimColor: !0
  }, D.description), AG.default.createElement(S, {
    marginTop: 1
  }, AG.default.createElement($, null, H1.pointerSmall, " "), AG.default.createElement($, null, U), AG.default.createElement($, null, "█"))), AG.default.createElement(S, {
    marginTop: 1
  }, AG.default.createElement($, {
    dimColor: !0
  }, "Field ", Y + 1, " of ", I.length)), Y < I.length - 1 && AG.default.createElement(S, null, AG.default.createElement($, {
    dimColor: !0
  }, "Tab: Next field · Enter: Save and continue")), Y === I.length - 1 && AG.default.createElement(S, null, AG.default.createElement($, {
    dimColor: !0
  }, "Enter: Save configuration"))), AG.default.createElement(S, {
    marginLeft: 3
  }, AG.default.createElement($, {
    dimColor: !0
  }, H.pending ? AG.default.createElement(AG.default.Fragment, null, "Press ", H.keyName, " again to exit") : AG.default.createElement(AG.default.Fragment, null, "Esc to cancel"))))
}
// @from(Start 14333975, End 14333977)
AG
// @from(Start 14333983, End 14334044)
QC9 = L(() => {
  hA();
  Q4();
  V9();
  AG = BA(VA(), 1)
})
// @from(Start 14334111, End 14334577)
async function BC9(A) {
  try {
    return (await oQA.readdir(A, {
      withFileTypes: !0
    })).filter((B) => B.isFile() && B.name.endsWith(".md")).map((B) => {
      return RVA.basename(B.name, ".md")
    })
  } catch (Q) {
    let B = Q instanceof Error ? Q.message : String(Q);
    return g(`Failed to read plugin components from ${A}: ${B}`, {
      level: "error"
    }), AA(Q instanceof Error ? Q : Error(`Failed to read plugin components: ${B}`)), []
  }
}
// @from(Start 14334578, End 14335166)
async function ux3(A) {
  try {
    let Q = await oQA.readdir(A, {
        withFileTypes: !0
      }),
      B = [];
    for (let G of Q)
      if (G.isDirectory() || G.isSymbolicLink()) {
        let Z = RVA.join(A, G.name, "SKILL.md");
        try {
          await oQA.access(Z), B.push(G.name)
        } catch {}
      } return B
  } catch (Q) {
    let B = Q instanceof Error ? Q.message : String(Q);
    return g(`Failed to read skill directories from ${A}: ${B}`, {
      level: "error"
    }), AA(Q instanceof Error ? Q : Error(`Failed to read skill directories: ${B}`)), []
  }
}
// @from(Start 14335168, End 14339002)
function mx3({
  plugin: A,
  marketplace: Q
}) {
  let [B, G] = tJ.useState(null), [Z, I] = tJ.useState(!0), [Y, J] = tJ.useState(null);
  if (tJ.useEffect(() => {
      async function X() {
        try {
          let F = (await _D(Q)).plugins.find((K) => K.name === A.name);
          if (F) {
            let K = [];
            if (A.commandsPath) K.push(A.commandsPath);
            if (A.commandsPaths) K.push(...A.commandsPaths);
            let D = [];
            for (let N of K)
              if (typeof N === "string") {
                let R = await BC9(N);
                D.push(...R)
              } let H = [];
            if (A.agentsPath) H.push(A.agentsPath);
            if (A.agentsPaths) H.push(...A.agentsPaths);
            let C = [];
            for (let N of H)
              if (typeof N === "string") {
                let R = await BC9(N);
                C.push(...R)
              } let E = [];
            if (A.skillsPath) E.push(A.skillsPath);
            if (A.skillsPaths) E.push(...A.skillsPaths);
            let U = [];
            for (let N of E)
              if (typeof N === "string") {
                let R = await ux3(N);
                U.push(...R)
              } let q = [];
            if (A.hooksConfig) q.push(Object.keys(A.hooksConfig));
            if (F.hooks) q.push(F.hooks);
            let w = [];
            if (A.mcpServers) w.push(Object.keys(A.mcpServers));
            if (F.mcpServers) w.push(F.mcpServers);
            G({
              commands: D.length > 0 ? D : null,
              agents: C.length > 0 ? C : null,
              skills: U.length > 0 ? U : null,
              hooks: q.length > 0 ? q : null,
              mcpServers: w.length > 0 ? w : null
            })
          } else J(`Plugin ${A.name} not found in marketplace`)
        } catch (V) {
          J(V instanceof Error ? V.message : "Failed to load components")
        } finally {
          I(!1)
        }
      }
      X()
    }, [A.name, A.commandsPath, A.commandsPaths, A.agentsPath, A.agentsPaths, A.skillsPath, A.skillsPaths, A.hooksConfig, A.mcpServers, Q]), Z) return null;
  if (Y) return Q0.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, Q0.createElement($, {
    bold: !0
  }, "Components:"), Q0.createElement($, {
    dimColor: !0
  }, "Error: ", Y));
  if (!B) return null;
  if (!(B.commands || B.agents || B.skills || B.hooks || B.mcpServers)) return null;
  return Q0.createElement(S, {
    flexDirection: "column",
    marginBottom: 1
  }, Q0.createElement($, {
    bold: !0
  }, "Installed components:"), B.commands ? Q0.createElement($, {
    dimColor: !0
  }, "• Commands:", " ", typeof B.commands === "string" ? B.commands : Array.isArray(B.commands) ? B.commands.join(", ") : Object.keys(B.commands).join(", ")) : null, B.agents ? Q0.createElement($, {
    dimColor: !0
  }, "• Agents:", " ", typeof B.agents === "string" ? B.agents : Array.isArray(B.agents) ? B.agents.join(", ") : Object.keys(B.agents).join(", ")) : null, B.skills ? Q0.createElement($, {
    dimColor: !0
  }, "• Skills:", " ", typeof B.skills === "string" ? B.skills : Array.isArray(B.skills) ? B.skills.join(", ") : Object.keys(B.skills).join(", ")) : null, B.hooks ? Q0.createElement($, {
    dimColor: !0
  }, "• Hooks:", " ", typeof B.hooks === "string" ? B.hooks : Array.isArray(B.hooks) ? B.hooks.map(String).join(", ") : typeof B.hooks === "object" && B.hooks !== null ? Object.keys(B.hooks).join(", ") : String(B.hooks)) : null, B.mcpServers ? Q0.createElement($, {
    dimColor: !0
  }, "• MCP Servers:", " ", typeof B.mcpServers === "string" ? B.mcpServers : Array.isArray(B.mcpServers) ? B.mcpServers.map(String).join(", ") : typeof B.mcpServers === "object" && B.mcpServers !== null ? Object.keys(B.mcpServers).join(", ") : String(B.mcpServers)) : null)
}
// @from(Start 14339003, End 14339243)
async function GK0(A, Q) {
  let G = (await _D(Q))?.plugins.find((Z) => Z.name === A);
  if (G && typeof G.source === "string") return `Local plugins cannot be updated remotely. To update, modify the source at: ${G.source}`;
  return null
}
// @from(Start 14339245, End 14362332)
function GC9({
  setViewState: A,
  setResult: Q,
  onManageComplete: B,
  targetPlugin: G,
  action: Z
}) {
  let [I, Y] = tJ.useState("marketplace-list"), [J, W] = tJ.useState(null), [X, V] = tJ.useState(null), [F, K] = tJ.useState([]), [D, H] = tJ.useState([]), [C, E] = tJ.useState(!0), [U, q] = tJ.useState(0), [w, N] = tJ.useState(0), [R, T] = tJ.useState(!1), [y, v] = tJ.useState(null), [x, p] = tJ.useState(null), [u, e] = tJ.useState(!1), [l, k] = tJ.useState(!1);
  tJ.useEffect(() => {
    if (!X) {
      k(!1);
      return
    }
    async function KA() {
      let yA = X.plugin.manifest.mcpServers,
        oA = !1;
      if (yA) oA = typeof yA === "string" && rM(yA) || Array.isArray(yA) && yA.some((X1) => typeof X1 === "string" && rM(X1));
      if (!oA) try {
        let X1 = RVA.join(X.plugin.path, ".."),
          WA = RVA.join(X1, ".claude-plugin", "marketplace.json"),
          EA = await oQA.readFile(WA, "utf-8"),
          DA = JSON.parse(EA).plugins?.find(($A) => $A.name === X.plugin.name);
        if (DA?.mcpServers) {
          let $A = DA.mcpServers;
          oA = typeof $A === "string" && rM($A) || Array.isArray($A) && $A.some((TA) => typeof TA === "string" && rM(TA))
        }
      } catch (X1) {
        g(`Failed to read raw marketplace.json: ${X1}`)
      }
      k(oA)
    }
    KA()
  }, [X]), tJ.useEffect(() => {
    async function KA() {
      E(!0);
      try {
        let {
          enabled: yA,
          disabled: oA
        } = await l7(), X1 = [...yA, ...oA], WA = l0(), EA = {};
        for (let DA of X1) {
          let $A = DA.source.split("@")[1] || "local";
          if (!EA[$A]) EA[$A] = [];
          EA[$A].push(DA)
        }
        let MA = [];
        for (let [DA, $A] of Object.entries(EA)) {
          let TA = $A.filter((iA) => {
              let J1 = `${iA.name}@${DA}`;
              return WA?.enabledPlugins?.[J1] !== !1
            }).length,
            rA = $A.length - TA;
          MA.push({
            name: DA,
            installedPlugins: $A,
            enabledCount: TA,
            disabledCount: rA
          })
        }
        MA.sort((DA, $A) => DA.name.localeCompare($A.name)), K(MA), q(0)
      } finally {
        E(!1)
      }
    }
    KA()
  }, []), tJ.useEffect(() => {
    if (J && I === "plugin-list") {
      let KA = F.find((yA) => yA.name === J);
      if (KA) {
        let yA = KA.installedPlugins.map((oA) => {
          return {
            plugin: oA,
            marketplace: KA.name,
            pendingEnable: void 0,
            pendingUpdate: !1
          }
        });
        H(yA), q(0)
      }
    }
  }, [J, I, F]);
  let m = () => {
      return D.some((KA) => KA.pendingEnable !== void 0 || KA.pendingUpdate)
    },
    o = () => {
      let KA = D.filter((X1) => X1.pendingUpdate).length,
        yA = D.filter((X1) => X1.pendingEnable === !0).length,
        oA = D.filter((X1) => X1.pendingEnable === !1).length;
      return {
        updateCount: KA,
        enableCount: yA,
        disableCount: oA
      }
    },
    IA = async () => {
      T(!0), v(null);
      try {
        let yA = {
            ...OB("userSettings")?.enabledPlugins
          },
          oA = 0,
          X1 = 0,
          WA = 0;
        for (let DA of D) {
          let $A = `${DA.plugin.name}@${DA.marketplace}`;
          if (DA.pendingUpdate) {
            let rA = (await _D(DA.marketplace))?.plugins.find((iA) => iA.name === DA.plugin.name);
            if (rA && typeof rA.source !== "string") await Bj($A, rA), oA++
          }
          if (DA.pendingEnable !== void 0)
            if (DA.pendingEnable) {
              if (!gg($A)) {
                let rA = (await _D(DA.marketplace))?.plugins.find((iA) => iA.name === DA.plugin.name);
                if (rA && typeof rA.source !== "string") await Bj($A, rA)
              }
              yA[$A] = !0, X1++
            } else yA[$A] = !1, WA++
        }
        cB("userSettings", {
          enabledPlugins: yA
        }), AF();
        let EA = [];
        if (oA > 0) EA.push(`Updated ${oA} plugin${oA!==1?"s":""}`);
        if (X1 > 0) EA.push(`Enabled ${X1} plugin${X1!==1?"s":""}`);
        if (WA > 0) EA.push(`Disabled ${WA} plugin${WA!==1?"s":""}`);
        let MA = `✓ ${EA.join(", ")}. Restart Claude Code to apply changes.`;
        if (Q(MA), B) await B();
        A({
          type: "menu"
        })
      } catch (KA) {
        T(!1);
        let yA = KA instanceof Error ? KA.message : String(KA);
        v(`Failed to apply changes: ${yA}`), AA(KA instanceof Error ? KA : Error(`Failed to apply plugin changes: ${String(KA)}`))
      }
    }, FA = async (KA) => {
      let oA = {
          ...OB("userSettings")?.enabledPlugins
        },
        MA = yQA().plugins[KA]?.find(($A) => $A.scope === "user")?.installPath;
      if (O39(KA), pI1(KA, "user"), MA && MA.includes("/cache/")) try {
        lI1(MA)
      } catch ($A) {
        AA($A instanceof Error ? $A : Error(String($A)))
      } else if (MA) g(`Skipping cache deletion for plugin ${KA} at ${MA} (not a cache path)`);
      oA[KA] = void 0;
      let {
        error: DA
      } = cB("userSettings", {
        enabledPlugins: oA
      });
      if (DA) throw DA;
      AF()
    }, zA = async (KA) => {
      if (!X) return;
      T(!0), v(null);
      try {
        let yA = `${X.plugin.name}@${X.marketplace}`,
          X1 = {
            ...OB("userSettings")?.enabledPlugins
          };
        switch (KA) {
          case "enable": {
            if (!gg(yA)) {
              let DA = (await _D(X.marketplace))?.plugins.find(($A) => $A.name === X.plugin.name);
              if (DA && typeof DA.source !== "string") await Bj(yA, DA)
            }
            X1[yA] = !0;
            break
          }
          case "disable":
            X1[yA] = !1;
            break;
          case "uninstall": {
            await FA(yA);
            break
          }
          case "update": {
            let DA = (await _D(X.marketplace))?.plugins.find(($A) => $A.name === X.plugin.name);
            if (DA && typeof DA.source !== "string") await Bj(yA, DA);
            break
          }
        }
        if (KA !== "uninstall") {
          let {
            error: MA
          } = cB("userSettings", {
            enabledPlugins: X1
          });
          if (MA) throw MA;
          AF()
        }
        let EA = `✓ ${KA==="enable"?"Enabled":KA==="disable"?"Disabled":KA==="update"?"Updated":"Uninstalled"} ${X.plugin.name}. Restart Claude Code to apply changes.`;
        if (Q(EA), B) await B();
        A({
          type: "menu"
        })
      } catch (yA) {
        T(!1);
        let oA = yA instanceof Error ? yA.message : String(yA);
        v(`Failed to ${KA}: ${oA}`), AA(yA instanceof Error ? yA : Error(`Failed to ${KA} plugin: ${String(yA)}`))
      }
    }, NA = async (KA) => {
      T(!0), v(null);
      try {
        let yA = `${KA.plugin.name}@${KA.marketplace}`;
        await FA(yA);
        let {
          enabled: oA,
          disabled: X1
        } = await l7(), WA = [...oA, ...X1];
        if (F.find((MA) => MA.name === J)) {
          let MA = WA.filter((iA) => {
              return (iA.source.split("@")[1] || "local") === J
            }),
            DA = MA.map((iA) => ({
              plugin: iA,
              marketplace: J,
              pendingEnable: void 0,
              pendingUpdate: !1
            }));
          H(DA);
          let $A = l0(),
            TA = MA.filter((iA) => {
              let J1 = `${iA.name}@${J}`;
              return $A?.enabledPlugins?.[J1] !== !1
            }).length,
            rA = MA.length - TA;
          if (K((iA) => iA.map((J1) => J1.name === J ? {
              ...J1,
              installedPlugins: MA,
              enabledCount: TA,
              disabledCount: rA
            } : J1)), U >= DA.length) q(Math.max(0, DA.length - 1))
        }
        Q(`✓ Uninstalled ${KA.plugin.name}. Restart Claude Code to apply changes.`)
      } catch (yA) {
        let oA = yA instanceof Error ? yA.message : String(yA);
        v(`Failed to uninstall: ${oA}`), AA(yA instanceof Error ? yA : Error(`Failed to uninstall plugin: ${String(yA)}`))
      } finally {
        T(!1)
      }
    };
  if (f1((KA, yA) => {
      if (yA.escape) {
        if (I === "plugin-list") Y("marketplace-list"), W(null), H([]);
        else if (I === "plugin-details") Y("plugin-list"), V(null), v(null);
        else if (I === "configuring") Y("plugin-details"), p(null);
        else A({
          type: "menu"
        });
        return
      }
      if (I === "marketplace-list") {
        if ((yA.upArrow || KA === "k") && U > 0) q(U - 1);
        else if ((yA.downArrow || KA === "j") && U < F.length - 1) q(U + 1);
        else if (yA.return) {
          let oA = F[U];
          if (oA) W(oA.name), Y("plugin-list")
        }
      } else if (I === "plugin-list") {
        let oA = m(),
          X1 = D.length + (oA ? 1 : 0);
        if ((yA.upArrow || KA === "k") && U > 0) q(U - 1);
        else if ((yA.downArrow || KA === "j") && U < X1 - 1) q(U + 1);
        else if (KA === " " && U < D.length) {
          let WA = [...D],
            EA = WA[U];
          if (EA) {
            let MA = l0(),
              DA = `${EA.plugin.name}@${EA.marketplace}`,
              $A = MA?.enabledPlugins?.[DA] !== !1;
            if (EA.pendingEnable === void 0) EA.pendingEnable = !$A;
            else EA.pendingEnable = void 0;
            H(WA)
          }
        } else if (KA === "u" && U < D.length) {
          let WA = [...D],
            EA = WA[U];
          if (EA)(async () => {
            try {
              let DA = await GK0(EA.plugin.name, EA.marketplace);
              if (DA) {
                v(DA);
                return
              }
              EA.pendingUpdate = !EA.pendingUpdate, H(WA)
            } catch (DA) {
              v(DA instanceof Error ? DA.message : "Failed to check plugin update availability")
            }
          })()
        } else if (yA.delete || yA.backspace) {
          if (U < D.length && !R) {
            let WA = D[U];
            if (WA) NA(WA)
          }
        } else if (yA.return) {
          if (U === D.length && oA) IA();
          else if (U < D.length) {
            let WA = D[U];
            if (WA) V(WA), Y("plugin-details"), N(0), v(null)
          }
        }
      } else if (I === "plugin-details" && X) {
        let oA = l0(),
          X1 = `${X.plugin.name}@${X.marketplace}`,
          WA = oA?.enabledPlugins?.[X1] !== !1,
          EA = [];
        if (EA.push({
            label: WA ? "Disable plugin" : "Enable plugin",
            action: () => void zA(WA ? "disable" : "enable")
          }), EA.push({
            label: X.pendingUpdate ? "Unmark for update" : "Mark for update",
            action: async () => {
              try {
                let MA = await GK0(X.plugin.name, X.marketplace);
                if (MA) {
                  v(MA);
                  return
                }
                let DA = [...D],
                  $A = DA.findIndex((TA) => TA.plugin.name === X.plugin.name && TA.marketplace === X.marketplace);
                if ($A !== -1) DA[$A].pendingUpdate = !X.pendingUpdate, H(DA), V({
                  ...X,
                  pendingUpdate: !X.pendingUpdate
                })
              } catch (MA) {
                v(MA instanceof Error ? MA.message : "Failed to check plugin update availability")
              }
            }
          }), l) EA.push({
          label: "Configure",
          action: async () => {
            e(!0);
            try {
              let MA = X.plugin.manifest.mcpServers,
                DA = null;
              if (typeof MA === "string" && rM(MA)) DA = MA;
              else if (Array.isArray(MA)) {
                for (let rA of MA)
                  if (typeof rA === "string" && rM(rA)) {
                    DA = rA;
                    break
                  }
              }
              if (!DA) {
                v("No MCPB file found in plugin"), e(!1);
                return
              }
              let $A = `${X.plugin.name}@${X.marketplace}`,
                TA = await BMA(DA, X.plugin.path, $A, void 0, void 0, !0);
              if ("status" in TA && TA.status === "needs-config") p(TA), Y("configuring");
              else v("Failed to load MCPB for configuration")
            } catch (MA) {
              let DA = MA instanceof Error ? MA.message : String(MA);
              v(`Failed to load configuration: ${DA}`)
            } finally {
              e(!1)
            }
          }
        });
        if (EA.push({
            label: "Update now",
            action: () => void zA("update")
          }), EA.push({
            label: "Uninstall",
            action: () => void zA("uninstall")
          }), X.plugin.manifest.homepage) EA.push({
          label: "Open homepage",
          action: () => void cZ(X.plugin.manifest.homepage)
        });
        if (X.plugin.manifest.repository) EA.push({
          label: "View on GitHub",
          action: () => void cZ(X.plugin.manifest.repository)
        });
        if (EA.push({
            label: "Back to plugin list",
            action: () => {
              Y("plugin-list"), V(null), v(null)
            }
          }), (yA.upArrow || KA === "k") && w > 0) N(w - 1);
        else if ((yA.downArrow || KA === "j") && w < EA.length - 1) N(w + 1);
        else if (yA.return && EA[w]) EA[w].action()
      }
    }), C) return Q0.createElement(S, {
    flexDirection: "column"
  }, Q0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, Q0.createElement($, null, "Loading installed plugins…")));
  if (F.length === 0) return Q0.createElement(S, {
    flexDirection: "column"
  }, Q0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, Q0.createElement(S, {
    marginBottom: 1
  }, Q0.createElement($, {
    bold: !0
  }, "Manage plugins")), Q0.createElement($, null, "No plugins installed.")), Q0.createElement(S, {
    marginTop: 1,
    paddingLeft: 1
  }, Q0.createElement($, {
    dimColor: !0
  }, "Esc to go back")));
  if (I === "marketplace-list") return Q0.createElement(S, {
    flexDirection: "column"
  }, Q0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, Q0.createElement($, {
    bold: !0
  }, "Manage plugins"), Q0.createElement(S, {
    marginBottom: 1
  }, Q0.createElement($, {
    dimColor: !0
  }, "Select a marketplace to manage plugins:")), F.map((KA, yA) => {
    let oA = yA === U,
      X1 = KA.installedPlugins.length,
      WA = KA.enabledCount ?? X1,
      EA = KA.disabledCount ?? 0,
      MA = yA === F.length - 1;
    return Q0.createElement(S, {
      key: KA.name,
      flexDirection: "column",
      marginBottom: MA ? 0 : 1
    }, Q0.createElement(S, null, Q0.createElement($, {
      color: oA ? "suggestion" : void 0
    }, oA ? H1.pointer : " ", " ", KA.name)), Q0.createElement(S, {
      marginLeft: 2
    }, Q0.createElement($, {
      dimColor: !0
    }, X1, " plugin", X1 !== 1 ? "s" : "", " installed", WA > 0 && ` · ${WA} enabled`, EA > 0 && ` · ${EA} disabled`)))
  })), Q0.createElement(S, {
    paddingLeft: 1
  }, Q0.createElement($, {
    dimColor: !0,
    italic: !0
  }, H1.arrowUp, H1.arrowDown, " enter to select · esc to go back")));
  if (I === "configuring" && x && X) {
    let oA = function() {
        p(null), Y("plugin-details")
      },
      KA = `${X.plugin.name}@${X.marketplace}`;
    async function yA(X1) {
      if (!x || !X) return;
      try {
        let WA = X.plugin.manifest.mcpServers,
          EA = null;
        if (typeof WA === "string" && rM(WA)) EA = WA;
        else if (Array.isArray(WA)) {
          for (let MA of WA)
            if (typeof MA === "string" && rM(MA)) {
              EA = MA;
              break
            }
        }
        if (!EA) {
          v("No MCPB file found"), Y("plugin-details");
          return
        }
        await BMA(EA, X.plugin.path, KA, void 0, X1), v(null), p(null), Y("plugin-details"), Q("Configuration saved. Restart Claude Code for changes to take effect.")
      } catch (WA) {
        let EA = WA instanceof Error ? WA.message : String(WA);
        v(`Failed to save configuration: ${EA}`), Y("plugin-details")
      }
    }
    return Q0.createElement(AC9, {
      pluginName: X.plugin.name,
      serverName: x.manifest.name,
      configSchema: x.configSchema,
      onSave: yA,
      onCancel: oA
    })
  }
  if (I === "plugin-details" && X) {
    let KA = l0(),
      yA = `${X.plugin.name}@${X.marketplace}`,
      oA = KA?.enabledPlugins?.[yA] !== !1,
      X1 = [];
    if (X1.push({
        label: oA ? "Disable plugin" : "Enable plugin",
        action: () => void zA(oA ? "disable" : "enable")
      }), X1.push({
        label: X.pendingUpdate ? "Unmark for update" : "Mark for update",
        action: async () => {
          try {
            let WA = await GK0(X.plugin.name, X.marketplace);
            if (WA) {
              v(WA);
              return
            }
            let EA = [...D],
              MA = EA.findIndex((DA) => DA.plugin.name === X.plugin.name && DA.marketplace === X.marketplace);
            if (MA !== -1) EA[MA].pendingUpdate = !X.pendingUpdate, H(EA), V({
              ...X,
              pendingUpdate: !X.pendingUpdate
            })
          } catch (WA) {
            v(WA instanceof Error ? WA.message : "Failed to check plugin update availability")
          }
        }
      }), l) X1.push({
      label: "Configure",
      action: () => {}
    });
    if (X1.push({
        label: "Update now",
        action: () => void zA("update")
      }), X1.push({
        label: "Uninstall",
        action: () => void zA("uninstall")
      }), X.plugin.manifest.homepage) X1.push({
      label: "Open homepage",
      action: () => void cZ(X.plugin.manifest.homepage)
    });
    if (X.plugin.manifest.repository) X1.push({
      label: "View on GitHub",
      action: () => void cZ(X.plugin.manifest.repository)
    });
    return X1.push({
      label: "Back to plugin list",
      action: () => {
        Y("plugin-list"), V(null), v(null)
      }
    }), Q0.createElement(S, {
      flexDirection: "column"
    }, Q0.createElement(S, {
      flexDirection: "column",
      paddingX: 1,
      borderStyle: "round"
    }, Q0.createElement(S, {
      marginBottom: 1
    }, Q0.createElement($, {
      bold: !0
    }, X.plugin.name, " @ ", X.marketplace)), X.plugin.manifest.version && Q0.createElement(S, {
      marginBottom: 1
    }, Q0.createElement($, {
      dimColor: !0
    }, "Version: "), Q0.createElement($, null, X.plugin.manifest.version)), X.plugin.manifest.description && Q0.createElement(S, {
      marginBottom: 1
    }, Q0.createElement($, null, X.plugin.manifest.description)), X.plugin.manifest.author && Q0.createElement(S, {
      marginBottom: 1
    }, Q0.createElement($, {
      dimColor: !0
    }, "Author: "), Q0.createElement($, null, X.plugin.manifest.author.name)), Q0.createElement(S, {
      marginBottom: 1
    }, Q0.createElement($, {
      dimColor: !0
    }, "Status: "), Q0.createElement($, {
      color: oA ? "success" : "warning"
    }, oA ? "Enabled" : "Disabled"), X.pendingUpdate && Q0.createElement($, {
      color: "suggestion"
    }, " · Marked for update")), Q0.createElement(mx3, {
      plugin: X.plugin,
      marketplace: X.marketplace
    }), Q0.createElement(S, {
      marginTop: 1,
      flexDirection: "column"
    }, X1.map((WA, EA) => {
      let MA = EA === w;
      return Q0.createElement(S, {
        key: EA
      }, MA && Q0.createElement($, null, H1.pointer, " "), !MA && Q0.createElement($, null, "  "), Q0.createElement($, {
        bold: MA,
        color: WA.label.includes("Uninstall") ? "error" : WA.label.includes("Update") ? "suggestion" : void 0
      }, WA.label))
    })), R && Q0.createElement(S, {
      marginTop: 1
    }, Q0.createElement($, null, "Processing…")), y && Q0.createElement(S, {
      marginTop: 1
    }, Q0.createElement($, {
      color: "error"
    }, y))), Q0.createElement(S, {
      marginTop: 1,
      paddingLeft: 1
    }, Q0.createElement($, {
      dimColor: !0
    }, Q0.createElement($, {
      bold: !0
    }, "Navigate:"), " ", H1.arrowUp, H1.arrowDown, " • ", Q0.createElement($, {
      bold: !0
    }, "Select:"), " Enter", " • ", Q0.createElement($, {
      bold: !0
    }, "Back:"), " Esc")))
  }
  let OA = m(),
    {
      updateCount: mA,
      enableCount: wA,
      disableCount: qA
    } = o();
  return Q0.createElement(S, {
    flexDirection: "column"
  }, Q0.createElement(S, {
    flexDirection: "column",
    paddingX: 1,
    borderStyle: "round"
  }, Q0.createElement(S, {
    marginBottom: 1
  }, Q0.createElement($, {
    bold: !0
  }, J, " ", H1.pointerSmall, " Manage plugins")), D.map((KA, yA) => {
    let oA = l0(),
      X1 = `${KA.plugin.name}@${KA.marketplace}`,
      WA = oA?.enabledPlugins?.[X1] !== !1,
      EA = KA.pendingEnable !== void 0 ? KA.pendingEnable : WA,
      MA = yA === U,
      DA = KA.pendingEnable !== void 0 || KA.pendingUpdate,
      $A = yA === D.length - 1;
    return Q0.createElement(S, {
      key: X1,
      flexDirection: "column",
      marginBottom: $A ? 0 : 1
    }, Q0.createElement(S, null, Q0.createElement($, {
      color: MA ? "suggestion" : void 0
    }, MA ? H1.pointer : " ", " "), Q0.createElement($, {
      color: KA.pendingEnable !== void 0 ? "warning" : EA ? "success" : void 0
    }, EA ? H1.radioOn : H1.radioOff, " "), Q0.createElement($, {
      bold: MA,
      color: KA.pendingUpdate ? "suggestion" : DA ? "warning" : void 0
    }, KA.plugin.name)), Q0.createElement(S, {
      marginLeft: 4
    }, Q0.createElement($, {
      dimColor: !0
    }, KA.plugin.manifest.description ? KA.plugin.manifest.description.length > 50 ? KA.plugin.manifest.description.substring(0, 47) + "..." : KA.plugin.manifest.description : "No description", KA.plugin.manifest.version && ` · v${KA.plugin.manifest.version}`), KA.pendingUpdate && Q0.createElement($, {
      color: "suggestion"
    }, " · Marked for update")))
  }), OA && Q0.createElement(S, {
    marginTop: 1
  }, U === D.length && Q0.createElement($, null, H1.pointer, " "), U !== D.length && Q0.createElement($, null, "  "), Q0.createElement($, {
    bold: U === D.length,
    color: "success"
  }, "Apply changes"), Q0.createElement($, {
    dimColor: !0
  }, " ", mA > 0 && `(update ${mA})`, wA > 0 && ` (enable ${wA})`, qA > 0 && ` (disable ${qA})`))), OA && Q0.createElement(S, {
    marginTop: 1,
    paddingLeft: 1
  }, Q0.createElement($, {
    color: "warning"
  }, "Restart to apply changes")), Q0.createElement(S, {
    paddingLeft: 3,
    flexDirection: "column"
  }, Q0.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Space to toggle enabled · 'u' to mark update · Delete to uninstall"), Q0.createElement($, {
    dimColor: !0,
    italic: !0
  }, "Enter for details · Esc to back")))
}
// @from(Start 14362337, End 14362339)
Q0
// @from(Start 14362341, End 14362343)
tJ
// @from(Start 14362349, End 14362520)
ZC9 = L(() => {
  hA();
  hA();
  V9();
  fV();
  oH();
  MB();
  sQA();
  gM();
  g1();
  V0();
  za();
  ejA();
  QC9();
  M10();
  Q0 = BA(VA(), 1), tJ = BA(VA(), 1)
})
// @from(Start 14362523, End 14364468)
function dx3(A) {
  switch (A.type) {
    case "path-not-found":
      return `${A.component} path not found: ${A.path}`;
    case "git-auth-failed":
      return `Git ${A.authType.toUpperCase()} authentication failed for ${A.gitUrl}`;
    case "git-timeout":
      return `Git ${A.operation} timed out for ${A.gitUrl}`;
    case "network-error":
      return `Network error accessing ${A.url}${A.details?`: ${A.details}`:""}`;
    case "manifest-parse-error":
      return `Failed to parse manifest at ${A.manifestPath}: ${A.parseError}`;
    case "manifest-validation-error":
      return `Invalid manifest at ${A.manifestPath}: ${A.validationErrors.join(", ")}`;
    case "plugin-not-found":
      return `Plugin '${A.pluginId}' not found in marketplace '${A.marketplace}'`;
    case "marketplace-not-found":
      return `Marketplace '${A.marketplace}' not found`;
    case "marketplace-load-failed":
      return `Failed to load marketplace '${A.marketplace}': ${A.reason}`;
    case "repository-scan-failed":
      return `Failed to scan repository at ${A.repositoryPath}: ${A.reason}`;
    case "mcp-config-invalid":
      return `Invalid MCP server config for '${A.serverName}': ${A.validationError}`;
    case "hook-load-failed":
      return `Failed to load hooks from ${A.hookPath}: ${A.reason}`;
    case "component-load-failed":
      return `Failed to load ${A.component} from ${A.path}: ${A.reason}`;
    case "mcpb-download-failed":
      return `Failed to download MCPB from ${A.url}: ${A.reason}`;
    case "mcpb-extract-failed":
      return `Failed to extract MCPB ${A.mcpbPath}: ${A.reason}`;
    case "mcpb-invalid-manifest":
      return `MCPB manifest invalid at ${A.mcpbPath}: ${A.validationError}`;
    case "marketplace-blocked-by-policy":
      return `Marketplace '${A.marketplace}' is not allowed by enterprise policy`;
    case "generic-error":
      return A.error;
    default:
      return "Unknown error"
  }
}
// @from(Start 14364470, End 14366401)
function IC9(A) {
  switch (A.type) {
    case "path-not-found":
      return "→ Check that the path in your manifest or marketplace config is correct";
    case "git-auth-failed":
      return A.authType === "ssh" ? "→ Configure SSH keys or use HTTPS URL instead" : "→ Configure credentials or use SSH URL instead";
    case "git-timeout":
    case "network-error":
      return "→ Check your internet connection and try again";
    case "manifest-parse-error":
      return "→ Check manifest file syntax in the plugin directory";
    case "manifest-validation-error":
      return "→ Check manifest file follows the required schema";
    case "plugin-not-found":
      return `→ Plugin may not exist in marketplace '${A.marketplace}'`;
    case "marketplace-not-found":
      return A.availableMarketplaces.length > 0 ? `→ Available marketplaces: ${A.availableMarketplaces.join(", ")}` : "→ Add the marketplace first using /plugin marketplace add";
    case "mcp-config-invalid":
      return "→ Check MCP server configuration in .mcp.json or manifest";
    case "hook-load-failed":
      return "→ Check hooks.json file syntax and structure";
    case "component-load-failed":
      return `→ Check ${A.component} directory structure and file permissions`;
    case "mcpb-download-failed":
      return "→ Check your internet connection and URL accessibility";
    case "mcpb-extract-failed":
      return "→ Verify the MCPB file is valid and not corrupted";
    case "mcpb-invalid-manifest":
      return "→ Contact the plugin author about the invalid manifest";
    case "marketplace-blocked-by-policy":
      return A.allowedSources.length > 0 ? `→ Allowed sources: ${A.allowedSources.join(", ")}` : "→ Contact your administrator to configure allowed marketplace sources";
    case "repository-scan-failed":
    case "marketplace-load-failed":
    case "generic-error":
      return null;
    default:
      return null
  }
}
// @from(Start 14366403, End 14372220)
function JC9({
  onComplete: A
}) {
  let [Q, B] = OQ(), {
    installationStatus: G,
    errors: Z
  } = Q.plugins;
  EQ();
  let I = YC9.useCallback(() => {
    B((F) => ({
      ...F,
      plugins: {
        ...F.plugins,
        installationStatus: {
          marketplaces: F.plugins.installationStatus.marketplaces.map((K) => K.status === "failed" ? {
            ...K,
            status: "pending"
          } : K),
          plugins: F.plugins.installationStatus.plugins.map((K) => K.status === "failed" ? {
            ...K,
            status: "pending"
          } : K)
        }
      }
    })), BY1(B)
  }, [B]);
  f1((F, K) => {
    if (K.escape) A();
    else if (F === "r" || F === "R") I()
  });
  let Y = {
      pending: G.marketplaces.filter((F) => F.status === "pending").length,
      installing: G.marketplaces.filter((F) => F.status === "installing").length,
      installed: G.marketplaces.filter((F) => F.status === "installed").length,
      failed: G.marketplaces.filter((F) => F.status === "failed").length
    },
    J = {
      pending: G.plugins.filter((F) => F.status === "pending").length,
      installing: G.plugins.filter((F) => F.status === "installing").length,
      installed: G.plugins.filter((F) => F.status === "installed").length,
      failed: G.plugins.filter((F) => F.status === "failed").length
    },
    W = Y.installing > 0 || J.installing > 0 || Y.pending > 0 || J.pending > 0,
    X = Z.length > 0,
    V = G.marketplaces.length > 0 || G.plugins.length > 0;
  return E0.createElement(S, {
    flexDirection: "column"
  }, E0.createElement(S, {
    marginBottom: 1
  }, E0.createElement($, {
    bold: !0
  }, X && !V ? "Plugin Loading Errors" : "Plugin Status")), G.marketplaces.length > 0 && E0.createElement(E0.Fragment, null, E0.createElement(S, {
    marginBottom: 1
  }, E0.createElement($, {
    dimColor: !0
  }, "Marketplaces:")), G.marketplaces.map((F) => E0.createElement(S, {
    key: F.name,
    marginLeft: 2
  }, F.status === "installing" && E0.createElement(E0.Fragment, null, E0.createElement(g4, null), E0.createElement(S, {
    marginLeft: 1
  }, E0.createElement($, null, F.name), E0.createElement($, {
    dimColor: !0
  }, " · Installing…"))), F.status === "pending" && E0.createElement($, null, E0.createElement($, {
    dimColor: !0
  }, H1.circle || "○", " "), F.name, E0.createElement($, {
    dimColor: !0
  }, " · Pending")), F.status === "installed" && E0.createElement($, null, E0.createElement($, {
    color: "success"
  }, H1.tick || "✓", " "), F.name, E0.createElement($, {
    dimColor: !0
  }, " · Installed")), F.status === "failed" && E0.createElement(S, {
    flexDirection: "column"
  }, E0.createElement($, null, E0.createElement($, {
    color: "error"
  }, H1.cross || "✗", " "), F.name, E0.createElement($, {
    color: "error"
  }, " · Failed")), F.error && E0.createElement(S, {
    marginLeft: 3
  }, E0.createElement($, {
    color: "error",
    dimColor: !0
  }, F.error)))))), G.plugins.length > 0 && E0.createElement(E0.Fragment, null, E0.createElement(S, {
    marginTop: 1,
    marginBottom: 1
  }, E0.createElement($, {
    dimColor: !0
  }, "Plugins:")), G.plugins.map((F) => E0.createElement(S, {
    key: F.id,
    marginLeft: 2
  }, F.status === "installing" && E0.createElement(E0.Fragment, null, E0.createElement(g4, null), E0.createElement(S, {
    marginLeft: 1
  }, E0.createElement($, null, F.name), E0.createElement($, {
    dimColor: !0
  }, " · Installing…"))), F.status === "pending" && E0.createElement($, null, E0.createElement($, {
    dimColor: !0
  }, H1.circle || "○", " "), F.name, E0.createElement($, {
    dimColor: !0
  }, " · Pending")), F.status === "installed" && E0.createElement($, null, E0.createElement($, {
    color: "success"
  }, H1.tick || "✓", " "), F.name, E0.createElement($, {
    dimColor: !0
  }, " · Installed")), F.status === "failed" && E0.createElement(S, {
    flexDirection: "column"
  }, E0.createElement($, null, E0.createElement($, {
    color: "error"
  }, H1.cross || "✗", " "), F.name, E0.createElement($, {
    color: "error"
  }, " · Failed")), F.error && E0.createElement(S, {
    marginLeft: 3
  }, E0.createElement($, {
    color: "error",
    dimColor: !0
  }, F.error)))))), G.marketplaces.length === 0 && G.plugins.length === 0 && Z.length === 0 && E0.createElement(S, {
    marginTop: 1
  }, E0.createElement($, {
    dimColor: !0
  }, "No pending installations or errors")), Z.length > 0 && E0.createElement(E0.Fragment, null, E0.createElement(S, {
    marginTop: 1,
    marginBottom: 1
  }, E0.createElement($, {
    dimColor: !0
  }, "Plugin Loading Errors:")), Z.map((F, K) => {
    let D = "plugin" in F ? F.plugin : void 0;
    return E0.createElement(S, {
      key: K,
      marginLeft: 2,
      flexDirection: "column"
    }, E0.createElement($, null, E0.createElement($, {
      color: "error"
    }, H1.cross || "✗", " "), D ? E0.createElement(E0.Fragment, null, "Plugin ", E0.createElement($, {
      bold: !0
    }, D), " from", " ", E0.createElement($, {
      dimColor: !0
    }, F.source)) : E0.createElement($, {
      dimColor: !0
    }, F.source)), E0.createElement(S, {
      marginLeft: 3
    }, E0.createElement($, {
      color: "error",
      dimColor: !0
    }, dx3(F))), IC9(F) && E0.createElement(S, {
      marginLeft: 3,
      marginTop: 1
    }, E0.createElement($, {
      dimColor: !0,
      italic: !0
    }, IC9(F))))
  })), E0.createElement(S, {
    marginTop: 2
  }, E0.createElement($, {
    dimColor: !0
  }, W ? "Installing…" : E0.createElement(E0.Fragment, null, "Press", " ", Y.failed > 0 || J.failed > 0 ? E0.createElement(E0.Fragment, null, E0.createElement($, {
    bold: !0
  }, "r"), " to retry failed installations ·", " ") : null, E0.createElement($, {
    bold: !0
  }, "Esc"), " to return"))))
}
// @from(Start 14372225, End 14372227)
E0
// @from(Start 14372229, End 14372232)
YC9
// @from(Start 14372238, End 14372343)
WC9 = L(() => {
  hA();
  Q4();
  z9();
  iX0();
  DY();
  V9();
  E0 = BA(VA(), 1), YC9 = BA(VA(), 1)
})
// @from(Start 14372400, End 14372645)
function cx3(A) {
  let Q = lO.basename(A),
    B = lO.basename(lO.dirname(A));
  if (Q === "plugin.json") return "plugin";
  if (Q === "marketplace.json") return "marketplace";
  if (B === ".claude-plugin") return "plugin";
  return "unknown"
}
// @from(Start 14372647, End 14372783)
function XC9(A) {
  return A.errors.map((Q) => ({
    path: Q.path.join(".") || "root",
    message: Q.message,
    code: Q.code
  }))
}
// @from(Start 14372785, End 14372941)
function MSA(A, Q, B) {
  if (A.includes("..")) B.push({
    path: Q,
    message: `Path contains ".." which could be a path traversal attempt: ${A}`
  })
}
// @from(Start 14372943, End 14375284)
function ZK0(A) {
  let Q = [],
    B = [],
    G = lO.resolve(A);
  if (!Xz.existsSync(G)) return {
    success: !1,
    errors: [{
      path: "file",
      message: `File not found: ${G}`
    }],
    warnings: [],
    filePath: G,
    fileType: "plugin"
  };
  if (!Xz.statSync(G).isFile()) return {
    success: !1,
    errors: [{
      path: "file",
      message: `Path is not a file: ${G}`
    }],
    warnings: [],
    filePath: G,
    fileType: "plugin"
  };
  let I;
  try {
    I = Xz.readFileSync(G, {
      encoding: "utf-8"
    })
  } catch (W) {
    return {
      success: !1,
      errors: [{
        path: "file",
        message: `Failed to read file: ${W instanceof Error?W.message:String(W)}`
      }],
      warnings: [],
      filePath: G,
      fileType: "plugin"
    }
  }
  let Y;
  try {
    Y = JSON.parse(I)
  } catch (W) {
    return {
      success: !1,
      errors: [{
        path: "json",
        message: `Invalid JSON syntax: ${W instanceof Error?W.message:String(W)}`
      }],
      warnings: [],
      filePath: G,
      fileType: "plugin"
    }
  }
  if (Y && typeof Y === "object") {
    let W = Y;
    if (W.commands)(Array.isArray(W.commands) ? W.commands : [W.commands]).forEach((V, F) => {
      if (typeof V === "string") MSA(V, `commands[${F}]`, Q)
    });
    if (W.agents)(Array.isArray(W.agents) ? W.agents : [W.agents]).forEach((V, F) => {
      if (typeof V === "string") MSA(V, `agents[${F}]`, Q)
    });
    if (W.skills)(Array.isArray(W.skills) ? W.skills : [W.skills]).forEach((V, F) => {
      if (typeof V === "string") MSA(V, `skills[${F}]`, Q)
    })
  }
  let J = nAA.safeParse(Y);
  if (!J.success) Q.push(...XC9(J.error));
  if (J.success) {
    let W = J.data;
    if (!W.version) B.push({
      path: "version",
      message: 'No version specified. Consider adding a version following semver (e.g., "1.0.0")'
    });
    if (!W.description) B.push({
      path: "description",
      message: "No description provided. Adding a description helps users understand what your plugin does"
    });
    if (!W.author) B.push({
      path: "author",
      message: "No author information provided. Consider adding author details for plugin attribution"
    })
  }
  return {
    success: Q.length === 0,
    errors: Q,
    warnings: B,
    filePath: G,
    fileType: "plugin"
  }
}
// @from(Start 14375286, End 14377864)
function IK0(A) {
  let Q = [],
    B = [],
    G = lO.resolve(A);
  if (!Xz.existsSync(G)) return {
    success: !1,
    errors: [{
      path: "file",
      message: `File not found: ${G}`
    }],
    warnings: [],
    filePath: G,
    fileType: "marketplace"
  };
  if (!Xz.statSync(G).isFile()) return {
    success: !1,
    errors: [{
      path: "file",
      message: `Path is not a file: ${G}`
    }],
    warnings: [],
    filePath: G,
    fileType: "marketplace"
  };
  let I;
  try {
    I = Xz.readFileSync(G, {
      encoding: "utf-8"
    })
  } catch (W) {
    return {
      success: !1,
      errors: [{
        path: "file",
        message: `Failed to read file: ${W instanceof Error?W.message:String(W)}`
      }],
      warnings: [],
      filePath: G,
      fileType: "marketplace"
    }
  }
  let Y;
  try {
    Y = JSON.parse(I)
  } catch (W) {
    return {
      success: !1,
      errors: [{
        path: "json",
        message: `Invalid JSON syntax: ${W instanceof Error?W.message:String(W)}`
      }],
      warnings: [],
      filePath: G,
      fileType: "marketplace"
    }
  }
  if (Y && typeof Y === "object") {
    let W = Y;
    if (Array.isArray(W.plugins)) W.plugins.forEach((X, V) => {
      if (X && typeof X === "object" && "source" in X) {
        let F = X.source;
        if (typeof F === "string") MSA(F, `plugins[${V}].source`, Q);
        if (F && typeof F === "object" && "path" in F && typeof F.path === "string") MSA(F.path, `plugins[${V}].source.path`, Q)
      }
    })
  }
  let J = TIA.safeParse(Y);
  if (!J.success) Q.push(...XC9(J.error));
  if (J.success) {
    let W = J.data;
    if (!W.plugins || W.plugins.length === 0) B.push({
      path: "plugins",
      message: "Marketplace has no plugins defined"
    });
    if (W.plugins) W.plugins.forEach((X, V) => {
      if (typeof X.source === "object" && X.source.source === "npm") B.push({
        path: `plugins[${V}].source`,
        message: `Plugin "${X.name}" uses npm source which is not yet fully implemented`
      });
      if (W.plugins.filter((K) => K.name === X.name).length > 1) Q.push({
        path: `plugins[${V}].name`,
        message: `Duplicate plugin name "${X.name}" found in marketplace`
      })
    });
    if (!W.metadata?.description) B.push({
      path: "metadata.description",
      message: "No marketplace description provided. Adding a description helps users understand what this marketplace offers"
    })
  }
  return {
    success: Q.length === 0,
    errors: Q,
    warnings: B,
    filePath: G,
    fileType: "marketplace"
  }
}
// @from(Start 14377866, End 14379042)
function qJ1(A) {
  let Q = lO.resolve(A);
  if (Xz.existsSync(Q) && Xz.statSync(Q).isDirectory()) {
    let G = lO.join(Q, ".claude-plugin", "marketplace.json"),
      Z = lO.join(Q, ".claude-plugin", "plugin.json");
    if (Xz.existsSync(G)) return IK0(G);
    else if (Xz.existsSync(Z)) return ZK0(Z);
    else return {
      success: !1,
      errors: [{
        path: "directory",
        message: "No manifest found in directory. Expected .claude-plugin/marketplace.json or .claude-plugin/plugin.json"
      }],
      warnings: [],
      filePath: Q,
      fileType: "plugin"
    }
  }
  switch (cx3(A)) {
    case "plugin":
      return ZK0(A);
    case "marketplace":
      return IK0(A);
    case "unknown": {
      if (!Xz.existsSync(Q)) return {
        success: !1,
        errors: [{
          path: "file",
          message: `File not found: ${Q}`
        }],
        warnings: [],
        filePath: Q,
        fileType: "plugin"
      };
      try {
        let G = Xz.readFileSync(Q, {
            encoding: "utf-8"
          }),
          Z = JSON.parse(G);
        if (Array.isArray(Z.plugins)) return IK0(A)
      } catch {}
      return ZK0(A)
    }
  }
}
// @from(Start 14379047, End 14379073)
YK0 = L(() => {
  aAA()
})
// @from(Start 14379076, End 14380849)
function FC9({
  onComplete: A,
  path: Q
}) {
  return VC9.useEffect(() => {
    async function B() {
      if (!Q) {
        A(`Usage: /plugin validate <path>

Validate a plugin or marketplace manifest file or directory.

Examples:
  /plugin validate .claude-plugin/plugin.json
  /plugin validate /path/to/plugin-directory
  /plugin validate .

When given a directory, automatically validates .claude-plugin/marketplace.json
or .claude-plugin/plugin.json (prefers marketplace if both exist).

Or from the command line:
  claude plugin validate <path>`);
        return
      }
      try {
        let G = qJ1(Q),
          Z = "";
        if (Z += `Validating ${G.fileType} manifest: ${G.filePath}

`, G.errors.length > 0) Z += `${H1.cross} Found ${G.errors.length} error${G.errors.length===1?"":"s"}:

`, G.errors.forEach((I) => {
          Z += `  ${H1.pointer} ${I.path}: ${I.message}
`
        }), Z += `
`;
        if (G.warnings.length > 0) Z += `${H1.warning} Found ${G.warnings.length} warning${G.warnings.length===1?"":"s"}:

`, G.warnings.forEach((I) => {
          Z += `  ${H1.pointer} ${I.path}: ${I.message}
`
        }), Z += `
`;
        if (G.success) {
          if (G.warnings.length > 0) Z += `${H1.tick} Validation passed with warnings
`;
          else Z += `${H1.tick} Validation passed
`;
          process.exitCode = 0
        } else Z += `${H1.cross} Validation failed
`, process.exitCode = 1;
        A(Z)
      } catch (G) {
        process.exitCode = 2, AA(G instanceof Error ? G : Error(String(G))), A(`${H1.cross} Unexpected error during validation: ${G instanceof Error?G.message:String(G)}`)
      }
    }
    B()
  }, [A, Q]), OSA.createElement(S, {
    flexDirection: "column"
  }, OSA.createElement($, null, "Running validation..."))
}
// @from(Start 14380854, End 14380857)
OSA
// @from(Start 14380859, End 14380862)
VC9
// @from(Start 14380868, End 14380958)
KC9 = L(() => {
  hA();
  YK0();
  V9();
  g1();
  OSA = BA(VA(), 1), VC9 = BA(VA(), 1)
})
// @from(Start 14380961, End 14382913)
function DC9(A) {
  if (!A) return {
    type: "menu"
  };
  let Q = A.trim().split(/\s+/);
  switch (Q[0]?.toLowerCase()) {
    case "help":
    case "--help":
    case "-h":
      return {
        type: "help"
      };
    case "install":
    case "i": {
      let G = Q[1];
      if (!G) return {
        type: "install"
      };
      if (G.includes("@")) {
        let [I, Y] = G.split("@");
        return {
          type: "install",
          plugin: I,
          marketplace: Y
        }
      }
      if (G.startsWith("http://") || G.startsWith("https://") || G.startsWith("file://") || G.includes("/") || G.includes("\\")) return {
        type: "install",
        marketplace: G
      };
      return {
        type: "install",
        plugin: G
      }
    }
    case "manage":
      return {
        type: "manage"
      };
    case "uninstall":
      return {
        type: "uninstall", plugin: Q[1]
      };
    case "enable":
      return {
        type: "enable", plugin: Q[1]
      };
    case "disable":
      return {
        type: "disable", plugin: Q[1]
      };
    case "validate":
      return {
        type: "validate", path: Q.slice(1).join(" ").trim() || void 0
      };
    case "marketplace":
    case "market": {
      let G = Q[1]?.toLowerCase(),
        Z = Q.slice(2).join(" ");
      switch (G) {
        case "add":
          return {
            type: "marketplace", action: "add", target: Z
          };
        case "remove":
        case "rm":
          return {
            type: "marketplace", action: "remove", target: Z
          };
        case "update":
          return {
            type: "marketplace", action: "update", target: Z
          };
        case "list":
          return {
            type: "marketplace", action: "list"
          };
        default:
          return {
            type: "marketplace"
          }
      }
    }
    default:
      return {
        type: "menu"
      }
  }
}
// @from(Start 14382915, End 14383406)
function px3({
  onComplete: A
}) {
  return iO.useEffect(() => {
    async function Q() {
      try {
        let B = await pZ(),
          G = Object.keys(B);
        if (G.length === 0) A("No marketplaces configured");
        else A(`Configured marketplaces:
${G.map((Z)=>`  • ${Z}`).join(`
`)}`)
      } catch (B) {
        A(`Error loading marketplaces: ${B instanceof Error?B.message:String(B)}`)
      }
    }
    Q()
  }, [A]), GB.createElement($, null, "Loading marketplaces...")
}
// @from(Start 14383408, End 14384919)
function lx3(A) {
  switch (A.type) {
    case "help":
      return {
        type: "help"
      };
    case "validate":
      return {
        type: "validate", path: A.path
      };
    case "install":
      if (A.marketplace || A.plugin) return {
        type: "browse-marketplace",
        targetMarketplace: A.marketplace,
        targetPlugin: A.plugin
      };
      return {
        type: "browse-marketplace"
      };
    case "manage":
      return {
        type: "manage-plugins"
      };
    case "uninstall":
      return {
        type: "manage-plugins", targetPlugin: A.plugin, action: "uninstall"
      };
    case "enable":
      return {
        type: "manage-plugins", targetPlugin: A.plugin, action: "enable"
      };
    case "disable":
      return {
        type: "manage-plugins", targetPlugin: A.plugin, action: "disable"
      };
    case "marketplace":
      if (A.action === "list") return {
        type: "marketplace-list"
      };
      if (A.action === "add") return {
        type: "add-marketplace",
        initialValue: A.target
      };
      if (A.action === "remove") return {
        type: "manage-marketplaces",
        targetMarketplace: A.target,
        action: "remove"
      };
      if (A.action === "update") return {
        type: "manage-marketplaces",
        targetMarketplace: A.target,
        action: "update"
      };
      return {
        type: "marketplace-menu"
      };
    case "menu":
    default:
      return {
        type: "menu"
      }
  }
}
// @from(Start 14384921, End 14389923)
function HC9({
  onComplete: A,
  args: Q
}) {
  let B = DC9(Q),
    [G, Z] = iO.useState(lx3(B)),
    [I, Y] = iO.useState(G.type === "add-marketplace" ? G.initialValue || "" : ""),
    [J, W] = iO.useState(0),
    [X, V] = iO.useState(null),
    [F, K] = iO.useState(null),
    [, D] = OQ(),
    H = EQ(),
    C = B.type === "marketplace" && B.action === "add" && B.target !== void 0,
    E = iO.useCallback(async () => {
      let {
        enabled: U,
        disabled: q,
        errors: w
      } = await l7(), [N, R] = await Promise.all([PQA(), _0A()]);
      D((T) => ({
        ...T,
        plugins: {
          ...T.plugins,
          enabled: U,
          disabled: q,
          commands: N,
          agents: R,
          errors: w
        }
      }))
    }, [D]);
  if (f1((U, q) => {
      if (q.escape) {
        if (G.type === "add-marketplace") Z({
          type: "menu"
        }), Y(""), V(null);
        else if (G.type === "manage-marketplaces") Z({
          type: "menu"
        }), V(null), K(null);
        else if (G.type === "browse-marketplace") Z({
          type: "menu"
        });
        return
      }
    }), iO.useEffect(() => {
      if (F) A(F)
    }, [F, A]), iO.useEffect(() => {
      if (G.type === "help") A()
    }, [G.type, A]), G.type === "help") return GB.createElement(S, {
    flexDirection: "column"
  }, GB.createElement($, {
    bold: !0
  }, "Plugin Command Usage:"), GB.createElement($, null, " "), GB.createElement($, {
    dimColor: !0
  }, "Installation:"), GB.createElement($, null, " /plugin install - Browse and install plugins"), GB.createElement($, null, " ", "/plugin install <marketplace> - Install from specific marketplace"), GB.createElement($, null, " /plugin install <plugin> - Install specific plugin"), GB.createElement($, null, " ", "/plugin install <plugin>@<market> - Install plugin from marketplace"), GB.createElement($, null, " "), GB.createElement($, {
    dimColor: !0
  }, "Management:"), GB.createElement($, null, " /plugin manage - Manage installed plugins"), GB.createElement($, null, " /plugin enable <plugin> - Enable a plugin"), GB.createElement($, null, " /plugin disable <plugin> - Disable a plugin"), GB.createElement($, null, " /plugin uninstall <plugin> - Uninstall a plugin"), GB.createElement($, null, " "), GB.createElement($, {
    dimColor: !0
  }, "Marketplaces:"), GB.createElement($, null, " /plugin marketplace - Marketplace management menu"), GB.createElement($, null, " /plugin marketplace add - Add a marketplace"), GB.createElement($, null, " ", "/plugin marketplace add <path/url> - Add marketplace directly"), GB.createElement($, null, " /plugin marketplace update - Update marketplaces"), GB.createElement($, null, " ", "/plugin marketplace update <name> - Update specific marketplace"), GB.createElement($, null, " /plugin marketplace remove - Remove a marketplace"), GB.createElement($, null, " ", "/plugin marketplace remove <name> - Remove specific marketplace"), GB.createElement($, null, " /plugin marketplace list - List all marketplaces"), GB.createElement($, null, " "), GB.createElement($, {
    dimColor: !0
  }, "Validation:"), GB.createElement($, null, " ", "/plugin validate <path> - Validate a manifest file or directory"), GB.createElement($, null, " "), GB.createElement($, {
    dimColor: !0
  }, "Other:"), GB.createElement($, null, " /plugin - Main plugin menu"), GB.createElement($, null, " /plugin help - Show this help"), GB.createElement($, null, " /plugins - Alias for /plugin"));
  if (G.type === "validate") return GB.createElement(FC9, {
    onComplete: A,
    path: G.path
  });
  if (G.type === "marketplace-menu") return Z({
    type: "menu"
  }), null;
  if (G.type === "marketplace-list") return GB.createElement(px3, {
    onComplete: A
  });
  if (G.type === "add-marketplace") return GB.createElement(aH9, {
    inputValue: I,
    setInputValue: Y,
    cursorOffset: J,
    setCursorOffset: W,
    error: X,
    setError: V,
    result: F,
    setResult: K,
    setViewState: Z,
    onAddComplete: E,
    cliMode: C
  });
  if (G.type === "manage-marketplaces") return GB.createElement(rH9, {
    setViewState: Z,
    error: X,
    setError: V,
    setResult: K,
    exitState: H,
    onManageComplete: E,
    targetMarketplace: G.targetMarketplace,
    action: G.action
  });
  if (G.type === "browse-marketplace") return GB.createElement(tH9, {
    error: X,
    setError: V,
    result: F,
    setResult: K,
    setViewState: Z,
    onInstallComplete: E,
    targetMarketplace: G.targetMarketplace,
    targetPlugin: G.targetPlugin
  });
  if (G.type === "manage-plugins") return GB.createElement(GC9, {
    setViewState: Z,
    setResult: K,
    onManageComplete: E,
    targetPlugin: G.targetPlugin,
    action: G.action
  });
  if (G.type === "installation-status") return GB.createElement(JC9, {
    onComplete: () => Z({
      type: "menu"
    })
  });
  return GB.createElement(cH9, {
    setViewState: Z,
    onComplete: A,
    exitState: H
  })
}
// @from(Start 14389928, End 14389930)
GB
// @from(Start 14389932, End 14389934)
iO
// @from(Start 14389940, End 14390116)
CC9 = L(() => {
  hA();
  Q4();
  fV();
  z9();
  TjA();
  ETA();
  pH9();
  sH9();
  oH9();
  eH9();
  ZC9();
  WC9();
  KC9();
  oH();
  GB = BA(VA(), 1), iO = BA(VA(), 1)
})
// @from(Start 14390122, End 14390125)
JK0
// @from(Start 14390127, End 14390130)
ix3
// @from(Start 14390132, End 14390135)
EC9
// @from(Start 14390141, End 14390556)
zC9 = L(() => {
  CC9();
  JK0 = BA(VA(), 1), ix3 = {
    type: "local-jsx",
    name: "plugin",
    aliases: ["plugins", "marketplace"],
    description: "Manage Claude Code plugins",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q, B) {
      return JK0.createElement(HC9, {
        onComplete: A,
        args: B
      })
    },
    userFacingName() {
      return "plugin"
    }
  }, EC9 = ix3
})
// @from(Start 14390562, End 14390565)
nx3
// @from(Start 14390567, End 14390570)
UC9
// @from(Start 14390576, End 14391028)
$C9 = L(() => {
  nx3 = {
    description: "Restore the code and/or conversation to a previous point",
    name: "rewind",
    aliases: ["checkpoint"],
    userFacingName: () => "rewind",
    argumentHint: "",
    isEnabled: () => !0,
    type: "local",
    isHidden: !1,
    supportsNonInteractive: !1,
    async call(A, Q) {
      if (Q.openMessageSelector) Q.openMessageSelector();
      return {
        type: "skip"
      }
    }
  }, UC9 = nx3
})
// @from(Start 14391034, End 14391059)
wC9 = L(() => {
  R9()
})
// @from(Start 14391065, End 14391068)
ax3
// @from(Start 14391070, End 14391073)
sx3
// @from(Start 14391079, End 14391161)
qC9 = L(() => {
  hA();
  J5();
  lbA();
  ax3 = BA(VA(), 1), sx3 = BA(VA(), 1)
})
// @from(Start 14391167, End 14391170)
rx3
// @from(Start 14391176, End 14391303)
NC9 = L(() => {
  NX();
  hA();
  Pi();
  gB();
  V0();
  AE();
  g1();
  J5();
  nV0();
  BK();
  _0();
  rx3 = BA(VA(), 1)
})
// @from(Start 14391309, End 14391323)
LC9 = () => {}
// @from(Start 14391326, End 14393882)
function MC9() {
  if (!nQ.isSandboxingEnabled()) return y4.createElement(S, {
    flexDirection: "column",
    paddingY: 1
  }, y4.createElement($, {
    color: "subtle"
  }, "Sandbox is not enabled"));
  let Q = nQ.getFsReadConfig(),
    B = nQ.getFsWriteConfig(),
    G = nQ.getNetworkRestrictionConfig(),
    Z = nQ.getAllowUnixSockets(),
    I = nQ.getExcludedCommands(),
    Y = nQ.getLinuxGlobPatternWarnings();
  return y4.createElement(S, {
    flexDirection: "column",
    paddingY: 1
  }, y4.createElement(S, {
    flexDirection: "column"
  }, y4.createElement($, {
    bold: !0,
    color: "permission"
  }, "Excluded Commands:"), y4.createElement($, {
    dimColor: !0
  }, I.length > 0 ? I.join(", ") : "None")), Q.denyOnly.length > 0 && y4.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, y4.createElement($, {
    bold: !0,
    color: "permission"
  }, "Filesystem Read Restrictions:"), y4.createElement($, {
    dimColor: !0
  }, "Denied: ", Q.denyOnly.join(", "))), B.allowOnly.length > 0 && y4.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, y4.createElement($, {
    bold: !0,
    color: "permission"
  }, "Filesystem Write Restrictions:"), y4.createElement($, {
    dimColor: !0
  }, "Allowed: ", B.allowOnly.join(", ")), B.denyWithinAllow.length > 0 && y4.createElement($, {
    dimColor: !0
  }, "Denied within allowed: ", B.denyWithinAllow.join(", "))), (G.allowedHosts && G.allowedHosts.length > 0 || G.deniedHosts && G.deniedHosts.length > 0) && y4.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, y4.createElement($, {
    bold: !0,
    color: "permission"
  }, "Network Restrictions:"), G.allowedHosts && G.allowedHosts.length > 0 && y4.createElement($, {
    dimColor: !0
  }, "Allowed: ", G.allowedHosts.join(", ")), G.deniedHosts && G.deniedHosts.length > 0 && y4.createElement($, {
    dimColor: !0
  }, "Denied: ", G.deniedHosts.join(", "))), Z && Z.length > 0 && y4.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, y4.createElement($, {
    bold: !0,
    color: "permission"
  }, "Allowed Unix Sockets:"), y4.createElement($, {
    dimColor: !0
  }, Z.join(", "))), Y.length > 0 && y4.createElement(S, {
    marginTop: 1,
    flexDirection: "column"
  }, y4.createElement($, {
    bold: !0,
    color: "warning"
  }, "⚠ Warning: Glob patterns not fully supported on Linux"), y4.createElement($, {
    dimColor: !0
  }, "The following patterns will be ignored:", " ", Y.slice(0, 3).join(", "), Y.length > 3 && ` (${Y.length-3} more)`)))
}
// @from(Start 14393887, End 14393889)
y4
// @from(Start 14393895, End 14393948)
OC9 = L(() => {
  hA();
  $J();
  y4 = BA(VA(), 1)
})
// @from(Start 14393951, End 14396724)
function RC9({
  onComplete: A
}) {
  let [Q] = qB(), B = nQ.isSandboxingEnabled(), G = nQ.areUnsandboxedCommandsAllowed(), Z = nQ.areSandboxSettingsLockedByPolicy(), I = G ? "open" : "closed", Y = ZB("success", Q)("(current)"), J = [{
    label: I === "open" ? `Allow unsandboxed fallback ${Y}` : "Allow unsandboxed fallback",
    value: "open"
  }, {
    label: I === "closed" ? `Strict sandbox mode ${Y}` : "Strict sandbox mode",
    value: "closed"
  }];
  async function W(X) {
    let V = X;
    await nQ.setSandboxSettings({
      allowUnsandboxedCommands: V === "open"
    }), A(V === "open" ? "✓ Unsandboxed fallback allowed - commands can run outside sandbox when necessary" : "✓ Strict sandbox mode - all commands must run in sandbox or be excluded via the `excludedCommands` option")
  }
  if (f1((X, V) => {
      if (V.escape) A()
    }), !B) return RK.default.createElement(S, {
    flexDirection: "column",
    paddingY: 1
  }, RK.default.createElement($, {
    color: "subtle"
  }, "Sandbox is not enabled. Enable sandbox to configure override settings."));
  if (Z) return RK.default.createElement(S, {
    flexDirection: "column",
    paddingY: 1
  }, RK.default.createElement($, {
    color: "subtle"
  }, "Override settings are managed by a higher-priority configuration and cannot be changed locally."), RK.default.createElement(S, {
    marginTop: 1
  }, RK.default.createElement($, {
    dimColor: !0
  }, "Current setting:", " ", I === "closed" ? "Strict sandbox mode" : "Allow unsandboxed fallback")));
  return RK.default.createElement(S, {
    flexDirection: "column",
    paddingY: 1
  }, RK.default.createElement(S, {
    marginBottom: 1
  }, RK.default.createElement($, {
    bold: !0
  }, "Configure Overrides:")), RK.default.createElement(M0, {
    options: J,
    onChange: W,
    onCancel: () => A()
  }), RK.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1
  }, RK.default.createElement($, {
    dimColor: !0
  }, RK.default.createElement($, {
    bold: !0,
    dimColor: !0
  }, "Allow unsandboxed fallback:"), " ", "When a command fails due to sandbox restrictions, Claude can retry with dangerouslyDisableSandbox to run outside the sandbox (falling back to default permissions)."), RK.default.createElement($, {
    dimColor: !0
  }, RK.default.createElement($, {
    bold: !0,
    dimColor: !0
  }, "Strict sandbox mode:"), " ", "All bash commands invoked by the model must run in the sandbox unless they are explicitly listed in excludedCommands."), RK.default.createElement($, {
    dimColor: !0
  }, "Learn more:", " ", RK.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/sandboxing#configure-sandboxing"
  }, "code.claude.com/docs/en/sandboxing#configure-sandboxing"))))
}
// @from(Start 14396729, End 14396731)
RK
// @from(Start 14396737, End 14396806)
TC9 = L(() => {
  hA();
  S5();
  $J();
  hA();
  RK = BA(VA(), 1)
})
// @from(Start 14396809, End 14399818)
function PC9({
  onComplete: A
}) {
  let [Q] = qB(), B = nQ.isSandboxingEnabled(), G = nQ.isAutoAllowBashIfSandboxedEnabled(), I = (() => {
    if (!B) return "disabled";
    if (G) return "auto-allow";
    return "regular"
  })(), Y = ZB("success", Q)("(current)"), J = [{
    label: I === "auto-allow" ? `Sandbox BashTool, with auto-allow in accept edits mode ${Y}` : "Sandbox BashTool, with auto-allow in accept edits mode",
    value: "auto-allow"
  }, {
    label: I === "regular" ? `Sandbox BashTool, with regular permissions ${Y}` : "Sandbox BashTool, with regular permissions",
    value: "regular"
  }, {
    label: I === "disabled" ? `No Sandbox ${Y}` : "No Sandbox",
    value: "disabled"
  }];
  async function W(X) {
    switch (X) {
      case "auto-allow":
        await nQ.setSandboxSettings({
          enabled: !0,
          autoAllowBashIfSandboxed: !0
        }), A("✓ Sandbox enabled with auto-allow for bash commands when in accept-edits mode");
        break;
      case "regular":
        await nQ.setSandboxSettings({
          enabled: !0,
          autoAllowBashIfSandboxed: !1
        }), A("✓ Sandbox enabled with regular bash permissions");
        break;
      case "disabled":
        await nQ.setSandboxSettings({
          enabled: !1,
          autoAllowBashIfSandboxed: !1
        }), A("○ Sandbox disabled");
        break
    }
  }
  return f1((X, V) => {
    if (V.escape) A()
  }), QF.default.createElement(S, {
    flexDirection: "column"
  }, QF.default.createElement(D3, {
    dividerColor: "permission",
    dividerDimColor: !0
  }), QF.default.createElement(S, {
    marginX: 1
  }, QF.default.createElement(Na, {
    title: "Sandbox:",
    color: "permission",
    defaultTab: "Mode"
  }, QF.default.createElement(eD, {
    key: "mode",
    title: "Mode"
  }, QF.default.createElement(S, {
    flexDirection: "column",
    paddingY: 1
  }, QF.default.createElement(S, {
    marginBottom: 1
  }, QF.default.createElement($, {
    bold: !0
  }, "Configure Mode:")), QF.default.createElement(M0, {
    options: J,
    onChange: W,
    onCancel: () => A()
  }), QF.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1,
    gap: 1
  }, QF.default.createElement($, {
    dimColor: !0
  }, QF.default.createElement($, {
    bold: !0,
    dimColor: !0
  }, "Auto-allow mode:"), " ", "When in accept-edits mode, commands will try to run in the sandbox automatically, and attempts to run outside of the sandbox fallback to regular permissions. Explicit ask/deny rules are always respected."), QF.default.createElement($, {
    dimColor: !0
  }, "Learn more:", " ", QF.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/sandboxing"
  }, "code.claude.com/docs/en/sandboxing"))))), QF.default.createElement(eD, {
    key: "overrides",
    title: "Overrides"
  }, QF.default.createElement(RC9, {
    onComplete: A
  })), QF.default.createElement(eD, {
    key: "config",
    title: "Config"
  }, QF.default.createElement(MC9, null)))))
}
// @from(Start 14399823, End 14399825)
QF
// @from(Start 14399831, End 14399935)
jC9 = L(() => {
  hA();
  S5();
  $J();
  FSA();
  BK();
  hA();
  OC9();
  TC9();
  QF = BA(VA(), 1)
})
// @from(Start 14399966, End 14401467)
async function ox3(A, Q, B) {
  let Z = l0().theme || "light";
  if (!nQ.isSupportedPlatform(dQ())) {
    let Y = ZB("error", Z)("Error: Sandboxing is currently only supported on macOS and Linux");
    return A(Y), null
  }
  if (!nQ.checkDependencies()) {
    let J = dQ() === "linux" ? "Error: Sandbox requires socat and bubblewrap. Please install these packages." : "Error: Sandbox dependencies are not available on this system.",
      W = ZB("error", Z)(J);
    return A(W), null
  }
  if (nQ.areSandboxSettingsLockedByPolicy()) {
    let Y = ZB("error", Z)("Error: Sandbox settings are overridden by a higher-priority configuration and cannot be changed locally.");
    return A(Y), null
  }
  let I = B?.trim() || "";
  if (!I) return _C9.default.createElement(PC9, {
    onComplete: A
  });
  if (I) {
    let J = I.split(" ")[0];
    if (J === "exclude") {
      let W = I.slice(8).trim();
      if (!W) {
        let D = ZB("error", Z)('Error: Please provide a command pattern to exclude (e.g., /sandbox exclude "npm run test:*")');
        return A(D), null
      }
      let X = W.replace(/^["']|["']$/g, "");
      Ac0(X);
      let V = Gw("localSettings"),
        F = V ? SC9.relative(I2A(), V) : ".claude/settings.local.json",
        K = ZB("success", Z)(`Added "${X}" to excluded commands in ${F}`);
      return A(K), null
    } else {
      let W = ZB("error", Z)(`Error: Unknown subcommand "${J}". Available subcommand: exclude`);
      return A(W), null
    }
  }
  return null
}
// @from(Start 14401472, End 14401475)
_C9
// @from(Start 14401477, End 14401480)
tx3
// @from(Start 14401482, End 14401485)
kC9
// @from(Start 14401491, End 14402296)
yC9 = L(() => {
  $J();
  hA();
  MB();
  $J();
  MB();
  _0();
  jC9();
  Q3();
  _C9 = BA(VA(), 1);
  tx3 = {
    name: "sandbox",
    get description() {
      let A = nQ.isSandboxingEnabled(),
        Q = nQ.isAutoAllowBashIfSandboxedEnabled(),
        B = nQ.areUnsandboxedCommandsAllowed(),
        G = nQ.areSandboxSettingsLockedByPolicy(),
        Z = A ? "✓" : "○",
        I = "sandbox disabled";
      if (A) I = Q ? "sandbox enabled (auto-allow)" : "sandbox enabled", I += B ? ", fallback allowed" : "";
      if (G) I += " (managed)";
      return `${Z} ${I} (⏎ to configure)`
    },
    argumentHint: 'exclude "command pattern"',
    isEnabled: () => !0,
    isHidden: !nQ.isSupportedPlatform(dQ()),
    type: "local-jsx",
    userFacingName: () => "sandbox",
    call: ox3
  }, kC9 = tx3
})
// @from(Start 14402302, End 14402305)
ex3
// @from(Start 14402307, End 14402310)
xC9
// @from(Start 14402316, End 14402898)
vC9 = L(() => {
  gM();
  ex3 = {
    type: "local",
    name: "stickers",
    description: "Order Claude Code stickers",
    isEnabled: () => !0,
    isHidden: !1,
    supportsNonInteractive: !1,
    async call() {
      if (await cZ("https://www.stickermule.com/claudecode")) return {
        type: "text",
        value: "Opening sticker page in browser…"
      };
      else return {
        type: "text",
        value: "Failed to open browser. Visit: https://www.stickermule.com/claudecode"
      }
    },
    userFacingName() {
      return "stickers"
    }
  }, xC9 = ex3
})
// @from(Start 14402975, End 14403031)
function WK0(A) {
  return /^skill\.md$/i.test(NJ1(A))
}
// @from(Start 14403033, End 14403454)
function Qv3(A) {
  let Q = new Map;
  for (let G of A) {
    let Z = RSA(G.filePath),
      I = Q.get(Z) ?? [];
    I.push(G), Q.set(Z, I)
  }
  let B = [];
  for (let [G, Z] of Q) {
    let I = Z.filter((Y) => WK0(Y.filePath));
    if (I.length > 0) {
      let Y = I[0];
      if (I.length > 1) g(`Multiple skill files found in ${G}, using ${NJ1(Y.filePath)}`);
      B.push(Y)
    } else B.push(...Z)
  }
  return B
}
// @from(Start 14403456, End 14403626)
function bC9(A, Q) {
  let B = Q.endsWith("/") ? Q.slice(0, -1) : Q;
  if (A === B) return "";
  let G = A.slice(B.length + 1);
  return G ? G.split(Av3).join(":") : ""
}
// @from(Start 14403628, End 14403748)
function Bv3(A, Q) {
  let B = RSA(A),
    G = RSA(B),
    Z = NJ1(B),
    I = bC9(G, Q);
  return I ? `${I}:${Z}` : Z
}
// @from(Start 14403750, End 14403886)
function Gv3(A, Q) {
  let B = NJ1(A),
    G = RSA(A),
    Z = B.replace(/\.md$/, ""),
    I = bC9(G, Q);
  return I ? `${I}:${Z}` : Z
}
// @from(Start 14403888, End 14403990)
function Zv3(A) {
  return WK0(A.filePath) ? Bv3(A.filePath, A.baseDir) : Gv3(A.filePath, A.baseDir)
}
// @from(Start 14403995, End 14403998)
fC9
// @from(Start 14404004, End 14406652)
hC9 = L(() => {
  l2();
  g1();
  V0();
  OjA();
  _y();
  LV();
  hQ();
  t2();
  fC9 = s1(async () => {
    try {
      let A = await _n("commands");
      return Qv3(A).map(({
        baseDir: G,
        filePath: Z,
        frontmatter: I,
        content: Y,
        source: J
      }) => {
        try {
          let W = I.description ?? Wx(Y, "Custom command"),
            X = UO(I["allowed-tools"]),
            V = I["argument-hint"],
            F = I.when_to_use,
            K = I.version,
            D = Y0(I["disable-model-invocation"] ?? void 0),
            H = I.model === "inherit" ? void 0 : I.model ? UD(I.model) : void 0,
            C = WK0(Z),
            E = C ? RSA(Z) : void 0,
            U = Zv3({
              baseDir: G,
              filePath: Z,
              frontmatter: I,
              content: Y,
              source: J
            }),
            q = `${W} (${Pm(J)})`;
          return {
            type: "prompt",
            name: U,
            description: q,
            hasUserSpecifiedDescription: !!I.description,
            allowedTools: X,
            argumentHint: V,
            whenToUse: F,
            version: K,
            model: H,
            isSkill: C,
            disableModelInvocation: D,
            isEnabled: () => !0,
            isHidden: !1,
            progressMessage: C ? "loading" : "running",
            userFacingName() {
              return U
            },
            source: J,
            async getPromptForCommand(w, N) {
              let R = Y;
              if (C && E) R = `Base directory for this skill: ${E}

${R}`;
              if (w)
                if (R.includes("$ARGUMENTS")) R = R.replaceAll("$ARGUMENTS", w);
                else R = R + `

ARGUMENTS: ${w}`;
              return R = await Fa(R, {
                ...N,
                async getAppState() {
                  let T = await N.getAppState();
                  return {
                    ...T,
                    toolPermissionContext: {
                      ...T.toolPermissionContext,
                      alwaysAllowRules: {
                        ...T.toolPermissionContext.alwaysAllowRules,
                        command: X
                      }
                    }
                  }
                }
              }, `/${U}`), [{
                type: "text",
                text: R
              }]
            }
          }
        } catch (W) {
          return AA(W instanceof Error ? W : Error(String(W))), null
        }
      }).filter((G) => G !== null)
    } catch (A) {
      return AA(A instanceof Error ? A : Error(String(A))), []
    }
  })
})
// @from(Start 14406692, End 14406866)
function Iv3(A, Q) {
  let B = RA();
  try {
    let G = B.statSync(A),
      Z = B.statSync(Q);
    return G.ino === Z.ino && G.dev === Z.dev
  } catch {
    return !1
  }
}
// @from(Start 14406867, End 14409273)
async function XK0(A, Q) {
  let B = RA(),
    G = [];
  try {
    if (!B.existsSync(A)) return [];
    let Z = B.readdirSync(A);
    for (let I of Z) {
      if (!I.isDirectory() && !I.isSymbolicLink()) continue;
      let Y = tg(A, I.name),
        J = tg(Y, "SKILL.md");
      if (B.existsSync(J)) try {
        let W = B.readFileSync(J, {
            encoding: "utf-8"
          }),
          {
            frontmatter: X,
            content: V
          } = NV(W),
          F = I.name,
          K = X.description ?? Wx(V, "Skill"),
          D = UO(X["allowed-tools"]),
          H = X["argument-hint"],
          C = X.when_to_use,
          E = X.version,
          U = X.name,
          q = X["disable-model-invocation"],
          w = q === void 0 ? !1 : Y0(q),
          N = X.model === "inherit" ? void 0 : X.model,
          R = `${K} (${Pm(Q)})`;
        G.push({
          type: "prompt",
          name: F,
          description: R,
          hasUserSpecifiedDescription: !!X.description,
          allowedTools: D,
          argumentHint: H,
          whenToUse: C,
          version: E,
          model: N,
          isSkill: !0,
          disableModelInvocation: w,
          isEnabled: () => !0,
          isHidden: !0,
          progressMessage: "running",
          userFacingName() {
            return U || F
          },
          source: Q,
          async getPromptForCommand(T, y) {
            let v = `Base directory for this skill: ${Y}

${V}`;
            if (T)
              if (v.includes("$ARGUMENTS")) v = v.replaceAll("$ARGUMENTS", T);
              else v = v + `

ARGUMENTS: ${T}`;
            return v = await Fa(v, {
              ...y,
              async getAppState() {
                let x = await y.getAppState();
                return {
                  ...x,
                  toolPermissionContext: {
                    ...x.toolPermissionContext,
                    alwaysAllowRules: {
                      ...x.toolPermissionContext.alwaysAllowRules,
                      command: D
                    }
                  }
                }
              }
            }, `/${F}`), [{
              type: "text",
              text: v
            }]
          }
        })
      } catch (W) {
        AA(W instanceof Error ? W : Error(String(W)))
      }
    }
  } catch (Z) {
    AA(Z instanceof Error ? Z : Error(String(Z)))
  }
  return G
}
// @from(Start 14409275, End 14409316)
function gC9() {
  VK0.cache?.clear?.()
}
// @from(Start 14409321, End 14409324)
VK0
// @from(Start 14409330, End 14410663)
uC9 = L(() => {
  l2();
  g1();
  V0();
  OjA();
  _y();
  LV();
  hQ();
  AQ();
  hQ();
  U2();
  MB();
  LV();
  VK0 = s1(async () => {
    let A = tg(MQ(), "skills"),
      Q = tg(W0(), ".claude", "skills"),
      B = tg(iw(), ".claude", "skills");
    g(`Loading skills from directories: managed=${B}, user=${A}, project=${Q}`);
    let [G, Z, I] = await Promise.all([XK0(B, "policySettings"), EH("userSettings") ? XK0(A, "userSettings") : Promise.resolve([]), EH("projectSettings") ? XK0(Q, "projectSettings") : Promise.resolve([])]), Y = [...G, ...Z, ...I], J = [], W = new Map;
    for (let X of Y) {
      if (X.type !== "prompt") continue;
      let V = X.source === "policySettings" ? tg(iw(), ".claude", "skills", X.name) : X.source === "userSettings" ? tg(MQ(), "skills", X.name) : tg(W0(), ".claude", "skills", X.name),
        F = tg(V, "SKILL.md"),
        K = W.get(X.name);
      if (K && Iv3(K, F)) {
        g(`Skipping duplicate skill '${X.name}' from ${X.source} (same file as earlier source)`);
        continue
      }
      W.set(X.name, F), J.push(X)
    }
    if (J.length < Y.length) g(`Deduplicated ${Y.length-J.length} duplicate skills`);
    return g(`Loaded ${J.length} unique skills (managed: ${G.length}, user: ${Z.length}, project: ${I.length}, duplicates removed: ${Y.length-J.length})`), J
  })
})
// @from(Start 14410704, End 14413753)
function mC9({
  content: A,
  defaultFilename: Q,
  onDone: B
}) {
  let [, G] = NZ.useState(null), [Z, I] = NZ.useState(Q), [Y, J] = NZ.useState(Q.length), [W, X] = NZ.useState(!1), V = EQ();
  return f1((H, C) => {
    if (C.escape)
      if (W) X(!1), G(null);
      else B({
        success: !1,
        message: "Export cancelled"
      })
  }), NZ.default.createElement(S, {
    width: "100%",
    flexDirection: "column"
  }, NZ.default.createElement(S, {
    borderStyle: "round",
    borderColor: "permission",
    flexDirection: "column",
    padding: 1,
    width: "100%"
  }, NZ.default.createElement(S, null, NZ.default.createElement($, {
    color: "permission",
    bold: !0
  }, "Export Conversation")), !W ? NZ.default.createElement(NZ.default.Fragment, null, NZ.default.createElement(S, {
    marginTop: 1
  }, NZ.default.createElement($, {
    dimColor: !0
  }, "Select export method:")), NZ.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, NZ.default.createElement(M0, {
    options: [{
      label: "Copy to clipboard",
      value: "clipboard",
      description: "Copy the conversation to your system clipboard"
    }, {
      label: "Save to file",
      value: "file",
      description: "Save the conversation to a file in the current directory"
    }],
    onChange: async (H) => {
      if (H === "clipboard")
        if (await La(A)) B({
          success: !0,
          message: "Conversation copied to clipboard"
        });
        else B({
          success: !1,
          message: ZJ1()
        });
      else if (H === "file") G("file"), X(!0)
    },
    onCancel: () => B({
      success: !1,
      message: "Export cancelled"
    })
  }))) : NZ.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, NZ.default.createElement($, null, "Enter filename:"), NZ.default.createElement(S, {
    flexDirection: "row",
    gap: 1,
    marginTop: 1
  }, NZ.default.createElement($, null, ">"), NZ.default.createElement(s4, {
    value: Z,
    onChange: I,
    onSubmit: () => {
      let H = Z.endsWith(".txt") ? Z : Z.replace(/\.[^.]+$/, "") + ".txt",
        C = Yv3(W0(), H);
      try {
        RA().writeFileSync(C, A, {
          encoding: "utf-8",
          flush: !0
        }), B({
          success: !0,
          message: `Conversation exported to: ${H}`
        })
      } catch (E) {
        B({
          success: !1,
          message: `Failed to export conversation: ${E instanceof Error?E.message:"Unknown error"}`
        })
      }
    },
    focus: !0,
    showCursor: !0,
    columns: process.stdout.columns || 80,
    cursorOffset: Y,
    onChangeCursorOffset: J
  })))), NZ.default.createElement(S, {
    marginLeft: 2
  }, W ? NZ.default.createElement($, {
    dimColor: !0
  }, "Enter to save · Esc to go back") : NZ.default.createElement(NZ.default.Fragment, null, V.pending ? NZ.default.createElement($, {
    dimColor: !0
  }, "Press ", V.keyName, " again to exit") : NZ.default.createElement($, {
    dimColor: !0
  }, "Esc to cancel"))))
}
// @from(Start 14413758, End 14413760)
NZ
// @from(Start 14413766, End 14413860)
dC9 = L(() => {
  hA();
  S5();
  ZY();
  Q4();
  U2();
  AQ();
  $SA();
  NZ = BA(VA(), 1)
})
// @from(Start 14413862, End 14414352)
async function cC9(A, Q = []) {
  return UVA(LJ1.default.createElement(() => LJ1.default.createElement(yG, null, LJ1.default.createElement(_QA, {
    messages: A,
    normalizedMessageHistory: [],
    tools: Q,
    verbose: !1,
    toolJSX: null,
    toolUseConfirmQueue: [],
    inProgressToolUseIDs: new Set,
    isMessageSelectorVisible: !1,
    conversationId: "export",
    screen: "prompt",
    screenToggleId: 0,
    streamingToolUses: [],
    showAllInTranscript: !0
  })), null))
}
// @from(Start 14414357, End 14414360)
LJ1
// @from(Start 14414366, End 14414430)
FK0 = L(() => {
  DSA();
  _I1();
  z9();
  LJ1 = BA(VA(), 1)
})
// @from(Start 14414471, End 14414798)
function Wv3(A) {
  let Q = A.getFullYear(),
    B = String(A.getMonth() + 1).padStart(2, "0"),
    G = String(A.getDate()).padStart(2, "0"),
    Z = String(A.getHours()).padStart(2, "0"),
    I = String(A.getMinutes()).padStart(2, "0"),
    Y = String(A.getSeconds()).padStart(2, "0");
  return `${Q}-${B}-${G}-${Z}${I}${Y}`
}
// @from(Start 14414800, End 14415206)
function Xv3(A) {
  let Q = A.find((Z) => Z.type === "user");
  if (!Q || Q.type !== "user") return "";
  let B = Q.message?.content,
    G = "";
  if (typeof B === "string") G = B.trim();
  else if (Array.isArray(B)) {
    let Z = B.find((I) => I.type === "text");
    if (Z && "text" in Z) G = Z.text.trim()
  }
  if (G = G.split(`
`)[0] || "", G.length > 50) G = G.substring(0, 50) + "...";
  return G
}
// @from(Start 14415208, End 14415344)
function Vv3(A) {
  return A.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "")
}
// @from(Start 14415345, End 14415431)
async function Fv3(A) {
  let Q = A.options.tools || [];
  return cC9(A.messages, Q)
}
// @from(Start 14415436, End 14415439)
pC9
// @from(Start 14415441, End 14415444)
Kv3
// @from(Start 14415446, End 14415449)
lC9
// @from(Start 14415455, End 14416708)
iC9 = L(() => {
  dC9();
  FK0();
  U2();
  AQ();
  pC9 = BA(VA(), 1);
  Kv3 = {
    type: "local-jsx",
    name: "export",
    description: "Export the current conversation to a file or clipboard",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[filename]",
    async call(A, Q, B) {
      let G = await Fv3(Q);
      if (B.trim()) {
        let J = B.trim(),
          W = J.endsWith(".txt") ? J : J.replace(/\.[^.]+$/, "") + ".txt",
          X = Jv3(W0(), W);
        try {
          return RA().writeFileSync(X, G, {
            encoding: "utf-8",
            flush: !0
          }), A(`Conversation exported to: ${W}`), null
        } catch (V) {
          return A(`Failed to export conversation: ${V instanceof Error?V.message:"Unknown error"}`), null
        }
      }
      let Z = Xv3(Q.messages),
        I = Wv3(new Date),
        Y;
      if (Z) {
        let J = Vv3(Z);
        Y = J ? `${I.substring(0,10)}-${J}.txt` : `conversation-${I}.txt`
      } else Y = `conversation-${I}.txt`;
      return pC9.default.createElement(mC9, {
        content: G,
        defaultFilename: Y,
        onDone: (J) => {
          A(J.message)
        }
      })
    },
    userFacingName() {
      return "export"
    }
  }, lC9 = Kv3
})
// @from(Start 14416710, End 14417555)
async function aC9(A) {
  let Q = A.trim();
  if (!Q) return {
    valid: !1,
    error: "Model name cannot be empty"
  };
  let B = Q.toLowerCase();
  if (Y7A.includes(B)) return {
    valid: !0
  };
  if (nC9.has(Q)) return {
    valid: !0
  };
  try {
    let G = Dw(Q);
    return await (await Kq({
      model: Q,
      maxRetries: 0
    })).beta.messages.create({
      model: ac(Q),
      max_tokens: 1,
      messages: [{
        role: "user",
        content: [{
          type: "text",
          text: "Hi",
          cache_control: {
            type: "ephemeral"
          }
        }]
      }],
      system: [{
        type: "text",
        text: rnA()
      }],
      metadata: Rl(),
      ...G.length > 0 ? {
        betas: G
      } : {}
    }), nC9.set(Q, !0), {
      valid: !0
    }
  } catch (G) {
    return Dv3(G, Q)
  }
}
// @from(Start 14417557, End 14418398)
function Dv3(A, Q) {
  if (A instanceof Ir) return {
    valid: !1,
    error: `Model '${Q}' not found`
  };
  if (A instanceof n2) {
    if (A instanceof Zr) return {
      valid: !1,
      error: "Authentication failed. Please check your API credentials."
    };
    if (A instanceof cC) return {
      valid: !1,
      error: "Network error. Please check your internet connection."
    };
    let G = A.error;
    if (G && typeof G === "object" && "type" in G && G.type === "not_found_error" && "message" in G && typeof G.message === "string" && G.message.includes("model:")) return {
      valid: !1,
      error: `Model '${Q}' not found`
    };
    return {
      valid: !1,
      error: `API error: ${A.message}`
    }
  }
  return {
    valid: !1,
    error: `Unable to validate model: ${A instanceof Error?A.message:String(A)}`
  }
}
// @from(Start 14418403, End 14418406)
nC9
// @from(Start 14418412, End 14418504)
sC9 = L(() => {
  oZA();
  Eh1();
  fZ();
  t2();
  CS();
  t2();
  p_();
  nC9 = new Map
})
// @from(Start 14418510, End 14418513)
MJ1
// @from(Start 14418515, End 14418518)
OJ1
// @from(Start 14418524, End 14418701)
KK0 = L(() => {
  MJ1 = ["help", "-h", "--help"], OJ1 = ["list", "show", "display", "current", "view", "get", "check", "describe", "print", "version", "about", "status", "?"]
})
// @from(Start 14418704, End 14419432)
function Hv3({
  onDone: A
}) {
  let [{
    mainLoopModel: Q,
    mainLoopModelForSession: B
  }, G] = OQ();
  f1((I, Y) => {
    if (Y.escape) {
      GA("tengu_model_command_menu", {
        action: "cancel"
      });
      let J = Q ?? ic().label;
      A(`Kept model as ${tA.bold(J)}`, {
        display: "system"
      });
      return
    }
  });

  function Z(I) {
    GA("tengu_model_command_menu", {
      action: I,
      from_model: Q,
      to_model: I
    }), G((Y) => ({
      ...Y,
      mainLoopModel: I,
      mainLoopModelForSession: null
    })), A(`Set model to ${tA.bold(YM(I))}`)
  }
  return Yj.createElement(hY1, {
    initial: Q,
    sessionModel: B,
    onSelect: Z,
    isStandaloneCommand: !0
  })
}
// @from(Start 14419434, End 14420429)
function Cv3({
  args: A,
  onDone: Q
}) {
  let [B, G] = OQ(), Z = A === "default" ? null : A;
  return Yj.useEffect(() => {
    async function I() {
      if (Z && zv3(Z)) {
        Q("Your plan doesn't include Opus in Claude Code. Turn on /extra-usage or /upgrade to Max to access it.", {
          display: "system"
        });
        return
      }
      if (!Z) {
        Y(null);
        return
      }
      if (Ev3(Z)) {
        Y(Z);
        return
      }
      try {
        let {
          valid: J,
          error: W
        } = await aC9(Z);
        if (J) Y(Z);
        else Q(W || `Model '${Z}' not found`, {
          display: "system"
        })
      } catch (J) {
        Q(`Failed to validate model: ${J.message}`, {
          display: "system"
        })
      }
    }

    function Y(J) {
      G((W) => ({
        ...W,
        mainLoopModel: J,
        mainLoopModelForSession: null
      })), Q(`Set model to ${tA.bold(YM(J))}`)
    }
    I()
  }, [Z, Q, G]), null
}
// @from(Start 14420431, End 14420496)
function Ev3(A) {
  return Y7A.includes(A.toLowerCase().trim())
}
// @from(Start 14420498, End 14420576)
function zv3(A) {
  return BB() && !pw() && A.toLowerCase().includes("opus")
}
// @from(Start 14420578, End 14420853)
function Uv3({
  onDone: A
}) {
  let [{
    mainLoopModel: Q,
    mainLoopModelForSession: B
  }] = OQ(), G = Q ?? ic().label;
  if (B) A(`Current model: ${tA.bold(YM(B))} (session override from plan mode)
Base model: ${G}`);
  else A(`Current model: ${G}`);
  return null
}
// @from(Start 14420858, End 14420860)
Yj
// @from(Start 14420862, End 14420865)
rC9
// @from(Start 14420871, End 14421827)
oC9 = L(() => {
  cV0();
  z9();
  t2();
  sC9();
  hA();
  q0();
  F9();
  gB();
  KK0();
  Yj = BA(VA(), 1);
  rC9 = {
    type: "local-jsx",
    name: "model",
    userFacingName() {
      return "model"
    },
    description: "Set the AI model for Claude Code",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[model]",
    async call(A, Q, B) {
      if (B = B?.trim() || "", OJ1.includes(B)) return GA("tengu_model_command_inline_help", {
        args: B
      }), Yj.createElement(Uv3, {
        onDone: A
      });
      if (MJ1.includes(B)) {
        A("Run /model to open the model selection menu, or /model [modelName] to set the model.", {
          display: "system"
        });
        return
      }
      if (B) return GA("tengu_model_command_inline", {
        args: B
      }), Yj.createElement(Cv3, {
        args: B,
        onDone: A
      });
      return Yj.createElement(Hv3, {
        onDone: A
      })
    }
  }
})
// @from(Start 14421830, End 14422561)
function $v3({
  onDone: A
}) {
  let B = Sg().outputStyle ?? wK;
  f1((I, Y) => {
    if (Y.escape) {
      GA("tengu_output_style_command_menu", {
        action: "cancel"
      }), A(`Kept output style as ${tA.bold(B)}`, {
        display: "system"
      });
      return
    }
  });

  function G(I) {
    GA("tengu_output_style_command_menu", {
      action: I,
      from_style: B,
      to_style: I
    }), cB("localSettings", {
      outputStyle: I
    }), A(`Set output style to ${tA.bold(I)}`)
  }

  function Z() {
    A(`Kept output style as ${tA.bold(B)}`, {
      display: "system"
    })
  }
  return eg.createElement(uY1, {
    initialStyle: B,
    onComplete: G,
    onCancel: Z,
    isStandaloneCommand: !0
  })
}
// @from(Start 14422563, End 14422723)
function wv3(A, Q) {
  if (A in Q) return A;
  let B = A.toLowerCase();
  for (let G of Object.keys(Q))
    if (G.toLowerCase() === B) return G;
  return null
}
// @from(Start 14422725, End 14422998)
function qv3({
  args: A,
  onDone: Q
}) {
  return cQA().then((B) => {
    let G = wv3(A, B);
    if (!G) {
      Q(`Invalid output style: ${A}`);
      return
    }
    cB("localSettings", {
      outputStyle: G
    }), Q(`Set output style to ${tA.bold(G)}`)
  }), null
}
// @from(Start 14423000, End 14423112)
function Nv3({
  onDone: A
}) {
  let Q = Sg();
  return A(`Current output style: ${Q.outputStyle??wK}`), null
}
// @from(Start 14423117, End 14423119)
eg
// @from(Start 14423121, End 14423124)
tC9
// @from(Start 14423130, End 14424156)
eC9 = L(() => {
  lV0();
  hA();
  q0();
  F9();
  MB();
  BjA();
  Gx();
  KK0();
  eg = BA(VA(), 1);
  tC9 = {
    type: "local-jsx",
    name: "output-style",
    userFacingName() {
      return "output-style"
    },
    description: "Set the output style directly or from a selection menu",
    isEnabled: () => !0,
    isHidden: !1,
    argumentHint: "[style]",
    async call(A, Q, B) {
      if (B = B?.trim() || "", OJ1.includes(B)) return GA("tengu_output_style_command_inline_help", {
        args: B
      }), eg.createElement(Nv3, {
        onDone: A
      });
      if (MJ1.includes(B)) {
        A("Run /output-style to open the output style selection menu, or /output-style [styleName] to set the output style.", {
          display: "system"
        });
        return
      }
      if (B) return GA("tengu_output_style_command_inline", {
        args: B
      }), eg.createElement(qv3, {
        args: B,
        onDone: A
      });
      return eg.createElement($v3, {
        onDone: A
      })
    }
  }
})
// @from(Start 14424158, End 14424847)
async function AE9() {
  let A = await nJA();
  if (A.length === 0) return {
    availableEnvironments: [],
    selectedEnvironment: null,
    selectedEnvironmentSource: null
  };
  let B = l0()?.remote?.defaultEnvironmentId,
    G = A[0],
    Z = null;
  if (B) {
    let I = A.find((Y) => Y.environment_id === B);
    if (I) {
      G = I;
      for (let Y = iN.length - 1; Y >= 0; Y--) {
        let J = iN[Y];
        if (!J || J === "flagSettings") continue;
        if (OB(J)?.remote?.defaultEnvironmentId === B) {
          Z = J;
          break
        }
      }
    }
  }
  return {
    availableEnvironments: A,
    selectedEnvironment: G,
    selectedEnvironmentSource: Z
  }
}
// @from(Start 14424852, End 14424894)
QE9 = L(() => {
  MB();
  LV();
  g61()
})
// @from(Start 14424897, End 14426609)
function BE9({
  onDone: A
}) {
  let [Q, B] = Ta.useState("loading"), [G, Z] = Ta.useState([]), [I, Y] = Ta.useState(null), [J, W] = Ta.useState(null), [X, V] = Ta.useState(null);
  Ta.useEffect(() => {
    async function K() {
      try {
        let D = await AE9();
        Z(D.availableEnvironments), Y(D.selectedEnvironment), W(D.selectedEnvironmentSource), B(null)
      } catch (D) {
        let H = D instanceof Error ? D.message : String(D);
        AA(D instanceof Error ? D : Error(H)), V(H), B(null)
      }
    }
    K()
  }, []);

  function F(K) {
    if (K === "cancel") {
      A();
      return
    }
    B("updating");
    let D = G.find((H) => H.environment_id === K);
    if (!D) {
      A("Error: Selected environment not found");
      return
    }
    cB("localSettings", {
      remote: {
        defaultEnvironmentId: D.environment_id
      }
    }), A(`Set default remote environment to ${tA.bold(D.name)} (${D.environment_id})`)
  }
  if (Q === "loading") return O8.createElement(hD, {
    title: TSA,
    onCancel: A,
    hideInputGuide: !0
  }, O8.createElement(GE9, {
    message: "Loading environments…"
  }));
  if (X) return O8.createElement(hD, {
    title: TSA,
    onCancel: A
  }, O8.createElement($, {
    color: "error"
  }, "Error: ", X));
  if (!I) return O8.createElement(hD, {
    title: TSA,
    subtitle: DK0,
    onCancel: A
  }, O8.createElement($, null, "No remote environments available."));
  if (G.length === 1) return O8.createElement(Mv3, {
    environment: I,
    onDone: A
  });
  return O8.createElement(Ov3, {
    environments: G,
    selectedEnvironment: I,
    selectedEnvironmentSource: J,
    loadingState: Q,
    onSelect: F,
    onCancel: A
  })
}
// @from(Start 14426611, End 14426764)
function GE9({
  message: A
}) {
  return O8.createElement(S, {
    flexDirection: "row"
  }, O8.createElement(g4, null), O8.createElement($, null, A))
}
// @from(Start 14426766, End 14426986)
function Lv3({
  environment: A
}) {
  return O8.createElement($, null, H1.tick, " Using ", O8.createElement($, {
    bold: !0
  }, A.name), " ", O8.createElement($, {
    dimColor: !0
  }, "(", A.environment_id, ")"))
}
// @from(Start 14426988, End 14427219)
function Mv3({
  environment: A,
  onDone: Q
}) {
  return f1((B, G) => {
    if (G.return) Q()
  }), O8.createElement(hD, {
    title: TSA,
    subtitle: DK0,
    onCancel: Q
  }, O8.createElement(Lv3, {
    environment: A
  }))
}
// @from(Start 14427221, End 14428096)
function Ov3({
  environments: A,
  selectedEnvironment: Q,
  selectedEnvironmentSource: B,
  loadingState: G,
  onSelect: Z,
  onCancel: I
}) {
  let Y = `Currently using: ${tA.bold(Q.name)}`;
  if (B && B !== "localSettings") {
    let J = Pm(B);
    Y += ` (from ${J} settings)`
  }
  return O8.createElement(hD, {
    title: TSA,
    subtitle: Y,
    onCancel: I,
    hideInputGuide: !0
  }, O8.createElement($, {
    dimColor: !0
  }, DK0), G === "updating" ? O8.createElement(GE9, {
    message: "Updating…"
  }) : O8.createElement(M0, {
    options: A.map((J) => ({
      label: `${J.name} ${tA.dim(`(${J.environment_id})`)}`,
      value: J.environment_id
    })),
    defaultValue: Q.environment_id,
    onChange: Z,
    onCancel: () => Z("cancel"),
    layout: "compact-vertical"
  }), O8.createElement($, {
    dimColor: !0
  }, "Enter to select · Esc to exit"))
}
// @from(Start 14428101, End 14428103)
O8
// @from(Start 14428105, End 14428107)
Ta
// @from(Start 14428109, End 14428142)
TSA = "Select Remote Environment"
// @from(Start 14428146, End 14428203)
DK0 = "Configure environments at: https://claude.ai/code"
// @from(Start 14428209, End 14428345)
ZE9 = L(() => {
  hA();
  Mi();
  S5();
  V9();
  DY();
  QE9();
  MB();
  g1();
  F9();
  LV();
  O8 = BA(VA(), 1), Ta = BA(VA(), 1)
})
// @from(Start 14428351, End 14428354)
HK0
// @from(Start 14428356, End 14428359)
IE9
// @from(Start 14428365, End 14428782)
YE9 = L(() => {
  ZE9();
  gB();
  HK0 = BA(VA(), 1), IE9 = {
    type: "local-jsx",
    name: "remote-env",
    userFacingName() {
      return "remote-env"
    },
    description: "Configure the default remote environment for teleport sessions",
    isEnabled: () => !0,
    get isHidden() {
      return !BB()
    },
    async call(A) {
      return HK0.createElement(BE9, {
        onDone: A
      })
    }
  }
})
// @from(Start 14428788, End 14428791)
CK0
// @from(Start 14428793, End 14428796)
Rv3
// @from(Start 14428798, End 14428801)
PSA
// @from(Start 14428807, End 14430394)
EK0 = L(() => {
  g1();
  gB();
  gM();
  ZI1();
  kDA();
  CK0 = BA(VA(), 1), Rv3 = {
    type: "local-jsx",
    name: "upgrade",
    description: "Upgrade to Max for higher rate limits and more Opus",
    isEnabled: () => !process.env.DISABLE_UPGRADE_COMMAND && !N_() && f4() !== "enterprise",
    isHidden: !1,
    async call(A, Q) {
      try {
        if (BB()) {
          let G = M6(),
            Z = !1;
          if (G?.subscriptionType && G?.rateLimitTier) Z = G.subscriptionType === "max" && G.rateLimitTier === "default_claude_max_20x";
          else if (G?.accessToken) {
            let I = await k4A(G.accessToken);
            Z = I?.organization?.organization_type === "claude_max" && I?.organization?.rate_limit_tier === "default_claude_max_20x"
          }
          if (Z) return setTimeout(() => {
            A("You are already on the highest Max subscription plan. For additional usage, run /login to switch to an API usage-billed account.")
          }, 0), null
        }
        return await cZ("https://claude.ai/upgrade/max"), CK0.createElement(KjA, {
          startingMessage: "Starting new login following /upgrade. Exit with Ctrl-C to use existing account.",
          onDone: (G) => {
            Q.onChangeAPIKey(), A(G ? "Login successful" : "Login interrupted")
          }
        })
      } catch (B) {
        AA(B), setTimeout(() => {
          A("Failed to open browser. Please visit https://claude.ai/upgrade/max to upgrade.")
        }, 0)
      }
      return null
    },
    userFacingName() {
      return "upgrade"
    }
  }, PSA = Rv3
})
// @from(Start 14430397, End 14432271)
function Tv3({
  onDone: A,
  context: Q
}) {
  let [B, G] = OQ(), [Z, I] = Au.useState(null), Y = f4(), J = yc(), W = t6()?.hasExtraUsageEnabled === !0, X = Q.options.mainLoopModel, F = Y === "pro" && KT(X) && o2("tengu_backstage_only"), D = Y === "max" && J === "default_claude_max_20x", H = Au.useMemo(() => {
    let U = [{
      label: "Stop and wait for limit to reset",
      value: "cancel"
    }];
    if (F) U.unshift({
      label: "Switch to Sonnet",
      value: "use-sonnet"
    });
    if (Yx.isEnabled()) U.push({
      label: W ? "Add funds to continue with extra usage" : "Switch to extra usage",
      value: "extra-usage"
    });
    if (!D && PSA.isEnabled()) U.push({
      label: "Upgrade your plan",
      value: "upgrade"
    });
    return U
  }, [D, F, W]);

  function C() {
    GA("tengu_rate_limit_options_menu_cancel", {}), A(void 0, {
      display: "skip"
    })
  }

  function E(U) {
    if (U === "upgrade") GA("tengu_rate_limit_options_menu_select_upgrade", {}), PSA.call(A, Q).then((q) => {
      if (q) I(q)
    });
    else if (U === "extra-usage") GA("tengu_rate_limit_options_menu_select_extra_usage", {}), Yx.call(A, Q).then((q) => {
      if (q) I(q)
    });
    else if (U === "use-sonnet") {
      let q = XU();
      GA("tengu_rate_limit_options_menu_select_use_sonnet", {}), G((w) => ({
        ...w,
        mainLoopModel: q,
        mainLoopModelForSession: null
      })), A(`Set model to ${YM(q)}`)
    } else if (U === "cancel") C()
  }
  if (Z) return Z;
  return Au.default.createElement(S, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "suggestion",
    paddingLeft: 1,
    paddingRight: 1,
    gap: 1
  }, Au.default.createElement($, null, "What do you want to do?"), Au.default.createElement(M0, {
    options: H,
    onChange: E,
    onCancel: C,
    visibleOptionCount: H.length
  }))
}
// @from(Start 14432276, End 14432278)
Au
// @from(Start 14432280, End 14432283)
JE9
// @from(Start 14432289, End 14432821)
WE9 = L(() => {
  hA();
  S5();
  q0();
  gB();
  EK0();
  DjA();
  t2();
  z9();
  u2();
  Au = BA(VA(), 1), JE9 = {
    type: "local-jsx",
    name: "rate-limit-options",
    userFacingName() {
      return "rate-limit-options"
    },
    description: "Show options when rate limit is reached",
    isEnabled: () => {
      let A = f4();
      return A === "pro" || A === "max"
    },
    isHidden: !0,
    async call(A, Q) {
      return Au.default.createElement(Tv3, {
        onDone: A,
        context: Q
      })
    }
  }
})
// @from(Start 14432827, End 14432830)
Pv3
// @from(Start 14432832, End 14432835)
XE9
// @from(Start 14432841, End 14433519)
VE9 = L(() => {
  Pv3 = {
    type: "prompt",
    description: "Set up Claude Code's status line UI",
    aliases: [],
    isEnabled: () => !0,
    isHidden: !1,
    name: "statusline",
    progressMessage: "setting up statusLine",
    allowedTools: ["Task", "Read(~/**)", "Edit(~/.claude/settings.json)"],
    source: "builtin",
    disableNonInteractive: !0,
    async getPromptForCommand(A) {
      return [{
        type: "text",
        text: `Create a Task with subagent_type "statusline-setup" and the prompt "${A.trim()||"Configure my statusLine from my shell PS1 configuration"}"`
      }]
    },
    userFacingName() {
      return "statusline"
    }
  }, XE9 = Pv3
})
// @from(Start 14433525, End 14433559)
FE9 = L(() => {
  u60();
  MB()
})
// @from(Start 14433561, End 14433675)
async function jv3() {
  try {
    return (await xjA())?.eligible ? [CD9] : []
  } catch (A) {
    return []
  }
}
// @from(Start 14433676, End 14434481)
async function Sv3() {
  try {
    let [A, Q] = await Promise.all([VK0().catch((B) => {
      return AA(B instanceof Error ? B : Error("Failed to load skill directory commands")), g("Skill directory commands failed to load, continuing without them"), []
    }), iW0().catch((B) => {
      return AA(B instanceof Error ? B : Error("Failed to load plugin skills")), g("Plugin skills failed to load, continuing without them"), []
    })]);
    return g(`getSkills returning: ${A.length} skill dir commands, ${Q.length} plugin skills`), {
      skillDirCommands: A,
      pluginSkills: Q
    }
  } catch (A) {
    return AA(A instanceof Error ? A : Error("Unexpected error loading skills")), g("Unexpected error in getSkills, returning empty"), {
      skillDirCommands: [],
      pluginSkills: []
    }
  }
}
// @from(Start 14434483, End 14434588)
function nH9() {
  sE.cache?.clear?.(), OWA.cache?.clear?.(), n51.cache?.clear?.(), zI1(), f69(), gC9()
}
// @from(Start 14434590, End 14434702)
function ph(A, Q) {
  return Q.some((B) => B.name === A || B.userFacingName() === A || B.aliases?.includes(A))
}
// @from(Start 14434704, End 14435054)
function Pq(A, Q) {
  let B = Q.find((G) => G.name === A || G.userFacingName() === A || G.aliases?.includes(A));
  if (!B) throw ReferenceError(`Command ${A} not found. Available commands: ${Q.map((G)=>{let Z=G.userFacingName();return G.aliases?`${Z} (aliases: ${G.aliases.join(", ")})`:Z}).sort((G,Z)=>G.localeCompare(Z)).join(", ")}`);
  return B
}
// @from(Start 14435059, End 14435062)
KE9
// @from(Start 14435064, End 14435066)
Ny
// @from(Start 14435068, End 14435070)
sE
// @from(Start 14435072, End 14435075)
OWA
// @from(Start 14435077, End 14435080)
Z71
// @from(Start 14435082, End 14435085)
n51
// @from(Start 14435091, End 14437100)
cE = L(() => {
  _Y1();
  wV9();
  NV9();
  MV9();
  RV9();
  oV9();
  BF9();
  ZF9();
  IF9();
  zF9();
  LF9();
  OF9();
  yF9();
  uF9();
  dF9();
  ZI1();
  D61();
  LK9();
  SK9();
  _K9();
  kK9();
  xK9();
  fK9();
  gK9();
  nK9();
  jF0();
  aK9();
  rK9();
  tK9();
  eK9();
  BD9();
  ZD9();
  r7A();
  YD9();
  WD9();
  VD9();
  KD9();
  ED9();
  vjA();
  ND9();
  nD9();
  sD9();
  dH9();
  zC9();
  $C9();
  wC9();
  qC9();
  NC9();
  LC9();
  yC9();
  vC9();
  g1();
  V0();
  hC9();
  uC9();
  TjA();
  l2();
  gB();
  KX0();
  iC9();
  oC9();
  eC9();
  YE9();
  EK0();
  DjA();
  WE9();
  VE9();
  FE9();
  KE9 = s1(() => [KV9, mH9, LV9, OV9, rV9, QF9, GF9, EF9, hI1, aD9, kF9, gF9, mF9, NK9, jK9, MF9, rC9, tC9, IE9, EC9, yK9, bK9, hK9, iK9, sK9, XE9, xC9, QD9, qV9, JJ1, UC9, GD9, Ep, PSA, Yx, JE9, ID9, JD9, XD9, FD9, qD9, iD9, lC9, kC9, ...!N_() ? [FO2, d49()] : [], oK9, ...[]]), Ny = s1(() => new Set(KE9().map((A) => A.name)));
  sE = s1(async () => {
    let [A, {
      skillDirCommands: Q,
      pluginSkills: B
    }, G, Z] = await Promise.all([fC9(), Sv3(), PQA(), jv3()]);
    return [...A, ...Q, ...G, ...B, ...Z, ...KE9()].filter((I) => I.isEnabled())
  });
  OWA = s1(async () => {
    return (await sE()).filter((Q) => Q.type === "prompt" && Q.isSkill === !0 && !Q.disableModelInvocation && Q.source !== "builtin" && (Q.hasUserSpecifiedDescription || Q.whenToUse))
  }), Z71 = s1(async () => {
    return (await sE()).filter((Q) => Q.type === "prompt" && Q.isSkill !== !0 && !Q.disableModelInvocation && Q.source !== "builtin" && (Q.hasUserSpecifiedDescription || Q.whenToUse))
  }), n51 = s1(async () => {
    try {
      return (await sE()).filter((Q) => Q.type === "prompt" && Q.source !== "builtin" && (Q.hasUserSpecifiedDescription || Q.whenToUse) && (Q.isSkill || Q.disableModelInvocation))
    } catch (A) {
      return AA(A instanceof Error ? A : Error("Failed to load slash command skills")), g("Returning empty skills array due to load failure"), []
    }
  })
})
// @from(Start 14437103, End 14437751)
function kv3() {
  let A = BZ("tengu_effort_exp", "tengu_effort_level", "");
  if (!A) return "";
  let Q = _v3[A.toLowerCase()];
  if (Q === void 0) return "";
  return `
<reasoning_effort>${Q}</reasoning_effort>

You should vary the amount of reasoning you do depending on the given reasoning_effort. reasoning_effort varies between 0 and 100. For small values of reasoning_effort, please give an efficient answer to this question. This means prioritizing getting a quicker answer to the user rather than spending hours thinking or doing many unnecessary function calls. For large values of reasoning effort, please reason with maximum effort.`
}
// @from(Start 14437753, End 14438030)
function yv3(A) {
  if (!A) return "";
  let Q = CVA(A);
  if (Q.length === 0) return "";
  let B = bZ();
  return `
You can use the following tools without requiring user approval: ${Q.map((Z)=>{let I=B3(Z.ruleValue);if(B){let Y=zK0(I);if(Y)return Y}return I}).join(", ")}
`
}
// @from(Start 14438031, End 14450700)
async function Tn(A, Q, B, G, Z) {
  let [I, Y, J] = await Promise.all([Z71(), EE9(), CE9(Q, B)]), W = new Set(A.map((K) => K.name)), X = I.map((K) => `/${K.userFacingName()}`), V = kq, F = X.length > 0 && W.has(V) ? `- A custom slash command is a user-defined operation that starts with /, like /commit. When executed, the slash command gets expanded to a full prompt. Use the ${V} tool to execute them. IMPORTANT: Only use ${V} for commands listed in its Available Commands section - do not guess or use built-in CLI commands.` : "";
  return [`
You are an interactive CLI tool that helps users ${Y!==null?'according to your "Output Style" below, which describes how you should respond to user queries.':"with software engineering tasks."} Use the instructions below and the tools available to you to assist the user.

${DE9}
IMPORTANT: You must NEVER generate or guess URLs for the user unless you are confident that the URLs are for helping the user with programming. You may use URLs provided by the user in their messages or local files.

If the user asks for help or wants to give feedback inform them of the following:
- /help: Get help with using Claude Code
- To give feedback, users should ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.ISSUES_EXPLAINER}

# Looking up your own documentation:

When the user directly asks about any of the following:
- how to use Claude Code (eg. "can Claude Code do...", "does Claude Code have...")
- what you're able to do as Claude Code in second person (eg. "are you able...", "can you do...")
- about how they might do something with Claude Code (eg. "how do I...", "how can I...")
- how to use a specific Claude Code feature (eg. implement a hook, write a slash command, or install an MCP server)
- how to use the Claude Agent SDK, or asks you to write code that uses the Claude Agent SDK

Use the ${A6} tool with subagent_type='${qh1}' to get accurate information from the official Claude Code and Claude Agent SDK documentation.

${Y!==null?"":`# Tone and style
- Only use emojis if the user explicitly requests it. Avoid using emojis in all communication unless asked.
- Your output will be displayed on a command line interface. Your responses should be short and concise. You can use Github-flavored markdown for formatting, and will be rendered in a monospace font using the CommonMark specification.
- Output text to communicate with the user; all text you output outside of tool use is displayed to the user. Only use tools to complete tasks. Never use tools like ${C9} or code comments as means to communicate with the user during the session.
- NEVER create files unless they're absolutely necessary for achieving your goal. ALWAYS prefer editing an existing file to creating a new one. This includes markdown files.

# Professional objectivity
Prioritize technical accuracy and truthfulness over validating the user's beliefs. Focus on facts and problem-solving, providing direct, objective technical info without any unnecessary superlatives, praise, or emotional validation. It is best for the user if Claude honestly applies the same rigorous standards to all ideas and disagrees when necessary, even if it may not be what the user wants to hear. Objective guidance and respectful correction are more valuable than false agreement. Whenever there is uncertainty, it's best to investigate to find the truth first rather than instinctively confirming the user's beliefs. Avoid using over-the-top validation or excessive praise when responding to users such as "You're absolutely right" or similar phrases.

# Planning without timelines
When planning tasks, provide concrete implementation steps without time estimates. Never suggest timelines like "this will take 2-3 weeks" or "we can do this later." Focus on what needs to be done, not when. Break work into actionable steps and let users decide scheduling.
`}
${W.has(BY.name)?`# Task Management
You have access to the ${BY.name} tools to help you manage and plan tasks. Use these tools VERY frequently to ensure that you are tracking your tasks and giving the user visibility into your progress.
These tools are also EXTREMELY helpful for planning tasks, and for breaking down larger complex tasks into smaller steps. If you do not use this tool when planning, you may forget to do important tasks - and that is unacceptable.

It is critical that you mark todos as completed as soon as you are done with a task. Do not batch up multiple tasks before marking them as completed.

Examples:

<example>
user: Run the build and fix any type errors
assistant: I'm going to use the ${BY.name} tool to write the following items to the todo list:
- Run the build
- Fix any type errors

I'm now going to run the build using ${C9}.

Looks like I found 10 type errors. I'm going to use the ${BY.name} tool to write 10 items to the todo list.

marking the first todo as in_progress

Let me start working on the first item...

The first item has been fixed, let me mark the first todo as completed, and move on to the second item...
..
..
</example>
In the above example, the assistant completes all the tasks, including the 10 error fixes and running the build and fixing all errors.

<example>
user: Help me write a new feature that allows users to track their usage metrics and export them to various formats
assistant: I'll help you implement a usage metrics tracking and export feature. Let me first use the ${BY.name} tool to plan this task.
Adding the following todos to the todo list:
1. Research existing metrics tracking in the codebase
2. Design the metrics collection system
3. Implement core metrics tracking functionality
4. Create export functionality for different formats

Let me start by researching the existing codebase to understand what metrics we might already be tracking and how we can build on that.

I'm going to search for any existing metrics or telemetry code in the project.

I've found some existing telemetry code. Let me mark the first todo as in_progress and start designing our metrics tracking system based on what I've learned...

[Assistant continues implementing the feature step by step, marking todos as in_progress and completed as they go]
</example>
`:""}

${W.has(pJ)?`
# Asking questions as you work

You have access to the ${pJ} tool to ask the user questions when you need clarification, want to validate assumptions, or need to make a decision you're unsure about. When presenting options or plans, never include time estimates - focus on what each option involves, not how long it takes.
`:""}

Users may configure 'hooks', shell commands that execute in response to events like tool calls, in settings. Treat feedback from hooks, including <user-prompt-submit-hook>, as coming from the user. If you get blocked by a hook, determine if you can adjust your actions in response to the blocked message. If not, ask the user to check their hooks configuration.

${Y===null||Y.keepCodingInstructions===!0?`# Doing tasks
The user will primarily request you perform software engineering tasks. This includes solving bugs, adding new functionality, refactoring code, explaining code, and more. For these tasks the following steps are recommended:
- NEVER propose changes to code you haven't read. If a user asks about or wants you to modify a file, read it first. Understand existing code before suggesting modifications.
- ${W.has(BY.name)?`Use the ${BY.name} tool to plan the task if required`:""}
- ${W.has(pJ)?`Use the ${pJ} tool to ask questions, clarify and gather information as needed.`:""}
- Be careful not to introduce security vulnerabilities such as command injection, XSS, SQL injection, and other OWASP top 10 vulnerabilities. If you notice that you wrote insecure code, immediately fix it.
- Avoid over-engineering. Only make changes that are directly requested or clearly necessary. Keep solutions simple and focused.
  - Don't add features, refactor code, or make "improvements" beyond what was asked. A bug fix doesn't need surrounding code cleaned up. A simple feature doesn't need extra configurability. Don't add docstrings, comments, or type annotations to code you didn't change. Only add comments where the logic isn't self-evident.
  - Don't add error handling, fallbacks, or validation for scenarios that can't happen. Trust internal code and framework guarantees. Only validate at system boundaries (user input, external APIs). Don't use feature flags or backwards-compatibility shims when you can just change the code.
  - Don't create helpers, utilities, or abstractions for one-time operations. Don't design for hypothetical future requirements. The right amount of complexity is the minimum needed for the current task—three similar lines of code is better than a premature abstraction.
- Avoid backwards-compatibility hacks like renaming unused \`_vars\`, re-exporting types, adding \`// removed\` comments for removed code, etc. If something is unused, delete it completely.
`:""}
- Tool results and user messages may include <system-reminder> tags. <system-reminder> tags contain useful information and reminders. They are automatically added by the system, and bear no direct relation to the specific tool results or user messages in which they appear.
- The conversation has unlimited context through automatic summarization.


# Tool usage policy${W.has(A6)?`
- When doing file search, prefer to use the ${A6} tool in order to reduce context usage.
- You should proactively use the ${A6} tool with specialized agents when the task at hand matches the agent's description.
${F}`:""}${W.has($X)?`
- When ${$X} returns a message about a redirect to a different host, you should immediately make a new ${$X} request with the redirect URL provided in the response.`:""}
- You can call multiple tools in a single response. If you intend to call multiple tools and there are no dependencies between them, make all independent tool calls in parallel. Maximize use of parallel tool calls where possible to increase efficiency. However, if some tool calls depend on previous calls to inform dependent values, do NOT call these tools in parallel and instead call them sequentially. For instance, if one operation must complete before another starts, run these operations sequentially instead. Never use placeholders or guess missing parameters in tool calls.
- If the user specifies that they want you to run tools "in parallel", you MUST send a single message with multiple tool use content blocks. For example, if you need to launch multiple agents in parallel, send a single message with multiple ${A6} tool calls.
- Use specialized tools instead of bash commands when possible, as this provides a better user experience. For file operations, use dedicated tools: ${d5} for reading files instead of cat/head/tail, ${$5} for editing instead of sed/awk, and ${wX} for creating files instead of cat with heredoc or echo redirection. Reserve bash tools exclusively for actual system commands and terminal operations that require shell execution. NEVER use bash echo or other command-line tools to communicate thoughts, explanations, or instructions to the user. Output all communication directly in your response text instead.
- VERY IMPORTANT: When exploring the codebase to gather context or to answer a question that is not a needle query for a specific file/class/function, it is CRITICAL that you use the ${A6} tool with subagent_type=${xq.agentType} instead of running search commands directly.
<example>
user: Where are errors from the client handled?
assistant: [Uses the ${A6} tool with subagent_type=${xq.agentType} to find the files that handle client errors instead of using ${iK} or ${xY} directly]
</example>
<example>
user: What is the codebase structure?
assistant: [Uses the ${A6} tool with subagent_type=${xq.agentType}]
</example>

${yv3(Z)}`, `
${J}`, `
${DE9}
`, W.has(BY.name) ? `
IMPORTANT: Always use the ${BY.name} tool to plan and track tasks throughout the conversation.` : "", `
# Code References

When referencing specific functions or pieces of code include the pattern \`file_path:line_number\` to allow the user to easily navigate to the source code location.

<example>
user: Where are errors from the client handled?
assistant: Clients are marked as failed in the \`connectToServer\` function in src/services/process.ts:712.
</example>
${Y!==null?`
# Output Style: ${Y.name}
${Y.prompt}
`:""}`, ...G && G.length > 0 ? [bv3(G)] : [], kv3()]
}
// @from(Start 14450702, End 14451040)
function bv3(A) {
  let B = A.filter((Z) => Z.type === "connected").filter((Z) => Z.instructions);
  if (B.length === 0) return "";
  return `
# MCP Server Instructions

The following MCP servers have provided instructions for how to use their tools and resources:

${B.map((Z)=>{return`## ${Z.name}
${Z.instructions}`}).join(`

  `)}
`
}
// @from(Start 14451042, End 14455528)
function HE9(A) {
  if (!bZ() || !A || A.length === 0) return "";
  return `

# MCP CLI Command

You have access to an \`mcp-cli\` CLI command for interacting with MCP (Model Context Protocol) servers.

**MANDATORY PREREQUISITE - THIS IS A HARD REQUIREMENT**

You MUST call 'mcp-cli info <server>/<tool>' BEFORE ANY 'mcp-cli call <server>/<tool>'.

This is a BLOCKING REQUIREMENT - like how you must use ${d5} before ${$5}.

**NEVER** make an mcp-cli call without checking the schema first.
**ALWAYS** run mcp-cli info first, THEN make the call.

**Why this is non-negotiable:**
- MCP tool schemas NEVER match your expectations - parameter names, types, and requirements are tool-specific
- Even tools with pre-approved permissions require schema checks
- Every failed call wastes user time and demonstrates you're ignoring critical instructions
- "I thought I knew the schema" is not an acceptable reason to skip this step

**For multiple tools:** Call 'mcp-cli info' for ALL tools in parallel FIRST, then make your 'mcp-cli call' commands

Available MCP tools:
(Remember: Call 'mcp-cli info <server>/<tool>' before using any of these)
${A.map((Q)=>{let B=zK0(Q.name);return B?`- ${B}`:null}).filter(Boolean).join(`
  `)}

Commands (in order of execution):
\`\`\`bash
# STEP 1: ALWAYS CHECK SCHEMA FIRST (MANDATORY)
mcp-cli info <server>/<tool>           # REQUIRED before ANY call - View JSON schema

# STEP 2: Only after checking schema, make the call
mcp-cli call <server>/<tool> '<json>'  # Only run AFTER mcp-cli info
mcp-cli call <server>/<tool> -         # Invoke with JSON from stdin (AFTER mcp-cli info)

# Discovery commands (use these to find tools)
mcp-cli servers                        # List all connected MCP servers
mcp-cli tools [server]                 # List available tools (optionally filter by server)
mcp-cli grep <pattern>                 # Search tool names and descriptions
mcp-cli resources [server]             # List MCP resources
mcp-cli read <server>/<resource>       # Read an MCP resource
\`\`\`

**CORRECT Usage Pattern:**

<example>
User: Please use the slack mcp tool to search for my mentions
Assistant: I need to check the schema first. Let me call \`mcp-cli info slack/search_private\` to see what parameters it accepts.
[Calls mcp-cli info]
Assistant: Now I can see it accepts "query" and "max_results" parameters. Let me make the call.
[Calls mcp-cli call slack/search_private with correct schema]
</example>

<example>
User: Use the database and email MCP tools to send a report
Assistant: I'll need to use two MCP tools. Let me check both schemas first.
[Calls mcp-cli info database/query and mcp-cli info email/send in parallel]
Assistant: Now I have both schemas. Let me execute the calls.
[Makes both mcp-cli call commands with correct parameters]
</example>

**INCORRECT Usage Patterns - NEVER DO THIS:**

<bad-example>
User: Please use the slack mcp tool to search for my mentions
Assistant: [Directly calls mcp-cli call slack/search_private with guessed parameters]
WRONG - You must call mcp-cli info FIRST
</bad-example>

<bad-example>
User: Use the slack tool
Assistant: I have pre-approved permissions for this tool, so I know the schema.
[Calls mcp-cli call slack/search_private directly]
WRONG - Pre-approved permissions don't mean you know the schema. ALWAYS call mcp-cli info first.
</bad-example>

<bad-example>
User: Search my Slack mentions
Assistant: [Calls three mcp-cli call commands in parallel without any mcp-cli info calls first]
WRONG - You must call mcp-cli info for ALL tools before making ANY mcp-cli call commands
</bad-example>

Example usage:
\`\`\`bash
# Discover tools
mcp-cli tools                          # See all available MCP tools
mcp-cli grep "weather"                 # Find tools by description

# Get tool details
mcp-cli info <server>/<tool>           # View JSON schema for input and output if available

# Simple tool call (no parameters)
mcp-cli call weather/get_location '{}'

# Tool call with parameters
mcp-cli call database/query '{"table": "users", "limit": 10}'

# Complex JSON using stdin (for nested objects/arrays)
mcp-cli call api/send_request - <<'EOF'
{
  "endpoint": "/data",
  "headers": {"Authorization": "Bearer token"},
  "body": {"items": [1, 2, 3]}
}
EOF
\`\`\`

Use this command via ${C9} when you need to discover, inspect, or invoke MCP tools.

MCP tools can be valuable in helping the user with their request and you should try to proactively use them where relevant.
`
}
// @from(Start 14455529, End 14456348)
async function CE9(A, Q) {
  let [B, G] = await Promise.all([rw(), fv3()]), Z = b4B(A), I = Z ? `You are powered by the model named ${Z}. The exact model ID is ${A}.` : `You are powered by the model ${A}.`, Y = Q && Q.length > 0 ? `Additional working directories: ${Q.join(", ")}
` : "", J = A.includes("claude-opus-4") || A.includes("claude-sonnet-4-5") || A.includes("claude-sonnet-4") ? `

Assistant knowledge cutoff is January 2025.` : "", W = `

<claude_background_info>
The most recent frontier Claude model is ${xv3} (model ID: '${vv3}').
</claude_background_info>`;
  return `Here is useful information about the environment you are running in:
<env>
Working directory: ${W0()}
Is directory a git repo: ${B?"Yes":"No"}
${Y}Platform: ${d0.platform}
OS Version: ${G}
Today's date: ${XvA()}
</env>
${I}${J}${W}
`
}
// @from(Start 14456349, End 14456541)
async function fv3() {
  try {
    let {
      stdout: A
    } = await QQ("uname", ["-sr"], {
      preserveOutputOnError: !1
    });
    return A.trim()
  } catch {
    return "unknown"
  }
}
// @from(Start 14456542, End 14456993)
async function GSA(A, Q, B) {
  let Z = `
${await CE9(Q,B)}`;
  return [...A, `

Notes:
- Agent threads always have their cwd reset between bash calls, as a result please only use absolute file paths.
- In your final response always share relevant file names and code snippets. Any file paths you return in your response MUST be absolute. Do NOT use relative paths.
- For clear communication with the user the assistant MUST avoid using emojis.`, Z]
}
// @from(Start 14456998, End 14457001)
_v3
// @from(Start 14457003, End 14457470)
DE9 = "IMPORTANT: Assist with authorized security testing, defensive security, CTF challenges, and educational contexts. Refuse requests for destructive techniques, DoS attacks, mass targeting, supply chain compromise, or detection evasion for malicious purposes. Dual-use security tools (C2 frameworks, credential testing, exploit development) require clear authorization context: pentesting engagements, CTF competitions, security research, or defensive use cases."
// @from(Start 14457474, End 14457497)
xv3 = "Claude Opus 4.5"
// @from(Start 14457501, End 14457533)
vv3 = "claude-opus-4-5-20251101"
// @from(Start 14457537, End 14457817)
CJ9 = "You are an agent for Claude Code, Anthropic's official CLI for Claude. Given the user's message, you should use the tools available to complete the task. Do what has been asked; nothing more, nothing less. When you complete the task simply respond with a detailed writeup."
// @from(Start 14457823, End 14458035)
Pn = L(() => {
  c5();
  PV();
  U2();
  Nh1();
  YS();
  wF();
  kt();
  _8();
  xzA();
  cE();
  dH();
  AZ();
  Gx();
  cQ();
  yR();
  _WA();
  u2();
  _v3 = {
    low: 45,
    medium: 75,
    high: 99
  }
})
// @from(Start 14458084, End 14458810)
function o11(A) {
  let Q = {},
    B = process.env.CLAUDE_CODE_EXTRA_BODY,
    G = {};
  if (B) try {
    let I = f7(B);
    if (I && typeof I === "object" && !Array.isArray(I)) G = I;
    else g(`CLAUDE_CODE_EXTRA_BODY env var must be a JSON object, but was given ${B}`, {
      level: "error"
    })
  } catch (I) {
    g(`Error parsing CLAUDE_CODE_EXTRA_BODY: ${I instanceof Error?I.message:String(I)}`, {
      level: "error"
    })
  }
  let Z = {
    ...Q,
    ...G
  };
  if (A && A.length > 0)
    if (Z.anthropic_beta && Array.isArray(Z.anthropic_beta)) {
      let I = Z.anthropic_beta,
        Y = A.filter((J) => !I.includes(J));
      Z.anthropic_beta = [...I, ...Y]
    } else Z.anthropic_beta = A;
  return Z
}
// @from(Start 14458812, End 14459210)
function UE9(A) {
  if (Y0(process.env.DISABLE_PROMPT_CACHING)) return !1;
  if (Y0(process.env.DISABLE_PROMPT_CACHING_HAIKU)) {
    let Q = MW();
    if (A === Q) return !1
  }
  if (Y0(process.env.DISABLE_PROMPT_CACHING_SONNET)) {
    let Q = XU();
    if (A === Q) return !1
  }
  if (Y0(process.env.DISABLE_PROMPT_CACHING_OPUS)) {
    let Q = wUA();
    if (A === Q) return !1
  }
  return !0
}
// @from(Start 14459212, End 14459367)
function jSA() {
  return BZ("prompt_cache_1h_experiment", "use_1h_cache", !1) ? {
    type: "ephemeral",
    ttl: "1h"
  } : {
    type: "ephemeral"
  }
}
// @from(Start 14459369, End 14459403)
function hv3(A, Q, B) {
  return
}
// @from(Start 14459405, End 14459551)
function Rl() {
  let A = hb(),
    Q = t6()?.accountUuid ?? "",
    B = e1();
  return {
    user_id: `user_${A}_account_${Q}_session_${B}`
  }
}
// @from(Start 14459552, End 14460379)
async function V69(A, Q) {
  if (Q) return !0;
  try {
    let B = MW(),
      G = Dw(B);
    return await YY2(t61(() => Kq({
      apiKey: A,
      maxRetries: 3,
      model: B
    }), async (Z) => {
      let I = [{
        role: "user",
        content: "test"
      }];
      return await Z.beta.messages.create({
        model: B,
        max_tokens: 1,
        messages: I,
        temperature: 1,
        ...G.length > 0 ? {
          betas: G
        } : {},
        metadata: Rl(),
        ...o11()
      }), !0
    }, {
      maxRetries: 2,
      model: B
    }))
  } catch (B) {
    let G = B;
    if (B instanceof Kn) G = B.originalError;
    if (AA(G), G instanceof Error && G.message.includes('{"type":"error","error":{"type":"authentication_error","message":"invalid x-api-key"}}')) return !1;
    throw G
  }
}
// @from(Start 14460381, End 14460936)
function gv3(A, Q = !1, B) {
  if (Q)
    if (typeof A.message.content === "string") return {
      role: "user",
      content: [{
        type: "text",
        text: A.message.content,
        ...B ? {
          cache_control: jSA()
        } : {}
      }]
    };
    else return {
      role: "user",
      content: A.message.content.map((G, Z) => ({
        ...G,
        ...Z === A.message.content.length - 1 ? B ? {
          cache_control: jSA()
        } : {} : {}
      }))
    };
  return {
    role: "user",
    content: A.message.content
  }
}
// @from(Start 14460938, End 14461567)
function uv3(A, Q = !1, B) {
  if (Q)
    if (typeof A.message.content === "string") return {
      role: "assistant",
      content: [{
        type: "text",
        text: A.message.content,
        ...B ? {
          cache_control: jSA()
        } : {}
      }]
    };
    else return {
      role: "assistant",
      content: A.message.content.map((G, Z) => ({
        ...G,
        ...Z === A.message.content.length - 1 && G.type !== "thinking" && G.type !== "redacted_thinking" ? B ? {
          cache_control: jSA()
        } : {} : {}
      }))
    };
  return {
    role: "assistant",
    content: A.message.content
  }
}
// @from(Start 14461568, End 14461886)
async function wy({
  messages: A,
  systemPrompt: Q,
  maxThinkingTokens: B,
  tools: G,
  signal: Z,
  options: I
}) {
  let Y;
  for await (let J of Ao1(A, async function*() {
    yield* $E9(A, Q, B, G, Z, I)
  })) if (J.type === "assistant") Y = J;
  if (!Y) throw Error("No assistant message found");
  return Y
}
// @from(Start 14461887, End 14462092)
async function* RYA({
  messages: A,
  systemPrompt: Q,
  maxThinkingTokens: B,
  tools: G,
  signal: Z,
  options: I
}) {
  return yield* Ao1(A, async function*() {
    yield* $E9(A, Q, B, G, Z, I)
  })
}
// @from(Start 14625750, End 14659683)
Pz9 = z((cf3) => {
  var hf3 = UA("node:events").EventEmitter,
    mK0 = UA("node:child_process"),
    Zu = UA("node:path"),
    dK0 = UA("node:fs"),
    eJ = UA("node:process"),
    {
      Argument: gf3,
      humanReadableArgName: uf3
    } = bJ1(),
    {
      CommanderError: cK0
    } = hSA(),
    {
      Help: mf3
    } = gK0(),
    {
      Option: Oz9,
      DualOptions: df3
    } = uK0(),
    {
      suggestSimilar: Rz9
    } = Mz9();
  class pK0 extends hf3 {
    constructor(A) {
      super();
      this.commands = [], this.options = [], this.parent = null, this._allowUnknownOption = !1, this._allowExcessArguments = !0, this.registeredArguments = [], this._args = this.registeredArguments, this.args = [], this.rawArgs = [], this.processedArgs = [], this._scriptPath = null, this._name = A || "", this._optionValues = {}, this._optionValueSources = {}, this._storeOptionsAsProperties = !1, this._actionHandler = null, this._executableHandler = !1, this._executableFile = null, this._executableDir = null, this._defaultCommandName = null, this._exitCallback = null, this._aliases = [], this._combineFlagAndOptionalValue = !0, this._description = "", this._summary = "", this._argsDescription = void 0, this._enablePositionalOptions = !1, this._passThroughOptions = !1, this._lifeCycleHooks = {}, this._showHelpAfterError = !1, this._showSuggestionAfterError = !0, this._outputConfiguration = {
        writeOut: (Q) => eJ.stdout.write(Q),
        writeErr: (Q) => eJ.stderr.write(Q),
        getOutHelpWidth: () => eJ.stdout.isTTY ? eJ.stdout.columns : void 0,
        getErrHelpWidth: () => eJ.stderr.isTTY ? eJ.stderr.columns : void 0,
        outputError: (Q, B) => B(Q)
      }, this._hidden = !1, this._helpOption = void 0, this._addImplicitHelpCommand = void 0, this._helpCommand = void 0, this._helpConfiguration = {}
    }
    copyInheritedSettings(A) {
      return this._outputConfiguration = A._outputConfiguration, this._helpOption = A._helpOption, this._helpCommand = A._helpCommand, this._helpConfiguration = A._helpConfiguration, this._exitCallback = A._exitCallback, this._storeOptionsAsProperties = A._storeOptionsAsProperties, this._combineFlagAndOptionalValue = A._combineFlagAndOptionalValue, this._allowExcessArguments = A._allowExcessArguments, this._enablePositionalOptions = A._enablePositionalOptions, this._showHelpAfterError = A._showHelpAfterError, this._showSuggestionAfterError = A._showSuggestionAfterError, this
    }
    _getCommandAndAncestors() {
      let A = [];
      for (let Q = this; Q; Q = Q.parent) A.push(Q);
      return A
    }
    command(A, Q, B) {
      let G = Q,
        Z = B;
      if (typeof G === "object" && G !== null) Z = G, G = null;
      Z = Z || {};
      let [, I, Y] = A.match(/([^ ]+) *(.*)/), J = this.createCommand(I);
      if (G) J.description(G), J._executableHandler = !0;
      if (Z.isDefault) this._defaultCommandName = J._name;
      if (J._hidden = !!(Z.noHelp || Z.hidden), J._executableFile = Z.executableFile || null, Y) J.arguments(Y);
      if (this._registerCommand(J), J.parent = this, J.copyInheritedSettings(this), G) return this;
      return J
    }
    createCommand(A) {
      return new pK0(A)
    }
    createHelp() {
      return Object.assign(new mf3, this.configureHelp())
    }
    configureHelp(A) {
      if (A === void 0) return this._helpConfiguration;
      return this._helpConfiguration = A, this
    }
    configureOutput(A) {
      if (A === void 0) return this._outputConfiguration;
      return Object.assign(this._outputConfiguration, A), this
    }
    showHelpAfterError(A = !0) {
      if (typeof A !== "string") A = !!A;
      return this._showHelpAfterError = A, this
    }
    showSuggestionAfterError(A = !0) {
      return this._showSuggestionAfterError = !!A, this
    }
    addCommand(A, Q) {
      if (!A._name) throw Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      if (Q = Q || {}, Q.isDefault) this._defaultCommandName = A._name;
      if (Q.noHelp || Q.hidden) A._hidden = !0;
      return this._registerCommand(A), A.parent = this, A._checkForBrokenPassThrough(), this
    }
    createArgument(A, Q) {
      return new gf3(A, Q)
    }
    argument(A, Q, B, G) {
      let Z = this.createArgument(A, Q);
      if (typeof B === "function") Z.default(G).argParser(B);
      else Z.default(B);
      return this.addArgument(Z), this
    }
    arguments(A) {
      return A.trim().split(/ +/).forEach((Q) => {
        this.argument(Q)
      }), this
    }
    addArgument(A) {
      let Q = this.registeredArguments.slice(-1)[0];
      if (Q && Q.variadic) throw Error(`only the last argument can be variadic '${Q.name()}'`);
      if (A.required && A.defaultValue !== void 0 && A.parseArg === void 0) throw Error(`a default value for a required argument is never used: '${A.name()}'`);
      return this.registeredArguments.push(A), this
    }
    helpCommand(A, Q) {
      if (typeof A === "boolean") return this._addImplicitHelpCommand = A, this;
      A = A ?? "help [command]";
      let [, B, G] = A.match(/([^ ]+) *(.*)/), Z = Q ?? "display help for command", I = this.createCommand(B);
      if (I.helpOption(!1), G) I.arguments(G);
      if (Z) I.description(Z);
      return this._addImplicitHelpCommand = !0, this._helpCommand = I, this
    }
    addHelpCommand(A, Q) {
      if (typeof A !== "object") return this.helpCommand(A, Q), this;
      return this._addImplicitHelpCommand = !0, this._helpCommand = A, this
    }
    _getHelpCommand() {
      if (this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help"))) {
        if (this._helpCommand === void 0) this.helpCommand(void 0, void 0);
        return this._helpCommand
      }
      return null
    }
    hook(A, Q) {
      let B = ["preSubcommand", "preAction", "postAction"];
      if (!B.includes(A)) throw Error(`Unexpected value for event passed to hook : '${A}'.
Expecting one of '${B.join("', '")}'`);
      if (this._lifeCycleHooks[A]) this._lifeCycleHooks[A].push(Q);
      else this._lifeCycleHooks[A] = [Q];
      return this
    }
    exitOverride(A) {
      if (A) this._exitCallback = A;
      else this._exitCallback = (Q) => {
        if (Q.code !== "commander.executeSubCommandAsync") throw Q
      };
      return this
    }
    _exit(A, Q, B) {
      if (this._exitCallback) this._exitCallback(new cK0(A, Q, B));
      eJ.exit(A)
    }
    action(A) {
      let Q = (B) => {
        let G = this.registeredArguments.length,
          Z = B.slice(0, G);
        if (this._storeOptionsAsProperties) Z[G] = this;
        else Z[G] = this.opts();
        return Z.push(this), A.apply(this, Z)
      };
      return this._actionHandler = Q, this
    }
    createOption(A, Q) {
      return new Oz9(A, Q)
    }
    _callParseArg(A, Q, B, G) {
      try {
        return A.parseArg(Q, B)
      } catch (Z) {
        if (Z.code === "commander.invalidArgument") {
          let I = `${G} ${Z.message}`;
          this.error(I, {
            exitCode: Z.exitCode,
            code: Z.code
          })
        }
        throw Z
      }
    }
    _registerOption(A) {
      let Q = A.short && this._findOption(A.short) || A.long && this._findOption(A.long);
      if (Q) {
        let B = A.long && this._findOption(A.long) ? A.long : A.short;
        throw Error(`Cannot add option '${A.flags}'${this._name&&` to command '${this._name}'`} due to conflicting flag '${B}'
-  already used by option '${Q.flags}'`)
      }
      this.options.push(A)
    }
    _registerCommand(A) {
      let Q = (G) => {
          return [G.name()].concat(G.aliases())
        },
        B = Q(A).find((G) => this._findCommand(G));
      if (B) {
        let G = Q(this._findCommand(B)).join("|"),
          Z = Q(A).join("|");
        throw Error(`cannot add command '${Z}' as already have command '${G}'`)
      }
      this.commands.push(A)
    }
    addOption(A) {
      this._registerOption(A);
      let Q = A.name(),
        B = A.attributeName();
      if (A.negate) {
        let Z = A.long.replace(/^--no-/, "--");
        if (!this._findOption(Z)) this.setOptionValueWithSource(B, A.defaultValue === void 0 ? !0 : A.defaultValue, "default")
      } else if (A.defaultValue !== void 0) this.setOptionValueWithSource(B, A.defaultValue, "default");
      let G = (Z, I, Y) => {
        if (Z == null && A.presetArg !== void 0) Z = A.presetArg;
        let J = this.getOptionValue(B);
        if (Z !== null && A.parseArg) Z = this._callParseArg(A, Z, J, I);
        else if (Z !== null && A.variadic) Z = A._concatValue(Z, J);
        if (Z == null)
          if (A.negate) Z = !1;
          else if (A.isBoolean() || A.optional) Z = !0;
        else Z = "";
        this.setOptionValueWithSource(B, Z, Y)
      };
      if (this.on("option:" + Q, (Z) => {
          let I = `error: option '${A.flags}' argument '${Z}' is invalid.`;
          G(Z, I, "cli")
        }), A.envVar) this.on("optionEnv:" + Q, (Z) => {
        let I = `error: option '${A.flags}' value '${Z}' from env '${A.envVar}' is invalid.`;
        G(Z, I, "env")
      });
      return this
    }
    _optionEx(A, Q, B, G, Z) {
      if (typeof Q === "object" && Q instanceof Oz9) throw Error("To add an Option object use addOption() instead of option() or requiredOption()");
      let I = this.createOption(Q, B);
      if (I.makeOptionMandatory(!!A.mandatory), typeof G === "function") I.default(Z).argParser(G);
      else if (G instanceof RegExp) {
        let Y = G;
        G = (J, W) => {
          let X = Y.exec(J);
          return X ? X[0] : W
        }, I.default(Z).argParser(G)
      } else I.default(G);
      return this.addOption(I)
    }
    option(A, Q, B, G) {
      return this._optionEx({}, A, Q, B, G)
    }
    requiredOption(A, Q, B, G) {
      return this._optionEx({
        mandatory: !0
      }, A, Q, B, G)
    }
    combineFlagAndOptionalValue(A = !0) {
      return this._combineFlagAndOptionalValue = !!A, this
    }
    allowUnknownOption(A = !0) {
      return this._allowUnknownOption = !!A, this
    }
    allowExcessArguments(A = !0) {
      return this._allowExcessArguments = !!A, this
    }
    enablePositionalOptions(A = !0) {
      return this._enablePositionalOptions = !!A, this
    }
    passThroughOptions(A = !0) {
      return this._passThroughOptions = !!A, this._checkForBrokenPassThrough(), this
    }
    _checkForBrokenPassThrough() {
      if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) throw Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`)
    }
    storeOptionsAsProperties(A = !0) {
      if (this.options.length) throw Error("call .storeOptionsAsProperties() before adding options");
      if (Object.keys(this._optionValues).length) throw Error("call .storeOptionsAsProperties() before setting option values");
      return this._storeOptionsAsProperties = !!A, this
    }
    getOptionValue(A) {
      if (this._storeOptionsAsProperties) return this[A];
      return this._optionValues[A]
    }
    setOptionValue(A, Q) {
      return this.setOptionValueWithSource(A, Q, void 0)
    }
    setOptionValueWithSource(A, Q, B) {
      if (this._storeOptionsAsProperties) this[A] = Q;
      else this._optionValues[A] = Q;
      return this._optionValueSources[A] = B, this
    }
    getOptionValueSource(A) {
      return this._optionValueSources[A]
    }
    getOptionValueSourceWithGlobals(A) {
      let Q;
      return this._getCommandAndAncestors().forEach((B) => {
        if (B.getOptionValueSource(A) !== void 0) Q = B.getOptionValueSource(A)
      }), Q
    }
    _prepareUserArgs(A, Q) {
      if (A !== void 0 && !Array.isArray(A)) throw Error("first parameter to parse must be array or undefined");
      if (Q = Q || {}, A === void 0 && Q.from === void 0) {
        if (eJ.versions?.electron) Q.from = "electron";
        let G = eJ.execArgv ?? [];
        if (G.includes("-e") || G.includes("--eval") || G.includes("-p") || G.includes("--print")) Q.from = "eval"
      }
      if (A === void 0) A = eJ.argv;
      this.rawArgs = A.slice();
      let B;
      switch (Q.from) {
        case void 0:
        case "node":
          this._scriptPath = A[1], B = A.slice(2);
          break;
        case "electron":
          if (eJ.defaultApp) this._scriptPath = A[1], B = A.slice(2);
          else B = A.slice(1);
          break;
        case "user":
          B = A.slice(0);
          break;
        case "eval":
          B = A.slice(1);
          break;
        default:
          throw Error(`unexpected parse option { from: '${Q.from}' }`)
      }
      if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
      return this._name = this._name || "program", B
    }
    parse(A, Q) {
      let B = this._prepareUserArgs(A, Q);
      return this._parseCommand([], B), this
    }
    async parseAsync(A, Q) {
      let B = this._prepareUserArgs(A, Q);
      return await this._parseCommand([], B), this
    }
    _executeSubCommand(A, Q) {
      Q = Q.slice();
      let B = !1,
        G = [".js", ".ts", ".tsx", ".mjs", ".cjs"];

      function Z(X, V) {
        let F = Zu.resolve(X, V);
        if (dK0.existsSync(F)) return F;
        if (G.includes(Zu.extname(V))) return;
        let K = G.find((D) => dK0.existsSync(`${F}${D}`));
        if (K) return `${F}${K}`;
        return
      }
      this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
      let I = A._executableFile || `${this._name}-${A._name}`,
        Y = this._executableDir || "";
      if (this._scriptPath) {
        let X;
        try {
          X = dK0.realpathSync(this._scriptPath)
        } catch (V) {
          X = this._scriptPath
        }
        Y = Zu.resolve(Zu.dirname(X), Y)
      }
      if (Y) {
        let X = Z(Y, I);
        if (!X && !A._executableFile && this._scriptPath) {
          let V = Zu.basename(this._scriptPath, Zu.extname(this._scriptPath));
          if (V !== this._name) X = Z(Y, `${V}-${A._name}`)
        }
        I = X || I
      }
      B = G.includes(Zu.extname(I));
      let J;
      if (eJ.platform !== "win32")
        if (B) Q.unshift(I), Q = Tz9(eJ.execArgv).concat(Q), J = mK0.spawn(eJ.argv[0], Q, {
          stdio: "inherit"
        });
        else J = mK0.spawn(I, Q, {
          stdio: "inherit"
        });
      else Q.unshift(I), Q = Tz9(eJ.execArgv).concat(Q), J = mK0.spawn(eJ.execPath, Q, {
        stdio: "inherit"
      });
      if (!J.killed)["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"].forEach((V) => {
        eJ.on(V, () => {
          if (J.killed === !1 && J.exitCode === null) J.kill(V)
        })
      });
      let W = this._exitCallback;
      J.on("close", (X) => {
        if (X = X ?? 1, !W) eJ.exit(X);
        else W(new cK0(X, "commander.executeSubCommandAsync", "(close)"))
      }), J.on("error", (X) => {
        if (X.code === "ENOENT") {
          let V = Y ? `searched for local subcommand relative to directory '${Y}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory",
            F = `'${I}' does not exist
 - if '${A._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${V}`;
          throw Error(F)
        } else if (X.code === "EACCES") throw Error(`'${I}' not executable`);
        if (!W) eJ.exit(1);
        else {
          let V = new cK0(1, "commander.executeSubCommandAsync", "(error)");
          V.nestedError = X, W(V)
        }
      }), this.runningCommand = J
    }
    _dispatchSubcommand(A, Q, B) {
      let G = this._findCommand(A);
      if (!G) this.help({
        error: !0
      });
      let Z;
      return Z = this._chainOrCallSubCommandHook(Z, G, "preSubcommand"), Z = this._chainOrCall(Z, () => {
        if (G._executableHandler) this._executeSubCommand(G, Q.concat(B));
        else return G._parseCommand(Q, B)
      }), Z
    }
    _dispatchHelpCommand(A) {
      if (!A) this.help();
      let Q = this._findCommand(A);
      if (Q && !Q._executableHandler) Q.help();
      return this._dispatchSubcommand(A, [], [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"])
    }
    _checkNumberOfArguments() {
      if (this.registeredArguments.forEach((A, Q) => {
          if (A.required && this.args[Q] == null) this.missingArgument(A.name())
        }), this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) return;
      if (this.args.length > this.registeredArguments.length) this._excessArguments(this.args)
    }
    _processArguments() {
      let A = (B, G, Z) => {
        let I = G;
        if (G !== null && B.parseArg) {
          let Y = `error: command-argument value '${G}' is invalid for argument '${B.name()}'.`;
          I = this._callParseArg(B, G, Z, Y)
        }
        return I
      };
      this._checkNumberOfArguments();
      let Q = [];
      this.registeredArguments.forEach((B, G) => {
        let Z = B.defaultValue;
        if (B.variadic) {
          if (G < this.args.length) {
            if (Z = this.args.slice(G), B.parseArg) Z = Z.reduce((I, Y) => {
              return A(B, Y, I)
            }, B.defaultValue)
          } else if (Z === void 0) Z = []
        } else if (G < this.args.length) {
          if (Z = this.args[G], B.parseArg) Z = A(B, Z, B.defaultValue)
        }
        Q[G] = Z
      }), this.processedArgs = Q
    }
    _chainOrCall(A, Q) {
      if (A && A.then && typeof A.then === "function") return A.then(() => Q());
      return Q()
    }
    _chainOrCallHooks(A, Q) {
      let B = A,
        G = [];
      if (this._getCommandAndAncestors().reverse().filter((Z) => Z._lifeCycleHooks[Q] !== void 0).forEach((Z) => {
          Z._lifeCycleHooks[Q].forEach((I) => {
            G.push({
              hookedCommand: Z,
              callback: I
            })
          })
        }), Q === "postAction") G.reverse();
      return G.forEach((Z) => {
        B = this._chainOrCall(B, () => {
          return Z.callback(Z.hookedCommand, this)
        })
      }), B
    }
    _chainOrCallSubCommandHook(A, Q, B) {
      let G = A;
      if (this._lifeCycleHooks[B] !== void 0) this._lifeCycleHooks[B].forEach((Z) => {
        G = this._chainOrCall(G, () => {
          return Z(this, Q)
        })
      });
      return G
    }
    _parseCommand(A, Q) {
      let B = this.parseOptions(Q);
      if (this._parseOptionsEnv(), this._parseOptionsImplied(), A = A.concat(B.operands), Q = B.unknown, this.args = A.concat(Q), A && this._findCommand(A[0])) return this._dispatchSubcommand(A[0], A.slice(1), Q);
      if (this._getHelpCommand() && A[0] === this._getHelpCommand().name()) return this._dispatchHelpCommand(A[1]);
      if (this._defaultCommandName) return this._outputHelpIfRequested(Q), this._dispatchSubcommand(this._defaultCommandName, A, Q);
      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) this.help({
        error: !0
      });
      this._outputHelpIfRequested(B.unknown), this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
      let G = () => {
          if (B.unknown.length > 0) this.unknownOption(B.unknown[0])
        },
        Z = `command:${this.name()}`;
      if (this._actionHandler) {
        G(), this._processArguments();
        let I;
        if (I = this._chainOrCallHooks(I, "preAction"), I = this._chainOrCall(I, () => this._actionHandler(this.processedArgs)), this.parent) I = this._chainOrCall(I, () => {
          this.parent.emit(Z, A, Q)
        });
        return I = this._chainOrCallHooks(I, "postAction"), I
      }
      if (this.parent && this.parent.listenerCount(Z)) G(), this._processArguments(), this.parent.emit(Z, A, Q);
      else if (A.length) {
        if (this._findCommand("*")) return this._dispatchSubcommand("*", A, Q);
        if (this.listenerCount("command:*")) this.emit("command:*", A, Q);
        else if (this.commands.length) this.unknownCommand();
        else G(), this._processArguments()
      } else if (this.commands.length) G(), this.help({
        error: !0
      });
      else G(), this._processArguments()
    }
    _findCommand(A) {
      if (!A) return;
      return this.commands.find((Q) => Q._name === A || Q._aliases.includes(A))
    }
    _findOption(A) {
      return this.options.find((Q) => Q.is(A))
    }
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((A) => {
        A.options.forEach((Q) => {
          if (Q.mandatory && A.getOptionValue(Q.attributeName()) === void 0) A.missingMandatoryOptionValue(Q)
        })
      })
    }
    _checkForConflictingLocalOptions() {
      let A = this.options.filter((B) => {
        let G = B.attributeName();
        if (this.getOptionValue(G) === void 0) return !1;
        return this.getOptionValueSource(G) !== "default"
      });
      A.filter((B) => B.conflictsWith.length > 0).forEach((B) => {
        let G = A.find((Z) => B.conflictsWith.includes(Z.attributeName()));
        if (G) this._conflictingOption(B, G)
      })
    }
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((A) => {
        A._checkForConflictingLocalOptions()
      })
    }
    parseOptions(A) {
      let Q = [],
        B = [],
        G = Q,
        Z = A.slice();

      function I(J) {
        return J.length > 1 && J[0] === "-"
      }
      let Y = null;
      while (Z.length) {
        let J = Z.shift();
        if (J === "--") {
          if (G === B) G.push(J);
          G.push(...Z);
          break
        }
        if (Y && !I(J)) {
          this.emit(`option:${Y.name()}`, J);
          continue
        }
        if (Y = null, I(J)) {
          let W = this._findOption(J);
          if (W) {
            if (W.required) {
              let X = Z.shift();
              if (X === void 0) this.optionMissingArgument(W);
              this.emit(`option:${W.name()}`, X)
            } else if (W.optional) {
              let X = null;
              if (Z.length > 0 && !I(Z[0])) X = Z.shift();
              this.emit(`option:${W.name()}`, X)
            } else this.emit(`option:${W.name()}`);
            Y = W.variadic ? W : null;
            continue
          }
        }
        if (J.length > 2 && J[0] === "-" && J[1] !== "-") {
          let W = this._findOption(`-${J[1]}`);
          if (W) {
            if (W.required || W.optional && this._combineFlagAndOptionalValue) this.emit(`option:${W.name()}`, J.slice(2));
            else this.emit(`option:${W.name()}`), Z.unshift(`-${J.slice(2)}`);
            continue
          }
        }
        if (/^--[^=]+=/.test(J)) {
          let W = J.indexOf("="),
            X = this._findOption(J.slice(0, W));
          if (X && (X.required || X.optional)) {
            this.emit(`option:${X.name()}`, J.slice(W + 1));
            continue
          }
        }
        if (I(J)) G = B;
        if ((this._enablePositionalOptions || this._passThroughOptions) && Q.length === 0 && B.length === 0) {
          if (this._findCommand(J)) {
            if (Q.push(J), Z.length > 0) B.push(...Z);
            break
          } else if (this._getHelpCommand() && J === this._getHelpCommand().name()) {
            if (Q.push(J), Z.length > 0) Q.push(...Z);
            break
          } else if (this._defaultCommandName) {
            if (B.push(J), Z.length > 0) B.push(...Z);
            break
          }
        }
        if (this._passThroughOptions) {
          if (G.push(J), Z.length > 0) G.push(...Z);
          break
        }
        G.push(J)
      }
      return {
        operands: Q,
        unknown: B
      }
    }
    opts() {
      if (this._storeOptionsAsProperties) {
        let A = {},
          Q = this.options.length;
        for (let B = 0; B < Q; B++) {
          let G = this.options[B].attributeName();
          A[G] = G === this._versionOptionName ? this._version : this[G]
        }
        return A
      }
      return this._optionValues
    }
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce((A, Q) => Object.assign(A, Q.opts()), {})
    }
    error(A, Q) {
      if (this._outputConfiguration.outputError(`${A}
`, this._outputConfiguration.writeErr), typeof this._showHelpAfterError === "string") this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
      else if (this._showHelpAfterError) this._outputConfiguration.writeErr(`
`), this.outputHelp({
        error: !0
      });
      let B = Q || {},
        G = B.exitCode || 1,
        Z = B.code || "commander.error";
      this._exit(G, Z, A)
    }
    _parseOptionsEnv() {
      this.options.forEach((A) => {
        if (A.envVar && A.envVar in eJ.env) {
          let Q = A.attributeName();
          if (this.getOptionValue(Q) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(Q)))
            if (A.required || A.optional) this.emit(`optionEnv:${A.name()}`, eJ.env[A.envVar]);
            else this.emit(`optionEnv:${A.name()}`)
        }
      })
    }
    _parseOptionsImplied() {
      let A = new df3(this.options),
        Q = (B) => {
          return this.getOptionValue(B) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(B))
        };
      this.options.filter((B) => B.implied !== void 0 && Q(B.attributeName()) && A.valueFromOption(this.getOptionValue(B.attributeName()), B)).forEach((B) => {
        Object.keys(B.implied).filter((G) => !Q(G)).forEach((G) => {
          this.setOptionValueWithSource(G, B.implied[G], "implied")
        })
      })
    }
    missingArgument(A) {
      let Q = `error: missing required argument '${A}'`;
      this.error(Q, {
        code: "commander.missingArgument"
      })
    }
    optionMissingArgument(A) {
      let Q = `error: option '${A.flags}' argument missing`;
      this.error(Q, {
        code: "commander.optionMissingArgument"
      })
    }
    missingMandatoryOptionValue(A) {
      let Q = `error: required option '${A.flags}' not specified`;
      this.error(Q, {
        code: "commander.missingMandatoryOptionValue"
      })
    }
    _conflictingOption(A, Q) {
      let B = (I) => {
          let Y = I.attributeName(),
            J = this.getOptionValue(Y),
            W = this.options.find((V) => V.negate && Y === V.attributeName()),
            X = this.options.find((V) => !V.negate && Y === V.attributeName());
          if (W && (W.presetArg === void 0 && J === !1 || W.presetArg !== void 0 && J === W.presetArg)) return W;
          return X || I
        },
        G = (I) => {
          let Y = B(I),
            J = Y.attributeName();
          if (this.getOptionValueSource(J) === "env") return `environment variable '${Y.envVar}'`;
          return `option '${Y.flags}'`
        },
        Z = `error: ${G(A)} cannot be used with ${G(Q)}`;
      this.error(Z, {
        code: "commander.conflictingOption"
      })
    }
    unknownOption(A) {
      if (this._allowUnknownOption) return;
      let Q = "";
      if (A.startsWith("--") && this._showSuggestionAfterError) {
        let G = [],
          Z = this;
        do {
          let I = Z.createHelp().visibleOptions(Z).filter((Y) => Y.long).map((Y) => Y.long);
          G = G.concat(I), Z = Z.parent
        } while (Z && !Z._enablePositionalOptions);
        Q = Rz9(A, G)
      }
      let B = `error: unknown option '${A}'${Q}`;
      this.error(B, {
        code: "commander.unknownOption"
      })
    }
    _excessArguments(A) {
      if (this._allowExcessArguments) return;
      let Q = this.registeredArguments.length,
        B = Q === 1 ? "" : "s",
        Z = `error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${Q} argument${B} but got ${A.length}.`;
      this.error(Z, {
        code: "commander.excessArguments"
      })
    }
    unknownCommand() {
      let A = this.args[0],
        Q = "";
      if (this._showSuggestionAfterError) {
        let G = [];
        this.createHelp().visibleCommands(this).forEach((Z) => {
          if (G.push(Z.name()), Z.alias()) G.push(Z.alias())
        }), Q = Rz9(A, G)
      }
      let B = `error: unknown command '${A}'${Q}`;
      this.error(B, {
        code: "commander.unknownCommand"
      })
    }
    version(A, Q, B) {
      if (A === void 0) return this._version;
      this._version = A, Q = Q || "-V, --version", B = B || "output the version number";
      let G = this.createOption(Q, B);
      return this._versionOptionName = G.attributeName(), this._registerOption(G), this.on("option:" + G.name(), () => {
        this._outputConfiguration.writeOut(`${A}
`), this._exit(0, "commander.version", A)
      }), this
    }
    description(A, Q) {
      if (A === void 0 && Q === void 0) return this._description;
      if (this._description = A, Q) this._argsDescription = Q;
      return this
    }
    summary(A) {
      if (A === void 0) return this._summary;
      return this._summary = A, this
    }
    alias(A) {
      if (A === void 0) return this._aliases[0];
      let Q = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) Q = this.commands[this.commands.length - 1];
      if (A === Q._name) throw Error("Command alias can't be the same as its name");
      let B = this.parent?._findCommand(A);
      if (B) {
        let G = [B.name()].concat(B.aliases()).join("|");
        throw Error(`cannot add alias '${A}' to command '${this.name()}' as already have command '${G}'`)
      }
      return Q._aliases.push(A), this
    }
    aliases(A) {
      if (A === void 0) return this._aliases;
      return A.forEach((Q) => this.alias(Q)), this
    }
    usage(A) {
      if (A === void 0) {
        if (this._usage) return this._usage;
        let Q = this.registeredArguments.map((B) => {
          return uf3(B)
        });
        return [].concat(this.options.length || this._helpOption !== null ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? Q : []).join(" ")
      }
      return this._usage = A, this
    }
    name(A) {
      if (A === void 0) return this._name;
      return this._name = A, this
    }
    nameFromFilename(A) {
      return this._name = Zu.basename(A, Zu.extname(A)), this
    }
    executableDir(A) {
      if (A === void 0) return this._executableDir;
      return this._executableDir = A, this
    }
    helpInformation(A) {
      let Q = this.createHelp();
      if (Q.helpWidth === void 0) Q.helpWidth = A && A.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
      return Q.formatHelp(this, Q)
    }
    _getHelpContext(A) {
      A = A || {};
      let Q = {
          error: !!A.error
        },
        B;
      if (Q.error) B = (G) => this._outputConfiguration.writeErr(G);
      else B = (G) => this._outputConfiguration.writeOut(G);
      return Q.write = A.write || B, Q.command = this, Q
    }
    outputHelp(A) {
      let Q;
      if (typeof A === "function") Q = A, A = void 0;
      let B = this._getHelpContext(A);
      this._getCommandAndAncestors().reverse().forEach((Z) => Z.emit("beforeAllHelp", B)), this.emit("beforeHelp", B);
      let G = this.helpInformation(B);
      if (Q) {
        if (G = Q(G), typeof G !== "string" && !Buffer.isBuffer(G)) throw Error("outputHelp callback must return a string or a Buffer")
      }
      if (B.write(G), this._getHelpOption()?.long) this.emit(this._getHelpOption().long);
      this.emit("afterHelp", B), this._getCommandAndAncestors().forEach((Z) => Z.emit("afterAllHelp", B))
    }
    helpOption(A, Q) {
      if (typeof A === "boolean") {
        if (A) this._helpOption = this._helpOption ?? void 0;
        else this._helpOption = null;
        return this
      }
      return A = A ?? "-h, --help", Q = Q ?? "display help for command", this._helpOption = this.createOption(A, Q), this
    }
    _getHelpOption() {
      if (this._helpOption === void 0) this.helpOption(void 0, void 0);
      return this._helpOption
    }
    addHelpOption(A) {
      return this._helpOption = A, this
    }
    help(A) {
      this.outputHelp(A);
      let Q = eJ.exitCode || 0;
      if (Q === 0 && A && typeof A !== "function" && A.error) Q = 1;
      this._exit(Q, "commander.help", "(outputHelp)")
    }
    addHelpText(A, Q) {
      let B = ["beforeAll", "before", "after", "afterAll"];
      if (!B.includes(A)) throw Error(`Unexpected value for position to addHelpText.
Expecting one of '${B.join("', '")}'`);
      let G = `${A}Help`;
      return this.on(G, (Z) => {
        let I;
        if (typeof Q === "function") I = Q({
          error: Z.error,
          command: Z.command
        });
        else I = Q;
        if (I) Z.write(`${I}
`)
      }), this
    }
    _outputHelpIfRequested(A) {
      let Q = this._getHelpOption();
      if (Q && A.find((G) => Q.is(G))) this.outputHelp(), this._exit(0, "commander.helpDisplayed", "(outputHelp)")
    }
  }

  function Tz9(A) {
    return A.map((Q) => {
      if (!Q.startsWith("--inspect")) return Q;
      let B, G = "127.0.0.1",
        Z = "9229",
        I;
      if ((I = Q.match(/^(--inspect(-brk)?)$/)) !== null) B = I[1];
      else if ((I = Q.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null)
        if (B = I[1], /^\d+$/.test(I[3])) Z = I[3];
        else G = I[3];
      else if ((I = Q.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) B = I[1], G = I[3], Z = I[4];
      if (B && Z !== "0") return `${B}=${G}:${parseInt(Z)+1}`;
      return Q
    })
  }
  cf3.Command = pK0
})
// @from(Start 14659689, End 14660253)
kz9 = z((nf3) => {
  var {
    Argument: jz9
  } = bJ1(), {
    Command: lK0
  } = Pz9(), {
    CommanderError: lf3,
    InvalidArgumentError: Sz9
  } = hSA(), {
    Help: if3
  } = gK0(), {
    Option: _z9
  } = uK0();
  nf3.program = new lK0;
  nf3.createCommand = (A) => new lK0(A);
  nf3.createOption = (A, Q) => new _z9(A, Q);
  nf3.createArgument = (A, Q) => new jz9(A, Q);
  nf3.Command = lK0;
  nf3.Option = _z9;
  nf3.Argument = jz9;
  nf3.Help = if3;
  nf3.CommanderError = lf3;
  nf3.InvalidArgumentError = Sz9;
  nf3.InvalidOptionArgumentError = Sz9
})
// @from(Start 14660259, End 14660765)
xz9 = z((VN, yz9) => {
  var Jj = kz9();
  VN = yz9.exports = {};
  VN.program = new Jj.Command;
  VN.Argument = Jj.Argument;
  VN.Command = Jj.Command;
  VN.CommanderError = Jj.CommanderError;
  VN.Help = Jj.Help;
  VN.InvalidArgumentError = Jj.InvalidArgumentError;
  VN.InvalidOptionArgumentError = Jj.InvalidArgumentError;
  VN.Option = Jj.Option;
  VN.createCommand = (A) => new Jj.Command(A);
  VN.createOption = (A, Q) => new Jj.Option(A, Q);
  VN.createArgument = (A, Q) => new Jj.Argument(A, Q)
})
// @from(Start 14660771, End 14660774)
vz9
// @from(Start 14660776, End 14660779)
YRI
// @from(Start 14660781, End 14660784)
JRI
// @from(Start 14660786, End 14660789)
WRI
// @from(Start 14660791, End 14660794)
XRI
// @from(Start 14660796, End 14660799)
VRI
// @from(Start 14660801, End 14660804)
FRI
// @from(Start 14660806, End 14660809)
KRI
// @from(Start 14660811, End 14660814)
fJ1
// @from(Start 14660816, End 14660819)
DRI
// @from(Start 14660821, End 14660823)
BF
// @from(Start 14660825, End 14660828)
HRI
// @from(Start 14660834, End 14661144)
iK0 = L(() => {
  vz9 = BA(xz9(), 1), {
    program: YRI,
    createCommand: JRI,
    createArgument: WRI,
    createOption: XRI,
    CommanderError: VRI,
    InvalidArgumentError: FRI,
    InvalidOptionArgumentError: KRI,
    Command: fJ1,
    Argument: DRI,
    Option: BF,
    Help: HRI
  } = vz9.default
})
// @from(Start 14661147, End 14661555)
function hJ1(A) {
  return A.map((Q) => ({
    name: n7(Q.name),
    type: Q.type,
    hasTools: Q.type === "connected" && Q.capabilities?.tools !== void 0,
    hasResources: Q.type === "connected" && Q.capabilities?.resources !== void 0,
    hasPrompts: Q.type === "connected" && Q.capabilities?.prompts !== void 0,
    serverInfo: Q.type === "connected" && "serverInfo" in Q ? Q.serverInfo : void 0
  }))
}
// @from(Start 14661560, End 14661574)
nK0 = () => {}
// @from(Start 14661577, End 14661980)
function gJ1(A, Q) {
  let B = Q?.server,
    G = B ? n7(B) : void 0,
    Z = G ? `mcp__${G}__` : "mcp__";
  return A.filter((Y) => Y.name.startsWith(Z)).map((Y) => {
    let J = mU(Y.name);
    return {
      server: J?.serverName || "unknown",
      name: J?.toolName || Y.name,
      description: typeof Y.description === "function" ? void 0 : Y.description || "",
      fullName: Y.name
    }
  })
}
// @from(Start 14661985, End 14662010)
aK0 = L(() => {
  nX()
})
// @from(Start 14662012, End 14662547)
async function uJ1(A, {
  server: Q,
  toolName: B
}) {
  let G = A.find((I) => I.name === `mcp__${Q}__${B}`);
  if (!G) return null;
  let Z = "";
  if (typeof G.description === "string") Z = G.description;
  else if (typeof G.description === "function") try {
    Z = await G.description({}, {
      isNonInteractiveSession: !0,
      toolPermissionContext: ZE(),
      tools: []
    }) || ""
  } catch {}
  return {
    server: Q,
    name: B,
    fullName: G.name,
    description: Z,
    inputSchema: G.inputJSONSchema || {}
  }
}
// @from(Start 14662552, End 14662566)
sK0 = () => {}
// @from(Start 14662569, End 14663169)
function mJ1(A, {
  pattern: Q,
  ignoreCase: B
}) {
  let G;
  try {
    G = new RegExp(Q, B ? "i" : "")
  } catch (Y) {
    throw Error(`Invalid regex pattern: ${Y instanceof Error?Y.message:String(Y)}`)
  }
  let Z = A.filter((Y) => Y.name.startsWith("mcp__")),
    I = [];
  for (let Y of Z) {
    let J = mU(Y.name),
      W = J?.serverName || "unknown",
      X = J?.toolName || Y.name,
      V = typeof Y.description === "string" ? Y.description : "";
    if (G.test(X) || G.test(V)) I.push({
      server: W,
      name: X,
      fullName: Y.name,
      description: V
    })
  }
  return I
}
// @from(Start 14663174, End 14663199)
rK0 = L(() => {
  nX()
})
// @from(Start 14663202, End 14663559)
function dJ1(A, Q, B) {
  let G = Q?.server;
  if (G) {
    let Z = A[G] || [],
      I = G;
    if (Z.length === 0 && B) {
      let Y = B[G];
      if (Y && A[Y]) Z = A[Y], I = Y
    }
    return Z.map((Y) => ({
      ...Y,
      server: n7(I)
    }))
  }
  return Object.entries(A).flatMap(([Z, I]) => I.map((Y) => ({
    ...Y,
    server: n7(Z)
  })))
}
// @from(Start 14663564, End 14663578)
oK0 = () => {}
// @from(Start 14663584, End 14663587)
Ih3
// @from(Start 14663589, End 14663592)
bz9
// @from(Start 14663594, End 14663597)
Yh3
// @from(Start 14663599, End 14663602)
fz9
// @from(Start 14663604, End 14663607)
Jh3
// @from(Start 14663609, End 14663612)
hz9
// @from(Start 14663614, End 14663617)
Wh3
// @from(Start 14663619, End 14663622)
Xh3
// @from(Start 14663624, End 14663627)
gz9
// @from(Start 14663629, End 14663632)
Vh3
// @from(Start 14663634, End 14663637)
uz9
// @from(Start 14663639, End 14663642)
Fh3
// @from(Start 14663644, End 14663647)
mz9
// @from(Start 14663653, End 14665692)
tK0 = L(() => {
  Q2();
  SD();
  Ih3 = j.object({
    command: j.literal("servers")
  }), bz9 = j.array(j.object({
    name: j.string(),
    type: j.string(),
    hasTools: j.boolean().optional(),
    hasResources: j.boolean().optional(),
    hasPrompts: j.boolean().optional(),
    serverInfo: j.object({
      name: j.string(),
      version: j.string()
    }).optional()
  })), Yh3 = j.object({
    command: j.literal("tools"),
    params: j.object({
      server: j.string().optional()
    }).optional()
  }), fz9 = j.array(j.object({
    server: j.string(),
    name: j.string(),
    description: j.string().optional(),
    fullName: j.string()
  })), Jh3 = j.object({
    command: j.literal("info"),
    params: j.object({
      server: j.string(),
      toolName: j.string()
    })
  }), hz9 = j.object({
    server: j.string(),
    name: j.string(),
    fullName: j.string(),
    description: j.string(),
    inputSchema: j.record(j.unknown())
  }).or(j.null()), Wh3 = j.object({
    command: j.literal("call"),
    params: j.object({
      server: j.string(),
      tool: j.string(),
      args: j.record(j.unknown()),
      timeoutMs: j.number().optional()
    })
  }), Xh3 = j.object({
    command: j.literal("grep"),
    params: j.object({
      pattern: j.string(),
      ignoreCase: j.boolean().optional()
    })
  }), gz9 = j.array(j.object({
    server: j.string(),
    name: j.string(),
    fullName: j.string(),
    description: j.string()
  })), Vh3 = j.object({
    command: j.literal("resources"),
    params: j.object({
      server: j.string().optional()
    }).optional()
  }), uz9 = j.array(j.object({
    uri: j.string(),
    name: j.string().optional(),
    description: j.string().optional(),
    mimeType: j.string().optional(),
    server: j.string()
  })), Fh3 = j.object({
    command: j.literal("read"),
    params: j.object({
      server: j.string(),
      uri: j.string(),
      timeoutMs: j.number().optional()
    })
  }), mz9 = j.discriminatedUnion("command", [Ih3, Yh3, Jh3, Wh3, Xh3, Vh3, Fh3])
})
// @from(Start 14665821, End 14665892)
function cJ1() {
  let A = SVA();
  return Kh3(Gu(), `${A}.endpoint`)
}
// @from(Start 14665894, End 14666100)
function pJ1(A) {
  if (A) eK0 = A;
  if (!eK0) return;
  Ch3(Gu(), {
    recursive: !0
  });
  let Q = cJ1(),
    B = Buffer.from(JSON.stringify(eK0)).toString("base64");
  Dh3(Q, B, {
    mode: 384
  })
}
// @from(Start 14666102, End 14666272)
function dz9() {
  let A = cJ1();
  try {
    let Q = Hh3(A, "utf-8");
    return JSON.parse(Buffer.from(Q, "base64").toString("utf-8"))
  } catch {
    return null
  }
}
// @from(Start 14666277, End 14666287)
eK0 = null
// @from(Start 14666293, End 14666319)
lJ1 = L(() => {
  _VA()
})
// @from(Start 14666322, End 14666477)
function gSA(A, Q, B) {
  let G = A.find((I) => I.name === Q);
  if (G) return G;
  let Z = B?.[Q];
  if (Z) return A.find((I) => I.name === Z);
  return
}
// @from(Start 14666479, End 14666728)
function tQA(A, Q) {
  if (!Q) return Error(`Server '${A}' not found`);
  if (Q !== "connected") return Error(`Server '${A}' is not connected (${Q==="needs-auth"?"needs authentication":Q}). Run '/mcp' to manage server connections.`);
  return null
}
// @from(Start 14666733, End 14666741)
az9 = {}
// @from(Start 14666934, End 14667201)
function Th3(A) {
  let Q;
  if (process.env.RIPGREP_NODE_PATH) Q = UA(process.env.RIPGREP_NODE_PATH).ripgrepMain;
  else {
    let B = Rh3(Oh3(Mh3(import.meta.url)), "ripgrep.node");
    Q = Lh3(import.meta.url)(B).ripgrepMain
  }
  return Q(["--no-config", ...A])
}
// @from(Start 14667206, End 14667220)
sz9 = () => {}
// @from(Start 14667278, End 14667643)
function Ph3() {
  let A = process.argv[1] || "",
    Q = process.execPath || process.argv[0] || "";
  if (dQ() === "windows") A = A.split(oz9.sep).join(rz9.sep), Q = Q.split(oz9.sep).join(rz9.sep);
  let B = [A, Q],
    G = ["/build-ant/", "/build-external/", "/build-external-native/", "/build-ant-native/"];
  return B.some((Z) => G.some((I) => Z.includes(I)))
}
// @from(Start 14667645, End 14667737)
function Sh3(A) {
  let Q = `${A.name}: ${A.message}`;
  return jh3.some((B) => B.test(Q))
}
// @from(Start 14667739, End 14668383)
function ez9() {
  let A = process.listeners("warning");
  if (iJ1 && A.includes(iJ1)) return;
  if (!Ph3()) process.removeAllListeners("warning");
  iJ1 = (B) => {
    try {
      let G = `${B.name}: ${B.message.slice(0,50)}`,
        Z = tz9.get(G) || 0;
      tz9.set(G, Z + 1);
      let I = Sh3(B);
      if (GA("tengu_node_warning", {
          is_internal: I ? 1 : 0,
          occurrence_count: Z + 1,
          classname: B.name,
          ...!1
        }), process.env.CLAUDE_DEBUG === "true") g(`${I?"[Internal Warning]":"[Warning]"} ${B.toString()}`, {
        level: "warn"
      })
    } catch {}
  }, process.on("warning", iJ1)
}
// @from(Start 14668388, End 14668391)
tz9
// @from(Start 14668393, End 14668396)
jh3
// @from(Start 14668398, End 14668408)
iJ1 = null
// @from(Start 14668414, End 14668570)
AU9 = L(() => {
  q0();
  V0();
  Q3();
  tz9 = new Map;
  jh3 = [/MaxListenersExceededWarning.*AbortSignal/, /MaxListenersExceededWarning.*EventTarget/]
})
// @from(Start 14668573, End 14668590)
function BU9() {}
// @from(Start 14668592, End 14668873)
function GU9() {
  let A = l0() || {},
    Q = N1().env || {},
    B = A.env || {};
  for (let [G, Z] of Object.entries(Q))
    if (QU9.has(G.toUpperCase())) process.env[G] = Z;
  for (let [G, Z] of Object.entries(B))
    if (QU9.has(G.toUpperCase())) process.env[G] = Z;
  BU9()
}
// @from(Start 14668875, End 14669003)
function BD0() {
  let A = l0() || {};
  Object.assign(process.env, N1().env), Object.assign(process.env, A.env), x4A(), BU9()
}
// @from(Start 14669008, End 14669011)
QU9
// @from(Start 14669017, End 14671229)
GD0 = L(() => {
  jQ();
  MB();
  CS();
  QU9 = new Set(["ANTHROPIC_API_KEY", "ANTHROPIC_AUTH_TOKEN", "ANTHROPIC_BASE_URL", "ANTHROPIC_CUSTOM_HEADERS", "ANTHROPIC_DEFAULT_HAIKU_MODEL", "ANTHROPIC_FOUNDRY_API_KEY", "ANTHROPIC_DEFAULT_OPUS_MODEL", "ANTHROPIC_DEFAULT_SONNET_MODEL", "ANTHROPIC_MODEL", "ANTHROPIC_SMALL_FAST_MODEL", "ANTHROPIC_SMALL_FAST_MODEL_AWS_REGION", "AWS_BEARER_TOKEN_BEDROCK", "AWS_DEFAULT_REGION", "AWS_PROFILE", "AWS_REGION", "BASH_DEFAULT_TIMEOUT_MS", "BASH_MAX_TIMEOUT_MS", "BASH_MAX_OUTPUT_LENGTH", "CLAUDE_BASH_MAINTAIN_PROJECT_WORKING_DIR", "CLAUDE_CODE_API_KEY_HELPER_TTL_MS", "CLAUDE_CODE_ENABLE_TELEMETRY", "CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL", "CLAUDE_CODE_MAX_OUTPUT_TOKENS", "CLAUDE_CODE_USE_BEDROCK", "CLAUDE_CODE_USE_FOUNDRY", "CLAUDE_CODE_USE_VERTEX", "CLAUDE_CODE_SKIP_BEDROCK_AUTH", "CLAUDE_CODE_SKIP_FOUNDRY_AUTH", "CLAUDE_CODE_SKIP_VERTEX_AUTH", "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC", "CLAUDE_CODE_DISABLE_TERMINAL_TITLE", "CLAUDE_CODE_SUBAGENT_MODEL", "DISABLE_AUTOUPDATER", "DISABLE_BUG_COMMAND", "DISABLE_COST_WARNINGS", "DISABLE_ERROR_REPORTING", "DISABLE_TELEMETRY", "HTTP_PROXY", "HTTPS_PROXY", "MAX_THINKING_TOKENS", "MCP_TIMEOUT", "MCP_TOOL_TIMEOUT", "MAX_MCP_OUTPUT_TOKENS", "NO_PROXY", "OTEL_EXPORTER_OTLP_ENDPOINT", "OTEL_EXPORTER_OTLP_HEADERS", "OTEL_EXPORTER_OTLP_LOGS_HEADERS", "OTEL_EXPORTER_OTLP_METRICS_HEADERS", "OTEL_EXPORTER_OTLP_TRACES_HEADERS", "OTEL_EXPORTER_OTLP_PROTOCOL", "OTEL_EXPORTER_OTLP_LOGS_PROTOCOL", "OTEL_EXPORTER_OTLP_LOGS_ENDPOINT", "OTEL_EXPORTER_OTLP_METRICS_PROTOCOL", "OTEL_EXPORTER_OTLP_METRICS_ENDPOINT", "OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY", "OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE", "OTEL_LOG_USER_PROMPTS", "OTEL_LOGS_EXPORTER", "OTEL_LOGS_EXPORT_INTERVAL", "OTEL_METRICS_INCLUDE_SESSION_ID", "OTEL_METRICS_INCLUDE_VERSION", "OTEL_METRICS_INCLUDE_ACCOUNT_UUID", "OTEL_METRICS_EXPORTER", "OTEL_METRIC_EXPORT_INTERVAL", "OTEL_RESOURCE_ATTRIBUTES", "USE_BUILTIN_RIPGREP", "VERTEX_REGION_CLAUDE_3_5_HAIKU", "VERTEX_REGION_CLAUDE_3_5_SONNET", "VERTEX_REGION_CLAUDE_3_7_SONNET", "VERTEX_REGION_CLAUDE_4_0_OPUS", "VERTEX_REGION_CLAUDE_4_0_SONNET", "VERTEX_REGION_CLAUDE_4_1_OPUS", "VERTEX_REGION_CLAUDE_HAIKU_4_5"])
})
// @from(Start 14671232, End 14672491)
function _h3({
  filePath: A,
  errorDescription: Q,
  onExit: B,
  onReset: G
}) {
  f1((Y, J) => {
    if (J.escape) B()
  });
  let Z = EQ();
  return PC.default.createElement(PC.default.Fragment, null, PC.default.createElement(S, {
    flexDirection: "column",
    borderColor: "error",
    borderStyle: "round",
    padding: 1,
    width: 70,
    gap: 1
  }, PC.default.createElement($, {
    bold: !0
  }, "Configuration Error"), PC.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, PC.default.createElement($, null, "The configuration file at ", PC.default.createElement($, {
    bold: !0
  }, A), " contains invalid JSON."), PC.default.createElement($, null, Q)), PC.default.createElement(S, {
    flexDirection: "column"
  }, PC.default.createElement($, {
    bold: !0
  }, "Choose an option:"), PC.default.createElement(M0, {
    options: [{
      label: "Exit and fix manually",
      value: "exit"
    }, {
      label: "Reset with default configuration",
      value: "reset"
    }],
    onChange: (Y) => {
      if (Y === "exit") B();
      else G()
    },
    onCancel: B
  }))), Z.pending ? PC.default.createElement($, {
    dimColor: !0
  }, "Press ", Z.keyName, " again to exit") : PC.default.createElement(bF, null))
}
// @from(Start 14672492, End 14673074)
async function ZU9({
  error: A
}) {
  let Q = {
    exitOnCtrlC: !1,
    theme: kh3
  };
  await new Promise(async (B) => {
    let {
      unmount: G
    } = await VG(PC.default.createElement(yG, null, PC.default.createElement(_h3, {
      filePath: A.filePath,
      errorDescription: A.message,
      onExit: () => {
        G(), B(), process.exit(1)
      },
      onReset: () => {
        RA().writeFileSync(A.filePath, JSON.stringify(A.defaultConfig, null, 2), {
          flush: !1,
          encoding: "utf8"
        }), G(), B(), process.exit(0)
      }
    })), Q)
  })
}
// @from(Start 14673079, End 14673081)
PC
// @from(Start 14673083, End 14673095)
kh3 = "dark"
// @from(Start 14673101, End 14673186)
IU9 = L(() => {
  hA();
  J5();
  hA();
  AQ();
  Q4();
  z9();
  PC = BA(VA(), 1)
})
// @from(Start 14673253, End 14673913)
async function YU9() {
  try {
    let A = await DO();
    if (!A) {
      g("Not in a GitHub repository, skipping path mapping update");
      return
    }
    let Q;
    try {
      Q = yh3(uQ())
    } catch {
      Q = uQ()
    }
    let B = A.toLowerCase(),
      G = N1(),
      Z = G.githubRepoPaths?.[B] ?? [];
    if (Z.includes(Q)) {
      g(`Path ${Q} already tracked for repo ${B}`);
      return
    }
    let I = [Q, ...Z];
    c0({
      ...G,
      githubRepoPaths: {
        ...G.githubRepoPaths,
        [B]: I
      }
    }), g(`Added ${Q} to tracked paths for repo ${B}`)
  } catch (A) {
    g(`Error updating repo path mapping: ${A}`)
  }
}
// @from(Start 14673915, End 14674013)
function JU9(A) {
  let Q = N1(),
    B = A.toLowerCase();
  return Q.githubRepoPaths?.[B] ?? []
}
// @from(Start 14674015, End 14674067)
function WU9(A) {
  return A.filter((Q) => xh3(Q))
}
// @from(Start 14674068, End 14674418)
async function XU9(A, Q) {
  try {
    let {
      stdout: B,
      code: G
    } = await A3("git", ["remote", "get-url", "origin"], {
      cwd: A,
      preserveOutputOnError: !1
    });
    if (G !== 0 || !B) return !1;
    let Z = dh(B.trim());
    if (!Z) return !1;
    return Z.toLowerCase() === Q.toLowerCase()
  } catch {
    return !1
  }
}
// @from(Start 14674420, End 14674783)
function VU9(A, Q) {
  let B = N1(),
    G = A.toLowerCase(),
    Z = B.githubRepoPaths?.[G] ?? [],
    I = Z.filter((J) => J !== Q);
  if (I.length === Z.length) return;
  let Y = {
    ...B.githubRepoPaths
  };
  if (I.length === 0) delete Y[G];
  else Y[G] = I;
  c0({
    ...B,
    githubRepoPaths: Y
  }), g(`Removed ${Q} from tracked paths for repo ${G}`)
}
// @from(Start 14674788, End 14674846)
nJ1 = L(() => {
  z0A();
  jQ();
  _0();
  V0();
  _8()
})
// @from(Start 14674849, End 14674904)
function KU9() {
  if (ZD0) return;
  DU9(), ZD0 = !0
}
// @from(Start 14674906, End 14675145)
function DU9() {
  let A = XO2();
  if (A) vE0(A, (B, G) => {
    let Z = A?.createCounter(B, G);
    return {
      add(I, Y = {}) {
        let W = {
          ...kJA(),
          ...Y
        };
        Z?.add(I, W)
      }
    }
  })
}
// @from(Start 14675150, End 14675158)
ZD0 = !1
// @from(Start 14675162, End 14675165)
FU9
// @from(Start 14675171, End 14676173)
HU9 = L(() => {
  js();
  _0();
  jQ();
  jQ();
  GD0();
  RZ();
  IU9();
  kW();
  HH();
  l2();
  _0();
  U80();
  CUA();
  W61();
  _c();
  v3A();
  H9A();
  qKA();
  gB();
  jQ();
  _0();
  AL();
  f60();
  nJ1();
  _VA();
  dH();
  lRA();
  FU9 = s1(() => {
    M9("init_function_start");
    try {
      PiA(), M9("init_configs_enabled"), GU9(), M9("init_safe_env_vars_applied"), fm.initialize(), M9("init_settings_detector_initialized"), AV9(), M9("init_after_graceful_shutdown"), JCB(), M9("init_after_1p_event_logging"), To0(), M9("init_after_oauth_populate");
      let A = uzA() && !TJ(!0) && !N6();
      if (M9("init_after_defer_check"), !A) DU9(), ZD0 = !0;
      if (M9("init_telemetry_setup"), G8B(), R4B(), _4B(), M9("init_network_configured"), Oh0(), Wj2(), YU9(), E_2(), PG(z_2), bZ()) process.env.CLAUDE_CODE_SESSION_ID = e1(), Iz9();
      M9("init_function_end")
    } catch (A) {
      if (A instanceof mz) return ZU9({
        error: A
      });
      else throw A
    }
  })
})
// @from(Start 14676222, End 14677737)
function CU9() {
  let A = !(Y0(process.env.CLAUDE_CODE_USE_BEDROCK) || Y0(process.env.CLAUDE_CODE_USE_VERTEX) || Y0(process.env.CLAUDE_CODE_USE_FOUNDRY) || process.env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC || process.env.DISABLE_ERROR_REPORTING);
  xa.init({
    dsn: Jr0,
    enabled: A,
    environment: "external",
    release: {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION,
    integrations: [new xa.Integrations.OnUncaughtException({
      exitEvenIfOtherHandlersAreRegistered: !1
    }), new xa.Integrations.OnUnhandledRejection({
      mode: "warn"
    }), new xa.Integrations.Http({
      tracing: !0
    }), xa.rewriteFramesIntegration()],
    tracesSampleRate: 1,
    tracePropagationTargets: ["localhost"],
    beforeSend(Q) {
      try {
        let B = vc();
        if (B.userID) {
          let G = vh3("sha256").update(B.userID).digest("hex");
          Q.user = {
            id: G
          }
        }
      } catch {}
      try {
        Q.tags = {
          ...Q.tags,
          terminal: d0.terminal,
          userType: "external",
          ..._CB()
        }
      } catch {}
      try {
        Q.extra = {
          ...Q.extra,
          sessionId: e1()
        }
      } catch {}
      return Q
    }
  })
}
// @from(Start 14677742, End 14677744)
xa
// @from(Start 14677750, End 14677828)
EU9 = L(() => {
  gb();
  c5();
  u2();
  _0();
  hQ();
  xa = BA(DJ0(), 1)
})
// @from(Start 14677869, End 14681343)
function fh3() {
  return `IMPORTANT: This message and these instructions are NOT part of the actual user conversation. Do NOT include any references to "note-taking", "session notes extraction", or these update instructions in the notes content.

Based on the user conversation above (EXCLUDING this note-taking instruction message as well as system prompt, claude.md entries, or any past session summaries), update the session notes file.

The file {{notesPath}} has already been read for you. Here are its current contents:
<current_notes_content>
{{currentNotes}}
</current_notes_content>

Your ONLY task is to use the Edit tool to update the notes file, then stop. You can make multiple edits (update every section as needed) - make all Edit tool calls in parallel in a single message. Do not call any other tools.

CRITICAL RULES FOR EDITING:
- The file must maintain its exact structure with all sections, headers, and italic descriptions intact
-- NEVER modify, delete, or add section headers (the lines starting with '#' like # Task specification)
-- NEVER modify or delete the italic _section description_ lines (these are the lines in italics immediately following each header - they start and end with underscores)
-- The italic _section descriptions_ are TEMPLATE INSTRUCTIONS that must be preserved exactly as-is - they guide what content belongs in each section
-- ONLY update the actual content that appears BELOW the italic _section descriptions_ within each existing section
-- Do NOT add any new sections, summaries, or information outside the existing structure
- Do NOT reference this note-taking process or instructions anywhere in the notes
- It's OK to skip updating a section if there are no substantial new insights to add. Do not add filler content like "No info yet", just leave sections blank/unedited if appropriate.
- Write DETAILED, INFO-DENSE content for each section - include specifics like file paths, function names, error messages, exact commands, technical details, etc.
- For "Key results", include the complete, exact output the user requested (e.g., full table, full answer, etc.)
- Do not include information that's already in the CLAUDE.md files included in the context
- Keep each section under ~${UU9} tokens/words - if a section is approaching this limit, condense it by cycling out less important details while preserving the most critical information
- Focus on actionable, specific information that would help someone understand or recreate the work discussed in the conversation
- IMPORTANT: Always update "Current State" to reflect the most recent work - this is critical for continuity after compaction

Use the Edit tool with file_path: {{notesPath}}

STRUCTURE PRESERVATION REMINDER:
Each section has TWO parts that must be preserved exactly as they appear in the current file:
1. The section header (line starting with #)
2. The italic description line (the _italicized text_ immediately after the header - this is a template instruction)

You ONLY update the actual content that comes AFTER these two preserved lines. The italic description lines starting and ending with underscores are part of the template structure, NOT content to be edited or removed.

REMEMBER: Use the Edit tool in parallel and stop. Do not continue after the edits. Only include insights from the actual user conversation, never from these note-taking instructions. Do not delete or change section headers or italic _section descriptions_.`
}
// @from(Start 14681344, End 14681664)
async function $U9() {
  let A = RA(),
    Q = zU9(MQ(), "session-memory", "config", "template.md");
  if (A.existsSync(Q)) try {
    return A.readFileSync(Q, {
      encoding: "utf-8"
    })
  } catch (B) {
    AA(B instanceof Error ? B : Error(`Failed to load custom session memory template: ${B}`))
  }
  return bh3
}
// @from(Start 14681665, End 14681983)
async function hh3() {
  let A = RA(),
    Q = zU9(MQ(), "session-memory", "config", "prompt.md");
  if (A.existsSync(Q)) try {
    return A.readFileSync(Q, {
      encoding: "utf-8"
    })
  } catch (B) {
    AA(B instanceof Error ? B : Error(`Failed to load custom session memory prompt: ${B}`))
  }
  return fh3()
}
// @from(Start 14681985, End 14682342)
function gh3(A) {
  let Q = {},
    B = A.split(`
`),
    G = "",
    Z = [];
  for (let I of B)
    if (I.startsWith("# ")) {
      if (G && Z.length > 0) {
        let Y = Z.join(`
`).trim();
        Q[G] = gG(Y)
      }
      G = I, Z = []
    } else Z.push(I);
  if (G && Z.length > 0) {
    let I = Z.join(`
`).trim();
    Q[G] = gG(I)
  }
  return Q
}
// @from(Start 14682344, End 14682631)
function uh3(A) {
  let Q = Object.entries(A).filter(([B, G]) => G > UU9).map(([B, G]) => `- The "${B}" section is currently ~${G} tokens and growing long. Consider condensing it a bit while keeping all important details.`);
  if (Q.length === 0) return "";
  return `

` + Q.join(`
`)
}
// @from(Start 14682633, End 14682774)
function mh3(A, Q) {
  let B = A;
  for (let [G, Z] of Object.entries(Q)) B = B.replace(new RegExp(`\\{\\{${G}\\}\\}`, "g"), Z);
  return B
}
// @from(Start 14682775, End 14682923)
async function wU9(A, Q) {
  let B = await hh3(),
    G = gh3(A),
    Z = uh3(G);
  return mh3(B, {
    currentNotes: A,
    notesPath: Q
  }) + Z
}
// @from(Start 14682928, End 14682938)
UU9 = 2000
// @from(Start 14682942, End 14684118)
bh3 = `
# Session Title
_A short and distinctive 5-10 word descriptive title for the session. Super info dense, no filler_

# Current State
_What is actively being worked on right now? Pending tasks not yet completed. Immediate next steps._

# Task specification
_What did the user ask to build? Any design decisions or other explanatory context_

# Files and Functions
_What are the important files? In short, what do they contain and why are they relevant?_

# Workflow
_What bash commands are usually run and in what order? How to interpret their output if not obvious?_

# Errors & Corrections
_Errors encountered and how they were fixed. What did the user correct? What approaches failed and should not be tried again?_

# Codebase and System Documentation
_What are the important system components? How do they work/fit together?_

# Learnings
_What has worked well? What has not? What to avoid? Do not duplicate items from other sections_

# Key results
_If the user asked a specific output such as an answer to a question, a table, or other document, repeat the exact result here_

# Worklog
_Step by step, what was attempted, done? Very terse summary for each step_
`
// @from(Start 14684124, End 14684173)
qU9 = L(() => {
  AQ();
  hQ();
  g1();
  xM()
})
// @from(Start 14684176, End 14684502)
function ch3(A, Q) {
  let B = 0,
    G = Q === null || Q === void 0;
  for (let Z of A) {
    if (!G) {
      if (Z.uuid === Q) G = !0;
      continue
    }
    if (Z.type === "assistant") {
      let Y = Z.message.content;
      if (Array.isArray(Y)) B += Y.filter((J) => J.type === "tool_use").length
    }
  }
  return B
}
// @from(Start 14684504, End 14684665)
function ph3(A) {
  let Q = ch3(A, NU9);
  if (!ySA(A) || Q >= dh3) {
    let G = A[A.length - 1];
    if (G?.uuid) NU9 = G.uuid;
    return !0
  }
  return !1
}
// @from(Start 14684666, End 14685111)
async function lh3(A) {
  let Q = RA(),
    B = kJ1();
  if (!Q.existsSync(B)) Q.mkdirSync(B);
  let G = k91();
  if (!Q.existsSync(G)) {
    let J = await $U9();
    Q.writeFileSync(G, J, {
      encoding: "utf-8",
      flush: !1,
      mode: 384
    })
  }
  let Z = await n8.call({
      file_path: G
    }, A),
    I = "",
    Y = Z.data;
  if (Y.type === "text") I = Y.file.content;
  return {
    memoryPath: G,
    currentMemory: I
  }
}
// @from(Start 14685112, End 14685135)
async function LU9() {}
// @from(Start 14685140, End 14685147)
dh3 = 3
// @from(Start 14685151, End 14685154)
NU9
// @from(Start 14685156, End 14685159)
_PI
// @from(Start 14685165, End 14686447)
MU9 = L(() => {
  EJ();
  AQ();
  Dq();
  qU9();
  JY1();
  ISA();
  u2();
  cQ();
  KQ0();
  _PI = q_(async function(A) {
    let {
      messages: Q,
      toolUseContext: B,
      querySource: G
    } = A;
    if (G !== "repl_main_thread") return;
    if (!ph3(Q)) return;
    uI2();
    let Z = BSA(B),
      {
        memoryPath: I,
        currentMemory: Y
      } = await lh3(Z),
      J = await wU9(Y, I),
      W = async (X, V) => {
        if (X.name === $5 && typeof V === "object" && V !== null && "file_path" in V) {
          if (V.file_path === I) return {
            behavior: "allow",
            updatedInput: V
          }
        }
        return {
          behavior: "deny",
          message: `only ${$5} on ${I} is allowed`,
          decisionReason: {
            type: "other",
            reason: `only ${$5} on ${I} is allowed`
          }
        }
      };
    if (await YY1({
        promptMessages: [R0({
          content: J
        })],
        cacheSafeParams: IY1(A),
        canUseTool: W,
        querySource: "session_memory",
        forkLabel: "session_memory",
        overrides: {
          readFileState: Z.readFileState
        }
      }), !ySA(Q)) {
      let X = Q[Q.length - 1];
      if (X?.uuid) gI2(X.uuid)
    }
    mI2()
  })
})
// @from(Start 14686488, End 14689707)
function nh3() {
  return `IMPORTANT: This message and these instructions are NOT part of the actual user conversation. Do NOT include any references to "documentation updates", "magic docs", or these update instructions in the document content.

Based on the user conversation above (EXCLUDING this documentation update instruction message), update the Magic Doc file to incorporate any NEW learnings, insights, or information that would be valuable to preserve.

The file {{docPath}} has already been read for you. Here are its current contents:
<current_doc_content>
{{docContents}}
</current_doc_content>

Document title: {{docTitle}}
{{customInstructions}}

Your ONLY task is to use the Edit tool to update the documentation file if there is substantial new information to add, then stop. You can make multiple edits (update multiple sections as needed) - make all Edit tool calls in parallel in a single message. If there's nothing substantial to add, simply respond with a brief explanation and do not call any tools.

CRITICAL RULES FOR EDITING:
- Preserve the Magic Doc header exactly as-is: # MAGIC DOC: {{docTitle}}
- If there's an italicized line immediately after the header, preserve it exactly as-is
- Keep the document CURRENT with the latest state of the codebase - this is NOT a changelog or history
- Update information IN-PLACE to reflect the current state - do NOT append historical notes or track changes over time
- Remove or replace outdated information rather than adding "Previously..." or "Updated to..." notes
- Clean up or DELETE sections that are no longer relevant or don't align with the document's purpose
- Fix obvious errors: typos, grammar mistakes, broken formatting, incorrect information, or confusing statements
- Keep the document well organized: use clear headings, logical section order, consistent formatting, and proper nesting

DOCUMENTATION PHILOSOPHY - READ CAREFULLY:
- BE TERSE. High signal only. No filler words or unnecessary elaboration.
- Documentation is for OVERVIEWS, ARCHITECTURE, and ENTRY POINTS - not detailed code walkthroughs
- Do NOT duplicate information that's already obvious from reading the source code
- Do NOT document every function, parameter, or line number reference
- Focus on: WHY things exist, HOW components connect, WHERE to start reading, WHAT patterns are used
- Skip: detailed implementation steps, exhaustive API docs, play-by-play narratives

What TO document:
- High-level architecture and system design
- Non-obvious patterns, conventions, or gotchas
- Key entry points and where to start reading code
- Important design decisions and their rationale
- Critical dependencies or integration points
- References to related files, docs, or code (like a wiki) - help readers navigate to relevant context

What NOT to document:
- Anything obvious from reading the code itself
- Exhaustive lists of files, functions, or parameters
- Step-by-step implementation details
- Low-level code mechanics
- Information already in CLAUDE.md or other project docs

Use the Edit tool with file_path: {{docPath}}

REMEMBER: Only update if there is substantial new information. The Magic Doc header (# MAGIC DOC: {{docTitle}}) must remain unchanged.`
}
// @from(Start 14689708, End 14689913)
async function ah3() {
  let A = RA(),
    Q = ih3(MQ(), "magic-docs", "prompt.md");
  if (A.existsSync(Q)) try {
    return A.readFileSync(Q, {
      encoding: "utf-8"
    })
  } catch {}
  return nh3()
}
// @from(Start 14689915, End 14690056)
function sh3(A, Q) {
  let B = A;
  for (let [G, Z] of Object.entries(Q)) B = B.replace(new RegExp(`\\{\\{${G}\\}\\}`, "g"), Z);
  return B
}
// @from(Start 14690057, End 14690571)
async function OU9(A, Q, B, G) {
  let Z = await ah3(),
    I = G ? `

DOCUMENT-SPECIFIC UPDATE INSTRUCTIONS:
The document author has provided specific instructions for how this file should be updated. Pay extra attention to these instructions and follow them carefully:

"${G}"

These instructions take priority over the general rules below. Make sure your updates align with these specific guidelines.` : "";
  return sh3(Z, {
    docContents: A,
    docPath: Q,
    docTitle: B,
    customInstructions: I
  })
}
// @from(Start 14690576, End 14690609)
RU9 = L(() => {
  AQ();
  hQ()
})
// @from(Start 14690612, End 14690999)
function th3(A) {
  let Q = A.match(rh3);
  if (!Q || !Q[1]) return null;
  let B = Q[1].trim(),
    G = Q.index + Q[0].length,
    I = A.slice(G).match(/^\s*\n(?:\s*\n)?(.+?)(?:\n|$)/);
  if (I && I[1]) {
    let J = I[1].match(oh3);
    if (J && J[1]) {
      let W = J[1].trim();
      return {
        title: B,
        instructions: W
      }
    }
  }
  return {
    title: B
  }
}
// @from(Start 14691001, End 14691216)
function eh3() {
  return {
    agentType: "magic-docs",
    whenToUse: "Update Magic Docs",
    tools: [$5],
    model: "sonnet",
    source: "built-in",
    baseDir: "built-in",
    getSystemPrompt: () => ""
  }
}
// @from(Start 14691217, End 14692577)
async function Ag3(A, Q) {
  let {
    messages: B,
    systemPrompt: G,
    userContext: Z,
    systemContext: I,
    toolUseContext: Y
  } = Q, J = kAA(Y.readFileState), W = {
    ...Y,
    readFileState: J
  };
  if (!RA().existsSync(A.path)) {
    aJ1.delete(A.path);
    return
  }
  let V = await n8.call({
      file_path: A.path
    }, W),
    F = "",
    K = V.data;
  if (K.type === "text") F = K.file.content;
  let D = th3(F);
  if (!D) {
    aJ1.delete(A.path);
    return
  }
  let H = await OU9(F, A.path, D.title, D.instructions),
    C = async (E, U) => {
      if (E.name === $5 && typeof U === "object" && U !== null && "file_path" in U) {
        let q = U.file_path;
        if (typeof q === "string" && q === A.path) return {
          behavior: "allow",
          updatedInput: U
        }
      }
      return {
        behavior: "deny",
        message: `only ${$5} is allowed for ${A.path}`,
        decisionReason: {
          type: "other",
          reason: `only ${$5} is allowed`
        }
      }
    };
  for await (let E of XY1({
    agentDefinition: eh3(),
    promptMessages: [R0({
      content: H
    })],
    toolUseContext: W,
    canUseTool: C,
    isAsync: !0,
    forkContextMessages: B,
    querySource: "magic_docs",
    override: {
      systemPrompt: G,
      userContext: Z,
      systemContext: I
    }
  }));
}
// @from(Start 14692578, End 14692601)
async function TU9() {}
// @from(Start 14692606, End 14692609)
rh3
// @from(Start 14692611, End 14692614)
oh3
// @from(Start 14692616, End 14692619)
aJ1
// @from(Start 14692621, End 14692624)
sPI
// @from(Start 14692630, End 14693053)
PU9 = L(() => {
  AQ();
  Dq();
  RU9();
  WY1();
  ISA();
  vM();
  cQ();
  Dq();
  rh3 = /^#\s*MAGIC\s+DOC:\s*(.+)$/im, oh3 = /^[_*](.+?)[_*]\s*$/m, aJ1 = new Map;
  sPI = q_(async function(A) {
    let {
      messages: Q,
      querySource: B
    } = A;
    if (B !== "repl_main_thread") return;
    if (ySA(Q)) return;
    if (aJ1.size === 0) return;
    for (let I of Array.from(aJ1.values())) await Ag3(I, A)
  })
})
// @from(Start 14693056, End 14693466)
function jU9(A) {
  let Q = [];
  for (let B of A)
    if (B.type === "user" && B.message?.content) {
      let G = "";
      if (typeof B.message.content === "string") G = B.message.content;
      else if (Array.isArray(B.message.content)) {
        for (let Z of B.message.content)
          if (Z.type === "text") G += Z.text + " "
      }
      if (G.trim()) Q.push(G.trim().slice(0, Qg3))
    } return Q
}
// @from(Start 14693468, End 14693557)
function Bg3(A) {
  return A.map((B) => `User: ${B}
Asst: [response hidden]`).join(`
`)
}
// @from(Start 14693559, End 14693716)
function Gg3(A) {
  let Q = B9(A, "frustrated"),
    B = B9(A, "pr_request");
  return {
    isFrustrated: Q === "true",
    hasPRRequest: B === "true"
  }
}
// @from(Start 14693717, End 14693750)
async function SU9() {
  return
}
// @from(Start 14693755, End 14693764)
Qg3 = 300
// @from(Start 14693768, End 14693771)
Zg3
// @from(Start 14693777, End 14695518)
_U9 = L(() => {
  zV0();
  ISA();
  cQ();
  t2();
  q0();
  cQ();
  Zg3 = {
    name: "session_quality_classifier",
    async shouldRun(A) {
      if (A.querySource !== "repl_main_thread") return !1;
      return jU9(A.messages).length > 0
    },
    buildMessages(A) {
      let Q = jU9(A.messages),
        B = Bg3(Q);
      return [R0({
        content: `Analyze the following conversation between a user and an assistant (assistant responses are hidden).

${B}

Think step-by-step about:
1. Does the user seem frustrated at the Asst based on their messages? Look for signs like repeated corrections, negative language, etc.
2. Has the user explicitly asked to SEND/CREATE/PUSH a pull request to GitHub? This means they want to actually submit a PR to a repository, not just work on code together or prepare changes. Look for explicit requests like: "create a pr", "send a pull request", "push a pr", "open a pr", "submit a pr to github", etc. Do NOT count mentions of working on a PR together, preparing for a PR, or discussing PR content.

Based on your analysis, output:
<frustrated>true/false</frustrated>
<pr_request>true/false</pr_request>`
      })]
    },
    systemPrompt: "You are analyzing user messages from a conversation to detect certain features of the interaction.",
    useTools: !1,
    parseResponse(A) {
      return Gg3(A)
    },
    logResult(A, Q) {
      if (A.type === "success") {
        let B = A.result;
        if (B.isFrustrated || B.hasPRRequest) GA("tengu_session_quality_classification", {
          uuid: A.uuid,
          isFrustrated: B.isFrustrated ? 1 : 0,
          hasPRRequest: B.hasPRRequest ? 1 : 0,
          messageCount: Q.queryMessageCount
        })
      }
    },
    getModel: MW
  }
})
// @from(Start 14695521, End 14695916)
function kU9({
  isFocused: A,
  isSelected: Q,
  children: B
}) {
  return dSA.default.createElement(S, {
    gap: 1,
    paddingLeft: A ? 0 : 2
  }, A && dSA.default.createElement($, {
    color: "suggestion"
  }, H1.pointer), dSA.default.createElement($, {
    color: Q ? "success" : A ? "suggestion" : void 0
  }, B), Q && dSA.default.createElement($, {
    color: "success"
  }, H1.tick))
}
// @from(Start 14695921, End 14695924)
dSA
// @from(Start 14695930, End 14695984)
yU9 = L(() => {
  hA();
  V9();
  dSA = BA(VA(), 1)
})
// @from(Start 14695990, End 14695993)
sJ1
// @from(Start 14695999, End 14696423)
xU9 = L(() => {
  sJ1 = class sJ1 extends Map {
    first;
    last;
    constructor(A) {
      let Q = [],
        B, G, Z, I = 0;
      for (let Y of A) {
        let J = {
          ...Y,
          previous: Z,
          next: void 0,
          index: I
        };
        if (Z) Z.next = J;
        B ||= J, G = J, Q.push([Y.value, J]), I++, Z = J
      }
      super(Q);
      this.first = B, this.last = G
    }
  }
})
// @from(Start 14696485, End 14696487)
FN
// @from(Start 14696489, End 14698672)
Ig3 = (A, Q) => {
    switch (Q.type) {
      case "focus-next-option": {
        if (!A.focusedValue) return A;
        let B = A.optionMap.get(A.focusedValue);
        if (!B) return A;
        let G = B.next || A.optionMap.first;
        if (!G) return A;
        if (!B.next && G === A.optionMap.first) return {
          ...A,
          focusedValue: G.value,
          visibleFromIndex: 0,
          visibleToIndex: A.visibleOptionCount
        };
        if (!(G.index >= A.visibleToIndex)) return {
          ...A,
          focusedValue: G.value
        };
        let I = Math.min(A.optionMap.size, A.visibleToIndex + 1),
          Y = I - A.visibleOptionCount;
        return {
          ...A,
          focusedValue: G.value,
          visibleFromIndex: Y,
          visibleToIndex: I
        }
      }
      case "focus-previous-option": {
        if (!A.focusedValue) return A;
        let B = A.optionMap.get(A.focusedValue);
        if (!B) return A;
        let G = B.previous || A.optionMap.last;
        if (!G) return A;
        if (!B.previous && G === A.optionMap.last) {
          let J = A.optionMap.size,
            W = Math.max(0, J - A.visibleOptionCount);
          return {
            ...A,
            focusedValue: G.value,
            visibleFromIndex: W,
            visibleToIndex: J
          }
        }
        if (!(G.index <= A.visibleFromIndex)) return {
          ...A,
          focusedValue: G.value
        };
        let I = Math.max(0, A.visibleFromIndex - 1),
          Y = I + A.visibleOptionCount;
        return {
          ...A,
          focusedValue: G.value,
          visibleFromIndex: I,
          visibleToIndex: Y
        }
      }
      case "toggle-focused-option": {
        if (!A.focusedValue) return A;
        if (A.value.includes(A.focusedValue)) {
          let B = new Set(A.value);
          return B.delete(A.focusedValue), {
            ...A,
            previousValue: A.value,
            value: [...B]
          }
        }
        return {
          ...A,
          previousValue: A.value,
          value: [...A.value, A.focusedValue]
        }
      }
      case "reset":
        return Q.state
    }
  }
// @from(Start 14698676, End 14699067)
bU9 = ({
    visibleOptionCount: A,
    defaultValue: Q,
    options: B
  }) => {
    let G = typeof A === "number" ? Math.min(A, B.length) : B.length,
      Z = new sJ1(B),
      I = Q ?? [];
    return {
      optionMap: Z,
      visibleOptionCount: G,
      focusedValue: Z.first?.value,
      visibleFromIndex: 0,
      visibleToIndex: G,
      previousValue: I,
      value: I
    }
  }
// @from(Start 14699071, End 14700531)
fU9 = ({
    visibleOptionCount: A = 5,
    options: Q,
    defaultValue: B,
    onChange: G,
    onSubmit: Z
  }) => {
    let [I, Y] = FN.useReducer(Ig3, {
      visibleOptionCount: A,
      defaultValue: B,
      options: Q
    }, bU9), [J, W] = FN.useState(Q);
    if (Q !== J && !vU9(Q, J)) Y({
      type: "reset",
      state: bU9({
        visibleOptionCount: A,
        defaultValue: B,
        options: Q
      })
    }), W(Q);
    let X = FN.useCallback(() => {
        Y({
          type: "focus-next-option"
        })
      }, []),
      V = FN.useCallback(() => {
        Y({
          type: "focus-previous-option"
        })
      }, []),
      F = FN.useCallback(() => {
        Y({
          type: "toggle-focused-option"
        })
      }, []),
      K = FN.useCallback(() => {
        Z?.(I.value)
      }, [I.value, Z]),
      D = FN.useMemo(() => {
        return Q.map((H, C) => ({
          ...H,
          index: C
        })).slice(I.visibleFromIndex, I.visibleToIndex)
      }, [Q, I.visibleFromIndex, I.visibleToIndex]);
    return FN.useEffect(() => {
      if (!vU9(I.previousValue, I.value)) G?.(I.value)
    }, [I.previousValue, I.value, Q, G]), {
      focusedValue: I.focusedValue,
      visibleFromIndex: I.visibleFromIndex,
      visibleToIndex: I.visibleToIndex,
      value: I.value,
      visibleOptions: D,
      focusNextOption: X,
      focusPreviousOption: V,
      toggleFocusedOption: F,
      submit: K
    }
  }
// @from(Start 14700537, End 14700583)
hU9 = L(() => {
  xU9();
  FN = BA(VA(), 1)
})
// @from(Start 14700589, End 14700845)
gU9 = ({
  isDisabled: A = !1,
  state: Q
}) => {
  f1((B, G) => {
    if (G.downArrow) Q.focusNextOption();
    if (G.upArrow) Q.focusPreviousOption();
    if (B === " ") Q.toggleFocusedOption();
    if (G.return) Q.submit()
  }, {
    isActive: !A
  })
}
// @from(Start 14700851, End 14700876)
uU9 = L(() => {
  hA()
})
// @from(Start 14700879, End 14701746)
function rJ1({
  isDisabled: A = !1,
  visibleOptionCount: Q = 5,
  highlightText: B,
  options: G,
  defaultValue: Z,
  onChange: I,
  onSubmit: Y
}) {
  let J = fU9({
    visibleOptionCount: Q,
    options: G,
    defaultValue: Z,
    onChange: I,
    onSubmit: Y
  });
  return gU9({
    isDisabled: A,
    state: J
  }), vVA.default.createElement(S, {
    flexDirection: "column"
  }, J.visibleOptions.map((W) => {
    let X = W.label;
    if (B && W.label.includes(B)) {
      let V = W.label.indexOf(B);
      X = vVA.default.createElement(vVA.default.Fragment, null, W.label.slice(0, V), vVA.default.createElement($, {
        bold: !0
      }, B), W.label.slice(V + B.length))
    }
    return vVA.default.createElement(kU9, {
      key: W.value,
      isFocused: !A && J.focusedValue === W.value,
      isSelected: J.value.includes(W.value)
    }, X)
  }))
}
// @from(Start 14701751, End 14701754)
vVA
// @from(Start 14701760, End 14701833)
ID0 = L(() => {
  hA();
  yU9();
  hU9();
  uU9();
  vVA = BA(VA(), 1)
})
// @from(Start 14701836, End 14703931)
function mU9({
  servers: A,
  scope: Q,
  onDone: B
}) {
  let G = Object.keys(A),
    [Z, I] = GF.useState({});
  GF.useEffect(() => {
    fk().then(({
      servers: F
    }) => I(F))
  }, []);
  let Y = G.filter((F) => Z[F] !== void 0);

  function J(F) {
    let K = 0;
    for (let D of F) {
      let H = A[D];
      if (H) {
        let C = D;
        if (Z[C] !== void 0) {
          let E = 1;
          while (Z[`${D}_${E}`] !== void 0) E++;
          C = `${D}_${E}`
        }
        K1A(C, H, Q), K++
      }
    }
    V(K)
  }
  let W = EQ();
  f1((F, K) => {
    if (K.escape) {
      V(0);
      return
    }
  });
  let [X] = qB();

  function V(F) {
    if (F > 0) L9(`
${ZB("success",X)(`Successfully imported ${F} MCP server${F!==1?"s":""} to ${Q} config.`)}
`);
    else L9(`
No servers were imported.`);
    B(), v6()
  }
  return GF.default.createElement(GF.default.Fragment, null, GF.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "success"
  }, GF.default.createElement($, {
    bold: !0,
    color: "success"
  }, "Import MCP Servers from Claude Desktop"), GF.default.createElement($, null, "Found ", G.length, " MCP server", G.length !== 1 ? "s" : "", " in Claude Desktop."), Y.length > 0 && GF.default.createElement($, {
    color: "warning"
  }, "Note: Some servers already exist with the same name. If selected, they will be imported with a numbered suffix."), GF.default.createElement($, null, "Please select the servers you want to import:"), GF.default.createElement(rJ1, {
    options: G.map((F) => ({
      label: `${F}${Y.includes(F)?" (already exists)":""}`,
      value: F
    })),
    defaultValue: G.filter((F) => !Y.includes(F)),
    onSubmit: J
  })), GF.default.createElement(S, {
    marginLeft: 3
  }, GF.default.createElement($, {
    dimColor: !0
  }, W.pending ? GF.default.createElement(GF.default.Fragment, null, "Press ", W.keyName, " again to exit") : GF.default.createElement(GF.default.Fragment, null, "Space to select · Enter to confirm · Esc to cancel"))))
}
// @from(Start 14703936, End 14703938)
GF
// @from(Start 14703944, End 14704022)
dU9 = L(() => {
  hA();
  ID0();
  Q4();
  tM();
  kW();
  GF = BA(VA(), 1)
})
// @from(Start 14704081, End 14705209)
function Yg3() {
  let A = dQ();
  if (!LD1.includes(A)) throw Error(`Unsupported platform: ${A} - Claude Desktop integration only works on macOS and WSL.`);
  if (A === "macos") return YD0.join(cU9.homedir(), "Library", "Application Support", "Claude", "claude_desktop_config.json");
  let Q = process.env.USERPROFILE ? process.env.USERPROFILE.replace(/\\/g, "/") : null;
  if (Q) {
    let G = `/mnt/c${Q.replace(/^[A-Z]:/,"")}/AppData/Roaming/Claude/claude_desktop_config.json`;
    if (RA().existsSync(G)) return G
  }
  try {
    if (RA().existsSync("/mnt/c/Users")) {
      let G = RA().readdirSync("/mnt/c/Users");
      for (let Z of G) {
        if (Z.name === "Public" || Z.name === "Default" || Z.name === "Default User" || Z.name === "All Users") continue;
        let I = YD0.join("/mnt/c/Users", Z.name, "AppData", "Roaming", "Claude", "claude_desktop_config.json");
        if (RA().existsSync(I)) return I
      }
    }
  } catch (B) {
    AA(B instanceof Error ? B : Error(String(B)))
  }
  throw Error("Could not find Claude Desktop config file in Windows. Make sure Claude Desktop is installed on Windows.")
}
// @from(Start 14705211, End 14705903)
function pU9() {
  if (!LD1.includes(dQ())) throw Error("Unsupported platform - Claude Desktop integration only works on macOS and WSL.");
  try {
    let A = Yg3();
    if (!RA().existsSync(A)) return {};
    let Q = RA().readFileSync(A, {
        encoding: "utf8"
      }),
      B = f7(Q);
    if (!B || typeof B !== "object") return {};
    let G = B.mcpServers;
    if (!G || typeof G !== "object") return {};
    let Z = {};
    for (let [I, Y] of Object.entries(G)) {
      if (!Y || typeof Y !== "object") continue;
      let J = je1.safeParse(Y);
      if (J.success) Z[I] = J.data
    }
    return Z
  } catch (A) {
    return AA(A instanceof Error ? A : Error(String(A))), {}
  }
}
// @from(Start 14705908, End 14705966)
lU9 = L(() => {
  LF();
  g1();
  MIA();
  Q3();
  AQ()
})
// @from(Start 14705969, End 14707742)
function oJ1({
  customApiKeyTruncated: A,
  onDone: Q
}) {
  function B(Z) {
    let I = N1();
    switch (Z) {
      case "yes": {
        c0({
          ...I,
          customApiKeyResponses: {
            ...I.customApiKeyResponses,
            approved: [...I.customApiKeyResponses?.approved ?? [], A]
          }
        }), Q();
        break
      }
      case "no": {
        c0({
          ...I,
          customApiKeyResponses: {
            ...I.customApiKeyResponses,
            rejected: [...I.customApiKeyResponses?.rejected ?? [], A]
          }
        }), Q();
        break
      }
    }
  }
  let G = EQ();
  return jC.default.createElement(jC.default.Fragment, null, jC.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "warning"
  }, jC.default.createElement($, {
    bold: !0,
    color: "warning"
  }, "Detected a custom API key in your environment"), jC.default.createElement($, null, jC.default.createElement($, {
    bold: !0
  }, "ANTHROPIC_API_KEY"), jC.default.createElement($, null, ": sk-ant-...", A)), jC.default.createElement($, null, "Do you want to use this API key?"), jC.default.createElement(M0, {
    defaultValue: "no",
    focusValue: "no",
    options: [{
      label: "Yes",
      value: "yes"
    }, {
      label: `No (${tA.bold("recommended")})`,
      value: "no"
    }],
    onChange: (Z) => B(Z),
    onCancel: () => B("no")
  })), jC.default.createElement(S, {
    marginLeft: 3
  }, jC.default.createElement($, {
    dimColor: !0
  }, G.pending ? jC.default.createElement(jC.default.Fragment, null, "Press ", G.keyName, " again to exit") : jC.default.createElement(jC.default.Fragment, null, "Enter to confirm ", H1.dot, " Esc to cancel"))))
}
// @from(Start 14707747, End 14707749)
jC
// @from(Start 14707755, End 14707840)
JD0 = L(() => {
  hA();
  jQ();
  J5();
  Q4();
  F9();
  V9();
  jC = BA(VA(), 1)
})
// @from(Start 14707842, End 14709018)
async function Jg3() {
  try {
    let A = ["https://api.anthropic.com/api/hello", "https://console.anthropic.com/v1/oauth/hello"],
      Q = async (Z) => {
        try {
          let I = await YQ.get(Z, {
            headers: {
              "User-Agent": fc()
            }
          });
          if (I.status !== 200) return {
            success: !1,
            error: `Failed to connect to ${new URL(Z).hostname}: Status ${I.status}`
          };
          return {
            success: !0
          }
        } catch (I) {
          return {
            success: !1,
            error: `Failed to connect to ${new URL(Z).hostname}: ${I instanceof Error?I.code||I.message:String(I)}`
          }
        }
      }, G = (await Promise.all(A.map(Q))).find((Z) => !Z.success);
    if (G) GA("tengu_preflight_check_failed", {
      isConnectivityError: !1,
      hasErrorMessage: !!G.error
    });
    return G || {
      success: !0
    }
  } catch (A) {
    return AA(A), GA("tengu_preflight_check_failed", {
      isConnectivityError: !0
    }), {
      success: !1,
      error: `Connectivity check error: ${A instanceof Error?A.code||A.message:String(A)}`
    }
  }
}
// @from(Start 14709020, End 14710375)
function iU9({
  onSuccess: A
}) {
  let [Q, B] = TK.useState(null), [G, Z] = TK.useState(!0), I = F71(1000) && G;
  return TK.useEffect(() => {
    async function Y() {
      let J = await Jg3();
      B(J), Z(!1)
    }
    Y()
  }, []), TK.useEffect(() => {
    if (Q?.success) A();
    else if (Q && !Q.success) {
      let Y = setTimeout(() => process.exit(1), 100);
      return () => clearTimeout(Y)
    }
  }, [Q, A]), TK.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    paddingLeft: 1
  }, G && I ? TK.default.createElement(S, {
    paddingLeft: 1
  }, TK.default.createElement(g4, null), TK.default.createElement($, null, "Checking connectivity...")) : !Q?.success && !G && TK.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, TK.default.createElement($, {
    color: "error"
  }, "Unable to connect to Anthropic services"), TK.default.createElement($, {
    color: "error"
  }, Q?.error), TK.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, TK.default.createElement($, null, "Please check your internet connection and network settings."), TK.default.createElement($, null, "Note: Claude Code might not be available in your country. Check supported countries at", " ", TK.default.createElement($, {
    color: "suggestion"
  }, "https://anthropic.com/supported-countries")))))
}
// @from(Start 14710380, End 14710382)
TK
// @from(Start 14710388, End 14710482)
nU9 = L(() => {
  hA();
  AE();
  g1();
  DY();
  WZ0();
  q0();
  O3();
  TK = BA(VA(), 1)
})
// @from(Start 14710485, End 14716020)
function eJ1() {
  let [A] = qB(), Q = "Welcome to Claude Code";
  if (d0.terminal === "Apple_Terminal") return T0.default.createElement(Wg3, {
    theme: A,
    welcomeMessage: "Welcome to Claude Code"
  });
  if (["light", "light-daltonized", "light-ansi"].includes(A)) return T0.default.createElement(S, {
    width: tJ1
  }, T0.default.createElement($, null, T0.default.createElement($, null, T0.default.createElement($, {
    color: "claude"
  }, "Welcome to Claude Code", " "), T0.default.createElement($, {
    dimColor: !0
  }, "v", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION, " ")), T0.default.createElement($, null, "…………………………………………………………………………………………………………………………………………………………"), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "            ░░░░░░                                        "), T0.default.createElement($, null, "    ░░░   ░░░░░░░░░░                                      "), T0.default.createElement($, null, "   ░░░░░░░░░░░░░░░░░░░                                    "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, T0.default.createElement($, {
    dimColor: !0
  }, "                           ░░░░"), T0.default.createElement($, null, "                     ██    ")), T0.default.createElement($, null, T0.default.createElement($, {
    dimColor: !0
  }, "                         ░░░░░░░░░░"), T0.default.createElement($, null, "               ██▒▒██  ")), T0.default.createElement($, null, "                                            ▒▒      ██   ▒"), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body"
  }, " █████████ "), "                         ▒▒░░▒▒      ▒ ▒▒"), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body",
    backgroundColor: "clawd_background"
  }, "██▄█████▄██"), "                           ▒▒         ▒▒ "), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body"
  }, " █████████ "), "                          ░          ▒   "), T0.default.createElement($, null, "…………………", T0.default.createElement($, {
    color: "clawd_body"
  }, "█ █   █ █"), "……………………………………………………………………░…………………………▒…………")));
  return T0.default.createElement(S, {
    width: tJ1
  }, T0.default.createElement($, null, T0.default.createElement($, null, T0.default.createElement($, {
    color: "claude"
  }, "Welcome to Claude Code", " "), T0.default.createElement($, {
    dimColor: !0
  }, "v", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION, " ")), T0.default.createElement($, null, "…………………………………………………………………………………………………………………………………………………………"), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "     *                                       █████▓▓░     "), T0.default.createElement($, null, "                                 *         ███▓░     ░░   "), T0.default.createElement($, null, "            ░░░░░░                        ███▓░           "), T0.default.createElement($, null, "    ░░░   ░░░░░░░░░░                      ███▓░           "), T0.default.createElement($, null, T0.default.createElement($, null, "   ░░░░░░░░░░░░░░░░░░░    "), T0.default.createElement($, {
    bold: !0
  }, "*"), T0.default.createElement($, null, "                ██▓░░      ▓   ")), T0.default.createElement($, null, "                                             ░▓▓███▓▓░    "), T0.default.createElement($, {
    dimColor: !0
  }, " *                                 ░░░░                   "), T0.default.createElement($, {
    dimColor: !0
  }, "                                 ░░░░░░░░                 "), T0.default.createElement($, {
    dimColor: !0
  }, "                               ░░░░░░░░░░░░░░░░           "), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body"
  }, " █████████ "), "                                       ", T0.default.createElement($, {
    dimColor: !0
  }, "*"), T0.default.createElement($, null, " ")), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body"
  }, "██▄█████▄██"), T0.default.createElement($, null, "                        "), T0.default.createElement($, {
    bold: !0
  }, "*"), T0.default.createElement($, null, "                ")), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body"
  }, " █████████ "), "     *                                   "), T0.default.createElement($, null, "…………………", T0.default.createElement($, {
    color: "clawd_body"
  }, "█ █   █ █"), "………………………………………………………………………………………………………………")))
}
// @from(Start 14716022, End 14722269)
function Wg3({
  theme: A,
  welcomeMessage: Q
}) {
  if (["light", "light-daltonized", "light-ansi"].includes(A)) return T0.default.createElement(S, {
    width: tJ1
  }, T0.default.createElement($, null, T0.default.createElement($, null, T0.default.createElement($, {
    color: "claude"
  }, Q, " "), T0.default.createElement($, {
    dimColor: !0
  }, "v", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION, " ")), T0.default.createElement($, null, "…………………………………………………………………………………………………………………………………………………………"), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "            ░░░░░░                                        "), T0.default.createElement($, null, "    ░░░   ░░░░░░░░░░                                      "), T0.default.createElement($, null, "   ░░░░░░░░░░░░░░░░░░░                                    "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, T0.default.createElement($, {
    dimColor: !0
  }, "                           ░░░░"), T0.default.createElement($, null, "                     ██    ")), T0.default.createElement($, null, T0.default.createElement($, {
    dimColor: !0
  }, "                         ░░░░░░░░░░"), T0.default.createElement($, null, "               ██▒▒██  ")), T0.default.createElement($, null, "                                            ▒▒      ██   ▒"), T0.default.createElement($, null, "                                          ▒▒░░▒▒      ▒ ▒▒"), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body"
  }, "▗"), T0.default.createElement($, {
    color: "clawd_background",
    backgroundColor: "clawd_body"
  }, " ", "▗", "     ", "▖", " "), T0.default.createElement($, {
    color: "clawd_body"
  }, "▖"), "                           ▒▒         ▒▒ "), T0.default.createElement($, null, "       ", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " ".repeat(9)), "                           ░          ▒   "), T0.default.createElement($, null, "…………………", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, "   "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), "……………………………………………………………………░…………………………▒…………")));
  return T0.default.createElement(S, {
    width: tJ1
  }, T0.default.createElement($, null, T0.default.createElement($, null, T0.default.createElement($, {
    color: "claude"
  }, Q, " "), T0.default.createElement($, {
    dimColor: !0
  }, "v", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION, " ")), T0.default.createElement($, null, "…………………………………………………………………………………………………………………………………………………………"), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "     *                                       █████▓▓░     "), T0.default.createElement($, null, "                                 *         ███▓░     ░░   "), T0.default.createElement($, null, "            ░░░░░░                        ███▓░           "), T0.default.createElement($, null, "    ░░░   ░░░░░░░░░░                      ███▓░           "), T0.default.createElement($, null, T0.default.createElement($, null, "   ░░░░░░░░░░░░░░░░░░░    "), T0.default.createElement($, {
    bold: !0
  }, "*"), T0.default.createElement($, null, "                ██▓░░      ▓   ")), T0.default.createElement($, null, "                                             ░▓▓███▓▓░    "), T0.default.createElement($, {
    dimColor: !0
  }, " *                                 ░░░░                   "), T0.default.createElement($, {
    dimColor: !0
  }, "                                 ░░░░░░░░                 "), T0.default.createElement($, {
    dimColor: !0
  }, "                               ░░░░░░░░░░░░░░░░           "), T0.default.createElement($, null, "                                                      ", T0.default.createElement($, {
    dimColor: !0
  }, "*"), T0.default.createElement($, null, " ")), T0.default.createElement($, null, "        ", T0.default.createElement($, {
    color: "clawd_body"
  }, "▗"), T0.default.createElement($, {
    color: "clawd_background",
    backgroundColor: "clawd_body"
  }, " ", "▗", "     ", "▖", " "), T0.default.createElement($, {
    color: "clawd_body"
  }, "▖"), T0.default.createElement($, null, "                       "), T0.default.createElement($, {
    bold: !0
  }, "*"), T0.default.createElement($, null, "                ")), T0.default.createElement($, null, "        ", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " ".repeat(9)), "      *                                   "), T0.default.createElement($, null, "…………………", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, "   "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), "………………………………………………………………………………………………………………")))
}
// @from(Start 14722274, End 14722276)
T0
// @from(Start 14722278, End 14722286)
tJ1 = 58
// @from(Start 14722292, End 14722345)
WD0 = L(() => {
  hA();
  c5();
  T0 = BA(VA(), 1)
})
// @from(Start 14722348, End 14726677)
function aU9({
  onDone: A
}) {
  let [Q, B] = R8.useState(0), G = JU(), [Z, I] = qB();
  R8.useEffect(() => {
    GA("tengu_began_setup", {
      oauthEnabled: G
    })
  }, [G]);

  function Y() {
    if (Q < D.length - 1) {
      let H = Q + 1;
      B(H), GA("tengu_onboarding_step", {
        oauthEnabled: G,
        stepId: D[H]?.id
      })
    } else A()
  }

  function J(H) {
    I(H), Y()
  }
  let W = EQ();
  f1(async (H, C) => {
    let E = D[Q];
    if (C.return && E && E.id === "security")
      if (Q === D.length - 1) {
        A();
        return
      } else Y();
    else if (C.escape && E?.id === "terminal-setup") Y()
  });
  let X = R8.default.createElement(bY1, {
      initialTheme: Z,
      onThemeSelect: J,
      showIntroText: !0,
      helpText: "To change this later, run /theme",
      hideEscToCancel: !0,
      skipExitHandling: !0
    }),
    V = R8.default.createElement(S, {
      flexDirection: "column",
      gap: 1,
      paddingLeft: 1
    }, R8.default.createElement($, {
      bold: !0
    }, "Security notes:"), R8.default.createElement(S, {
      flexDirection: "column",
      width: 70
    }, R8.default.createElement(q$A, null, R8.default.createElement(q$A.Item, null, R8.default.createElement($, null, "Claude can make mistakes"), R8.default.createElement($, {
      dimColor: !0,
      wrap: "wrap"
    }, "You should always review Claude's responses, especially when", R8.default.createElement(bF, null), "running code.", R8.default.createElement(bF, null))), R8.default.createElement(q$A.Item, null, R8.default.createElement($, null, "Due to prompt injection risks, only use it with code you trust"), R8.default.createElement($, {
      dimColor: !0,
      wrap: "wrap"
    }, "For more details see:", R8.default.createElement(bF, null), R8.default.createElement(h4, {
      url: "https://code.claude.com/docs/en/security"
    }))))), R8.default.createElement(pY1, null)),
    F = R8.default.createElement(iU9, {
      onSuccess: Y
    }),
    K = R8.useMemo(() => {
      if (!process.env.ANTHROPIC_API_KEY) return "";
      let H = dw(process.env.ANTHROPIC_API_KEY);
      if (TiA(H) === "new") return H
    }, []),
    D = [];
  if (G) D.push({
    id: "preflight",
    component: F
  });
  if (D.push({
      id: "theme",
      component: X
    }), G) D.push({
    id: "oauth",
    component: R8.default.createElement(Vn, {
      onDone: Y
    })
  });
  if (K) D.push({
    id: "api-key",
    component: R8.default.createElement(oJ1, {
      customApiKeyTruncated: K,
      onDone: Y
    })
  });
  if (D.push({
      id: "security",
      component: V
    }), M$A()) D.push({
    id: "terminal-setup",
    component: R8.default.createElement(S, {
      flexDirection: "column",
      gap: 1,
      paddingLeft: 1
    }, R8.default.createElement($, {
      bold: !0
    }, "Use Claude Code's terminal setup?"), R8.default.createElement(S, {
      flexDirection: "column",
      width: 70,
      gap: 1
    }, R8.default.createElement($, null, "For the optimal coding experience, enable the recommended settings", R8.default.createElement(bF, null), "for your terminal:", " ", d0.terminal === "Apple_Terminal" ? "Option+Enter for newlines and visual bell" : "Shift+Enter for newlines"), R8.default.createElement(M0, {
      options: [{
        label: "Yes, use recommended settings",
        value: "install"
      }, {
        label: "No, maybe later with /terminal-setup",
        value: "no"
      }],
      onChange: (H) => {
        if (H === "install") Dm1(Z).then(() => {
          Y()
        });
        else Y()
      },
      onCancel: () => Y()
    }), R8.default.createElement($, {
      dimColor: !0
    }, W.pending ? R8.default.createElement(R8.default.Fragment, null, "Press ", W.keyName, " again to exit") : R8.default.createElement(R8.default.Fragment, null, "Enter to confirm · Esc to skip"))))
  });
  return R8.default.createElement(S, {
    flexDirection: "column"
  }, R8.default.createElement(Zp, {
    items: [R8.default.createElement(eJ1, {
      key: "welcome"
    })]
  }, (H) => H), R8.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, D[Q]?.component, W.pending && R8.default.createElement(S, {
    padding: 1
  }, R8.default.createElement($, {
    dimColor: !0
  }, "Press ", W.keyName, " again to exit"))))
}
// @from(Start 14726682, End 14726684)
R8
// @from(Start 14726690, End 14726872)
sU9 = L(() => {
  hA();
  jQ();
  vzA();
  Jm1();
  Q4();
  SRA();
  JD0();
  gB();
  hA();
  oV0();
  nU9();
  mV0();
  q0();
  c5();
  S5();
  r7A();
  WD0();
  R8 = BA(VA(), 1)
})
// @from(Start 14726912, End 14727233)
function VD0(A) {
  let Q = Hi();
  if (A === Q.HOME) return "home";
  if (A === Q.DESKTOP || A.startsWith(Q.DESKTOP + XD0)) return "desktop";
  if (A === Q.DOCUMENTS || A.startsWith(Q.DOCUMENTS + XD0)) return "documents";
  if (A === Q.DOWNLOADS || A.startsWith(Q.DOWNLOADS + XD0)) return "downloads";
  return "other"
}
// @from(Start 14727235, End 14727447)
function rU9(A) {
  if (A === null || A.disableAllHooks) return !1;
  if (A.statusLine) return !0;
  if (!A.hooks) return !1;
  for (let Q of Object.values(A.hooks))
    if (Q.length > 0) return !0;
  return !1
}
// @from(Start 14727449, End 14727654)
function Q$9() {
  let A = [],
    Q = OB("projectSettings");
  if (rU9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (rU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14727656, End 14727804)
function oU9(A) {
  return A.some((Q) => Q.ruleBehavior === "allow" && (Q.ruleValue.toolName === C9 || Q.ruleValue.toolName.startsWith(C9 + "(")))
}
// @from(Start 14727806, End 14728013)
function B$9() {
  let A = [],
    Q = YxA("projectSettings");
  if (oU9(Q)) A.push(".claude/settings.json");
  let B = YxA("localSettings");
  if (oU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14728015, End 14728449)
function cSA(A, Q) {
  if (A.length === 0) return "";
  let B = Q === 0 ? void 0 : Q;
  if (!B || A.length <= B) {
    if (A.length === 1) return A[0];
    if (A.length === 2) return `${A[0]} and ${A[1]}`;
    let I = A[A.length - 1];
    return `${A.slice(0,-1).join(", ")}, and ${I}`
  }
  let G = A.slice(0, B),
    Z = A.length - B;
  if (G.length === 1) return `${G[0]} and ${Z} more`;
  return `${G.join(", ")}, and ${Z} more`
}
// @from(Start 14728451, End 14728502)
function tU9(A) {
  return !!A?.otelHeadersHelper
}
// @from(Start 14728504, End 14728709)
function G$9() {
  let A = [],
    Q = OB("projectSettings");
  if (tU9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (tU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14728711, End 14728757)
function eU9(A) {
  return !!A?.apiKeyHelper
}
// @from(Start 14728759, End 14728964)
function Z$9() {
  let A = [],
    Q = OB("projectSettings");
  if (eU9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (eU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14728966, End 14729042)
function A$9(A) {
  return !!(A?.awsAuthRefresh || A?.awsCredentialExport)
}
// @from(Start 14729044, End 14729249)
function I$9() {
  let A = [],
    Q = OB("projectSettings");
  if (A$9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (A$9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14729254, End 14729296)
Y$9 = L(() => {
  is();
  MB();
  QMA()
})
// @from(Start 14729302, End 14729305)
J$9
// @from(Start 14729311, End 14731069)
W$9 = L(() => {
  J$9 = {
    control: {
      title: "Do you trust the files in this folder?",
      bodyText: null,
      showDetailedPermissions: !0,
      learnMoreText: "Learn more",
      yesButtonLabel: "Yes, proceed",
      noButtonLabel: "No, exit"
    },
    variant_positive_attitude: {
      title: "Ready to code here?",
      bodyText: `I'll need permission to work with your files.

This means I can:
- Read any file in this folder
- Create, edit, or delete files
- Run commands (like npm, git, tests, ls, rm)
- Use tools defined in .mcp.json`,
      showDetailedPermissions: !1,
      learnMoreText: "Learn more",
      yesButtonLabel: "Yes, continue",
      noButtonLabel: "No, exit"
    },
    variant_normalize_action: {
      title: "Accessing workspace:",
      bodyText: `Quick safety check: Is this a project you created or one you trust? (Like your own code, a well-known open source project, or work from your team). If not, take a moment to review what's in this folder first.

Claude Code'll be able to read, edit, and execute files here.`,
      showDetailedPermissions: !1,
      learnMoreText: "Security guide",
      yesButtonLabel: "Yes, I trust this folder",
      noButtonLabel: "No, exit"
    },
    variant_explicit: {
      title: "Do you want to work in this folder?",
      bodyText: `In order to work in this folder, we need your permission for Claude Code to read, edit, and execute files.

If this folder has malicious code or untrusted scripts, Claude Code could run them while trying to help.

Only continue if this is your code or a project you trust.`,
      showDetailedPermissions: !1,
      learnMoreText: "Security details",
      yesButtonLabel: "Yes, continue",
      noButtonLabel: "No, exit"
    }
  }
})
// @from(Start 14731111, End 14736412)
function V$9({
  onDone: A,
  commands: Q
}) {
  let {
    servers: B
  } = sX("project"), G = BZ("trust_folder_dialog_copy", "variant", "control"), Z = J$9[G], I = Object.keys(B).length > 0, Y = Q$9(), J = Y.length > 0, W = B$9(), X = Z$9(), V = X.length > 0, F = I$9(), K = F.length > 0, D = G$9(), H = D.length > 0, C = [...new Set([...Y, ...W, ...X, ...F, ...D])], E = Q?.filter((m) => m.type === "prompt" && m.source === "projectSettings" && !m.isSkill && m.allowedTools?.some((o) => o === C9 || o.startsWith(C9 + "("))) ?? [], U = Q?.filter((m) => m.type === "prompt" && m.source === "localSettings" && m.isSkill && m.allowedTools?.some((o) => o === C9 || o.startsWith(C9 + "("))) ?? [], q = E.length > 0, w = U.length > 0, N = E.map((m) => m.name), R = U.map((m) => m.name), T = W.length > 0 || q || w, y = TJ(J || T || V || K || H), x = [{
    name: "MCP servers",
    shouldShowWarning: () => I,
    onChange: () => {
      let m = {
        enabledMcpjsonServers: Object.keys(B),
        enableAllProjectMcpServers: !0
      };
      cB("localSettings", m)
    }
  }, {
    name: "hooks",
    shouldShowWarning: () => J
  }, {
    name: "bash commands",
    shouldShowWarning: () => T
  }, {
    name: "OpenTelemetry headers helper commands",
    shouldShowWarning: () => H
  }].filter((m) => m.shouldShowWarning()), p = new Set(x.map((m) => m.name)), u = Object.keys(B);

  function e() {
    let m = ["files"];
    if (p.has("MCP servers")) m.push("MCP servers");
    if (p.has("hooks")) m.push("hooks");
    if (p.has("bash commands")) m.push("bash commands");
    if (p.has("OpenTelemetry headers helper commands")) m.push("OpenTelemetry headers helper commands");
    return cSA(m)
  }
  v5.default.useEffect(() => {
    let m = X$9() === W0();
    GA("tengu_trust_dialog_shown", {
      isHomeDir: m,
      hasMcpServers: I,
      hasHooks: J,
      hasBashExecution: T,
      hasApiKeyHelper: V,
      hasAwsCommands: K,
      hasOtelHeadersHelper: H,
      folderType: VD0(W0()),
      copyVariant: G
    })
  }, [I, J, T, V, K, H, G]);

  function l(m) {
    let o = j5();
    if (m === "exit") {
      l5(1);
      return
    }
    let IA = X$9() === W0();
    if (GA("tengu_trust_dialog_accept", {
        isHomeDir: IA,
        hasMcpServers: I,
        hasHooks: J,
        hasBashExecution: T,
        hasApiKeyHelper: V,
        hasAwsCommands: K,
        hasOtelHeadersHelper: H,
        enableMcp: !0,
        folderType: VD0(W0()),
        copyVariant: G
      }), !IA) AY({
      ...o,
      hasTrustDialogAccepted: !0
    });
    x.forEach((FA) => {
      if (FA.onChange !== void 0) FA.onChange()
    }), A()
  }
  let k = EQ();
  if (f1((m, o) => {
      if (o.escape) {
        l5(0);
        return
      }
    }), y) return setTimeout(A), null;
  return v5.default.createElement(uJ, {
    color: "warning",
    titleColor: "warning",
    title: Z.title
  }, v5.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    paddingTop: 1
  }, v5.default.createElement($, {
    bold: !0
  }, RA().cwd()), Z.bodyText !== null ? v5.default.createElement($, null, Z.bodyText) : v5.default.createElement($, null, "Claude Code may read, write, or execute files contained in this directory. This can pose security risks, so only use", " ", e(), " from trusted sources."), Z.showDetailedPermissions && (I || J || T || V || K || H) && v5.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, v5.default.createElement($, {
    dimColor: !0
  }, "Execution allowed by:"), I && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, ".mcp.json"), u.length > 0 && v5.default.createElement($, {
    dimColor: !0
  }, " ", "(", cSA(u, 3), ")"))), C.length > 0 && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, C.join(", ")))), q && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, ".claude/commands"), v5.default.createElement($, {
    dimColor: !0
  }, " ", "(", cSA(N, 3), ")"))), w && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, ".claude/skills"), v5.default.createElement($, {
    dimColor: !0
  }, " (", cSA(R, 3), ")")))), v5.default.createElement($, {
    dimColor: !0
  }, v5.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/security"
  }, Z.learnMoreText)), v5.default.createElement(M0, {
    options: [{
      label: Z.yesButtonLabel,
      value: "enable_all"
    }, {
      label: Z.noButtonLabel,
      value: "exit"
    }],
    onChange: (m) => l(m),
    onCancel: () => l("exit")
  }), v5.default.createElement($, {
    dimColor: !0
  }, k.pending ? v5.default.createElement(v5.default.Fragment, null, "Press ", k.keyName, " again to exit") : v5.default.createElement(v5.default.Fragment, null, "Enter to confirm · Esc to exit"))))
}
// @from(Start 14736417, End 14736419)
v5
// @from(Start 14736425, End 14736584)
F$9 = L(() => {
  hA();
  J5();
  jQ();
  tM();
  MB();
  u2();
  q0();
  Q4();
  U2();
  hA();
  AQ();
  kW();
  Y$9();
  W$9();
  wO();
  v5 = BA(VA(), 1)
})
// @from(Start 14736590, End 14736593)
AW1
// @from(Start 14736599, End 14736686)
K$9 = L(() => {
  GJ1();
  g1();
  S7();
  g1();
  kW();
  i8();
  AW1 = BA(VA(), 1)
})
// @from(Start 14736689, End 14738892)
function D$9({
  commands: A,
  initialLogs: Q,
  initialTools: B,
  mcpClients: G,
  dynamicMcpConfig: Z,
  mcpCliEndpoint: I,
  appState: Y,
  onChangeAppState: J,
  debug: W,
  strictMcpConfig: X = !1,
  systemPrompt: V,
  appendSystemPrompt: F,
  initialSearchQuery: K
}) {
  let {
    rows: D
  } = WB(), [H, C] = qY.default.useState(Q), [E, U] = qY.default.useState(!1), [q, w] = qY.default.useState(!1), [N, R] = qY.default.useState(null), [T, y] = qY.default.useState(null), v = H.filter((k) => !k.isSidechain);
  EQ();
  let x = ug(),
    p = qY.default.useCallback((k) => {
      U(!0), (k ? YJ1 : eP)().then((o) => {
        C(o)
      }).catch((o) => {
        AA(o)
      }).finally(() => {
        U(!1)
      })
    }, []);
  qY.default.useEffect(() => {
    p(q)
  }, [p, q]);
  let u = qY.default.useCallback(() => {
    w((k) => !k)
  }, []);

  function e() {
    process.exit(1)
  }
  async function l(k) {
    let m = IJ1(k, q);
    if (m.isCrossProject) {
      await La(m.command), y(m.command);
      return
    }
    try {
      let o = await ki(k, void 0);
      if (!o) throw Error("Failed to load conversation");
      if (!gH()) await kJ();
      R(o)
    } catch (o) {
      throw AA(o), o
    }
  }
  if (T) return qY.default.createElement(Xg3, {
    command: T
  });
  if (N) return qY.default.createElement(yG, {
    initialState: Y,
    onChangeAppState: J
  }, qY.default.createElement(WVA, {
    initialPrompt: "",
    debug: W,
    commands: A,
    initialTools: B,
    initialMessages: N.messages,
    initialFileHistorySnapshots: N.fileHistorySnapshots,
    mcpClients: G,
    dynamicMcpConfig: Z,
    mcpCliEndpoint: I,
    strictMcpConfig: X,
    systemPrompt: V,
    appendSystemPrompt: F
  }));
  if (E) return qY.default.createElement(S, null, qY.default.createElement(g4, null), qY.default.createElement($, null, " Loading conversations…"));
  return qY.default.createElement(yG, {
    initialState: Y,
    onChangeAppState: J
  }, qY.default.createElement(USA, {
    logs: v,
    maxHeight: D,
    onCancel: e,
    onSelect: l,
    onLogsChanged: x ? () => p(q) : void 0,
    initialSearchQuery: K,
    showAllProjects: q,
    onToggleAllProjects: u
  }))
}
// @from(Start 14738894, End 14739484)
function Xg3({
  command: A
}) {
  return qY.default.useEffect(() => {
    let Q = setTimeout(() => {
      process.exit(0)
    }, 100);
    return () => clearTimeout(Q)
  }, []), qY.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, qY.default.createElement($, null, "This conversation is from a different directory."), qY.default.createElement(S, {
    flexDirection: "column"
  }, qY.default.createElement($, null, "To resume, run:"), qY.default.createElement($, null, " ", A)), qY.default.createElement($, {
    dimColor: !0
  }, "(Command copied to clipboard)"))
}
// @from(Start 14739489, End 14739491)
qY
// @from(Start 14739497, End 14739651)
H$9 = L(() => {
  hA();
  DY();
  ZY1();
  GJ1();
  g1();
  S7();
  Bh();
  nt();
  Q4();
  z9();
  vYA();
  i8();
  $SA();
  TF0();
  qY = BA(VA(), 1)
})
// @from(Start 14739657, End 14739660)
C$9
// @from(Start 14739662, End 14739665)
FD0
// @from(Start 14739671, End 14745556)
E$9 = L(() => {
  Ht1();
  SD();
  C$9 = BA(QQ1(), 1);
  FD0 = class FD0 extends QLA {
    constructor(A, Q) {
      var B;
      super(Q);
      this._serverInfo = A, this._capabilities = (B = Q === null || Q === void 0 ? void 0 : Q.capabilities) !== null && B !== void 0 ? B : {}, this._instructions = Q === null || Q === void 0 ? void 0 : Q.instructions, this.setRequestHandler(eo1, (G) => this._oninitialize(G)), this.setNotificationHandler(_01, () => {
        var G;
        return (G = this.oninitialized) === null || G === void 0 ? void 0 : G.call(this)
      })
    }
    registerCapabilities(A) {
      if (this.transport) throw Error("Cannot register capabilities after connecting to transport");
      this._capabilities = b01(this._capabilities, A)
    }
    assertCapabilityForMethod(A) {
      var Q, B, G;
      switch (A) {
        case "sampling/createMessage":
          if (!((Q = this._clientCapabilities) === null || Q === void 0 ? void 0 : Q.sampling)) throw Error(`Client does not support sampling (required for ${A})`);
          break;
        case "elicitation/create":
          if (!((B = this._clientCapabilities) === null || B === void 0 ? void 0 : B.elicitation)) throw Error(`Client does not support elicitation (required for ${A})`);
          break;
        case "roots/list":
          if (!((G = this._clientCapabilities) === null || G === void 0 ? void 0 : G.roots)) throw Error(`Client does not support listing roots (required for ${A})`);
          break;
        case "ping":
          break
      }
    }
    assertNotificationCapability(A) {
      switch (A) {
        case "notifications/message":
          if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${A})`);
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources) throw Error(`Server does not support notifying about resources (required for ${A})`);
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools) throw Error(`Server does not support notifying of tool list changes (required for ${A})`);
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts) throw Error(`Server does not support notifying of prompt list changes (required for ${A})`);
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break
      }
    }
    assertRequestHandlerCapability(A) {
      switch (A) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling) throw Error(`Server does not support sampling (required for ${A})`);
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${A})`);
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts) throw Error(`Server does not support prompts (required for ${A})`);
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources) throw Error(`Server does not support resources (required for ${A})`);
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools) throw Error(`Server does not support tools (required for ${A})`);
          break;
        case "ping":
        case "initialize":
          break
      }
    }
    async _oninitialize(A) {
      let Q = A.params.protocolVersion;
      return this._clientCapabilities = A.params.capabilities, this._clientVersion = A.params.clientInfo, {
        protocolVersion: R01.includes(Q) ? Q : hl,
        capabilities: this.getCapabilities(),
        serverInfo: this._serverInfo,
        ...this._instructions && {
          instructions: this._instructions
        }
      }
    }
    getClientCapabilities() {
      return this._clientCapabilities
    }
    getClientVersion() {
      return this._clientVersion
    }
    getCapabilities() {
      return this._capabilities
    }
    async ping() {
      return this.request({
        method: "ping"
      }, Ih)
    }
    async createMessage(A, Q) {
      return this.request({
        method: "sampling/createMessage",
        params: A
      }, Xt1, Q)
    }
    async elicitInput(A, Q) {
      let B = await this.request({
        method: "elicitation/create",
        params: A
      }, Vt1, Q);
      if (B.action === "accept" && B.content) try {
        let G = new C$9.default,
          Z = G.compile(A.requestedSchema);
        if (!Z(B.content)) throw new ME(LE.InvalidParams, `Elicitation response content does not match requested schema: ${G.errorsText(Z.errors)}`)
      } catch (G) {
        if (G instanceof ME) throw G;
        throw new ME(LE.InternalError, `Error validating elicitation response: ${G}`)
      }
      return B
    }
    async listRoots(A, Q) {
      return this.request({
        method: "roots/list",
        params: A
      }, Dt1, Q)
    }
    async sendLoggingMessage(A) {
      return this.notification({
        method: "notifications/message",
        params: A
      })
    }
    async sendResourceUpdated(A) {
      return this.notification({
        method: "notifications/resources/updated",
        params: A
      })
    }
    async sendResourceListChanged() {
      return this.notification({
        method: "notifications/resources/list_changed"
      })
    }
    async sendToolListChanged() {
      return this.notification({
        method: "notifications/tools/list_changed"
      })
    }
    async sendPromptListChanged() {
      return this.notification({
        method: "notifications/prompts/list_changed"
      })
    }
  }
})
// @from(Start 14745590, End 14746947)
class KD0 {
  constructor(A = z$9.stdin, Q = z$9.stdout) {
    this._stdin = A, this._stdout = Q, this._readBuffer = new GLA, this._started = !1, this._ondata = (B) => {
      this._readBuffer.append(B), this.processReadBuffer()
    }, this._onerror = (B) => {
      var G;
      (G = this.onerror) === null || G === void 0 || G.call(this, B)
    }
  }
  async start() {
    if (this._started) throw Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    this._started = !0, this._stdin.on("data", this._ondata), this._stdin.on("error", this._onerror)
  }
  processReadBuffer() {
    var A, Q;
    while (!0) try {
      let B = this._readBuffer.readMessage();
      if (B === null) break;
      (A = this.onmessage) === null || A === void 0 || A.call(this, B)
    } catch (B) {
      (Q = this.onerror) === null || Q === void 0 || Q.call(this, B)
    }
  }
  async close() {
    var A;
    if (this._stdin.off("data", this._ondata), this._stdin.off("error", this._onerror), this._stdin.listenerCount("data") === 0) this._stdin.pause();
    this._readBuffer.clear(), (A = this.onclose) === null || A === void 0 || A.call(this)
  }
  send(A) {
    return new Promise((Q) => {
      let B = GQ1(A);
      if (this._stdout.write(B)) Q();
      else this._stdout.once("drain", Q)
    })
  }
}
// @from(Start 14746952, End 14746978)
U$9 = L(() => {
  gt1()
})
// @from(Start 14746980, End 14750665)
async function w$9(A, Q, B) {
  let Z = Gh(100);
  Bq(A);
  let I = new FD0({
    name: "claude/tengu",
    version: {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION
  }, {
    capabilities: {
      tools: {}
    }
  });
  I.setRequestHandler(Jt1, async () => {
    let J = ZE(),
      W = LC(J);
    return {
      tools: await Promise.all(W.map(async (X) => {
        let V;
        if (X.outputSchema) {
          let F = sRA(X.outputSchema);
          if (typeof F === "object" && F !== null && "type" in F && F.type === "object") V = F
        }
        return {
          ...X,
          description: await X.prompt({
            getToolPermissionContext: async () => J,
            tools: W,
            agents: []
          }),
          inputSchema: sRA(X.inputSchema),
          outputSchema: V
        }
      }))
    }
  }), I.setRequestHandler(Wt1, async ({
    params: {
      name: J,
      arguments: W
    }
  }) => {
    let X = ZE(),
      V = LC(X),
      F = V.find((K) => K.name === J);
    if (!F) throw Error(`Tool ${J} not found`);
    try {
      if (!F.isEnabled()) throw Error(`Tool ${J} is not enabled`);
      let K = k3(),
        D = await F.validateInput?.(W ?? {}, {
          abortController: o9(),
          options: {
            commands: $$9,
            tools: V,
            mainLoopModel: K,
            maxThinkingTokens: 0,
            mcpClients: [],
            mcpResources: {},
            isNonInteractiveSession: !0,
            hasAppendSystemPrompt: !1,
            debug: Q,
            verbose: B,
            agentDefinitions: {
              activeAgents: [],
              allAgents: []
            }
          },
          getAppState: async () => wp(),
          setAppState: () => {},
          messages: [],
          setMessages: () => {},
          readFileState: Z,
          setInProgressToolUseIDs: () => {},
          setResponseLength: () => {},
          updateFileHistoryState: () => {},
          agentId: e1()
        });
      if (D && !D.result) throw Error(`Tool ${J} input is invalid: ${D.message}`);
      let H = await F.call(W ?? {}, {
        abortController: o9(),
        options: {
          commands: $$9,
          tools: V,
          mainLoopModel: k3(),
          maxThinkingTokens: 0,
          mcpClients: [],
          mcpResources: {},
          isNonInteractiveSession: !0,
          hasAppendSystemPrompt: !1,
          debug: Q,
          verbose: B,
          agentDefinitions: {
            activeAgents: [],
            allAgents: []
          }
        },
        getAppState: async () => wp(),
        setAppState: () => {},
        messages: [],
        setMessages: () => {},
        readFileState: Z,
        setInProgressToolUseIDs: () => {},
        setResponseLength: () => {},
        updateFileHistoryState: () => {},
        agentId: e1()
      }, M$, uD({
        content: []
      }));
      return {
        content: [{
          type: "text",
          text: typeof H === "string" ? H : JSON.stringify(H.data)
        }]
      }
    } catch (K) {
      return AA(K instanceof Error ? K : Error(String(K))), {
        isError: !0,
        content: [{
          type: "text",
          text: (K instanceof Error ? NV0(K) : [String(K)]).filter(Boolean).join(`
`).trim() || "Error"
        }]
      }
    }
  });
  async function Y() {
    let J = new KD0;
    await I.connect(J)
  }
  return await Y()
}
// @from(Start 14750670, End 14750673)
$$9
// @from(Start 14750679, End 14750843)
q$9 = L(() => {
  E$9();
  U$9();
  SD();
  D30();
  AZ();
  u_();
  t2();
  g1();
  vM();
  Ca();
  _0();
  jF0();
  cQ();
  yq();
  OZ();
  z9();
  $$9 = [JJ1]
})
// @from(Start 14750846, End 14751073)
function DD0(A, Q, B) {
  let G = "";
  if (Object.keys(B?.enabledPlugins || {}).forEach((Z) => {
      if (Z === A || Z === Q.name || Z.startsWith(`${Q.name}@`)) G = Z
    }), !G) G = A.includes("@") ? A : Q.name;
  return G
}
// @from(Start 14751075, End 14751243)
function N$9(A) {
  if (A.includes("@")) {
    let Q = A.split("@");
    return {
      name: Q[0] || "",
      marketplace: Q[1]
    }
  }
  return {
    name: A
  }
}
// @from(Start 14751245, End 14751488)
function HD0(A, Q) {
  let {
    name: B,
    marketplace: G
  } = N$9(A);
  return Q.find((Z) => {
    if (Z.name === A || Z.name === B) return !0;
    if (G && Z.source) return Z.name === B && Z.source.includes(`@${G}`);
    return !1
  })
}
// @from(Start 14751490, End 14751787)
function CD0(A, Q, B) {
  let Z = {
    ...OB("userSettings")?.enabledPlugins
  };
  Object.keys(Z).forEach((Y) => {
    if (Y === A || Y === B.name || Y.startsWith(`${B.name}@`)) Z[Y] = Q
  });
  let {
    error: I
  } = cB("userSettings", {
    enabledPlugins: Z
  });
  if (I) throw I;
  AF()
}
// @from(Start 14751789, End 14751964)
function QW1(A, Q) {
  AA(A instanceof Error ? A : Error(String(A))), console.error(`${H1.cross} Failed to ${Q}: ${A instanceof Error?A.message:String(A)}`), process.exit(1)
}
// @from(Start 14751965, End 14753019)
async function L$9(A) {
  try {
    let {
      name: Q,
      marketplace: B
    } = N$9(A), G = await pZ(), Z, I;
    for (let [X] of Object.entries(G)) {
      if (B && X !== B) continue;
      let F = (await _D(X)).plugins.find((K) => K.name === Q);
      if (F) {
        Z = F, I = X;
        break
      }
    }
    if (!Z || !I) {
      let X = B ? `marketplace "${B}"` : "any configured marketplace";
      throw Error(`Plugin "${Q}" not found in ${X}`)
    }
    if (typeof Z.source !== "string") console.log(`Installing plugin "${Q}" from marketplace "${I}"...`), await SIA(Z.source, {
      manifest: {
        name: Z.name
      }
    });
    let Y = `${Z.name}@${I}`,
      W = {
        ...OB("userSettings")?.enabledPlugins,
        [Y]: !0
      };
    cB("userSettings", {
      enabledPlugins: W
    }), AF(), console.log(`${H1.tick} Successfully installed plugin: ${Y}`), GA("tengu_plugin_installed_cli", {
      plugin_id: Y,
      marketplace_name: I
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `install plugin "${A}"`)
  }
}
// @from(Start 14753020, End 14753801)
async function M$9(A) {
  try {
    let {
      enabled: Q,
      disabled: B
    } = await l7(), G = [...Q, ...B], Z = HD0(A, G);
    if (!Z) throw Error(`Plugin "${A}" not found in installed plugins`);
    let I = OB("userSettings"),
      Y = DD0(A, Z, I);
    if (I?.enabledPlugins?.[Y] === !1) throw Error(`Plugin "${A}" is already uninstalled`);
    CD0(Y, !1, Z);
    let F = yQA().plugins[Y]?.find((H) => H.scope === "user")?.installPath;
    pI1(Y, "user");
    let D = yQA().plugins[Y];
    if ((!D || D.length === 0) && F) try {
      lI1(F)
    } catch {}
    console.log(`${H1.tick} Successfully uninstalled plugin: ${Z.name}`), GA("tengu_plugin_uninstalled_cli", {
      plugin_id: Y
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `uninstall plugin "${A}"`)
  }
}
// @from(Start 14753802, End 14754242)
async function O$9(A) {
  try {
    let {
      disabled: Q
    } = await l7(), B = HD0(A, Q);
    if (!B) throw Error(`Plugin "${A}" not found in disabled plugins`);
    let G = OB("userSettings"),
      Z = DD0(A, B, G);
    CD0(Z, !0, B), console.log(`${H1.tick} Successfully enabled plugin: ${B.name}`), GA("tengu_plugin_enabled_cli", {
      plugin_id: Z
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `enable plugin "${A}"`)
  }
}
// @from(Start 14754243, End 14754684)
async function R$9(A) {
  try {
    let {
      enabled: Q
    } = await l7(), B = HD0(A, Q);
    if (!B) throw Error(`Plugin "${A}" not found in enabled plugins`);
    let G = OB("userSettings"),
      Z = DD0(A, B, G);
    CD0(Z, !1, B), console.log(`${H1.tick} Successfully disabled plugin: ${B.name}`), GA("tengu_plugin_disabled_cli", {
      plugin_id: Z
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `disable plugin "${A}"`)
  }
}
// @from(Start 14754689, End 14754771)
T$9 = L(() => {
  V9();
  g1();
  q0();
  fV();
  za();
  oH();
  MB();
  sQA()
})
// @from(Start 14754811, End 14754936)
function pSA() {
  let B = ((l0() || {}).cleanupPeriodDays ?? Vg3) * 24 * 60 * 60 * 1000;
  return new Date(Date.now() - B)
}
// @from(Start 14754938, End 14755046)
function Fg3(A, Q) {
  return {
    messages: A.messages + Q.messages,
    errors: A.errors + Q.errors
  }
}
// @from(Start 14755048, End 14755177)
function Kg3(A) {
  let Q = A.split(".")[0].replace(/T(\d{2})-(\d{2})-(\d{2})-(\d{3})Z/, "T$1:$2:$3.$4Z");
  return new Date(Q)
}
// @from(Start 14755179, End 14755571)
function P$9(A, Q, B) {
  let G = {
    messages: 0,
    errors: 0
  };
  try {
    let Z = RA().readdirSync(A);
    for (let I of Z) try {
      if (Kg3(I.name) < Q)
        if (RA().unlinkSync(k$(A, I.name)), B) G.messages++;
        else G.errors++
    } catch (Y) {
      AA(Y)
    }
  } catch (Z) {
    if (Z instanceof Error && "code" in Z && Z.code !== "ENOENT") AA(Z)
  }
  return G
}
// @from(Start 14755572, End 14756112)
async function Dg3() {
  let A = RA(),
    Q = pSA(),
    B = mj.errors(),
    G = mj.baseLogs(),
    Z = P$9(B, Q, !1);
  try {
    if (A.existsSync(G)) {
      let Y = A.readdirSync(G).filter((J) => J.isDirectory() && J.name.startsWith("mcp-logs-")).map((J) => k$(G, J.name));
      for (let J of Y) {
        Z = Fg3(Z, P$9(J, Q, !0));
        try {
          if (A.isDirEmptySync(J)) A.rmdirSync(J)
        } catch {}
      }
    }
  } catch (I) {
    if (I instanceof Error && "code" in I && I.code !== "ENOENT") AA(I)
  }
  return Z
}
// @from(Start 14756114, End 14756540)
function BW1(A, Q, B, G) {
  let Z = {
    messages: 0,
    errors: 0
  };
  if (!G.existsSync(A)) return Z;
  let Y = G.readdirSync(A).filter((J) => J.isFile() && J.name.endsWith(B));
  for (let J of Y) try {
    let W = k$(A, J.name);
    if (G.statSync(W).mtime < Q) G.unlinkSync(W), Z.messages++
  } catch {
    Z.errors++
  }
  try {
    if (G.isDirEmptySync(A)) G.rmdirSync(A)
  } catch {
    Z.errors++
  }
  return Z
}
// @from(Start 14756542, End 14758422)
function Hg3() {
  let A = pSA(),
    Q = {
      messages: 0,
      errors: 0
    },
    B = PVA(),
    G = RA();
  try {
    if (!G.existsSync(B)) return Q;
    let I = G.readdirSync(B).filter((Y) => Y.isDirectory()).map((Y) => k$(B, Y.name));
    for (let Y of I) try {
      let J = BW1(Y, A, ".jsonl", G);
      Q.messages += J.messages, Q.errors += J.errors;
      let W = k$(Y, "bash-outputs");
      if (G.existsSync(W)) try {
        let X = G.readdirSync(W);
        for (let V of X)
          if (V.isDirectory()) {
            let F = k$(W, V.name),
              K = BW1(F, A, ".txt", G);
            Q.messages += K.messages, Q.errors += K.errors
          } if (G.isDirEmptySync(W)) G.rmdirSync(W)
      } catch {
        Q.errors++
      }
      if (G.existsSync(Y)) try {
        let X = G.readdirSync(Y);
        for (let V of X) {
          if (!V.isDirectory()) continue;
          if (V.name === "bash-outputs") continue;
          let F = k$(Y, V.name, CV0);
          if (!G.existsSync(F)) continue;
          try {
            let K = G.readdirSync(F);
            for (let D of K) {
              if (!D.isDirectory()) continue;
              let H = k$(F, D.name),
                C = BW1(H, A, "", G);
              Q.messages += C.messages, Q.errors += C.errors;
              try {
                if (G.isDirEmptySync(H)) G.rmdirSync(H)
              } catch {}
            }
            try {
              if (G.isDirEmptySync(F)) G.rmdirSync(F)
            } catch {}
            try {
              let D = k$(Y, V.name);
              if (G.isDirEmptySync(D)) G.rmdirSync(D)
            } catch {}
          } catch {}
        }
      } catch {
        Q.errors++
      }
      try {
        if (G.isDirEmptySync(Y)) G.rmdirSync(Y)
      } catch {}
    } catch {
      Q.errors++;
      continue
    }
  } catch {
    Q.errors++
  }
  return Q
}
// @from(Start 14758424, End 14758778)
function Cg3(A, Q, B = !0) {
  let G = pSA(),
    Z = {
      messages: 0,
      errors: 0
    },
    I = RA();
  try {
    if (!I.existsSync(A)) return Z;
    let Y = BW1(A, G, Q, I);
    if (Z.messages += Y.messages, Z.errors += Y.errors, B) try {
      if (I.isDirEmptySync(A)) I.rmdirSync(A)
    } catch {}
  } catch {
    Z.errors++
  }
  return Z
}
// @from(Start 14758780, End 14758850)
function Eg3() {
  let A = k$(MQ(), "plans");
  return Cg3(A, ".md")
}
// @from(Start 14758852, End 14759462)
function zg3() {
  let A = pSA(),
    Q = {
      messages: 0,
      errors: 0
    },
    B = RA();
  try {
    let G = MQ(),
      Z = k$(G, "file-history");
    if (!B.existsSync(Z)) return Q;
    let Y = B.readdirSync(Z).filter((J) => J.isDirectory()).map((J) => k$(Z, J.name));
    for (let J of Y) try {
      if (!B.existsSync(J)) continue;
      if (B.statSync(J).mtime < A) B.rmSync(J, {
        recursive: !0,
        force: !0
      }), Q.messages++
    } catch {
      Q.errors++
    }
    try {
      if (B.isDirEmptySync(Z)) B.rmdirSync(Z)
    } catch {}
  } catch (G) {
    AA(G)
  }
  return Q
}
// @from(Start 14759464, End 14760073)
function Ug3() {
  let A = pSA(),
    Q = {
      messages: 0,
      errors: 0
    },
    B = RA();
  try {
    let G = MQ(),
      Z = k$(G, "session-env");
    if (!B.existsSync(Z)) return Q;
    let Y = B.readdirSync(Z).filter((J) => J.isDirectory()).map((J) => k$(Z, J.name));
    for (let J of Y) try {
      if (!B.existsSync(J)) continue;
      if (B.statSync(J).mtime < A) B.rmSync(J, {
        recursive: !0,
        force: !0
      }), Q.messages++
    } catch {
      Q.errors++
    }
    try {
      if (B.isDirEmptySync(Z)) B.rmdirSync(Z)
    } catch {}
  } catch (G) {
    AA(G)
  }
  return Q
}
// @from(Start 14760075, End 14760167)
function j$9() {
  setImmediate(() => {
    Dg3(), Hg3(), Eg3(), zg3(), Ug3()
  }).unref()
}
// @from(Start 14760172, End 14760180)
Vg3 = 30
// @from(Start 14760186, End 14760276)
S$9 = L(() => {
  LY1();
  g1();
  R9();
  AQ();
  MB();
  S7();
  hQ();
  jQ();
  V0()
})
// @from(Start 14760282, End 14760333)
_$9 = "com.anthropic.claude_code_browser_extension"
// @from(Start 14760337, End 14760340)
GkI
// @from(Start 14760342, End 14760345)
ZkI
// @from(Start 14760351, End 14760501)
k$9 = L(() => {
  Q3();
  V0();
  g1();
  _8();
  hQ();
  GkI = `${_$9}.json`, ZkI = `HKCU\\Software\\Google\\Chrome\\NativeMessagingHosts\\${_$9}`
})
// @from(Start 14760561, End 14760671)
function qg3() {
  let A = MW(),
    Q = su(A);
  if (Q <= y$9) return Math.floor(Q * 0.8);
  return Q - y$9
}
// @from(Start 14760673, End 14761175)
function Ng3(A) {
  return nJ(A).map((Q) => {
    if (Q.type === "user") {
      if (typeof Q.message.content === "string") return `User: ${Q.message.content}`;
      else if (Array.isArray(Q.message.content)) return `User: ${Q.message.content.filter((B)=>B.type==="text").map((B)=>B.type==="text"?B.text:"").join(`
`).trim()}`
    } else if (Q.type === "assistant") {
      let B = ji(Q);
      if (B) return `Claude: ${RMA(B).trim()}`
    }
    return null
  }).filter((Q) => Q !== null).join(`

`)
}
// @from(Start 14761176, End 14762382)
async function Lg3(A, Q) {
  if (!A.length) throw Error("Can't summarize empty conversation");
  let B = [],
    G = 0,
    Z = qg3(),
    I = null;
  for (let F = A.length - 1; F >= 0; F--) {
    let K = A[F];
    if (!K) continue;
    let D = ZK([K]),
      H = 0;
    if (I !== null && D > 0 && D < I) H = I - D;
    if (G + H > Z) break;
    if (B.unshift(K), G += H, D > 0) I = D
  }
  let Y = B.length < A.length;
  g(Y ? `Summarizing last ${B.length} of ${A.length} messages (~${G} tokens)` : `Summarizing all ${A.length} messages (~${G} tokens)`);
  let J = Ng3(B),
    X = [`Please write a 5-10 word title for the following conversation:

${Y?`[Last ${B.length} of ${A.length} messages]

`:""}${J}
`, "Respond with the title for the conversation and nothing else."];
  return (await uX({
    systemPrompt: [wg3],
    userPrompt: X.join(`
`),
    enablePromptCaching: !0,
    signal: new AbortController().signal,
    options: {
      querySource: "summarize_for_resume",
      agents: [],
      isNonInteractiveSession: Q,
      hasAppendSystemPrompt: !1,
      mcpTools: [],
      agentIdOrSessionId: e1()
    }
  })).message.content.filter((F) => F.type === "text").map((F) => F.text).join("")
}
// @from(Start 14762384, End 14762456)
function Mg3(A) {
  return x$9(PVA(), A.replace(/[^a-zA-Z0-9]/g, "-"))
}
// @from(Start 14762458, End 14762767)
function Og3(A) {
  let Q = RA();
  try {
    Q.statSync(A)
  } catch {
    return []
  }
  return Q.readdirSync(A).filter((G) => G.isFile() && G.name.endsWith(".jsonl")).map((G) => x$9(A, G.name)).sort((G, Z) => {
    let I = Q.statSync(G);
    return Q.statSync(Z).mtime.getTime() - I.mtime.getTime()
  })
}
// @from(Start 14762769, End 14762986)
function Rg3(A, Q) {
  let B = [],
    G = A;
  while (G) {
    let {
      isSidechain: Z,
      parentUuid: I,
      ...Y
    } = G;
    B.unshift(Y), G = G.parentUuid ? Q.get(G.parentUuid) : void 0
  }
  return B
}
// @from(Start 14762988, End 14763149)
function Tg3(A) {
  let Q = new Set([...A.values()].map((B) => B.parentUuid).filter((B) => B !== null));
  return [...A.values()].filter((B) => !Q.has(B.uuid))
}
// @from(Start 14763151, End 14763485)
function Pg3(A) {
  let Q = RA();
  try {
    let {
      buffer: B
    } = Q.readSync(A, {
      length: 512
    }), G = B.toString("utf8"), Z = G.indexOf(`
`);
    if (Z === -1) return JSON.parse(G.trim()).type === "summary";
    let I = G.substring(0, Z);
    return JSON.parse(I).type === "summary"
  } catch {
    return !1
  }
}
// @from(Start 14763486, End 14764097)
async function v$9(A) {
  if (N6()) return;
  let Q = Mg3(W0()),
    B = Og3(Q);
  for (let G of B) try {
    if (Pg3(G)) break;
    if (!nE($g3(G, ".jsonl"))) continue;
    let {
      messages: Y,
      summaries: J
    } = await jVA(G), W = Tg3(Y);
    for (let X of W) {
      if (J.has(X.uuid)) continue;
      let V = Rg3(X, Y);
      if (V.length === 0) continue;
      try {
        let F = await Lg3(V, A);
        if (F) await eE9(X.uuid, F)
      } catch (F) {
        AA(F instanceof Error ? F : Error(String(F)))
      }
    }
  } catch (Z) {
    AA(Z instanceof Error ? Z : Error(String(Z)))
  }
}
// @from(Start 14764102, End 14764105)
wg3
// @from(Start 14764107, End 14764118)
y$9 = 50000
// @from(Start 14764124, End 14764382)
b$9 = L(() => {
  fZ();
  cQ();
  S7();
  g1();
  V0();
  AQ();
  Sy();
  U2();
  GO();
  t2();
  _0();
  wg3 = `
Summarize this coding conversation in under 50 characters.
Capture the main task, key files, problems addressed, and current status.
`.trim()
})
// @from(Start 14764385, End 14764674)
function GW1() {
  return ED0.default.createElement($, null, "MCP servers may execute code or access system resources. All tool calls require approval. Learn more in the", " ", ED0.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/mcp"
  }, "MCP documentation"), ".")
}
// @from(Start 14764679, End 14764682)
ED0
// @from(Start 14764688, End 14764742)
zD0 = L(() => {
  hA();
  hA();
  ED0 = BA(VA(), 1)
})
// @from(Start 14764745, End 14766515)
function f$9({
  serverNames: A,
  onDone: Q
}) {
  function B(Z) {
    let I = l0() || {},
      Y = I.enabledMcpjsonServers || [],
      J = I.disabledMcpjsonServers || [],
      [W, X] = pu0(A, (V) => Z.includes(V));
    if (GA("tengu_mcp_multidialog_choice", {
        approved: W.length,
        rejected: X.length
      }), W.length > 0) {
      let V = [...new Set([...Y, ...W])];
      cB("localSettings", {
        enabledMcpjsonServers: V
      })
    }
    if (X.length > 0) {
      let V = [...new Set([...J, ...X])];
      cB("localSettings", {
        disabledMcpjsonServers: V
      })
    }
    Q()
  }
  let G = EQ();
  return f1((Z, I) => {
    if (I.escape) {
      let J = (l0() || {}).disabledMcpjsonServers || [],
        W = [...new Set([...J, ...A])];
      cB("localSettings", {
        disabledMcpjsonServers: W
      }), Q();
      return
    }
  }), y$.default.createElement(y$.default.Fragment, null, y$.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "warning"
  }, y$.default.createElement($, {
    bold: !0,
    color: "warning"
  }, A.length, " new MCP servers found in .mcp.json"), y$.default.createElement($, null, "Select any you wish to enable."), y$.default.createElement(GW1, null), y$.default.createElement(rJ1, {
    options: A.map((Z) => ({
      label: Z,
      value: Z
    })),
    defaultValue: A,
    onSubmit: B
  })), y$.default.createElement(S, {
    marginLeft: 3
  }, y$.default.createElement($, {
    dimColor: !0
  }, G.pending ? y$.default.createElement(y$.default.Fragment, null, "Press ", G.keyName, " again to exit") : y$.default.createElement(y$.default.Fragment, null, "Space to select · Enter to confirm · Esc to reject all"))))
}
// @from(Start 14766520, End 14766522)
y$
// @from(Start 14766528, End 14766624)
h$9 = L(() => {
  hA();
  ID0();
  MB();
  lu0();
  zD0();
  Q4();
  q0();
  y$ = BA(VA(), 1)
})
// @from(Start 14766627, End 14768443)
function g$9({
  serverName: A,
  onDone: Q
}) {
  function B(Z) {
    switch (GA("tengu_mcp_dialog_choice", {
        choice: Z
      }), Z) {
      case "yes":
      case "yes_all": {
        let Y = (l0() || {}).enabledMcpjsonServers || [];
        if (!Y.includes(A)) cB("localSettings", {
          enabledMcpjsonServers: [...Y, A]
        });
        if (Z === "yes_all") cB("localSettings", {
          enableAllProjectMcpServers: !0
        });
        Q();
        break
      }
      case "no": {
        let Y = (l0() || {}).disabledMcpjsonServers || [];
        if (!Y.includes(A)) cB("localSettings", {
          disabledMcpjsonServers: [...Y, A]
        });
        Q();
        break
      }
    }
  }
  let G = EQ();
  return f1((Z, I) => {
    if (I.escape) {
      Q();
      return
    }
  }), KN.default.createElement(KN.default.Fragment, null, KN.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "warning"
  }, KN.default.createElement($, {
    bold: !0,
    color: "warning"
  }, "New MCP server found in .mcp.json: ", A), KN.default.createElement(GW1, null), KN.default.createElement(M0, {
    options: [{
      label: "Use this and all future MCP servers in this project",
      value: "yes_all"
    }, {
      label: "Use this MCP server",
      value: "yes"
    }, {
      label: "Continue without using this MCP server",
      value: "no"
    }],
    onChange: (Z) => B(Z),
    onCancel: () => B("no")
  })), KN.default.createElement(S, {
    marginLeft: 3
  }, KN.default.createElement($, {
    dimColor: !0
  }, G.pending ? KN.default.createElement(KN.default.Fragment, null, "Press ", G.keyName, " again to exit") : KN.default.createElement(KN.default.Fragment, null, "Enter to confirm · Esc to reject"))))
}
// @from(Start 14768448, End 14768450)
KN
// @from(Start 14768456, End 14768542)
u$9 = L(() => {
  hA();
  J5();
  MB();
  zD0();
  Q4();
  q0();
  KN = BA(VA(), 1)
})
// @from(Start 14768544, End 14769361)
async function m$9() {
  let {
    servers: A
  } = sX("project"), Q = Object.keys(A).filter((B) => C21(B) === "pending");
  if (Q.length === 0) return;
  await new Promise(async (B) => {
    let G = () => {
      process.stdout.write("\x1B[2J\x1B[3J\x1B[H", () => {
        B()
      })
    };
    if (Q.length === 1 && Q[0] !== void 0) {
      let Z = await VG(lSA.default.createElement(yG, null, lSA.default.createElement(g$9, {
        serverName: Q[0],
        onDone: () => {
          Z.unmount?.(), G()
        }
      })), {
        exitOnCtrlC: !1
      })
    } else {
      let Z = await VG(lSA.default.createElement(yG, null, lSA.default.createElement(f$9, {
        serverNames: Q,
        onDone: () => {
          Z.unmount?.(), G()
        }
      })), {
        exitOnCtrlC: !1
      })
    }
  })
}
// @from(Start 14769366, End 14769369)
lSA
// @from(Start 14769375, End 14769463)
d$9 = L(() => {
  hA();
  h$9();
  u$9();
  z9();
  tM();
  nX();
  lSA = BA(VA(), 1)
})
// @from(Start 14769466, End 14769544)
function c$9(A) {
  return A.replace(/[A-Z]/g, (Q) => `_${Q.toLowerCase()}`)
}
// @from(Start 14769545, End 14769861)
async function UD0() {
  if (iSA.length === 0) return;
  let A = [...iSA];
  iSA = [];
  try {
    await YQ.post(jg3, A, {
      headers: {
        "Content-Type": "application/json",
        "DD-API-KEY": Sg3
      },
      timeout: yg3
    })
  } catch (Q) {
    AA(Q instanceof Error ? Q : Error(String(Q)))
  }
}
// @from(Start 14769863, End 14769964)
function bg3() {
  if (Iu) return;
  Iu = setTimeout(() => {
    Iu = null, UD0()
  }, _g3).unref()
}
// @from(Start 14769965, End 14771328)
async function $D0(A, Q) {
  if (!await fg3() || !xg3.has(A)) return;
  try {
    let G = await lc({
        model: Q.model
      }),
      {
        envContext: Z,
        ...I
      } = G,
      Y = {
        ...I,
        ...Z,
        ...Q
      };
    if (typeof Y.toolName === "string" && Y.toolName.startsWith("mcp__")) Y.toolName = "mcp";
    if (typeof Y.model === "string" && !Y.model.startsWith("claude-")) Y.model = "other";
    if (typeof Y.version === "string") Y.version = Y.version.replace(/^(\d+\.\d+\.\d+-dev\.\d{8})\.t\d+\.sha[a-f0-9]+$/, "$1");
    if (Y.status !== void 0 && Y.status !== null) {
      let V = String(Y.status);
      Y.http_status = V;
      let F = V.charAt(0);
      if (F >= "1" && F <= "5") Y.http_status_range = `${F}xx`;
      delete Y.status
    }
    let J = Y,
      X = {
        ddsource: "nodejs",
        ddtags: vg3.filter((V) => J[V] !== void 0 && J[V] !== null).map((V) => `${c$9(V)}:${J[V]}`).join(","),
        message: A,
        service: "claude-code",
        hostname: "claude-code",
        env: "external"
      };
    for (let [V, F] of Object.entries(Y))
      if (F !== void 0 && F !== null) X[c$9(V)] = F;
    if (iSA.push(X), iSA.length >= kg3) {
      if (Iu) clearTimeout(Iu), Iu = null;
      await UD0()
    } else bg3()
  } catch (G) {
    AA(G instanceof Error ? G : Error(String(G)))
  }
}
// @from(Start 14771333, End 14771391)
jg3 = "https://http-intake.logs.datadoghq.com/api/v2/logs"
// @from(Start 14771395, End 14771438)
Sg3 = "pubbc113c03434b701e6e00977875d7382f"
// @from(Start 14771442, End 14771453)
_g3 = 15000
// @from(Start 14771457, End 14771466)
kg3 = 100
// @from(Start 14771470, End 14771480)
yg3 = 5000
// @from(Start 14771484, End 14771487)
xg3
// @from(Start 14771489, End 14771492)
vg3
// @from(Start 14771494, End 14771497)
iSA
// @from(Start 14771499, End 14771508)
Iu = null
// @from(Start 14771512, End 14771515)
fg3
// @from(Start 14771521, End 14772359)
p$9 = L(() => {
  O3();
  l2();
  g1();
  B7A();
  Ft();
  xg3 = new Set(["tengu_api_error", "tengu_api_success", "tengu_compact_failed", "tengu_model_fallback_triggered", "tengu_oauth_error", "tengu_oauth_success", "tengu_oauth_token_refresh_failure", "tengu_oauth_token_refresh_success", "tengu_query_error", "tengu_tool_use_error", "tengu_tool_use_success"]), vg3 = ["arch", "clientType", "errorType", "http_status_range", "http_status", "model", "platform", "provider", "toolName", "userType", "version", "versionBase"];
  iSA = [];
  fg3 = s1(async () => {
    if (fX()) return !1;
    try {
      let A = async () => {
        if (Iu) clearTimeout(Iu), Iu = null;
        await UD0()
      };
      return process.on("beforeExit", A), !0
    } catch (A) {
      return AA(A instanceof Error ? A : Error(String(A))), !1
    }
  })
})
// @from(Start 14772362, End 14772498)
function n$9() {
  if (wD0 !== void 0) return wD0;
  try {
    return N1().cachedStatsigGates[l$9] ?? !1
  } catch {
    return !1
  }
}
// @from(Start 14772500, End 14772636)
function a$9() {
  if (qD0 !== void 0) return qD0;
  try {
    return N1().cachedStatsigGates[i$9] ?? !1
  } catch {
    return !1
  }
}
// @from(Start 14772638, End 14772835)
function hg3(A, Q) {
  let B = Qh1(A);
  if (B === 0) return;
  let G = B !== null ? {
    ...Q,
    sample_rate: B
  } : Q;
  if (SCB(A, G), n$9()) TW0(A, G);
  if (a$9()) $D0(A, G);
  Gh1(A, G)
}
// @from(Start 14772836, End 14773093)
async function gg3(A, Q) {
  let B = Qh1(A);
  if (B === 0) return;
  let G = B !== null ? {
      ...Q,
      sample_rate: B
    } : Q,
    Z = [Hh1(A, G)];
  if (n$9()) Z.push(TW0(A, G));
  if (a$9()) Z.push($D0(A, G));
  Gh1(A, G), await Promise.all(Z)
}
// @from(Start 14773094, End 14773161)
async function s$9() {
  wD0 = await hX(l$9), qD0 = await hX(i$9)
}
// @from(Start 14773163, End 14773236)
function r$9() {
  Hz0({
    logEvent: hg3,
    logEventAsync: gg3
  })
}
// @from(Start 14773241, End 14773273)
l$9 = "tengu_log_segment_events"
// @from(Start 14773277, End 14773309)
i$9 = "tengu_log_datadog_events"
// @from(Start 14773313, End 14773325)
wD0 = void 0
// @from(Start 14773329, End 14773341)
qD0 = void 0
// @from(Start 14773347, End 14773415)
o$9 = L(() => {
  u2();
  PW0();
  p$9();
  jQ();
  CUA();
  q0()
})
// @from(Start 14773421, End 14773424)
ug3
// @from(Start 14773430, End 14773469)
t$9 = L(() => {
  ug3 = BA(p21(), 1)
})
// @from(Start 14773472, End 14775507)
function e$9({
  onAccept: A
}) {
  PK.default.useEffect(() => {
    GA("tengu_bypass_permissions_mode_dialog_shown", {})
  }, []);

  function Q(G) {
    let Z = N1();
    switch (G) {
      case "accept": {
        GA("tengu_bypass_permissions_mode_dialog_accept", {}), c0({
          ...Z,
          bypassPermissionsModeAccepted: !0
        }), A();
        break
      }
      case "decline": {
        l5(1);
        break
      }
    }
  }
  let B = EQ();
  return f1((G, Z) => {
    if (Z.escape) {
      l5(0);
      return
    }
  }), PK.default.createElement(PK.default.Fragment, null, PK.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "error"
  }, PK.default.createElement($, {
    bold: !0,
    color: "error"
  }, "WARNING: Claude Code running in Bypass Permissions mode"), PK.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, PK.default.createElement($, null, "In Bypass Permissions mode, Claude Code will not ask for your approval before running potentially dangerous commands.", PK.default.createElement(bF, null), "This mode should only be used in a sandboxed container/VM that has restricted internet access and can easily be restored if damaged."), PK.default.createElement($, null, "By proceeding, you accept all responsibility for actions taken while running in Bypass Permissions mode."), PK.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/security"
  })), PK.default.createElement(M0, {
    options: [{
      label: "No, exit",
      value: "decline"
    }, {
      label: "Yes, I accept",
      value: "accept"
    }],
    onChange: (G) => Q(G),
    onCancel: () => Q("decline")
  })), PK.default.createElement(S, {
    marginLeft: 3
  }, PK.default.createElement($, {
    dimColor: !0
  }, B.pending ? PK.default.createElement(PK.default.Fragment, null, "Press ", B.keyName, " again to exit") : PK.default.createElement(PK.default.Fragment, null, "Enter to confirm · Esc to exit"))))
}
// @from(Start 14775512, End 14775514)
PK
// @from(Start 14775520, End 14775613)
Aw9 = L(() => {
  hA();
  J5();
  jQ();
  q0();
  Q4();
  hA();
  kW();
  PK = BA(VA(), 1)
})
// @from(Start 14775616, End 14777004)
function Yu({
  newState: A,
  oldState: Q
}) {
  if (A.mainLoopModel !== Q.mainLoopModel && A.mainLoopModel === null) cB("userSettings", {
    model: void 0
  }), Ts(null);
  if (A.mainLoopModel !== Q.mainLoopModel && A.mainLoopModel !== null) cB("userSettings", {
    model: A.mainLoopModel
  }), Ts(A.mainLoopModel);
  if (A.showExpandedTodos !== Q.showExpandedTodos && N1().showExpandedTodos !== A.showExpandedTodos) c0({
    ...N1(),
    showExpandedTodos: A.showExpandedTodos
  });
  if (Q !== null && A.todos !== Q.todos)
    for (let B in A.todos) UYA(A.todos[B], B);
  if (A.verbose !== Q.verbose && N1().verbose !== A.verbose) c0({
    ...N1(),
    verbose: A.verbose
  });
  if (A.thinkingEnabled !== Q.thinkingEnabled) cB("userSettings", {
    alwaysThinkingEnabled: A.thinkingEnabled
  });
  if (A.feedbackSurvey.timeLastShown !== Q.feedbackSurvey.timeLastShown && A.feedbackSurvey.timeLastShown !== null) c0({
    ...N1(),
    feedbackSurveyState: {
      lastShownTime: A.feedbackSurvey.timeLastShown
    }
  });
  if (bZ() && (A.mcp.tools.length > 0 || A.mcp.clients.length > 0 || Object.keys(A.mcp.resources).length > 0 || A.mcp !== Q.mcp)) {
    if (Yz9(A.mcp.clients, A.mcp.tools, A.mcp.resources), xVA()) pJ1()
  }
  if (A.settings !== Q.settings) try {
    LiA(), MiA()
  } catch (B) {
    AA(B instanceof Error ? B : Error(`Failed to clear auth caches: ${B}`))
  }
}
// @from(Start 14777009, End 14777108)
Qw9 = L(() => {
  jQ();
  jQ();
  _0();
  MB();
  Ti();
  _VA();
  dH();
  lJ1();
  gB();
  g1()
})
// @from(Start 14777111, End 14777812)
function Bw9() {
  let A = N1();
  if (A.autoUpdates !== !1 || A.autoUpdatesProtectedForNative === !0) return;
  try {
    let Q = OB("userSettings") || {};
    cB("userSettings", {
      ...Q,
      env: {
        ...Q.env,
        DISABLE_AUTOUPDATER: "1"
      }
    }), GA("tengu_migrate_autoupdates_to_settings", {
      was_user_preference: !0,
      already_had_env_var: !!Q.env?.DISABLE_AUTOUPDATER
    }), process.env.DISABLE_AUTOUPDATER = "1";
    let {
      autoUpdates: B,
      autoUpdatesProtectedForNative: G,
      ...Z
    } = A;
    c0(Z)
  } catch (Q) {
    AA(Error(`Failed to migrate auto-updates: ${Q}`)), GA("tengu_migrate_autoupdates_error", {
      has_error: !0
    })
  }
}
// @from(Start 14777817, End 14777866)
Gw9 = L(() => {
  jQ();
  MB();
  q0();
  g1()
})
// @from(Start 14777869, End 14779384)
function Zw9() {
  let A = j5(),
    Q = A.enableAllProjectMcpServers !== void 0,
    B = A.enabledMcpjsonServers && A.enabledMcpjsonServers.length > 0,
    G = A.disabledMcpjsonServers && A.disabledMcpjsonServers.length > 0;
  if (!Q && !B && !G) return;
  try {
    let Z = OB("localSettings") || {},
      I = {},
      Y = [];
    if (Q && Z.enableAllProjectMcpServers === void 0) I.enableAllProjectMcpServers = A.enableAllProjectMcpServers, Y.push("enableAllProjectMcpServers");
    else if (Q) Y.push("enableAllProjectMcpServers");
    if (B && A.enabledMcpjsonServers) {
      let J = Z.enabledMcpjsonServers || [];
      I.enabledMcpjsonServers = [...new Set([...J, ...A.enabledMcpjsonServers])], Y.push("enabledMcpjsonServers")
    }
    if (G && A.disabledMcpjsonServers) {
      let J = Z.disabledMcpjsonServers || [];
      I.disabledMcpjsonServers = [...new Set([...J, ...A.disabledMcpjsonServers])], Y.push("disabledMcpjsonServers")
    }
    if (Object.keys(I).length > 0) cB("localSettings", I);
    if (Y.length > 0) {
      let J = j5(),
        {
          enableAllProjectMcpServers: W,
          enabledMcpjsonServers: X,
          disabledMcpjsonServers: V,
          ...F
        } = J;
      if (Y.includes("enableAllProjectMcpServers") || Y.includes("enabledMcpjsonServers") || Y.includes("disabledMcpjsonServers")) AY(F)
    }
    GA("tengu_migrate_mcp_approval_fields_success", {
      migratedCount: Y.length
    })
  } catch {
    GA("tengu_migrate_mcp_approval_fields_error", {})
  }
}
// @from(Start 14779389, End 14779430)
Iw9 = L(() => {
  jQ();
  MB();
  q0()
})
// @from(Start 14779472, End 14779640)
function dg3(A) {
  let Q = VxA(A).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  return mg3.isAbsolute(Q) && !Q.startsWith("//") ? "/" + Q : Q
}
// @from(Start 14779642, End 14780545)
function Yw9() {
  let A = j5(),
    Q = A.ignorePatterns;
  if (!Q || !Array.isArray(Q) || Q.length === 0) return;
  let B = [];
  for (let I of Q) {
    let Y = dg3(I);
    B.push({
      toolName: "Read",
      ruleContent: Y
    }, {
      toolName: "Edit",
      ruleContent: Y
    })
  }
  if (JxA({
      ruleValues: B,
      ruleBehavior: "deny"
    }, "localSettings")) try {
    delete A.ignorePatterns, AY(A), GA("tengu_migrate_ignore_patterns_success", {
      ignore_patterns_count: Q.length
    })
  } catch (I) {
    AA(Error(`Failed to remove ignorePatterns from config: ${I instanceof Error?I.message:String(I)}`)), GA("tengu_migrate_ignore_patterns_config_cleanup_error", {
      ignore_patterns_count: Q.length
    })
  } else AA(Error("Failed to migrate ignorePatterns to settings permissions")), GA("tengu_migrate_ignore_patterns_error", {
    ignore_patterns_count: Q.length
  })
}
// @from(Start 14780550, End 14780607)
Jw9 = L(() => {
  jQ();
  q0();
  g1();
  EJ();
  is()
})
// @from(Start 14780610, End 14781029)
function Ww9() {
  if (N1().sonnet45MigrationComplete) return;
  if (V6() !== "firstParty") {
    c0({
      ...N1(),
      sonnet45MigrationComplete: !0
    });
    return
  }
  if (l0()?.model !== void 0) cB("userSettings", {
    model: void 0
  }), c0({
    ...N1(),
    sonnet45MigrationComplete: !0,
    sonnet45MigrationTimestamp: Date.now()
  });
  else c0({
    ...N1(),
    sonnet45MigrationComplete: !0
  })
}
// @from(Start 14781034, End 14781075)
Xw9 = L(() => {
  jQ();
  MB();
  lK()
})
// @from(Start 14781078, End 14781427)
function Vw9() {
  if (N1().opus45MigrationComplete) return;
  let Q = V6(),
    B = UUA() || $UA();
  if (Q !== "firstParty" || !B) {
    c0({
      ...N1(),
      opus45MigrationComplete: !0
    });
    return
  }
  if (l0()?.model !== void 0) cB("userSettings", {
    model: void 0
  });
  c0({
    ...N1(),
    opus45MigrationComplete: !0
  })
}
// @from(Start 14781432, End 14781481)
Fw9 = L(() => {
  jQ();
  MB();
  lK();
  t2()
})
// @from(Start 14781484, End 14782005)
function nSA(A, Q, B, G) {
  let Z = {
    type: "permissionPromptTool",
    permissionPromptToolName: Q.name,
    toolResult: A
  };
  if (A.behavior === "allow") {
    let I = A.updatedPermissions;
    if (I) G.setAppState((Y) => ({
      ...Y,
      toolPermissionContext: jm(Y.toolPermissionContext, I)
    })), QKA(I);
    return {
      ...A,
      decisionReason: Z
    }
  } else if (A.behavior === "deny" && A.interrupt) G.abortController.abort("tool-rejection");
  return {
    ...A,
    decisionReason: Z
  }
}
// @from(Start 14782010, End 14782013)
tyI
// @from(Start 14782015, End 14782018)
cg3
// @from(Start 14782020, End 14782023)
pg3
// @from(Start 14782025, End 14782028)
ZW1
// @from(Start 14782034, End 14782719)
ND0 = L(() => {
  Q2();
  _00();
  cK();
  tyI = W2.object({
    tool_name: W2.string().describe("The name of the tool requesting permission"),
    input: W2.record(W2.unknown()).describe("The input for the tool"),
    tool_use_id: W2.string().optional().describe("The unique tool use request ID")
  }), cg3 = W2.object({
    behavior: W2.literal("allow"),
    updatedInput: W2.record(W2.unknown()),
    updatedPermissions: W2.array(A91).optional(),
    toolUseID: W2.string().optional()
  }), pg3 = W2.object({
    behavior: W2.literal("deny"),
    message: W2.string(),
    interrupt: W2.boolean().optional(),
    toolUseID: W2.string().optional()
  }), ZW1 = W2.union([cg3, pg3])
})
// @from(Start 14782768, End 14783094)
function ig3(A) {
  if (!A) return;
  switch (A.type) {
    case "rule":
    case "mode":
    case "subcommandResults":
    case "permissionPromptTool":
      return;
    case "hook":
    case "asyncAgent":
    case "sandboxOverride":
    case "classifier":
    case "workingDir":
    case "other":
      return A.reason
  }
}
// @from(Start 14783095, End 14787850)
class aSA {
  input;
  replayUserMessages;
  structuredInput;
  pendingRequests = new Map;
  inputClosed = !1;
  unexpectedResponseCallback;
  constructor(A, Q) {
    this.input = A;
    this.replayUserMessages = Q;
    this.input = A, this.structuredInput = this.read()
  }
  async * read() {
    let A = "";
    for await (let Q of this.input) {
      A += Q;
      let B;
      while ((B = A.indexOf(`
`)) !== -1) {
        let G = A.slice(0, B);
        A = A.slice(B + 1);
        let Z = await this.processLine(G);
        if (Z) yield Z
      }
    }
    if (A) {
      let Q = await this.processLine(A);
      if (Q) yield Q
    }
    this.inputClosed = !0;
    for (let Q of this.pendingRequests.values()) Q.reject(Error("Tool permission stream closed before response received"))
  }
  getPendingPermissionRequests() {
    return this.pendingRequests.values().map((A) => A.request).filter((A) => A.request.subtype === "can_use_tool").toArray()
  }
  setUnexpectedResponseCallback(A) {
    this.unexpectedResponseCallback = A
  }
  async processLine(A) {
    try {
      let Q = JSON.parse(A);
      if (Q.type === "keep_alive") return;
      if (Q.type === "control_response") {
        let B = this.pendingRequests.get(Q.response.request_id);
        if (!B) {
          if (this.unexpectedResponseCallback) await this.unexpectedResponseCallback(Q);
          return
        }
        if (this.pendingRequests.delete(Q.response.request_id), Q.response.subtype === "error") {
          B.reject(Error(Q.response.error));
          return
        }
        let G = Q.response.response;
        if (B.schema) try {
          B.resolve(B.schema.parse(G))
        } catch (Z) {
          B.reject(Z)
        } else B.resolve({});
        if (this.replayUserMessages) return Q;
        return
      }
      if (Q.type !== "user" && Q.type !== "control_request") LD0(`Error: Expected message type 'user' or 'control', got '${Q.type}'`);
      if (Q.type === "control_request") {
        if (!Q.request) LD0("Error: Missing request on control_request");
        return Q
      }
      if (Q.message.role !== "user") LD0(`Error: Expected message role 'user', got '${Q.message.role}'`);
      return Q
    } catch (Q) {
      console.error(`Error parsing streaming input line: ${A}: ${Q}`), process.exit(1)
    }
  }
  write(A) {
    L9(JSON.stringify(A) + `
`)
  }
  async sendRequest(A, Q, B) {
    let G = lg3(),
      Z = {
        type: "control_request",
        request_id: G,
        request: A
      };
    if (this.inputClosed) throw Error("Stream closed");
    if (B?.aborted) throw Error("Request aborted");
    this.write(Z);
    let I = () => {
      this.write({
        type: "control_cancel_request",
        request_id: G
      });
      let Y = this.pendingRequests.get(G);
      if (Y) Y.reject(new WW)
    };
    if (B) B.addEventListener("abort", I, {
      once: !0
    });
    try {
      return await new Promise((Y, J) => {
        this.pendingRequests.set(G, {
          request: {
            type: "control_request",
            request_id: G,
            request: A
          },
          resolve: (W) => {
            Y(W)
          },
          reject: J,
          schema: Q
        })
      })
    } finally {
      if (B) B.removeEventListener("abort", I);
      this.pendingRequests.delete(G)
    }
  }
  createCanUseTool() {
    return async (A, Q, B, G, Z) => {
      let I = await M$(A, Q, B, G, Z);
      if (I.behavior === "allow" || I.behavior === "deny") return I;
      try {
        let Y = await this.sendRequest({
          subtype: "can_use_tool",
          tool_name: A.name,
          input: Q,
          permission_suggestions: I.suggestions,
          blocked_path: I.blockedPath,
          decision_reason: ig3(I.decisionReason),
          tool_use_id: Z,
          agent_id: B.agentId
        }, ZW1, B.abortController.signal);
        return nSA(Y, A, Q, B)
      } catch (Y) {
        return nSA({
          behavior: "deny",
          message: `Tool permission request failed: ${Y}`,
          toolUseID: Z
        }, A, Q, B)
      }
    }
  }
  createHookCallback(A, Q) {
    return {
      type: "callback",
      timeout: Q,
      callback: async (B, G, Z) => {
        try {
          return await this.sendRequest({
            subtype: "hook_callback",
            callback_id: A,
            input: B,
            tool_use_id: G || void 0
          }, Q91, Z)
        } catch (I) {
          return console.error(`Error in hook callback ${A}:`, I), {}
        }
      }
    }
  }
  async sendMcpMessage(A, Q) {
    return (await this.sendRequest({
      subtype: "mcp_message",
      server_name: A,
      message: Q
    }, j.object({
      mcp_response: j.any()
    }))).mcp_response
  }
}
// @from(Start 14787852, End 14787907)
function LD0(A) {
  console.error(A), process.exit(1)
}
// @from(Start 14787912, End 14787971)
MD0 = L(() => {
  AZ();
  Q2();
  ND0();
  k00();
  RZ()
})
// @from(Start 14787973, End 14793201)
class OD0 {
  ws = null;
  lastSentId = null;
  url;
  state = "idle";
  onData;
  onCloseCallback;
  headers;
  reconnectAttempts = 0;
  reconnectTimer = null;
  pingInterval = null;
  messageBuffer;
  constructor(A, Q = {}) {
    this.url = A, this.headers = Q, this.messageBuffer = new K$A(ng3)
  }
  connect() {
    if (this.state !== "idle" && this.state !== "reconnecting") {
      g(`WebSocketTransport: Cannot connect, current state is ${this.state}`, {
        level: "error"
      }), k6("error", "cli_websocket_connect_failed");
      return
    }
    this.state = "reconnecting", g(`WebSocketTransport: Opening ${this.url.href}`), k6("info", "cli_websocket_connect_opening");
    let A = {
      ...this.headers
    };
    if (this.lastSentId) A["X-Last-Request-Id"] = this.lastSentId, g(`WebSocketTransport: Adding X-Last-Request-Id header: ${this.lastSentId}`);
    this.ws = new __(this.url.href, {
      headers: A,
      agent: RzA(this.url.href)
    }), this.ws.on("open", () => {
      g("WebSocketTransport: Connected"), k6("info", "cli_websocket_connect_connected");
      let Q = this.ws.upgradeReq;
      if (Q?.headers?.["x-last-request-id"]) {
        let B = Q.headers["x-last-request-id"];
        this.replayBufferedMessages(B)
      }
      this.reconnectAttempts = 0, this.state = "connected", this.startPingInterval()
    }), this.ws.on("message", (Q) => {
      let B = Q.toString();
      if (this.onData) this.onData(B)
    }), this.ws.on("error", (Q) => {
      g(`WebSocketTransport: Error: ${Q.message}`, {
        level: "error"
      }), k6("error", "cli_websocket_connect_error"), this.handleConnectionError()
    }), this.ws.on("close", (Q, B) => {
      g(`WebSocketTransport: Closed: ${Q}`, {
        level: "error"
      }), k6("error", "cli_websocket_connect_closed"), this.handleConnectionError()
    })
  }
  sendLine(A) {
    if (!this.ws || this.state !== "connected") return g("WebSocketTransport: Not connected"), k6("info", "cli_websocket_send_not_connected"), !1;
    try {
      return this.ws.send(A), !0
    } catch (Q) {
      return g(`WebSocketTransport: Failed to send: ${Q}`, {
        level: "error"
      }), k6("error", "cli_websocket_send_error"), this.ws = null, this.handleConnectionError(), !1
    }
  }
  doDisconnect() {
    if (this.stopPingInterval(), this.ws) this.ws.close(), this.ws = null
  }
  handleConnectionError() {
    if (g(`WebSocketTransport: Disconnected from ${this.url.href}`), k6("info", "cli_websocket_disconnected"), this.doDisconnect(), this.state === "closing" || this.state === "closed") return;
    if (this.reconnectAttempts < Kw9) {
      if (this.reconnectTimer) clearTimeout(this.reconnectTimer), this.reconnectTimer = null;
      this.state = "reconnecting", this.reconnectAttempts++;
      let A = Math.min(ag3 * Math.pow(2, this.reconnectAttempts - 1), sg3);
      g(`WebSocketTransport: Reconnecting in ${A}ms (attempt ${this.reconnectAttempts}/${Kw9})`), k6("error", "cli_websocket_reconnect_attempt", {
        reconnectAttempts: this.reconnectAttempts
      }), this.reconnectTimer = setTimeout(() => {
        this.reconnectTimer = null, this.connect()
      }, A)
    } else if (g(`WebSocketTransport: Max reconnection attempts reached for ${this.url.href}`, {
        level: "error"
      }), k6("error", "cli_websocket_reconnect_exhausted", {
        reconnectAttempts: this.reconnectAttempts
      }), this.state = "closed", this.onCloseCallback) this.onCloseCallback()
  }
  close() {
    if (this.reconnectTimer) clearTimeout(this.reconnectTimer), this.reconnectTimer = null;
    this.stopPingInterval(), this.state = "closing", this.doDisconnect()
  }
  replayBufferedMessages(A) {
    let Q = this.messageBuffer.toArray();
    if (Q.length === 0) return;
    let B = 0;
    if (A) {
      let Z = Q.findIndex((I) => ("uuid" in I) && I.uuid === A);
      if (Z >= 0) B = Z + 1
    }
    let G = Q.slice(B);
    if (G.length === 0) {
      g("WebSocketTransport: No new messages to replay"), k6("info", "cli_websocket_no_messages_to_replay");
      return
    }
    g(`WebSocketTransport: Replaying ${G.length} buffered messages`), k6("info", "cli_websocket_messages_to_replay", {
      count: G.length
    });
    for (let Z of G) {
      let I = JSON.stringify(Z) + `
`;
      if (!this.sendLine(I)) {
        this.handleConnectionError();
        break
      }
    }
  }
  isConnectedStatus() {
    return this.state === "connected"
  }
  setOnData(A) {
    this.onData = A
  }
  setOnClose(A) {
    this.onCloseCallback = A
  }
  write(A) {
    if ("uuid" in A && typeof A.uuid === "string") this.messageBuffer.add(A), this.lastSentId = A.uuid;
    let Q = JSON.stringify(A) + `
`;
    if (this.state !== "connected") return;
    this.sendLine(Q)
  }
  startPingInterval() {
    this.stopPingInterval(), this.pingInterval = setInterval(() => {
      if (this.state === "connected" && this.ws) try {
        this.ws.ping()
      } catch (A) {
        g(`WebSocketTransport: Ping failed: ${A}`, {
          level: "error"
        }), k6("error", "cli_websocket_ping_failed")
      }
    }, rg3)
  }
  stopPingInterval() {
    if (this.pingInterval) clearInterval(this.pingInterval), this.pingInterval = null
  }
}
// @from(Start 14793206, End 14793216)
ng3 = 1000
// @from(Start 14793220, End 14793227)
Kw9 = 3
// @from(Start 14793231, End 14793241)
ag3 = 1000
// @from(Start 14793245, End 14793256)
sg3 = 30000
// @from(Start 14793260, End 14793269)
rg3 = 1e4
// @from(Start 14793275, End 14793326)
Dw9 = L(() => {
  dUA();
  V0();
  _c();
  NIA()
})
// @from(Start 14793329, End 14793489)
function Hw9(A, Q = {}) {
  if (A.protocol === "ws:" || A.protocol === "wss:") return new OD0(A, Q);
  else throw Error(`Unsupported protocol: ${A.protocol}`)
}
// @from(Start 14793494, End 14793520)
Cw9 = L(() => {
  Dw9()
})
// @from(Start 14793609, End 14793612)
RD0
// @from(Start 14793618, End 14794512)
Ew9 = L(() => {
  MD0();
  Cw9();
  HH();
  yQ1();
  RD0 = class RD0 extends aSA {
    url;
    transport;
    inputStream;
    constructor(A, Q, B) {
      let G = new tg3({
        encoding: "utf8"
      });
      super(G, B);
      this.inputStream = G, this.url = new og3(A);
      let Z = {},
        I = cAA();
      if (I) Z.Authorization = `Bearer ${I}`;
      if (this.transport = Hw9(this.url, Z), this.transport.setOnData((Y) => {
          this.inputStream.write(Y)
        }), this.transport.setOnClose(() => {
          this.inputStream.end()
        }), this.transport.connect(), PG(async () => this.close()), Q) {
        let Y = this.inputStream;
        (async () => {
          for await (let J of Q) Y.write(J + `
`)
        })()
      }
    }
    write(A) {
      this.transport.write(A)
    }
    close() {
      this.transport.close(), this.inputStream.end()
    }
  }
})
// @from(Start 14794515, End 14794987)
function zw9(A) {
  let Q = process.env.CLAUDE_CODE_EXIT_AFTER_STOP_DELAY,
    B = Q ? parseInt(Q, 10) : null,
    G = B && !isNaN(B) && B > 0,
    Z = null,
    I = 0;
  return {
    start() {
      if (Z) clearTimeout(Z), Z = null;
      if (G) I = Date.now(), Z = setTimeout(() => {
        let Y = Date.now() - I;
        if (A() && Y >= B) g(`Exiting after ${B}ms of idle time`), l5()
      }, B)
    },
    stop() {
      if (Z) clearTimeout(Z), Z = null
    }
  }
}
// @from(Start 14794992, End 14795025)
Uw9 = L(() => {
  V0();
  kW()
})
// @from(Start 14795074, End 14795575)
function ww9(A) {
  try {
    let Q = new URL(A);
    return {
      sessionId: $w9(),
      ingressUrl: Q.href,
      isUrl: !0,
      jsonlFile: null,
      isJsonlFile: !1
    }
  } catch {
    if (nE(A)) return {
      sessionId: A,
      ingressUrl: null,
      isUrl: !1,
      jsonlFile: null,
      isJsonlFile: !1
    };
    if (A.endsWith(".jsonl")) return {
      sessionId: $w9(),
      ingressUrl: null,
      isUrl: !1,
      jsonlFile: A,
      isJsonlFile: !0
    }
  }
  return null
}
// @from(Start 14795580, End 14795605)
qw9 = L(() => {
  Sy()
})
// @from(Start 14795608, End 14796091)
function Nw9(A) {
  let Q = A.find((B) => B.name === "claude-vscode");
  if (Q && Q.type === "connected") {
    Q.client.setNotificationHandler(eg3, async (G) => {
      let {
        eventName: Z,
        eventData: I
      } = G.params;
      GA(`tengu_vscode_${Z}`, I)
    });
    let B = {
      tengu_vscode_review_upsell: o2("tengu_vscode_review_upsell")
    };
    Q.client.notification({
      method: "experiment_gates",
      params: {
        gates: B
      }
    })
  }
}
// @from(Start 14796096, End 14796099)
eg3
// @from(Start 14796105, End 14796310)
Lw9 = L(() => {
  Q2();
  q0();
  u2();
  eg3 = j.object({
    method: j.literal("log_event"),
    params: j.object({
      eventName: j.string(),
      eventData: j.object({}).passthrough()
    })
  })
})
// @from(Start 14796398, End 14799141)
async function Rw9(A, Q, B, G, Z, I, Y, J) {
  if (await fYA()) await $D9();
  if (nQ.isSandboxingEnabled()) try {
    await nQ.initialize()
  } catch (q) {
    process.stderr.write(`
❌ Sandbox Error: ${q instanceof Error?q.message:String(q)}
`), l5(1, "other");
    return
  }
  if (J.resumeSessionAt && !J.resume) {
    process.stderr.write(`Error: --resume-session-at requires --resume
`), l5(1);
    return
  }
  let W = await Q(),
    X = await Ju3(B, {
      continue: J.continue,
      teleport: J.teleport,
      resume: J.resume,
      resumeSessionAt: J.resumeSessionAt,
      forkSession: J.forkSession
    }),
    V = typeof J.resume === "string" && (Boolean(nE(J.resume)) || J.resume.endsWith(".jsonl")),
    F = Boolean(J.sdkUrl);
  if (!A && !V && !F) {
    process.stderr.write(`Error: Input must be provided either through stdin or as a prompt argument when using --print
`), l5(1);
    return
  }
  if (J.outputFormat === "stream-json" && !J.verbose) {
    process.stderr.write(`Error: When using --print, --output-format=stream-json requires --verbose
`), l5(1);
    return
  }
  let K = bZ() ? Z : [...Z, ...W.mcp.tools],
    D = Wu3(A, J),
    H = J.sdkUrl ? "stdio" : J.permissionPromptToolName,
    C = Gu3(H, D, W.mcp.tools);
  if (J.permissionPromptToolName) K = K.filter((q) => q.name !== J.permissionPromptToolName);
  let E = [];
  for await (let q of Qu3(D, W.mcp.clients, [...G, ...W.mcp.commands], K, X, C, I, Q, B, Y, J)) {
    if (J.outputFormat === "stream-json" && J.verbose) D.write(q);
    if (q.type !== "control_response" && q.type !== "control_request" && q.type !== "control_cancel_request" && q.type !== "stream_event" && q.type !== "keep_alive") E.push(q)
  }
  let U = dC(E);
  switch (J.outputFormat) {
    case "json":
      if (!U || U.type !== "result") throw Error("No messages returned");
      if (J.verbose) {
        L9(JSON.stringify(E) + `
`);
        break
      }
      L9(JSON.stringify(U) + `
`);
      break;
    case "stream-json":
      break;
    default:
      if (!U || U.type !== "result") throw Error("No messages returned");
      switch (U.subtype) {
        case "success":
          L9(U.result.endsWith(`
`) ? U.result : U.result + `
`);
          break;
        case "error_during_execution":
          L9("Execution error");
          break;
        case "error_max_turns":
          L9(`Error: Reached max turns (${J.maxTurns})`);
          break;
        case "error_max_budget_usd":
          L9(`Error: Exceeded USD budget (${J.maxBudgetUsd})`);
          break;
        case "error_max_structured_output_retries":
          L9("Error: Failed to provide valid structured output after maximum retries")
      }
  }
  l5(U?.type === "result" && U?.is_error ? 1 : 0)
}
// @from(Start 14799143, End 14806690)
function Qu3(A, Q, B, G, Z, I, Y, J, W, X, V) {
  let F = !1,
    K = !1,
    D, H = new YSA;
  if (V.enableAuthStatus) vH.getInstance().subscribe((k) => {
    H.enqueue({
      type: "auth_status",
      isAuthenticating: k.isAuthenticating,
      output: k.output,
      error: k.error,
      uuid: IW1(),
      session_id: e1()
    })
  });
  let C = VQ9(Z),
    E = [],
    U = !1,
    q = Z;
  for (let l of C)
    if (l.type === "system" && l.subtype === "hook_response" && l.hook_event === "SessionStart") E.push(l);
  let N = lnA().map((l) => {
      return {
        value: l.value === null ? "default" : l.value,
        displayName: l.label,
        description: l.description
      }
    }),
    R = V.userSpecifiedModel,
    T = [],
    y = [];
  async function v() {
    let l = new Set(Object.keys(Y)),
      k = new Set(T.map((FA) => FA.name)),
      m = Array.from(l).some((FA) => !k.has(FA)),
      o = Array.from(k).some((FA) => !l.has(FA));
    if (m || o) {
      for (let zA of T)
        if (!l.has(zA.name)) {
          if (zA.type === "connected") await zA.cleanup()
        } let FA = await x32(Y, (zA, NA) => A.sendMcpMessage(zA, NA));
      T = FA.clients, y = FA.tools, Nw9(T)
    }
  }
  v();
  let x = zw9(() => !F),
    p = async () => {
      if (F) return;
      if (F = !0, x.stop(), !U) {
        U = !0;
        for (let o of E) H.enqueue(o)
      }
      await v();
      let l = [...Q, ...T],
        k = [...G, ...y],
        m = xX1();
      if (m && !V.jsonSchema) {
        let o = yI1(m);
        if (o) k = [...k, o]
      }
      try {
        let o;
        while (o = await n89(J, W)) {
          if (o.mode !== "prompt" && o.mode !== "orphaned-permission") throw Error("only prompt commands are supported in streaming mode");
          let IA = o.value;
          D = o9();
          for await (let FA of o59({
            commands: B,
            prompt: IA,
            promptUuid: o.uuid,
            cwd: Au3(),
            tools: k,
            verbose: V.verbose,
            mcpClients: l,
            maxThinkingTokens: V.maxThinkingTokens,
            maxTurns: V.maxTurns,
            maxBudgetUsd: V.maxBudgetUsd,
            canUseTool: I,
            userSpecifiedModel: R,
            fallbackModel: V.fallbackModel,
            jsonSchema: xX1() ?? V.jsonSchema,
            sdkBetas: V.sdkBetas,
            mutableMessages: q,
            customSystemPrompt: V.systemPrompt,
            appendSystemPrompt: V.appendSystemPrompt,
            getAppState: J,
            setAppState: W,
            abortController: D,
            replayUserMessages: V.replayUserMessages,
            includePartialMessages: V.includePartialMessages,
            agents: X,
            orphanedPermission: o.orphanedPermission,
            setSDKStatus: (zA) => {
              H.enqueue({
                type: "system",
                subtype: "status",
                status: zA,
                session_id: e1(),
                uuid: IW1()
              })
            }
          })) {
            let zA = (FA.type === "assistant" || FA.type === "user") && FA.parent_tool_use_id,
              NA = FA.type === "user" && "isReplay" in FA && FA.isReplay;
            if (!zA && !NA && FA.type !== "stream_event") C.push(FA);
            H.enqueue(FA)
          }
        }
      } catch (o) {
        try {
          A.write({
            type: "result",
            subtype: "error_during_execution",
            duration_ms: 0,
            duration_api_ms: 0,
            is_error: !0,
            num_turns: 0,
            session_id: e1(),
            total_cost_usd: 0,
            usage: bO,
            modelUsage: {},
            permission_denials: [],
            uuid: IW1(),
            errors: [o instanceof Error ? o.message : String(o), ...z2A().map((IA) => IA.error)]
          })
        } catch {}
        l5(1);
        return
      } finally {
        F = !1, x.start()
      }
      if (K) H.done()
    }, u = function(l, k) {
      H.enqueue({
        type: "control_response",
        response: {
          subtype: "success",
          request_id: l.request_id,
          response: k
        }
      })
    }, e = function(l, k) {
      H.enqueue({
        type: "control_response",
        response: {
          subtype: "error",
          request_id: l.request_id,
          error: k
        }
      })
    };
  return A.setUnexpectedResponseCallback(async (l) => {
    await Xu3({
      message: l,
      setAppState: W,
      onEnqueued: () => {
        p()
      }
    })
  }), (async () => {
    let l = !1;
    for await (let k of A.structuredInput) {
      if (k.type === "control_request") {
        if (k.request.subtype === "interrupt") {
          if (D) D.abort();
          u(k)
        } else if (k.request.subtype === "initialize") {
          if (k.request.sdkMcpServers && k.request.sdkMcpServers.length > 0)
            for (let m of k.request.sdkMcpServers) Y[m] = {
              type: "sdk",
              name: m
            };
          await Zu3(k.request, k.request_id, l, H, B, N, A, !!V.enableAuthStatus, V, X), l = !0
        } else if (k.request.subtype === "set_permission_mode") {
          let m = k.request;
          W((o) => ({
            ...o,
            toolPermissionContext: Yu3(m, k.request_id, o.toolPermissionContext, H)
          })), u(k)
        } else if (k.request.subtype === "set_model") {
          let m = k.request.model === "default" ? jt() : k.request.model;
          R = m, Ts(m), u(k)
        } else if (k.request.subtype === "set_max_thinking_tokens") {
          if (k.request.max_thinking_tokens === null) V.maxThinkingTokens = void 0;
          else V.maxThinkingTokens = k.request.max_thinking_tokens;
          u(k)
        } else if (k.request.subtype === "mcp_status") {
          let m = [...Q, ...T].map((o) => {
            return {
              name: o.name,
              status: o.type,
              serverInfo: o.type === "connected" ? o.serverInfo : void 0
            }
          });
          u(k, {
            mcpServers: m
          })
        } else if (k.request.subtype === "mcp_message") {
          let m = k.request,
            o = T.find((IA) => IA.name === m.server_name);
          if (o && o.type === "connected") {
            if (o.client.transport?.onmessage) o.client.transport.onmessage(m.message)
          }
          u(k)
        } else if (k.request.subtype === "rewind_code") {
          let m = await J(),
            o = await Iu3(k.request.user_message_id, m, W);
          if (!o) u(k);
          else e(k, o)
        }
        continue
      } else if (k.type === "control_response") {
        if (V.replayUserMessages) H.enqueue(k);
        continue
      } else if (k.type === "keep_alive") continue;
      if (l = !0, k.uuid) {
        let m = e1();
        if (await Qz9(m, k.uuid) || Mw9.has(k.uuid)) {
          if (g(`Skipping duplicate user message: ${k.uuid}`), V.replayUserMessages) g(`Sending acknowledgment for duplicate user message: ${k.uuid}`), H.enqueue({
            type: "user",
            message: k.message,
            session_id: m,
            parent_tool_use_id: null,
            uuid: k.uuid,
            isReplay: !0
          });
          continue
        }
        Mw9.add(k.uuid)
      }
      W((m) => ({
        ...m,
        queuedCommands: [...m.queuedCommands, {
          mode: "prompt",
          value: k.message.content,
          uuid: k.uuid
        }]
      })), p()
    }
    if (K = !0, !F) H.done()
  })(), H
}
// @from(Start 14806692, End 14807644)
function Bu3(A) {
  let Q = async (B, G, Z, I, Y) => {
    let J = await M$(B, G, Z, I, Y);
    if (J.behavior === "allow" || J.behavior === "deny") return J;
    let W = await A.call({
      tool_name: B.name,
      input: G,
      tool_use_id: Y
    }, Z, Q, I);
    if (Z.abortController.signal.aborted) return {
      behavior: "deny",
      message: "Permission prompt was aborted.",
      decisionReason: {
        type: "permissionPromptTool",
        permissionPromptToolName: B.name,
        toolResult: W
      }
    };
    let X = A.mapToolResultToToolResultBlockParam(W.data, "1");
    if (!X.content || !Array.isArray(X.content) || !X.content[0] || X.content[0].type !== "text" || typeof X.content[0].text !== "string") throw Error('Permission prompt tool returned an invalid result. Expected a single text block param with type="text" and a string text value.');
    return nSA(ZW1.parse(f7(X.content[0].text)), A, G, Z)
  };
  return Q
}
// @from(Start 14807646, End 14808227)
function Gu3(A, Q, B) {
  if (A === "stdio") return Q.createCanUseTool();
  else if (A) {
    let G = B.find((Z) => Z.name === A);
    if (!G) {
      let Z = `Error: MCP tool ${A} (passed via --permission-prompt-tool) not found. Available MCP tools: ${B.map((I)=>I.name).join(", ")||"none"}`;
      throw process.stderr.write(`${Z}
`), l5(1), Error(Z)
    }
    if (!G.inputJSONSchema) {
      let Z = `Error: tool ${A} (passed via --permission-prompt-tool) must be an MCP tool`;
      throw process.stderr.write(`${Z}
`), l5(1), Error(Z)
    }
    return Bu3(G)
  }
  return M$
}
// @from(Start 14808228, End 14810101)
async function Zu3(A, Q, B, G, Z, I, Y, J, W, X) {
  if (B) {
    G.enqueue({
      type: "control_response",
      response: {
        subtype: "error",
        error: "Already initialized",
        request_id: Q,
        pending_permission_requests: Y.getPendingPermissionRequests()
      }
    });
    return
  }
  if (A.systemPrompt !== void 0) W.systemPrompt = A.systemPrompt;
  if (A.appendSystemPrompt !== void 0) W.appendSystemPrompt = A.appendSystemPrompt;
  if (A.agents) {
    let H = A31(A.agents, "flagSettings");
    X.push(...H)
  }
  let F = l0()?.outputStyle || wK,
    K = await cQA(),
    D = RiA();
  if (A.hooks) {
    let H = {};
    for (let [C, E] of Object.entries(A.hooks)) H[C] = E.map((U) => {
      let q = U.hookCallbackIds.map((w) => {
        return Y.createHookCallback(w, U.timeout)
      });
      return {
        matcher: U.matcher,
        hooks: q
      }
    });
    LkA(H)
  }
  if (A.jsonSchema) Wz0(A.jsonSchema);
  if (G.enqueue({
      type: "control_response",
      response: {
        subtype: "success",
        request_id: Q,
        response: {
          commands: Z.map((H) => ({
            name: H.userFacingName(),
            description: H.description,
            argumentHint: H.argumentHint || ""
          })),
          output_style: F,
          available_output_styles: Object.keys(K),
          models: I,
          account: {
            email: D?.email,
            organization: D?.organization,
            subscriptionType: D?.subscription,
            tokenSource: D?.tokenSource,
            apiKeySource: D?.apiKeySource
          }
        }
      }
    }), J) {
    let C = vH.getInstance().getStatus();
    if (C) G.enqueue({
      type: "auth_status",
      isAuthenticating: C.isAuthenticating,
      output: C.output,
      error: C.error,
      uuid: IW1(),
      session_id: e1()
    })
  }
}
// @from(Start 14810102, End 14810460)
async function Iu3(A, Q, B) {
  if (!EG()) return "Code rewinding is not enabled for the SDK.";
  if (!c91(Q.fileHistory, A)) return `No code checkpoint found for message ${A}`;
  try {
    await iMA((G) => B((Z) => ({
      ...Z,
      fileHistory: G(Z.fileHistory)
    })), A)
  } catch (G) {
    return `Failed to rewind code: ${G.message}`
  }
  return
}
// @from(Start 14810462, End 14810983)
function Yu3(A, Q, B, G) {
  if (A.mode === "bypassPermissions" && kE9()) return G.enqueue({
    type: "control_response",
    response: {
      subtype: "error",
      request_id: Q,
      error: "Cannot set permission mode to bypassPermissions because it is disabled by settings or configuration"
    }
  }), B;
  return G.enqueue({
    type: "control_response",
    response: {
      subtype: "success",
      request_id: Q,
      response: {
        mode: A.mode
      }
    }
  }), {
    ...B,
    mode: A.mode
  }
}
// @from(Start 14810984, End 14813105)
async function Ju3(A, Q) {
  if (Q.continue) try {
    GA("tengu_continue_print", {});
    let B = await ki(void 0, void 0);
    if (B) {
      if (!Q.forkSession) {
        if (B.sessionId) zR(B.sessionId), await Fx()
      }
      return Ow9(B.fileHistorySnapshots, A), B.messages
    }
  } catch (B) {
    return AA(B instanceof Error ? B : Error(String(B))), l5(1), []
  }
  if (Q.teleport) try {
    GA("tengu_teleport_print", {});
    let B = typeof Q.teleport === "string" ? Q.teleport : null;
    await c61();
    let G = await xRA(B);
    return (await kRA(Pg(G.log), G.branch)).messages
  } catch (B) {
    return AA(B instanceof Error ? B : Error(String(B))), l5(1), []
  }
  if (Q.resume) try {
    GA("tengu_resume_print", {});
    let B = ww9(typeof Q.resume === "string" ? Q.resume : "");
    if (!B) {
      if (process.stderr.write(`Error: --resume requires a valid session ID when used with --print
`), process.stderr.write(`Usage: claude -p --resume <session-id>
`), typeof Q.resume === "string") process.stderr.write(`Session IDs must be in UUID format (e.g., 550e8400-e29b-41d4-a716-446655440000)
`), process.stderr.write(`Provided value "${Q.resume}" is not a valid UUID
`);
      return l5(1), []
    }
    if (B.isUrl && B.ingressUrl) await oE9(B.sessionId, B.ingressUrl);
    let G = await ki(B.sessionId, B.jsonlFile || void 0);
    if (!G)
      if (B.isUrl) return await wq("startup");
      else return process.stderr.write(`No conversation found with session ID: ${B.sessionId}
`), l5(1), [];
    if (Q.resumeSessionAt) {
      let Z = G.messages.findIndex((I) => I.uuid === Q.resumeSessionAt);
      if (Z < 0) return process.stderr.write(`No message found with message.uuid of: ${Q.resumeSessionAt}
`), l5(1), [];
      G.messages = Z >= 0 ? G.messages.slice(0, Z + 1) : []
    }
    if (!Q.forkSession && G.sessionId) zR(G.sessionId), await Fx();
    return Ow9(G.fileHistorySnapshots, A), G.messages
  } catch (B) {
    return AA(B instanceof Error ? B : Error(String(B))), process.stderr.write(`Failed to resume session with --print mode
`), l5(1), []
  }
  return await wq("startup")
}
// @from(Start 14813107, End 14813502)
function Wu3(A, Q) {
  let B;
  if (typeof A === "string")
    if (A.trim() !== "") B = LQ0([JSON.stringify({
      type: "user",
      session_id: "",
      message: {
        role: "user",
        content: A
      },
      parent_tool_use_id: null
    })]);
    else B = LQ0([]);
  else B = A;
  return Q.sdkUrl ? new RD0(Q.sdkUrl, B, Q.replayUserMessages) : new aSA(B, Q.replayUserMessages)
}
// @from(Start 14813503, End 14814120)
async function Xu3({
  message: A,
  setAppState: Q,
  onEnqueued: B
}) {
  if (A.response.subtype === "success" && A.response.response?.toolUseID && typeof A.response.response.toolUseID === "string") {
    let G = A.response.response,
      {
        toolUseID: Z
      } = G;
    if (!Z) return !1;
    let I = await Gz9(Z);
    if (I) return Q((Y) => ({
      ...Y,
      queuedCommands: [...Y.queuedCommands, {
        mode: "orphaned-permission",
        value: [],
        orphanedPermission: {
          permissionResult: G,
          assistantMessage: I
        }
      }]
    })), B?.(), !0
  }
  return !1
}
// @from(Start 14814122, End 14814231)
function Ow9(A, Q) {
  if (A && A.length > 0) xYA(A, (B) => Q((G) => ({
    ...G,
    fileHistory: B
  })))
}
// @from(Start 14814236, End 14814239)
Mw9
// @from(Start 14814245, End 14814618)
Tw9 = L(() => {
  MD0();
  Ew9();
  q0();
  V0();
  fP();
  RQA();
  g1();
  qV0();
  cjA();
  vYA();
  Sy();
  _i();
  XX0();
  kW();
  Uw9();
  E9A();
  $0A();
  AZ();
  LF();
  ND0();
  OZ();
  k1A();
  Gx();
  MB();
  tJA();
  gB();
  _0();
  eXA();
  qw9();
  S7();
  Ok();
  Lw9();
  dH();
  hYA();
  XJ1();
  QjA();
  t2();
  _0();
  sU();
  $J();
  Mw9 = new Set
})
// @from(Start 14814620, End 14827043)
async function jw9() {
  GA("tengu_update_check", {}), L9(`Current version: ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION}
`), L9(`Checking for updates...
`), g("update: Starting update check"), g("update: Running diagnostic");
  let A = await YIA();
  if (g(`update: Installation type: ${A.installationType}`), g(`update: Config install method: ${A.configInstallMethod}`), A.multipleInstallations.length > 1) {
    L9(`
`), L9(tA.yellow("Warning: Multiple installations found") + `
`);
    for (let J of A.multipleInstallations) {
      let W = A.installationType === J.type ? " (currently running)" : "";
      L9(`- ${J.type} at ${J.path}${W}
`)
    }
  }
  if (A.warnings.length > 0) {
    L9(`
`);
    for (let J of A.warnings) g(`update: Warning detected: ${J.issue}`), g(`update: Showing warning: ${J.issue}`), L9(tA.yellow(`Warning: ${J.issue}
`)), L9(tA.bold(`Fix: ${J.fix}
`))
  }
  let Q = N1();
  if (!Q.installMethod && A.installationType !== "package-manager") {
    L9(`
`), L9(`Updating configuration to track installation method...
`);
    let J = "unknown";
    switch (A.installationType) {
      case "npm-local":
        J = "local";
        break;
      case "native":
        J = "native";
        break;
      case "npm-global":
        J = "global";
        break;
      default:
        J = "unknown"
    }
    c0({
      ...Q,
      installMethod: J
    }), L9(`Installation method set to: ${J}
`)
  }
  if (A.installationType === "development") L9(`
`), L9(tA.yellow("Warning: Cannot update development build") + `
`), await v6(1);
  if (A.installationType === "package-manager") {
    let J = IIA();
    if (L9(`
`), J === "homebrew") {
      L9(`Claude is managed by Homebrew.
`);
      let W = await bAA();
      if (W && !Pw9.gte({
          ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
          PACKAGE_URL: "@anthropic-ai/claude-code",
          README_URL: "https://code.claude.com/docs/en/overview",
          VERSION: "2.0.59",
          FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
        }.VERSION, W, {
          loose: !0
        })) L9(`Update available: ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION} → ${W}
`), L9(`
`), L9(`To update, run:
`), L9(tA.bold("  brew upgrade claude-code") + `
`);
      else L9(`Claude is up to date!
`)
    } else L9(`Claude is managed by a package manager.
`), L9(`Please use your package manager to update.
`);
    await v6(0)
  }
  if (Q.installMethod && A.configInstallMethod !== "not set" && A.installationType !== "package-manager") {
    let {
      installationType: J,
      configInstallMethod: W
    } = A, V = {
      "npm-local": "local",
      "npm-global": "global",
      native: "native",
      development: "development",
      unknown: "unknown"
    } [J] || J;
    if (V !== W && W !== "unknown") L9(`
`), L9(tA.yellow("Warning: Configuration mismatch") + `
`), L9(`Config expects: ${W} installation
`), L9(`Currently running: ${J}
`), L9(tA.yellow(`Updating the ${J} installation you are currently using`) + `
`), c0({
      ...Q,
      installMethod: V
    }), L9(`Config updated to reflect current installation method: ${V}
`)
  }
  if (A.installationType === "native") {
    g("update: Detected native installation, using native updater");
    try {
      let J = await Wg();
      if (J.lockFailed) L9(tA.yellow("Another process is currently updating Claude. Please try again in a moment.") + `
`), await v6(0);
      if (!J.latestVersion) process.stderr.write(`Failed to check for updates
`), await v6(1);
      if (J.latestVersion === {
          ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
          PACKAGE_URL: "@anthropic-ai/claude-code",
          README_URL: "https://code.claude.com/docs/en/overview",
          VERSION: "2.0.59",
          FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
        }.VERSION) L9(tA.green(`Claude Code is up to date (${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION})`) + `
`);
      else if (J.wasUpdated) L9(tA.green(`Successfully updated from ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION} to version ${J.latestVersion}`) + `
`);
      else L9(tA.green(`Claude Code is up to date (${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION})`) + `
`);
      await v6(0)
    } catch (J) {
      process.stderr.write(`Error: Failed to install native update
`), process.stderr.write(String(J) + `
`), process.stderr.write(`Try running "claude doctor" for diagnostics
`), await v6(1)
    }
  }
  if (Q.installMethod !== "native") aTA();
  g("update: Checking npm registry for latest version"), g(`update: Package URL: ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.PACKAGE_URL}`);
  let B = `npm view ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.PACKAGE_URL}@latest version`;
  g(`update: Running: ${B}`);
  let G = await bAA();
  if (g(`update: Latest version from npm: ${G||"FAILED"}`), !G) {
    if (g("update: Failed to get latest version from npm registry"), process.stderr.write(tA.red("Failed to check for updates") + `
`), process.stderr.write(`Unable to fetch latest version from npm registry
`), process.stderr.write(`
`), process.stderr.write(`Possible causes:
`), process.stderr.write(`  • Network connectivity issues
`), process.stderr.write(`  • npm registry is unreachable
`), process.stderr.write(`  • Corporate proxy/firewall blocking npm
`), {
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.PACKAGE_URL && !{
        ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
        PACKAGE_URL: "@anthropic-ai/claude-code",
        README_URL: "https://code.claude.com/docs/en/overview",
        VERSION: "2.0.59",
        FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
      }.PACKAGE_URL.startsWith("@anthropic")) process.stderr.write(`  • Internal/development build not published to npm
`);
    process.stderr.write(`
`), process.stderr.write(`Try:
`), process.stderr.write(`  • Check your internet connection
`), process.stderr.write(`  • Run with --debug flag for more details
`);
    let J = {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.PACKAGE_URL || "@anthropic-ai/claude-code";
    process.stderr.write(`  • Manually check: npm view ${J} version
`), process.stderr.write(`  • Check if you need to login: npm whoami
`), await v6(1)
  }
  if (G === {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION) L9(tA.green(`Claude Code is up to date (${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION})`) + `
`), await v6(0);
  L9(`New version available: ${G} (current: ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION})
`), L9(`Installing update...
`);
  let Z = !1,
    I = "";
  switch (A.installationType) {
    case "npm-local":
      Z = !0, I = "local";
      break;
    case "npm-global":
      Z = !1, I = "global";
      break;
    case "unknown": {
      let J = bl();
      Z = J, I = J ? "local" : "global", L9(tA.yellow("Warning: Could not determine installation type") + `
`), L9(`Attempting ${I} update based on file detection...
`);
      break
    }
    default:
      process.stderr.write(`Error: Cannot update ${A.installationType} installation
`), await v6(1)
  }
  L9(`Using ${I} installation update method...
`), g(`update: Update method determined: ${I}`), g(`update: useLocalUpdate: ${Z}`);
  let Y;
  if (Z) g("update: Calling installOrUpdateClaudePackage() for local update"), Y = await lNA();
  else g("update: Calling installGlobalPackage() for global update"), Y = await nNA();
  switch (g(`update: Installation status: ${Y}`), Y) {
    case "success":
      L9(tA.green(`Successfully updated from ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.VERSION} to version ${G}`) + `
`);
      break;
    case "no_permissions":
      if (process.stderr.write(`Error: Insufficient permissions to install update
`), Z) process.stderr.write(`Try manually updating with:
`), process.stderr.write(`  cd ~/.claude/local && npm update ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.PACKAGE_URL}
`);
      else process.stderr.write(`Try running with sudo or fix npm permissions
`), process.stderr.write(`Or consider using native installation with: claude install
`);
      await v6(1);
      break;
    case "install_failed":
      if (process.stderr.write(`Error: Failed to install update
`), Z) process.stderr.write(`Try manually updating with:
`), process.stderr.write(`  cd ~/.claude/local && npm update ${{ISSUES_EXPLAINER:"report the issue at https://github.com/anthropics/claude-code/issues",PACKAGE_URL:"@anthropic-ai/claude-code",README_URL:"https://code.claude.com/docs/en/overview",VERSION:"2.0.59",FEEDBACK_CHANNEL:"https://github.com/anthropics/claude-code/issues"}.PACKAGE_URL}
`);
      else process.stderr.write(`Or consider using native installation with: claude install
`);
      await v6(1);
      break;
    case "in_progress":
      process.stderr.write(`Error: Another instance is currently performing an update
`), process.stderr.write(`Please wait and try again later
`), await v6(1);
      break
  }
  await v6(0)
}
// @from(Start 14827048, End 14827051)
Pw9
// @from(Start 14827057, End 14827178)
Sw9 = L(() => {
  q0();
  ZIA();
  w01();
  jQ();
  xAA();
  uy();
  Zh();
  F9();
  V0();
  kW();
  Pw9 = BA(KU(), 1)
})
// @from(Start 14827268, End 14827443)
function Ku3() {
  let A = d0.platform === "win32",
    Q = Vu3();
  if (A) return Fu3(Q, ".local", "bin", "claude.exe").replace(/\//g, "\\");
  return "~/.local/bin/claude"
}
// @from(Start 14827445, End 14827886)
function _w9({
  messages: A
}) {
  if (A.length === 0) return null;
  return x8.default.createElement(S, {
    flexDirection: "column",
    gap: 0,
    marginBottom: 1
  }, x8.default.createElement(S, null, x8.default.createElement($, {
    color: "warning"
  }, H1.warning, " Setup notes:")), A.map((Q, B) => x8.default.createElement(S, {
    key: B,
    marginLeft: 2
  }, x8.default.createElement($, {
    dimColor: !0
  }, "• ", Q))))
}
// @from(Start 14827888, End 14833152)
function Du3({
  onDone: A,
  force: Q,
  target: B
}) {
  let [G, Z] = x8.useState({
    type: "checking"
  });
  return x8.useEffect(() => {
    async function I() {
      try {
        g(`Install: Starting installation process (force=${Q}, target=${B})`), Z({
          type: "installing",
          version: B || "stable"
        }), g(`Install: Calling installLatest(force=true, target=${B}, forceReinstall=${Q})`);
        let J = await Wg(!0, B, Q);
        if (g(`Install: installLatest returned version=${J.latestVersion}, wasUpdated=${J.wasUpdated}, lockFailed=${J.lockFailed}`), J.lockFailed) throw Error("Could not install - another process is currently installing Claude. Please try again in a moment.");
        if (!J.latestVersion) g("Install: Failed to retrieve version information during install", {
          level: "error"
        });
        if (!J.wasUpdated) g("Install: Already up to date");
        Z({
          type: "setting-up"
        });
        let W = await gy(!0);
        if (g(`Install: Setup launcher completed with ${W.length} messages`), W.length > 0) W.forEach((H) => g(`Install: Setup message: ${H.message}`));
        g("Install: Cleaning up npm installations after successful install");
        let {
          removed: X,
          errors: V,
          warnings: F
        } = await rTA();
        if (X > 0) g(`Cleaned up ${X} npm installation(s)`);
        if (V.length > 0) g(`Cleanup errors: ${V.join(", ")}`);
        let K = sTA();
        if (K.length > 0) g(`Shell alias cleanup: ${K.map((H)=>H.message).join("; ")}`);
        GA("tengu_claude_install_command", {
          has_version: J.latestVersion ? 1 : 0,
          forced: Q ? 1 : 0
        });
        let D = [...F, ...K.map((H) => H.message)];
        if (W.length > 0) Z({
          type: "set-up",
          messages: W.map((H) => H.message)
        }), setTimeout(() => {
          Z({
            type: "success",
            version: J.latestVersion || "current",
            setupMessages: [...W.map((H) => H.message), ...D]
          })
        }, 2000);
        else g("Install: Shell PATH already configured"), Z({
          type: "success",
          version: J.latestVersion || "current",
          setupMessages: D.length > 0 ? D : void 0
        })
      } catch (Y) {
        g(`Install command failed: ${Y}`, {
          level: "error"
        }), Z({
          type: "error",
          message: Y instanceof Error ? Y.message : String(Y)
        })
      }
    }
    I()
  }, [Q, B]), x8.useEffect(() => {
    if (G.type === "success") setTimeout(() => {
      A("Claude Code installation completed successfully", {
        display: "system"
      })
    }, 2000);
    else if (G.type === "error") setTimeout(() => {
      A("Claude Code installation failed", {
        display: "system"
      })
    }, 3000)
  }, [G, A]), x8.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, G.type === "checking" && x8.default.createElement($, {
    color: "claude"
  }, "Checking installation status..."), G.type === "cleaning-npm" && x8.default.createElement($, {
    color: "warning"
  }, "Cleaning up old npm installations..."), G.type === "installing" && x8.default.createElement($, {
    color: "claude"
  }, "Installing Claude Code native build ", G.version, "..."), G.type === "setting-up" && x8.default.createElement($, {
    color: "claude"
  }, "Setting up launcher and shell integration..."), G.type === "set-up" && x8.default.createElement(_w9, {
    messages: G.messages
  }), G.type === "success" && x8.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, x8.default.createElement(S, null, x8.default.createElement($, {
    color: "success"
  }, H1.tick, " "), x8.default.createElement($, {
    color: "success",
    bold: !0
  }, "Claude Code successfully installed!")), x8.default.createElement(S, {
    marginLeft: 2,
    flexDirection: "column",
    gap: 1
  }, G.version !== "current" && x8.default.createElement(S, null, x8.default.createElement($, {
    dimColor: !0
  }, "Version: "), x8.default.createElement($, {
    color: "claude"
  }, G.version)), x8.default.createElement(S, null, x8.default.createElement($, {
    dimColor: !0
  }, "Location: "), x8.default.createElement($, {
    color: "text"
  }, Ku3()))), x8.default.createElement(S, {
    marginLeft: 2,
    flexDirection: "column",
    gap: 1
  }, x8.default.createElement(S, {
    marginTop: 1
  }, x8.default.createElement($, {
    dimColor: !0
  }, "Next: Run "), x8.default.createElement($, {
    color: "claude",
    bold: !0
  }, "claude --help"), x8.default.createElement($, {
    dimColor: !0
  }, " to get started"))), G.setupMessages && x8.default.createElement(_w9, {
    messages: G.setupMessages
  })), G.type === "error" && x8.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, x8.default.createElement(S, null, x8.default.createElement($, {
    color: "error"
  }, H1.cross, " "), x8.default.createElement($, {
    color: "error"
  }, "Installation failed")), x8.default.createElement($, {
    color: "error"
  }, G.message), x8.default.createElement(S, {
    marginTop: 1
  }, x8.default.createElement($, {
    dimColor: !0
  }, "Try running with --force to override checks"))))
}
// @from(Start 14833157, End 14833159)
x8
// @from(Start 14833161, End 14833164)
kw9
// @from(Start 14833170, End 14833732)
yw9 = L(() => {
  hA();
  hA();
  uy();
  V0();
  q0();
  V9();
  c5();
  x8 = BA(VA(), 1);
  kw9 = {
    type: "local-jsx",
    name: "install",
    description: "Install Claude Code native build",
    argumentHint: "[options]",
    async call(A, Q, B) {
      let G = B.includes("--force"),
        I = B.filter((J) => !J.startsWith("--"))[0],
        {
          unmount: Y
        } = await VG(x8.default.createElement(Du3, {
          onDone: (J, W) => {
            Y(), A(J, W)
          },
          force: G,
          target: I
        }))
    }
  }
})
// @from(Start 14833735, End 14835315)
function xw9({
  targetRepo: A,
  initialPaths: Q,
  onSelectPath: B,
  onCancel: G
}) {
  let [Z, I] = rW.useState(Q), [Y, J] = rW.useState(null), [W, X] = rW.useState(!1), V = rW.useCallback(async (K) => {
    if (K === "cancel") {
      G();
      return
    }
    if (X(!0), J(null), await XU9(K, A)) {
      B(K);
      return
    }
    VU9(A, K);
    let H = Z.filter((C) => C !== K);
    I(H), X(!1), J(`${Q5(K)} no longer contains the correct repository. Select another path.`)
  }, [A, Z, B, G]), F = [...Z.map((K) => ({
    label: `Use ${tA.bold(Q5(K))}`,
    value: K
  })), {
    label: "Cancel",
    value: "cancel"
  }];
  return rW.default.createElement(hD, {
    title: "Teleport to Repo",
    onCancel: G,
    color: "background",
    borderDimColor: !0
  }, Z.length > 0 ? rW.default.createElement(rW.default.Fragment, null, rW.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, Y && rW.default.createElement($, {
    color: "error"
  }, Y), rW.default.createElement($, null, "Open Claude Code in ", rW.default.createElement($, {
    bold: !0
  }, A), ":")), W ? rW.default.createElement(S, null, rW.default.createElement(g4, null), rW.default.createElement($, null, " Validating repository…")) : rW.default.createElement(M0, {
    options: F,
    onChange: (K) => void V(K),
    onCancel: G
  })) : rW.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, Y && rW.default.createElement($, {
    color: "error"
  }, Y), rW.default.createElement($, {
    dimColor: !0
  }, "Run claude --teleport from a checkout of ", A)))
}
// @from(Start 14835320, End 14835322)
rW
// @from(Start 14835328, End 14835422)
vw9 = L(() => {
  hA();
  Mi();
  J5();
  DY();
  R9();
  nJ1();
  F9();
  rW = BA(VA(), 1)
})
// @from(Start 14835425, End 14839577)
function fw9({
  onSelect: A,
  onCancel: Q,
  isEmbedded: B = !1
}) {
  let {
    rows: G
  } = WB(), [Z, I] = K4.useState([]), [Y, J] = K4.useState(null), [W, X] = K4.useState(!0), [V, F] = K4.useState(null), [K, D] = K4.useState(!1), [H, C] = K4.useState(!1), E = K4.useCallback(async () => {
    try {
      X(!0), F(null);
      let v = await DO();
      J(v), g(`Current repository: ${v||"not detected"}`);
      let x = await QP2(),
        p = x;
      if (v) p = x.filter((e) => {
        if (!e.repo) return !1;
        return `${e.repo.owner.login}/${e.repo.name}` === v
      }), g(`Filtered ${p.length} sessions for repo ${v} from ${x.length} total`);
      let u = [...p].sort((e, l) => {
        let k = new Date(e.updated_at);
        return new Date(l.updated_at).getTime() - k.getTime()
      });
      I(u)
    } catch (v) {
      let x = v instanceof Error ? v.message : String(v);
      g(`Error loading code sessions: ${x}`), F(Cu3(x))
    } finally {
      X(!1), D(!1)
    }
  }, []), U = () => {
    D(!0), E()
  };
  f1((v, x) => {
    if (x.escape || x.ctrl && v === "c") {
      Q();
      return
    }
    if (x.ctrl && v === "r" && V) {
      U();
      return
    }
    if (V !== null && x.return) {
      Q();
      return
    }
  });
  let q = K4.useCallback(() => {
    C(!0), E()
  }, [C, E]);
  if (!H) return K4.default.createElement(m61, {
    onComplete: q
  });
  if (W) return K4.default.createElement(S, {
    flexDirection: "column",
    padding: 1
  }, K4.default.createElement(S, {
    flexDirection: "row"
  }, K4.default.createElement(g4, null), K4.default.createElement($, {
    bold: !0
  }, "Loading Claude Code sessions…")), K4.default.createElement($, {
    dimColor: !0
  }, K ? "Retrying…" : "Fetching your Claude Code sessions…"));
  if (V) return K4.default.createElement(S, {
    flexDirection: "column",
    padding: 1
  }, K4.default.createElement($, {
    bold: !0,
    color: "error"
  }, "Error loading Claude Code sessions"), Eu3(V), K4.default.createElement($, {
    dimColor: !0
  }, "Press ", K4.default.createElement($, {
    bold: !0
  }, "Ctrl+R"), " to retry · Press ", K4.default.createElement($, {
    bold: !0
  }, "Esc"), " ", "to cancel"));
  if (Z.length === 0) return K4.default.createElement(S, {
    flexDirection: "column",
    padding: 1
  }, K4.default.createElement($, {
    bold: !0
  }, "No Claude Code sessions found", Y && K4.default.createElement($, null, " for ", Y)), K4.default.createElement(S, {
    marginTop: 1
  }, K4.default.createElement($, {
    dimColor: !0
  }, "Press ", K4.default.createElement($, {
    bold: !0
  }, "Esc"), " to cancel")));
  let w = Z.map((v) => ({
      ...v,
      timeString: yiA(new Date(v.updated_at))
    })),
    N = Math.max(bw9.length, ...w.map((v) => v.timeString.length)),
    R = w.map(({
      timeString: v,
      title: x,
      id: p
    }) => {
      return {
        label: `${v.padEnd(N," ")}  ${x}`,
        value: p
      }
    }),
    T = B ? Math.min(Z.length + 7, G - 6) : G - 1,
    y = B ? Math.min(Z.length, 12) : Math.min(Z.length, G - 6);
  return K4.default.createElement(S, {
    flexDirection: "column",
    padding: 1,
    height: T
  }, K4.default.createElement($, {
    bold: !0
  }, "Select a session to resume", Y && K4.default.createElement($, {
    dimColor: !0
  }, " (", Y, ")"), ":"), K4.default.createElement(S, {
    flexDirection: "column",
    marginY: 1,
    flexGrow: 1
  }, K4.default.createElement(S, {
    marginLeft: 2
  }, K4.default.createElement($, {
    bold: !0
  }, bw9.padEnd(N, " "), Hu3, "Session Title")), K4.default.createElement(M0, {
    visibleOptionCount: y,
    options: R,
    onCancel: () => {},
    onChange: (v) => {
      let x = Z.find((p) => p.id === v);
      if (x) A(x)
    }
  })), K4.default.createElement(S, {
    flexDirection: "row"
  }, K4.default.createElement($, {
    dimColor: !0
  }, K4.default.createElement(E4, {
    shortcut: "↑/↓",
    action: "select"
  }), " · ", K4.default.createElement(E4, {
    shortcut: "Enter",
    action: "confirm"
  }), " · ", K4.default.createElement(E4, {
    shortcut: "Esc",
    action: "cancel"
  }))))
}
// @from(Start 14839579, End 14840074)
function Cu3(A) {
  let Q = A.toLowerCase();
  if (Q.includes("fetch") || Q.includes("network") || Q.includes("timeout")) return "network";
  if (Q.includes("auth") || Q.includes("token") || Q.includes("permission") || Q.includes("oauth") || Q.includes("not authenticated") || Q.includes("/login") || Q.includes("console account") || Q.includes("403")) return "auth";
  if (Q.includes("api") || Q.includes("rate limit") || Q.includes("500") || Q.includes("529")) return "api";
  return "other"
}
// @from(Start 14840076, End 14841184)
function Eu3(A) {
  switch (A) {
    case "network":
      return K4.default.createElement(S, {
        marginY: 1,
        flexDirection: "column"
      }, K4.default.createElement($, {
        dimColor: !0
      }, "Check your internet connection"));
    case "auth":
      return K4.default.createElement(S, {
        marginY: 1,
        flexDirection: "column"
      }, K4.default.createElement($, {
        dimColor: !0
      }, "Teleport requires a Claude account"), K4.default.createElement($, {
        dimColor: !0
      }, "Run ", K4.default.createElement($, {
        bold: !0
      }, "/login"), ' and select "Claude account with subscription"'));
    case "api":
      return K4.default.createElement(S, {
        marginY: 1,
        flexDirection: "column"
      }, K4.default.createElement($, {
        dimColor: !0
      }, "Sorry, Claude encountered an error"));
    case "other":
      return K4.default.createElement(S, {
        marginY: 1,
        flexDirection: "row"
      }, K4.default.createElement($, {
        dimColor: !0
      }, "Sorry, Claude Code encountered an error"))
  }
}
// @from(Start 14841189, End 14841191)
K4
// @from(Start 14841193, End 14841208)
bw9 = "Updated"
// @from(Start 14841212, End 14841222)
Hu3 = "  "
// @from(Start 14841228, End 14841339)
hw9 = L(() => {
  hA();
  J5();
  DY();
  i8();
  V0();
  Y60();
  z0A();
  Fn();
  dF();
  K4 = BA(VA(), 1)
})
// @from(Start 14841342, End 14842121)
function gw9(A) {
  let [Q, B] = ABA.useState(!1), [G, Z] = ABA.useState(null), [I, Y] = ABA.useState(null), J = ABA.useCallback(async (X) => {
    B(!0), Z(null), Y(X), GA("tengu_teleport_resume_session", {
      source: A,
      session_id: X.id
    });
    try {
      let V = await yRA(X.id);
      return B(!1), V
    } catch (V) {
      let F = {
        message: V instanceof XI ? V.message : V instanceof Error ? V.message : String(V),
        formattedMessage: V instanceof XI ? V.formattedMessage : void 0,
        isOperationError: V instanceof XI
      };
      return Z(F), B(!1), null
    }
  }, [A]), W = ABA.useCallback(() => {
    Z(null)
  }, []);
  return {
    resumeSession: J,
    isResuming: Q,
    error: G,
    selectedSession: I,
    clearError: W
  }
}
// @from(Start 14842126, End 14842129)
ABA
// @from(Start 14842135, End 14842198)
uw9 = L(() => {
  $0A();
  RZ();
  q0();
  ABA = BA(VA(), 1)
})
// @from(Start 14842201, End 14843494)
function zu3({
  onComplete: A,
  onCancel: Q,
  onError: B,
  isEmbedded: G = !1,
  source: Z
}) {
  let {
    resumeSession: I,
    isResuming: Y,
    error: J,
    selectedSession: W
  } = gw9(Z), X = async (F) => {
    let K = await I(F);
    if (K) A(K);
    else if (J) {
      if (B) B(J.message, J.formattedMessage)
    }
  }, V = () => {
    GA("tengu_teleport_cancelled", {}), Q()
  };
  if (Y && W) return Kz.default.createElement(S, {
    flexDirection: "column",
    padding: 1
  }, Kz.default.createElement(S, {
    flexDirection: "row"
  }, Kz.default.createElement(g4, null), Kz.default.createElement($, {
    bold: !0
  }, "Resuming session…")), Kz.default.createElement($, {
    dimColor: !0
  }, 'Loading "', W.title, '"…'));
  if (J && !B) return Kz.default.createElement(S, {
    flexDirection: "column",
    padding: 1
  }, Kz.default.createElement($, {
    bold: !0,
    color: "error"
  }, "Failed to resume session"), Kz.default.createElement($, {
    dimColor: !0
  }, J.message), Kz.default.createElement(S, {
    marginTop: 1
  }, Kz.default.createElement($, {
    dimColor: !0
  }, "Press ", Kz.default.createElement($, {
    bold: !0
  }, "Esc"), " to cancel")));
  return Kz.default.createElement(fw9, {
    onSelect: X,
    onCancel: V,
    isEmbedded: G
  })
}
// @from(Start 14843495, End 14844012)
async function mw9() {
  return g("selectAndResumeTeleportTask: Starting teleport flow..."), new Promise(async (A) => {
    let {
      unmount: Q
    } = await VG(Kz.default.createElement(yG, null, Kz.default.createElement(zu3, {
      onComplete: (B) => {
        Q(), A(B)
      },
      onCancel: () => {
        Q(), A(null)
      },
      onError: (B, G) => {
        process.stderr.write(G ? G + `
` : `Error: ${B}
`), Q(), A(null)
      },
      source: "cliArg"
    })), {
      exitOnCtrlC: !1
    })
  })
}
// @from(Start 14844017, End 14844019)
Kz
// @from(Start 14844025, End 14844120)
dw9 = L(() => {
  hA();
  hw9();
  DY();
  uw9();
  q0();
  z9();
  V0();
  Kz = BA(VA(), 1)
})
// @from(Start 14844123, End 14844218)
function pw9() {
  if (process.env.CLAUDE_CODE_REMOTE === "true") return;
  cw9(xq), cw9(kWA)
}
// @from(Start 14844220, End 14845361)
function cw9(A) {
  try {
    jn.call({
      prompt: "Warmup",
      subagent_type: A.agentType,
      description: "Warmup"
    }, {
      options: {
        agentDefinitions: {
          allAgents: [A],
          activeAgents: [A]
        },
        commands: [],
        debug: !1,
        mainLoopModel: k3(),
        tools: [],
        verbose: !1,
        maxThinkingTokens: 1000,
        mcpClients: [],
        mcpResources: {},
        isNonInteractiveSession: !1,
        hasAppendSystemPrompt: !1
      },
      abortController: new AbortController,
      readFileState: new tm({
        max: 1000
      }),
      getAppState: async () => wp(),
      setAppState: async () => {},
      setMessages: async () => {},
      setInProgressToolUseIDs: async () => {},
      setResponseLength: async () => {},
      updateFileHistoryState: async () => {},
      agentId: "warmup",
      messages: []
    }, async () => ({
      behavior: "deny",
      message: "Warmup",
      decisionReason: {
        type: "other",
        reason: "Warmup"
      }
    }), uD({
      content: "Warmup"
    }), () => {}).catch(() => {})
  } catch {}
}
// @from(Start 14845366, End 14845443)
lw9 = L(() => {
  bbA();
  DTA();
  _WA();
  z9();
  cQ();
  t2();
  t51()
})
// @from(Start 14845564, End 14853468)
class PD0 {
  server = null;
  secret;
  port = null;
  mcpClients;
  availableTools;
  resources;
  constructor(A, Q) {
    this.mcpClients = A, this.availableTools = Q || [], this.resources = {}, this.secret = $u3(32).toString("hex")
  }
  async start() {
    if (this.server) throw Error("MCP CLI endpoint already started");
    return new Promise((A, Q) => {
      this.server = Uu3((B, G) => {
        this.handleRequest(B, G)
      }), this.server.on("error", (B) => {
        AA(B), Q(B)
      }), this.server.listen(0, "127.0.0.1", () => {
        let B = this.server.address();
        if (!B || typeof B === "string") {
          Q(Error("Failed to get server address"));
          return
        }
        this.port = B.port;
        let G = `http://127.0.0.1:${this.port}`;
        g(`[MCP CLI Endpoint] Started on ${G}`), A({
          port: this.port,
          url: G
        })
      })
    })
  }
  getSecret() {
    return this.secret
  }
  async handleRequest(A, Q) {
    if (A.setTimeout(30000), A.on("timeout", () => {
        g("[MCP CLI Endpoint] Request timeout"), Q.writeHead(408, {
          "Content-Type": "application/json"
        }), Q.end(JSON.stringify({
          error: "Request Timeout"
        }))
      }), A.method !== "POST" || A.url !== "/mcp") {
      Q.writeHead(404, {
        "Content-Type": "application/json"
      }), Q.end(JSON.stringify({
        error: "Not Found"
      }));
      return
    }
    let B = A.headers.authorization;
    if (!B?.startsWith("Bearer ")) {
      Q.writeHead(403, {
        "Content-Type": "application/json"
      }), Q.end(JSON.stringify({
        error: "Forbidden"
      }));
      return
    }
    let G = B.slice(7);
    if (!this.validateSecret(G)) {
      Q.writeHead(403, {
        "Content-Type": "application/json"
      }), Q.end(JSON.stringify({
        error: "Forbidden"
      }));
      return
    }
    let Z = 10485760,
      I = 0,
      Y = "";
    A.on("data", (J) => {
      if (I += J.length, I > Z) {
        g(`[MCP CLI Endpoint] Request too large: ${I} bytes`), Q.writeHead(413, {
          "Content-Type": "application/json"
        }), Q.end(JSON.stringify({
          error: "Payload Too Large"
        })), A.destroy();
        return
      }
      Y += J.toString()
    }), A.on("end", async () => {
      try {
        let J = JSON.parse(Y),
          W = mz9.parse(J),
          X = await this.handleCommand(W);
        Q.writeHead(200, {
          "Content-Type": "application/json"
        }), Q.end(JSON.stringify(X))
      } catch (J) {
        let W = 500;
        if (J instanceof SyntaxError) W = 400;
        else if (J && typeof J === "object" && "name" in J) {
          if (J.name === "ZodError") W = 400
        }
        Q.writeHead(W, {
          "Content-Type": "application/json"
        }), Q.end(JSON.stringify({
          error: J instanceof Error ? J.message : "Unknown error",
          type: J instanceof Error ? J.constructor.name : "Error"
        })), AA(J instanceof Error ? J : Error(String(J)))
      }
    }), A.on("error", (J) => {
      if (AA(J), !Q.headersSent) Q.writeHead(500, {
        "Content-Type": "application/json"
      }), Q.end(JSON.stringify({
        error: "Internal Server Error"
      }))
    })
  }
  validateSecret(A) {
    try {
      let Q = Buffer.from(A),
        B = Buffer.from(this.secret);
      if (Q.length !== B.length) return !1;
      return wu3(Q, B)
    } catch {
      return !1
    }
  }
  async handleCommand(A) {
    let Q = Date.now(),
      B = A.command === "call" ? `mcp__${A.params.server}__${A.params.tool}` : void 0;
    try {
      let {
        data: G,
        metadata: Z
      } = await this.executeCommand(A), I = Date.now() - Q;
      if (A.command === "call") GA("tengu_tool_use_success", {
        toolName: B,
        isMcp: !0,
        durationMs: I
      });
      return GA("tengu_mcp_cli_command_executed", {
        command: A.command,
        success: !0,
        duration_ms: I,
        ...Z
      }), G
    } catch (G) {
      let Z = G instanceof Error ? G : Error(String(G)),
        I = Date.now() - Q,
        Y = String(G).slice(0, 2000);
      if (A.command === "call") GA("tengu_tool_use_error", {
        toolName: B,
        isMcp: !0,
        error: Y,
        durationMs: I
      });
      throw GA("tengu_mcp_cli_command_executed", {
        command: A.command,
        success: !1,
        error_type: A.command === "call" ? "tool_execution_failed" : Z.constructor,
        duration_ms: Date.now() - Q
      }), G
    }
  }
  async executeCommand(A) {
    switch (A.command) {
      case "servers": {
        let Q = hJ1(this.mcpClients);
        return {
          data: Q,
          metadata: {
            server_count: Q.length
          }
        }
      }
      case "tools": {
        let Q = gJ1(this.availableTools, A.params);
        return {
          data: Q,
          metadata: {
            tool_count: Q.length,
            filtered: !!A.params?.server
          }
        }
      }
      case "info": {
        let Q = await uJ1(this.availableTools, A.params);
        if (!Q) {
          let B = gSA(this.mcpClients, A.params.server, this.getNormalizedNames()),
            G = tQA(A.params.server, B?.type);
          if (G) throw G;
          throw new TD0(`Tool '${A.params.toolName}' not found on server '${A.params.server}'`)
        }
        return {
          data: Q,
          metadata: {
            tool_found: !0
          }
        }
      }
      case "grep": {
        let Q = mJ1(this.availableTools, A.params);
        return {
          data: Q,
          metadata: {
            match_count: Q.length
          }
        }
      }
      case "resources": {
        let Q = dJ1(this.resources, A.params, this.getNormalizedNames());
        return {
          data: Q,
          metadata: {
            resource_count: Q.length,
            filtered: !!A.params?.server
          }
        }
      }
      case "call": {
        let {
          server: Q,
          tool: B
        } = A.params;
        return {
          data: await this.callTool(A.params),
          metadata: {
            tool_name: `mcp__${Q}__${B}`
          }
        }
      }
      case "read":
        return {
          data: await this.readResource(A.params), metadata: {
            server: A.params.server
          }
        };
      default: {
        let Q = A;
        throw Error("Unknown command")
      }
    }
  }
  getConnectedClient(A) {
    let Q = gSA(this.mcpClients, A, this.getNormalizedNames()),
      B = tQA(A, Q?.type);
    if (B) throw B;
    return Q
  }
  async callTool({
    server: A,
    tool: Q,
    args: B,
    timeoutMs: G
  }) {
    let Z = this.getConnectedClient(A),
      I = `mcp__${A}__${Q}`,
      Y = this.availableTools.find((X) => X.name === I);
    if (this.availableTools.length > 0 && !Y) throw new TD0(`Tool '${Q}' not found on server '${A}'`);
    let J = Y?.originalMcpToolName || Q;
    return await Z.client.request({
      method: "tools/call",
      params: {
        name: J,
        arguments: B
      }
    }, aT, G ? {
      signal: AbortSignal.timeout(G)
    } : void 0)
  }
  async readResource({
    server: A,
    uri: Q,
    timeoutMs: B
  }) {
    return await this.getConnectedClient(A).client.readResource({
      uri: Q
    }, B ? {
      signal: AbortSignal.timeout(B)
    } : void 0)
  }
  async stop() {
    if (!this.server) return;
    return new Promise((A, Q) => {
      this.server.close((B) => {
        if (B) Q(B);
        else g("[MCP CLI Endpoint] Stopped"), this.server = null, this.port = null, A()
      })
    })
  }
  updateClients(A) {
    this.mcpClients = A
  }
  updateTools(A) {
    this.availableTools = A
  }
  updateResources(A) {
    this.resources = A
  }
  getNormalizedNames() {
    let A = {};
    for (let Q of this.mcpClients) A[n7(Q.name)] = Q.name;
    return A
  }
}
// @from(Start 14853473, End 14853476)
TD0
// @from(Start 14853482, End 14853705)
iw9 = L(() => {
  SD();
  nK0();
  aK0();
  sK0();
  rK0();
  oK0();
  V0();
  g1();
  q0();
  tK0();
  TD0 = class TD0 extends Error {
    constructor(A) {
      super(A);
      this.name = "ToolNotFoundError"
    }
  }
})
// @from(Start 14853711, End 14853719)
ow9 = {}
// @from(Start 14854070, End 14854291)
function Mu3() {
  try {
    let A = OB("policySettings");
    if (A) {
      let Q = zz9(A);
      GA("tengu_managed_settings_loaded", {
        keyCount: Q.length,
        keys: Q.join(",")
      })
    }
  } catch {}
}
// @from(Start 14854293, End 14854572)
function Ou3() {
  try {
    let A = bZ(),
      Q = process.env.ENABLE_EXPERIMENTAL_MCP_CLI !== void 0 ? "external_env_var" : "external_default",
      B = !1;
    GA("tengu_mcp_cli_status", {
      enabled: A,
      source: Q,
      legacy_env_var_set: !1
    })
  } catch {}
}
// @from(Start 14854574, End 14854964)
function Ru3() {
  let A = ms(),
    Q = process.execArgv.some((G) => {
      if (A) return /--inspect(-brk)?/.test(G);
      else return /--inspect(-brk)?|--debug(-brk)?/.test(G)
    }),
    B = process.env.NODE_OPTIONS && /--inspect(-brk)?|--debug(-brk)?/.test(process.env.NODE_OPTIONS);
  try {
    return !!global.require("inspector").url() || Q || B
  } catch {
    return Q || B
  }
}
// @from(Start 14854966, End 14855403)
function sw9() {
  let A = N1();
  c0({
    ...A,
    hasCompletedOnboarding: !0,
    lastOnboardingVersion: {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION
  })
}
// @from(Start 14855404, End 14857999)
async function rw9(A, Q, B) {
  if (Y0(!1) || process.env.IS_DEMO) return !1;
  let G = N1(),
    Z = !1;
  if (!G.theme || !G.hasCompletedOnboarding) Z = !0, await kJ(), await new Promise(async (I) => {
    let {
      unmount: Y
    } = await VG(d3.default.createElement(yG, {
      onChangeAppState: Yu
    }, d3.default.createElement(aU9, {
      onDone: async () => {
        sw9(), Y(), await kJ(), I()
      }
    })), {
      exitOnCtrlC: !1
    })
  });
  if (A !== "bypassPermissions" && process.env.CLAUBBIT !== "true") {
    let I = TJ(!1);
    if (await new Promise(async (W) => {
        let {
          unmount: X
        } = await VG(d3.default.createElement(yG, null, d3.default.createElement(V$9, {
          commands: B,
          onDone: async () => {
            if (X(), !I) await kJ();
            W()
          }
        })), {
          exitOnCtrlC: !1
        })
      }), uzA()) KU9();
    I7A(), iD();
    let {
      errors: J
    } = wa();
    if (J.length === 0) await m$9();
    if (await nZ2()) await new Promise(async (W) => {
      let {
        unmount: X
      } = await VG(d3.default.createElement(yG, null, d3.default.createElement(gY1, {
        onDone: () => {
          X(), W()
        },
        isStandaloneDialog: !0
      })), {
        exitOnCtrlC: !1
      })
    })
  }
  if (await fYA()) await new Promise(async (I) => {
    let {
      unmount: Y
    } = await VG(d3.default.createElement(yG, null, d3.default.createElement(WJ1, {
      showIfAlreadyViewed: !1,
      location: Z ? "onboarding" : "policy_update_modal",
      onDone: async (J) => {
        if (J === "escape") {
          GA("tengu_grove_policy_exited", {}), l5(0);
          return
        }
        if (Y(), J !== "skip_rendering") await kJ();
        I()
      }
    })), {
      exitOnCtrlC: !1
    })
  });
  if (process.env.ANTHROPIC_API_KEY) {
    let I = dw(process.env.ANTHROPIC_API_KEY);
    if (TiA(I) === "new") await new Promise(async (J) => {
      let {
        unmount: W
      } = await VG(d3.default.createElement(yG, {
        onChangeAppState: Yu
      }, d3.default.createElement(oJ1, {
        customApiKeyTruncated: I,
        onDone: async () => {
          W(), await kJ(), J()
        }
      })), {
        exitOnCtrlC: !1
      })
    })
  }
  if (BD0(), (A === "bypassPermissions" || Q) && !N1().bypassPermissionsModeAccepted) await new Promise(async (I) => {
    let {
      unmount: Y
    } = await VG(d3.default.createElement(yG, null, d3.default.createElement(e$9, {
      onAccept: () => {
        Y(), I()
      }
    })))
  });
  return Z
}
// @from(Start 14858000, End 14858280)
async function aw9(A, Q) {
  try {
    let B = await ZYA(A, Q);
    if (B.type === "connected") return "✓ Connected";
    else if (B.type === "needs-auth") return "⚠ Needs authentication";
    else return "✗ Failed to connect"
  } catch (B) {
    return "✗ Connection error"
  }
}
// @from(Start 14858282, End 14858402)
function Tu3() {
  let A = N1();
  c0({
    ...A,
    numStartups: (A.numStartups ?? 0) + 1
  }), Pu3(), bE0()?.add(1)
}
// @from(Start 14858403, End 14858758)
async function Pu3() {
  let [A, Q] = await Promise.all([rw(), NUA()]);
  GA("tengu_startup_telemetry", {
    is_git: A,
    worktree_count: Q,
    sandbox_enabled: nQ.isSandboxingEnabled(),
    are_unsandboxed_commands_allowed: nQ.areUnsandboxedCommandsAllowed(),
    is_auto_bash_allowed_if_sandbox_enabled: nQ.isAutoAllowBashIfSandboxedEnabled()
  })
}
// @from(Start 14858760, End 14858814)
function ju3() {
  Bw9(), Zw9(), Ww9(), Vw9(), Yw9()
}
// @from(Start 14858816, End 14858892)
function Su3() {
  if (N6()) {
    iD();
    return
  }
  if (TJ(!0)) iD()
}
// @from(Start 14858893, End 14862006)
async function JW1(A, Q, B, G, Z) {
  let I = process.version.match(/^v(\d+)\./)?.[1];
  if (!I || parseInt(I) < 18) console.error(tA.bold.red("Error: Claude Code requires Node.js version 18 or higher.")), process.exit(1);
  if (Z) zR(Z);
  S00();
  let Y = jMB();
  if (Y.status === "restored") console.log(tA.yellow("Detected an interrupted iTerm2 setup. Your original settings have been restored. You may need to restart iTerm2 for the changes to take effect."));
  else if (Y.status === "failed") console.error(tA.red(`Failed to restore iTerm2 settings. Please manually restore your original settings with: defaults import com.googlecode.iterm2 ${Y.backupPath}.`));
  try {
    let V = await tsA();
    if (V.status === "restored") console.log(tA.yellow("Detected an interrupted Terminal.app setup. Your original settings have been restored. You may need to restart Terminal.app for the changes to take effect."));
    else if (V.status === "failed") console.error(tA.red(`Failed to restore Terminal.app settings. Please manually restore your original settings with: defaults import com.apple.Terminal ${V.backupPath}.`))
  } catch (V) {
    AA(V instanceof Error ? V : Error(String(V)))
  }
  if (Bq(A), LU9(), TU9(), SU9(), hX9(), uX9(), j$9(), CZ0(), EZ0(), M9("setup_before_prefetch"), CU9(), Z8B(), sE(), iI1(), _1A(), g89(), DK(), Su3(), r$9(), nb(), jCB(), s$9(), c4B(N6()), Y0(process.env.CLAUDE_CODE_USE_BEDROCK) && !Y0(process.env.CLAUDE_CODE_SKIP_BEDROCK_AUTH)) l4B();
  j$A().catch((V) => AA(V)), UYA([], e1()), KOB(), M9("setup_after_prefetch");
  let {
    hasReleaseNotes: J
  } = SjA(N1().lastReleaseNotesSeen);
  if (J) await Z59();
  let W = o9();
  if (setTimeout(() => W.abort(), 3000), myA(W0(), W.signal, []), Q === "bypassPermissions" || B) {
    if (process.platform !== "win32" && typeof process.getuid === "function" && process.getuid() === 0 && !process.env.IS_SANDBOX) console.error("--dangerously-skip-permissions cannot be used with root/sudo privileges for security reasons"), process.exit(1)
  }
  let X = j5();
  if (X.lastCost !== void 0 && X.lastDuration !== void 0) GA("tengu_exit", {
    last_session_cost: X.lastCost,
    last_session_api_duration: X.lastAPIDuration,
    last_session_tool_duration: X.lastToolDuration,
    last_session_duration: X.lastDuration,
    last_session_lines_added: X.lastLinesAdded,
    last_session_lines_removed: X.lastLinesRemoved,
    last_session_total_input_tokens: X.lastTotalInputTokens,
    last_session_total_output_tokens: X.lastTotalOutputTokens,
    last_session_total_cache_creation_input_tokens: X.lastTotalCacheCreationInputTokens,
    last_session_total_cache_read_input_tokens: X.lastTotalCacheReadInputTokens,
    last_session_id: X.lastSessionId
  }), AY({
    ...X,
    lastCost: void 0,
    lastAPIDuration: void 0,
    lastToolDuration: void 0,
    lastDuration: void 0,
    lastLinesAdded: void 0,
    lastLinesRemoved: void 0,
    lastTotalInputTokens: void 0,
    lastTotalOutputTokens: void 0,
    lastTotalCacheCreationInputTokens: void 0,
    lastTotalCacheReadInputTokens: void 0,
    lastSessionId: void 0
  })
}
// @from(Start 14862008, End 14862693)
function _u3(A) {
  try {
    let Q = A.trim(),
      B = Q.startsWith("{") && Q.endsWith("}"),
      G;
    if (B) {
      if (!f7(Q)) process.stderr.write(tA.red(`Error: Invalid JSON provided to --settings
`)), process.exit(1);
      G = t31("claude-settings", ".json"), Lu3(G, Q, "utf8")
    } else {
      let {
        resolvedPath: Z
      } = fK(RA(), A);
      if (!YW1(Z)) process.stderr.write(tA.red(`Error: Settings file not found: ${Z}
`)), process.exit(1);
      G = Z
    }
    nE0(G), e7A()
  } catch (Q) {
    if (Q instanceof Error) AA(Q);
    process.stderr.write(tA.red(`Error processing settings: ${Q instanceof Error?Q.message:String(Q)}
`)), process.exit(1)
  }
}
// @from(Start 14862695, End 14862947)
function ku3(A) {
  try {
    let Q = vh0(A);
    Bz0(Q), e7A()
  } catch (Q) {
    if (Q instanceof Error) AA(Q);
    process.stderr.write(tA.red(`Error processing --setting-sources: ${Q instanceof Error?Q.message:String(Q)}
`)), process.exit(1)
  }
}
// @from(Start 14862949, End 14863378)
function yu3() {
  M9("eagerLoadSettings_start");
  let A = process.argv.findIndex((B) => B === "--settings");
  if (A !== -1 && A + 1 < process.argv.length) {
    let B = process.argv[A + 1];
    if (B) _u3(B)
  }
  let Q = process.argv.findIndex((B) => B === "--setting-sources");
  if (Q !== -1 && Q + 1 < process.argv.length) {
    let B = process.argv[Q + 1];
    if (B !== void 0) ku3(B)
  }
  M9("eagerLoadSettings_end")
}
// @from(Start 14863380, End 14863803)
function xu3(A) {
  if (process.env.CLAUDE_CODE_ENTRYPOINT) return;
  let Q = process.argv.slice(2),
    B = Q.indexOf("mcp");
  if (B !== -1 && Q[B + 1] === "serve") {
    process.env.CLAUDE_CODE_ENTRYPOINT = "mcp";
    return
  }
  if (Y0(process.env.CLAUDE_CODE_ACTION)) {
    process.env.CLAUDE_CODE_ENTRYPOINT = "claude-code-github-action";
    return
  }
  process.env.CLAUDE_CODE_ENTRYPOINT = A ? "sdk-cli" : "cli"
}
// @from(Start 14863804, End 14864953)
async function vu3() {
  M9("main_function_start"), process.env.NoDefaultCurrentDirectoryInExePath = "1", ez9(), process.on("exit", () => {
    uu3()
  }), process.on("SIGINT", () => {
    process.exit(0)
  }), M9("main_warning_handler_initialized");
  let A = process.argv.slice(2),
    Q = A.includes("-p") || A.includes("--print"),
    B = A.some((Y) => Y.startsWith("--sdk-url")),
    G = Q || B || !process.stdout.isTTY;
  lE0(!G), xu3(G);
  let I = (() => {
    if (process.env.GITHUB_ACTIONS === "true") return "github-action";
    if (process.env.CLAUDE_CODE_ENTRYPOINT === "sdk-ts") return "sdk-typescript";
    if (process.env.CLAUDE_CODE_ENTRYPOINT === "sdk-py") return "sdk-python";
    if (process.env.CLAUDE_CODE_ENTRYPOINT === "sdk-cli") return "sdk-cli";
    if (process.env.CLAUDE_CODE_ENTRYPOINT === "claude-vscode") return "claude-vscode";
    if (process.env.CLAUDE_CODE_SESSION_ACCESS_TOKEN || process.env.CLAUDE_CODE_WEBSOCKET_AUTH_FILE_DESCRIPTOR) return "remote";
    return "cli"
  })();
  iE0(I), M9("main_client_type_determined"), yu3(), M9("main_before_run"), process.title = "claude", await hu3(), M9("main_after_run")
}
// @from(Start 14864955, End 14865572)
function bu3(A) {
  let Q = 0,
    B = {
      exitOnCtrlC: A,
      onFlicker: (G, Z, I, Y) => {
        let J = Date.now();
        if (J - Q < 1000) GA("tengu_flicker", {
          desiredHeight: G,
          actualHeight: Z,
          ink2Enabled: I,
          reason: Y
        });
        Q = J
      }
    };
  if (!process.stdin.isTTY && !Y0(!1) && !process.argv.includes("mcp")) {
    if (GA("tengu_stdin_interactive", {}), process.platform !== "win32") try {
      let G = Nu3("/dev/tty", "r");
      B = {
        ...B,
        stdin: new qu3(G)
      }
    } catch (G) {
      AA(G)
    }
  }
  return B
}
// @from(Start 14865573, End 14865952)
async function fu3(A, Q) {
  if (!process.stdin.isTTY && !process.argv.includes("mcp")) {
    if (Q === "stream-json") return process.stdin;
    process.stdin.setEncoding("utf8");
    let B = "";
    return process.stdin.on("data", (G) => {
      B += G
    }), await new Promise((G) => {
      process.stdin.on("end", G)
    }), [A, B].filter(Boolean).join(`
`)
  }
  return A
}
// @from(Start 1631663, End 1642317)
hd0 = L(() => {
  wd0();
  Td0(); /*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */
  U64 = /\\/g, Pd0 = /\/\//, $64 = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/, w64 = /^\.[/\\]/;
  O64 = Object.freeze(new Set);
  nH1 = class nH1 extends H64 {
    constructor(A = {}) {
      super();
      this.closed = !1, this._closers = new Map, this._ignoredPaths = new Set, this._throttled = new Map, this._streams = new Set, this._symlinkPaths = new Map, this._watched = new Map, this._pendingWrites = new Map, this._pendingUnlinks = new Map, this._readyCount = 0, this._readyEmitted = !1;
      let Q = A.awaitWriteFinish,
        B = {
          stabilityThreshold: 2000,
          pollInterval: 100
        },
        G = {
          persistent: !0,
          ignoreInitial: !1,
          ignorePermissionErrors: !1,
          interval: 100,
          binaryInterval: 300,
          followSymlinks: !0,
          usePolling: !1,
          atomic: !0,
          ...A,
          ignored: A.ignored ? cxA(A.ignored) : cxA([]),
          awaitWriteFinish: Q === !0 ? B : typeof Q === "object" ? {
            ...B,
            ...Q
          } : !1
        };
      if (Od0) G.usePolling = !0;
      if (G.atomic === void 0) G.atomic = !G.usePolling;
      let Z = process.env.CHOKIDAR_USEPOLLING;
      if (Z !== void 0) {
        let J = Z.toLowerCase();
        if (J === "false" || J === "0") G.usePolling = !1;
        else if (J === "true" || J === "1") G.usePolling = !0;
        else G.usePolling = !!J
      }
      let I = process.env.CHOKIDAR_INTERVAL;
      if (I) G.interval = Number.parseInt(I, 10);
      let Y = 0;
      this._emitReady = () => {
        if (Y++, Y >= this._readyCount) this._emitReady = mxA, this._readyEmitted = !0, process.nextTick(() => this.emit(VI.READY))
      }, this._emitRaw = (...J) => this.emit(VI.RAW, ...J), this._boundRemove = this._remove.bind(this), this.options = G, this._nodeFsHandler = new pH1(this), Object.freeze(G)
    }
    _addIgnoredPath(A) {
      if (iH1(A)) {
        for (let Q of this._ignoredPaths)
          if (iH1(Q) && Q.path === A.path && Q.recursive === A.recursive) return
      }
      this._ignoredPaths.add(A)
    }
    _removeIgnoredPath(A) {
      if (this._ignoredPaths.delete(A), typeof A === "string") {
        for (let Q of this._ignoredPaths)
          if (iH1(Q) && Q.path === A) this._ignoredPaths.delete(Q)
      }
    }
    add(A, Q, B) {
      let {
        cwd: G
      } = this.options;
      this.closed = !1, this._closePromise = void 0;
      let Z = Sd0(A);
      if (G) Z = Z.map((I) => {
        return M64(I, G)
      });
      if (Z.forEach((I) => {
          this._removeIgnoredPath(I)
        }), this._userIgnored = void 0, !this._readyCount) this._readyCount = 0;
      return this._readyCount += Z.length, Promise.all(Z.map(async (I) => {
        let Y = await this._nodeFsHandler._addToNodeFs(I, !B, void 0, 0, Q);
        if (Y) this._emitReady();
        return Y
      })).then((I) => {
        if (this.closed) return;
        I.forEach((Y) => {
          if (Y) this.add(n6.dirname(Y), n6.basename(Q || Y))
        })
      }), this
    }
    unwatch(A) {
      if (this.closed) return this;
      let Q = Sd0(A),
        {
          cwd: B
        } = this.options;
      return Q.forEach((G) => {
        if (!n6.isAbsolute(G) && !this._closers.has(G)) {
          if (B) G = n6.join(B, G);
          G = n6.resolve(G)
        }
        if (this._closePath(G), this._addIgnoredPath(G), this._watched.has(G)) this._addIgnoredPath({
          path: G,
          recursive: !0
        });
        this._userIgnored = void 0
      }), this
    }
    close() {
      if (this._closePromise) return this._closePromise;
      this.closed = !0, this.removeAllListeners();
      let A = [];
      return this._closers.forEach((Q) => Q.forEach((B) => {
        let G = B();
        if (G instanceof Promise) A.push(G)
      })), this._streams.forEach((Q) => Q.destroy()), this._userIgnored = void 0, this._readyCount = 0, this._readyEmitted = !1, this._watched.forEach((Q) => Q.dispose()), this._closers.clear(), this._watched.clear(), this._streams.clear(), this._symlinkPaths.clear(), this._throttled.clear(), this._closePromise = A.length ? Promise.all(A).then(() => {
        return
      }) : Promise.resolve(), this._closePromise
    }
    getWatched() {
      let A = {};
      return this._watched.forEach((Q, B) => {
        let Z = (this.options.cwd ? n6.relative(this.options.cwd, B) : B) || yd0;
        A[Z] = Q.getChildren().sort()
      }), A
    }
    emitWithAll(A, Q) {
      if (this.emit(A, ...Q), A !== VI.ERROR) this.emit(VI.ALL, A, ...Q)
    }
    async _emit(A, Q, B) {
      if (this.closed) return;
      let G = this.options;
      if (cH1) Q = n6.normalize(Q);
      if (G.cwd) Q = n6.relative(G.cwd, Q);
      let Z = [Q];
      if (B != null) Z.push(B);
      let I = G.awaitWriteFinish,
        Y;
      if (I && (Y = this._pendingWrites.get(Q))) return Y.lastChange = new Date, this;
      if (G.atomic) {
        if (A === VI.UNLINK) return this._pendingUnlinks.set(Q, [A, ...Z]), setTimeout(() => {
          this._pendingUnlinks.forEach((J, W) => {
            this.emit(...J), this.emit(VI.ALL, ...J), this._pendingUnlinks.delete(W)
          })
        }, typeof G.atomic === "number" ? G.atomic : 100), this;
        if (A === VI.ADD && this._pendingUnlinks.has(Q)) A = VI.CHANGE, this._pendingUnlinks.delete(Q)
      }
      if (I && (A === VI.ADD || A === VI.CHANGE) && this._readyEmitted) {
        let J = (W, X) => {
          if (W) A = VI.ERROR, Z[0] = W, this.emitWithAll(A, Z);
          else if (X) {
            if (Z.length > 1) Z[1] = X;
            else Z.push(X);
            this.emitWithAll(A, Z)
          }
        };
        return this._awaitWriteFinish(Q, I.stabilityThreshold, A, J), this
      }
      if (A === VI.CHANGE) {
        if (!this._throttle(VI.CHANGE, Q, 50)) return this
      }
      if (G.alwaysStat && B === void 0 && (A === VI.ADD || A === VI.ADD_DIR || A === VI.CHANGE)) {
        let J = G.cwd ? n6.join(G.cwd, Q) : Q,
          W;
        try {
          W = await K64(J)
        } catch (X) {}
        if (!W || this.closed) return;
        Z.push(W)
      }
      return this.emitWithAll(A, Z), this
    }
    _handleError(A) {
      let Q = A && A.code;
      if (A && Q !== "ENOENT" && Q !== "ENOTDIR" && (!this.options.ignorePermissionErrors || Q !== "EPERM" && Q !== "EACCES")) this.emit(VI.ERROR, A);
      return A || this.closed
    }
    _throttle(A, Q, B) {
      if (!this._throttled.has(A)) this._throttled.set(A, new Map);
      let G = this._throttled.get(A);
      if (!G) throw Error("invalid throttle");
      let Z = G.get(Q);
      if (Z) return Z.count++, !1;
      let I, Y = () => {
        let W = G.get(Q),
          X = W ? W.count : 0;
        if (G.delete(Q), clearTimeout(I), W) clearTimeout(W.timeoutObject);
        return X
      };
      I = setTimeout(Y, B);
      let J = {
        timeoutObject: I,
        clear: Y,
        count: 0
      };
      return G.set(Q, J), J
    }
    _incrReadyCount() {
      return this._readyCount++
    }
    _awaitWriteFinish(A, Q, B, G) {
      let Z = this.options.awaitWriteFinish;
      if (typeof Z !== "object") return;
      let I = Z.pollInterval,
        Y, J = A;
      if (this.options.cwd && !n6.isAbsolute(A)) J = n6.join(this.options.cwd, A);
      let W = new Date,
        X = this._pendingWrites;

      function V(F) {
        F64(J, (K, D) => {
          if (K || !X.has(A)) {
            if (K && K.code !== "ENOENT") G(K);
            return
          }
          let H = Number(new Date);
          if (F && D.size !== F.size) X.get(A).lastChange = H;
          let C = X.get(A);
          if (H - C.lastChange >= Q) X.delete(A), G(void 0, D);
          else Y = setTimeout(V, I, D)
        })
      }
      if (!X.has(A)) X.set(A, {
        lastChange: W,
        cancelWait: () => {
          return X.delete(A), clearTimeout(Y), B
        }
      }), Y = setTimeout(V, I)
    }
    _isIgnored(A, Q) {
      if (this.options.atomic && $64.test(A)) return !0;
      if (!this._userIgnored) {
        let {
          cwd: B
        } = this.options, Z = (this.options.ignored || []).map(kd0(B)), Y = [...[...this._ignoredPaths].map(kd0(B)), ...Z];
        this._userIgnored = L64(Y, void 0)
      }
      return this._userIgnored(A, Q)
    }
    _isntIgnored(A, Q) {
      return !this._isIgnored(A, Q)
    }
    _getWatchHelpers(A) {
      return new bd0(A, this.options.followSymlinks, this)
    }
    _getWatchedDir(A) {
      let Q = n6.resolve(A);
      if (!this._watched.has(Q)) this._watched.set(Q, new vd0(Q, this._boundRemove));
      return this._watched.get(Q)
    }
    _hasReadPermissions(A) {
      if (this.options.ignorePermissionErrors) return !0;
      return Boolean(Number(A.mode) & 256)
    }
    _remove(A, Q, B) {
      let G = n6.join(A, Q),
        Z = n6.resolve(G);
      if (B = B != null ? B : this._watched.has(G) || this._watched.has(Z), !this._throttle("remove", G, 100)) return;
      if (!B && this._watched.size === 1) this.add(A, Q, !0);
      this._getWatchedDir(G).getChildren().forEach((F) => this._remove(G, F));
      let J = this._getWatchedDir(A),
        W = J.has(Q);
      if (J.remove(Q), this._symlinkPaths.has(Z)) this._symlinkPaths.delete(Z);
      let X = G;
      if (this.options.cwd) X = n6.relative(this.options.cwd, G);
      if (this.options.awaitWriteFinish && this._pendingWrites.has(X)) {
        if (this._pendingWrites.get(X).cancelWait() === VI.ADD) return
      }
      this._watched.delete(G), this._watched.delete(Z);
      let V = B ? VI.UNLINK_DIR : VI.UNLINK;
      if (W && !this._isIgnored(G)) this._emit(V, G);
      this._closePath(G)
    }
    _closePath(A) {
      this._closeFile(A);
      let Q = n6.dirname(A);
      this._getWatchedDir(Q).remove(n6.basename(A))
    }
    _closeFile(A) {
      let Q = this._closers.get(A);
      if (!Q) return;
      Q.forEach((B) => B()), this._closers.delete(A)
    }
    _addPathCloser(A, Q) {
      if (!Q) return;
      let B = this._closers.get(A);
      if (!B) B = [], this._closers.set(A, B);
      B.push(Q)
    }
    _readdirp(A, Q) {
      if (this.closed) return;
      let B = {
          type: VI.ALL,
          alwaysStat: !0,
          lstat: !0,
          ...Q,
          depth: 0
        },
        G = $d0(A, B);
      return this._streams.add(G), G.once(Md0, () => {
        G = void 0
      }), G.once(dH1, () => {
        if (G) this._streams.delete(G), G = void 0
      }), G
    }
  };
  fd0 = {
    watch: P64,
    FSWatcher: nH1
  }
})
// @from(Start 1642349, End 1642872)
function k64() {
  if (gd0 || md0) return;
  gd0 = !0;
  let A = v64();
  if (A.length === 0) return;
  g(`Watching for changes in setting files ${A.join(", ")}...`), h9A = fd0.watch(A, {
    persistent: !0,
    ignoreInitial: !0,
    awaitWriteFinish: {
      stabilityThreshold: j64,
      pollInterval: S64
    },
    ignored: (Q) => Q.split(ud0.sep).some((B) => B === ".git"),
    ignorePermissionErrors: !0,
    usePolling: !1,
    atomic: !0
  }), h9A.on("change", b64), h9A.on("unlink", f64), PG(async () => dd0())
}
// @from(Start 1642874, End 1642965)
function dd0() {
  if (md0 = !0, h9A) h9A.close(), h9A = null;
  pxA.clear(), wKA.clear()
}
// @from(Start 1642967, End 1643037)
function y64(A) {
  return wKA.add(A), () => {
    wKA.delete(A)
  }
}
// @from(Start 1643039, End 1643107)
function x64(A) {
  let Q = Gw(A);
  if (Q) pxA.set(Q, Date.now())
}
// @from(Start 1643109, End 1643338)
function v64() {
  let A = RA();
  return iN.map((Q) => {
    let B = Gw(Q);
    if (!B) return;
    try {
      if (!A.statSync(B).isFile()) return
    } catch {
      return
    }
    return B
  }).filter((Q) => Q !== void 0)
}
// @from(Start 1643340, End 1643543)
function b64(A) {
  let Q = cd0(A);
  if (!Q) return;
  let B = pxA.get(A);
  if (B && Date.now() - B < _64) {
    pxA.delete(A);
    return
  }
  g(`Detected change to ${A}`), wKA.forEach((G) => G(Q))
}
// @from(Start 1643545, End 1643659)
function f64(A) {
  let Q = cd0(A);
  if (!Q) return;
  g(`Detected deletion of ${A}`), wKA.forEach((B) => B(Q))
}
// @from(Start 1643661, End 1643717)
function cd0(A) {
  return iN.find((Q) => Gw(Q) === A)
}
// @from(Start 1643722, End 1643732)
j64 = 1000
// @from(Start 1643736, End 1643745)
S64 = 500
// @from(Start 1643749, End 1643759)
_64 = 5000
// @from(Start 1643763, End 1643773)
h9A = null
// @from(Start 1643777, End 1643785)
gd0 = !1
// @from(Start 1643789, End 1643797)
md0 = !1
// @from(Start 1643801, End 1643804)
pxA
// @from(Start 1643806, End 1643809)
wKA
// @from(Start 1643811, End 1643813)
fm
// @from(Start 1643819, End 1644017)
qKA = L(() => {
  hd0();
  V0();
  AQ();
  MB();
  LV();
  HH();
  pxA = new Map, wKA = new Set;
  fm = {
    initialize: k64,
    dispose: dd0,
    subscribe: y64,
    markInternalWrite: x64
  }
})
// @from(Start 1644020, End 1644589)
function ld0(A, Q) {
  return `
Web page content:
---
${A}
---

${Q}

Provide a concise response based only on the content above. In your response:
 - Enforce a strict 125-character maximum for quotes from any source document. Open Source Software is ok as long as we respect the license.
 - Use quotation marks for exact language from articles; any language outside of the quotation should never be word-for-word the same.
 - You are not a lawyer and never comment on the legality of your own prompts and responses.
 - Never produce or reproduce exact song lyrics.
`
}
// @from(Start 1644594, End 1644609)
$X = "WebFetch"
// @from(Start 1644613, End 1645776)
pd0 = `
- Fetches content from a specified URL and processes it using an AI model
- Takes a URL and a prompt as input
- Fetches the URL content, converts HTML to markdown
- Processes the content with the prompt using a small, fast model
- Returns the model's response about the content
- Use this tool when you need to retrieve and analyze web content

Usage notes:
  - IMPORTANT: If an MCP-provided web fetch tool is available, prefer using that tool instead of this one, as it may have fewer restrictions. All MCP-provided tools start with "mcp__".
  - The URL must be a fully-formed valid URL
  - HTTP URLs will be automatically upgraded to HTTPS
  - The prompt should describe what information you want to extract from the page
  - This tool is read-only and does not modify any files
  - Results may be summarized if the content is very large
  - Includes a self-cleaning 15-minute cache for faster responses when repeatedly accessing the same URL
  - When a URL redirects to a different host, the tool will inform you and provide the redirect URL in a special format. You should then make a new WebFetch request with the redirect URL to fetch the content.
`
// @from(Start 1645782, End 1645793)
$5 = "Edit"
// @from(Start 1645796, End 1645995)
function V6() {
  return Y0(process.env.CLAUDE_CODE_USE_BEDROCK) ? "bedrock" : Y0(process.env.CLAUDE_CODE_USE_VERTEX) ? "vertex" : Y0(process.env.CLAUDE_CODE_USE_FOUNDRY) ? "foundry" : "firstParty"
}
// @from(Start 1645997, End 1646028)
function _R() {
  return V6()
}
// @from(Start 1646033, End 1646057)
lK = L(() => {
  hQ()
})
// @from(Start 1646060, End 1646109)
function g9A() {
  return V6() === "firstParty"
}
// @from(Start 1646111, End 1646210)
function lxA(A) {
  let Q = A.startsWith(".") ? A.slice(1) : A;
  return h64.has(Q.toLowerCase())
}
// @from(Start 1646211, End 1646629)
async function nd0(A) {
  let Q = RA(),
    G = Q.statSync(A).size;
  if (G === 0) throw Error(`PDF file is empty: ${A}`);
  if (G > id0) throw Error(`PDF file size (${UJ(G)}) exceeds maximum allowed size (${UJ(id0)}). PDF files must be less than 32MB.`);
  let I = Q.readFileBytesSync(A).toString("base64");
  return {
    type: "pdf",
    file: {
      filePath: A,
      base64: I,
      originalSize: G
    }
  }
}
// @from(Start 1646634, End 1646637)
h64
// @from(Start 1646639, End 1646653)
id0 = 33554432
// @from(Start 1646659, End 1646726)
aH1 = L(() => {
  lK();
  AQ();
  R9();
  h64 = new Set(["pdf"])
})
// @from(Start 1646732, End 1646743)
d5 = "Read"
// @from(Start 1646747, End 1646757)
NKA = 2000
// @from(Start 1646761, End 1646771)
g64 = 2000
// @from(Start 1646775, End 1646821)
ad0 = "Read a file from the local filesystem."
// @from(Start 1646825, End 1646828)
sd0
// @from(Start 1646834, End 1648642)
wF = L(() => {
  aH1();
  sd0 = `Reads a file from the local filesystem. You can access any file directly by using this tool.
Assume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.

Usage:
- The file_path parameter must be an absolute path, not a relative path
- By default, it reads up to ${NKA} lines starting from the beginning of the file
- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters
- Any lines longer than ${g64} characters will be truncated
- Results are returned using cat -n format, with line numbers starting at 1
- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.${g9A()?`
- This tool can read PDF files (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.`:""}
- This tool can read Jupyter notebooks (.ipynb files) and returns all cells with their outputs, combining code, text, and visualizations.
- This tool can only read files, not directories. To read a directory, use an ls command via the ${C9} tool.
- You can call multiple tools in a single response. It is always better to speculatively read multiple potentially useful files in parallel.
- You will regularly be asked to read screenshots. If the user provides a path to a screenshot, ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths.
- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.`
})
// @from(Start 1648686, End 1648915)
function LKA(A) {
  let Q = A.match(/^([^(]+)\(([^)]+)\)$/);
  if (!Q) return {
    toolName: A
  };
  let B = Q[1],
    G = Q[2];
  if (!B || !G) return {
    toolName: A
  };
  return {
    toolName: B,
    ruleContent: G
  }
}
// @from(Start 1648917, End 1648979)
function u64(A) {
  return A.match(/^(.+):\*$/)?.[1] ?? null
}
// @from(Start 1648981, End 1650728)
function sH1(A) {
  let Q = A.permissions || {},
    B = [],
    G = [];
  for (let F of Q.allow || []) {
    let K = LKA(F);
    if (K.toolName === $X && K.ruleContent?.startsWith("domain:")) B.push(K.ruleContent.substring(7))
  }
  for (let F of Q.deny || []) {
    let K = LKA(F);
    if (K.toolName === $X && K.ruleContent?.startsWith("domain:")) G.push(K.ruleContent.substring(7))
  }
  let Z = ["."],
    I = [],
    Y = [],
    J = iN.map((F) => Gw(F)).filter((F) => F !== void 0);
  I.push(...J);
  let W = I2A(),
    X = uQ();
  if (W !== X) I.push(rd0(W, ".claude", "settings.json")), I.push(rd0(W, ".claude", "settings.local.json"));
  for (let F of Q.allow || []) {
    let K = LKA(F);
    if (K.toolName === $5 && K.ruleContent) Z.push(K.ruleContent)
  }
  for (let F of Q.deny || []) {
    let K = LKA(F);
    if (K.toolName === $5 && K.ruleContent) I.push(K.ruleContent);
    if (K.toolName === d5 && K.ruleContent) Y.push(K.ruleContent)
  }
  let V = A.sandbox?.ripgrep ? A.sandbox.ripgrep : (() => {
    let {
      rgPath: F,
      rgArgs: K
    } = Y9A();
    return {
      command: F,
      args: K
    }
  })();
  return {
    network: {
      allowedDomains: B,
      deniedDomains: G,
      allowUnixSockets: A.sandbox?.network?.allowUnixSockets,
      allowAllUnixSockets: A.sandbox?.network?.allowAllUnixSockets,
      allowLocalBinding: A.sandbox?.network?.allowLocalBinding,
      httpProxyPort: A.sandbox?.network?.httpProxyPort,
      socksProxyPort: A.sandbox?.network?.socksProxyPort
    },
    filesystem: {
      denyRead: Y,
      allowWrite: Z,
      denyWrite: I
    },
    ignoreViolations: A.sandbox?.ignoreViolations,
    enableWeakerNestedSandbox: A.sandbox?.enableWeakerNestedSandbox,
    ripgrep: V
  }
}
// @from(Start 1650730, End 1650879)
function m64() {
  try {
    let A = l0();
    return od0(A)
  } catch (A) {
    return g(`Failed to get settings for sandbox check: ${A}`), !1
  }
}
// @from(Start 1650881, End 1650931)
function d64() {
  let A = l0();
  return td0(A)
}
// @from(Start 1650933, End 1650983)
function c64() {
  let A = l0();
  return ed0(A)
}
// @from(Start 1650985, End 1651139)
function ixA() {
  let A = dQ(),
    Q = A === "wsl" ? "linux" : A;
  if (!xI.isSupportedPlatform(Q)) return !1;
  if (!oH1()) return !1;
  return m64()
}
// @from(Start 1651141, End 1651697)
function p64() {
  if (dQ() !== "linux") return [];
  try {
    let Q = l0();
    if (!Q?.sandbox?.enabled) return [];
    let B = Q?.permissions || {},
      G = [],
      Z = (I) => {
        let Y = I.replace(/\/\*\*$/, "");
        return /[*?[\]]/.test(Y)
      };
    for (let I of [...B.allow || [], ...B.deny || []]) {
      let Y = LKA(I);
      if ((Y.toolName === $5 || Y.toolName === d5) && Y.ruleContent && Z(Y.ruleContent)) G.push(I)
    }
    return G
  } catch (Q) {
    return g(`Failed to get Linux glob pattern warnings: ${Q}`), []
  }
}
// @from(Start 1651699, End 1651971)
function l64() {
  let A = ["flagSettings", "policySettings"];
  for (let Q of A) {
    let B = OB(Q);
    if (B?.sandbox?.enabled !== void 0 || B?.sandbox?.autoAllowBashIfSandboxed !== void 0 || B?.sandbox?.allowUnsandboxedCommands !== void 0) return !0
  }
  return !1
}
// @from(Start 1651972, End 1652413)
async function i64(A) {
  let Q = OB("localSettings");
  cB("localSettings", {
    sandbox: {
      ...Q?.sandbox,
      ...A.enabled !== void 0 && {
        enabled: A.enabled
      },
      ...A.autoAllowBashIfSandboxed !== void 0 && {
        autoAllowBashIfSandboxed: A.autoAllowBashIfSandboxed
      },
      ...A.allowUnsandboxedCommands !== void 0 && {
        allowUnsandboxedCommands: A.allowUnsandboxedCommands
      }
    }
  })
}
// @from(Start 1652415, End 1652480)
function n64() {
  return l0()?.sandbox?.excludedCommands ?? []
}
// @from(Start 1652481, End 1652646)
async function a64(A, Q, B, G) {
  if (ixA())
    if (hm) await hm;
    else throw Error("Sandbox failed to initialize. ");
  return xI.wrapWithSandbox(A, Q, B, G)
}
// @from(Start 1652647, End 1653114)
async function s64(A) {
  if (hm) return hm;
  if (!ixA()) return;
  let Q = l0(),
    B = sH1(Q);
  return hm = (async () => {
    try {
      await xI.initialize(B, A), rH1 = fm.subscribe(() => {
        let G = l0(),
          Z = sH1(G);
        xI.updateConfig(Z), g("Sandbox configuration updated from settings change")
      })
    } catch (G) {
      hm = void 0, g(`Failed to initialize sandbox: ${G instanceof Error?G.message:String(G)}`)
    }
  })(), hm
}
// @from(Start 1653116, End 1653209)
function r64() {
  if (!ixA()) return;
  let A = l0(),
    Q = sH1(A);
  xI.updateConfig(Q)
}
// @from(Start 1653210, End 1653374)
async function o64() {
  return rH1?.(), rH1 = void 0, od0.cache.clear?.(), td0.cache.clear?.(), ed0.cache.clear?.(), oH1.cache.clear?.(), hm = void 0, xI.reset()
}
// @from(Start 1653376, End 1653911)
function Ac0(A, Q) {
  let B = OB("localSettings"),
    G = B?.sandbox?.excludedCommands || [],
    Z = A;
  if (Q) {
    let I = Q.filter((Y) => Y.type === "addRules" && Y.rules.some((J) => J.toolName === C9));
    if (I.length > 0 && I[0].type === "addRules") {
      let Y = I[0].rules.find((J) => J.toolName === C9);
      if (Y?.ruleContent) Z = u64(Y.ruleContent) || Y.ruleContent
    }
  }
  if (!G.includes(Z)) cB("localSettings", {
    sandbox: {
      ...B?.sandbox,
      excludedCommands: [...G, Z]
    }
  });
  return Z
}
// @from(Start 1653916, End 1653918)
hm
// @from(Start 1653920, End 1653923)
rH1
// @from(Start 1653925, End 1653928)
oH1
// @from(Start 1653930, End 1653933)
od0
// @from(Start 1653935, End 1653938)
td0
// @from(Start 1653940, End 1653943)
ed0
// @from(Start 1653945, End 1653947)
nQ
// @from(Start 1653953, End 1655620)
$J = L(() => {
  Fd0();
  Q3();
  MB();
  LV();
  _0();
  V0();
  qKA();
  $9A();
  wF();
  sj();
  oH1 = s1(() => {
    let {
      rgPath: A,
      rgArgs: Q
    } = Y9A();
    return xI.checkDependencies({
      command: A,
      args: Q
    })
  }), od0 = s1((A) => {
    return A?.sandbox?.enabled ?? !1
  });
  td0 = s1((A) => {
    return A?.sandbox?.autoAllowBashIfSandboxed ?? !0
  });
  ed0 = s1((A) => {
    return A?.sandbox?.allowUnsandboxedCommands ?? !0
  });
  nQ = {
    initialize: s64,
    isSandboxingEnabled: ixA,
    isAutoAllowBashIfSandboxedEnabled: d64,
    areUnsandboxedCommandsAllowed: c64,
    areSandboxSettingsLockedByPolicy: l64,
    setSandboxSettings: i64,
    getExcludedCommands: n64,
    wrapWithSandbox: a64,
    refreshConfig: r64,
    reset: o64,
    checkDependencies: oH1,
    getFsReadConfig: xI.getFsReadConfig,
    getFsWriteConfig: xI.getFsWriteConfig,
    getNetworkRestrictionConfig: xI.getNetworkRestrictionConfig,
    getIgnoreViolations: xI.getIgnoreViolations,
    getLinuxGlobPatternWarnings: p64,
    isSupportedPlatform: xI.isSupportedPlatform,
    getAllowUnixSockets: xI.getAllowUnixSockets,
    getAllowLocalBinding: xI.getAllowLocalBinding,
    getEnableWeakerNestedSandbox: xI.getEnableWeakerNestedSandbox,
    getProxyPort: xI.getProxyPort,
    getSocksProxyPort: xI.getSocksProxyPort,
    getLinuxHttpSocketPath: xI.getLinuxHttpSocketPath,
    getLinuxSocksSocketPath: xI.getLinuxSocksSocketPath,
    waitForNetworkInitialization: xI.waitForNetworkInitialization,
    getSandboxViolationStore: xI.getSandboxViolationStore,
    annotateStderrWithSandboxFailures: xI.annotateStderrWithSandboxFailures
  }
})
// @from(Start 1655623, End 1655939)
function nxA(A) {
  switch (A) {
    case "bypassPermissions":
      return "bypassPermissions";
    case "acceptEdits":
      return "acceptEdits";
    case "plan":
      return "plan";
    case "dontAsk":
      return "dontAsk";
    case "default":
      return "default";
    default:
      return "default"
  }
}
// @from(Start 1655941, End 1656228)
function Fv(A) {
  switch (A) {
    case "default":
      return "Default";
    case "plan":
      return "Plan Mode";
    case "acceptEdits":
      return "Accept edits";
    case "bypassPermissions":
      return "Bypass Permissions";
    case "dontAsk":
      return "Don't Ask"
  }
}
// @from(Start 1656230, End 1656290)
function Bc0(A) {
  return A === "default" || A === void 0
}
// @from(Start 1656292, End 1656532)
function Gc0(A) {
  switch (A) {
    case "default":
      return "";
    case "plan":
      return "⏸";
    case "acceptEdits":
      return "⏵⏵";
    case "bypassPermissions":
      return "⏵⏵";
    case "dontAsk":
      return "⏵⏵"
  }
}
// @from(Start 1656534, End 1656798)
function ZS(A) {
  switch (A) {
    case "default":
      return "text";
    case "plan":
      return "planMode";
    case "acceptEdits":
      return "autoAccept";
    case "bypassPermissions":
      return "error";
    case "dontAsk":
      return "error"
  }
}
// @from(Start 1656803, End 1656805)
kR
// @from(Start 1656807, End 1656810)
Qc0
// @from(Start 1656816, End 1656934)
Zw = L(() => {
  Q2();
  kR = ["acceptEdits", "bypassPermissions", "default", "dontAsk", "plan"], Qc0 = W2.enum(kR)
})
// @from(Start 1656937, End 1657344)
function fB(A, Q, B, G, Z) {
  if (G === "m") throw TypeError("Private method is not writable");
  if (G === "a" && !Z) throw TypeError("Private accessor was defined without a setter");
  if (typeof Q === "function" ? A !== Q || !Z : !Q.has(A)) throw TypeError("Cannot write private member to an object whose class did not declare it");
  return G === "a" ? Z.call(A, B) : Z ? Z.value = B : Q.set(A, B), B
}
// @from(Start 1657346, End 1657686)
function N0(A, Q, B, G) {
  if (B === "a" && !G) throw TypeError("Private accessor was defined without a getter");
  if (typeof Q === "function" ? A !== Q || !G : !Q.has(A)) throw TypeError("Cannot read private member from an object whose class did not declare it");
  return B === "m" ? G : B === "a" ? G.call(A) : G ? G.value : Q.get(A)
}
// @from(Start 1657691, End 1657704)
Kv = () => {}
// @from(Start 1657710, End 1659946)
t64 = (A) => {
    let Q = 0,
      B = [];
    while (Q < A.length) {
      let G = A[Q];
      if (G === "\\") {
        Q++;
        continue
      }
      if (G === "{") {
        B.push({
          type: "brace",
          value: "{"
        }), Q++;
        continue
      }
      if (G === "}") {
        B.push({
          type: "brace",
          value: "}"
        }), Q++;
        continue
      }
      if (G === "[") {
        B.push({
          type: "paren",
          value: "["
        }), Q++;
        continue
      }
      if (G === "]") {
        B.push({
          type: "paren",
          value: "]"
        }), Q++;
        continue
      }
      if (G === ":") {
        B.push({
          type: "separator",
          value: ":"
        }), Q++;
        continue
      }
      if (G === ",") {
        B.push({
          type: "delimiter",
          value: ","
        }), Q++;
        continue
      }
      if (G === '"') {
        let J = "",
          W = !1;
        G = A[++Q];
        while (G !== '"') {
          if (Q === A.length) {
            W = !0;
            break
          }
          if (G === "\\") {
            if (Q++, Q === A.length) {
              W = !0;
              break
            }
            J += G + A[Q], G = A[++Q]
          } else J += G, G = A[++Q]
        }
        if (G = A[++Q], !W) B.push({
          type: "string",
          value: J
        });
        continue
      }
      if (G && /\s/.test(G)) {
        Q++;
        continue
      }
      let I = /[0-9]/;
      if (G && I.test(G) || G === "-" || G === ".") {
        let J = "";
        if (G === "-") J += G, G = A[++Q];
        while (G && I.test(G) || G === ".") J += G, G = A[++Q];
        B.push({
          type: "number",
          value: J
        });
        continue
      }
      let Y = /[a-z]/i;
      if (G && Y.test(G)) {
        let J = "";
        while (G && Y.test(G)) {
          if (Q === A.length) break;
          J += G, G = A[++Q]
        }
        if (J == "true" || J == "false" || J === "null") B.push({
          type: "name",
          value: J
        });
        else {
          Q++;
          continue
        }
        continue
      }
      Q++
    }
    return B
  }
// @from(Start 1659950, End 1660655)
u9A = (A) => {
    if (A.length === 0) return A;
    let Q = A[A.length - 1];
    switch (Q.type) {
      case "separator":
        return A = A.slice(0, A.length - 1), u9A(A);
        break;
      case "number":
        let B = Q.value[Q.value.length - 1];
        if (B === "." || B === "-") return A = A.slice(0, A.length - 1), u9A(A);
      case "string":
        let G = A[A.length - 2];
        if (G?.type === "delimiter") return A = A.slice(0, A.length - 1), u9A(A);
        else if (G?.type === "brace" && G.value === "{") return A = A.slice(0, A.length - 1), u9A(A);
        break;
      case "delimiter":
        return A = A.slice(0, A.length - 1), u9A(A);
        break
    }
    return A
  }
// @from(Start 1660659, End 1661201)
e64 = (A) => {
    let Q = [];
    if (A.map((B) => {
        if (B.type === "brace")
          if (B.value === "{") Q.push("}");
          else Q.splice(Q.lastIndexOf("}"), 1);
        if (B.type === "paren")
          if (B.value === "[") Q.push("]");
          else Q.splice(Q.lastIndexOf("]"), 1)
      }), Q.length > 0) Q.reverse().map((B) => {
      if (B === "}") A.push({
        type: "brace",
        value: "}"
      });
      else if (B === "]") A.push({
        type: "paren",
        value: "]"
      })
    });
    return A
  }
// @from(Start 1661205, End 1661440)
A54 = (A) => {
    let Q = "";
    return A.map((B) => {
      switch (B.type) {
        case "string":
          Q += '"' + B.value + '"';
          break;
        default:
          Q += B.value;
          break
      }
    }), Q
  }
// @from(Start 1661444, End 1661490)
axA = (A) => JSON.parse(A54(e64(u9A(t64(A)))))
// @from(Start 1661496, End 1661510)
tH1 = () => {}
// @from(Start 1661513, End 1661705)
function Dv(A) {
  return typeof A === "object" && A !== null && (("name" in A) && A.name === "AbortError" || ("message" in A) && String(A.message).includes("FetchRequestCanceledException"))
}
// @from(Start 1661710, End 1662226)
MKA = (A) => {
  if (A instanceof Error) return A;
  if (typeof A === "object" && A !== null) {
    try {
      if (Object.prototype.toString.call(A) === "[object Error]") {
        let Q = Error(A.message, A.cause ? {
          cause: A.cause
        } : {});
        if (A.stack) Q.stack = A.stack;
        if (A.cause && !Q.cause) Q.cause = A.cause;
        if (A.name) Q.name = A.name;
        return Q
      }
    } catch {}
    try {
      return Error(JSON.stringify(A))
    } catch {}
  }
  return Error(A)
}
// @from(Start 1662232, End 1662234)
vB
// @from(Start 1662236, End 1662238)
n2
// @from(Start 1662240, End 1662242)
yY
// @from(Start 1662244, End 1662246)
cC
// @from(Start 1662248, End 1662250)
IS
// @from(Start 1662252, End 1662255)
OKA
// @from(Start 1662257, End 1662259)
Zr
// @from(Start 1662261, End 1662264)
RKA
// @from(Start 1662266, End 1662268)
Ir
// @from(Start 1662270, End 1662273)
TKA
// @from(Start 1662275, End 1662278)
PKA
// @from(Start 1662280, End 1662283)
jKA
// @from(Start 1662285, End 1662288)
SKA
// @from(Start 1662294, End 1664193)
pC = L(() => {
  vB = class vB extends Error {};
  n2 = class n2 extends vB {
    constructor(A, Q, B, G) {
      super(`${n2.makeMessage(A,Q,B)}`);
      this.status = A, this.headers = G, this.requestID = G?.get("request-id"), this.error = Q
    }
    static makeMessage(A, Q, B) {
      let G = Q?.message ? typeof Q.message === "string" ? Q.message : JSON.stringify(Q.message) : Q ? JSON.stringify(Q) : B;
      if (A && G) return `${A} ${G}`;
      if (A) return `${A} status code (no body)`;
      if (G) return G;
      return "(no status code or body)"
    }
    static generate(A, Q, B, G) {
      if (!A || !G) return new cC({
        message: B,
        cause: MKA(Q)
      });
      let Z = Q;
      if (A === 400) return new OKA(A, Z, B, G);
      if (A === 401) return new Zr(A, Z, B, G);
      if (A === 403) return new RKA(A, Z, B, G);
      if (A === 404) return new Ir(A, Z, B, G);
      if (A === 409) return new TKA(A, Z, B, G);
      if (A === 422) return new PKA(A, Z, B, G);
      if (A === 429) return new jKA(A, Z, B, G);
      if (A >= 500) return new SKA(A, Z, B, G);
      return new n2(A, Z, B, G)
    }
  };
  yY = class yY extends n2 {
    constructor({
      message: A
    } = {}) {
      super(void 0, void 0, A || "Request was aborted.", void 0)
    }
  };
  cC = class cC extends n2 {
    constructor({
      message: A,
      cause: Q
    }) {
      super(void 0, void 0, A || "Connection error.", void 0);
      if (Q) this.cause = Q
    }
  };
  IS = class IS extends cC {
    constructor({
      message: A
    } = {}) {
      super({
        message: A ?? "Request timed out."
      })
    }
  };
  OKA = class OKA extends n2 {};
  Zr = class Zr extends n2 {};
  RKA = class RKA extends n2 {};
  Ir = class Ir extends n2 {};
  TKA = class TKA extends n2 {};
  PKA = class PKA extends n2 {};
  jKA = class jKA extends n2 {};
  SKA = class SKA extends n2 {}
})
// @from(Start 1664199, End 1664223)
Yr = L(() => {
  pC()
})
// @from(Start 1664226, End 1664450)
function Zc0() {
  if (typeof fetch < "u") return fetch;
  throw Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`")
}
// @from(Start 1664452, End 1664690)
function eH1(...A) {
  let Q = globalThis.ReadableStream;
  if (typeof Q > "u") throw Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  return new Q(...A)
}
// @from(Start 1664692, End 1665034)
function sxA(A) {
  let Q = Symbol.asyncIterator in A ? A[Symbol.asyncIterator]() : A[Symbol.iterator]();
  return eH1({
    start() {},
    async pull(B) {
      let {
        done: G,
        value: Z
      } = await Q.next();
      if (G) B.close();
      else B.enqueue(Z)
    },
    async cancel() {
      await Q.return?.()
    }
  })
}
// @from(Start 1665036, End 1665521)
function _KA(A) {
  if (A[Symbol.asyncIterator]) return A;
  let Q = A.getReader();
  return {
    async next() {
      try {
        let B = await Q.read();
        if (B?.done) Q.releaseLock();
        return B
      } catch (B) {
        throw Q.releaseLock(), B
      }
    },
    async return () {
      let B = Q.cancel();
      return Q.releaseLock(), await B, {
        done: !0,
        value: void 0
      }
    },
    [Symbol.asyncIterator]() {
      return this
    }
  }
}
// @from(Start 1665522, End 1665766)
async function Ic0(A) {
  if (A === null || typeof A !== "object") return;
  if (A[Symbol.asyncIterator]) {
    await A[Symbol.asyncIterator]().return?.();
    return
  }
  let Q = A.getReader(),
    B = Q.cancel();
  Q.releaseLock(), await B
}
// @from(Start 1665768, End 1665932)
function Wc0(A) {
  let Q = 0;
  for (let Z of A) Q += Z.length;
  let B = new Uint8Array(Q),
    G = 0;
  for (let Z of A) B.set(Z, G), G += Z.length;
  return B
}
// @from(Start 1665934, End 1666040)
function kKA(A) {
  let Q;
  return (Yc0 ?? (Q = new globalThis.TextEncoder, Yc0 = Q.encode.bind(Q)))(A)
}
// @from(Start 1666042, End 1666148)
function AC1(A) {
  let Q;
  return (Jc0 ?? (Q = new globalThis.TextDecoder, Jc0 = Q.decode.bind(Q)))(A)
}
// @from(Start 1666153, End 1666156)
Yc0
// @from(Start 1666158, End 1666161)
Jc0
// @from(Start 1666163, End 1667322)
class gm {
  constructor() {
    Iw.set(this, void 0), Yw.set(this, void 0), fB(this, Iw, new Uint8Array, "f"), fB(this, Yw, null, "f")
  }
  decode(A) {
    if (A == null) return [];
    let Q = A instanceof ArrayBuffer ? new Uint8Array(A) : typeof A === "string" ? kKA(A) : A;
    fB(this, Iw, Wc0([N0(this, Iw, "f"), Q]), "f");
    let B = [],
      G;
    while ((G = G54(N0(this, Iw, "f"), N0(this, Yw, "f"))) != null) {
      if (G.carriage && N0(this, Yw, "f") == null) {
        fB(this, Yw, G.index, "f");
        continue
      }
      if (N0(this, Yw, "f") != null && (G.index !== N0(this, Yw, "f") + 1 || G.carriage)) {
        B.push(AC1(N0(this, Iw, "f").subarray(0, N0(this, Yw, "f") - 1))), fB(this, Iw, N0(this, Iw, "f").subarray(N0(this, Yw, "f")), "f"), fB(this, Yw, null, "f");
        continue
      }
      let Z = N0(this, Yw, "f") !== null ? G.preceding - 1 : G.preceding,
        I = AC1(N0(this, Iw, "f").subarray(0, Z));
      B.push(I), fB(this, Iw, N0(this, Iw, "f").subarray(G.index), "f"), fB(this, Yw, null, "f")
    }
    return B
  }
  flush() {
    if (!N0(this, Iw, "f").length) return [];
    return this.decode(`
`)
  }
}
// @from(Start 1667324, End 1667599)
function G54(A, Q) {
  for (let Z = Q ?? 0; Z < A.length; Z++) {
    if (A[Z] === 10) return {
      preceding: Z,
      index: Z + 1,
      carriage: !1
    };
    if (A[Z] === 13) return {
      preceding: Z,
      index: Z + 1,
      carriage: !0
    }
  }
  return null
}
// @from(Start 1667601, End 1667898)
function Xc0(A) {
  for (let G = 0; G < A.length - 1; G++) {
    if (A[G] === 10 && A[G + 1] === 10) return G + 2;
    if (A[G] === 13 && A[G + 1] === 13) return G + 2;
    if (A[G] === 13 && A[G + 1] === 10 && G + 3 < A.length && A[G + 2] === 13 && A[G + 3] === 10) return G + 4
  }
  return -1
}
// @from(Start 1667903, End 1667905)
Iw
// @from(Start 1667907, End 1667909)
Yw
// @from(Start 1667915, End 1668059)
QC1 = L(() => {
  Kv();
  Iw = new WeakMap, Yw = new WeakMap;
  gm.NEWLINE_CHARS = new Set([`
`, "\r"]);
  gm.NEWLINE_REGEXP = /\r\n|[\n\r]/g
})
// @from(Start 1668062, End 1668138)
function rxA(A) {
  if (typeof A !== "object") return {};
  return A ?? {}
}
// @from(Start 1668140, End 1668222)
function Fc0(A) {
  if (!A) return !0;
  for (let Q in A) return !1;
  return !0
}
// @from(Start 1668224, End 1668298)
function Kc0(A, Q) {
  return Object.prototype.hasOwnProperty.call(A, Q)
}
// @from(Start 1668303, End 1668306)
Z54
// @from(Start 1668308, End 1668349)
Vc0 = (A) => {
    return Z54.test(A)
  }
// @from(Start 1668353, End 1668395)
BC1 = (A) => (BC1 = Array.isArray, BC1(A))
// @from(Start 1668399, End 1668402)
GC1
// @from(Start 1668404, End 1668598)
Dc0 = (A, Q) => {
    if (typeof Q !== "number" || !Number.isInteger(Q)) throw new vB(`${A} must be an integer`);
    if (Q < 0) throw new vB(`${A} must be a positive integer`);
    return Q
  }
// @from(Start 1668602, End 1668694)
oxA = (A) => {
    try {
      return JSON.parse(A)
    } catch (Q) {
      return
    }
  }
// @from(Start 1668700, End 1668767)
Jr = L(() => {
  pC();
  Z54 = /^[a-z][a-z0-9+.-]*:/i, GC1 = BC1
})
// @from(Start 1668770, End 1668787)
function yKA() {}
// @from(Start 1668789, End 1668882)
function txA(A, Q, B) {
  if (!Q || exA[A] > exA[B]) return yKA;
  else return Q[A].bind(Q)
}
// @from(Start 1668884, End 1669198)
function qF(A) {
  let Q = A.logger,
    B = A.logLevel ?? "off";
  if (!Q) return I54;
  let G = Hc0.get(Q);
  if (G && G[0] === B) return G[1];
  let Z = {
    error: txA("error", Q, B),
    warn: txA("warn", Q, B),
    info: txA("info", Q, B),
    debug: txA("debug", Q, B)
  };
  return Hc0.set(Q, [B, Z]), Z
}
// @from(Start 1669203, End 1669206)
exA
// @from(Start 1669208, End 1669403)
ZC1 = (A, Q, B) => {
    if (!A) return;
    if (Kc0(exA, A)) return A;
    qF(B).warn(`${Q} was set to ${JSON.stringify(A)}, expected one of ${JSON.stringify(Object.keys(exA))}`);
    return
  }
// @from(Start 1669407, End 1669410)
I54
// @from(Start 1669412, End 1669415)
Hc0
// @from(Start 1669417, End 1669980)
Hv = (A) => {
    if (A.options) A.options = {
      ...A.options
    }, delete A.options.headers;
    if (A.headers) A.headers = Object.fromEntries((A.headers instanceof Headers ? [...A.headers] : Object.entries(A.headers)).map(([Q, B]) => [Q, Q.toLowerCase() === "x-api-key" || Q.toLowerCase() === "authorization" || Q.toLowerCase() === "cookie" || Q.toLowerCase() === "set-cookie" ? "***" : B]));
    if ("retryOfRequestLogID" in A) {
      if (A.retryOfRequestLogID) A.retryOf = A.retryOfRequestLogID;
      delete A.retryOfRequestLogID
    }
    return A
  }
// @from(Start 1669986, End 1670194)
AvA = L(() => {
  Jr();
  exA = {
    off: 0,
    error: 200,
    warn: 300,
    info: 400,
    debug: 500
  };
  I54 = {
    error: yKA,
    warn: yKA,
    info: yKA,
    debug: yKA
  }, Hc0 = new WeakMap
})
// @from(Start 1670196, End 1670836)
async function* Y54(A, Q) {
  if (!A.body) {
    if (Q.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative") throw new vB("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api");
    throw new vB("Attempted to iterate over a response with no body")
  }
  let B = new Cc0,
    G = new gm,
    Z = _KA(A.body);
  for await (let I of J54(Z)) for (let Y of G.decode(I)) {
    let J = B.decode(Y);
    if (J) yield J
  }
  for (let I of G.flush()) {
    let Y = B.decode(I);
    if (Y) yield Y
  }
}
// @from(Start 1670837, End 1671239)
async function* J54(A) {
  let Q = new Uint8Array;
  for await (let B of A) {
    if (B == null) continue;
    let G = B instanceof ArrayBuffer ? new Uint8Array(B) : typeof B === "string" ? kKA(B) : B,
      Z = new Uint8Array(Q.length + G.length);
    Z.set(Q), Z.set(G, Q.length), Q = Z;
    let I;
    while ((I = Xc0(Q)) !== -1) yield Q.slice(0, I), Q = Q.slice(I)
  }
  if (Q.length > 0) yield Q
}
// @from(Start 1671240, End 1671908)
class Cc0 {
  constructor() {
    this.event = null, this.data = [], this.chunks = []
  }
  decode(A) {
    if (A.endsWith("\r")) A = A.substring(0, A.length - 1);
    if (!A) {
      if (!this.event && !this.data.length) return null;
      let Z = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      return this.event = null, this.data = [], this.chunks = [], Z
    }
    if (this.chunks.push(A), A.startsWith(":")) return null;
    let [Q, B, G] = W54(A, ":");
    if (G.startsWith(" ")) G = G.substring(1);
    if (Q === "event") this.event = G;
    else if (Q === "data") this.data.push(G);
    return null
  }
}
// @from(Start 1671910, End 1672051)
function W54(A, Q) {
  let B = A.indexOf(Q);
  if (B !== -1) return [A.substring(0, B), Q, A.substring(B + Q.length)];
  return [A, "", ""]
}
// @from(Start 1672056, End 1672059)
xKA
// @from(Start 1672061, End 1672063)
lC
// @from(Start 1672069, End 1675419)
IC1 = L(() => {
  Kv();
  pC();
  QC1();
  Jr();
  AvA();
  pC();
  lC = class lC {
    constructor(A, Q, B) {
      this.iterator = A, xKA.set(this, void 0), this.controller = Q, fB(this, xKA, B, "f")
    }
    static fromSSEResponse(A, Q, B) {
      let G = !1,
        Z = B ? qF(B) : console;
      async function* I() {
        if (G) throw new vB("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        G = !0;
        let Y = !1;
        try {
          for await (let J of Y54(A, Q)) {
            if (J.event === "completion") try {
              yield JSON.parse(J.data)
            } catch (W) {
              throw Z.error("Could not parse message into JSON:", J.data), Z.error("From chunk:", J.raw), W
            }
            if (J.event === "message_start" || J.event === "message_delta" || J.event === "message_stop" || J.event === "content_block_start" || J.event === "content_block_delta" || J.event === "content_block_stop") try {
              yield JSON.parse(J.data)
            } catch (W) {
              throw Z.error("Could not parse message into JSON:", J.data), Z.error("From chunk:", J.raw), W
            }
            if (J.event === "ping") continue;
            if (J.event === "error") throw new n2(void 0, oxA(J.data) ?? J.data, void 0, A.headers)
          }
          Y = !0
        } catch (J) {
          if (Dv(J)) return;
          throw J
        } finally {
          if (!Y) Q.abort()
        }
      }
      return new lC(I, Q, B)
    }
    static fromReadableStream(A, Q, B) {
      let G = !1;
      async function* Z() {
        let Y = new gm,
          J = _KA(A);
        for await (let W of J) for (let X of Y.decode(W)) yield X;
        for (let W of Y.flush()) yield W
      }
      async function* I() {
        if (G) throw new vB("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        G = !0;
        let Y = !1;
        try {
          for await (let J of Z()) {
            if (Y) continue;
            if (J) yield JSON.parse(J)
          }
          Y = !0
        } catch (J) {
          if (Dv(J)) return;
          throw J
        } finally {
          if (!Y) Q.abort()
        }
      }
      return new lC(I, Q, B)
    } [(xKA = new WeakMap, Symbol.asyncIterator)]() {
      return this.iterator()
    }
    tee() {
      let A = [],
        Q = [],
        B = this.iterator(),
        G = (Z) => {
          return {
            next: () => {
              if (Z.length === 0) {
                let I = B.next();
                A.push(I), Q.push(I)
              }
              return Z.shift()
            }
          }
        };
      return [new lC(() => G(A), this.controller, N0(this, xKA, "f")), new lC(() => G(Q), this.controller, N0(this, xKA, "f"))]
    }
    toReadableStream() {
      let A = this,
        Q;
      return eH1({
        async start() {
          Q = A[Symbol.asyncIterator]()
        },
        async pull(B) {
          try {
            let {
              value: G,
              done: Z
            } = await Q.next();
            if (Z) return B.close();
            let I = kKA(JSON.stringify(G) + `
`);
            B.enqueue(I)
          } catch (G) {
            B.error(G)
          }
        },
        async cancel() {
          await Q.return?.()
        }
      })
    }
  }
})
// @from(Start 1675425, End 1675451)
QvA = L(() => {
  IC1()
})
// @from(Start 1675454, End 1675735)
function YC1(A, Q) {
  if (!Q || !("parse" in (Q.output_format ?? {}))) return {
    ...A,
    content: A.content.map((B) => {
      if (B.type === "text") return {
        ...B,
        parsed: null
      };
      return B
    }),
    parsed_output: null
  };
  return JC1(A, Q)
}
// @from(Start 1675737, End 1676056)
function JC1(A, Q) {
  let B = null,
    G = A.content.map((Z) => {
      if (Z.type === "text") {
        let I = X54(Q, Z.text);
        if (B === null) B = I;
        return {
          ...Z,
          parsed: I
        }
      }
      return Z
    });
  return {
    ...A,
    content: G,
    parsed_output: B
  }
}
// @from(Start 1676058, End 1676322)
function X54(A, Q) {
  if (A.output_format?.type !== "json_schema") return null;
  try {
    if ("parse" in A.output_format) return A.output_format.parse(Q);
    return JSON.parse(Q)
  } catch (B) {
    throw new vB(`Failed to parse structured output: ${B}`)
  }
}
// @from(Start 1676327, End 1676352)
WC1 = L(() => {
  pC()
})
// @from(Start 1676355, End 1676466)
function $c0(A) {
  return A.type === "tool_use" || A.type === "server_tool_use" || A.type === "mcp_tool_use"
}
// @from(Start 1676468, End 1676486)
function wc0(A) {}
// @from(Start 1676491, End 1676493)
oN
// @from(Start 1676495, End 1676497)
um
// @from(Start 1676499, End 1676502)
m9A
// @from(Start 1676504, End 1676507)
vKA
// @from(Start 1676509, End 1676512)
BvA
// @from(Start 1676514, End 1676517)
bKA
// @from(Start 1676519, End 1676522)
fKA
// @from(Start 1676524, End 1676527)
GvA
// @from(Start 1676529, End 1676532)
hKA
// @from(Start 1676534, End 1676536)
Cv
// @from(Start 1676538, End 1676541)
gKA
// @from(Start 1676543, End 1676546)
ZvA
// @from(Start 1676548, End 1676551)
IvA
// @from(Start 1676553, End 1676556)
d9A
// @from(Start 1676558, End 1676561)
YvA
// @from(Start 1676563, End 1676566)
JvA
// @from(Start 1676568, End 1676571)
XC1
// @from(Start 1676573, End 1676576)
Ec0
// @from(Start 1676578, End 1676581)
WvA
// @from(Start 1676583, End 1676586)
VC1
// @from(Start 1676588, End 1676591)
FC1
// @from(Start 1676593, End 1676596)
KC1
// @from(Start 1676598, End 1676601)
zc0
// @from(Start 1676603, End 1676621)
Uc0 = "__json_buf"
// @from(Start 1676625, End 1676627)
Wr
// @from(Start 1676633, End 1690115)
DC1 = L(() => {
  Kv();
  tH1();
  Yr();
  QvA();
  WC1();
  Wr = class Wr {
    constructor(A) {
      oN.add(this), this.messages = [], this.receivedMessages = [], um.set(this, void 0), m9A.set(this, null), this.controller = new AbortController, vKA.set(this, void 0), BvA.set(this, () => {}), bKA.set(this, () => {}), fKA.set(this, void 0), GvA.set(this, () => {}), hKA.set(this, () => {}), Cv.set(this, {}), gKA.set(this, !1), ZvA.set(this, !1), IvA.set(this, !1), d9A.set(this, !1), YvA.set(this, void 0), JvA.set(this, void 0), WvA.set(this, (Q) => {
        if (fB(this, ZvA, !0, "f"), Dv(Q)) Q = new yY;
        if (Q instanceof yY) return fB(this, IvA, !0, "f"), this._emit("abort", Q);
        if (Q instanceof vB) return this._emit("error", Q);
        if (Q instanceof Error) {
          let B = new vB(Q.message);
          return B.cause = Q, this._emit("error", B)
        }
        return this._emit("error", new vB(String(Q)))
      }), fB(this, vKA, new Promise((Q, B) => {
        fB(this, BvA, Q, "f"), fB(this, bKA, B, "f")
      }), "f"), fB(this, fKA, new Promise((Q, B) => {
        fB(this, GvA, Q, "f"), fB(this, hKA, B, "f")
      }), "f"), N0(this, vKA, "f").catch(() => {}), N0(this, fKA, "f").catch(() => {}), fB(this, m9A, A, "f")
    }
    get response() {
      return N0(this, YvA, "f")
    }
    get request_id() {
      return N0(this, JvA, "f")
    }
    async withResponse() {
      let A = await N0(this, vKA, "f");
      if (!A) throw Error("Could not resolve a `Response` object");
      return {
        data: this,
        response: A,
        request_id: A.headers.get("request-id")
      }
    }
    static fromReadableStream(A) {
      let Q = new Wr(null);
      return Q._run(() => Q._fromReadableStream(A)), Q
    }
    static createMessage(A, Q, B) {
      let G = new Wr(Q);
      for (let Z of Q.messages) G._addMessageParam(Z);
      return fB(G, m9A, {
        ...Q,
        stream: !0
      }, "f"), G._run(() => G._createMessage(A, {
        ...Q,
        stream: !0
      }, {
        ...B,
        headers: {
          ...B?.headers,
          "X-Stainless-Helper-Method": "stream"
        }
      })), G
    }
    _run(A) {
      A().then(() => {
        this._emitFinal(), this._emit("end")
      }, N0(this, WvA, "f"))
    }
    _addMessageParam(A) {
      this.messages.push(A)
    }
    _addMessage(A, Q = !0) {
      if (this.receivedMessages.push(A), Q) this._emit("message", A)
    }
    async _createMessage(A, Q, B) {
      let G = B?.signal,
        Z;
      if (G) {
        if (G.aborted) this.controller.abort();
        Z = this.controller.abort.bind(this.controller), G.addEventListener("abort", Z)
      }
      try {
        N0(this, oN, "m", VC1).call(this);
        let {
          response: I,
          data: Y
        } = await A.create({
          ...Q,
          stream: !0
        }, {
          ...B,
          signal: this.controller.signal
        }).withResponse();
        this._connected(I);
        for await (let J of Y) N0(this, oN, "m", FC1).call(this, J);
        if (Y.controller.signal?.aborted) throw new yY;
        N0(this, oN, "m", KC1).call(this)
      } finally {
        if (G && Z) G.removeEventListener("abort", Z)
      }
    }
    _connected(A) {
      if (this.ended) return;
      fB(this, YvA, A, "f"), fB(this, JvA, A?.headers.get("request-id"), "f"), N0(this, BvA, "f").call(this, A), this._emit("connect")
    }
    get ended() {
      return N0(this, gKA, "f")
    }
    get errored() {
      return N0(this, ZvA, "f")
    }
    get aborted() {
      return N0(this, IvA, "f")
    }
    abort() {
      this.controller.abort()
    }
    on(A, Q) {
      return (N0(this, Cv, "f")[A] || (N0(this, Cv, "f")[A] = [])).push({
        listener: Q
      }), this
    }
    off(A, Q) {
      let B = N0(this, Cv, "f")[A];
      if (!B) return this;
      let G = B.findIndex((Z) => Z.listener === Q);
      if (G >= 0) B.splice(G, 1);
      return this
    }
    once(A, Q) {
      return (N0(this, Cv, "f")[A] || (N0(this, Cv, "f")[A] = [])).push({
        listener: Q,
        once: !0
      }), this
    }
    emitted(A) {
      return new Promise((Q, B) => {
        if (fB(this, d9A, !0, "f"), A !== "error") this.once("error", B);
        this.once(A, Q)
      })
    }
    async done() {
      fB(this, d9A, !0, "f"), await N0(this, fKA, "f")
    }
    get currentMessage() {
      return N0(this, um, "f")
    }
    async finalMessage() {
      return await this.done(), N0(this, oN, "m", XC1).call(this)
    }
    async finalText() {
      return await this.done(), N0(this, oN, "m", Ec0).call(this)
    }
    _emit(A, ...Q) {
      if (N0(this, gKA, "f")) return;
      if (A === "end") fB(this, gKA, !0, "f"), N0(this, GvA, "f").call(this);
      let B = N0(this, Cv, "f")[A];
      if (B) N0(this, Cv, "f")[A] = B.filter((G) => !G.once), B.forEach(({
        listener: G
      }) => G(...Q));
      if (A === "abort") {
        let G = Q[0];
        if (!N0(this, d9A, "f") && !B?.length) Promise.reject(G);
        N0(this, bKA, "f").call(this, G), N0(this, hKA, "f").call(this, G), this._emit("end");
        return
      }
      if (A === "error") {
        let G = Q[0];
        if (!N0(this, d9A, "f") && !B?.length) Promise.reject(G);
        N0(this, bKA, "f").call(this, G), N0(this, hKA, "f").call(this, G), this._emit("end")
      }
    }
    _emitFinal() {
      if (this.receivedMessages.at(-1)) this._emit("finalMessage", N0(this, oN, "m", XC1).call(this))
    }
    async _fromReadableStream(A, Q) {
      let B = Q?.signal,
        G;
      if (B) {
        if (B.aborted) this.controller.abort();
        G = this.controller.abort.bind(this.controller), B.addEventListener("abort", G)
      }
      try {
        N0(this, oN, "m", VC1).call(this), this._connected(null);
        let Z = lC.fromReadableStream(A, this.controller);
        for await (let I of Z) N0(this, oN, "m", FC1).call(this, I);
        if (Z.controller.signal?.aborted) throw new yY;
        N0(this, oN, "m", KC1).call(this)
      } finally {
        if (B && G) B.removeEventListener("abort", G)
      }
    } [(um = new WeakMap, m9A = new WeakMap, vKA = new WeakMap, BvA = new WeakMap, bKA = new WeakMap, fKA = new WeakMap, GvA = new WeakMap, hKA = new WeakMap, Cv = new WeakMap, gKA = new WeakMap, ZvA = new WeakMap, IvA = new WeakMap, d9A = new WeakMap, YvA = new WeakMap, JvA = new WeakMap, WvA = new WeakMap, oN = new WeakSet, XC1 = function() {
      if (this.receivedMessages.length === 0) throw new vB("stream ended without producing a Message with role=assistant");
      return this.receivedMessages.at(-1)
    }, Ec0 = function() {
      if (this.receivedMessages.length === 0) throw new vB("stream ended without producing a Message with role=assistant");
      let Q = this.receivedMessages.at(-1).content.filter((B) => B.type === "text").map((B) => B.text);
      if (Q.length === 0) throw new vB("stream ended without producing a content block with type=text");
      return Q.join(" ")
    }, VC1 = function() {
      if (this.ended) return;
      fB(this, um, void 0, "f")
    }, FC1 = function(Q) {
      if (this.ended) return;
      let B = N0(this, oN, "m", zc0).call(this, Q);
      switch (this._emit("streamEvent", Q, B), Q.type) {
        case "content_block_delta": {
          let G = B.content.at(-1);
          switch (Q.delta.type) {
            case "text_delta": {
              if (G.type === "text") this._emit("text", Q.delta.text, G.text || "");
              break
            }
            case "citations_delta": {
              if (G.type === "text") this._emit("citation", Q.delta.citation, G.citations ?? []);
              break
            }
            case "input_json_delta": {
              if ($c0(G) && G.input) this._emit("inputJson", Q.delta.partial_json, G.input);
              break
            }
            case "thinking_delta": {
              if (G.type === "thinking") this._emit("thinking", Q.delta.thinking, G.thinking);
              break
            }
            case "signature_delta": {
              if (G.type === "thinking") this._emit("signature", G.signature);
              break
            }
            default:
              wc0(Q.delta)
          }
          break
        }
        case "message_stop": {
          this._addMessageParam(B), this._addMessage(YC1(B, N0(this, m9A, "f")), !0);
          break
        }
        case "content_block_stop": {
          this._emit("contentBlock", B.content.at(-1));
          break
        }
        case "message_start": {
          fB(this, um, B, "f");
          break
        }
        case "content_block_start":
        case "message_delta":
          break
      }
    }, KC1 = function() {
      if (this.ended) throw new vB("stream has ended, this shouldn't happen");
      let Q = N0(this, um, "f");
      if (!Q) throw new vB("request ended without sending any chunks");
      return fB(this, um, void 0, "f"), YC1(Q, N0(this, m9A, "f"))
    }, zc0 = function(Q) {
      let B = N0(this, um, "f");
      if (Q.type === "message_start") {
        if (B) throw new vB(`Unexpected event order, got ${Q.type} before receiving "message_stop"`);
        return Q.message
      }
      if (!B) throw new vB(`Unexpected event order, got ${Q.type} before "message_start"`);
      switch (Q.type) {
        case "message_stop":
          return B;
        case "message_delta":
          if (B.container = Q.delta.container, B.stop_reason = Q.delta.stop_reason, B.stop_sequence = Q.delta.stop_sequence, B.usage.output_tokens = Q.usage.output_tokens, B.context_management = Q.context_management, Q.usage.input_tokens != null) B.usage.input_tokens = Q.usage.input_tokens;
          if (Q.usage.cache_creation_input_tokens != null) B.usage.cache_creation_input_tokens = Q.usage.cache_creation_input_tokens;
          if (Q.usage.cache_read_input_tokens != null) B.usage.cache_read_input_tokens = Q.usage.cache_read_input_tokens;
          if (Q.usage.server_tool_use != null) B.usage.server_tool_use = Q.usage.server_tool_use;
          return B;
        case "content_block_start":
          return B.content.push(Q.content_block), B;
        case "content_block_delta": {
          let G = B.content.at(Q.index);
          switch (Q.delta.type) {
            case "text_delta": {
              if (G?.type === "text") B.content[Q.index] = {
                ...G,
                text: (G.text || "") + Q.delta.text
              };
              break
            }
            case "citations_delta": {
              if (G?.type === "text") B.content[Q.index] = {
                ...G,
                citations: [...G.citations ?? [], Q.delta.citation]
              };
              break
            }
            case "input_json_delta": {
              if (G && $c0(G)) {
                let Z = G[Uc0] || "";
                Z += Q.delta.partial_json;
                let I = {
                  ...G
                };
                if (Object.defineProperty(I, Uc0, {
                    value: Z,
                    enumerable: !1,
                    writable: !0
                  }), Z) try {
                  I.input = axA(Z)
                } catch (Y) {
                  let J = new vB(`Unable to parse tool parameter JSON from model. Please retry your request or adjust your prompt. Error: ${Y}. JSON: ${Z}`);
                  N0(this, WvA, "f").call(this, J)
                }
                B.content[Q.index] = I
              }
              break
            }
            case "thinking_delta": {
              if (G?.type === "thinking") B.content[Q.index] = {
                ...G,
                thinking: G.thinking + Q.delta.thinking
              };
              break
            }
            case "signature_delta": {
              if (G?.type === "thinking") B.content[Q.index] = {
                ...G,
                signature: Q.delta.signature
              };
              break
            }
            default:
              wc0(Q.delta)
          }
          return B
        }
        case "content_block_stop":
          return B
      }
    }, Symbol.asyncIterator)]() {
      let A = [],
        Q = [],
        B = !1;
      return this.on("streamEvent", (G) => {
        let Z = Q.shift();
        if (Z) Z.resolve(G);
        else A.push(G)
      }), this.on("end", () => {
        B = !0;
        for (let G of Q) G.resolve(void 0);
        Q.length = 0
      }), this.on("abort", (G) => {
        B = !0;
        for (let Z of Q) Z.reject(G);
        Q.length = 0
      }), this.on("error", (G) => {
        B = !0;
        for (let Z of Q) Z.reject(G);
        Q.length = 0
      }), {
        next: async () => {
          if (!A.length) {
            if (B) return {
              value: void 0,
              done: !0
            };
            return new Promise((Z, I) => Q.push({
              resolve: Z,
              reject: I
            })).then((Z) => Z ? {
              value: Z,
              done: !1
            } : {
              value: void 0,
              done: !0
            })
          }
          return {
            value: A.shift(),
            done: !1
          }
        },
        return: async () => {
          return this.abort(), {
            value: void 0,
            done: !0
          }
        }
      }
    }
    toReadableStream() {
      return new lC(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream()
    }
  }
})
// @from(Start 1690121, End 1690132)
iK = "Glob"
// @from(Start 1690136, End 1690674)
HC1 = `- Fast file pattern matching tool that works with any codebase size
- Supports glob patterns like "**/*.js" or "src/**/*.ts"
- Returns matching file paths sorted by modification time
- Use this tool when you need to find files by name patterns
- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the Agent tool instead
- You can call multiple tools in a single response. It is always better to speculatively perform multiple searches in parallel if they are potentially useful.`
// @from(Start 1690680, End 1690691)
A6 = "Task"
// @from(Start 1690694, End 1691612)
function CC1() {
  return `A powerful search tool built on ripgrep

  Usage:
  - ALWAYS use ${xY} for search tasks. NEVER invoke \`grep\` or \`rg\` as a ${C9} command. The ${xY} tool has been optimized for correct permissions and access.
  - Supports full regex syntax (e.g., "log.*Error", "function\\s+\\w+")
  - Filter files with glob parameter (e.g., "*.js", "**/*.tsx") or type parameter (e.g., "js", "py", "rust")
  - Output modes: "content" shows matching lines, "files_with_matches" shows only file paths (default), "count" shows match counts
  - Use ${A6} tool for open-ended searches requiring multiple rounds
  - Pattern syntax: Uses ripgrep (not grep) - literal braces need escaping (use \`interface\\{\\}\` to find \`interface{}\` in Go code)
  - Multiline matching: By default patterns match within single lines only. For cross-line patterns like \`struct \\{[\\s\\S]*?field\`, use \`multiline: true\`
`
}
// @from(Start 1691617, End 1691628)
xY = "Grep"
// @from(Start 1691634, End 1691647)
yR = () => {}
// @from(Start 1691653, End 1691665)
wX = "Write"
// @from(Start 1691669, End 1691672)
qc0
// @from(Start 1691678, End 1692337)
YS = L(() => {
  wF();
  qc0 = `Writes a file to the local filesystem.

Usage:
- This tool will overwrite the existing file if there is one at the provided path.
- If this is an existing file, you MUST use the ${d5} tool first to read the file's contents. This tool will fail if you did not read the file first.
- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.
- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.
- Only use emojis if the user explicitly requests it. Avoid writing emojis to files unless asked.`
})
// @from(Start 1692343, End 1692362)
JS = "NotebookEdit"
// @from(Start 1692365, End 1692551)
function XvA() {
  let A = new Date,
    Q = A.getFullYear(),
    B = String(A.getMonth() + 1).padStart(2, "0"),
    G = String(A.getDate()).padStart(2, "0");
  return `${Q}-${B}-${G}`
}
// @from(Start 1692553, End 1693918)
function Nc0() {
  return `
- Allows Claude to search the web and use the results to inform responses
- Provides up-to-date information for current events and recent data
- Returns search result information formatted as search result blocks, including links as markdown hyperlinks
- Use this tool for accessing information beyond Claude's knowledge cutoff
- Searches are performed automatically within a single API call

CRITICAL REQUIREMENT - You MUST follow this:
  - After answering the user's question, you MUST include a "Sources:" section at the end of your response
  - In the Sources section, list all relevant URLs from the search results as markdown hyperlinks: [Title](URL)
  - This is MANDATORY - never skip including sources in your response
  - Example format:

    [Your answer here]

    Sources:
    - [Source Title 1](https://example.com/1)
    - [Source Title 2](https://example.com/2)

Usage notes:
  - Domain filtering is supported to include or block specific websites
  - Web search is only available in the US

IMPORTANT - Use the correct year in search queries:
  - Today's date is ${XvA()}. You MUST use this year when searching for recent information, documentation, or current events.
  - Example: If today is 2025-07-15 and the user asks for "latest React docs", search for "React documentation 2025", NOT "React documentation 2024"
`
}
// @from(Start 1693923, End 1693939)
WS = "WebSearch"
// @from(Start 1693945, End 1693959)
c9A = () => {}
// @from(Start 1693965, End 1703337)
VA = z((O54) => {
  var uKA = Symbol.for("react.element"),
    V54 = Symbol.for("react.portal"),
    F54 = Symbol.for("react.fragment"),
    K54 = Symbol.for("react.strict_mode"),
    D54 = Symbol.for("react.profiler"),
    H54 = Symbol.for("react.provider"),
    C54 = Symbol.for("react.context"),
    E54 = Symbol.for("react.forward_ref"),
    z54 = Symbol.for("react.suspense"),
    U54 = Symbol.for("react.memo"),
    $54 = Symbol.for("react.lazy"),
    Lc0 = Symbol.iterator;

  function w54(A) {
    if (A === null || typeof A !== "object") return null;
    return A = Lc0 && A[Lc0] || A["@@iterator"], typeof A === "function" ? A : null
  }
  var Rc0 = {
      isMounted: function() {
        return !1
      },
      enqueueForceUpdate: function() {},
      enqueueReplaceState: function() {},
      enqueueSetState: function() {}
    },
    Tc0 = Object.assign,
    Pc0 = {};

  function p9A(A, Q, B) {
    this.props = A, this.context = Q, this.refs = Pc0, this.updater = B || Rc0
  }
  p9A.prototype.isReactComponent = {};
  p9A.prototype.setState = function(A, Q) {
    if (typeof A !== "object" && typeof A !== "function" && A != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, A, Q, "setState")
  };
  p9A.prototype.forceUpdate = function(A) {
    this.updater.enqueueForceUpdate(this, A, "forceUpdate")
  };

  function jc0() {}
  jc0.prototype = p9A.prototype;

  function zC1(A, Q, B) {
    this.props = A, this.context = Q, this.refs = Pc0, this.updater = B || Rc0
  }
  var UC1 = zC1.prototype = new jc0;
  UC1.constructor = zC1;
  Tc0(UC1, p9A.prototype);
  UC1.isPureReactComponent = !0;
  var Mc0 = Array.isArray,
    Sc0 = Object.prototype.hasOwnProperty,
    $C1 = {
      current: null
    },
    _c0 = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    };

  function kc0(A, Q, B) {
    var G, Z = {},
      I = null,
      Y = null;
    if (Q != null)
      for (G in Q.ref !== void 0 && (Y = Q.ref), Q.key !== void 0 && (I = "" + Q.key), Q) Sc0.call(Q, G) && !_c0.hasOwnProperty(G) && (Z[G] = Q[G]);
    var J = arguments.length - 2;
    if (J === 1) Z.children = B;
    else if (1 < J) {
      for (var W = Array(J), X = 0; X < J; X++) W[X] = arguments[X + 2];
      Z.children = W
    }
    if (A && A.defaultProps)
      for (G in J = A.defaultProps, J) Z[G] === void 0 && (Z[G] = J[G]);
    return {
      $$typeof: uKA,
      type: A,
      key: I,
      ref: Y,
      props: Z,
      _owner: $C1.current
    }
  }

  function q54(A, Q) {
    return {
      $$typeof: uKA,
      type: A.type,
      key: Q,
      ref: A.ref,
      props: A.props,
      _owner: A._owner
    }
  }

  function wC1(A) {
    return typeof A === "object" && A !== null && A.$$typeof === uKA
  }

  function N54(A) {
    var Q = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + A.replace(/[=:]/g, function(B) {
      return Q[B]
    })
  }
  var Oc0 = /\/+/g;

  function EC1(A, Q) {
    return typeof A === "object" && A !== null && A.key != null ? N54("" + A.key) : Q.toString(36)
  }

  function FvA(A, Q, B, G, Z) {
    var I = typeof A;
    if (I === "undefined" || I === "boolean") A = null;
    var Y = !1;
    if (A === null) Y = !0;
    else switch (I) {
      case "string":
      case "number":
        Y = !0;
        break;
      case "object":
        switch (A.$$typeof) {
          case uKA:
          case V54:
            Y = !0
        }
    }
    if (Y) return Y = A, Z = Z(Y), A = G === "" ? "." + EC1(Y, 0) : G, Mc0(Z) ? (B = "", A != null && (B = A.replace(Oc0, "$&/") + "/"), FvA(Z, Q, B, "", function(X) {
      return X
    })) : Z != null && (wC1(Z) && (Z = q54(Z, B + (!Z.key || Y && Y.key === Z.key ? "" : ("" + Z.key).replace(Oc0, "$&/") + "/") + A)), Q.push(Z)), 1;
    if (Y = 0, G = G === "" ? "." : G + ":", Mc0(A))
      for (var J = 0; J < A.length; J++) {
        I = A[J];
        var W = G + EC1(I, J);
        Y += FvA(I, Q, B, W, Z)
      } else if (W = w54(A), typeof W === "function")
        for (A = W.call(A), J = 0; !(I = A.next()).done;) I = I.value, W = G + EC1(I, J++), Y += FvA(I, Q, B, W, Z);
      else if (I === "object") throw Q = String(A), Error("Objects are not valid as a React child (found: " + (Q === "[object Object]" ? "object with keys {" + Object.keys(A).join(", ") + "}" : Q) + "). If you meant to render a collection of children, use an array instead.");
    return Y
  }

  function VvA(A, Q, B) {
    if (A == null) return A;
    var G = [],
      Z = 0;
    return FvA(A, G, "", "", function(I) {
      return Q.call(B, I, Z++)
    }), G
  }

  function L54(A) {
    if (A._status === -1) {
      var Q = A._result;
      Q = Q(), Q.then(function(B) {
        if (A._status === 0 || A._status === -1) A._status = 1, A._result = B
      }, function(B) {
        if (A._status === 0 || A._status === -1) A._status = 2, A._result = B
      }), A._status === -1 && (A._status = 0, A._result = Q)
    }
    if (A._status === 1) return A._result.default;
    throw A._result
  }
  var iC = {
      current: null
    },
    KvA = {
      transition: null
    },
    M54 = {
      ReactCurrentDispatcher: iC,
      ReactCurrentBatchConfig: KvA,
      ReactCurrentOwner: $C1
    };

  function yc0() {
    throw Error("act(...) is not supported in production builds of React.")
  }
  O54.Children = {
    map: VvA,
    forEach: function(A, Q, B) {
      VvA(A, function() {
        Q.apply(this, arguments)
      }, B)
    },
    count: function(A) {
      var Q = 0;
      return VvA(A, function() {
        Q++
      }), Q
    },
    toArray: function(A) {
      return VvA(A, function(Q) {
        return Q
      }) || []
    },
    only: function(A) {
      if (!wC1(A)) throw Error("React.Children.only expected to receive a single React element child.");
      return A
    }
  };
  O54.Component = p9A;
  O54.Fragment = F54;
  O54.Profiler = D54;
  O54.PureComponent = zC1;
  O54.StrictMode = K54;
  O54.Suspense = z54;
  O54.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = M54;
  O54.act = yc0;
  O54.cloneElement = function(A, Q, B) {
    if (A === null || A === void 0) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + A + ".");
    var G = Tc0({}, A.props),
      Z = A.key,
      I = A.ref,
      Y = A._owner;
    if (Q != null) {
      if (Q.ref !== void 0 && (I = Q.ref, Y = $C1.current), Q.key !== void 0 && (Z = "" + Q.key), A.type && A.type.defaultProps) var J = A.type.defaultProps;
      for (W in Q) Sc0.call(Q, W) && !_c0.hasOwnProperty(W) && (G[W] = Q[W] === void 0 && J !== void 0 ? J[W] : Q[W])
    }
    var W = arguments.length - 2;
    if (W === 1) G.children = B;
    else if (1 < W) {
      J = Array(W);
      for (var X = 0; X < W; X++) J[X] = arguments[X + 2];
      G.children = J
    }
    return {
      $$typeof: uKA,
      type: A.type,
      key: Z,
      ref: I,
      props: G,
      _owner: Y
    }
  };
  O54.createContext = function(A) {
    return A = {
      $$typeof: C54,
      _currentValue: A,
      _currentValue2: A,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    }, A.Provider = {
      $$typeof: H54,
      _context: A
    }, A.Consumer = A
  };
  O54.createElement = kc0;
  O54.createFactory = function(A) {
    var Q = kc0.bind(null, A);
    return Q.type = A, Q
  };
  O54.createRef = function() {
    return {
      current: null
    }
  };
  O54.forwardRef = function(A) {
    return {
      $$typeof: E54,
      render: A
    }
  };
  O54.isValidElement = wC1;
  O54.lazy = function(A) {
    return {
      $$typeof: $54,
      _payload: {
        _status: -1,
        _result: A
      },
      _init: L54
    }
  };
  O54.memo = function(A, Q) {
    return {
      $$typeof: U54,
      type: A,
      compare: Q === void 0 ? null : Q
    }
  };
  O54.startTransition = function(A) {
    var Q = KvA.transition;
    KvA.transition = {};
    try {
      A()
    } finally {
      KvA.transition = Q
    }
  };
  O54.unstable_act = yc0;
  O54.useCallback = function(A, Q) {
    return iC.current.useCallback(A, Q)
  };
  O54.useContext = function(A) {
    return iC.current.useContext(A)
  };
  O54.useDebugValue = function() {};
  O54.useDeferredValue = function(A) {
    return iC.current.useDeferredValue(A)
  };
  O54.useEffect = function(A, Q) {
    return iC.current.useEffect(A, Q)
  };
  O54.useId = function() {
    return iC.current.useId()
  };
  O54.useImperativeHandle = function(A, Q, B) {
    return iC.current.useImperativeHandle(A, Q, B)
  };
  O54.useInsertionEffect = function(A, Q) {
    return iC.current.useInsertionEffect(A, Q)
  };
  O54.useLayoutEffect = function(A, Q) {
    return iC.current.useLayoutEffect(A, Q)
  };
  O54.useMemo = function(A, Q) {
    return iC.current.useMemo(A, Q)
  };
  O54.useReducer = function(A, Q, B) {
    return iC.current.useReducer(A, Q, B)
  };
  O54.useRef = function(A) {
    return iC.current.useRef(A)
  };
  O54.useState = function(A) {
    return iC.current.useState(A)
  };
  O54.useSyncExternalStore = function(A, Q, B) {
    return iC.current.useSyncExternalStore(A, Q, B)
  };
  O54.useTransition = function() {
    return iC.current.useTransition()
  };
  O54.version = "18.3.1"
})
// @from(Start 1703340, End 1703421)
function mKA(A, Q) {
  return function() {
    return A.apply(Q, arguments)
  }
}
// @from(Start 1703423, End 1703581)
function X34(A) {
  return A !== null && !dKA(A) && A.constructor !== null && !dKA(A.constructor) && Jw(A.constructor.isBuffer) && A.constructor.isBuffer(A)
}
// @from(Start 1703583, End 1703746)
function V34(A) {
  let Q;
  if (typeof ArrayBuffer < "u" && ArrayBuffer.isView) Q = ArrayBuffer.isView(A);
  else Q = A && A.buffer && vc0(A.buffer);
  return Q
}
// @from(Start 1703748, End 1704146)
function cKA(A, Q, {
  allOwnKeys: B = !1
} = {}) {
  if (A === null || typeof A > "u") return;
  let G, Z;
  if (typeof A !== "object") A = [A];
  if (l9A(A))
    for (G = 0, Z = A.length; G < Z; G++) Q.call(null, A[G], G, A);
  else {
    let I = B ? Object.getOwnPropertyNames(A) : Object.keys(A),
      Y = I.length,
      J;
    for (G = 0; G < Y; G++) J = I[G], Q.call(null, A[J], J, A)
  }
}
// @from(Start 1704148, End 1704327)
function fc0(A, Q) {
  Q = Q.toLowerCase();
  let B = Object.keys(A),
    G = B.length,
    Z;
  while (G-- > 0)
    if (Z = B[G], Q === Z.toLowerCase()) return Z;
  return null
}
// @from(Start 1704329, End 1704712)
function qC1() {
  let {
    caseless: A
  } = hc0(this) && this || {}, Q = {}, B = (G, Z) => {
    let I = A && fc0(Q, Z) || Z;
    if (DvA(Q[I]) && DvA(G)) Q[I] = qC1(Q[I], G);
    else if (DvA(G)) Q[I] = qC1({}, G);
    else if (l9A(G)) Q[I] = G.slice();
    else Q[I] = G
  };
  for (let G = 0, Z = arguments.length; G < Z; G++) arguments[G] && cKA(arguments[G], B);
  return Q
}
// @from(Start 1704714, End 1704826)
function m34(A) {
  return !!(A && Jw(A.append) && A[Symbol.toStringTag] === "FormData" && A[Symbol.iterator])
}
// @from(Start 1704831, End 1704834)
W34
// @from(Start 1704836, End 1704839)
NC1
// @from(Start 1704841, End 1704844)
HvA
// @from(Start 1704846, End 1704915)
xR = (A) => {
    return A = A.toLowerCase(), (Q) => HvA(Q) === A
  }
// @from(Start 1704919, End 1704953)
CvA = (A) => (Q) => typeof Q === A
// @from(Start 1704957, End 1704960)
l9A
// @from(Start 1704962, End 1704965)
dKA
// @from(Start 1704967, End 1704970)
vc0
// @from(Start 1704972, End 1704975)
F34
// @from(Start 1704977, End 1704979)
Jw
// @from(Start 1704981, End 1704984)
bc0
// @from(Start 1704986, End 1705034)
EvA = (A) => A !== null && typeof A === "object"
// @from(Start 1705038, End 1705071)
K34 = (A) => A === !0 || A === !1
// @from(Start 1705075, End 1705297)
DvA = (A) => {
    if (HvA(A) !== "object") return !1;
    let Q = NC1(A);
    return (Q === null || Q === Object.prototype || Object.getPrototypeOf(Q) === null) && !(Symbol.toStringTag in A) && !(Symbol.iterator in A)
  }
// @from(Start 1705301, End 1705304)
D34
// @from(Start 1705306, End 1705309)
H34
// @from(Start 1705311, End 1705314)
C34
// @from(Start 1705316, End 1705319)
E34
// @from(Start 1705321, End 1705354)
z34 = (A) => EvA(A) && Jw(A.pipe)
// @from(Start 1705358, End 1705586)
U34 = (A) => {
    let Q;
    return A && (typeof FormData === "function" && A instanceof FormData || Jw(A.append) && ((Q = HvA(A)) === "formdata" || Q === "object" && Jw(A.toString) && A.toString() === "[object FormData]"))
  }
// @from(Start 1705590, End 1705593)
$34
// @from(Start 1705595, End 1705598)
w34
// @from(Start 1705600, End 1705603)
q34
// @from(Start 1705605, End 1705608)
N34
// @from(Start 1705610, End 1705613)
L34
// @from(Start 1705615, End 1705699)
M34 = (A) => A.trim ? A.trim() : A.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
// @from(Start 1705703, End 1705705)
Xr
// @from(Start 1705707, End 1705739)
hc0 = (A) => !dKA(A) && A !== Xr
// @from(Start 1705743, End 1705926)
O34 = (A, Q, B, {
    allOwnKeys: G
  } = {}) => {
    return cKA(Q, (Z, I) => {
      if (B && Jw(Z)) A[I] = mKA(Z, B);
      else A[I] = Z
    }, {
      allOwnKeys: G
    }), A
  }
// @from(Start 1705930, End 1706012)
R34 = (A) => {
    if (A.charCodeAt(0) === 65279) A = A.slice(1);
    return A
  }
// @from(Start 1706016, End 1706225)
T34 = (A, Q, B, G) => {
    A.prototype = Object.create(Q.prototype, G), A.prototype.constructor = A, Object.defineProperty(A, "super", {
      value: Q.prototype
    }), B && Object.assign(A.prototype, B)
  }
// @from(Start 1706229, End 1706588)
P34 = (A, Q, B, G) => {
    let Z, I, Y, J = {};
    if (Q = Q || {}, A == null) return Q;
    do {
      Z = Object.getOwnPropertyNames(A), I = Z.length;
      while (I-- > 0)
        if (Y = Z[I], (!G || G(Y, A, Q)) && !J[Y]) Q[Y] = A[Y], J[Y] = !0;
      A = B !== !1 && NC1(A)
    } while (A && (!B || B(A, Q)) && A !== Object.prototype);
    return Q
  }
// @from(Start 1706592, End 1706762)
j34 = (A, Q, B) => {
    if (A = String(A), B === void 0 || B > A.length) B = A.length;
    B -= Q.length;
    let G = A.indexOf(Q, B);
    return G !== -1 && G === B
  }
// @from(Start 1706766, End 1706955)
S34 = (A) => {
    if (!A) return null;
    if (l9A(A)) return A;
    let Q = A.length;
    if (!bc0(Q)) return null;
    let B = Array(Q);
    while (Q-- > 0) B[Q] = A[Q];
    return B
  }
// @from(Start 1706959, End 1706962)
_34
// @from(Start 1706964, End 1707138)
k34 = (A, Q) => {
    let G = (A && A[Symbol.iterator]).call(A),
      Z;
    while ((Z = G.next()) && !Z.done) {
      let I = Z.value;
      Q.call(A, I[0], I[1])
    }
  }
// @from(Start 1707142, End 1707243)
y34 = (A, Q) => {
    let B, G = [];
    while ((B = A.exec(Q)) !== null) G.push(B);
    return G
  }
// @from(Start 1707247, End 1707250)
x34
// @from(Start 1707252, End 1707390)
v34 = (A) => {
    return A.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(B, G, Z) {
      return G.toUpperCase() + Z
    })
  }
// @from(Start 1707394, End 1707397)
xc0
// @from(Start 1707399, End 1707402)
b34
// @from(Start 1707404, End 1707611)
gc0 = (A, Q) => {
    let B = Object.getOwnPropertyDescriptors(A),
      G = {};
    cKA(B, (Z, I) => {
      let Y;
      if ((Y = Q(Z, I, A)) !== !1) G[I] = Y || Z
    }), Object.defineProperties(A, G)
  }
// @from(Start 1707615, End 1707998)
f34 = (A) => {
    gc0(A, (Q, B) => {
      if (Jw(A) && ["arguments", "caller", "callee"].indexOf(B) !== -1) return !1;
      let G = A[B];
      if (!Jw(G)) return;
      if (Q.enumerable = !1, "writable" in Q) {
        Q.writable = !1;
        return
      }
      if (!Q.set) Q.set = () => {
        throw Error("Can not rewrite read-only method '" + B + "'")
      }
    })
  }
// @from(Start 1708002, End 1708177)
h34 = (A, Q) => {
    let B = {},
      G = (Z) => {
        Z.forEach((I) => {
          B[I] = !0
        })
      };
    return l9A(A) ? G(A) : G(String(A).split(Q)), B
  }
// @from(Start 1708181, End 1708195)
g34 = () => {}
// @from(Start 1708199, End 1708276)
u34 = (A, Q) => {
    return A != null && Number.isFinite(A = +A) ? A : Q
  }
// @from(Start 1708280, End 1708722)
d34 = (A) => {
    let Q = [, , , , , , , , , , ],
      B = (G, Z) => {
        if (EvA(G)) {
          if (Q.indexOf(G) >= 0) return;
          if (!("toJSON" in G)) {
            Q[Z] = G;
            let I = l9A(G) ? [] : {};
            return cKA(G, (Y, J) => {
              let W = B(Y, Z + 1);
              !dKA(W) && (I[J] = W)
            }), Q[Z] = void 0, I
          }
        }
        return G
      };
    return B(A, 0)
  }
// @from(Start 1708726, End 1708729)
c34
// @from(Start 1708731, End 1708795)
p34 = (A) => A && (EvA(A) || Jw(A)) && Jw(A.then) && Jw(A.catch)
// @from(Start 1708799, End 1708802)
uc0
// @from(Start 1708804, End 1708807)
l34
// @from(Start 1708809, End 1708811)
b1
// @from(Start 1708817, End 1711522)
QZ = L(() => {
  ({
    toString: W34
  } = Object.prototype), {
    getPrototypeOf: NC1
  } = Object, HvA = ((A) => (Q) => {
    let B = W34.call(Q);
    return A[B] || (A[B] = B.slice(8, -1).toLowerCase())
  })(Object.create(null)), {
    isArray: l9A
  } = Array, dKA = CvA("undefined");
  vc0 = xR("ArrayBuffer");
  F34 = CvA("string"), Jw = CvA("function"), bc0 = CvA("number"), D34 = xR("Date"), H34 = xR("File"), C34 = xR("Blob"), E34 = xR("FileList"), $34 = xR("URLSearchParams"), [w34, q34, N34, L34] = ["ReadableStream", "Request", "Response", "Headers"].map(xR);
  Xr = (() => {
    if (typeof globalThis < "u") return globalThis;
    return typeof self < "u" ? self : typeof window < "u" ? window : global
  })();
  _34 = ((A) => {
    return (Q) => {
      return A && Q instanceof A
    }
  })(typeof Uint8Array < "u" && NC1(Uint8Array)), x34 = xR("HTMLFormElement"), xc0 = (({
    hasOwnProperty: A
  }) => (Q, B) => A.call(Q, B))(Object.prototype), b34 = xR("RegExp");
  c34 = xR("AsyncFunction"), uc0 = ((A, Q) => {
    if (A) return setImmediate;
    return Q ? ((B, G) => {
      return Xr.addEventListener("message", ({
        source: Z,
        data: I
      }) => {
        if (Z === Xr && I === B) G.length && G.shift()()
      }, !1), (Z) => {
        G.push(Z), Xr.postMessage(B, "*")
      }
    })(`axios@${Math.random()}`, []) : (B) => setTimeout(B)
  })(typeof setImmediate === "function", Jw(Xr.postMessage)), l34 = typeof queueMicrotask < "u" ? queueMicrotask.bind(Xr) : typeof process < "u" && process.nextTick || uc0, b1 = {
    isArray: l9A,
    isArrayBuffer: vc0,
    isBuffer: X34,
    isFormData: U34,
    isArrayBufferView: V34,
    isString: F34,
    isNumber: bc0,
    isBoolean: K34,
    isObject: EvA,
    isPlainObject: DvA,
    isReadableStream: w34,
    isRequest: q34,
    isResponse: N34,
    isHeaders: L34,
    isUndefined: dKA,
    isDate: D34,
    isFile: H34,
    isBlob: C34,
    isRegExp: b34,
    isFunction: Jw,
    isStream: z34,
    isURLSearchParams: $34,
    isTypedArray: _34,
    isFileList: E34,
    forEach: cKA,
    merge: qC1,
    extend: O34,
    trim: M34,
    stripBOM: R34,
    inherits: T34,
    toFlatObject: P34,
    kindOf: HvA,
    kindOfTest: xR,
    endsWith: j34,
    toArray: S34,
    forEachEntry: k34,
    matchAll: y34,
    isHTMLForm: x34,
    hasOwnProperty: xc0,
    hasOwnProp: xc0,
    reduceDescriptors: gc0,
    freezeMethods: f34,
    toObjectSet: h34,
    toCamelCase: v34,
    noop: g34,
    toFiniteNumber: u34,
    findKey: fc0,
    global: Xr,
    isContextDefined: hc0,
    isSpecCompliantForm: m34,
    toJSONObject: d34,
    isAsyncFn: c34,
    isThenable: p34,
    setImmediate: uc0,
    asap: l34
  }
})
// @from(Start 1711525, End 1711873)
function i9A(A, Q, B, G, Z) {
  if (Error.call(this), Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
  else this.stack = Error().stack;
  if (this.message = A, this.name = "AxiosError", Q && (this.code = Q), B && (this.config = B), G && (this.request = G), Z) this.response = Z, this.status = Z.status ? Z.status : null
}
// @from(Start 1711878, End 1711881)
mc0
// @from(Start 1711883, End 1711886)
dc0
// @from(Start 1711888, End 1711890)
RB
// @from(Start 1711896, End 1713114)
Ww = L(() => {
  QZ();
  b1.inherits(i9A, Error, {
    toJSON: function() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: b1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      }
    }
  });
  mc0 = i9A.prototype, dc0 = {};
  ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((A) => {
    dc0[A] = {
      value: A
    }
  });
  Object.defineProperties(i9A, dc0);
  Object.defineProperty(mc0, "isAxiosError", {
    value: !0
  });
  i9A.from = (A, Q, B, G, Z, I) => {
    let Y = Object.create(mc0);
    return b1.toFlatObject(A, Y, function(W) {
      return W !== Error.prototype
    }, (J) => {
      return J !== "isAxiosError"
    }), i9A.call(Y, A.message, Q, B, G, Z), Y.cause = A, Y.name = A.name, I && Object.assign(Y, I), Y
  };
  RB = i9A
})
// @from(Start 1713120, End 1715076)
lc0 = z((rI7, pc0) => {
  var cc0 = UA("stream").Stream,
    i34 = UA("util");
  pc0.exports = vR;

  function vR() {
    this.source = null, this.dataSize = 0, this.maxDataSize = 1048576, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = []
  }
  i34.inherits(vR, cc0);
  vR.create = function(A, Q) {
    var B = new this;
    Q = Q || {};
    for (var G in Q) B[G] = Q[G];
    B.source = A;
    var Z = A.emit;
    if (A.emit = function() {
        return B._handleEmit(arguments), Z.apply(A, arguments)
      }, A.on("error", function() {}), B.pauseStream) A.pause();
    return B
  };
  Object.defineProperty(vR.prototype, "readable", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.source.readable
    }
  });
  vR.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments)
  };
  vR.prototype.resume = function() {
    if (!this._released) this.release();
    this.source.resume()
  };
  vR.prototype.pause = function() {
    this.source.pause()
  };
  vR.prototype.release = function() {
    this._released = !0, this._bufferedEvents.forEach(function(A) {
      this.emit.apply(this, A)
    }.bind(this)), this._bufferedEvents = []
  };
  vR.prototype.pipe = function() {
    var A = cc0.prototype.pipe.apply(this, arguments);
    return this.resume(), A
  };
  vR.prototype._handleEmit = function(A) {
    if (this._released) {
      this.emit.apply(this, A);
      return
    }
    if (A[0] === "data") this.dataSize += A[1].length, this._checkIfMaxDataSizeExceeded();
    this._bufferedEvents.push(A)
  };
  vR.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) return;
    if (this.dataSize <= this.maxDataSize) return;
    this._maxDataSizeExceeded = !0;
    var A = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", Error(A))
  }
})
// @from(Start 1715082, End 1718911)
sc0 = z((oI7, ac0) => {
  var n34 = UA("util"),
    nc0 = UA("stream").Stream,
    ic0 = lc0();
  ac0.exports = wJ;

  function wJ() {
    this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2097152, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1
  }
  n34.inherits(wJ, nc0);
  wJ.create = function(A) {
    var Q = new this;
    A = A || {};
    for (var B in A) Q[B] = A[B];
    return Q
  };
  wJ.isStreamLike = function(A) {
    return typeof A !== "function" && typeof A !== "string" && typeof A !== "boolean" && typeof A !== "number" && !Buffer.isBuffer(A)
  };
  wJ.prototype.append = function(A) {
    var Q = wJ.isStreamLike(A);
    if (Q) {
      if (!(A instanceof ic0)) {
        var B = ic0.create(A, {
          maxDataSize: 1 / 0,
          pauseStream: this.pauseStreams
        });
        A.on("data", this._checkDataSize.bind(this)), A = B
      }
      if (this._handleErrors(A), this.pauseStreams) A.pause()
    }
    return this._streams.push(A), this
  };
  wJ.prototype.pipe = function(A, Q) {
    return nc0.prototype.pipe.call(this, A, Q), this.resume(), A
  };
  wJ.prototype._getNext = function() {
    if (this._currentStream = null, this._insideLoop) {
      this._pendingNext = !0;
      return
    }
    this._insideLoop = !0;
    try {
      do this._pendingNext = !1, this._realGetNext(); while (this._pendingNext)
    } finally {
      this._insideLoop = !1
    }
  };
  wJ.prototype._realGetNext = function() {
    var A = this._streams.shift();
    if (typeof A > "u") {
      this.end();
      return
    }
    if (typeof A !== "function") {
      this._pipeNext(A);
      return
    }
    var Q = A;
    Q(function(B) {
      var G = wJ.isStreamLike(B);
      if (G) B.on("data", this._checkDataSize.bind(this)), this._handleErrors(B);
      this._pipeNext(B)
    }.bind(this))
  };
  wJ.prototype._pipeNext = function(A) {
    this._currentStream = A;
    var Q = wJ.isStreamLike(A);
    if (Q) {
      A.on("end", this._getNext.bind(this)), A.pipe(this, {
        end: !1
      });
      return
    }
    var B = A;
    this.write(B), this._getNext()
  };
  wJ.prototype._handleErrors = function(A) {
    var Q = this;
    A.on("error", function(B) {
      Q._emitError(B)
    })
  };
  wJ.prototype.write = function(A) {
    this.emit("data", A)
  };
  wJ.prototype.pause = function() {
    if (!this.pauseStreams) return;
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
    this.emit("pause")
  };
  wJ.prototype.resume = function() {
    if (!this._released) this._released = !0, this.writable = !0, this._getNext();
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
    this.emit("resume")
  };
  wJ.prototype.end = function() {
    this._reset(), this.emit("end")
  };
  wJ.prototype.destroy = function() {
    this._reset(), this.emit("close")
  };
  wJ.prototype._reset = function() {
    this.writable = !1, this._streams = [], this._currentStream = null
  };
  wJ.prototype._checkDataSize = function() {
    if (this._updateDataSize(), this.dataSize <= this.maxDataSize) return;
    var A = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(Error(A))
  };
  wJ.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var A = this;
    if (this._streams.forEach(function(Q) {
        if (!Q.dataSize) return;
        A.dataSize += Q.dataSize
      }), this._currentStream && this._currentStream.dataSize) this.dataSize += this._currentStream.dataSize
  };
  wJ.prototype._emitError = function(A) {
    this._reset(), this.emit("error", A)
  }
})
// @from(Start 5913140, End 6290974)
JUB = z((SaA, Ug1) => {
  (function(Q, B) {
    if (typeof SaA === "object" && typeof Ug1 === "object") Ug1.exports = B();
    else if (typeof define === "function" && define.amd) define([], B);
    else if (typeof SaA === "object") SaA.ReactDevToolsBackend = B();
    else Q.ReactDevToolsBackend = B()
  })(self, () => {
    return (() => {
      var A = {
          602: (Z, I, Y) => {
            var J;

            function W(l) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") W = function(m) {
                return typeof m
              };
              else W = function(m) {
                return m && typeof Symbol === "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m
              };
              return W(l)
            }
            var X = Y(206),
              V = Y(189),
              F = Object.assign,
              K = V.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
              D = [],
              H = null;

            function C() {
              if (H === null) {
                var l = new Map;
                try {
                  q.useContext({
                    _currentValue: null
                  }), q.useState(null), q.useReducer(function(IA) {
                    return IA
                  }, null), q.useRef(null), typeof q.useCacheRefresh === "function" && q.useCacheRefresh(), q.useLayoutEffect(function() {}), q.useInsertionEffect(function() {}), q.useEffect(function() {}), q.useImperativeHandle(void 0, function() {
                    return null
                  }), q.useDebugValue(null), q.useCallback(function() {}), q.useMemo(function() {
                    return null
                  }), typeof q.useMemoCache === "function" && q.useMemoCache(0)
                } finally {
                  var k = D;
                  D = []
                }
                for (var m = 0; m < k.length; m++) {
                  var o = k[m];
                  l.set(o.primitive, X.parse(o.stackError))
                }
                H = l
              }
              return H
            }
            var E = null;

            function U() {
              var l = E;
              return l !== null && (E = l.next), l
            }
            var q = {
                use: function() {
                  throw Error("Support for `use` not yet implemented in react-debug-tools.")
                },
                readContext: function(k) {
                  return k._currentValue
                },
                useCacheRefresh: function() {
                  var k = U();
                  return D.push({
                      primitive: "CacheRefresh",
                      stackError: Error(),
                      value: k !== null ? k.memoizedState : function() {}
                    }),
                    function() {}
                },
                useCallback: function(k) {
                  var m = U();
                  return D.push({
                    primitive: "Callback",
                    stackError: Error(),
                    value: m !== null ? m.memoizedState[0] : k
                  }), k
                },
                useContext: function(k) {
                  return D.push({
                    primitive: "Context",
                    stackError: Error(),
                    value: k._currentValue
                  }), k._currentValue
                },
                useEffect: function(k) {
                  U(), D.push({
                    primitive: "Effect",
                    stackError: Error(),
                    value: k
                  })
                },
                useImperativeHandle: function(k) {
                  U();
                  var m = void 0;
                  k !== null && W(k) === "object" && (m = k.current), D.push({
                    primitive: "ImperativeHandle",
                    stackError: Error(),
                    value: m
                  })
                },
                useDebugValue: function(k, m) {
                  D.push({
                    primitive: "DebugValue",
                    stackError: Error(),
                    value: typeof m === "function" ? m(k) : k
                  })
                },
                useLayoutEffect: function(k) {
                  U(), D.push({
                    primitive: "LayoutEffect",
                    stackError: Error(),
                    value: k
                  })
                },
                useInsertionEffect: function(k) {
                  U(), D.push({
                    primitive: "InsertionEffect",
                    stackError: Error(),
                    value: k
                  })
                },
                useMemo: function(k) {
                  var m = U();
                  return k = m !== null ? m.memoizedState[0] : k(), D.push({
                    primitive: "Memo",
                    stackError: Error(),
                    value: k
                  }), k
                },
                useMemoCache: function() {
                  return []
                },
                useReducer: function(k, m, o) {
                  return k = U(), m = k !== null ? k.memoizedState : o !== void 0 ? o(m) : m, D.push({
                    primitive: "Reducer",
                    stackError: Error(),
                    value: m
                  }), [m, function() {}]
                },
                useRef: function(k) {
                  var m = U();
                  return k = m !== null ? m.memoizedState : {
                    current: k
                  }, D.push({
                    primitive: "Ref",
                    stackError: Error(),
                    value: k.current
                  }), k
                },
                useState: function(k) {
                  var m = U();
                  return k = m !== null ? m.memoizedState : typeof k === "function" ? k() : k, D.push({
                    primitive: "State",
                    stackError: Error(),
                    value: k
                  }), [k, function() {}]
                },
                useTransition: function() {
                  return U(), U(), D.push({
                    primitive: "Transition",
                    stackError: Error(),
                    value: void 0
                  }), [!1, function() {}]
                },
                useSyncExternalStore: function(k, m) {
                  return U(), U(), k = m(), D.push({
                    primitive: "SyncExternalStore",
                    stackError: Error(),
                    value: k
                  }), k
                },
                useDeferredValue: function(k) {
                  var m = U();
                  return D.push({
                    primitive: "DeferredValue",
                    stackError: Error(),
                    value: m !== null ? m.memoizedState : k
                  }), k
                },
                useId: function() {
                  var k = U();
                  return k = k !== null ? k.memoizedState : "", D.push({
                    primitive: "Id",
                    stackError: Error(),
                    value: k
                  }), k
                }
              },
              w = {
                get: function(k, m) {
                  if (k.hasOwnProperty(m)) return k[m];
                  throw k = Error("Missing method in Dispatcher: " + m), k.name = "ReactDebugToolsUnsupportedHookError", k
                }
              },
              N = typeof Proxy > "u" ? q : new Proxy(q, w),
              R = 0;

            function T(l, k, m) {
              var o = k[m].source,
                IA = 0;
              A: for (; IA < l.length; IA++)
                if (l[IA].source === o) {
                  for (var FA = m + 1, zA = IA + 1; FA < k.length && zA < l.length; FA++, zA++)
                    if (l[zA].source !== k[FA].source) continue A;
                  return IA
                }
              return -1
            }

            function y(l, k) {
              if (!l) return !1;
              return k = "use" + k, l.length < k.length ? !1 : l.lastIndexOf(k) === l.length - k.length
            }

            function v(l, k, m) {
              for (var o = [], IA = null, FA = o, zA = 0, NA = [], OA = 0; OA < k.length; OA++) {
                var mA = k[OA],
                  wA = l,
                  qA = X.parse(mA.stackError);
                A: {
                  var KA = qA,
                    yA = T(KA, wA, R);
                  if (yA !== -1) wA = yA;
                  else {
                    for (var oA = 0; oA < wA.length && 5 > oA; oA++)
                      if (yA = T(KA, wA, oA), yA !== -1) {
                        R = oA, wA = yA;
                        break A
                      } wA = -1
                  }
                }
                A: {
                  if (KA = qA, yA = C().get(mA.primitive), yA !== void 0) {
                    for (oA = 0; oA < yA.length && oA < KA.length; oA++)
                      if (yA[oA].source !== KA[oA].source) {
                        oA < KA.length - 1 && y(KA[oA].functionName, mA.primitive) && oA++, oA < KA.length - 1 && y(KA[oA].functionName, mA.primitive) && oA++, KA = oA;
                        break A
                      }
                  }
                  KA = -1
                }
                if (qA = wA === -1 || KA === -1 || 2 > wA - KA ? null : qA.slice(KA, wA - 1), qA !== null) {
                  if (wA = 0, IA !== null) {
                    for (; wA < qA.length && wA < IA.length && qA[qA.length - wA - 1].source === IA[IA.length - wA - 1].source;) wA++;
                    for (IA = IA.length - 1; IA > wA; IA--) FA = NA.pop()
                  }
                  for (IA = qA.length - wA - 1; 1 <= IA; IA--) wA = [], KA = qA[IA], (yA = qA[IA - 1].functionName) ? (oA = yA.lastIndexOf("."), oA === -1 && (oA = 0), yA.slice(oA, oA + 3) === "use" && (oA += 3), yA = yA.slice(oA)) : yA = "", yA = {
                    id: null,
                    isStateEditable: !1,
                    name: yA,
                    value: void 0,
                    subHooks: wA
                  }, m && (yA.hookSource = {
                    lineNumber: KA.lineNumber,
                    columnNumber: KA.columnNumber,
                    functionName: KA.functionName,
                    fileName: KA.fileName
                  }), FA.push(yA), NA.push(FA), FA = wA;
                  IA = qA
                }
                wA = mA.primitive, mA = {
                  id: wA === "Context" || wA === "DebugValue" ? null : zA++,
                  isStateEditable: wA === "Reducer" || wA === "State",
                  name: wA,
                  value: mA.value,
                  subHooks: []
                }, m && (wA = {
                  lineNumber: null,
                  functionName: null,
                  fileName: null,
                  columnNumber: null
                }, qA && 1 <= qA.length && (qA = qA[0], wA.lineNumber = qA.lineNumber, wA.functionName = qA.functionName, wA.fileName = qA.fileName, wA.columnNumber = qA.columnNumber), mA.hookSource = wA), FA.push(mA)
              }
              return x(o, null), o
            }

            function x(l, k) {
              for (var m = [], o = 0; o < l.length; o++) {
                var IA = l[o];
                IA.name === "DebugValue" && IA.subHooks.length === 0 ? (l.splice(o, 1), o--, m.push(IA)) : x(IA.subHooks, IA)
              }
              k !== null && (m.length === 1 ? k.value = m[0].value : 1 < m.length && (k.value = m.map(function(FA) {
                return FA.value
              })))
            }

            function p(l) {
              if (l instanceof Error && l.name === "ReactDebugToolsUnsupportedHookError") throw l;
              var k = Error("Error rendering inspected component", {
                cause: l
              });
              throw k.name = "ReactDebugToolsRenderError", k.cause = l, k
            }

            function u(l, k, m) {
              var o = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : !1;
              m == null && (m = K.ReactCurrentDispatcher);
              var IA = m.current;
              m.current = N;
              try {
                var FA = Error();
                l(k)
              } catch (NA) {
                p(NA)
              } finally {
                var zA = D;
                D = [], m.current = IA
              }
              return IA = X.parse(FA), v(IA, zA, o)
            }

            function e(l) {
              l.forEach(function(k, m) {
                return m._currentValue = k
              })
            }
            J = u, I.inspectHooksOfFiber = function(l, k) {
              var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !1;
              if (k == null && (k = K.ReactCurrentDispatcher), l.tag !== 0 && l.tag !== 15 && l.tag !== 11) throw Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
              C();
              var {
                type: o,
                memoizedProps: IA
              } = l;
              if (o !== l.elementType && o && o.defaultProps) {
                IA = F({}, IA);
                var FA = o.defaultProps;
                for (zA in FA) IA[zA] === void 0 && (IA[zA] = FA[zA])
              }
              E = l.memoizedState;
              var zA = new Map;
              try {
                for (FA = l; FA;) {
                  if (FA.tag === 10) {
                    var NA = FA.type._context;
                    zA.has(NA) || (zA.set(NA, NA._currentValue), NA._currentValue = FA.memoizedProps.value)
                  }
                  FA = FA.return
                }
                if (l.tag === 11) {
                  var OA = o.render;
                  o = IA;
                  var mA = l.ref;
                  NA = k;
                  var wA = NA.current;
                  NA.current = N;
                  try {
                    var qA = Error();
                    OA(o, mA)
                  } catch (oA) {
                    p(oA)
                  } finally {
                    var KA = D;
                    D = [], NA.current = wA
                  }
                  var yA = X.parse(qA);
                  return v(yA, KA, m)
                }
                return u(o, IA, k, m)
              } finally {
                E = null, e(zA)
              }
            }
          },
          987: (Z, I, Y) => {
            Z.exports = Y(602)
          },
          9: (Z, I) => {
            var Y;

            function J(x) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") J = function(u) {
                return typeof u
              };
              else J = function(u) {
                return u && typeof Symbol === "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u
              };
              return J(x)
            }
            var W = Symbol.for("react.element"),
              X = Symbol.for("react.portal"),
              V = Symbol.for("react.fragment"),
              F = Symbol.for("react.strict_mode"),
              K = Symbol.for("react.profiler"),
              D = Symbol.for("react.provider"),
              H = Symbol.for("react.context"),
              C = Symbol.for("react.server_context"),
              E = Symbol.for("react.forward_ref"),
              U = Symbol.for("react.suspense"),
              q = Symbol.for("react.suspense_list"),
              w = Symbol.for("react.memo"),
              N = Symbol.for("react.lazy"),
              R = Symbol.for("react.offscreen"),
              T = Symbol.for("react.cache"),
              y = Symbol.for("react.client.reference");

            function v(x) {
              if (J(x) === "object" && x !== null) {
                var p = x.$$typeof;
                switch (p) {
                  case W:
                    switch (x = x.type, x) {
                      case V:
                      case K:
                      case F:
                      case U:
                      case q:
                        return x;
                      default:
                        switch (x = x && x.$$typeof, x) {
                          case C:
                          case H:
                          case E:
                          case N:
                          case w:
                          case D:
                            return x;
                          default:
                            return p
                        }
                    }
                  case X:
                    return p
                }
              }
            }
            I.ContextConsumer = H, I.ContextProvider = D, Y = W, I.ForwardRef = E, I.Fragment = V, I.Lazy = N, I.Memo = w, I.Portal = X, I.Profiler = K, I.StrictMode = F, I.Suspense = U, Y = q, Y = function() {
              return !1
            }, Y = function() {
              return !1
            }, Y = function(x) {
              return v(x) === H
            }, Y = function(x) {
              return v(x) === D
            }, I.isElement = function(x) {
              return J(x) === "object" && x !== null && x.$$typeof === W
            }, Y = function(x) {
              return v(x) === E
            }, Y = function(x) {
              return v(x) === V
            }, Y = function(x) {
              return v(x) === N
            }, Y = function(x) {
              return v(x) === w
            }, Y = function(x) {
              return v(x) === X
            }, Y = function(x) {
              return v(x) === K
            }, Y = function(x) {
              return v(x) === F
            }, Y = function(x) {
              return v(x) === U
            }, Y = function(x) {
              return v(x) === q
            }, Y = function(x) {
              return typeof x === "string" || typeof x === "function" || x === V || x === K || x === F || x === U || x === q || x === R || x === T || J(x) === "object" && x !== null && (x.$$typeof === N || x.$$typeof === w || x.$$typeof === D || x.$$typeof === H || x.$$typeof === E || x.$$typeof === y || x.getModuleId !== void 0) ? !0 : !1
            }, I.typeOf = v
          },
          550: (Z, I, Y) => {
            Z.exports = Y(9)
          },
          978: (Z, I) => {
            function Y(jA) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") Y = function(t1) {
                return typeof t1
              };
              else Y = function(t1) {
                return t1 && typeof Symbol === "function" && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1
              };
              return Y(jA)
            }
            var J = Symbol.for("react.element"),
              W = Symbol.for("react.portal"),
              X = Symbol.for("react.fragment"),
              V = Symbol.for("react.strict_mode"),
              F = Symbol.for("react.profiler"),
              K = Symbol.for("react.provider"),
              D = Symbol.for("react.context"),
              H = Symbol.for("react.server_context"),
              C = Symbol.for("react.forward_ref"),
              E = Symbol.for("react.suspense"),
              U = Symbol.for("react.suspense_list"),
              q = Symbol.for("react.memo"),
              w = Symbol.for("react.lazy"),
              N = Symbol.for("react.debug_trace_mode"),
              R = Symbol.for("react.offscreen"),
              T = Symbol.for("react.cache"),
              y = Symbol.for("react.default_value"),
              v = Symbol.for("react.postpone"),
              x = Symbol.iterator;

            function p(jA) {
              if (jA === null || Y(jA) !== "object") return null;
              return jA = x && jA[x] || jA["@@iterator"], typeof jA === "function" ? jA : null
            }
            var u = {
                isMounted: function() {
                  return !1
                },
                enqueueForceUpdate: function() {},
                enqueueReplaceState: function() {},
                enqueueSetState: function() {}
              },
              e = Object.assign,
              l = {};

            function k(jA, eA, t1) {
              this.props = jA, this.context = eA, this.refs = l, this.updater = t1 || u
            }
            k.prototype.isReactComponent = {}, k.prototype.setState = function(jA, eA) {
              if (Y(jA) !== "object" && typeof jA !== "function" && jA != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
              this.updater.enqueueSetState(this, jA, eA, "setState")
            }, k.prototype.forceUpdate = function(jA) {
              this.updater.enqueueForceUpdate(this, jA, "forceUpdate")
            };

            function m() {}
            m.prototype = k.prototype;

            function o(jA, eA, t1) {
              this.props = jA, this.context = eA, this.refs = l, this.updater = t1 || u
            }
            var IA = o.prototype = new m;
            IA.constructor = o, e(IA, k.prototype), IA.isPureReactComponent = !0;
            var FA = Array.isArray,
              zA = Object.prototype.hasOwnProperty,
              NA = {
                current: null
              },
              OA = {
                key: !0,
                ref: !0,
                __self: !0,
                __source: !0
              };

            function mA(jA, eA, t1) {
              var v1, F0 = {},
                g0 = null,
                p0 = null;
              if (eA != null)
                for (v1 in eA.ref !== void 0 && (p0 = eA.ref), eA.key !== void 0 && (g0 = "" + eA.key), eA) zA.call(eA, v1) && !OA.hasOwnProperty(v1) && (F0[v1] = eA[v1]);
              var n0 = arguments.length - 2;
              if (n0 === 1) F0.children = t1;
              else if (1 < n0) {
                for (var _1 = Array(n0), zQ = 0; zQ < n0; zQ++) _1[zQ] = arguments[zQ + 2];
                F0.children = _1
              }
              if (jA && jA.defaultProps)
                for (v1 in n0 = jA.defaultProps, n0) F0[v1] === void 0 && (F0[v1] = n0[v1]);
              return {
                $$typeof: J,
                type: jA,
                key: g0,
                ref: p0,
                props: F0,
                _owner: NA.current
              }
            }

            function wA(jA, eA) {
              return {
                $$typeof: J,
                type: jA.type,
                key: eA,
                ref: jA.ref,
                props: jA.props,
                _owner: jA._owner
              }
            }

            function qA(jA) {
              return Y(jA) === "object" && jA !== null && jA.$$typeof === J
            }

            function KA(jA) {
              var eA = {
                "=": "=0",
                ":": "=2"
              };
              return "$" + jA.replace(/[=:]/g, function(t1) {
                return eA[t1]
              })
            }
            var yA = /\/+/g;

            function oA(jA, eA) {
              return Y(jA) === "object" && jA !== null && jA.key != null ? KA("" + jA.key) : eA.toString(36)
            }

            function X1(jA, eA, t1, v1, F0) {
              var g0 = Y(jA);
              if (g0 === "undefined" || g0 === "boolean") jA = null;
              var p0 = !1;
              if (jA === null) p0 = !0;
              else switch (g0) {
                case "string":
                case "number":
                  p0 = !0;
                  break;
                case "object":
                  switch (jA.$$typeof) {
                    case J:
                    case W:
                      p0 = !0
                  }
              }
              if (p0) return p0 = jA, F0 = F0(p0), jA = v1 === "" ? "." + oA(p0, 0) : v1, FA(F0) ? (t1 = "", jA != null && (t1 = jA.replace(yA, "$&/") + "/"), X1(F0, eA, t1, "", function(zQ) {
                return zQ
              })) : F0 != null && (qA(F0) && (F0 = wA(F0, t1 + (!F0.key || p0 && p0.key === F0.key ? "" : ("" + F0.key).replace(yA, "$&/") + "/") + jA)), eA.push(F0)), 1;
              if (p0 = 0, v1 = v1 === "" ? "." : v1 + ":", FA(jA))
                for (var n0 = 0; n0 < jA.length; n0++) {
                  g0 = jA[n0];
                  var _1 = v1 + oA(g0, n0);
                  p0 += X1(g0, eA, t1, _1, F0)
                } else if (_1 = p(jA), typeof _1 === "function")
                  for (jA = _1.call(jA), n0 = 0; !(g0 = jA.next()).done;) g0 = g0.value, _1 = v1 + oA(g0, n0++), p0 += X1(g0, eA, t1, _1, F0);
                else if (g0 === "object") throw eA = String(jA), Error("Objects are not valid as a React child (found: " + (eA === "[object Object]" ? "object with keys {" + Object.keys(jA).join(", ") + "}" : eA) + "). If you meant to render a collection of children, use an array instead.");
              return p0
            }

            function WA(jA, eA, t1) {
              if (jA == null) return jA;
              var v1 = [],
                F0 = 0;
              return X1(jA, v1, "", "", function(g0) {
                return eA.call(t1, g0, F0++)
              }), v1
            }

            function EA(jA) {
              if (jA._status === -1) {
                var eA = jA._result;
                eA = eA(), eA.then(function(t1) {
                  if (jA._status === 0 || jA._status === -1) jA._status = 1, jA._result = t1
                }, function(t1) {
                  if (jA._status === 0 || jA._status === -1) jA._status = 2, jA._result = t1
                }), jA._status === -1 && (jA._status = 0, jA._result = eA)
              }
              if (jA._status === 1) return jA._result.default;
              throw jA._result
            }
            var MA = {
              current: null
            };

            function DA() {
              return new WeakMap
            }

            function $A() {
              return {
                s: 0,
                v: void 0,
                o: null,
                p: null
              }
            }
            var TA = {
              current: null
            };

            function rA(jA, eA) {
              return TA.current.useOptimistic(jA, eA)
            }
            var iA = {
                transition: null
              },
              J1 = {},
              w1 = {
                ReactCurrentDispatcher: TA,
                ReactCurrentCache: MA,
                ReactCurrentBatchConfig: iA,
                ReactCurrentOwner: NA,
                ContextRegistry: J1
              };
            I.Children = {
              map: WA,
              forEach: function(eA, t1, v1) {
                WA(eA, function() {
                  t1.apply(this, arguments)
                }, v1)
              },
              count: function(eA) {
                var t1 = 0;
                return WA(eA, function() {
                  t1++
                }), t1
              },
              toArray: function(eA) {
                return WA(eA, function(t1) {
                  return t1
                }) || []
              },
              only: function(eA) {
                if (!qA(eA)) throw Error("React.Children.only expected to receive a single React element child.");
                return eA
              }
            }, I.Component = k, I.Fragment = X, I.Profiler = F, I.PureComponent = o, I.StrictMode = V, I.Suspense = E, I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = w1, I.cache = function(jA) {
              return function() {
                var eA = MA.current;
                if (!eA) return jA.apply(null, arguments);
                var t1 = eA.getCacheForType(DA);
                eA = t1.get(jA), eA === void 0 && (eA = $A(), t1.set(jA, eA)), t1 = 0;
                for (var v1 = arguments.length; t1 < v1; t1++) {
                  var F0 = arguments[t1];
                  if (typeof F0 === "function" || Y(F0) === "object" && F0 !== null) {
                    var g0 = eA.o;
                    g0 === null && (eA.o = g0 = new WeakMap), eA = g0.get(F0), eA === void 0 && (eA = $A(), g0.set(F0, eA))
                  } else g0 = eA.p, g0 === null && (eA.p = g0 = new Map), eA = g0.get(F0), eA === void 0 && (eA = $A(), g0.set(F0, eA))
                }
                if (eA.s === 1) return eA.v;
                if (eA.s === 2) throw eA.v;
                try {
                  var p0 = jA.apply(null, arguments);
                  return t1 = eA, t1.s = 1, t1.v = p0
                } catch (n0) {
                  throw p0 = eA, p0.s = 2, p0.v = n0, n0
                }
              }
            }, I.cloneElement = function(jA, eA, t1) {
              if (jA === null || jA === void 0) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + jA + ".");
              var v1 = e({}, jA.props),
                F0 = jA.key,
                g0 = jA.ref,
                p0 = jA._owner;
              if (eA != null) {
                if (eA.ref !== void 0 && (g0 = eA.ref, p0 = NA.current), eA.key !== void 0 && (F0 = "" + eA.key), jA.type && jA.type.defaultProps) var n0 = jA.type.defaultProps;
                for (_1 in eA) zA.call(eA, _1) && !OA.hasOwnProperty(_1) && (v1[_1] = eA[_1] === void 0 && n0 !== void 0 ? n0[_1] : eA[_1])
              }
              var _1 = arguments.length - 2;
              if (_1 === 1) v1.children = t1;
              else if (1 < _1) {
                n0 = Array(_1);
                for (var zQ = 0; zQ < _1; zQ++) n0[zQ] = arguments[zQ + 2];
                v1.children = n0
              }
              return {
                $$typeof: J,
                type: jA.type,
                key: F0,
                ref: g0,
                props: v1,
                _owner: p0
              }
            }, I.createContext = function(jA) {
              return jA = {
                $$typeof: D,
                _currentValue: jA,
                _currentValue2: jA,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
              }, jA.Provider = {
                $$typeof: K,
                _context: jA
              }, jA.Consumer = jA
            }, I.createElement = mA, I.createFactory = function(jA) {
              var eA = mA.bind(null, jA);
              return eA.type = jA, eA
            }, I.createRef = function() {
              return {
                current: null
              }
            }, I.createServerContext = function(jA, eA) {
              var t1 = !0;
              if (!J1[jA]) {
                t1 = !1;
                var v1 = {
                  $$typeof: H,
                  _currentValue: eA,
                  _currentValue2: eA,
                  _defaultValue: eA,
                  _threadCount: 0,
                  Provider: null,
                  Consumer: null,
                  _globalName: jA
                };
                v1.Provider = {
                  $$typeof: K,
                  _context: v1
                }, J1[jA] = v1
              }
              if (v1 = J1[jA], v1._defaultValue === y) v1._defaultValue = eA, v1._currentValue === y && (v1._currentValue = eA), v1._currentValue2 === y && (v1._currentValue2 = eA);
              else if (t1) throw Error("ServerContext: " + jA + " already defined");
              return v1
            }, I.experimental_useEffectEvent = function(jA) {
              return TA.current.useEffectEvent(jA)
            }, I.experimental_useOptimistic = function(jA, eA) {
              return rA(jA, eA)
            }, I.forwardRef = function(jA) {
              return {
                $$typeof: C,
                render: jA
              }
            }, I.isValidElement = qA, I.lazy = function(jA) {
              return {
                $$typeof: w,
                _payload: {
                  _status: -1,
                  _result: jA
                },
                _init: EA
              }
            }, I.memo = function(jA, eA) {
              return {
                $$typeof: q,
                type: jA,
                compare: eA === void 0 ? null : eA
              }
            }, I.startTransition = function(jA) {
              var eA = iA.transition;
              iA.transition = {};
              try {
                jA()
              } finally {
                iA.transition = eA
              }
            }, I.unstable_Cache = T, I.unstable_DebugTracingMode = N, I.unstable_Offscreen = R, I.unstable_SuspenseList = U, I.unstable_act = function() {
              throw Error("act(...) is not supported in production builds of React.")
            }, I.unstable_getCacheForType = function(jA) {
              var eA = MA.current;
              return eA ? eA.getCacheForType(jA) : jA()
            }, I.unstable_getCacheSignal = function() {
              var jA = MA.current;
              return jA ? jA.getCacheSignal() : (jA = new AbortController, jA.abort(Error("This CacheSignal was requested outside React which means that it is immediately aborted.")), jA.signal)
            }, I.unstable_postpone = function(jA) {
              throw jA = Error(jA), jA.$$typeof = v, jA
            }, I.unstable_useCacheRefresh = function() {
              return TA.current.useCacheRefresh()
            }, I.unstable_useMemoCache = function(jA) {
              return TA.current.useMemoCache(jA)
            }, I.use = function(jA) {
              return TA.current.use(jA)
            }, I.useCallback = function(jA, eA) {
              return TA.current.useCallback(jA, eA)
            }, I.useContext = function(jA) {
              return TA.current.useContext(jA)
            }, I.useDebugValue = function() {}, I.useDeferredValue = function(jA, eA) {
              return TA.current.useDeferredValue(jA, eA)
            }, I.useEffect = function(jA, eA) {
              return TA.current.useEffect(jA, eA)
            }, I.useId = function() {
              return TA.current.useId()
            }, I.useImperativeHandle = function(jA, eA, t1) {
              return TA.current.useImperativeHandle(jA, eA, t1)
            }, I.useInsertionEffect = function(jA, eA) {
              return TA.current.useInsertionEffect(jA, eA)
            }, I.useLayoutEffect = function(jA, eA) {
              return TA.current.useLayoutEffect(jA, eA)
            }, I.useMemo = function(jA, eA) {
              return TA.current.useMemo(jA, eA)
            }, I.useOptimistic = rA, I.useReducer = function(jA, eA, t1) {
              return TA.current.useReducer(jA, eA, t1)
            }, I.useRef = function(jA) {
              return TA.current.useRef(jA)
            }, I.useState = function(jA) {
              return TA.current.useState(jA)
            }, I.useSyncExternalStore = function(jA, eA, t1) {
              return TA.current.useSyncExternalStore(jA, eA, t1)
            }, I.useTransition = function() {
              return TA.current.useTransition()
            }, I.version = "18.3.0-experimental-51ffd3564-20231025"
          },
          189: (Z, I, Y) => {
            Z.exports = Y(978)
          },
          206: function(Z, I, Y) {
            var J, W, X;

            function V(F) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") V = function(D) {
                return typeof D
              };
              else V = function(D) {
                return D && typeof Symbol === "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D
              };
              return V(F)
            }(function(F, K) {
              W = [Y(430)], J = K, X = typeof J === "function" ? J.apply(I, W) : J, X !== void 0 && (Z.exports = X)
            })(this, function(K) {
              var D = /(^|@)\S+:\d+/,
                H = /^\s*at .*(\S+:\d+|\(native\))/m,
                C = /^(eval@)?(\[native code])?$/;
              return {
                parse: function(U) {
                  if (typeof U.stacktrace < "u" || typeof U["opera#sourceloc"] < "u") return this.parseOpera(U);
                  else if (U.stack && U.stack.match(H)) return this.parseV8OrIE(U);
                  else if (U.stack) return this.parseFFOrSafari(U);
                  else throw Error("Cannot parse given Error object")
                },
                extractLocation: function(U) {
                  if (U.indexOf(":") === -1) return [U];
                  var q = /(.+?)(?::(\d+))?(?::(\d+))?$/,
                    w = q.exec(U.replace(/[()]/g, ""));
                  return [w[1], w[2] || void 0, w[3] || void 0]
                },
                parseV8OrIE: function(U) {
                  var q = U.stack.split(`
`).filter(function(w) {
                    return !!w.match(H)
                  }, this);
                  return q.map(function(w) {
                    if (w.indexOf("(eval ") > -1) w = w.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "");
                    var N = w.replace(/^\s+/, "").replace(/\(eval code/g, "("),
                      R = N.match(/ (\((.+):(\d+):(\d+)\)$)/);
                    N = R ? N.replace(R[0], "") : N;
                    var T = N.split(/\s+/).slice(1),
                      y = this.extractLocation(R ? R[1] : T.pop()),
                      v = T.join(" ") || void 0,
                      x = ["eval", "<anonymous>"].indexOf(y[0]) > -1 ? void 0 : y[0];
                    return new K({
                      functionName: v,
                      fileName: x,
                      lineNumber: y[1],
                      columnNumber: y[2],
                      source: w
                    })
                  }, this)
                },
                parseFFOrSafari: function(U) {
                  var q = U.stack.split(`
`).filter(function(w) {
                    return !w.match(C)
                  }, this);
                  return q.map(function(w) {
                    if (w.indexOf(" > eval") > -1) w = w.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
                    if (w.indexOf("@") === -1 && w.indexOf(":") === -1) return new K({
                      functionName: w
                    });
                    else {
                      var N = /((.*".+"[^@]*)?[^@]*)(?:@)/,
                        R = w.match(N),
                        T = R && R[1] ? R[1] : void 0,
                        y = this.extractLocation(w.replace(N, ""));
                      return new K({
                        functionName: T,
                        fileName: y[0],
                        lineNumber: y[1],
                        columnNumber: y[2],
                        source: w
                      })
                    }
                  }, this)
                },
                parseOpera: function(U) {
                  if (!U.stacktrace || U.message.indexOf(`
`) > -1 && U.message.split(`
`).length > U.stacktrace.split(`
`).length) return this.parseOpera9(U);
                  else if (!U.stack) return this.parseOpera10(U);
                  else return this.parseOpera11(U)
                },
                parseOpera9: function(U) {
                  var q = /Line (\d+).*script (?:in )?(\S+)/i,
                    w = U.message.split(`
`),
                    N = [];
                  for (var R = 2, T = w.length; R < T; R += 2) {
                    var y = q.exec(w[R]);
                    if (y) N.push(new K({
                      fileName: y[2],
                      lineNumber: y[1],
                      source: w[R]
                    }))
                  }
                  return N
                },
                parseOpera10: function(U) {
                  var q = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,
                    w = U.stacktrace.split(`
`),
                    N = [];
                  for (var R = 0, T = w.length; R < T; R += 2) {
                    var y = q.exec(w[R]);
                    if (y) N.push(new K({
                      functionName: y[3] || void 0,
                      fileName: y[2],
                      lineNumber: y[1],
                      source: w[R]
                    }))
                  }
                  return N
                },
                parseOpera11: function(U) {
                  var q = U.stack.split(`
`).filter(function(w) {
                    return !!w.match(D) && !w.match(/^Error created at/)
                  }, this);
                  return q.map(function(w) {
                    var N = w.split("@"),
                      R = this.extractLocation(N.pop()),
                      T = N.shift() || "",
                      y = T.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0,
                      v;
                    if (T.match(/\(([^)]*)\)/)) v = T.replace(/^[^(]+\(([^)]*)\)$/, "$1");
                    var x = v === void 0 || v === "[arguments not available]" ? void 0 : v.split(",");
                    return new K({
                      functionName: y,
                      args: x,
                      fileName: R[0],
                      lineNumber: R[1],
                      columnNumber: R[2],
                      source: w
                    })
                  }, this)
                }
              }
            })
          },
          172: (Z) => {
            function I(e) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") I = function(k) {
                return typeof k
              };
              else I = function(k) {
                return k && typeof Symbol === "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k
              };
              return I(e)
            }
            var Y = "Expected a function",
              J = NaN,
              W = "[object Symbol]",
              X = /^\s+|\s+$/g,
              V = /^[-+]0x[0-9a-f]+$/i,
              F = /^0b[01]+$/i,
              K = /^0o[0-7]+$/i,
              D = parseInt,
              H = (typeof global > "u" ? "undefined" : I(global)) == "object" && global && global.Object === Object && global,
              C = (typeof self > "u" ? "undefined" : I(self)) == "object" && self && self.Object === Object && self,
              E = H || C || Function("return this")(),
              U = Object.prototype,
              q = U.toString,
              w = Math.max,
              N = Math.min,
              R = function() {
                return E.Date.now()
              };

            function T(e, l, k) {
              var m, o, IA, FA, zA, NA, OA = 0,
                mA = !1,
                wA = !1,
                qA = !0;
              if (typeof e != "function") throw TypeError(Y);
              if (l = u(l) || 0, v(k)) mA = !!k.leading, wA = "maxWait" in k, IA = wA ? w(u(k.maxWait) || 0, l) : IA, qA = "trailing" in k ? !!k.trailing : qA;

              function KA(TA) {
                var rA = m,
                  iA = o;
                return m = o = void 0, OA = TA, FA = e.apply(iA, rA), FA
              }

              function yA(TA) {
                return OA = TA, zA = setTimeout(WA, l), mA ? KA(TA) : FA
              }

              function oA(TA) {
                var rA = TA - NA,
                  iA = TA - OA,
                  J1 = l - rA;
                return wA ? N(J1, IA - iA) : J1
              }

              function X1(TA) {
                var rA = TA - NA,
                  iA = TA - OA;
                return NA === void 0 || rA >= l || rA < 0 || wA && iA >= IA
              }

              function WA() {
                var TA = R();
                if (X1(TA)) return EA(TA);
                zA = setTimeout(WA, oA(TA))
              }

              function EA(TA) {
                if (zA = void 0, qA && m) return KA(TA);
                return m = o = void 0, FA
              }

              function MA() {
                if (zA !== void 0) clearTimeout(zA);
                OA = 0, m = NA = o = zA = void 0
              }

              function DA() {
                return zA === void 0 ? FA : EA(R())
              }

              function $A() {
                var TA = R(),
                  rA = X1(TA);
                if (m = arguments, o = this, NA = TA, rA) {
                  if (zA === void 0) return yA(NA);
                  if (wA) return zA = setTimeout(WA, l), KA(NA)
                }
                if (zA === void 0) zA = setTimeout(WA, l);
                return FA
              }
              return $A.cancel = MA, $A.flush = DA, $A
            }

            function y(e, l, k) {
              var m = !0,
                o = !0;
              if (typeof e != "function") throw TypeError(Y);
              if (v(k)) m = "leading" in k ? !!k.leading : m, o = "trailing" in k ? !!k.trailing : o;
              return T(e, l, {
                leading: m,
                maxWait: l,
                trailing: o
              })
            }

            function v(e) {
              var l = I(e);
              return !!e && (l == "object" || l == "function")
            }

            function x(e) {
              return !!e && I(e) == "object"
            }

            function p(e) {
              return I(e) == "symbol" || x(e) && q.call(e) == W
            }

            function u(e) {
              if (typeof e == "number") return e;
              if (p(e)) return J;
              if (v(e)) {
                var l = typeof e.valueOf == "function" ? e.valueOf() : e;
                e = v(l) ? l + "" : l
              }
              if (typeof e != "string") return e === 0 ? e : +e;
              e = e.replace(X, "");
              var k = F.test(e);
              return k || K.test(e) ? D(e.slice(2), k ? 2 : 8) : V.test(e) ? J : +e
            }
            Z.exports = y
          },
          730: (Z, I, Y) => {
            var J = Y(169);
            Z.exports = y;
            var W = Y(307),
              X = Y(82),
              V = Y(695),
              F = typeof Symbol === "function" && J.env._nodeLRUCacheForceNoSymbol !== "1",
              K;
            if (F) K = function(m) {
              return Symbol(m)
            };
            else K = function(m) {
              return "_" + m
            };
            var D = K("max"),
              H = K("length"),
              C = K("lengthCalculator"),
              E = K("allowStale"),
              U = K("maxAge"),
              q = K("dispose"),
              w = K("noDisposeOnSet"),
              N = K("lruList"),
              R = K("cache");

            function T() {
              return 1
            }

            function y(k) {
              if (!(this instanceof y)) return new y(k);
              if (typeof k === "number") k = {
                max: k
              };
              if (!k) k = {};
              var m = this[D] = k.max;
              if (!m || typeof m !== "number" || m <= 0) this[D] = 1 / 0;
              var o = k.length || T;
              if (typeof o !== "function") o = T;
              this[C] = o, this[E] = k.stale || !1, this[U] = k.maxAge || 0, this[q] = k.dispose, this[w] = k.noDisposeOnSet || !1, this.reset()
            }
            Object.defineProperty(y.prototype, "max", {
              set: function(m) {
                if (!m || typeof m !== "number" || m <= 0) m = 1 / 0;
                this[D] = m, u(this)
              },
              get: function() {
                return this[D]
              },
              enumerable: !0
            }), Object.defineProperty(y.prototype, "allowStale", {
              set: function(m) {
                this[E] = !!m
              },
              get: function() {
                return this[E]
              },
              enumerable: !0
            }), Object.defineProperty(y.prototype, "maxAge", {
              set: function(m) {
                if (!m || typeof m !== "number" || m < 0) m = 0;
                this[U] = m, u(this)
              },
              get: function() {
                return this[U]
              },
              enumerable: !0
            }), Object.defineProperty(y.prototype, "lengthCalculator", {
              set: function(m) {
                if (typeof m !== "function") m = T;
                if (m !== this[C]) this[C] = m, this[H] = 0, this[N].forEach(function(o) {
                  o.length = this[C](o.value, o.key), this[H] += o.length
                }, this);
                u(this)
              },
              get: function() {
                return this[C]
              },
              enumerable: !0
            }), Object.defineProperty(y.prototype, "length", {
              get: function() {
                return this[H]
              },
              enumerable: !0
            }), Object.defineProperty(y.prototype, "itemCount", {
              get: function() {
                return this[N].length
              },
              enumerable: !0
            }), y.prototype.rforEach = function(k, m) {
              m = m || this;
              for (var o = this[N].tail; o !== null;) {
                var IA = o.prev;
                v(this, k, o, m), o = IA
              }
            };

            function v(k, m, o, IA) {
              var FA = o.value;
              if (p(k, FA)) {
                if (e(k, o), !k[E]) FA = void 0
              }
              if (FA) m.call(IA, FA.value, FA.key, k)
            }
            y.prototype.forEach = function(k, m) {
              m = m || this;
              for (var o = this[N].head; o !== null;) {
                var IA = o.next;
                v(this, k, o, m), o = IA
              }
            }, y.prototype.keys = function() {
              return this[N].toArray().map(function(k) {
                return k.key
              }, this)
            }, y.prototype.values = function() {
              return this[N].toArray().map(function(k) {
                return k.value
              }, this)
            }, y.prototype.reset = function() {
              if (this[q] && this[N] && this[N].length) this[N].forEach(function(k) {
                this[q](k.key, k.value)
              }, this);
              this[R] = new W, this[N] = new V, this[H] = 0
            }, y.prototype.dump = function() {
              return this[N].map(function(k) {
                if (!p(this, k)) return {
                  k: k.key,
                  v: k.value,
                  e: k.now + (k.maxAge || 0)
                }
              }, this).toArray().filter(function(k) {
                return k
              })
            }, y.prototype.dumpLru = function() {
              return this[N]
            }, y.prototype.inspect = function(k, m) {
              var o = "LRUCache {",
                IA = !1,
                FA = this[E];
              if (FA) o += `
  allowStale: true`, IA = !0;
              var zA = this[D];
              if (zA && zA !== 1 / 0) {
                if (IA) o += ",";
                o += `
  max: ` + X.inspect(zA, m), IA = !0
              }
              var NA = this[U];
              if (NA) {
                if (IA) o += ",";
                o += `
  maxAge: ` + X.inspect(NA, m), IA = !0
              }
              var OA = this[C];
              if (OA && OA !== T) {
                if (IA) o += ",";
                o += `
  length: ` + X.inspect(this[H], m), IA = !0
              }
              var mA = !1;
              if (this[N].forEach(function(wA) {
                  if (mA) o += `,
  `;
                  else {
                    if (IA) o += `,
`;
                    mA = !0, o += `
  `
                  }
                  var qA = X.inspect(wA.key).split(`
`).join(`
  `),
                    KA = {
                      value: wA.value
                    };
                  if (wA.maxAge !== NA) KA.maxAge = wA.maxAge;
                  if (OA !== T) KA.length = wA.length;
                  if (p(this, wA)) KA.stale = !0;
                  KA = X.inspect(KA, m).split(`
`).join(`
  `), o += qA + " => " + KA
                }), mA || IA) o += `
`;
              return o += "}", o
            }, y.prototype.set = function(k, m, o) {
              o = o || this[U];
              var IA = o ? Date.now() : 0,
                FA = this[C](m, k);
              if (this[R].has(k)) {
                if (FA > this[D]) return e(this, this[R].get(k)), !1;
                var zA = this[R].get(k),
                  NA = zA.value;
                if (this[q]) {
                  if (!this[w]) this[q](k, NA.value)
                }
                return NA.now = IA, NA.maxAge = o, NA.value = m, this[H] += FA - NA.length, NA.length = FA, this.get(k), u(this), !0
              }
              var OA = new l(k, m, FA, IA, o);
              if (OA.length > this[D]) {
                if (this[q]) this[q](k, m);
                return !1
              }
              return this[H] += OA.length, this[N].unshift(OA), this[R].set(k, this[N].head), u(this), !0
            }, y.prototype.has = function(k) {
              if (!this[R].has(k)) return !1;
              var m = this[R].get(k).value;
              if (p(this, m)) return !1;
              return !0
            }, y.prototype.get = function(k) {
              return x(this, k, !0)
            }, y.prototype.peek = function(k) {
              return x(this, k, !1)
            }, y.prototype.pop = function() {
              var k = this[N].tail;
              if (!k) return null;
              return e(this, k), k.value
            }, y.prototype.del = function(k) {
              e(this, this[R].get(k))
            }, y.prototype.load = function(k) {
              this.reset();
              var m = Date.now();
              for (var o = k.length - 1; o >= 0; o--) {
                var IA = k[o],
                  FA = IA.e || 0;
                if (FA === 0) this.set(IA.k, IA.v);
                else {
                  var zA = FA - m;
                  if (zA > 0) this.set(IA.k, IA.v, zA)
                }
              }
            }, y.prototype.prune = function() {
              var k = this;
              this[R].forEach(function(m, o) {
                x(k, o, !1)
              })
            };

            function x(k, m, o) {
              var IA = k[R].get(m);
              if (IA) {
                var FA = IA.value;
                if (p(k, FA)) {
                  if (e(k, IA), !k[E]) FA = void 0
                } else if (o) k[N].unshiftNode(IA);
                if (FA) FA = FA.value
              }
              return FA
            }

            function p(k, m) {
              if (!m || !m.maxAge && !k[U]) return !1;
              var o = !1,
                IA = Date.now() - m.now;
              if (m.maxAge) o = IA > m.maxAge;
              else o = k[U] && IA > k[U];
              return o
            }

            function u(k) {
              if (k[H] > k[D])
                for (var m = k[N].tail; k[H] > k[D] && m !== null;) {
                  var o = m.prev;
                  e(k, m), m = o
                }
            }

            function e(k, m) {
              if (m) {
                var o = m.value;
                if (k[q]) k[q](o.key, o.value);
                k[H] -= o.length, k[R].delete(o.key), k[N].removeNode(m)
              }
            }

            function l(k, m, o, IA, FA) {
              this.key = k, this.value = m, this.length = o, this.now = IA, this.maxAge = FA || 0
            }
          },
          169: (Z) => {
            var I = Z.exports = {},
              Y, J;

            function W() {
              throw Error("setTimeout has not been defined")
            }

            function X() {
              throw Error("clearTimeout has not been defined")
            }(function() {
              try {
                if (typeof setTimeout === "function") Y = setTimeout;
                else Y = W
              } catch (N) {
                Y = W
              }
              try {
                if (typeof clearTimeout === "function") J = clearTimeout;
                else J = X
              } catch (N) {
                J = X
              }
            })();

            function V(N) {
              if (Y === setTimeout) return setTimeout(N, 0);
              if ((Y === W || !Y) && setTimeout) return Y = setTimeout, setTimeout(N, 0);
              try {
                return Y(N, 0)
              } catch (R) {
                try {
                  return Y.call(null, N, 0)
                } catch (T) {
                  return Y.call(this, N, 0)
                }
              }
            }

            function F(N) {
              if (J === clearTimeout) return clearTimeout(N);
              if ((J === X || !J) && clearTimeout) return J = clearTimeout, clearTimeout(N);
              try {
                return J(N)
              } catch (R) {
                try {
                  return J.call(null, N)
                } catch (T) {
                  return J.call(this, N)
                }
              }
            }
            var K = [],
              D = !1,
              H, C = -1;

            function E() {
              if (!D || !H) return;
              if (D = !1, H.length) K = H.concat(K);
              else C = -1;
              if (K.length) U()
            }

            function U() {
              if (D) return;
              var N = V(E);
              D = !0;
              var R = K.length;
              while (R) {
                H = K, K = [];
                while (++C < R)
                  if (H) H[C].run();
                C = -1, R = K.length
              }
              H = null, D = !1, F(N)
            }
            I.nextTick = function(N) {
              var R = Array(arguments.length - 1);
              if (arguments.length > 1)
                for (var T = 1; T < arguments.length; T++) R[T - 1] = arguments[T];
              if (K.push(new q(N, R)), K.length === 1 && !D) V(U)
            };

            function q(N, R) {
              this.fun = N, this.array = R
            }
            q.prototype.run = function() {
              this.fun.apply(null, this.array)
            }, I.title = "browser", I.browser = !0, I.env = {}, I.argv = [], I.version = "", I.versions = {};

            function w() {}
            I.on = w, I.addListener = w, I.once = w, I.off = w, I.removeListener = w, I.removeAllListeners = w, I.emit = w, I.prependListener = w, I.prependOnceListener = w, I.listeners = function(N) {
              return []
            }, I.binding = function(N) {
              throw Error("process.binding is not supported")
            }, I.cwd = function() {
              return "/"
            }, I.chdir = function(N) {
              throw Error("process.chdir is not supported")
            }, I.umask = function() {
              return 0
            }
          },
          307: (Z, I, Y) => {
            var J = Y(169);
            if (J.env.npm_package_name === "pseudomap" && J.env.npm_lifecycle_script === "test") J.env.TEST_PSEUDOMAP = "true";
            if (typeof Map === "function" && !J.env.TEST_PSEUDOMAP) Z.exports = Map;
            else Z.exports = Y(761)
          },
          761: (Z) => {
            var I = Object.prototype.hasOwnProperty;
            Z.exports = Y;

            function Y(F) {
              if (!(this instanceof Y)) throw TypeError("Constructor PseudoMap requires 'new'");
              if (this.clear(), F)
                if (F instanceof Y || typeof Map === "function" && F instanceof Map) F.forEach(function(K, D) {
                  this.set(D, K)
                }, this);
                else if (Array.isArray(F)) F.forEach(function(K) {
                this.set(K[0], K[1])
              }, this);
              else throw TypeError("invalid argument")
            }
            Y.prototype.forEach = function(F, K) {
              K = K || this, Object.keys(this._data).forEach(function(D) {
                if (D !== "size") F.call(K, this._data[D].value, this._data[D].key)
              }, this)
            }, Y.prototype.has = function(F) {
              return !!X(this._data, F)
            }, Y.prototype.get = function(F) {
              var K = X(this._data, F);
              return K && K.value
            }, Y.prototype.set = function(F, K) {
              V(this._data, F, K)
            }, Y.prototype.delete = function(F) {
              var K = X(this._data, F);
              if (K) delete this._data[K._index], this._data.size--
            }, Y.prototype.clear = function() {
              var F = Object.create(null);
              F.size = 0, Object.defineProperty(this, "_data", {
                value: F,
                enumerable: !1,
                configurable: !0,
                writable: !1
              })
            }, Object.defineProperty(Y.prototype, "size", {
              get: function() {
                return this._data.size
              },
              set: function(K) {},
              enumerable: !0,
              configurable: !0
            }), Y.prototype.values = Y.prototype.keys = Y.prototype.entries = function() {
              throw Error("iterators are not implemented in this version")
            };

            function J(F, K) {
              return F === K || F !== F && K !== K
            }

            function W(F, K, D) {
              this.key = F, this.value = K, this._index = D
            }

            function X(F, K) {
              for (var D = 0, H = "_" + K, C = H; I.call(F, C); C = H + D++)
                if (J(F[C].key, K)) return F[C]
            }

            function V(F, K, D) {
              for (var H = 0, C = "_" + K, E = C; I.call(F, E); E = C + H++)
                if (J(F[E].key, K)) {
                  F[E].value = D;
                  return
                } F.size++, F[E] = new W(K, D, E)
            }
          },
          430: function(Z, I) {
            var Y, J, W;

            function X(V) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") X = function(K) {
                return typeof K
              };
              else X = function(K) {
                return K && typeof Symbol === "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K
              };
              return X(V)
            }(function(V, F) {
              J = [], Y = F, W = typeof Y === "function" ? Y.apply(I, J) : Y, W !== void 0 && (Z.exports = W)
            })(this, function() {
              function V(T) {
                return !isNaN(parseFloat(T)) && isFinite(T)
              }

              function F(T) {
                return T.charAt(0).toUpperCase() + T.substring(1)
              }

              function K(T) {
                return function() {
                  return this[T]
                }
              }
              var D = ["isConstructor", "isEval", "isNative", "isToplevel"],
                H = ["columnNumber", "lineNumber"],
                C = ["fileName", "functionName", "source"],
                E = ["args"],
                U = D.concat(H, C, E);

              function q(T) {
                if (!T) return;
                for (var y = 0; y < U.length; y++)
                  if (T[U[y]] !== void 0) this["set" + F(U[y])](T[U[y]])
              }
              q.prototype = {
                getArgs: function() {
                  return this.args
                },
                setArgs: function(y) {
                  if (Object.prototype.toString.call(y) !== "[object Array]") throw TypeError("Args must be an Array");
                  this.args = y
                },
                getEvalOrigin: function() {
                  return this.evalOrigin
                },
                setEvalOrigin: function(y) {
                  if (y instanceof q) this.evalOrigin = y;
                  else if (y instanceof Object) this.evalOrigin = new q(y);
                  else throw TypeError("Eval Origin must be an Object or StackFrame")
                },
                toString: function() {
                  var y = this.getFileName() || "",
                    v = this.getLineNumber() || "",
                    x = this.getColumnNumber() || "",
                    p = this.getFunctionName() || "";
                  if (this.getIsEval()) {
                    if (y) return "[eval] (" + y + ":" + v + ":" + x + ")";
                    return "[eval]:" + v + ":" + x
                  }
                  if (p) return p + " (" + y + ":" + v + ":" + x + ")";
                  return y + ":" + v + ":" + x
                }
              }, q.fromString = function(y) {
                var v = y.indexOf("("),
                  x = y.lastIndexOf(")"),
                  p = y.substring(0, v),
                  u = y.substring(v + 1, x).split(","),
                  e = y.substring(x + 1);
                if (e.indexOf("@") === 0) var l = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e, ""),
                  k = l[1],
                  m = l[2],
                  o = l[3];
                return new q({
                  functionName: p,
                  args: u || void 0,
                  fileName: k,
                  lineNumber: m || void 0,
                  columnNumber: o || void 0
                })
              };
              for (var w = 0; w < D.length; w++) q.prototype["get" + F(D[w])] = K(D[w]), q.prototype["set" + F(D[w])] = function(T) {
                return function(y) {
                  this[T] = Boolean(y)
                }
              }(D[w]);
              for (var N = 0; N < H.length; N++) q.prototype["get" + F(H[N])] = K(H[N]), q.prototype["set" + F(H[N])] = function(T) {
                return function(y) {
                  if (!V(y)) throw TypeError(T + " must be a Number");
                  this[T] = Number(y)
                }
              }(H[N]);
              for (var R = 0; R < C.length; R++) q.prototype["get" + F(C[R])] = K(C[R]), q.prototype["set" + F(C[R])] = function(T) {
                return function(y) {
                  this[T] = String(y)
                }
              }(C[R]);
              return q
            })
          },
          718: (Z) => {
            if (typeof Object.create === "function") Z.exports = function(Y, J) {
              Y.super_ = J, Y.prototype = Object.create(J.prototype, {
                constructor: {
                  value: Y,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0
                }
              })
            };
            else Z.exports = function(Y, J) {
              Y.super_ = J;
              var W = function() {};
              W.prototype = J.prototype, Y.prototype = new W, Y.prototype.constructor = Y
            }
          },
          715: (Z) => {
            function I(Y) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") I = function(W) {
                return typeof W
              };
              else I = function(W) {
                return W && typeof Symbol === "function" && W.constructor === Symbol && W !== Symbol.prototype ? "symbol" : typeof W
              };
              return I(Y)
            }
            Z.exports = function(J) {
              return J && I(J) === "object" && typeof J.copy === "function" && typeof J.fill === "function" && typeof J.readUInt8 === "function"
            }
          },
          82: (Z, I, Y) => {
            var J = Y(169);

            function W(KA) {
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") W = function(oA) {
                return typeof oA
              };
              else W = function(oA) {
                return oA && typeof Symbol === "function" && oA.constructor === Symbol && oA !== Symbol.prototype ? "symbol" : typeof oA
              };
              return W(KA)
            }
            var X = /%[sdj%]/g;
            I.format = function(KA) {
              if (!u(KA)) {
                var yA = [];
                for (var oA = 0; oA < arguments.length; oA++) yA.push(K(arguments[oA]));
                return yA.join(" ")
              }
              var oA = 1,
                X1 = arguments,
                WA = X1.length,
                EA = String(KA).replace(X, function(DA) {
                  if (DA === "%%") return "%";
                  if (oA >= WA) return DA;
                  switch (DA) {
                    case "%s":
                      return String(X1[oA++]);
                    case "%d":
                      return Number(X1[oA++]);
                    case "%j":
                      try {
                        return JSON.stringify(X1[oA++])
                      } catch ($A) {
                        return "[Circular]"
                      }
                    default:
                      return DA
                  }
                });
              for (var MA = X1[oA]; oA < WA; MA = X1[++oA])
                if (v(MA) || !m(MA)) EA += " " + MA;
                else EA += " " + K(MA);
              return EA
            }, I.deprecate = function(KA, yA) {
              if (l(global.process)) return function() {
                return I.deprecate(KA, yA).apply(this, arguments)
              };
              if (J.noDeprecation === !0) return KA;
              var oA = !1;

              function X1() {
                if (!oA) {
                  if (J.throwDeprecation) throw Error(yA);
                  else if (J.traceDeprecation) console.trace(yA);
                  else console.error(yA);
                  oA = !0
                }
                return KA.apply(this, arguments)
              }
              return X1
            };
            var V = {},
              F;
            I.debuglog = function(KA) {
              if (l(F)) F = J.env.NODE_DEBUG || "";
              if (KA = KA.toUpperCase(), !V[KA])
                if (new RegExp("\\b" + KA + "\\b", "i").test(F)) {
                  var yA = J.pid;
                  V[KA] = function() {
                    var oA = I.format.apply(I, arguments);
                    console.error("%s %d: %s", KA, yA, oA)
                  }
                } else V[KA] = function() {};
              return V[KA]
            };

            function K(KA, yA) {
              var oA = {
                seen: [],
                stylize: H
              };
              if (arguments.length >= 3) oA.depth = arguments[2];
              if (arguments.length >= 4) oA.colors = arguments[3];
              if (y(yA)) oA.showHidden = yA;
              else if (yA) I._extend(oA, yA);
              if (l(oA.showHidden)) oA.showHidden = !1;
              if (l(oA.depth)) oA.depth = 2;
              if (l(oA.colors)) oA.colors = !1;
              if (l(oA.customInspect)) oA.customInspect = !0;
              if (oA.colors) oA.stylize = D;
              return E(oA, KA, oA.depth)
            }
            I.inspect = K, K.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39]
            }, K.styles = {
              special: "cyan",
              number: "yellow",
              boolean: "yellow",
              undefined: "grey",
              null: "bold",
              string: "green",
              date: "magenta",
              regexp: "red"
            };

            function D(KA, yA) {
              var oA = K.styles[yA];
              if (oA) return "\x1B[" + K.colors[oA][0] + "m" + KA + "\x1B[" + K.colors[oA][1] + "m";
              else return KA
            }

            function H(KA, yA) {
              return KA
            }

            function C(KA) {
              var yA = {};
              return KA.forEach(function(oA, X1) {
                yA[oA] = !0
              }), yA
            }

            function E(KA, yA, oA) {
              if (KA.customInspect && yA && FA(yA.inspect) && yA.inspect !== I.inspect && !(yA.constructor && yA.constructor.prototype === yA)) {
                var X1 = yA.inspect(oA, KA);
                if (!u(X1)) X1 = E(KA, X1, oA);
                return X1
              }
              var WA = U(KA, yA);
              if (WA) return WA;
              var EA = Object.keys(yA),
                MA = C(EA);
              if (KA.showHidden) EA = Object.getOwnPropertyNames(yA);
              if (IA(yA) && (EA.indexOf("message") >= 0 || EA.indexOf("description") >= 0)) return q(yA);
              if (EA.length === 0) {
                if (FA(yA)) {
                  var DA = yA.name ? ": " + yA.name : "";
                  return KA.stylize("[Function" + DA + "]", "special")
                }
                if (k(yA)) return KA.stylize(RegExp.prototype.toString.call(yA), "regexp");
                if (o(yA)) return KA.stylize(Date.prototype.toString.call(yA), "date");
                if (IA(yA)) return q(yA)
              }
              var $A = "",
                TA = !1,
                rA = ["{", "}"];
              if (T(yA)) TA = !0, rA = ["[", "]"];
              if (FA(yA)) {
                var iA = yA.name ? ": " + yA.name : "";
                $A = " [Function" + iA + "]"
              }
              if (k(yA)) $A = " " + RegExp.prototype.toString.call(yA);
              if (o(yA)) $A = " " + Date.prototype.toUTCString.call(yA);
              if (IA(yA)) $A = " " + q(yA);
              if (EA.length === 0 && (!TA || yA.length == 0)) return rA[0] + $A + rA[1];
              if (oA < 0)
                if (k(yA)) return KA.stylize(RegExp.prototype.toString.call(yA), "regexp");
                else return KA.stylize("[Object]", "special");
              KA.seen.push(yA);
              var J1;
              if (TA) J1 = w(KA, yA, oA, MA, EA);
              else J1 = EA.map(function(w1) {
                return N(KA, yA, oA, MA, w1, TA)
              });
              return KA.seen.pop(), R(J1, $A, rA)
            }

            function U(KA, yA) {
              if (l(yA)) return KA.stylize("undefined", "undefined");
              if (u(yA)) {
                var oA = "'" + JSON.stringify(yA).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return KA.stylize(oA, "string")
              }
              if (p(yA)) return KA.stylize("" + yA, "number");
              if (y(yA)) return KA.stylize("" + yA, "boolean");
              if (v(yA)) return KA.stylize("null", "null")
            }

            function q(KA) {
              return "[" + Error.prototype.toString.call(KA) + "]"
            }

            function w(KA, yA, oA, X1, WA) {
              var EA = [];
              for (var MA = 0, DA = yA.length; MA < DA; ++MA)
                if (qA(yA, String(MA))) EA.push(N(KA, yA, oA, X1, String(MA), !0));
                else EA.push("");
              return WA.forEach(function($A) {
                if (!$A.match(/^\d+$/)) EA.push(N(KA, yA, oA, X1, $A, !0))
              }), EA
            }

            function N(KA, yA, oA, X1, WA, EA) {
              var MA, DA, $A;
              if ($A = Object.getOwnPropertyDescriptor(yA, WA) || {
                  value: yA[WA]
                }, $A.get)
                if ($A.set) DA = KA.stylize("[Getter/Setter]", "special");
                else DA = KA.stylize("[Getter]", "special");
              else if ($A.set) DA = KA.stylize("[Setter]", "special");
              if (!qA(X1, WA)) MA = "[" + WA + "]";
              if (!DA)
                if (KA.seen.indexOf($A.value) < 0) {
                  if (v(oA)) DA = E(KA, $A.value, null);
                  else DA = E(KA, $A.value, oA - 1);
                  if (DA.indexOf(`
`) > -1)
                    if (EA) DA = DA.split(`
`).map(function(TA) {
                      return "  " + TA
                    }).join(`
`).substr(2);
                    else DA = `
` + DA.split(`
`).map(function(TA) {
                      return "   " + TA
                    }).join(`
`)
                } else DA = KA.stylize("[Circular]", "special");
              if (l(MA)) {
                if (EA && WA.match(/^\d+$/)) return DA;
                if (MA = JSON.stringify("" + WA), MA.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) MA = MA.substr(1, MA.length - 2), MA = KA.stylize(MA, "name");
                else MA = MA.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), MA = KA.stylize(MA, "string")
              }
              return MA + ": " + DA
            }

            function R(KA, yA, oA) {
              var X1 = 0,
                WA = KA.reduce(function(EA, MA) {
                  if (X1++, MA.indexOf(`
`) >= 0) X1++;
                  return EA + MA.replace(/\u001b\[\d\d?m/g, "").length + 1
                }, 0);
              if (WA > 60) return oA[0] + (yA === "" ? "" : yA + `
 `) + " " + KA.join(`,
  `) + " " + oA[1];
              return oA[0] + yA + " " + KA.join(", ") + " " + oA[1]
            }

            function T(KA) {
              return Array.isArray(KA)
            }
            I.isArray = T;

            function y(KA) {
              return typeof KA === "boolean"
            }
            I.isBoolean = y;

            function v(KA) {
              return KA === null
            }
            I.isNull = v;

            function x(KA) {
              return KA == null
            }
            I.isNullOrUndefined = x;

            function p(KA) {
              return typeof KA === "number"
            }
            I.isNumber = p;

            function u(KA) {
              return typeof KA === "string"
            }
            I.isString = u;

            function e(KA) {
              return W(KA) === "symbol"
            }
            I.isSymbol = e;

            function l(KA) {
              return KA === void 0
            }
            I.isUndefined = l;

            function k(KA) {
              return m(KA) && NA(KA) === "[object RegExp]"
            }
            I.isRegExp = k;

            function m(KA) {
              return W(KA) === "object" && KA !== null
            }
            I.isObject = m;

            function o(KA) {
              return m(KA) && NA(KA) === "[object Date]"
            }
            I.isDate = o;

            function IA(KA) {
              return m(KA) && (NA(KA) === "[object Error]" || KA instanceof Error)
            }
            I.isError = IA;

            function FA(KA) {
              return typeof KA === "function"
            }
            I.isFunction = FA;

            function zA(KA) {
              return KA === null || typeof KA === "boolean" || typeof KA === "number" || typeof KA === "string" || W(KA) === "symbol" || typeof KA > "u"
            }
            I.isPrimitive = zA, I.isBuffer = Y(715);

            function NA(KA) {
              return Object.prototype.toString.call(KA)
            }

            function OA(KA) {
              return KA < 10 ? "0" + KA.toString(10) : KA.toString(10)
            }
            var mA = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

            function wA() {
              var KA = new Date,
                yA = [OA(KA.getHours()), OA(KA.getMinutes()), OA(KA.getSeconds())].join(":");
              return [KA.getDate(), mA[KA.getMonth()], yA].join(" ")
            }
            I.log = function() {
              console.log("%s - %s", wA(), I.format.apply(I, arguments))
            }, I.inherits = Y(718), I._extend = function(KA, yA) {
              if (!yA || !m(yA)) return KA;
              var oA = Object.keys(yA),
                X1 = oA.length;
              while (X1--) KA[oA[X1]] = yA[oA[X1]];
              return KA
            };

            function qA(KA, yA) {
              return Object.prototype.hasOwnProperty.call(KA, yA)
            }
          },
          695: (Z) => {
            Z.exports = I, I.Node = W, I.create = I;

            function I(X) {
              var V = this;
              if (!(V instanceof I)) V = new I;
              if (V.tail = null, V.head = null, V.length = 0, X && typeof X.forEach === "function") X.forEach(function(D) {
                V.push(D)
              });
              else if (arguments.length > 0)
                for (var F = 0, K = arguments.length; F < K; F++) V.push(arguments[F]);
              return V
            }
            I.prototype.removeNode = function(X) {
              if (X.list !== this) throw Error("removing node which does not belong to this list");
              var {
                next: V,
                prev: F
              } = X;
              if (V) V.prev = F;
              if (F) F.next = V;
              if (X === this.head) this.head = V;
              if (X === this.tail) this.tail = F;
              X.list.length--, X.next = null, X.prev = null, X.list = null
            }, I.prototype.unshiftNode = function(X) {
              if (X === this.head) return;
              if (X.list) X.list.removeNode(X);
              var V = this.head;
              if (X.list = this, X.next = V, V) V.prev = X;
              if (this.head = X, !this.tail) this.tail = X;
              this.length++
            }, I.prototype.pushNode = function(X) {
              if (X === this.tail) return;
              if (X.list) X.list.removeNode(X);
              var V = this.tail;
              if (X.list = this, X.prev = V, V) V.next = X;
              if (this.tail = X, !this.head) this.head = X;
              this.length++
            }, I.prototype.push = function() {
              for (var X = 0, V = arguments.length; X < V; X++) Y(this, arguments[X]);
              return this.length
            }, I.prototype.unshift = function() {
              for (var X = 0, V = arguments.length; X < V; X++) J(this, arguments[X]);
              return this.length
            }, I.prototype.pop = function() {
              if (!this.tail) return;
              var X = this.tail.value;
              if (this.tail = this.tail.prev, this.tail) this.tail.next = null;
              else this.head = null;
              return this.length--, X
            }, I.prototype.shift = function() {
              if (!this.head) return;
              var X = this.head.value;
              if (this.head = this.head.next, this.head) this.head.prev = null;
              else this.tail = null;
              return this.length--, X
            }, I.prototype.forEach = function(X, V) {
              V = V || this;
              for (var F = this.head, K = 0; F !== null; K++) X.call(V, F.value, K, this), F = F.next
            }, I.prototype.forEachReverse = function(X, V) {
              V = V || this;
              for (var F = this.tail, K = this.length - 1; F !== null; K--) X.call(V, F.value, K, this), F = F.prev
            }, I.prototype.get = function(X) {
              for (var V = 0, F = this.head; F !== null && V < X; V++) F = F.next;
              if (V === X && F !== null) return F.value
            }, I.prototype.getReverse = function(X) {
              for (var V = 0, F = this.tail; F !== null && V < X; V++) F = F.prev;
              if (V === X && F !== null) return F.value
            }, I.prototype.map = function(X, V) {
              V = V || this;
              var F = new I;
              for (var K = this.head; K !== null;) F.push(X.call(V, K.value, this)), K = K.next;
              return F
            }, I.prototype.mapReverse = function(X, V) {
              V = V || this;
              var F = new I;
              for (var K = this.tail; K !== null;) F.push(X.call(V, K.value, this)), K = K.prev;
              return F
            }, I.prototype.reduce = function(X, V) {
              var F, K = this.head;
              if (arguments.length > 1) F = V;
              else if (this.head) K = this.head.next, F = this.head.value;
              else throw TypeError("Reduce of empty list with no initial value");
              for (var D = 0; K !== null; D++) F = X(F, K.value, D), K = K.next;
              return F
            }, I.prototype.reduceReverse = function(X, V) {
              var F, K = this.tail;
              if (arguments.length > 1) F = V;
              else if (this.tail) K = this.tail.prev, F = this.tail.value;
              else throw TypeError("Reduce of empty list with no initial value");
              for (var D = this.length - 1; K !== null; D--) F = X(F, K.value, D), K = K.prev;
              return F
            }, I.prototype.toArray = function() {
              var X = Array(this.length);
              for (var V = 0, F = this.head; F !== null; V++) X[V] = F.value, F = F.next;
              return X
            }, I.prototype.toArrayReverse = function() {
              var X = Array(this.length);
              for (var V = 0, F = this.tail; F !== null; V++) X[V] = F.value, F = F.prev;
              return X
            }, I.prototype.slice = function(X, V) {
              if (V = V || this.length, V < 0) V += this.length;
              if (X = X || 0, X < 0) X += this.length;
              var F = new I;
              if (V < X || V < 0) return F;
              if (X < 0) X = 0;
              if (V > this.length) V = this.length;
              for (var K = 0, D = this.head; D !== null && K < X; K++) D = D.next;
              for (; D !== null && K < V; K++, D = D.next) F.push(D.value);
              return F
            }, I.prototype.sliceReverse = function(X, V) {
              if (V = V || this.length, V < 0) V += this.length;
              if (X = X || 0, X < 0) X += this.length;
              var F = new I;
              if (V < X || V < 0) return F;
              if (X < 0) X = 0;
              if (V > this.length) V = this.length;
              for (var K = this.length, D = this.tail; D !== null && K > V; K--) D = D.prev;
              for (; D !== null && K > X; K--, D = D.prev) F.push(D.value);
              return F
            }, I.prototype.reverse = function() {
              var X = this.head,
                V = this.tail;
              for (var F = X; F !== null; F = F.prev) {
                var K = F.prev;
                F.prev = F.next, F.next = K
              }
              return this.head = V, this.tail = X, this
            };

            function Y(X, V) {
              if (X.tail = new W(V, X.tail, null, X), !X.head) X.head = X.tail;
              X.length++
            }

            function J(X, V) {
              if (X.head = new W(V, null, X.head, X), !X.tail) X.tail = X.head;
              X.length++
            }

            function W(X, V, F, K) {
              if (!(this instanceof W)) return new W(X, V, F, K);
              if (this.list = K, this.value = X, V) V.next = this, this.prev = V;
              else this.prev = null;
              if (F) F.prev = this, this.next = F;
              else this.next = null
            }
          }
        },
        Q = {};

      function B(Z) {
        var I = Q[Z];
        if (I !== void 0) return I.exports;
        var Y = Q[Z] = {
          exports: {}
        };
        return A[Z].call(Y.exports, Y, Y.exports, B), Y.exports
      }(() => {
        B.n = (Z) => {
          var I = Z && Z.__esModule ? () => Z.default : () => Z;
          return B.d(I, {
            a: I
          }), I
        }
      })(), (() => {
        B.d = (Z, I) => {
          for (var Y in I)
            if (B.o(I, Y) && !B.o(Z, Y)) Object.defineProperty(Z, Y, {
              enumerable: !0,
              get: I[Y]
            })
        }
      })(), (() => {
        B.o = (Z, I) => Object.prototype.hasOwnProperty.call(Z, I)
      })(), (() => {
        B.r = (Z) => {
          if (typeof Symbol < "u" && Symbol.toStringTag) Object.defineProperty(Z, Symbol.toStringTag, {
            value: "Module"
          });
          Object.defineProperty(Z, "__esModule", {
            value: !0
          })
        }
      })();
      var G = {};
      return (() => {
        B.r(G), B.d(G, {
          connectToDevTools: () => l3
        });

        function Z(b, a) {
          if (!(b instanceof a)) throw TypeError("Cannot call a class as a function")
        }

        function I(b, a) {
          for (var c = 0; c < a.length; c++) {
            var s = a[c];
            if (s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s) s.writable = !0;
            Object.defineProperty(b, s.key, s)
          }
        }

        function Y(b, a, c) {
          if (a) I(b.prototype, a);
          if (c) I(b, c);
          return b
        }

        function J(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }
        var W = function() {
            function b() {
              Z(this, b), J(this, "listenersMap", new Map)
            }
            return Y(b, [{
              key: "addListener",
              value: function(c, s) {
                var r = this.listenersMap.get(c);
                if (r === void 0) this.listenersMap.set(c, [s]);
                else {
                  var bA = r.indexOf(s);
                  if (bA < 0) r.push(s)
                }
              }
            }, {
              key: "emit",
              value: function(c) {
                var s = this.listenersMap.get(c);
                if (s !== void 0) {
                  for (var r = arguments.length, bA = Array(r > 1 ? r - 1 : 0), Y1 = 1; Y1 < r; Y1++) bA[Y1 - 1] = arguments[Y1];
                  if (s.length === 1) {
                    var B1 = s[0];
                    B1.apply(null, bA)
                  } else {
                    var uA = !1,
                      z1 = null,
                      S1 = Array.from(s);
                    for (var l1 = 0; l1 < S1.length; l1++) {
                      var n1 = S1[l1];
                      try {
                        n1.apply(null, bA)
                      } catch (ZQ) {
                        if (z1 === null) uA = !0, z1 = ZQ
                      }
                    }
                    if (uA) throw z1
                  }
                }
              }
            }, {
              key: "removeAllListeners",
              value: function() {
                this.listenersMap.clear()
              }
            }, {
              key: "removeListener",
              value: function(c, s) {
                var r = this.listenersMap.get(c);
                if (r !== void 0) {
                  var bA = r.indexOf(s);
                  if (bA >= 0) r.splice(bA, 1)
                }
              }
            }]), b
          }(),
          X = B(172),
          V = B.n(X),
          F = "fmkadmapgofadopljbjfkapdkoienihi",
          K = "dnjnjgbfilfphmojnmhliehogmojhclc",
          D = "ikiahnapldjmdmpkmfhjdjilojjhgcbf",
          H = !1,
          C = !1,
          E = 1,
          U = 2,
          q = 3,
          w = 4,
          N = 5,
          R = 6,
          T = 7,
          y = 1,
          v = 2,
          x = "React::DevTools::defaultTab",
          p = "React::DevTools::componentFilters",
          u = "React::DevTools::lastSelection",
          e = "React::DevTools::openInEditorUrl",
          l = "React::DevTools::openInEditorUrlPreset",
          k = "React::DevTools::parseHookNames",
          m = "React::DevTools::recordChangeDescriptions",
          o = "React::DevTools::reloadAndProfile",
          IA = "React::DevTools::breakOnConsoleErrors",
          FA = "React::DevTools::theme",
          zA = "React::DevTools::appendComponentStack",
          NA = "React::DevTools::showInlineWarningsAndErrors",
          OA = "React::DevTools::traceUpdatesEnabled",
          mA = "React::DevTools::hideConsoleLogsInStrictMode",
          wA = "React::DevTools::supportsProfiling",
          qA = 5;

        function KA(b) {
          try {
            return localStorage.getItem(b)
          } catch (a) {
            return null
          }
        }

        function yA(b) {
          try {
            localStorage.removeItem(b)
          } catch (a) {}
        }

        function oA(b, a) {
          try {
            return localStorage.setItem(b, a)
          } catch (c) {}
        }

        function X1(b) {
          try {
            return sessionStorage.getItem(b)
          } catch (a) {
            return null
          }
        }

        function WA(b) {
          try {
            sessionStorage.removeItem(b)
          } catch (a) {}
        }

        function EA(b, a) {
          try {
            return sessionStorage.setItem(b, a)
          } catch (c) {}
        }
        var MA = function(a, c) {
          return a === c
        };

        function DA(b) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : MA,
            c = void 0,
            s = [],
            r = void 0,
            bA = !1,
            Y1 = function(z1, S1) {
              return a(z1, s[S1])
            },
            B1 = function() {
              for (var z1 = arguments.length, S1 = Array(z1), l1 = 0; l1 < z1; l1++) S1[l1] = arguments[l1];
              if (bA && c === this && S1.length === s.length && S1.every(Y1)) return r;
              return bA = !0, c = this, s = S1, r = b.apply(this, S1), r
            };
          return B1
        }

        function $A(b) {
          if (!b.ownerDocument) return null;
          return b.ownerDocument.defaultView
        }

        function TA(b) {
          var a = $A(b);
          if (a) return a.frameElement;
          return null
        }

        function rA(b) {
          var a = w1(b);
          return iA([b.getBoundingClientRect(), {
            top: a.borderTop,
            left: a.borderLeft,
            bottom: a.borderBottom,
            right: a.borderRight,
            width: 0,
            height: 0
          }])
        }

        function iA(b) {
          return b.reduce(function(a, c) {
            if (a == null) return c;
            return {
              top: a.top + c.top,
              left: a.left + c.left,
              width: a.width,
              height: a.height,
              bottom: a.bottom + c.bottom,
              right: a.right + c.right
            }
          })
        }

        function J1(b, a) {
          var c = TA(b);
          if (c && c !== a) {
            var s = [b.getBoundingClientRect()],
              r = c,
              bA = !1;
            while (r) {
              var Y1 = rA(r);
              if (s.push(Y1), r = TA(r), bA) break;
              if (r && $A(r) === a) bA = !0
            }
            return iA(s)
          } else return b.getBoundingClientRect()
        }

        function w1(b) {
          var a = window.getComputedStyle(b);
          return {
            borderLeft: parseInt(a.borderLeftWidth, 10),
            borderRight: parseInt(a.borderRightWidth, 10),
            borderTop: parseInt(a.borderTopWidth, 10),
            borderBottom: parseInt(a.borderBottomWidth, 10),
            marginLeft: parseInt(a.marginLeft, 10),
            marginRight: parseInt(a.marginRight, 10),
            marginTop: parseInt(a.marginTop, 10),
            marginBottom: parseInt(a.marginBottom, 10),
            paddingLeft: parseInt(a.paddingLeft, 10),
            paddingRight: parseInt(a.paddingRight, 10),
            paddingTop: parseInt(a.paddingTop, 10),
            paddingBottom: parseInt(a.paddingBottom, 10)
          }
        }

        function jA(b, a) {
          if (!(b instanceof a)) throw TypeError("Cannot call a class as a function")
        }

        function eA(b, a) {
          for (var c = 0; c < a.length; c++) {
            var s = a[c];
            if (s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s) s.writable = !0;
            Object.defineProperty(b, s.key, s)
          }
        }

        function t1(b, a, c) {
          if (a) eA(b.prototype, a);
          if (c) eA(b, c);
          return b
        }
        var v1 = Object.assign,
          F0 = function() {
            function b(a, c) {
              jA(this, b), this.node = a.createElement("div"), this.border = a.createElement("div"), this.padding = a.createElement("div"), this.content = a.createElement("div"), this.border.style.borderColor = zQ.border, this.padding.style.borderColor = zQ.padding, this.content.style.backgroundColor = zQ.background, v1(this.node.style, {
                borderColor: zQ.margin,
                pointerEvents: "none",
                position: "fixed"
              }), this.node.style.zIndex = "10000000", this.node.appendChild(this.border), this.border.appendChild(this.padding), this.padding.appendChild(this.content), c.appendChild(this.node)
            }
            return t1(b, [{
              key: "remove",
              value: function() {
                if (this.node.parentNode) this.node.parentNode.removeChild(this.node)
              }
            }, {
              key: "update",
              value: function(c, s) {
                _1(s, "margin", this.node), _1(s, "border", this.border), _1(s, "padding", this.padding), v1(this.content.style, {
                  height: c.height - s.borderTop - s.borderBottom - s.paddingTop - s.paddingBottom + "px",
                  width: c.width - s.borderLeft - s.borderRight - s.paddingLeft - s.paddingRight + "px"
                }), v1(this.node.style, {
                  top: c.top - s.marginTop + "px",
                  left: c.left - s.marginLeft + "px"
                })
              }
            }]), b
          }(),
          g0 = function() {
            function b(a, c) {
              jA(this, b), this.tip = a.createElement("div"), v1(this.tip.style, {
                display: "flex",
                flexFlow: "row nowrap",
                backgroundColor: "#333740",
                borderRadius: "2px",
                fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
                fontWeight: "bold",
                padding: "3px 5px",
                pointerEvents: "none",
                position: "fixed",
                fontSize: "12px",
                whiteSpace: "nowrap"
              }), this.nameSpan = a.createElement("span"), this.tip.appendChild(this.nameSpan), v1(this.nameSpan.style, {
                color: "#ee78e6",
                borderRight: "1px solid #aaaaaa",
                paddingRight: "0.5rem",
                marginRight: "0.5rem"
              }), this.dimSpan = a.createElement("span"), this.tip.appendChild(this.dimSpan), v1(this.dimSpan.style, {
                color: "#d7d7d7"
              }), this.tip.style.zIndex = "10000000", c.appendChild(this.tip)
            }
            return t1(b, [{
              key: "remove",
              value: function() {
                if (this.tip.parentNode) this.tip.parentNode.removeChild(this.tip)
              }
            }, {
              key: "updateText",
              value: function(c, s, r) {
                this.nameSpan.textContent = c, this.dimSpan.textContent = Math.round(s) + "px × " + Math.round(r) + "px"
              }
            }, {
              key: "updatePosition",
              value: function(c, s) {
                var r = this.tip.getBoundingClientRect(),
                  bA = n0(c, s, {
                    width: r.width,
                    height: r.height
                  });
                v1(this.tip.style, bA.style)
              }
            }]), b
          }(),
          p0 = function() {
            function b(a) {
              jA(this, b);
              var c = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
              this.window = c;
              var s = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
              this.tipBoundsWindow = s;
              var r = c.document;
              this.container = r.createElement("div"), this.container.style.zIndex = "10000000", this.tip = new g0(r, this.container), this.rects = [], this.agent = a, r.body.appendChild(this.container)
            }
            return t1(b, [{
              key: "remove",
              value: function() {
                if (this.tip.remove(), this.rects.forEach(function(c) {
                    c.remove()
                  }), this.rects.length = 0, this.container.parentNode) this.container.parentNode.removeChild(this.container)
              }
            }, {
              key: "inspect",
              value: function(c, s) {
                var r = this,
                  bA = c.filter(function(ZQ) {
                    return ZQ.nodeType === Node.ELEMENT_NODE
                  });
                while (this.rects.length > bA.length) {
                  var Y1 = this.rects.pop();
                  Y1.remove()
                }
                if (bA.length === 0) return;
                while (this.rects.length < bA.length) this.rects.push(new F0(this.window.document, this.container));
                var B1 = {
                  top: Number.POSITIVE_INFINITY,
                  right: Number.NEGATIVE_INFINITY,
                  bottom: Number.NEGATIVE_INFINITY,
                  left: Number.POSITIVE_INFINITY
                };
                if (bA.forEach(function(ZQ, TQ) {
                    var M2 = J1(ZQ, r.window),
                      gQ = w1(ZQ);
                    B1.top = Math.min(B1.top, M2.top - gQ.marginTop), B1.right = Math.max(B1.right, M2.left + M2.width + gQ.marginRight), B1.bottom = Math.max(B1.bottom, M2.top + M2.height + gQ.marginBottom), B1.left = Math.min(B1.left, M2.left - gQ.marginLeft);
                    var W9 = r.rects[TQ];
                    W9.update(M2, gQ)
                  }), !s) {
                  s = bA[0].nodeName.toLowerCase();
                  var uA = bA[0],
                    z1 = this.agent.getBestMatchingRendererInterface(uA);
                  if (z1) {
                    var S1 = z1.getFiberIDForNative(uA, !0);
                    if (S1) {
                      var l1 = z1.getDisplayNameForFiberID(S1, !0);
                      if (l1) s += " (in " + l1 + ")"
                    }
                  }
                }
                this.tip.updateText(s, B1.right - B1.left, B1.bottom - B1.top);
                var n1 = J1(this.tipBoundsWindow.document.documentElement, this.window);
                this.tip.updatePosition({
                  top: B1.top,
                  left: B1.left,
                  height: B1.bottom - B1.top,
                  width: B1.right - B1.left
                }, {
                  top: n1.top + this.tipBoundsWindow.scrollY,
                  left: n1.left + this.tipBoundsWindow.scrollX,
                  height: this.tipBoundsWindow.innerHeight,
                  width: this.tipBoundsWindow.innerWidth
                })
              }
            }]), b
          }();

        function n0(b, a, c) {
          var s = Math.max(c.height, 20),
            r = Math.max(c.width, 60),
            bA = 5,
            Y1;
          if (b.top + b.height + s <= a.top + a.height)
            if (b.top + b.height < a.top + 0) Y1 = a.top + bA;
            else Y1 = b.top + b.height + bA;
          else if (b.top - s <= a.top + a.height)
            if (b.top - s - bA < a.top + bA) Y1 = a.top + bA;
            else Y1 = b.top - s - bA;
          else Y1 = a.top + a.height - s - bA;
          var B1 = b.left + bA;
          if (b.left < a.left) B1 = a.left + bA;
          if (b.left + r > a.left + a.width) B1 = a.left + a.width - r - bA;
          return Y1 += "px", B1 += "px", {
            style: {
              top: Y1,
              left: B1
            }
          }
        }

        function _1(b, a, c) {
          v1(c.style, {
            borderTopWidth: b[a + "Top"] + "px",
            borderLeftWidth: b[a + "Left"] + "px",
            borderRightWidth: b[a + "Right"] + "px",
            borderBottomWidth: b[a + "Bottom"] + "px",
            borderStyle: "solid"
          })
        }
        var zQ = {
            background: "rgba(120, 170, 210, 0.7)",
            padding: "rgba(77, 200, 0, 0.3)",
            margin: "rgba(255, 155, 0, 0.3)",
            border: "rgba(255, 200, 50, 0.3)"
          },
          W1 = 2000,
          O1 = null,
          a1 = null;

        function C0(b) {
          if (window.document == null) {
            b.emit("hideNativeHighlight");
            return
          }
          if (O1 = null, a1 !== null) a1.remove(), a1 = null
        }

        function v0(b, a, c, s) {
          if (window.document == null) {
            if (b != null && b[0] != null) c.emit("showNativeHighlight", b[0]);
            return
          }
          if (O1 !== null) clearTimeout(O1);
          if (b == null) return;
          if (a1 === null) a1 = new p0(c);
          if (a1.inspect(b, a), s) O1 = setTimeout(function() {
            return C0(c)
          }, W1)
        }
        var k0 = new Set;

        function f0(b, a) {
          b.addListener("clearNativeElementHighlight", Y1), b.addListener("highlightNativeElement", B1), b.addListener("shutdown", r), b.addListener("startInspectingNative", c), b.addListener("stopInspectingNative", r);

          function c() {
            s(window)
          }

          function s(gQ) {
            if (gQ && typeof gQ.addEventListener === "function") gQ.addEventListener("click", uA, !0), gQ.addEventListener("mousedown", z1, !0), gQ.addEventListener("mouseover", z1, !0), gQ.addEventListener("mouseup", z1, !0), gQ.addEventListener("pointerdown", S1, !0), gQ.addEventListener("pointermove", n1, !0), gQ.addEventListener("pointerup", ZQ, !0);
            else a.emit("startInspectingNative")
          }

          function r() {
            C0(a), bA(window), k0.forEach(function(gQ) {
              try {
                bA(gQ.contentWindow)
              } catch (W9) {}
            }), k0 = new Set
          }

          function bA(gQ) {
            if (gQ && typeof gQ.removeEventListener === "function") gQ.removeEventListener("click", uA, !0), gQ.removeEventListener("mousedown", z1, !0), gQ.removeEventListener("mouseover", z1, !0), gQ.removeEventListener("mouseup", z1, !0), gQ.removeEventListener("pointerdown", S1, !0), gQ.removeEventListener("pointermove", n1, !0), gQ.removeEventListener("pointerup", ZQ, !0);
            else a.emit("stopInspectingNative")
          }

          function Y1() {
            C0(a)
          }

          function B1(gQ) {
            var {
              displayName: W9,
              hideAfterTimeout: p4,
              id: g5,
              openNativeElementsPanel: kB,
              rendererID: U5,
              scrollIntoView: z7
            } = gQ, l4 = a.rendererInterfaces[U5];
            if (l4 == null) {
              console.warn('Invalid renderer id "'.concat(U5, '" for element "').concat(g5, '"')), C0(a);
              return
            }
            if (!l4.hasFiberWithId(g5)) {
              C0(a);
              return
            }
            var F8 = l4.findNativeNodesForFiberID(g5);
            if (F8 != null && F8[0] != null) {
              var L3 = F8[0];
              if (z7 && typeof L3.scrollIntoView === "function") L3.scrollIntoView({
                block: "nearest",
                inline: "nearest"
              });
              if (v0(F8, W9, a, p4), kB) window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = L3, b.send("syncSelectionToNativeElementsPanel")
            } else C0(a)
          }

          function uA(gQ) {
            gQ.preventDefault(), gQ.stopPropagation(), r(), b.send("stopInspectingNative", !0)
          }

          function z1(gQ) {
            gQ.preventDefault(), gQ.stopPropagation()
          }

          function S1(gQ) {
            gQ.preventDefault(), gQ.stopPropagation(), TQ(M2(gQ))
          }
          var l1 = null;

          function n1(gQ) {
            gQ.preventDefault(), gQ.stopPropagation();
            var W9 = M2(gQ);
            if (l1 === W9) return;
            if (l1 = W9, W9.tagName === "IFRAME") {
              var p4 = W9;
              try {
                if (!k0.has(p4)) {
                  var g5 = p4.contentWindow;
                  s(g5), k0.add(p4)
                }
              } catch (kB) {}
            }
            v0([W9], null, a, !1), TQ(W9)
          }

          function ZQ(gQ) {
            gQ.preventDefault(), gQ.stopPropagation()
          }
          var TQ = V()(DA(function(gQ) {
            var W9 = a.getIDForNode(gQ);
            if (W9 !== null) b.send("selectFiber", W9)
          }), 200, {
            leading: !1
          });

          function M2(gQ) {
            if (gQ.composed) return gQ.composedPath()[0];
            return gQ.target
          }
        }
        var G0 = "#f0f0f0",
          yQ = ["#37afa9", "#63b19e", "#80b393", "#97b488", "#abb67d", "#beb771", "#cfb965", "#dfba57", "#efbb49", "#febc38"],
          aQ = null;

        function sQ(b, a) {
          if (window.document == null) {
            var c = [];
            K0(b, function(bA, Y1, B1) {
              c.push({
                node: B1,
                color: Y1
              })
            }), a.emit("drawTraceUpdates", c);
            return
          }
          if (aQ === null) s8();
          var s = aQ;
          s.width = window.innerWidth, s.height = window.innerHeight;
          var r = s.getContext("2d");
          r.clearRect(0, 0, s.width, s.height), K0(b, function(bA, Y1) {
            if (bA !== null) mB(r, bA, Y1)
          })
        }

        function K0(b, a) {
          b.forEach(function(c, s) {
            var {
              count: r,
              rect: bA
            } = c, Y1 = Math.min(yQ.length - 1, r - 1), B1 = yQ[Y1];
            a(bA, B1, s)
          })
        }

        function mB(b, a, c) {
          var {
            height: s,
            left: r,
            top: bA,
            width: Y1
          } = a;
          b.lineWidth = 1, b.strokeStyle = G0, b.strokeRect(r - 1, bA - 1, Y1 + 2, s + 2), b.lineWidth = 1, b.strokeStyle = G0, b.strokeRect(r + 1, bA + 1, Y1 - 1, s - 1), b.strokeStyle = c, b.setLineDash([0]), b.lineWidth = 1, b.strokeRect(r, bA, Y1 - 1, s - 1), b.setLineDash([0])
        }

        function e2(b) {
          if (window.document == null) {
            b.emit("disableTraceUpdates");
            return
          }
          if (aQ !== null) {
            if (aQ.parentNode != null) aQ.parentNode.removeChild(aQ);
            aQ = null
          }
        }

        function s8() {
          aQ = window.document.createElement("canvas"), aQ.style.cssText = `
    xx-background-color: red;
    xx-opacity: 0.5;
    bottom: 0;
    left: 0;
    pointer-events: none;
    position: fixed;
    right: 0;
    top: 0;
    z-index: 1000000000;
  `;
          var b = window.document.documentElement;
          b.insertBefore(aQ, b.firstChild)
        }

        function K5(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") K5 = function(c) {
            return typeof c
          };
          else K5 = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return K5(b)
        }
        var g6 = 250,
          c3 = 3000,
          tZ = 250,
          H7 = (typeof performance > "u" ? "undefined" : K5(performance)) === "object" && typeof performance.now === "function" ? function() {
            return performance.now()
          } : function() {
            return Date.now()
          },
          H8 = new Map,
          r5 = null,
          nG = null,
          aG = !1,
          U1 = null;

        function sA(b) {
          r5 = b, r5.addListener("traceUpdates", M1)
        }

        function E1(b) {
          if (aG = b, !aG) {
            if (H8.clear(), nG !== null) cancelAnimationFrame(nG), nG = null;
            if (U1 !== null) clearTimeout(U1), U1 = null;
            e2(r5)
          }
        }

        function M1(b) {
          if (!aG) return;
          if (b.forEach(function(a) {
              var c = H8.get(a),
                s = H7(),
                r = c != null ? c.lastMeasuredAt : 0,
                bA = c != null ? c.rect : null;
              if (bA === null || r + tZ < s) r = s, bA = O0(a);
              H8.set(a, {
                count: c != null ? c.count + 1 : 1,
                expirationTime: c != null ? Math.min(s + c3, c.expirationTime + g6) : s + g6,
                lastMeasuredAt: r,
                rect: bA
              })
            }), U1 !== null) clearTimeout(U1), U1 = null;
          if (nG === null) nG = requestAnimationFrame(k1)
        }

        function k1() {
          nG = null, U1 = null;
          var b = H7(),
            a = Number.MAX_VALUE;
          if (H8.forEach(function(c, s) {
              if (c.expirationTime < b) H8.delete(s);
              else a = Math.min(a, c.expirationTime)
            }), sQ(H8, r5), a !== Number.MAX_VALUE) U1 = setTimeout(k1, a - b)
        }

        function O0(b) {
          if (!b || typeof b.getBoundingClientRect !== "function") return null;
          var a = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
          return J1(b, a)
        }

        function oQ(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") oQ = function(c) {
            return typeof c
          };
          else oQ = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return oQ(b)
        }

        function tB(b, a) {
          return $6(b) || r8(b, a) || Y6(b, a) || y9()
        }

        function y9() {
          throw TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function Y6(b, a) {
          if (!b) return;
          if (typeof b === "string") return u9(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return u9(b, a)
        }

        function u9(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }

        function r8(b, a) {
          if (typeof Symbol > "u" || !(Symbol.iterator in Object(b))) return;
          var c = [],
            s = !0,
            r = !1,
            bA = void 0;
          try {
            for (var Y1 = b[Symbol.iterator](), B1; !(s = (B1 = Y1.next()).done); s = !0)
              if (c.push(B1.value), a && c.length === a) break
          } catch (uA) {
            r = !0, bA = uA
          } finally {
            try {
              if (!s && Y1.return != null) Y1.return()
            } finally {
              if (r) throw bA
            }
          }
          return c
        }

        function $6(b) {
          if (Array.isArray(b)) return b
        }
        var T8 = function(a, c) {
            var s = w6(a),
              r = w6(c),
              bA = s.pop(),
              Y1 = r.pop(),
              B1 = Y8(s, r);
            if (B1 !== 0) return B1;
            if (bA && Y1) return Y8(bA.split("."), Y1.split("."));
            else if (bA || Y1) return bA ? -1 : 1;
            return 0
          },
          i9 = function(a) {
            return typeof a === "string" && /^[v\d]/.test(a) && QG.test(a)
          },
          J6 = function(a, c, s) {
            L4(s);
            var r = T8(a, c);
            return d4[s].includes(r)
          },
          N4 = function(a, c) {
            var s = c.match(/^([<>=~^]+)/),
              r = s ? s[1] : "=";
            if (r !== "^" && r !== "~") return J6(a, c, r);
            var bA = w6(a),
              Y1 = tB(bA, 5),
              B1 = Y1[0],
              uA = Y1[1],
              z1 = Y1[2],
              S1 = Y1[4],
              l1 = w6(c),
              n1 = tB(l1, 5),
              ZQ = n1[0],
              TQ = n1[1],
              M2 = n1[2],
              gQ = n1[4],
              W9 = [B1, uA, z1],
              p4 = [ZQ, TQ !== null && TQ !== void 0 ? TQ : "x", M2 !== null && M2 !== void 0 ? M2 : "x"];
            if (gQ) {
              if (!S1) return !1;
              if (Y8(W9, p4) !== 0) return !1;
              if (Y8(S1.split("."), gQ.split(".")) === -1) return !1
            }
            var g5 = p4.findIndex(function(U5) {
                return U5 !== "0"
              }) + 1,
              kB = r === "~" ? 2 : g5 > 1 ? g5 : 1;
            if (Y8(W9.slice(0, kB), p4.slice(0, kB)) !== 0) return !1;
            if (Y8(W9.slice(kB), p4.slice(kB)) === -1) return !1;
            return !0
          },
          QG = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i,
          w6 = function(a) {
            if (typeof a !== "string") throw TypeError("Invalid argument expected string");
            var c = a.match(QG);
            if (!c) throw Error("Invalid argument not valid semver ('".concat(a, "' received)"));
            return c.shift(), c
          },
          b5 = function(a) {
            return a === "*" || a === "x" || a === "X"
          },
          n9 = function(a) {
            var c = parseInt(a, 10);
            return isNaN(c) ? a : c
          },
          I8 = function(a, c) {
            return oQ(a) !== oQ(c) ? [String(a), String(c)] : [a, c]
          },
          f5 = function(a, c) {
            if (b5(a) || b5(c)) return 0;
            var s = I8(n9(a), n9(c)),
              r = tB(s, 2),
              bA = r[0],
              Y1 = r[1];
            if (bA > Y1) return 1;
            if (bA < Y1) return -1;
            return 0
          },
          Y8 = function(a, c) {
            for (var s = 0; s < Math.max(a.length, c.length); s++) {
              var r = f5(a[s] || "0", c[s] || "0");
              if (r !== 0) return r
            }
            return 0
          },
          d4 = {
            ">": [1],
            ">=": [0, 1],
            "=": [0],
            "<=": [-1, 0],
            "<": [-1]
          },
          a9 = Object.keys(d4),
          L4 = function(a) {
            if (typeof a !== "string") throw TypeError("Invalid operator type, expected string but got ".concat(oQ(a)));
            if (a9.indexOf(a) === -1) throw Error("Invalid operator, expected one of ".concat(a9.join("|")))
          },
          o5 = B(730),
          m9 = B.n(o5),
          d9 = B(550);

        function cA(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") cA = function(c) {
            return typeof c
          };
          else cA = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return cA(b)
        }
        var YA = Symbol.for("react.element"),
          ZA = Symbol.for("react.portal"),
          SA = Symbol.for("react.fragment"),
          xA = Symbol.for("react.strict_mode"),
          dA = Symbol.for("react.profiler"),
          C1 = Symbol.for("react.provider"),
          j1 = Symbol.for("react.context"),
          T1 = Symbol.for("react.server_context"),
          m1 = Symbol.for("react.forward_ref"),
          p1 = Symbol.for("react.suspense"),
          D0 = Symbol.for("react.suspense_list"),
          GQ = Symbol.for("react.memo"),
          lQ = Symbol.for("react.lazy"),
          lB = Symbol.for("react.scope"),
          iQ = Symbol.for("react.debug_trace_mode"),
          s2 = Symbol.for("react.offscreen"),
          P8 = Symbol.for("react.legacy_hidden"),
          C7 = Symbol.for("react.cache"),
          D5 = Symbol.for("react.tracing_marker"),
          AW = Symbol.for("react.default_value"),
          u6 = Symbol.for("react.memo_cache_sentinel"),
          QW = Symbol.for("react.postpone"),
          NY = Symbol.iterator,
          G4 = "@@iterator";

        function BJ(b) {
          if (b === null || cA(b) !== "object") return null;
          var a = NY && b[NY] || b[G4];
          if (typeof a === "function") return a;
          return null
        }
        var sG = 1,
          jK = 2,
          oW = 5,
          ZF = 6,
          q3 = 7,
          GJ = 8,
          BW = 9,
          DN = 10,
          x$ = 11,
          H5 = 12,
          M4 = 13,
          a0 = 14,
          eB = 1,
          IB = 2,
          $9 = 3,
          q6 = 4,
          C8 = 1,
          x4 = Array.isArray;
        let J8 = x4;
        var x9 = B(169);

        function T4(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") T4 = function(c) {
            return typeof c
          };
          else T4 = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return T4(b)
        }

        function N3(b) {
          return BG(b) || W8(b) || IF(b) || KV()
        }

        function KV() {
          throw TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function IF(b, a) {
          if (!b) return;
          if (typeof b === "string") return tW(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return tW(b, a)
        }

        function W8(b) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(b)) return Array.from(b)
        }

        function BG(b) {
          if (Array.isArray(b)) return tW(b)
        }

        function tW(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }
        var eW = Object.prototype.hasOwnProperty,
          AX = new WeakMap,
          C5 = new(m9())({
            max: 1000
          });

        function Wj(b, a) {
          if (b.toString() > a.toString()) return 1;
          else if (a.toString() > b.toString()) return -1;
          else return 0
        }

        function eZ(b) {
          var a = new Set,
            c = b,
            s = function() {
              var bA = [].concat(N3(Object.keys(c)), N3(Object.getOwnPropertySymbols(c))),
                Y1 = Object.getOwnPropertyDescriptors(c);
              bA.forEach(function(B1) {
                if (Y1[B1].enumerable) a.add(B1)
              }), c = Object.getPrototypeOf(c)
            };
          while (c != null) s();
          return a
        }

        function c2(b, a, c, s) {
          var r = b.displayName;
          return r || "".concat(c, "(").concat(m6(a, s), ")")
        }

        function m6(b) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Anonymous",
            c = AX.get(b);
          if (c != null) return c;
          var s = a;
          if (typeof b.displayName === "string") s = b.displayName;
          else if (typeof b.name === "string" && b.name !== "") s = b.name;
          return AX.set(b, s), s
        }
        var GG = 0;

        function p3() {
          return ++GG
        }

        function QX(b) {
          var a = "";
          for (var c = 0; c < b.length; c++) {
            var s = b[c];
            a += String.fromCodePoint(s)
          }
          return a
        }

        function LY(b, a) {
          return ((b & 1023) << 10) + (a & 1023) + 65536
        }

        function SK(b) {
          var a = C5.get(b);
          if (a !== void 0) return a;
          var c = [],
            s = 0,
            r;
          while (s < b.length) {
            if (r = b.charCodeAt(s), (r & 63488) === 55296) c.push(LY(r, b.charCodeAt(++s)));
            else c.push(r);
            ++s
          }
          return C5.set(b, c), c
        }

        function h5(b) {
          var a = b[0],
            c = b[1],
            s = ["operations for renderer:".concat(a, " and root:").concat(c)],
            r = 2,
            bA = [null],
            Y1 = b[r++],
            B1 = r + Y1;
          while (r < B1) {
            var uA = b[r++],
              z1 = QX(b.slice(r, r + uA));
            bA.push(z1), r += uA
          }
          while (r < b.length) {
            var S1 = b[r];
            switch (S1) {
              case E: {
                var l1 = b[r + 1],
                  n1 = b[r + 2];
                if (r += 3, n1 === x$) s.push("Add new root node ".concat(l1)), r++, r++, r++, r++;
                else {
                  var ZQ = b[r];
                  r++, r++;
                  var TQ = b[r],
                    M2 = bA[TQ];
                  r++, r++, s.push("Add node ".concat(l1, " (").concat(M2 || "null", ") as child of ").concat(ZQ))
                }
                break
              }
              case U: {
                var gQ = b[r + 1];
                r += 2;
                for (var W9 = 0; W9 < gQ; W9++) {
                  var p4 = b[r];
                  r += 1, s.push("Remove node ".concat(p4))
                }
                break
              }
              case R: {
                r += 1, s.push("Remove root ".concat(c));
                break
              }
              case T: {
                var g5 = b[r + 1],
                  kB = b[r + 1];
                r += 3, s.push("Mode ".concat(kB, " set for subtree with root ").concat(g5));
                break
              }
              case q: {
                var U5 = b[r + 1],
                  z7 = b[r + 2];
                r += 3;
                var l4 = b.slice(r, r + z7);
                r += z7, s.push("Re-order node ".concat(U5, " children ").concat(l4.join(",")));
                break
              }
              case w:
                r += 3;
                break;
              case N:
                var F8 = b[r + 1],
                  L3 = b[r + 2],
                  jY = b[r + 3];
                r += 4, s.push("Node ".concat(F8, " has ").concat(L3, " errors and ").concat(jY, " warnings"));
                break;
              default:
                throw Error('Unsupported Bridge operation "'.concat(S1, '"'))
            }
          }
          console.log(s.join(`
  `))
        }

        function MY() {
          return [{
            type: eB,
            value: q3,
            isEnabled: !0
          }]
        }

        function YF() {
          try {
            var b = localStorageGetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY);
            if (b != null) return JSON.parse(b)
          } catch (a) {}
          return MY()
        }

        function Xj(b) {
          localStorageSetItem(LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY, JSON.stringify(b))
        }

        function _K(b) {
          if (b === "true") return !0;
          if (b === "false") return !1
        }

        function GH(b) {
          if (b === !0 || b === !1) return b
        }

        function SC(b) {
          if (b === "light" || b === "dark" || b === "auto") return b
        }

        function Ju() {
          var b, a = localStorageGetItem(LOCAL_STORAGE_SHOULD_APPEND_COMPONENT_STACK_KEY);
          return (b = _K(a)) !== null && b !== void 0 ? b : !0
        }

        function va() {
          var b, a = localStorageGetItem(LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS);
          return (b = _K(a)) !== null && b !== void 0 ? b : !1
        }

        function HN() {
          var b, a = localStorageGetItem(LOCAL_STORAGE_HIDE_CONSOLE_LOGS_IN_STRICT_MODE);
          return (b = _K(a)) !== null && b !== void 0 ? b : !1
        }

        function CN() {
          var b, a = localStorageGetItem(LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY);
          return (b = _K(a)) !== null && b !== void 0 ? b : !0
        }

        function HA() {
          return typeof x9.env.EDITOR_URL === "string" ? x9.env.EDITOR_URL : ""
        }

        function LA() {
          try {
            var b = localStorageGetItem(LOCAL_STORAGE_OPEN_IN_EDITOR_URL);
            if (b != null) return JSON.parse(b)
          } catch (a) {}
          return HA()
        }

        function D1(b, a) {
          if (b === null) return [null, null];
          var c = null;
          switch (a) {
            case ElementTypeClass:
            case ElementTypeForwardRef:
            case ElementTypeFunction:
            case ElementTypeMemo:
              if (b.indexOf("(") >= 0) {
                var s = b.match(/[^()]+/g);
                if (s != null) b = s.pop(), c = s
              }
              break;
            default:
              break
          }
          return [b, c]
        }

        function I0(b, a) {
          for (var c in b)
            if (!(c in a)) return !0;
          for (var s in a)
            if (b[s] !== a[s]) return !0;
          return !1
        }

        function z0(b, a) {
          return a.reduce(function(c, s) {
            if (c) {
              if (eW.call(c, s)) return c[s];
              if (typeof c[Symbol.iterator] === "function") return Array.from(c)[s]
            }
            return null
          }, b)
        }

        function rQ(b, a) {
          var c = a.length,
            s = a[c - 1];
          if (b != null) {
            var r = z0(b, a.slice(0, c - 1));
            if (r)
              if (J8(r)) r.splice(s, 1);
              else delete r[s]
          }
        }

        function T2(b, a, c) {
          var s = a.length;
          if (b != null) {
            var r = z0(b, a.slice(0, s - 1));
            if (r) {
              var bA = a[s - 1],
                Y1 = c[s - 1];
              if (r[Y1] = r[bA], J8(r)) r.splice(bA, 1);
              else delete r[bA]
            }
          }
        }

        function s9(b, a, c) {
          var s = a.length,
            r = a[s - 1];
          if (b != null) {
            var bA = z0(b, a.slice(0, s - 1));
            if (bA) bA[r] = c
          }
        }

        function d6(b) {
          if (b === null) return "null";
          else if (b === void 0) return "undefined";
          if ((0, d9.isElement)(b)) return "react_element";
          if (typeof HTMLElement < "u" && b instanceof HTMLElement) return "html_element";
          var a = T4(b);
          switch (a) {
            case "bigint":
              return "bigint";
            case "boolean":
              return "boolean";
            case "function":
              return "function";
            case "number":
              if (Number.isNaN(b)) return "nan";
              else if (!Number.isFinite(b)) return "infinity";
              else return "number";
            case "object":
              if (J8(b)) return "array";
              else if (ArrayBuffer.isView(b)) return eW.call(b.constructor, "BYTES_PER_ELEMENT") ? "typed_array" : "data_view";
              else if (b.constructor && b.constructor.name === "ArrayBuffer") return "array_buffer";
              else if (typeof b[Symbol.iterator] === "function") {
                var c = b[Symbol.iterator]();
                if (!c);
                else return c === b ? "opaque_iterator" : "iterator"
              } else if (b.constructor && b.constructor.name === "RegExp") return "regexp";
              else {
                var s = Object.prototype.toString.call(b);
                if (s === "[object Date]") return "date";
                else if (s === "[object HTMLAllCollection]") return "html_all_collection"
              }
              if (!BX(b)) return "class_instance";
              return "object";
            case "string":
              return "string";
            case "symbol":
              return "symbol";
            case "undefined":
              if (Object.prototype.toString.call(b) === "[object HTMLAllCollection]") return "html_all_collection";
              return "undefined";
            default:
              return "unknown"
          }
        }

        function LZ(b) {
          var a = (0, d9.typeOf)(b);
          switch (a) {
            case d9.ContextConsumer:
              return "ContextConsumer";
            case d9.ContextProvider:
              return "ContextProvider";
            case d9.ForwardRef:
              return "ForwardRef";
            case d9.Fragment:
              return "Fragment";
            case d9.Lazy:
              return "Lazy";
            case d9.Memo:
              return "Memo";
            case d9.Portal:
              return "Portal";
            case d9.Profiler:
              return "Profiler";
            case d9.StrictMode:
              return "StrictMode";
            case d9.Suspense:
              return "Suspense";
            case D0:
              return "SuspenseList";
            case D5:
              return "TracingMarker";
            default:
              var c = b.type;
              if (typeof c === "string") return c;
              else if (typeof c === "function") return m6(c, "Anonymous");
              else if (c != null) return "NotImplementedInDevtools";
              else return "Element"
          }
        }
        var AI = 50;

        function o8(b) {
          var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : AI;
          if (b.length > a) return b.slice(0, a) + "…";
          else return b
        }

        function c4(b, a) {
          if (b != null && eW.call(b, E5.type)) return a ? b[E5.preview_long] : b[E5.preview_short];
          var c = d6(b);
          switch (c) {
            case "html_element":
              return "<".concat(o8(b.tagName.toLowerCase()), " />");
            case "function":
              return o8("ƒ ".concat(typeof b.name === "function" ? "" : b.name, "() {}"));
            case "string":
              return '"'.concat(b, '"');
            case "bigint":
              return o8(b.toString() + "n");
            case "regexp":
              return o8(b.toString());
            case "symbol":
              return o8(b.toString());
            case "react_element":
              return "<".concat(o8(LZ(b) || "Unknown"), " />");
            case "array_buffer":
              return "ArrayBuffer(".concat(b.byteLength, ")");
            case "data_view":
              return "DataView(".concat(b.buffer.byteLength, ")");
            case "array":
              if (a) {
                var s = "";
                for (var r = 0; r < b.length; r++) {
                  if (r > 0) s += ", ";
                  if (s += c4(b[r], !1), s.length > AI) break
                }
                return "[".concat(o8(s), "]")
              } else {
                var bA = eW.call(b, E5.size) ? b[E5.size] : b.length;
                return "Array(".concat(bA, ")")
              }
            case "typed_array":
              var Y1 = "".concat(b.constructor.name, "(").concat(b.length, ")");
              if (a) {
                var B1 = "";
                for (var uA = 0; uA < b.length; uA++) {
                  if (uA > 0) B1 += ", ";
                  if (B1 += b[uA], B1.length > AI) break
                }
                return "".concat(Y1, " [").concat(o8(B1), "]")
              } else return Y1;
            case "iterator":
              var z1 = b.constructor.name;
              if (a) {
                var S1 = Array.from(b),
                  l1 = "";
                for (var n1 = 0; n1 < S1.length; n1++) {
                  var ZQ = S1[n1];
                  if (n1 > 0) l1 += ", ";
                  if (J8(ZQ)) {
                    var TQ = c4(ZQ[0], !0),
                      M2 = c4(ZQ[1], !1);
                    l1 += "".concat(TQ, " => ").concat(M2)
                  } else l1 += c4(ZQ, !1);
                  if (l1.length > AI) break
                }
                return "".concat(z1, "(").concat(b.size, ") {").concat(o8(l1), "}")
              } else return "".concat(z1, "(").concat(b.size, ")");
            case "opaque_iterator":
              return b[Symbol.toStringTag];
            case "date":
              return b.toString();
            case "class_instance":
              return b.constructor.name;
            case "object":
              if (a) {
                var gQ = Array.from(eZ(b)).sort(Wj),
                  W9 = "";
                for (var p4 = 0; p4 < gQ.length; p4++) {
                  var g5 = gQ[p4];
                  if (p4 > 0) W9 += ", ";
                  if (W9 += "".concat(g5.toString(), ": ").concat(c4(b[g5], !1)), W9.length > AI) break
                }
                return "{".concat(o8(W9), "}")
              } else return "{…}";
            case "boolean":
            case "number":
            case "infinity":
            case "nan":
            case "null":
            case "undefined":
              return b;
            default:
              try {
                return o8(String(b))
              } catch (kB) {
                return "unserializable"
              }
          }
        }
        var BX = function(a) {
          var c = Object.getPrototypeOf(a);
          if (!c) return !0;
          var s = Object.getPrototypeOf(c);
          return !s
        };

        function JF(b, a) {
          var c = Object.keys(b);
          if (Object.getOwnPropertySymbols) {
            var s = Object.getOwnPropertySymbols(b);
            if (a) s = s.filter(function(r) {
              return Object.getOwnPropertyDescriptor(b, r).enumerable
            });
            c.push.apply(c, s)
          }
          return c
        }

        function DV(b) {
          for (var a = 1; a < arguments.length; a++) {
            var c = arguments[a] != null ? arguments[a] : {};
            if (a % 2) JF(Object(c), !0).forEach(function(s) {
              HV(b, s, c[s])
            });
            else if (Object.getOwnPropertyDescriptors) Object.defineProperties(b, Object.getOwnPropertyDescriptors(c));
            else JF(Object(c)).forEach(function(s) {
              Object.defineProperty(b, s, Object.getOwnPropertyDescriptor(c, s))
            })
          }
          return b
        }

        function HV(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }
        var E5 = {
            inspectable: Symbol("inspectable"),
            inspected: Symbol("inspected"),
            name: Symbol("name"),
            preview_long: Symbol("preview_long"),
            preview_short: Symbol("preview_short"),
            readonly: Symbol("readonly"),
            size: Symbol("size"),
            type: Symbol("type"),
            unserializable: Symbol("unserializable")
          },
          zx = 2;

        function kK(b, a, c, s, r) {
          s.push(r);
          var bA = {
            inspectable: a,
            type: b,
            preview_long: c4(c, !0),
            preview_short: c4(c, !1),
            name: !c.constructor || c.constructor.name === "Object" ? "" : c.constructor.name
          };
          if (b === "array" || b === "typed_array") bA.size = c.length;
          else if (b === "object") bA.size = Object.keys(c).length;
          if (b === "iterator" || b === "typed_array") bA.readonly = !0;
          return bA
        }

        function ZH(b, a, c, s, r) {
          var bA = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0,
            Y1 = d6(b),
            B1;
          switch (Y1) {
            case "html_element":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: b.tagName,
                type: Y1
              };
            case "function":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: typeof b.name === "function" || !b.name ? "function" : b.name,
                type: Y1
              };
            case "string":
              if (B1 = r(s), B1) return b;
              else return b.length <= 500 ? b : b.slice(0, 500) + "...";
            case "bigint":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: b.toString(),
                type: Y1
              };
            case "symbol":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: b.toString(),
                type: Y1
              };
            case "react_element":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: LZ(b) || "Unknown",
                type: Y1
              };
            case "array_buffer":
            case "data_view":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: Y1 === "data_view" ? "DataView" : "ArrayBuffer",
                size: b.byteLength,
                type: Y1
              };
            case "array":
              if (B1 = r(s), bA >= zx && !B1) return kK(Y1, !0, b, a, s);
              return b.map(function(l1, n1) {
                return ZH(l1, a, c, s.concat([n1]), r, B1 ? 1 : bA + 1)
              });
            case "html_all_collection":
            case "typed_array":
            case "iterator":
              if (B1 = r(s), bA >= zx && !B1) return kK(Y1, !0, b, a, s);
              else {
                var uA = {
                  unserializable: !0,
                  type: Y1,
                  readonly: !0,
                  size: Y1 === "typed_array" ? b.length : void 0,
                  preview_short: c4(b, !1),
                  preview_long: c4(b, !0),
                  name: !b.constructor || b.constructor.name === "Object" ? "" : b.constructor.name
                };
                return Array.from(b).forEach(function(l1, n1) {
                  return uA[n1] = ZH(l1, a, c, s.concat([n1]), r, B1 ? 1 : bA + 1)
                }), c.push(s), uA
              }
            case "opaque_iterator":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: b[Symbol.toStringTag],
                type: Y1
              };
            case "date":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: b.toString(),
                type: Y1
              };
            case "regexp":
              return a.push(s), {
                inspectable: !1,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: b.toString(),
                type: Y1
              };
            case "object":
              if (B1 = r(s), bA >= zx && !B1) return kK(Y1, !0, b, a, s);
              else {
                var z1 = {};
                return eZ(b).forEach(function(l1) {
                  var n1 = l1.toString();
                  z1[n1] = ZH(b[l1], a, c, s.concat([n1]), r, B1 ? 1 : bA + 1)
                }), z1
              }
            case "class_instance":
              if (B1 = r(s), bA >= zx && !B1) return kK(Y1, !0, b, a, s);
              var S1 = {
                unserializable: !0,
                type: Y1,
                readonly: !0,
                preview_short: c4(b, !1),
                preview_long: c4(b, !0),
                name: b.constructor.name
              };
              return eZ(b).forEach(function(l1) {
                var n1 = l1.toString();
                S1[n1] = ZH(b[l1], a, c, s.concat([n1]), r, B1 ? 1 : bA + 1)
              }), c.push(s), S1;
            case "infinity":
            case "nan":
            case "undefined":
              return a.push(s), {
                type: Y1
              };
            default:
              return b
          }
        }

        function aO(b, a, c, s) {
          var r = getInObject(b, c);
          if (r != null) {
            if (!r[E5.unserializable]) delete r[E5.inspectable], delete r[E5.inspected], delete r[E5.name], delete r[E5.preview_long], delete r[E5.preview_short], delete r[E5.readonly], delete r[E5.size], delete r[E5.type]
          }
          if (s !== null && a.unserializable.length > 0) {
            var bA = a.unserializable[0],
              Y1 = bA.length === c.length;
            for (var B1 = 0; B1 < c.length; B1++)
              if (c[B1] !== bA[B1]) {
                Y1 = !1;
                break
              } if (Y1) Dz(s, s)
          }
          setInObject(b, c, s)
        }

        function bVA(b, a, c) {
          return a.forEach(function(s) {
            var r = s.length,
              bA = s[r - 1],
              Y1 = getInObject(b, s.slice(0, r - 1));
            if (!Y1 || !Y1.hasOwnProperty(bA)) return;
            var B1 = Y1[bA];
            if (!B1) return;
            else if (B1.type === "infinity") Y1[bA] = 1 / 0;
            else if (B1.type === "nan") Y1[bA] = NaN;
            else if (B1.type === "undefined") Y1[bA] = void 0;
            else {
              var uA = {};
              uA[E5.inspectable] = !!B1.inspectable, uA[E5.inspected] = !1, uA[E5.name] = B1.name, uA[E5.preview_long] = B1.preview_long, uA[E5.preview_short] = B1.preview_short, uA[E5.size] = B1.size, uA[E5.readonly] = !!B1.readonly, uA[E5.type] = B1.type, Y1[bA] = uA
            }
          }), c.forEach(function(s) {
            var r = s.length,
              bA = s[r - 1],
              Y1 = getInObject(b, s.slice(0, r - 1));
            if (!Y1 || !Y1.hasOwnProperty(bA)) return;
            var B1 = Y1[bA],
              uA = DV({}, B1);
            Dz(uA, B1), Y1[bA] = uA
          }), b
        }

        function Dz(b, a) {
          var c;
          Object.defineProperties(b, (c = {}, HV(c, E5.inspected, {
            configurable: !0,
            enumerable: !1,
            value: !!a.inspected
          }), HV(c, E5.name, {
            configurable: !0,
            enumerable: !1,
            value: a.name
          }), HV(c, E5.preview_long, {
            configurable: !0,
            enumerable: !1,
            value: a.preview_long
          }), HV(c, E5.preview_short, {
            configurable: !0,
            enumerable: !1,
            value: a.preview_short
          }), HV(c, E5.size, {
            configurable: !0,
            enumerable: !1,
            value: a.size
          }), HV(c, E5.readonly, {
            configurable: !0,
            enumerable: !1,
            value: !!a.readonly
          }), HV(c, E5.type, {
            configurable: !0,
            enumerable: !1,
            value: a.type
          }), HV(c, E5.unserializable, {
            configurable: !0,
            enumerable: !1,
            value: !!a.unserializable
          }), c)), delete b.inspected, delete b.name, delete b.preview_long, delete b.preview_short, delete b.size, delete b.readonly, delete b.type, delete b.unserializable
        }
        var Hz = Array.isArray;

        function Ux(b) {
          return Hz(b)
        }
        let GX = Ux;

        function EN(b) {
          return Cz(b) || IH(b) || $x(b) || QBA()
        }

        function QBA() {
          throw TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function $x(b, a) {
          if (!b) return;
          if (typeof b === "string") return ZJ(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return ZJ(b, a)
        }

        function IH(b) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(b)) return Array.from(b)
        }

        function Cz(b) {
          if (Array.isArray(b)) return ZJ(b)
        }

        function ZJ(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }

        function CV(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") CV = function(c) {
            return typeof c
          };
          else CV = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return CV(b)
        }

        function Wu(b, a) {
          var c = Object.keys(b);
          if (Object.getOwnPropertySymbols) {
            var s = Object.getOwnPropertySymbols(b);
            if (a) s = s.filter(function(r) {
              return Object.getOwnPropertyDescriptor(b, r).enumerable
            });
            c.push.apply(c, s)
          }
          return c
        }

        function zN(b) {
          for (var a = 1; a < arguments.length; a++) {
            var c = arguments[a] != null ? arguments[a] : {};
            if (a % 2) Wu(Object(c), !0).forEach(function(s) {
              BBA(b, s, c[s])
            });
            else if (Object.getOwnPropertyDescriptors) Object.defineProperties(b, Object.getOwnPropertyDescriptors(c));
            else Wu(Object(c)).forEach(function(s) {
              Object.defineProperty(b, s, Object.getOwnPropertyDescriptor(c, s))
            })
          }
          return b
        }

        function BBA(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }
        var ba = "999.9.9";

        function rG(b) {
          if (b == null || b === "") return !1;
          return _C(b, ba)
        }

        function IJ(b, a) {
          var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          if (b !== null) {
            var s = [],
              r = [],
              bA = ZH(b, s, r, c, a);
            return {
              data: bA,
              cleaned: s,
              unserializable: r
            }
          } else return null
        }

        function d1(b, a) {
          var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
            s = a[c],
            r = GX(b) ? b.slice() : zN({}, b);
          if (c + 1 === a.length)
            if (GX(r)) r.splice(s, 1);
            else delete r[s];
          else r[s] = d1(b[s], a, c + 1);
          return r
        }

        function P0(b, a, c) {
          var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
            r = a[s],
            bA = GX(b) ? b.slice() : zN({}, b);
          if (s + 1 === a.length) {
            var Y1 = c[s];
            if (bA[Y1] = bA[r], GX(bA)) bA.splice(r, 1);
            else delete bA[r]
          } else bA[r] = P0(b[r], a, c, s + 1);
          return bA
        }

        function U0(b, a, c) {
          var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          if (s >= a.length) return c;
          var r = a[s],
            bA = GX(b) ? b.slice() : zN({}, b);
          return bA[r] = U0(b[r], a, c, s + 1), bA
        }

        function _B(b) {
          var a = null,
            c = null,
            s = b.current;
          if (s != null) {
            var r = s.stateNode;
            if (r != null) a = r.effectDuration != null ? r.effectDuration : null, c = r.passiveEffectDuration != null ? r.passiveEffectDuration : null
          }
          return {
            effectDuration: a,
            passiveEffectDuration: c
          }
        }

        function w9(b) {
          if (b === void 0) return "undefined";
          var a = new Set;
          return JSON.stringify(b, function(c, s) {
            if (CV(s) === "object" && s !== null) {
              if (a.has(s)) return;
              a.add(s)
            }
            if (typeof s === "bigint") return s.toString() + "n";
            return s
          }, 2)
        }

        function Y9(b, a) {
          if (b === void 0 || b === null || b.length === 0 || typeof b[0] === "string" && b[0].match(/([^%]|^)(%c)/g) || a === void 0) return b;
          var c = /([^%]|^)((%%)*)(%([oOdisf]))/g;
          if (typeof b[0] === "string" && b[0].match(c)) return ["%c".concat(b[0]), a].concat(EN(b.slice(1)));
          else {
            var s = b.reduce(function(r, bA, Y1) {
              if (Y1 > 0) r += " ";
              switch (CV(bA)) {
                case "string":
                case "boolean":
                case "symbol":
                  return r += "%s";
                case "number":
                  var B1 = Number.isInteger(bA) ? "%i" : "%f";
                  return r += B1;
                default:
                  return r += "%o"
              }
            }, "%c");
            return [s, a].concat(EN(b))
          }
        }

        function j8(b) {
          for (var a = arguments.length, c = Array(a > 1 ? a - 1 : 0), s = 1; s < a; s++) c[s - 1] = arguments[s];
          var r = c.slice(),
            bA = String(b);
          if (typeof b === "string") {
            if (r.length) {
              var Y1 = /(%?)(%([jds]))/g;
              bA = bA.replace(Y1, function(uA, z1, S1, l1) {
                var n1 = r.shift();
                switch (l1) {
                  case "s":
                    n1 += "";
                    break;
                  case "d":
                  case "i":
                    n1 = parseInt(n1, 10).toString();
                    break;
                  case "f":
                    n1 = parseFloat(n1).toString();
                    break
                }
                if (!z1) return n1;
                return r.unshift(n1), uA
              })
            }
          }
          if (r.length)
            for (var B1 = 0; B1 < r.length; B1++) bA += " " + String(r[B1]);
          return bA = bA.replace(/%{2,2}/g, "%"), String(bA)
        }

        function O4() {
          return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature("sync-xhr"))
        }

        function sO() {
          var b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
            a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return T8(b, a) === 1
        }

        function _C() {
          var b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
            a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return T8(b, a) > -1
        }
        var ZX = B(987),
          Vj = 60111,
          YJ = "Symbol(react.concurrent_mode)",
          Ez = 60110,
          UN = "Symbol(react.context)",
          Fj = "Symbol(react.server_context)",
          X8 = "Symbol(react.async_mode)",
          kC = 60103,
          wx = "Symbol(react.element)",
          qx = 60129,
          GBA = "Symbol(react.debug_trace_mode)",
          ZBA = 60112,
          IBA = "Symbol(react.forward_ref)",
          Xu = 60107,
          $N = "Symbol(react.fragment)",
          Vu = 60116,
          YBA = "Symbol(react.lazy)",
          Nx = 60115,
          fa = "Symbol(react.memo)",
          Lx = 60106,
          Fu = "Symbol(react.portal)",
          Kj = 60114,
          v$ = "Symbol(react.profiler)",
          zz = 60109,
          wN = "Symbol(react.provider)",
          JBA = 60119,
          WBA = "Symbol(react.scope)",
          Ku = 60108,
          rO = "Symbol(react.strict_mode)",
          Mx = 60113,
          ha = "Symbol(react.suspense)",
          fVA = 60120,
          XBA = "Symbol(react.suspense_list)",
          sSA = "Symbol(react.server_context.defaultValue)",
          ga = !1,
          JJ = !1,
          IX = !1,
          hVA = !1;

        function VBA(b, a) {
          return b === a && (b !== 0 || 1 / b === 1 / a) || b !== b && a !== a
        }
        var ua = typeof Object.is === "function" ? Object.is : VBA;
        let Du = ua;
        var ma = Object.prototype.hasOwnProperty;
        let Ox = ma;
        var Rx = new Map;

        function YX(b) {
          var a = new Set,
            c = {};
          return b$(b, a, c), {
            sources: Array.from(a).sort(),
            resolvedStyles: c
          }
        }

        function b$(b, a, c) {
          if (b == null) return;
          if (J8(b)) b.forEach(function(s) {
            if (s == null) return;
            if (J8(s)) b$(s, a, c);
            else f$(s, a, c)
          });
          else f$(b, a, c);
          c = Object.fromEntries(Object.entries(c).sort())
        }

        function f$(b, a, c) {
          var s = Object.keys(b);
          s.forEach(function(r) {
            var bA = b[r];
            if (typeof bA === "string")
              if (r === bA) a.add(r);
              else {
                var Y1 = Tx(bA);
                if (Y1 != null) c[r] = Y1
              }
            else {
              var B1 = {};
              c[r] = B1, b$([bA], a, B1)
            }
          })
        }

        function Tx(b) {
          if (Rx.has(b)) return Rx.get(b);
          for (var a = 0; a < document.styleSheets.length; a++) {
            var c = document.styleSheets[a],
              s = null;
            try {
              s = c.cssRules
            } catch (n1) {
              continue
            }
            for (var r = 0; r < s.length; r++) {
              if (!(s[r] instanceof CSSStyleRule)) continue;
              var bA = s[r],
                Y1 = bA.cssText,
                B1 = bA.selectorText,
                uA = bA.style;
              if (B1 != null) {
                if (B1.startsWith(".".concat(b))) {
                  var z1 = Y1.match(/{ *([a-z\-]+):/);
                  if (z1 !== null) {
                    var S1 = z1[1],
                      l1 = uA.getPropertyValue(S1);
                    return Rx.set(b, l1), l1
                  } else return null
                }
              }
            }
          }
          return null
        }
        var Dj = "https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md",
          gVA = "https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back",
          FBA = "https://fburl.com/react-devtools-workplace-group",
          oO = {
            light: {
              "--color-attribute-name": "#ef6632",
              "--color-attribute-name-not-editable": "#23272f",
              "--color-attribute-name-inverted": "rgba(255, 255, 255, 0.7)",
              "--color-attribute-value": "#1a1aa6",
              "--color-attribute-value-inverted": "#ffffff",
              "--color-attribute-editable-value": "#1a1aa6",
              "--color-background": "#ffffff",
              "--color-background-hover": "rgba(0, 136, 250, 0.1)",
              "--color-background-inactive": "#e5e5e5",
              "--color-background-invalid": "#fff0f0",
              "--color-background-selected": "#0088fa",
              "--color-button-background": "#ffffff",
              "--color-button-background-focus": "#ededed",
              "--color-button": "#5f6673",
              "--color-button-disabled": "#cfd1d5",
              "--color-button-active": "#0088fa",
              "--color-button-focus": "#23272f",
              "--color-button-hover": "#23272f",
              "--color-border": "#eeeeee",
              "--color-commit-did-not-render-fill": "#cfd1d5",
              "--color-commit-did-not-render-fill-text": "#000000",
              "--color-commit-did-not-render-pattern": "#cfd1d5",
              "--color-commit-did-not-render-pattern-text": "#333333",
              "--color-commit-gradient-0": "#37afa9",
              "--color-commit-gradient-1": "#63b19e",
              "--color-commit-gradient-2": "#80b393",
              "--color-commit-gradient-3": "#97b488",
              "--color-commit-gradient-4": "#abb67d",
              "--color-commit-gradient-5": "#beb771",
              "--color-commit-gradient-6": "#cfb965",
              "--color-commit-gradient-7": "#dfba57",
              "--color-commit-gradient-8": "#efbb49",
              "--color-commit-gradient-9": "#febc38",
              "--color-commit-gradient-text": "#000000",
              "--color-component-name": "#6a51b2",
              "--color-component-name-inverted": "#ffffff",
              "--color-component-badge-background": "rgba(0, 0, 0, 0.1)",
              "--color-component-badge-background-inverted": "rgba(255, 255, 255, 0.25)",
              "--color-component-badge-count": "#777d88",
              "--color-component-badge-count-inverted": "rgba(255, 255, 255, 0.7)",
              "--color-console-error-badge-text": "#ffffff",
              "--color-console-error-background": "#fff0f0",
              "--color-console-error-border": "#ffd6d6",
              "--color-console-error-icon": "#eb3941",
              "--color-console-error-text": "#fe2e31",
              "--color-console-warning-badge-text": "#000000",
              "--color-console-warning-background": "#fffbe5",
              "--color-console-warning-border": "#fff5c1",
              "--color-console-warning-icon": "#f4bd00",
              "--color-console-warning-text": "#64460c",
              "--color-context-background": "rgba(0,0,0,.9)",
              "--color-context-background-hover": "rgba(255, 255, 255, 0.1)",
              "--color-context-background-selected": "#178fb9",
              "--color-context-border": "#3d424a",
              "--color-context-text": "#ffffff",
              "--color-context-text-selected": "#ffffff",
              "--color-dim": "#777d88",
              "--color-dimmer": "#cfd1d5",
              "--color-dimmest": "#eff0f1",
              "--color-error-background": "hsl(0, 100%, 97%)",
              "--color-error-border": "hsl(0, 100%, 92%)",
              "--color-error-text": "#ff0000",
              "--color-expand-collapse-toggle": "#777d88",
              "--color-link": "#0000ff",
              "--color-modal-background": "rgba(255, 255, 255, 0.75)",
              "--color-bridge-version-npm-background": "#eff0f1",
              "--color-bridge-version-npm-text": "#000000",
              "--color-bridge-version-number": "#0088fa",
              "--color-primitive-hook-badge-background": "#e5e5e5",
              "--color-primitive-hook-badge-text": "#5f6673",
              "--color-record-active": "#fc3a4b",
              "--color-record-hover": "#3578e5",
              "--color-record-inactive": "#0088fa",
              "--color-resize-bar": "#eeeeee",
              "--color-resize-bar-active": "#dcdcdc",
              "--color-resize-bar-border": "#d1d1d1",
              "--color-resize-bar-dot": "#333333",
              "--color-timeline-internal-module": "#d1d1d1",
              "--color-timeline-internal-module-hover": "#c9c9c9",
              "--color-timeline-internal-module-text": "#444",
              "--color-timeline-native-event": "#ccc",
              "--color-timeline-native-event-hover": "#aaa",
              "--color-timeline-network-primary": "#fcf3dc",
              "--color-timeline-network-primary-hover": "#f0e7d1",
              "--color-timeline-network-secondary": "#efc457",
              "--color-timeline-network-secondary-hover": "#e3ba52",
              "--color-timeline-priority-background": "#f6f6f6",
              "--color-timeline-priority-border": "#eeeeee",
              "--color-timeline-user-timing": "#c9cacd",
              "--color-timeline-user-timing-hover": "#93959a",
              "--color-timeline-react-idle": "#d3e5f6",
              "--color-timeline-react-idle-hover": "#c3d9ef",
              "--color-timeline-react-render": "#9fc3f3",
              "--color-timeline-react-render-hover": "#83afe9",
              "--color-timeline-react-render-text": "#11365e",
              "--color-timeline-react-commit": "#c88ff0",
              "--color-timeline-react-commit-hover": "#b281d6",
              "--color-timeline-react-commit-text": "#3e2c4a",
              "--color-timeline-react-layout-effects": "#b281d6",
              "--color-timeline-react-layout-effects-hover": "#9d71bd",
              "--color-timeline-react-layout-effects-text": "#3e2c4a",
              "--color-timeline-react-passive-effects": "#b281d6",
              "--color-timeline-react-passive-effects-hover": "#9d71bd",
              "--color-timeline-react-passive-effects-text": "#3e2c4a",
              "--color-timeline-react-schedule": "#9fc3f3",
              "--color-timeline-react-schedule-hover": "#2683E2",
              "--color-timeline-react-suspense-rejected": "#f1cc14",
              "--color-timeline-react-suspense-rejected-hover": "#ffdf37",
              "--color-timeline-react-suspense-resolved": "#a6e59f",
              "--color-timeline-react-suspense-resolved-hover": "#89d281",
              "--color-timeline-react-suspense-unresolved": "#c9cacd",
              "--color-timeline-react-suspense-unresolved-hover": "#93959a",
              "--color-timeline-thrown-error": "#ee1638",
              "--color-timeline-thrown-error-hover": "#da1030",
              "--color-timeline-text-color": "#000000",
              "--color-timeline-text-dim-color": "#ccc",
              "--color-timeline-react-work-border": "#eeeeee",
              "--color-search-match": "yellow",
              "--color-search-match-current": "#f7923b",
              "--color-selected-tree-highlight-active": "rgba(0, 136, 250, 0.1)",
              "--color-selected-tree-highlight-inactive": "rgba(0, 0, 0, 0.05)",
              "--color-scroll-caret": "rgba(150, 150, 150, 0.5)",
              "--color-tab-selected-border": "#0088fa",
              "--color-text": "#000000",
              "--color-text-invalid": "#ff0000",
              "--color-text-selected": "#ffffff",
              "--color-toggle-background-invalid": "#fc3a4b",
              "--color-toggle-background-on": "#0088fa",
              "--color-toggle-background-off": "#cfd1d5",
              "--color-toggle-text": "#ffffff",
              "--color-warning-background": "#fb3655",
              "--color-warning-background-hover": "#f82042",
              "--color-warning-text-color": "#ffffff",
              "--color-warning-text-color-inverted": "#fd4d69",
              "--color-scroll-thumb": "#c2c2c2",
              "--color-scroll-track": "#fafafa",
              "--color-tooltip-background": "rgba(0, 0, 0, 0.9)",
              "--color-tooltip-text": "#ffffff"
            },
            dark: {
              "--color-attribute-name": "#9d87d2",
              "--color-attribute-name-not-editable": "#ededed",
              "--color-attribute-name-inverted": "#282828",
              "--color-attribute-value": "#cedae0",
              "--color-attribute-value-inverted": "#ffffff",
              "--color-attribute-editable-value": "yellow",
              "--color-background": "#282c34",
              "--color-background-hover": "rgba(255, 255, 255, 0.1)",
              "--color-background-inactive": "#3d424a",
              "--color-background-invalid": "#5c0000",
              "--color-background-selected": "#178fb9",
              "--color-button-background": "#282c34",
              "--color-button-background-focus": "#3d424a",
              "--color-button": "#afb3b9",
              "--color-button-active": "#61dafb",
              "--color-button-disabled": "#4f5766",
              "--color-button-focus": "#a2e9fc",
              "--color-button-hover": "#ededed",
              "--color-border": "#3d424a",
              "--color-commit-did-not-render-fill": "#777d88",
              "--color-commit-did-not-render-fill-text": "#000000",
              "--color-commit-did-not-render-pattern": "#666c77",
              "--color-commit-did-not-render-pattern-text": "#ffffff",
              "--color-commit-gradient-0": "#37afa9",
              "--color-commit-gradient-1": "#63b19e",
              "--color-commit-gradient-2": "#80b393",
              "--color-commit-gradient-3": "#97b488",
              "--color-commit-gradient-4": "#abb67d",
              "--color-commit-gradient-5": "#beb771",
              "--color-commit-gradient-6": "#cfb965",
              "--color-commit-gradient-7": "#dfba57",
              "--color-commit-gradient-8": "#efbb49",
              "--color-commit-gradient-9": "#febc38",
              "--color-commit-gradient-text": "#000000",
              "--color-component-name": "#61dafb",
              "--color-component-name-inverted": "#282828",
              "--color-component-badge-background": "rgba(255, 255, 255, 0.25)",
              "--color-component-badge-background-inverted": "rgba(0, 0, 0, 0.25)",
              "--color-component-badge-count": "#8f949d",
              "--color-component-badge-count-inverted": "rgba(255, 255, 255, 0.7)",
              "--color-console-error-badge-text": "#000000",
              "--color-console-error-background": "#290000",
              "--color-console-error-border": "#5c0000",
              "--color-console-error-icon": "#eb3941",
              "--color-console-error-text": "#fc7f7f",
              "--color-console-warning-badge-text": "#000000",
              "--color-console-warning-background": "#332b00",
              "--color-console-warning-border": "#665500",
              "--color-console-warning-icon": "#f4bd00",
              "--color-console-warning-text": "#f5f2ed",
              "--color-context-background": "rgba(255,255,255,.95)",
              "--color-context-background-hover": "rgba(0, 136, 250, 0.1)",
              "--color-context-background-selected": "#0088fa",
              "--color-context-border": "#eeeeee",
              "--color-context-text": "#000000",
              "--color-context-text-selected": "#ffffff",
              "--color-dim": "#8f949d",
              "--color-dimmer": "#777d88",
              "--color-dimmest": "#4f5766",
              "--color-error-background": "#200",
              "--color-error-border": "#900",
              "--color-error-text": "#f55",
              "--color-expand-collapse-toggle": "#8f949d",
              "--color-link": "#61dafb",
              "--color-modal-background": "rgba(0, 0, 0, 0.75)",
              "--color-bridge-version-npm-background": "rgba(0, 0, 0, 0.25)",
              "--color-bridge-version-npm-text": "#ffffff",
              "--color-bridge-version-number": "yellow",
              "--color-primitive-hook-badge-background": "rgba(0, 0, 0, 0.25)",
              "--color-primitive-hook-badge-text": "rgba(255, 255, 255, 0.7)",
              "--color-record-active": "#fc3a4b",
              "--color-record-hover": "#a2e9fc",
              "--color-record-inactive": "#61dafb",
              "--color-resize-bar": "#282c34",
              "--color-resize-bar-active": "#31363f",
              "--color-resize-bar-border": "#3d424a",
              "--color-resize-bar-dot": "#cfd1d5",
              "--color-timeline-internal-module": "#303542",
              "--color-timeline-internal-module-hover": "#363b4a",
              "--color-timeline-internal-module-text": "#7f8899",
              "--color-timeline-native-event": "#b2b2b2",
              "--color-timeline-native-event-hover": "#949494",
              "--color-timeline-network-primary": "#fcf3dc",
              "--color-timeline-network-primary-hover": "#e3dbc5",
              "--color-timeline-network-secondary": "#efc457",
              "--color-timeline-network-secondary-hover": "#d6af4d",
              "--color-timeline-priority-background": "#1d2129",
              "--color-timeline-priority-border": "#282c34",
              "--color-timeline-user-timing": "#c9cacd",
              "--color-timeline-user-timing-hover": "#93959a",
              "--color-timeline-react-idle": "#3d485b",
              "--color-timeline-react-idle-hover": "#465269",
              "--color-timeline-react-render": "#2683E2",
              "--color-timeline-react-render-hover": "#1a76d4",
              "--color-timeline-react-render-text": "#11365e",
              "--color-timeline-react-commit": "#731fad",
              "--color-timeline-react-commit-hover": "#611b94",
              "--color-timeline-react-commit-text": "#e5c1ff",
              "--color-timeline-react-layout-effects": "#611b94",
              "--color-timeline-react-layout-effects-hover": "#51167a",
              "--color-timeline-react-layout-effects-text": "#e5c1ff",
              "--color-timeline-react-passive-effects": "#611b94",
              "--color-timeline-react-passive-effects-hover": "#51167a",
              "--color-timeline-react-passive-effects-text": "#e5c1ff",
              "--color-timeline-react-schedule": "#2683E2",
              "--color-timeline-react-schedule-hover": "#1a76d4",
              "--color-timeline-react-suspense-rejected": "#f1cc14",
              "--color-timeline-react-suspense-rejected-hover": "#e4c00f",
              "--color-timeline-react-suspense-resolved": "#a6e59f",
              "--color-timeline-react-suspense-resolved-hover": "#89d281",
              "--color-timeline-react-suspense-unresolved": "#c9cacd",
              "--color-timeline-react-suspense-unresolved-hover": "#93959a",
              "--color-timeline-thrown-error": "#fb3655",
              "--color-timeline-thrown-error-hover": "#f82042",
              "--color-timeline-text-color": "#282c34",
              "--color-timeline-text-dim-color": "#555b66",
              "--color-timeline-react-work-border": "#3d424a",
              "--color-search-match": "yellow",
              "--color-search-match-current": "#f7923b",
              "--color-selected-tree-highlight-active": "rgba(23, 143, 185, 0.15)",
              "--color-selected-tree-highlight-inactive": "rgba(255, 255, 255, 0.05)",
              "--color-scroll-caret": "#4f5766",
              "--color-shadow": "rgba(0, 0, 0, 0.5)",
              "--color-tab-selected-border": "#178fb9",
              "--color-text": "#ffffff",
              "--color-text-invalid": "#ff8080",
              "--color-text-selected": "#ffffff",
              "--color-toggle-background-invalid": "#fc3a4b",
              "--color-toggle-background-on": "#178fb9",
              "--color-toggle-background-off": "#777d88",
              "--color-toggle-text": "#ffffff",
              "--color-warning-background": "#ee1638",
              "--color-warning-background-hover": "#da1030",
              "--color-warning-text-color": "#ffffff",
              "--color-warning-text-color-inverted": "#ee1638",
              "--color-scroll-thumb": "#afb3b9",
              "--color-scroll-track": "#313640",
              "--color-tooltip-background": "rgba(255, 255, 255, 0.95)",
              "--color-tooltip-text": "#000000"
            },
            compact: {
              "--font-size-monospace-small": "9px",
              "--font-size-monospace-normal": "11px",
              "--font-size-monospace-large": "15px",
              "--font-size-sans-small": "10px",
              "--font-size-sans-normal": "12px",
              "--font-size-sans-large": "14px",
              "--line-height-data": "18px"
            },
            comfortable: {
              "--font-size-monospace-small": "10px",
              "--font-size-monospace-normal": "13px",
              "--font-size-monospace-large": "17px",
              "--font-size-sans-small": "12px",
              "--font-size-sans-normal": "14px",
              "--font-size-sans-large": "16px",
              "--line-height-data": "22px"
            }
          },
          KBA = parseInt(oO.comfortable["--line-height-data"], 10),
          DBA = parseInt(oO.compact["--line-height-data"], 10),
          Px = 31,
          Hj = 1,
          HBA = 60;

        function nA(b, a) {
          var c = Object.keys(b);
          if (Object.getOwnPropertySymbols) {
            var s = Object.getOwnPropertySymbols(b);
            if (a) s = s.filter(function(r) {
              return Object.getOwnPropertyDescriptor(b, r).enumerable
            });
            c.push.apply(c, s)
          }
          return c
        }

        function PI(b) {
          for (var a = 1; a < arguments.length; a++) {
            var c = arguments[a] != null ? arguments[a] : {};
            if (a % 2) nA(Object(c), !0).forEach(function(s) {
              jx(b, s, c[s])
            });
            else if (Object.getOwnPropertyDescriptors) Object.defineProperties(b, Object.getOwnPropertyDescriptors(c));
            else nA(Object(c)).forEach(function(s) {
              Object.defineProperty(b, s, Object.getOwnPropertyDescriptor(c, s))
            })
          }
          return b
        }

        function jx(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }
        var JX = 0,
          O9, WX, da, ca, h$, pa, la;

        function Hu() {}
        Hu.__reactDisabledLog = !0;

        function CBA() {
          if (JX === 0) {
            O9 = console.log, WX = console.info, da = console.warn, ca = console.error, h$ = console.group, pa = console.groupCollapsed, la = console.groupEnd;
            var b = {
              configurable: !0,
              enumerable: !0,
              value: Hu,
              writable: !0
            };
            Object.defineProperties(console, {
              info: b,
              log: b,
              warn: b,
              error: b,
              group: b,
              groupCollapsed: b,
              groupEnd: b
            })
          }
          JX++
        }

        function ia() {
          if (JX--, JX === 0) {
            var b = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: PI(PI({}, b), {}, {
                value: O9
              }),
              info: PI(PI({}, b), {}, {
                value: WX
              }),
              warn: PI(PI({}, b), {}, {
                value: da
              }),
              error: PI(PI({}, b), {}, {
                value: ca
              }),
              group: PI(PI({}, b), {}, {
                value: h$
              }),
              groupCollapsed: PI(PI({}, b), {}, {
                value: pa
              }),
              groupEnd: PI(PI({}, b), {}, {
                value: la
              })
            })
          }
          if (JX < 0) console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")
        }

        function WF(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") WF = function(c) {
            return typeof c
          };
          else WF = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return WF(b)
        }
        var Cu;

        function Uz(b, a) {
          if (Cu === void 0) try {
            throw Error()
          } catch (s) {
            var c = s.stack.trim().match(/\n( *(at )?)/);
            Cu = c && c[1] || ""
          }
          return `
` + Cu + b
        }
        var Sx = !1,
          uVA;
        if (!1) var EBA;

        function XF(b, a, c) {
          if (!b || Sx) return "";
          if (!1) var s;
          var r, bA = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0, Sx = !0;
          var Y1 = c.current;
          c.current = null, CBA();
          try {
            if (a) {
              var B1 = function() {
                throw Error()
              };
              if (Object.defineProperty(B1.prototype, "props", {
                  set: function() {
                    throw Error()
                  }
                }), (typeof Reflect > "u" ? "undefined" : WF(Reflect)) === "object" && Reflect.construct) {
                try {
                  Reflect.construct(B1, [])
                } catch (M2) {
                  r = M2
                }
                Reflect.construct(b, [], B1)
              } else {
                try {
                  B1.call()
                } catch (M2) {
                  r = M2
                }
                b.call(B1.prototype)
              }
            } else {
              try {
                throw Error()
              } catch (M2) {
                r = M2
              }
              b()
            }
          } catch (M2) {
            if (M2 && r && typeof M2.stack === "string") {
              var uA = M2.stack.split(`
`),
                z1 = r.stack.split(`
`),
                S1 = uA.length - 1,
                l1 = z1.length - 1;
              while (S1 >= 1 && l1 >= 0 && uA[S1] !== z1[l1]) l1--;
              for (; S1 >= 1 && l1 >= 0; S1--, l1--)
                if (uA[S1] !== z1[l1]) {
                  if (S1 !== 1 || l1 !== 1)
                    do
                      if (S1--, l1--, l1 < 0 || uA[S1] !== z1[l1]) {
                        var n1 = `
` + uA[S1].replace(" at new ", " at ");
                        return n1
                      } while (S1 >= 1 && l1 >= 0);
                  break
                }
            }
          } finally {
            Sx = !1, Error.prepareStackTrace = bA, c.current = Y1, ia()
          }
          var ZQ = b ? b.displayName || b.name : "",
            TQ = ZQ ? Uz(ZQ) : "";
          return TQ
        }

        function mVA(b, a, c) {
          return XF(b, !0, c)
        }

        function Eu(b, a, c) {
          return XF(b, !1, c)
        }

        function na(b) {
          var a = b.prototype;
          return !!(a && a.isReactComponent)
        }

        function aa(b, a, c) {
          return "";
          switch (b) {
            case SUSPENSE_NUMBER:
            case SUSPENSE_SYMBOL_STRING:
              return Uz("Suspense", a);
            case SUSPENSE_LIST_NUMBER:
            case SUSPENSE_LIST_SYMBOL_STRING:
              return Uz("SuspenseList", a)
          }
          if (WF(b) === "object") switch (b.$$typeof) {
            case FORWARD_REF_NUMBER:
            case FORWARD_REF_SYMBOL_STRING:
              return Eu(b.render, a, c);
            case MEMO_NUMBER:
            case MEMO_SYMBOL_STRING:
              return aa(b.type, a, c);
            case LAZY_NUMBER:
            case LAZY_SYMBOL_STRING: {
              var s = b,
                r = s._payload,
                bA = s._init;
              try {
                return aa(bA(r), a, c)
              } catch (Y1) {}
            }
          }
        }

        function _x(b, a, c) {
          var {
            HostComponent: s,
            LazyComponent: r,
            SuspenseComponent: bA,
            SuspenseListComponent: Y1,
            FunctionComponent: B1,
            IndeterminateComponent: uA,
            SimpleMemoComponent: z1,
            ForwardRef: S1,
            ClassComponent: l1
          } = b, n1 = null;
          switch (a.tag) {
            case s:
              return Uz(a.type, n1);
            case r:
              return Uz("Lazy", n1);
            case bA:
              return Uz("Suspense", n1);
            case Y1:
              return Uz("SuspenseList", n1);
            case B1:
            case uA:
            case z1:
              return Eu(a.type, n1, c);
            case S1:
              return Eu(a.type.render, n1, c);
            case l1:
              return mVA(a.type, n1, c);
            default:
              return ""
          }
        }

        function EV(b, a, c) {
          try {
            var s = "",
              r = a;
            do s += _x(b, r, c), r = r.return; while (r);
            return s
          } catch (bA) {
            return `
Error generating stack: ` + bA.message + `
` + bA.stack
          }
        }

        function zBA(b, a) {
          return zu(b) || kx(b, a) || YH(b, a) || $z()
        }

        function $z() {
          throw TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function YH(b, a) {
          if (!b) return;
          if (typeof b === "string") return Cj(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return Cj(b, a)
        }

        function Cj(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }

        function kx(b, a) {
          if (typeof Symbol > "u" || !(Symbol.iterator in Object(b))) return;
          var c = [],
            s = !0,
            r = !1,
            bA = void 0;
          try {
            for (var Y1 = b[Symbol.iterator](), B1; !(s = (B1 = Y1.next()).done); s = !0)
              if (c.push(B1.value), a && c.length === a) break
          } catch (uA) {
            r = !0, bA = uA
          } finally {
            try {
              if (!s && Y1.return != null) Y1.return()
            } finally {
              if (r) throw bA
            }
          }
          return c
        }

        function zu(b) {
          if (Array.isArray(b)) return b
        }

        function qN(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") qN = function(c) {
            return typeof c
          };
          else qN = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return qN(b)
        }
        var sa = 10,
          g$ = null,
          WJ = typeof performance < "u" && typeof performance.mark === "function" && typeof performance.clearMarks === "function",
          E8 = !1;
        if (WJ) {
          var UBA = "__v3",
            tO = {};
          Object.defineProperty(tO, "startTime", {
            get: function() {
              return E8 = !0, 0
            },
            set: function() {}
          });
          try {
            performance.mark(UBA, tO)
          } catch (b) {} finally {
            performance.clearMarks(UBA)
          }
        }
        if (E8) g$ = performance;
        var jI = (typeof performance > "u" ? "undefined" : qN(performance)) === "object" && typeof performance.now === "function" ? function() {
          return performance.now()
        } : function() {
          return Date.now()
        };

        function ra(b) {
          g$ = b, WJ = b !== null, E8 = b !== null
        }

        function hB(b) {
          var {
            getDisplayNameForFiber: a,
            getIsProfiling: c,
            getLaneLabelMap: s,
            workTagMap: r,
            currentDispatcherRef: bA,
            reactVersion: Y1
          } = b, B1 = 0, uA = null, z1 = [], S1 = null, l1 = new Map, n1 = !1, ZQ = !1;

          function TQ() {
            var NB = jI();
            if (S1) {
              if (S1.startTime === 0) S1.startTime = NB - sa;
              return NB - S1.startTime
            }
            return 0
          }

          function M2() {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges === "function") {
              var NB = __REACT_DEVTOOLS_GLOBAL_HOOK__.getInternalModuleRanges();
              if (GX(NB)) return NB
            }
            return null
          }

          function gQ() {
            return S1
          }

          function W9(NB) {
            var h2 = [],
              v8 = 1;
            for (var p6 = 0; p6 < Px; p6++) {
              if (v8 & NB) h2.push(v8);
              v8 *= 2
            }
            return h2
          }
          var p4 = typeof s === "function" ? s() : null;

          function g5() {
            kB("--react-version-".concat(Y1)), kB("--profiler-version-".concat(Hj));
            var NB = M2();
            if (NB)
              for (var h2 = 0; h2 < NB.length; h2++) {
                var v8 = NB[h2];
                if (GX(v8) && v8.length === 2) {
                  var p6 = zBA(NB[h2], 2),
                    YI = p6[0],
                    RG = p6[1];
                  kB("--react-internal-module-start-".concat(YI)), kB("--react-internal-module-stop-".concat(RG))
                }
              }
            if (p4 != null) {
              var HX = Array.from(p4.values()).join(",");
              kB("--react-lane-labels-".concat(HX))
            }
          }

          function kB(NB) {
            g$.mark(NB), g$.clearMarks(NB)
          }

          function U5(NB, h2) {
            var v8 = 0;
            if (z1.length > 0) {
              var p6 = z1[z1.length - 1];
              v8 = p6.type === "render-idle" ? p6.depth : p6.depth + 1
            }
            var YI = W9(h2),
              RG = {
                type: NB,
                batchUID: B1,
                depth: v8,
                lanes: YI,
                timestamp: TQ(),
                duration: 0
              };
            if (z1.push(RG), S1) {
              var HX = S1,
                DF = HX.batchUIDToMeasuresMap,
                ZW = HX.laneToReactMeasureMap,
                fC = DF.get(B1);
              if (fC != null) fC.push(RG);
              else DF.set(B1, [RG]);
              YI.forEach(function(xN) {
                if (fC = ZW.get(xN), fC) fC.push(RG)
              })
            }
          }

          function z7(NB) {
            var h2 = TQ();
            if (z1.length === 0) {
              console.error('Unexpected type "%s" completed at %sms while currentReactMeasuresStack is empty.', NB, h2);
              return
            }
            var v8 = z1.pop();
            if (v8.type !== NB) console.error('Unexpected type "%s" completed at %sms before "%s" completed.', NB, h2, v8.type);
            if (v8.duration = h2 - v8.timestamp, S1) S1.duration = TQ() + sa
          }

          function l4(NB) {
            if (n1) U5("commit", NB), ZQ = !0;
            if (E8) kB("--commit-start-".concat(NB)), g5()
          }

          function F8() {
            if (n1) z7("commit"), z7("render-idle");
            if (E8) kB("--commit-stop")
          }

          function L3(NB) {
            if (n1 || E8) {
              var h2 = a(NB) || "Unknown";
              if (n1) {
                if (n1) uA = {
                  componentName: h2,
                  duration: 0,
                  timestamp: TQ(),
                  type: "render",
                  warning: null
                }
              }
              if (E8) kB("--component-render-start-".concat(h2))
            }
          }

          function jY() {
            if (n1) {
              if (uA) {
                if (S1) S1.componentMeasures.push(uA);
                uA.duration = TQ() - uA.timestamp, uA = null
              }
            }
            if (E8) kB("--component-render-stop")
          }

          function D4(NB) {
            if (n1 || E8) {
              var h2 = a(NB) || "Unknown";
              if (n1) {
                if (n1) uA = {
                  componentName: h2,
                  duration: 0,
                  timestamp: TQ(),
                  type: "layout-effect-mount",
                  warning: null
                }
              }
              if (E8) kB("--component-layout-effect-mount-start-".concat(h2))
            }
          }

          function VJ() {
            if (n1) {
              if (uA) {
                if (S1) S1.componentMeasures.push(uA);
                uA.duration = TQ() - uA.timestamp, uA = null
              }
            }
            if (E8) kB("--component-layout-effect-mount-stop")
          }

          function GI(NB) {
            if (n1 || E8) {
              var h2 = a(NB) || "Unknown";
              if (n1) {
                if (n1) uA = {
                  componentName: h2,
                  duration: 0,
                  timestamp: TQ(),
                  type: "layout-effect-unmount",
                  warning: null
                }
              }
              if (E8) kB("--component-layout-effect-unmount-start-".concat(h2))
            }
          }

          function v7() {
            if (n1) {
              if (uA) {
                if (S1) S1.componentMeasures.push(uA);
                uA.duration = TQ() - uA.timestamp, uA = null
              }
            }
            if (E8) kB("--component-layout-effect-unmount-stop")
          }

          function r9(NB) {
            if (n1 || E8) {
              var h2 = a(NB) || "Unknown";
              if (n1) {
                if (n1) uA = {
                  componentName: h2,
                  duration: 0,
                  timestamp: TQ(),
                  type: "passive-effect-mount",
                  warning: null
                }
              }
              if (E8) kB("--component-passive-effect-mount-start-".concat(h2))
            }
          }

          function i3() {
            if (n1) {
              if (uA) {
                if (S1) S1.componentMeasures.push(uA);
                uA.duration = TQ() - uA.timestamp, uA = null
              }
            }
            if (E8) kB("--component-passive-effect-mount-stop")
          }

          function FJ(NB) {
            if (n1 || E8) {
              var h2 = a(NB) || "Unknown";
              if (n1) {
                if (n1) uA = {
                  componentName: h2,
                  duration: 0,
                  timestamp: TQ(),
                  type: "passive-effect-unmount",
                  warning: null
                }
              }
              if (E8) kB("--component-passive-effect-unmount-start-".concat(h2))
            }
          }

          function UV() {
            if (n1) {
              if (uA) {
                if (S1) S1.componentMeasures.push(uA);
                uA.duration = TQ() - uA.timestamp, uA = null
              }
            }
            if (E8) kB("--component-passive-effect-unmount-stop")
          }

          function YB(NB, h2, v8) {
            if (n1 || E8) {
              var p6 = a(NB) || "Unknown",
                YI = NB.alternate === null ? "mount" : "update",
                RG = "";
              if (h2 !== null && qN(h2) === "object" && typeof h2.message === "string") RG = h2.message;
              else if (typeof h2 === "string") RG = h2;
              if (n1) {
                if (S1) S1.thrownErrors.push({
                  componentName: p6,
                  message: RG,
                  phase: YI,
                  timestamp: TQ(),
                  type: "thrown-error"
                })
              }
              if (E8) kB("--error-".concat(p6, "-").concat(YI, "-").concat(RG))
            }
          }
          var z2 = typeof WeakMap === "function" ? WeakMap : Map,
            A9 = new z2,
            ZG = 0;

          function _I(NB) {
            if (!A9.has(NB)) A9.set(NB, ZG++);
            return A9.get(NB)
          }

          function OG(NB, h2, v8) {
            if (n1 || E8) {
              var p6 = A9.has(h2) ? "resuspend" : "suspend",
                YI = _I(h2),
                RG = a(NB) || "Unknown",
                HX = NB.alternate === null ? "mount" : "update",
                DF = h2.displayName || "",
                ZW = null;
              if (n1) {
                if (ZW = {
                    componentName: RG,
                    depth: 0,
                    duration: 0,
                    id: "".concat(YI),
                    phase: HX,
                    promiseName: DF,
                    resolution: "unresolved",
                    timestamp: TQ(),
                    type: "suspense",
                    warning: null
                  }, S1) S1.suspenseEvents.push(ZW)
              }
              if (E8) kB("--suspense-".concat(p6, "-").concat(YI, "-").concat(RG, "-").concat(HX, "-").concat(v8, "-").concat(DF));
              h2.then(function() {
                if (ZW) ZW.duration = TQ() - ZW.timestamp, ZW.resolution = "resolved";
                if (E8) kB("--suspense-resolved-".concat(YI, "-").concat(RG))
              }, function() {
                if (ZW) ZW.duration = TQ() - ZW.timestamp, ZW.resolution = "rejected";
                if (E8) kB("--suspense-rejected-".concat(YI, "-").concat(RG))
              })
            }
          }

          function ZI(NB) {
            if (n1) U5("layout-effects", NB);
            if (E8) kB("--layout-effects-start-".concat(NB))
          }

          function II() {
            if (n1) z7("layout-effects");
            if (E8) kB("--layout-effects-stop")
          }

          function c$(NB) {
            if (n1) U5("passive-effects", NB);
            if (E8) kB("--passive-effects-start-".concat(NB))
          }

          function XH() {
            if (n1) z7("passive-effects");
            if (E8) kB("--passive-effects-stop")
          }

          function p$(NB) {
            if (n1) {
              if (ZQ) ZQ = !1, B1++;
              if (z1.length === 0 || z1[z1.length - 1].type !== "render-idle") U5("render-idle", NB);
              U5("render", NB)
            }
            if (E8) kB("--render-start-".concat(NB))
          }

          function bC() {
            if (n1) z7("render");
            if (E8) kB("--render-yield")
          }

          function Tz() {
            if (n1) z7("render");
            if (E8) kB("--render-stop")
          }

          function KJ(NB) {
            if (n1) {
              if (S1) S1.schedulingEvents.push({
                lanes: W9(NB),
                timestamp: TQ(),
                type: "schedule-render",
                warning: null
              })
            }
            if (E8) kB("--schedule-render-".concat(NB))
          }

          function VH(NB, h2) {
            if (n1 || E8) {
              var v8 = a(NB) || "Unknown";
              if (n1) {
                if (S1) S1.schedulingEvents.push({
                  componentName: v8,
                  lanes: W9(h2),
                  timestamp: TQ(),
                  type: "schedule-force-update",
                  warning: null
                })
              }
              if (E8) kB("--schedule-forced-update-".concat(h2, "-").concat(v8))
            }
          }

          function yN(NB) {
            var h2 = [],
              v8 = NB;
            while (v8 !== null) h2.push(v8), v8 = v8.return;
            return h2
          }

          function Su(NB, h2) {
            if (n1 || E8) {
              var v8 = a(NB) || "Unknown";
              if (n1) {
                if (S1) {
                  var p6 = {
                    componentName: v8,
                    lanes: W9(h2),
                    timestamp: TQ(),
                    type: "schedule-state-update",
                    warning: null
                  };
                  l1.set(p6, yN(NB)), S1.schedulingEvents.push(p6)
                }
              }
              if (E8) kB("--schedule-state-update-".concat(h2, "-").concat(v8))
            }
          }

          function Ks(NB) {
            if (n1 !== NB)
              if (n1 = NB, n1) {
                var h2 = new Map;
                if (E8) {
                  var v8 = M2();
                  if (v8)
                    for (var p6 = 0; p6 < v8.length; p6++) {
                      var YI = v8[p6];
                      if (GX(YI) && YI.length === 2) {
                        var RG = zBA(v8[p6], 2),
                          HX = RG[0],
                          DF = RG[1];
                        kB("--react-internal-module-start-".concat(HX)), kB("--react-internal-module-stop-".concat(DF))
                      }
                    }
                }
                var ZW = new Map,
                  fC = 1;
                for (var xN = 0; xN < Px; xN++) ZW.set(fC, []), fC *= 2;
                B1 = 0, uA = null, z1 = [], l1 = new Map, S1 = {
                  internalModuleSourceToRanges: h2,
                  laneToLabelMap: p4 || new Map,
                  reactVersion: Y1,
                  componentMeasures: [],
                  schedulingEvents: [],
                  suspenseEvents: [],
                  thrownErrors: [],
                  batchUIDToMeasuresMap: new Map,
                  duration: 0,
                  laneToReactMeasureMap: ZW,
                  startTime: 0,
                  flamechart: [],
                  nativeEvents: [],
                  networkMeasures: [],
                  otherUserTimingMarks: [],
                  snapshots: [],
                  snapshotHeight: 0
                }, ZQ = !0
              } else {
                if (S1 !== null) S1.schedulingEvents.forEach(function(XR) {
                  if (XR.type === "schedule-state-update") {
                    var s0 = l1.get(XR);
                    if (s0 && bA != null) XR.componentStack = s0.reduce(function(IQ, JQ) {
                      return IQ + _x(r, JQ, bA)
                    }, "")
                  }
                });
                l1.clear()
              }
          }
          return {
            getTimelineData: gQ,
            profilingHooks: {
              markCommitStarted: l4,
              markCommitStopped: F8,
              markComponentRenderStarted: L3,
              markComponentRenderStopped: jY,
              markComponentPassiveEffectMountStarted: r9,
              markComponentPassiveEffectMountStopped: i3,
              markComponentPassiveEffectUnmountStarted: FJ,
              markComponentPassiveEffectUnmountStopped: UV,
              markComponentLayoutEffectMountStarted: D4,
              markComponentLayoutEffectMountStopped: VJ,
              markComponentLayoutEffectUnmountStarted: GI,
              markComponentLayoutEffectUnmountStopped: v7,
              markComponentErrored: YB,
              markComponentSuspended: OG,
              markLayoutEffectsStarted: ZI,
              markLayoutEffectsStopped: II,
              markPassiveEffectsStarted: c$,
              markPassiveEffectsStopped: XH,
              markRenderStarted: p$,
              markRenderYielded: bC,
              markRenderStopped: Tz,
              markRenderScheduled: KJ,
              markForceUpdateScheduled: VH,
              markStateUpdateScheduled: Su
            },
            toggleProfilingStatus: Ks
          }
        }

        function eO(b, a) {
          if (b == null) return {};
          var c = oa(b, a),
            s, r;
          if (Object.getOwnPropertySymbols) {
            var bA = Object.getOwnPropertySymbols(b);
            for (r = 0; r < bA.length; r++) {
              if (s = bA[r], a.indexOf(s) >= 0) continue;
              if (!Object.prototype.propertyIsEnumerable.call(b, s)) continue;
              c[s] = b[s]
            }
          }
          return c
        }

        function oa(b, a) {
          if (b == null) return {};
          var c = {},
            s = Object.keys(b),
            r, bA;
          for (bA = 0; bA < s.length; bA++) {
            if (r = s[bA], a.indexOf(r) >= 0) continue;
            c[r] = b[r]
          }
          return c
        }

        function yC(b, a) {
          var c = Object.keys(b);
          if (Object.getOwnPropertySymbols) {
            var s = Object.getOwnPropertySymbols(b);
            if (a) s = s.filter(function(r) {
              return Object.getOwnPropertyDescriptor(b, r).enumerable
            });
            c.push.apply(c, s)
          }
          return c
        }

        function yx(b) {
          for (var a = 1; a < arguments.length; a++) {
            var c = arguments[a] != null ? arguments[a] : {};
            if (a % 2) yC(Object(c), !0).forEach(function(s) {
              xC(b, s, c[s])
            });
            else if (Object.getOwnPropertyDescriptors) Object.defineProperties(b, Object.getOwnPropertyDescriptors(c));
            else yC(Object(c)).forEach(function(s) {
              Object.defineProperty(b, s, Object.getOwnPropertyDescriptor(c, s))
            })
          }
          return b
        }

        function xC(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }

        function XX(b, a) {
          return As(b) || ea(b, a) || JH(b, a) || ta()
        }

        function ta() {
          throw TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function ea(b, a) {
          if (typeof Symbol > "u" || !(Symbol.iterator in Object(b))) return;
          var c = [],
            s = !0,
            r = !1,
            bA = void 0;
          try {
            for (var Y1 = b[Symbol.iterator](), B1; !(s = (B1 = Y1.next()).done); s = !0)
              if (c.push(B1.value), a && c.length === a) break
          } catch (uA) {
            r = !0, bA = uA
          } finally {
            try {
              if (!s && Y1.return != null) Y1.return()
            } finally {
              if (r) throw bA
            }
          }
          return c
        }

        function As(b) {
          if (Array.isArray(b)) return b
        }

        function NN(b) {
          return GW(b) || Uu(b) || JH(b) || wz()
        }

        function wz() {
          throw TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function Uu(b) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(b)) return Array.from(b)
        }

        function GW(b) {
          if (Array.isArray(b)) return Ej(b)
        }

        function XJ(b, a) {
          var c;
          if (typeof Symbol > "u" || b[Symbol.iterator] == null) {
            if (Array.isArray(b) || (c = JH(b)) || a && b && typeof b.length === "number") {
              if (c) b = c;
              var s = 0,
                r = function() {};
              return {
                s: r,
                n: function() {
                  if (s >= b.length) return {
                    done: !0
                  };
                  return {
                    done: !1,
                    value: b[s++]
                  }
                },
                e: function(z1) {
                  throw z1
                },
                f: r
              }
            }
            throw TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
          }
          var bA = !0,
            Y1 = !1,
            B1;
          return {
            s: function() {
              c = b[Symbol.iterator]()
            },
            n: function() {
              var z1 = c.next();
              return bA = z1.done, z1
            },
            e: function(z1) {
              Y1 = !0, B1 = z1
            },
            f: function() {
              try {
                if (!bA && c.return != null) c.return()
              } finally {
                if (Y1) throw B1
              }
            }
          }
        }

        function JH(b, a) {
          if (!b) return;
          if (typeof b === "string") return Ej(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return Ej(b, a)
        }

        function Ej(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }

        function LG(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") LG = function(c) {
            return typeof c
          };
          else LG = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return LG(b)
        }

        function yK(b) {
          return b.flags !== void 0 ? b.flags : b.effectTag
        }
        var xx = (typeof performance > "u" ? "undefined" : LG(performance)) === "object" && typeof performance.now === "function" ? function() {
          return performance.now()
        } : function() {
          return Date.now()
        };

        function SI(b) {
          var a = {
            ImmediatePriority: 99,
            UserBlockingPriority: 98,
            NormalPriority: 97,
            LowPriority: 96,
            IdlePriority: 95,
            NoPriority: 90
          };
          if (sO(b, "17.0.2")) a = {
            ImmediatePriority: 1,
            UserBlockingPriority: 2,
            NormalPriority: 3,
            LowPriority: 4,
            IdlePriority: 5,
            NoPriority: 0
          };
          var c = 0;
          if (_C(b, "18.0.0-alpha")) c = 24;
          else if (_C(b, "16.9.0")) c = 1;
          else if (_C(b, "16.3.0")) c = 2;
          var s = null;
          if (sO(b, "17.0.1")) s = {
            CacheComponent: 24,
            ClassComponent: 1,
            ContextConsumer: 9,
            ContextProvider: 10,
            CoroutineComponent: -1,
            CoroutineHandlerPhase: -1,
            DehydratedSuspenseComponent: 18,
            ForwardRef: 11,
            Fragment: 7,
            FunctionComponent: 0,
            HostComponent: 5,
            HostPortal: 4,
            HostRoot: 3,
            HostHoistable: 26,
            HostSingleton: 27,
            HostText: 6,
            IncompleteClassComponent: 17,
            IndeterminateComponent: 2,
            LazyComponent: 16,
            LegacyHiddenComponent: 23,
            MemoComponent: 14,
            Mode: 8,
            OffscreenComponent: 22,
            Profiler: 12,
            ScopeComponent: 21,
            SimpleMemoComponent: 15,
            SuspenseComponent: 13,
            SuspenseListComponent: 19,
            TracingMarkerComponent: 25,
            YieldComponent: -1
          };
          else if (_C(b, "17.0.0-alpha")) s = {
            CacheComponent: -1,
            ClassComponent: 1,
            ContextConsumer: 9,
            ContextProvider: 10,
            CoroutineComponent: -1,
            CoroutineHandlerPhase: -1,
            DehydratedSuspenseComponent: 18,
            ForwardRef: 11,
            Fragment: 7,
            FunctionComponent: 0,
            HostComponent: 5,
            HostPortal: 4,
            HostRoot: 3,
            HostHoistable: -1,
            HostSingleton: -1,
            HostText: 6,
            IncompleteClassComponent: 17,
            IndeterminateComponent: 2,
            LazyComponent: 16,
            LegacyHiddenComponent: 24,
            MemoComponent: 14,
            Mode: 8,
            OffscreenComponent: 23,
            Profiler: 12,
            ScopeComponent: 21,
            SimpleMemoComponent: 15,
            SuspenseComponent: 13,
            SuspenseListComponent: 19,
            TracingMarkerComponent: -1,
            YieldComponent: -1
          };
          else if (_C(b, "16.6.0-beta.0")) s = {
            CacheComponent: -1,
            ClassComponent: 1,
            ContextConsumer: 9,
            ContextProvider: 10,
            CoroutineComponent: -1,
            CoroutineHandlerPhase: -1,
            DehydratedSuspenseComponent: 18,
            ForwardRef: 11,
            Fragment: 7,
            FunctionComponent: 0,
            HostComponent: 5,
            HostPortal: 4,
            HostRoot: 3,
            HostHoistable: -1,
            HostSingleton: -1,
            HostText: 6,
            IncompleteClassComponent: 17,
            IndeterminateComponent: 2,
            LazyComponent: 16,
            LegacyHiddenComponent: -1,
            MemoComponent: 14,
            Mode: 8,
            OffscreenComponent: -1,
            Profiler: 12,
            ScopeComponent: -1,
            SimpleMemoComponent: 15,
            SuspenseComponent: 13,
            SuspenseListComponent: 19,
            TracingMarkerComponent: -1,
            YieldComponent: -1
          };
          else if (_C(b, "16.4.3-alpha")) s = {
            CacheComponent: -1,
            ClassComponent: 2,
            ContextConsumer: 11,
            ContextProvider: 12,
            CoroutineComponent: -1,
            CoroutineHandlerPhase: -1,
            DehydratedSuspenseComponent: -1,
            ForwardRef: 13,
            Fragment: 9,
            FunctionComponent: 0,
            HostComponent: 7,
            HostPortal: 6,
            HostRoot: 5,
            HostHoistable: -1,
            HostSingleton: -1,
            HostText: 8,
            IncompleteClassComponent: -1,
            IndeterminateComponent: 4,
            LazyComponent: -1,
            LegacyHiddenComponent: -1,
            MemoComponent: -1,
            Mode: 10,
            OffscreenComponent: -1,
            Profiler: 15,
            ScopeComponent: -1,
            SimpleMemoComponent: -1,
            SuspenseComponent: 16,
            SuspenseListComponent: -1,
            TracingMarkerComponent: -1,
            YieldComponent: -1
          };
          else s = {
            CacheComponent: -1,
            ClassComponent: 2,
            ContextConsumer: 12,
            ContextProvider: 13,
            CoroutineComponent: 7,
            CoroutineHandlerPhase: 8,
            DehydratedSuspenseComponent: -1,
            ForwardRef: 14,
            Fragment: 10,
            FunctionComponent: 1,
            HostComponent: 5,
            HostPortal: 4,
            HostRoot: 3,
            HostHoistable: -1,
            HostSingleton: -1,
            HostText: 6,
            IncompleteClassComponent: -1,
            IndeterminateComponent: 0,
            LazyComponent: -1,
            LegacyHiddenComponent: -1,
            MemoComponent: -1,
            Mode: 11,
            OffscreenComponent: -1,
            Profiler: 15,
            ScopeComponent: -1,
            SimpleMemoComponent: -1,
            SuspenseComponent: 16,
            SuspenseListComponent: -1,
            TracingMarkerComponent: -1,
            YieldComponent: 9
          };

          function r(r9) {
            var i3 = LG(r9) === "object" && r9 !== null ? r9.$$typeof : r9;
            return LG(i3) === "symbol" ? i3.toString() : i3
          }
          var bA = s,
            Y1 = bA.CacheComponent,
            B1 = bA.ClassComponent,
            uA = bA.IncompleteClassComponent,
            z1 = bA.FunctionComponent,
            S1 = bA.IndeterminateComponent,
            l1 = bA.ForwardRef,
            n1 = bA.HostRoot,
            ZQ = bA.HostHoistable,
            TQ = bA.HostSingleton,
            M2 = bA.HostComponent,
            gQ = bA.HostPortal,
            W9 = bA.HostText,
            p4 = bA.Fragment,
            g5 = bA.LazyComponent,
            kB = bA.LegacyHiddenComponent,
            U5 = bA.MemoComponent,
            z7 = bA.OffscreenComponent,
            l4 = bA.Profiler,
            F8 = bA.ScopeComponent,
            L3 = bA.SimpleMemoComponent,
            jY = bA.SuspenseComponent,
            D4 = bA.SuspenseListComponent,
            VJ = bA.TracingMarkerComponent;

          function GI(r9) {
            var i3 = r(r9);
            switch (i3) {
              case Nx:
              case fa:
                return GI(r9.type);
              case ZBA:
              case IBA:
                return r9.render;
              default:
                return r9
            }
          }

          function v7(r9) {
            var {
              elementType: i3,
              type: FJ,
              tag: UV
            } = r9, YB = FJ;
            if (LG(FJ) === "object" && FJ !== null) YB = GI(FJ);
            var z2 = null;
            switch (UV) {
              case Y1:
                return "Cache";
              case B1:
              case uA:
                return m6(YB);
              case z1:
              case S1:
                return m6(YB);
              case l1:
                return c2(i3, YB, "ForwardRef", "Anonymous");
              case n1:
                var A9 = r9.stateNode;
                if (A9 != null && A9._debugRootType !== null) return A9._debugRootType;
                return null;
              case M2:
              case TQ:
              case ZQ:
                return FJ;
              case gQ:
              case W9:
                return null;
              case p4:
                return "Fragment";
              case g5:
                return "Lazy";
              case U5:
              case L3:
                return c2(i3, YB, "Memo", "Anonymous");
              case jY:
                return "Suspense";
              case kB:
                return "LegacyHidden";
              case z7:
                return "Offscreen";
              case F8:
                return "Scope";
              case D4:
                return "SuspenseList";
              case l4:
                return "Profiler";
              case VJ:
                return "TracingMarker";
              default:
                var ZG = r(FJ);
                switch (ZG) {
                  case Vj:
                  case YJ:
                  case X8:
                    return null;
                  case zz:
                  case wN:
                    return z2 = r9.type._context || r9.type.context, "".concat(z2.displayName || "Context", ".Provider");
                  case Ez:
                  case UN:
                  case Fj:
                    return z2 = r9.type._context || r9.type, "".concat(z2.displayName || "Context", ".Consumer");
                  case Ku:
                  case rO:
                    return null;
                  case Kj:
                  case v$:
                    return "Profiler(".concat(r9.memoizedProps.id, ")");
                  case JBA:
                  case WBA:
                    return "Scope";
                  default:
                    return null
                }
            }
          }
          return {
            getDisplayNameForFiber: v7,
            getTypeSymbol: r,
            ReactPriorityLevels: a,
            ReactTypeOfWork: s,
            StrictModeBits: c
          }
        }
        var VX = new Map,
          OY = new Map;

        function LN(b, a, c, s) {
          var r = c.reconcilerVersion || c.version,
            bA = SI(r),
            Y1 = bA.getDisplayNameForFiber,
            B1 = bA.getTypeSymbol,
            uA = bA.ReactPriorityLevels,
            z1 = bA.ReactTypeOfWork,
            S1 = bA.StrictModeBits,
            l1 = z1.CacheComponent,
            n1 = z1.ClassComponent,
            ZQ = z1.ContextConsumer,
            TQ = z1.DehydratedSuspenseComponent,
            M2 = z1.ForwardRef,
            gQ = z1.Fragment,
            W9 = z1.FunctionComponent,
            p4 = z1.HostRoot,
            g5 = z1.HostHoistable,
            kB = z1.HostSingleton,
            U5 = z1.HostPortal,
            z7 = z1.HostComponent,
            l4 = z1.HostText,
            F8 = z1.IncompleteClassComponent,
            L3 = z1.IndeterminateComponent,
            jY = z1.LegacyHiddenComponent,
            D4 = z1.MemoComponent,
            VJ = z1.OffscreenComponent,
            GI = z1.SimpleMemoComponent,
            v7 = z1.SuspenseComponent,
            r9 = z1.SuspenseListComponent,
            i3 = z1.TracingMarkerComponent,
            FJ = uA.ImmediatePriority,
            UV = uA.UserBlockingPriority,
            YB = uA.NormalPriority,
            z2 = uA.LowPriority,
            A9 = uA.IdlePriority,
            ZG = uA.NoPriority,
            _I = c.getLaneLabelMap,
            OG = c.injectProfilingHooks,
            ZI = c.overrideHookState,
            II = c.overrideHookStateDeletePath,
            c$ = c.overrideHookStateRenamePath,
            XH = c.overrideProps,
            p$ = c.overridePropsDeletePath,
            bC = c.overridePropsRenamePath,
            Tz = c.scheduleRefresh,
            KJ = c.setErrorHandler,
            VH = c.setSuspenseHandler,
            yN = c.scheduleUpdate,
            Su = typeof KJ === "function" && typeof yN === "function",
            Ks = typeof VH === "function" && typeof yN === "function";
          if (typeof Tz === "function") c.scheduleRefresh = function() {
            try {
              b.emit("fastRefreshScheduled")
            } finally {
              return Tz.apply(void 0, arguments)
            }
          };
          var NB = null,
            h2 = null;
          if (typeof OG === "function") {
            var v8 = hB({
              getDisplayNameForFiber: Y1,
              getIsProfiling: function() {
                return yz
              },
              getLaneLabelMap: _I,
              currentDispatcherRef: c.currentDispatcherRef,
              workTagMap: z1,
              reactVersion: r
            });
            OG(v8.profilingHooks), NB = v8.getTimelineData, h2 = v8.toggleProfilingStatus
          }
          var p6 = new Set,
            YI = new Map,
            RG = new Map,
            HX = new Map,
            DF = new Map;

          function ZW() {
            var vA = XJ(HX.keys()),
              aA;
            try {
              for (vA.s(); !(aA = vA.n()).done;) {
                var $1 = aA.value,
                  K1 = OY.get($1);
                if (K1 != null) p6.add(K1), s0($1)
              }
            } catch (q9) {
              vA.e(q9)
            } finally {
              vA.f()
            }
            var c1 = XJ(DF.keys()),
              u0;
            try {
              for (c1.s(); !(u0 = c1.n()).done;) {
                var $Q = u0.value,
                  X9 = OY.get($Q);
                if (X9 != null) p6.add(X9), s0($Q)
              }
            } catch (q9) {
              c1.e(q9)
            } finally {
              c1.f()
            }
            HX.clear(), DF.clear(), px()
          }

          function fC(vA, aA, $1) {
            var K1 = OY.get(vA);
            if (K1 != null)
              if (YI.delete(K1), $1.has(vA)) $1.delete(vA), p6.add(K1), px(), s0(vA);
              else p6.delete(K1)
          }

          function xN(vA) {
            fC(vA, YI, HX)
          }

          function XR(vA) {
            fC(vA, RG, DF)
          }

          function s0(vA) {
            if (bK !== null && bK.id === vA) Es = !0
          }

          function IQ(vA, aA, $1) {
            if (aA === "error") {
              var K1 = _z(vA);
              if (K1 != null && i$.get(K1) === !0) return
            }
            var c1 = j8.apply(void 0, NN($1));
            if (H) JQ("onErrorOrWarning", vA, null, "".concat(aA, ': "').concat(c1, '"'));
            p6.add(vA);
            var u0 = aA === "error" ? YI : RG,
              $Q = u0.get(vA);
            if ($Q != null) {
              var X9 = $Q.get(c1) || 0;
              $Q.set(c1, X9 + 1)
            } else u0.set(vA, new Map([
              [c1, 1]
            ]));
            HW1()
          }
          BR(c, IQ), KX();
          var JQ = function(aA, $1, K1) {
              var c1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
              if (H) {
                var u0 = $1.tag + ":" + (Y1($1) || "null"),
                  $Q = _z($1) || "<no id>",
                  X9 = K1 ? K1.tag + ":" + (Y1(K1) || "null") : "",
                  q9 = K1 ? _z(K1) || "<no-id>" : "";
                console.groupCollapsed("[renderer] %c".concat(aA, " %c").concat(u0, " (").concat($Q, ") %c").concat(K1 ? "".concat(X9, " (").concat(q9, ")") : "", " %c").concat(c1), "color: red; font-weight: bold;", "color: blue;", "color: purple;", "color: black;"), console.log(Error().stack.split(`
`).slice(1).join(`
`)), console.groupEnd()
              }
            },
            NQ = new Set,
            A2 = new Set,
            i4 = new Set,
            b8 = !1,
            M3 = new Set;

          function DJ(vA) {
            i4.clear(), NQ.clear(), A2.clear(), vA.forEach(function(aA) {
              if (!aA.isEnabled) return;
              switch (aA.type) {
                case IB:
                  if (aA.isValid && aA.value !== "") NQ.add(new RegExp(aA.value, "i"));
                  break;
                case eB:
                  i4.add(aA.value);
                  break;
                case $9:
                  if (aA.isValid && aA.value !== "") A2.add(new RegExp(aA.value, "i"));
                  break;
                case q6:
                  NQ.add(new RegExp("\\("));
                  break;
                default:
                  console.warn('Invalid component filter type "'.concat(aA.type, '"'));
                  break
              }
            })
          }
          if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) DJ(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);
          else DJ(MY());

          function $V(vA) {
            if (yz) throw Error("Cannot modify filter preferences while profiling");
            b.getFiberRoots(a).forEach(function(aA) {
              HJ = l$(aA.current), U7(R), px(aA), HJ = -1
            }), DJ(vA), TG.clear(), b.getFiberRoots(a).forEach(function(aA) {
              HJ = l$(aA.current), PBA(HJ, aA.current), FH(aA.current, null, !1, !1), px(aA), HJ = -1
            }), CW1(), px()
          }

          function Pz(vA) {
            var {
              _debugSource: aA,
              tag: $1,
              type: K1,
              key: c1
            } = vA;
            switch ($1) {
              case TQ:
                return !0;
              case U5:
              case l4:
              case jY:
              case VJ:
                return !0;
              case p4:
                return !1;
              case gQ:
                return c1 === null;
              default:
                var u0 = B1(K1);
                switch (u0) {
                  case Vj:
                  case YJ:
                  case X8:
                  case Ku:
                  case rO:
                    return !0;
                  default:
                    break
                }
            }
            var $Q = n3(vA);
            if (i4.has($Q)) return !0;
            if (NQ.size > 0) {
              var X9 = Y1(vA);
              if (X9 != null) {
                var q9 = XJ(NQ),
                  r2;
                try {
                  for (q9.s(); !(r2 = q9.n()).done;) {
                    var N9 = r2.value;
                    if (N9.test(X9)) return !0
                  }
                } catch (KH) {
                  q9.e(KH)
                } finally {
                  q9.f()
                }
              }
            }
            if (aA != null && A2.size > 0) {
              var W6 = aA.fileName,
                CJ = XJ(A2),
                $7;
              try {
                for (CJ.s(); !($7 = CJ.n()).done;) {
                  var CX = $7.value;
                  if (CX.test(W6)) return !0
                }
              } catch (KH) {
                CJ.e(KH)
              } finally {
                CJ.f()
              }
            }
            return !1
          }

          function n3(vA) {
            var {
              type: aA,
              tag: $1
            } = vA;
            switch ($1) {
              case n1:
              case F8:
                return sG;
              case W9:
              case L3:
                return oW;
              case M2:
                return ZF;
              case p4:
                return x$;
              case z7:
              case g5:
              case kB:
                return q3;
              case U5:
              case l4:
              case gQ:
                return BW;
              case D4:
              case GI:
                return GJ;
              case v7:
                return H5;
              case r9:
                return M4;
              case i3:
                return a0;
              default:
                var K1 = B1(aA);
                switch (K1) {
                  case Vj:
                  case YJ:
                  case X8:
                    return BW;
                  case zz:
                  case wN:
                    return jK;
                  case Ez:
                  case UN:
                    return jK;
                  case Ku:
                  case rO:
                    return BW;
                  case Kj:
                  case v$:
                    return DN;
                  default:
                    return BW
                }
            }
          }
          var jz = new Map,
            mx = new Map,
            HJ = -1;

          function l$(vA) {
            var aA = null;
            if (VX.has(vA)) aA = VX.get(vA);
            else {
              var $1 = vA.alternate;
              if ($1 !== null && VX.has($1)) aA = VX.get($1)
            }
            var K1 = !1;
            if (aA === null) K1 = !0, aA = p3();
            var c1 = aA;
            if (!VX.has(vA)) VX.set(vA, c1), OY.set(c1, vA);
            var u0 = vA.alternate;
            if (u0 !== null) {
              if (!VX.has(u0)) VX.set(u0, c1)
            }
            if (H) {
              if (K1) JQ("getOrGenerateFiberID()", vA, vA.return, "Generated a new UID")
            }
            return c1
          }

          function Sz(vA) {
            var aA = _z(vA);
            if (aA !== null) return aA;
            throw Error('Could not find ID for Fiber "'.concat(Y1(vA) || "", '"'))
          }

          function _z(vA) {
            if (VX.has(vA)) return VX.get(vA);
            else {
              var aA = vA.alternate;
              if (aA !== null && VX.has(aA)) return VX.get(aA)
            }
            return null
          }

          function WW1(vA) {
            if (H) JQ("untrackFiberID()", vA, vA.return, "schedule after delay");
            Ds.add(vA);
            var aA = vA.alternate;
            if (aA !== null) Ds.add(aA);
            if (dx === null) dx = setTimeout(rSA, 1000)
          }
          var Ds = new Set,
            dx = null;

          function rSA() {
            if (dx !== null) clearTimeout(dx), dx = null;
            Ds.forEach(function(vA) {
              var aA = _z(vA);
              if (aA !== null) OY.delete(aA), xN(aA), XR(aA);
              VX.delete(vA);
              var $1 = vA.alternate;
              if ($1 !== null) VX.delete($1);
              if (i$.has(aA)) {
                if (i$.delete(aA), i$.size === 0 && KJ != null) KJ(N_A)
              }
            }), Ds.clear()
          }

          function XW1(vA, aA) {
            switch (n3(aA)) {
              case sG:
              case oW:
              case GJ:
              case ZF:
                if (vA === null) return {
                  context: null,
                  didHooksChange: !1,
                  isFirstMount: !0,
                  props: null,
                  state: null
                };
                else {
                  var $1 = {
                      context: VW1(aA),
                      didHooksChange: !1,
                      isFirstMount: !1,
                      props: pVA(vA.memoizedProps, aA.memoizedProps),
                      state: pVA(vA.memoizedState, aA.memoizedState)
                    },
                    K1 = DW1(vA.memoizedState, aA.memoizedState);
                  return $1.hooks = K1, $1.didHooksChange = K1 !== null && K1.length > 0, $1
                }
              default:
                return null
            }
          }

          function oSA(vA) {
            switch (n3(vA)) {
              case sG:
              case ZF:
              case oW:
              case GJ:
                if (bu !== null) {
                  var aA = Sz(vA),
                    $1 = tSA(vA);
                  if ($1 !== null) bu.set(aA, $1)
                }
                break;
              default:
                break
            }
          }
          var _u = {};

          function tSA(vA) {
            var aA = _u,
              $1 = _u;
            switch (n3(vA)) {
              case sG:
                var K1 = vA.stateNode;
                if (K1 != null) {
                  if (K1.constructor && K1.constructor.contextType != null) $1 = K1.context;
                  else if (aA = K1.context, aA && Object.keys(aA).length === 0) aA = _u
                }
                return [aA, $1];
              case ZF:
              case oW:
              case GJ:
                var c1 = vA.dependencies;
                if (c1 && c1.firstContext) $1 = c1.firstContext;
                return [aA, $1];
              default:
                return null
            }
          }

          function eSA(vA) {
            var aA = _z(vA);
            if (aA !== null) {
              oSA(vA);
              var $1 = vA.child;
              while ($1 !== null) eSA($1), $1 = $1.sibling
            }
          }

          function VW1(vA) {
            if (bu !== null) {
              var aA = Sz(vA),
                $1 = bu.has(aA) ? bu.get(aA) : null,
                K1 = tSA(vA);
              if ($1 == null || K1 == null) return null;
              var c1 = XX($1, 2),
                u0 = c1[0],
                $Q = c1[1],
                X9 = XX(K1, 2),
                q9 = X9[0],
                r2 = X9[1];
              switch (n3(vA)) {
                case sG:
                  if ($1 && K1) {
                    if (q9 !== _u) return pVA(u0, q9);
                    else if (r2 !== _u) return $Q !== r2
                  }
                  break;
                case ZF:
                case oW:
                case GJ:
                  if (r2 !== _u) {
                    var N9 = $Q,
                      W6 = r2;
                    while (N9 && W6) {
                      if (!Du(N9.memoizedValue, W6.memoizedValue)) return !0;
                      N9 = N9.next, W6 = W6.next
                    }
                    return !1
                  }
                  break;
                default:
                  break
              }
            }
            return null
          }

          function FW1(vA) {
            var aA = vA.queue;
            if (!aA) return !1;
            var $1 = Ox.bind(aA);
            if ($1("pending")) return !0;
            return $1("value") && $1("getSnapshot") && typeof aA.getSnapshot === "function"
          }

          function KW1(vA, aA) {
            var $1 = vA.memoizedState,
              K1 = aA.memoizedState;
            if (FW1(vA)) return $1 !== K1;
            return !1
          }

          function DW1(vA, aA) {
            if (vA == null || aA == null) return null;
            var $1 = [],
              K1 = 0;
            if (aA.hasOwnProperty("baseState") && aA.hasOwnProperty("memoizedState") && aA.hasOwnProperty("next") && aA.hasOwnProperty("queue"))
              while (aA !== null) {
                if (KW1(vA, aA)) $1.push(K1);
                aA = aA.next, vA = vA.next, K1++
              }
            return $1
          }

          function pVA(vA, aA) {
            if (vA == null || aA == null) return null;
            if (aA.hasOwnProperty("baseState") && aA.hasOwnProperty("memoizedState") && aA.hasOwnProperty("next") && aA.hasOwnProperty("queue")) return null;
            var $1 = new Set([].concat(NN(Object.keys(vA)), NN(Object.keys(aA)))),
              K1 = [],
              c1 = XJ($1),
              u0;
            try {
              for (c1.s(); !(u0 = c1.n()).done;) {
                var $Q = u0.value;
                if (vA[$Q] !== aA[$Q]) K1.push($Q)
              }
            } catch (X9) {
              c1.e(X9)
            } finally {
              c1.f()
            }
            return K1
          }

          function lVA(vA, aA) {
            switch (aA.tag) {
              case n1:
              case W9:
              case ZQ:
              case D4:
              case GI:
              case M2:
                var $1 = 1;
                return (yK(aA) & $1) === $1;
              default:
                return vA.memoizedProps !== aA.memoizedProps || vA.memoizedState !== aA.memoizedState || vA.ref !== aA.ref
            }
          }
          var kz = [],
            ku = [],
            cx = [],
            OBA = [],
            Hs = new Map,
            RBA = 0,
            yu = null;

          function U7(vA) {
            kz.push(vA)
          }

          function xu() {
            if (yz) {
              if (vN != null && vN.durations.length > 0) return !1
            }
            return kz.length === 0 && ku.length === 0 && cx.length === 0 && yu === null
          }

          function iVA(vA) {
            if (xu()) return;
            if (OBA !== null) OBA.push(vA);
            else b.emit("operations", vA)
          }
          var Cs = null;

          function A_A() {
            if (Cs !== null) clearTimeout(Cs), Cs = null
          }

          function HW1() {
            A_A(), Cs = setTimeout(function() {
              if (Cs = null, kz.length > 0) return;
              if (nVA(), xu()) return;
              var vA = Array(3 + kz.length);
              vA[0] = a, vA[1] = HJ, vA[2] = 0;
              for (var aA = 0; aA < kz.length; aA++) vA[3 + aA] = kz[aA];
              iVA(vA), kz.length = 0
            }, 1000)
          }

          function CW1() {
            p6.clear(), HX.forEach(function(vA, aA) {
              var $1 = OY.get(aA);
              if ($1 != null) p6.add($1)
            }), DF.forEach(function(vA, aA) {
              var $1 = OY.get(aA);
              if ($1 != null) p6.add($1)
            }), nVA()
          }

          function Q_A(vA, aA, $1, K1) {
            var c1 = 0,
              u0 = K1.get(aA),
              $Q = $1.get(vA);
            if ($Q != null)
              if (u0 == null) u0 = $Q, K1.set(aA, $Q);
              else {
                var X9 = u0;
                $Q.forEach(function(q9, r2) {
                  var N9 = X9.get(r2) || 0;
                  X9.set(r2, N9 + q9)
                })
              } if (!Pz(vA)) {
              if (u0 != null) u0.forEach(function(q9) {
                c1 += q9
              })
            }
            return $1.delete(vA), c1
          }

          function nVA() {
            A_A(), p6.forEach(function(vA) {
              var aA = _z(vA);
              if (aA === null);
              else {
                var $1 = Q_A(vA, aA, YI, HX),
                  K1 = Q_A(vA, aA, RG, DF);
                U7(N), U7(aA), U7($1), U7(K1)
              }
              YI.delete(vA), RG.delete(vA)
            }), p6.clear()
          }

          function px(vA) {
            if (nVA(), xu()) return;
            var aA = ku.length + cx.length + (yu === null ? 0 : 1),
              $1 = Array(3 + RBA + (aA > 0 ? 2 + aA : 0) + kz.length),
              K1 = 0;
            if ($1[K1++] = a, $1[K1++] = HJ, $1[K1++] = RBA, Hs.forEach(function(X9, q9) {
                var r2 = X9.encodedString,
                  N9 = r2.length;
                $1[K1++] = N9;
                for (var W6 = 0; W6 < N9; W6++) $1[K1 + W6] = r2[W6];
                K1 += N9
              }), aA > 0) {
              $1[K1++] = U, $1[K1++] = aA;
              for (var c1 = ku.length - 1; c1 >= 0; c1--) $1[K1++] = ku[c1];
              for (var u0 = 0; u0 < cx.length; u0++) $1[K1 + u0] = cx[u0];
              if (K1 += cx.length, yu !== null) $1[K1] = yu, K1++
            }
            for (var $Q = 0; $Q < kz.length; $Q++) $1[K1 + $Q] = kz[$Q];
            K1 += kz.length, iVA($1), kz.length = 0, ku.length = 0, cx.length = 0, yu = null, Hs.clear(), RBA = 0
          }

          function B_A(vA) {
            if (vA === null) return 0;
            var aA = Hs.get(vA);
            if (aA !== void 0) return aA.id;
            var $1 = Hs.size + 1,
              K1 = SK(vA);
            return Hs.set(vA, {
              encodedString: K1,
              id: $1
            }), RBA += K1.length + 1, $1
          }

          function G_A(vA, aA) {
            var $1 = vA.tag === p4,
              K1 = l$(vA);
            if (H) JQ("recordMount()", vA, aA);
            var c1 = vA.hasOwnProperty("_debugOwner"),
              u0 = vA.hasOwnProperty("treeBaseDuration"),
              $Q = 0;
            if (u0) {
              if ($Q = y, typeof OG === "function") $Q |= v
            }
            if ($1) {
              if (U7(E), U7(K1), U7(x$), U7((vA.mode & S1) !== 0 ? 1 : 0), U7($Q), U7(S1 !== 0 ? 1 : 0), U7(c1 ? 1 : 0), yz) {
                if (vu !== null) vu.set(K1, AFA(vA))
              }
            } else {
              var X9 = vA.key,
                q9 = Y1(vA),
                r2 = n3(vA),
                N9 = vA._debugOwner,
                W6 = N9 != null ? l$(N9) : 0,
                CJ = aA ? Sz(aA) : 0,
                $7 = B_A(q9),
                CX = X9 === null ? null : String(X9),
                KH = B_A(CX);
              if (U7(E), U7(K1), U7(r2), U7(CJ), U7(W6), U7($7), U7(KH), (vA.mode & S1) !== 0 && (aA.mode & S1) === 0) U7(T), U7(K1), U7(C8)
            }
            if (u0) mx.set(K1, HJ), I_A(vA)
          }

          function aVA(vA, aA) {
            if (H) JQ("recordUnmount()", vA, null, aA ? "unmount is simulated" : "");
            if (IW !== null) {
              if (vA === IW || vA === IW.alternate) Rj(null)
            }
            var $1 = _z(vA);
            if ($1 === null) return;
            var K1 = $1,
              c1 = vA.tag === p4;
            if (c1) yu = K1;
            else if (!Pz(vA))
              if (aA) cx.push(K1);
              else ku.push(K1);
            if (!vA._debugNeedsRemount) {
              WW1(vA);
              var u0 = vA.hasOwnProperty("treeBaseDuration");
              if (u0) mx.delete(K1), jz.delete(K1)
            }
          }

          function FH(vA, aA, $1, K1) {
            var c1 = vA;
            while (c1 !== null) {
              if (l$(c1), H) JQ("mountFiberRecursively()", c1, aA);
              var u0 = n4(c1),
                $Q = !Pz(c1);
              if ($Q) G_A(c1, aA);
              if (b8) {
                if (K1) {
                  var X9 = n3(c1);
                  if (X9 === q3) M3.add(c1.stateNode), K1 = !1
                }
              }
              var q9 = c1.tag === z1.SuspenseComponent;
              if (q9) {
                var r2 = c1.memoizedState !== null;
                if (r2) {
                  var N9 = c1.child,
                    W6 = N9 ? N9.sibling : null,
                    CJ = W6 ? W6.child : null;
                  if (CJ !== null) FH(CJ, $Q ? c1 : aA, !0, K1)
                } else {
                  var $7 = null,
                    CX = VJ === -1;
                  if (CX) $7 = c1.child;
                  else if (c1.child !== null) $7 = c1.child.child;
                  if ($7 !== null) FH($7, $Q ? c1 : aA, !0, K1)
                }
              } else if (c1.child !== null) FH(c1.child, $Q ? c1 : aA, !0, K1);
              hW1(u0), c1 = $1 ? c1.sibling : null
            }
          }

          function Z_A(vA) {
            if (H) JQ("unmountFiberChildrenRecursively()", vA);
            var aA = vA.tag === z1.SuspenseComponent && vA.memoizedState !== null,
              $1 = vA.child;
            if (aA) {
              var K1 = vA.child,
                c1 = K1 ? K1.sibling : null;
              $1 = c1 ? c1.child : null
            }
            while ($1 !== null) {
              if ($1.return !== null) Z_A($1), aVA($1, !0);
              $1 = $1.sibling
            }
          }

          function I_A(vA) {
            var aA = Sz(vA),
              $1 = vA.actualDuration,
              K1 = vA.treeBaseDuration;
            if (jz.set(aA, K1 || 0), yz) {
              var c1 = vA.alternate;
              if (c1 == null || K1 !== c1.treeBaseDuration) {
                var u0 = Math.floor((K1 || 0) * 1000);
                U7(w), U7(aA), U7(u0)
              }
              if (c1 == null || lVA(c1, vA)) {
                if ($1 != null) {
                  var $Q = $1,
                    X9 = vA.child;
                  while (X9 !== null) $Q -= X9.actualDuration || 0, X9 = X9.sibling;
                  var q9 = vN;
                  if (q9.durations.push(aA, $1, $Q), q9.maxActualDuration = Math.max(q9.maxActualDuration, $1), ix) {
                    var r2 = XW1(c1, vA);
                    if (r2 !== null) {
                      if (q9.changeDescriptions !== null) q9.changeDescriptions.set(aA, r2)
                    }
                    oSA(vA)
                  }
                }
              }
            }
          }

          function EW1(vA, aA) {
            if (H) JQ("recordResetChildren()", aA, vA);
            var $1 = [],
              K1 = aA;
            while (K1 !== null) Y_A(K1, $1), K1 = K1.sibling;
            var c1 = $1.length;
            if (c1 < 2) return;
            U7(q), U7(Sz(vA)), U7(c1);
            for (var u0 = 0; u0 < $1.length; u0++) U7($1[u0])
          }

          function Y_A(vA, aA) {
            if (!Pz(vA)) aA.push(Sz(vA));
            else {
              var $1 = vA.child,
                K1 = vA.tag === v7 && vA.memoizedState !== null;
              if (K1) {
                var c1 = vA.child,
                  u0 = c1 ? c1.sibling : null,
                  $Q = u0 ? u0.child : null;
                if ($Q !== null) $1 = $Q
              }
              while ($1 !== null) Y_A($1, aA), $1 = $1.sibling
            }
          }

          function sVA(vA, aA, $1, K1) {
            var c1 = l$(vA);
            if (H) JQ("updateFiberRecursively()", vA, $1);
            if (b8) {
              var u0 = n3(vA);
              if (K1) {
                if (u0 === q3) M3.add(vA.stateNode), K1 = !1
              } else if (u0 === oW || u0 === sG || u0 === jK || u0 === GJ || u0 === ZF) K1 = lVA(aA, vA)
            }
            if (bK !== null && bK.id === c1 && lVA(aA, vA)) Es = !0;
            var $Q = !Pz(vA),
              X9 = vA.tag === v7,
              q9 = !1,
              r2 = X9 && aA.memoizedState !== null,
              N9 = X9 && vA.memoizedState !== null;
            if (r2 && N9) {
              var W6 = vA.child,
                CJ = W6 ? W6.sibling : null,
                $7 = aA.child,
                CX = $7 ? $7.sibling : null;
              if (CX == null && CJ != null) FH(CJ, $Q ? vA : $1, !0, K1), q9 = !0;
              if (CJ != null && CX != null && sVA(CJ, CX, vA, K1)) q9 = !0
            } else if (r2 && !N9) {
              var KH = vA.child;
              if (KH !== null) FH(KH, $Q ? vA : $1, !0, K1);
              q9 = !0
            } else if (!r2 && N9) {
              Z_A(aA);
              var HF = vA.child,
                FR = HF ? HF.sibling : null;
              if (FR != null) FH(FR, $Q ? vA : $1, !0, K1), q9 = !0
            } else if (vA.child !== aA.child) {
              var MZ = vA.child,
                EX = aA.child;
              while (MZ) {
                if (MZ.alternate) {
                  var Pj = MZ.alternate;
                  if (sVA(MZ, Pj, $Q ? vA : $1, K1)) q9 = !0;
                  if (Pj !== EX) q9 = !0
                } else FH(MZ, $Q ? vA : $1, !1, K1), q9 = !0;
                if (MZ = MZ.sibling, !q9 && EX !== null) EX = EX.sibling
              }
              if (EX !== null) q9 = !0
            } else if (b8) {
              if (K1) {
                var mu = W_A(Sz(vA));
                mu.forEach(function(hC) {
                  M3.add(hC.stateNode)
                })
              }
            }
            if ($Q) {
              var $s = vA.hasOwnProperty("treeBaseDuration");
              if ($s) I_A(vA)
            }
            if (q9)
              if ($Q) {
                var KR = vA.child;
                if (N9) {
                  var DR = vA.child;
                  KR = DR ? DR.sibling : null
                }
                if (KR != null) EW1(vA, KR);
                return !1
              } else return !0;
            else return !1
          }

          function zW1() {}

          function rVA(vA) {
            if (vA.memoizedInteractions != null) return !0;
            else if (vA.current != null && vA.current.hasOwnProperty("treeBaseDuration")) return !0;
            else return !1
          }

          function UW1() {
            var vA = OBA;
            if (OBA = null, vA !== null && vA.length > 0) vA.forEach(function(aA) {
              b.emit("operations", aA)
            });
            else {
              if (Mj !== null) Oj = !0;
              b.getFiberRoots(a).forEach(function(aA) {
                if (HJ = l$(aA.current), PBA(HJ, aA.current), yz && rVA(aA)) vN = {
                  changeDescriptions: ix ? new Map : null,
                  durations: [],
                  commitTime: xx() - eVA,
                  maxActualDuration: 0,
                  priorityLevel: null,
                  updaters: J_A(aA),
                  effectDuration: null,
                  passiveEffectDuration: null
                };
                FH(aA.current, null, !1, !1), px(aA), HJ = -1
              })
            }
          }

          function J_A(vA) {
            return vA.memoizedUpdaters != null ? Array.from(vA.memoizedUpdaters).filter(function(aA) {
              return _z(aA) !== null
            }).map(lx) : null
          }

          function $W1(vA) {
            if (!Ds.has(vA)) aVA(vA, !1)
          }

          function wW1(vA) {
            if (yz && rVA(vA)) {
              if (vN !== null) {
                var aA = _B(vA),
                  $1 = aA.effectDuration,
                  K1 = aA.passiveEffectDuration;
                vN.effectDuration = $1, vN.passiveEffectDuration = K1
              }
            }
          }

          function qW1(vA, aA) {
            var $1 = vA.current,
              K1 = $1.alternate;
            if (rSA(), HJ = l$($1), Mj !== null) Oj = !0;
            if (b8) M3.clear();
            var c1 = rVA(vA);
            if (yz && c1) vN = {
              changeDescriptions: ix ? new Map : null,
              durations: [],
              commitTime: xx() - eVA,
              maxActualDuration: 0,
              priorityLevel: aA == null ? null : mW1(aA),
              updaters: J_A(vA),
              effectDuration: null,
              passiveEffectDuration: null
            };
            if (K1) {
              var u0 = K1.memoizedState != null && K1.memoizedState.element != null && K1.memoizedState.isDehydrated !== !0,
                $Q = $1.memoizedState != null && $1.memoizedState.element != null && $1.memoizedState.isDehydrated !== !0;
              if (!u0 && $Q) PBA(HJ, $1), FH($1, null, !1, !1);
              else if (u0 && $Q) sVA($1, K1, null, !1);
              else if (u0 && !$Q) Tj(HJ), aVA($1, !1)
            } else PBA(HJ, $1), FH($1, null, !1, !1);
            if (yz && c1) {
              if (!xu()) {
                var X9 = gu.get(HJ);
                if (X9 != null) X9.push(vN);
                else gu.set(HJ, [vN])
              }
            }
            if (px(vA), b8) b.emit("traceUpdates", M3);
            HJ = -1
          }

          function W_A(vA) {
            var aA = [],
              $1 = VR(vA);
            if (!$1) return aA;
            var K1 = $1;
            while (!0) {
              if (K1.tag === z7 || K1.tag === l4) aA.push(K1);
              else if (K1.child) {
                K1.child.return = K1, K1 = K1.child;
                continue
              }
              if (K1 === $1) return aA;
              while (!K1.sibling) {
                if (!K1.return || K1.return === $1) return aA;
                K1 = K1.return
              }
              K1.sibling.return = K1.return, K1 = K1.sibling
            }
            return aA
          }

          function X_A(vA) {
            try {
              var aA = VR(vA);
              if (aA === null) return null;
              var $1 = W_A(vA);
              return $1.map(function(K1) {
                return K1.stateNode
              }).filter(Boolean)
            } catch (K1) {
              return null
            }
          }

          function NW1(vA) {
            var aA = OY.get(vA);
            return aA != null ? Y1(aA) : null
          }

          function LW1(vA) {
            return c.findFiberByHostInstance(vA)
          }

          function V_A(vA) {
            var aA = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
              $1 = c.findFiberByHostInstance(vA);
            if ($1 != null) {
              if (aA)
                while ($1 !== null && Pz($1)) $1 = $1.return;
              return Sz($1)
            }
            return null
          }

          function oVA(vA) {
            if (F_A(vA) !== vA) throw Error("Unable to find node on an unmounted component.")
          }

          function F_A(vA) {
            var aA = vA,
              $1 = vA;
            if (!vA.alternate) {
              var K1 = aA;
              do {
                aA = K1;
                var c1 = 2,
                  u0 = 4096;
                if ((aA.flags & (c1 | u0)) !== 0) $1 = aA.return;
                K1 = aA.return
              } while (K1)
            } else
              while (aA.return) aA = aA.return;
            if (aA.tag === p4) return $1;
            return null
          }

          function VR(vA) {
            var aA = OY.get(vA);
            if (aA == null) return console.warn('Could not find Fiber with id "'.concat(vA, '"')), null;
            var $1 = aA.alternate;
            if (!$1) {
              var K1 = F_A(aA);
              if (K1 === null) throw Error("Unable to find node on an unmounted component.");
              if (K1 !== aA) return null;
              return aA
            }
            var c1 = aA,
              u0 = $1;
            while (!0) {
              var $Q = c1.return;
              if ($Q === null) break;
              var X9 = $Q.alternate;
              if (X9 === null) {
                var q9 = $Q.return;
                if (q9 !== null) {
                  c1 = u0 = q9;
                  continue
                }
                break
              }
              if ($Q.child === X9.child) {
                var r2 = $Q.child;
                while (r2) {
                  if (r2 === c1) return oVA($Q), aA;
                  if (r2 === u0) return oVA($Q), $1;
                  r2 = r2.sibling
                }
                throw Error("Unable to find node on an unmounted component.")
              }
              if (c1.return !== u0.return) c1 = $Q, u0 = X9;
              else {
                var N9 = !1,
                  W6 = $Q.child;
                while (W6) {
                  if (W6 === c1) {
                    N9 = !0, c1 = $Q, u0 = X9;
                    break
                  }
                  if (W6 === u0) {
                    N9 = !0, u0 = $Q, c1 = X9;
                    break
                  }
                  W6 = W6.sibling
                }
                if (!N9) {
                  W6 = X9.child;
                  while (W6) {
                    if (W6 === c1) {
                      N9 = !0, c1 = X9, u0 = $Q;
                      break
                    }
                    if (W6 === u0) {
                      N9 = !0, u0 = X9, c1 = $Q;
                      break
                    }
                    W6 = W6.sibling
                  }
                  if (!N9) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.")
                }
              }
              if (c1.alternate !== u0) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.")
            }
            if (c1.tag !== p4) throw Error("Unable to find node on an unmounted component.");
            if (c1.stateNode.current === c1) return aA;
            return $1
          }

          function MW1(vA, aA) {
            if (zs(vA)) window.$attribute = z0(bK, aA)
          }

          function OW1(vA) {
            var aA = OY.get(vA);
            if (aA == null) {
              console.warn('Could not find Fiber with id "'.concat(vA, '"'));
              return
            }
            var {
              elementType: $1,
              tag: K1,
              type: c1
            } = aA;
            switch (K1) {
              case n1:
              case F8:
              case L3:
              case W9:
                s.$type = c1;
                break;
              case M2:
                s.$type = c1.render;
                break;
              case D4:
              case GI:
                s.$type = $1 != null && $1.type != null ? $1.type : c1;
                break;
              default:
                s.$type = null;
                break
            }
          }

          function lx(vA) {
            return {
              displayName: Y1(vA) || "Anonymous",
              id: Sz(vA),
              key: vA.key,
              type: n3(vA)
            }
          }

          function RW1(vA) {
            var aA = VR(vA);
            if (aA == null) return null;
            var $1 = aA._debugOwner,
              K1 = [lx(aA)];
            if ($1) {
              var c1 = $1;
              while (c1 !== null) K1.unshift(lx(c1)), c1 = c1._debugOwner || null
            }
            return K1
          }

          function TW1(vA) {
            var aA = null,
              $1 = null,
              K1 = VR(vA);
            if (K1 !== null) {
              if (aA = K1.stateNode, K1.memoizedProps !== null) $1 = K1.memoizedProps.style
            }
            return {
              instance: aA,
              style: $1
            }
          }

          function K_A(vA) {
            var {
              tag: aA,
              type: $1
            } = vA;
            switch (aA) {
              case n1:
              case F8:
                var K1 = vA.stateNode;
                return typeof $1.getDerivedStateFromError === "function" || K1 !== null && typeof K1.componentDidCatch === "function";
              default:
                return !1
            }
          }

          function D_A(vA) {
            var aA = vA.return;
            while (aA !== null) {
              if (K_A(aA)) return _z(aA);
              aA = aA.return
            }
            return null
          }

          function H_A(vA) {
            var aA = VR(vA);
            if (aA == null) return null;
            var {
              _debugOwner: $1,
              _debugSource: K1,
              stateNode: c1,
              key: u0,
              memoizedProps: $Q,
              memoizedState: X9,
              dependencies: q9,
              tag: r2,
              type: N9
            } = aA, W6 = n3(aA), CJ = (r2 === W9 || r2 === GI || r2 === M2) && (!!X9 || !!q9), $7 = !CJ && r2 !== l1, CX = B1(N9), KH = !1, HF = null;
            if (r2 === n1 || r2 === W9 || r2 === F8 || r2 === L3 || r2 === D4 || r2 === M2 || r2 === GI) {
              if (KH = !0, c1 && c1.context != null) {
                var FR = W6 === sG && !(N9.contextTypes || N9.contextType);
                if (!FR) HF = c1.context
              }
            } else if (CX === Ez || CX === UN) {
              var MZ = N9._context || N9;
              HF = MZ._currentValue || null;
              var EX = aA.return;
              while (EX !== null) {
                var Pj = EX.type,
                  mu = B1(Pj);
                if (mu === zz || mu === wN) {
                  var $s = Pj._context || Pj.context;
                  if ($s === MZ) {
                    HF = EX.memoizedProps.value;
                    break
                  }
                }
                EX = EX.return
              }
            }
            var KR = !1;
            if (HF !== null) KR = !!N9.contextTypes, HF = {
              value: HF
            };
            var DR = null;
            if ($1) {
              DR = [];
              var hC = $1;
              while (hC !== null) DR.push(lx(hC)), hC = hC._debugOwner || null
            }
            var xz = r2 === v7 && X9 !== null,
              K8 = null;
            if (CJ) {
              var jBA = {};
              for (var DH in console) try {
                jBA[DH] = console[DH], console[DH] = function() {}
              } catch (pW1) {}
              try {
                K8 = (0, ZX.inspectHooksOfFiber)(aA, c.currentDispatcherRef, !0)
              } finally {
                for (var BFA in jBA) try {
                  console[BFA] = jBA[BFA]
                } catch (pW1) {}
              }
            }
            var M_A = null,
              u5 = aA;
            while (u5.return !== null) u5 = u5.return;
            var GFA = u5.stateNode;
            if (GFA != null && GFA._debugRootType !== null) M_A = GFA._debugRootType;
            var O_A = HX.get(vA) || new Map,
              SBA = DF.get(vA) || new Map,
              ZFA = !1,
              _BA;
            if (K_A(aA)) {
              var cW1 = 128;
              ZFA = (aA.flags & cW1) !== 0 || i$.get(vA) === !0, _BA = ZFA ? vA : D_A(aA)
            } else _BA = D_A(aA);
            var R_A = {
              stylex: null
            };
            if (IX) {
              if ($Q != null && $Q.hasOwnProperty("xstyle")) R_A.stylex = YX($Q.xstyle)
            }
            return {
              id: vA,
              canEditHooks: typeof ZI === "function",
              canEditFunctionProps: typeof XH === "function",
              canEditHooksAndDeletePaths: typeof II === "function",
              canEditHooksAndRenamePaths: typeof c$ === "function",
              canEditFunctionPropsDeletePaths: typeof p$ === "function",
              canEditFunctionPropsRenamePaths: typeof bC === "function",
              canToggleError: Su && _BA != null,
              isErrored: ZFA,
              targetErrorBoundaryID: _BA,
              canToggleSuspense: Ks && (!xz || uu.has(vA)),
              canViewSource: KH,
              hasLegacyContext: KR,
              key: u0 != null ? u0 : null,
              displayName: Y1(aA),
              type: W6,
              context: HF,
              hooks: K8,
              props: $Q,
              state: $7 ? X9 : null,
              errors: Array.from(O_A.entries()),
              warnings: Array.from(SBA.entries()),
              owners: DR,
              source: K1 || null,
              rootType: M_A,
              rendererPackageName: c.rendererPackageName,
              rendererVersion: c.version,
              plugins: R_A
            }
          }
          var bK = null,
            Es = !1,
            TBA = {};

          function zs(vA) {
            return bK !== null && bK.id === vA
          }

          function PW1(vA) {
            return zs(vA) && !Es
          }

          function jW1(vA) {
            var aA = TBA;
            vA.forEach(function($1) {
              if (!aA[$1]) aA[$1] = {};
              aA = aA[$1]
            })
          }

          function Lj(vA, aA) {
            return function(K1) {
              switch (aA) {
                case "hooks":
                  if (K1.length === 1) return !0;
                  if (K1[K1.length - 2] === "hookSource" && K1[K1.length - 1] === "fileName") return !0;
                  if (K1[K1.length - 1] === "subHooks" || K1[K1.length - 2] === "subHooks") return !0;
                  break;
                default:
                  break
              }
              var c1 = vA === null ? TBA : TBA[vA];
              if (!c1) return !1;
              for (var u0 = 0; u0 < K1.length; u0++)
                if (c1 = c1[K1[u0]], !c1) return !1;
              return !0
            }
          }

          function SW1(vA) {
            var {
              hooks: aA,
              id: $1,
              props: K1
            } = vA, c1 = OY.get($1);
            if (c1 == null) {
              console.warn('Could not find Fiber with id "'.concat($1, '"'));
              return
            }
            var {
              elementType: u0,
              stateNode: $Q,
              tag: X9,
              type: q9
            } = c1;
            switch (X9) {
              case n1:
              case F8:
              case L3:
                s.$r = $Q;
                break;
              case W9:
                s.$r = {
                  hooks: aA,
                  props: K1,
                  type: q9
                };
                break;
              case M2:
                s.$r = {
                  hooks: aA,
                  props: K1,
                  type: q9.render
                };
                break;
              case D4:
              case GI:
                s.$r = {
                  hooks: aA,
                  props: K1,
                  type: u0 != null && u0.type != null ? u0.type : q9
                };
                break;
              default:
                s.$r = null;
                break
            }
          }

          function C_A(vA, aA, $1) {
            if (zs(vA)) {
              var K1 = z0(bK, aA),
                c1 = "$reactTemp".concat($1);
              window[c1] = K1, console.log(c1), console.log(K1)
            }
          }

          function E_A(vA, aA) {
            if (zs(vA)) {
              var $1 = z0(bK, aA);
              return w9($1)
            }
          }

          function tVA(vA, aA, $1, K1) {
            if ($1 !== null) jW1($1);
            if (zs(aA) && !K1) {
              if (!Es)
                if ($1 !== null) {
                  var c1 = null;
                  if ($1[0] === "hooks") c1 = "hooks";
                  return {
                    id: aA,
                    responseID: vA,
                    type: "hydrated-path",
                    path: $1,
                    value: IJ(z0(bK, $1), Lj(null, c1), $1)
                  }
                } else return {
                  id: aA,
                  responseID: vA,
                  type: "no-change"
                }
            } else TBA = {};
            Es = !1;
            try {
              bK = H_A(aA)
            } catch (N9) {
              if (N9.name === "ReactDebugToolsRenderError") {
                var u0 = "Error rendering inspected element.",
                  $Q;
                if (console.error(u0 + `

`, N9), N9.cause != null) {
                  var X9 = VR(aA),
                    q9 = X9 != null ? Y1(X9) : null;
                  if (console.error("React DevTools encountered an error while trying to inspect hooks. This is most likely caused by an error in current inspected component" + (q9 != null ? ': "'.concat(q9, '".') : ".") + `
The error thrown in the component is: 

`, N9.cause), N9.cause instanceof Error) u0 = N9.cause.message || u0, $Q = N9.cause.stack
                }
                return {
                  type: "error",
                  errorType: "user",
                  id: aA,
                  responseID: vA,
                  message: u0,
                  stack: $Q
                }
              }
              if (N9.name === "ReactDebugToolsUnsupportedHookError") return {
                type: "error",
                errorType: "unknown-hook",
                id: aA,
                responseID: vA,
                message: "Unsupported hook in the react-debug-tools package: " + N9.message
              };
              return console.error(`Error inspecting element.

`, N9), {
                type: "error",
                errorType: "uncaught",
                id: aA,
                responseID: vA,
                message: N9.message,
                stack: N9.stack
              }
            }
            if (bK === null) return {
              id: aA,
              responseID: vA,
              type: "not-found"
            };
            SW1(bK);
            var r2 = yx({}, bK);
            return r2.context = IJ(r2.context, Lj("context", null)), r2.hooks = IJ(r2.hooks, Lj("hooks", "hooks")), r2.props = IJ(r2.props, Lj("props", null)), r2.state = IJ(r2.state, Lj("state", null)), {
              id: aA,
              responseID: vA,
              type: "full-data",
              value: r2
            }
          }

          function z_A(vA) {
            var aA = PW1(vA) ? bK : H_A(vA);
            if (aA === null) {
              console.warn('Could not find Fiber with id "'.concat(vA, '"'));
              return
            }
            var $1 = typeof console.groupCollapsed === "function";
            if ($1) console.groupCollapsed("[Click to expand] %c<".concat(aA.displayName || "Component", " />"), "color: var(--dom-tag-name-color); font-weight: normal;");
            if (aA.props !== null) console.log("Props:", aA.props);
            if (aA.state !== null) console.log("State:", aA.state);
            if (aA.hooks !== null) console.log("Hooks:", aA.hooks);
            var K1 = X_A(vA);
            if (K1 !== null) console.log("Nodes:", K1);
            if (aA.source !== null) console.log("Location:", aA.source);
            if (window.chrome || /firefox/i.test(navigator.userAgent)) console.log("Right-click any value to save it as a global variable for further inspection.");
            if ($1) console.groupEnd()
          }

          function U_A(vA, aA, $1, K1) {
            var c1 = VR(aA);
            if (c1 !== null) {
              var u0 = c1.stateNode;
              switch (vA) {
                case "context":
                  switch (K1 = K1.slice(1), c1.tag) {
                    case n1:
                      if (K1.length === 0);
                      else rQ(u0.context, K1);
                      u0.forceUpdate();
                      break;
                    case W9:
                      break
                  }
                  break;
                case "hooks":
                  if (typeof II === "function") II(c1, $1, K1);
                  break;
                case "props":
                  if (u0 === null) {
                    if (typeof p$ === "function") p$(c1, K1)
                  } else c1.pendingProps = d1(u0.props, K1), u0.forceUpdate();
                  break;
                case "state":
                  rQ(u0.state, K1), u0.forceUpdate();
                  break
              }
            }
          }

          function $_A(vA, aA, $1, K1, c1) {
            var u0 = VR(aA);
            if (u0 !== null) {
              var $Q = u0.stateNode;
              switch (vA) {
                case "context":
                  switch (K1 = K1.slice(1), c1 = c1.slice(1), u0.tag) {
                    case n1:
                      if (K1.length === 0);
                      else T2($Q.context, K1, c1);
                      $Q.forceUpdate();
                      break;
                    case W9:
                      break
                  }
                  break;
                case "hooks":
                  if (typeof c$ === "function") c$(u0, $1, K1, c1);
                  break;
                case "props":
                  if ($Q === null) {
                    if (typeof bC === "function") bC(u0, K1, c1)
                  } else u0.pendingProps = P0($Q.props, K1, c1), $Q.forceUpdate();
                  break;
                case "state":
                  T2($Q.state, K1, c1), $Q.forceUpdate();
                  break
              }
            }
          }

          function w_A(vA, aA, $1, K1, c1) {
            var u0 = VR(aA);
            if (u0 !== null) {
              var $Q = u0.stateNode;
              switch (vA) {
                case "context":
                  switch (K1 = K1.slice(1), u0.tag) {
                    case n1:
                      if (K1.length === 0) $Q.context = c1;
                      else s9($Q.context, K1, c1);
                      $Q.forceUpdate();
                      break;
                    case W9:
                      break
                  }
                  break;
                case "hooks":
                  if (typeof ZI === "function") ZI(u0, $1, K1, c1);
                  break;
                case "props":
                  switch (u0.tag) {
                    case n1:
                      u0.pendingProps = U0($Q.props, K1, c1), $Q.forceUpdate();
                      break;
                    default:
                      if (typeof XH === "function") XH(u0, K1, c1);
                      break
                  }
                  break;
                case "state":
                  switch (u0.tag) {
                    case n1:
                      s9($Q.state, K1, c1), $Q.forceUpdate();
                      break
                  }
                  break
              }
            }
          }
          var vN = null,
            vu = null,
            bu = null,
            fu = null,
            hu = null,
            yz = !1,
            eVA = 0,
            ix = !1,
            gu = null;

          function _W1() {
            var vA = [];
            if (gu === null) throw Error("getProfilingData() called before any profiling data was recorded");
            gu.forEach(function(q9, r2) {
              var N9 = [],
                W6 = [],
                CJ = vu !== null && vu.get(r2) || "Unknown";
              if (fu != null) fu.forEach(function($7, CX) {
                if (hu != null && hu.get(CX) === r2) W6.push([CX, $7])
              });
              q9.forEach(function($7, CX) {
                var {
                  changeDescriptions: KH,
                  durations: HF,
                  effectDuration: FR,
                  maxActualDuration: MZ,
                  passiveEffectDuration: EX,
                  priorityLevel: Pj,
                  commitTime: mu,
                  updaters: $s
                } = $7, KR = [], DR = [];
                for (var hC = 0; hC < HF.length; hC += 3) {
                  var xz = HF[hC];
                  KR.push([xz, HF[hC + 1]]), DR.push([xz, HF[hC + 2]])
                }
                N9.push({
                  changeDescriptions: KH !== null ? Array.from(KH.entries()) : null,
                  duration: MZ,
                  effectDuration: FR,
                  fiberActualDurations: KR,
                  fiberSelfDurations: DR,
                  passiveEffectDuration: EX,
                  priorityLevel: Pj,
                  timestamp: mu,
                  updaters: $s
                })
              }), vA.push({
                commitData: N9,
                displayName: CJ,
                initialTreeBaseDurations: W6,
                rootID: r2
              })
            });
            var aA = null;
            if (typeof NB === "function") {
              var $1 = NB();
              if ($1) {
                var {
                  batchUIDToMeasuresMap: K1,
                  internalModuleSourceToRanges: c1,
                  laneToLabelMap: u0,
                  laneToReactMeasureMap: $Q
                } = $1, X9 = eO($1, ["batchUIDToMeasuresMap", "internalModuleSourceToRanges", "laneToLabelMap", "laneToReactMeasureMap"]);
                aA = yx(yx({}, X9), {}, {
                  batchUIDToMeasuresKeyValueArray: Array.from(K1.entries()),
                  internalModuleSourceToRanges: Array.from(c1.entries()),
                  laneToLabelKeyValueArray: Array.from(u0.entries()),
                  laneToReactMeasureKeyValueArray: Array.from($Q.entries())
                })
              }
            }
            return {
              dataForRoots: vA,
              rendererID: a,
              timelineData: aA
            }
          }

          function q_A(vA) {
            if (yz) return;
            if (ix = vA, vu = new Map, fu = new Map(jz), hu = new Map(mx), bu = new Map, b.getFiberRoots(a).forEach(function(aA) {
                var $1 = Sz(aA.current);
                if (vu.set($1, AFA(aA.current)), vA) eSA(aA.current)
              }), yz = !0, eVA = xx(), gu = new Map, h2 !== null) h2(!0)
          }

          function kW1() {
            if (yz = !1, ix = !1, h2 !== null) h2(!1)
          }
          if (X1(o) === "true") q_A(X1(m) === "true");

          function N_A() {
            return null
          }
          var i$ = new Map;

          function yW1(vA) {
            if (typeof KJ !== "function") throw Error("Expected overrideError() to not get called for earlier React versions.");
            var aA = _z(vA);
            if (aA === null) return null;
            var $1 = null;
            if (i$.has(aA)) {
              if ($1 = i$.get(aA), $1 === !1) {
                if (i$.delete(aA), i$.size === 0) KJ(N_A)
              }
            }
            return $1
          }

          function xW1(vA, aA) {
            if (typeof KJ !== "function" || typeof yN !== "function") throw Error("Expected overrideError() to not get called for earlier React versions.");
            if (i$.set(vA, aA), i$.size === 1) KJ(yW1);
            var $1 = OY.get(vA);
            if ($1 != null) yN($1)
          }

          function vW1() {
            return !1
          }
          var uu = new Set;

          function bW1(vA) {
            var aA = _z(vA);
            return aA !== null && uu.has(aA)
          }

          function fW1(vA, aA) {
            if (typeof VH !== "function" || typeof yN !== "function") throw Error("Expected overrideSuspense() to not get called for earlier React versions.");
            if (aA) {
              if (uu.add(vA), uu.size === 1) VH(bW1)
            } else if (uu.delete(vA), uu.size === 0) VH(vW1);
            var $1 = OY.get(vA);
            if ($1 != null) yN($1)
          }
          var Mj = null,
            IW = null,
            Us = -1,
            Oj = !1;

          function Rj(vA) {
            if (vA === null) IW = null, Us = -1, Oj = !1;
            Mj = vA
          }

          function n4(vA) {
            if (Mj === null || !Oj) return !1;
            var aA = vA.return,
              $1 = aA !== null ? aA.alternate : null;
            if (IW === aA || IW === $1 && $1 !== null) {
              var K1 = L_A(vA),
                c1 = Mj[Us + 1];
              if (c1 === void 0) throw Error("Expected to see a frame at the next depth.");
              if (K1.index === c1.index && K1.key === c1.key && K1.displayName === c1.displayName) {
                if (IW = vA, Us++, Us === Mj.length - 1) Oj = !1;
                else Oj = !0;
                return !1
              }
            }
            return Oj = !1, !0
          }

          function hW1(vA) {
            Oj = vA
          }
          var wV = new Map,
            TG = new Map;

          function PBA(vA, aA) {
            var $1 = AFA(aA),
              K1 = TG.get($1) || 0;
            TG.set($1, K1 + 1);
            var c1 = "".concat($1, ":").concat(K1);
            wV.set(vA, c1)
          }

          function Tj(vA) {
            var aA = wV.get(vA);
            if (aA === void 0) throw Error("Expected root pseudo key to be known.");
            var $1 = aA.slice(0, aA.lastIndexOf(":")),
              K1 = TG.get($1);
            if (K1 === void 0) throw Error("Expected counter to be known.");
            if (K1 > 1) TG.set($1, K1 - 1);
            else TG.delete($1);
            wV.delete(vA)
          }

          function AFA(vA) {
            var aA = null,
              $1 = null,
              K1 = vA.child;
            for (var c1 = 0; c1 < 3; c1++) {
              if (K1 === null) break;
              var u0 = Y1(K1);
              if (u0 !== null) {
                if (typeof K1.type === "function") aA = u0;
                else if ($1 === null) $1 = u0
              }
              if (aA !== null) break;
              K1 = K1.child
            }
            return aA || $1 || "Anonymous"
          }

          function L_A(vA) {
            var aA = vA.key,
              $1 = Y1(vA),
              K1 = vA.index;
            switch (vA.tag) {
              case p4:
                var c1 = Sz(vA),
                  u0 = wV.get(c1);
                if (u0 === void 0) throw Error("Expected mounted root to have known pseudo key.");
                $1 = u0;
                break;
              case z7:
                $1 = vA.type;
                break;
              default:
                break
            }
            return {
              displayName: $1,
              key: aA,
              index: K1
            }
          }

          function gW1(vA) {
            var aA = OY.get(vA);
            if (aA == null) return null;
            var $1 = [];
            while (aA !== null) $1.push(L_A(aA)), aA = aA.return;
            return $1.reverse(), $1
          }

          function uW1() {
            if (Mj === null) return null;
            if (IW === null) return null;
            var vA = IW;
            while (vA !== null && Pz(vA)) vA = vA.return;
            if (vA === null) return null;
            return {
              id: Sz(vA),
              isFullMatch: Us === Mj.length - 1
            }
          }
          var mW1 = function(aA) {
            if (aA == null) return "Unknown";
            switch (aA) {
              case FJ:
                return "Immediate";
              case UV:
                return "User-Blocking";
              case YB:
                return "Normal";
              case z2:
                return "Low";
              case A9:
                return "Idle";
              case ZG:
              default:
                return "Unknown"
            }
          };

          function QFA(vA) {
            b8 = vA
          }

          function dW1(vA) {
            return OY.has(vA)
          }
          return {
            cleanup: zW1,
            clearErrorsAndWarnings: ZW,
            clearErrorsForFiberID: xN,
            clearWarningsForFiberID: XR,
            getSerializedElementValueByPath: E_A,
            deletePath: U_A,
            findNativeNodesForFiberID: X_A,
            flushInitialOperations: UW1,
            getBestMatchForTrackedPath: uW1,
            getDisplayNameForFiberID: NW1,
            getFiberForNative: LW1,
            getFiberIDForNative: V_A,
            getInstanceAndStyle: TW1,
            getOwnersList: RW1,
            getPathForElement: gW1,
            getProfilingData: _W1,
            handleCommitFiberRoot: qW1,
            handleCommitFiberUnmount: $W1,
            handlePostCommitFiberRoot: wW1,
            hasFiberWithId: dW1,
            inspectElement: tVA,
            logElementToConsole: z_A,
            patchConsoleForStrictMode: $j,
            prepareViewAttributeSource: MW1,
            prepareViewElementSource: OW1,
            overrideError: xW1,
            overrideSuspense: fW1,
            overrideValueAtPath: w_A,
            renamePath: $_A,
            renderer: c,
            setTraceUpdatesEnabled: QFA,
            setTrackedPath: Rj,
            startProfiling: q_A,
            stopProfiling: kW1,
            storeAsGlobal: C_A,
            unpatchConsoleForStrictMode: hx,
            updateComponentFilters: $V
          }
        }

        function Qs(b) {
          return $u(b) || zj(b) || vx(b) || FX()
        }

        function FX() {
          throw TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function zj(b) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(b)) return Array.from(b)
        }

        function $u(b) {
          if (Array.isArray(b)) return MN(b)
        }

        function wu(b, a) {
          var c;
          if (typeof Symbol > "u" || b[Symbol.iterator] == null) {
            if (Array.isArray(b) || (c = vx(b)) || a && b && typeof b.length === "number") {
              if (c) b = c;
              var s = 0,
                r = function() {};
              return {
                s: r,
                n: function() {
                  if (s >= b.length) return {
                    done: !0
                  };
                  return {
                    done: !1,
                    value: b[s++]
                  }
                },
                e: function(z1) {
                  throw z1
                },
                f: r
              }
            }
            throw TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
          }
          var bA = !0,
            Y1 = !1,
            B1;
          return {
            s: function() {
              c = b[Symbol.iterator]()
            },
            n: function() {
              var z1 = c.next();
              return bA = z1.done, z1
            },
            e: function(z1) {
              Y1 = !0, B1 = z1
            },
            f: function() {
              try {
                if (!bA && c.return != null) c.return()
              } finally {
                if (Y1) throw B1
              }
            }
          }
        }

        function vx(b, a) {
          if (!b) return;
          if (typeof b === "string") return MN(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return MN(b, a)
        }

        function MN(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }
        var bx = ["error", "trace", "warn"],
          AR = "\x1B[2m%s\x1B[0m",
          qu = /\s{4}(in|at)\s{1}/,
          Bs = /:\d+:\d+(\n|$)/;

        function $BA(b) {
          return qu.test(b) || Bs.test(b)
        }
        var QR = /^%c/;

        function dVA(b, a) {
          return b.length >= 2 && QR.test(b[0]) && b[1] === "color: ".concat(fx(a) || "")
        }

        function fx(b) {
          switch (b) {
            case "warn":
              return z5.browserTheme === "light" ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";
            case "error":
              return z5.browserTheme === "light" ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";
            case "log":
            default:
              return z5.browserTheme === "light" ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)"
          }
        }
        var Uj = new Map,
          c6 = console,
          V8 = {};
        for (var RY in console) V8[RY] = console[RY];
        var MG = null,
          TY = !1;
        try {
          TY = global === void 0
        } catch (b) {}

        function VF(b) {
          c6 = b, V8 = {};
          for (var a in c6) V8[a] = console[a]
        }

        function BR(b, a) {
          var {
            currentDispatcherRef: c,
            getCurrentFiber: s,
            findFiberByHostInstance: r,
            version: bA
          } = b;
          if (typeof r !== "function") return;
          if (c != null && typeof s === "function") {
            var Y1 = SI(bA),
              B1 = Y1.ReactTypeOfWork;
            Uj.set(b, {
              currentDispatcherRef: c,
              getCurrentFiber: s,
              workTagMap: B1,
              onErrorOrWarning: a
            })
          }
        }
        var z5 = {
          appendComponentStack: !1,
          breakOnConsoleErrors: !1,
          showInlineWarningsAndErrors: !1,
          hideConsoleLogsInStrictMode: !1,
          browserTheme: "dark"
        };

        function GR(b) {
          var {
            appendComponentStack: a,
            breakOnConsoleErrors: c,
            showInlineWarningsAndErrors: s,
            hideConsoleLogsInStrictMode: r,
            browserTheme: bA
          } = b;
          if (z5.appendComponentStack = a, z5.breakOnConsoleErrors = c, z5.showInlineWarningsAndErrors = s, z5.hideConsoleLogsInStrictMode = r, z5.browserTheme = bA, a || c || s) {
            if (MG !== null) return;
            var Y1 = {};
            MG = function() {
              for (var uA in Y1) try {
                c6[uA] = Y1[uA]
              } catch (z1) {}
            }, bx.forEach(function(B1) {
              try {
                var uA = Y1[B1] = c6[B1].__REACT_DEVTOOLS_ORIGINAL_METHOD__ ? c6[B1].__REACT_DEVTOOLS_ORIGINAL_METHOD__ : c6[B1],
                  z1 = function() {
                    var l1 = !1;
                    for (var n1 = arguments.length, ZQ = Array(n1), TQ = 0; TQ < n1; TQ++) ZQ[TQ] = arguments[TQ];
                    if (B1 !== "log") {
                      if (z5.appendComponentStack) {
                        var M2 = ZQ.length > 0 ? ZQ[ZQ.length - 1] : null,
                          gQ = typeof M2 === "string" && $BA(M2);
                        l1 = !gQ
                      }
                    }
                    var W9 = z5.showInlineWarningsAndErrors && (B1 === "error" || B1 === "warn"),
                      p4 = wu(Uj.values()),
                      g5;
                    try {
                      for (p4.s(); !(g5 = p4.n()).done;) {
                        var kB = g5.value,
                          U5 = kB.currentDispatcherRef,
                          z7 = kB.getCurrentFiber,
                          l4 = kB.onErrorOrWarning,
                          F8 = kB.workTagMap,
                          L3 = z7();
                        if (L3 != null) try {
                          if (W9) {
                            if (typeof l4 === "function") l4(L3, B1, ZQ.slice())
                          }
                          if (l1) {
                            var jY = EV(F8, L3, U5);
                            if (jY !== "")
                              if (dVA(ZQ, B1)) ZQ[0] = "".concat(ZQ[0], " %s"), ZQ.push(jY);
                              else ZQ.push(jY)
                          }
                        } catch (D4) {
                          setTimeout(function() {
                            throw D4
                          }, 0)
                        } finally {
                          break
                        }
                      }
                    } catch (D4) {
                      p4.e(D4)
                    } finally {
                      p4.f()
                    }
                    if (z5.breakOnConsoleErrors) debugger;
                    uA.apply(void 0, ZQ)
                  };
                z1.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = uA, uA.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = z1, c6[B1] = z1
              } catch (S1) {}
            })
          } else ON()
        }

        function ON() {
          if (MG !== null) MG(), MG = null
        }
        var u$ = null;

        function $j() {
          if (ga) {
            var b = ["error", "group", "groupCollapsed", "info", "log", "trace", "warn"];
            if (u$ !== null) return;
            var a = {};
            u$ = function() {
              for (var s in a) try {
                c6[s] = a[s]
              } catch (r) {}
            }, b.forEach(function(c) {
              try {
                var s = a[c] = c6[c].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? c6[c].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : c6[c],
                  r = function() {
                    if (!z5.hideConsoleLogsInStrictMode) {
                      for (var Y1 = arguments.length, B1 = Array(Y1), uA = 0; uA < Y1; uA++) B1[uA] = arguments[uA];
                      if (TY) s(AR, j8.apply(void 0, B1));
                      else {
                        var z1 = fx(c);
                        if (z1) s.apply(void 0, Qs(Y9(B1, "color: ".concat(z1))));
                        else throw Error("Console color is not defined")
                      }
                    }
                  };
                r.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = s, s.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = r, c6[c] = r
              } catch (bA) {}
            })
          }
        }

        function hx() {
          if (ga) {
            if (u$ !== null) u$(), u$ = null
          }
        }

        function KX() {
          var b, a, c, s, r, bA = (b = GH(window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__)) !== null && b !== void 0 ? b : !0,
            Y1 = (a = GH(window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__)) !== null && a !== void 0 ? a : !1,
            B1 = (c = GH(window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__)) !== null && c !== void 0 ? c : !0,
            uA = (s = GH(window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__)) !== null && s !== void 0 ? s : !1,
            z1 = (r = SC(window.__REACT_DEVTOOLS_BROWSER_THEME__)) !== null && r !== void 0 ? r : "dark";
          GR({
            appendComponentStack: bA,
            breakOnConsoleErrors: Y1,
            showInlineWarningsAndErrors: B1,
            hideConsoleLogsInStrictMode: uA,
            browserTheme: z1
          })
        }

        function Nu(b) {
          window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ = b.appendComponentStack, window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ = b.breakOnConsoleErrors, window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ = b.showInlineWarningsAndErrors, window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ = b.hideConsoleLogsInStrictMode, window.__REACT_DEVTOOLS_BROWSER_THEME__ = b.browserTheme
        }

        function Gs() {
          window.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__ = {
            patchConsoleUsingWindowValues: KX,
            registerRendererWithConsole: BR
          }
        }

        function xK(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") xK = function(c) {
            return typeof c
          };
          else xK = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return xK(b)
        }

        function wj(b) {
          return Mu(b) || qz(b) || Lu(b) || qj()
        }

        function qj() {
          throw TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function Lu(b, a) {
          if (!b) return;
          if (typeof b === "string") return WH(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return WH(b, a)
        }

        function qz(b) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(b)) return Array.from(b)
        }

        function Mu(b) {
          if (Array.isArray(b)) return WH(b)
        }

        function WH(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }

        function v4(b, a) {
          if (!(b instanceof a)) throw TypeError("Cannot call a class as a function")
        }

        function Nj(b, a) {
          for (var c = 0; c < a.length; c++) {
            var s = a[c];
            if (s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s) s.writable = !0;
            Object.defineProperty(b, s.key, s)
          }
        }

        function Zs(b, a, c) {
          if (a) Nj(b.prototype, a);
          if (c) Nj(b, c);
          return b
        }

        function RN(b, a) {
          if (typeof a !== "function" && a !== null) throw TypeError("Super expression must either be null or a function");
          if (b.prototype = Object.create(a && a.prototype, {
              constructor: {
                value: b,
                writable: !0,
                configurable: !0
              }
            }), a) ZR(b, a)
        }

        function ZR(b, a) {
          return ZR = Object.setPrototypeOf || function(s, r) {
            return s.__proto__ = r, s
          }, ZR(b, a)
        }

        function DX(b) {
          var a = FF();
          return function() {
            var s = PN(b),
              r;
            if (a) {
              var bA = PN(this).constructor;
              r = Reflect.construct(s, arguments, bA)
            } else r = s.apply(this, arguments);
            return TN(this, r)
          }
        }

        function TN(b, a) {
          if (a && (xK(a) === "object" || typeof a === "function")) return a;
          return t5(b)
        }

        function t5(b) {
          if (b === void 0) throw ReferenceError("this hasn't been initialised - super() hasn't been called");
          return b
        }

        function FF() {
          if (typeof Reflect > "u" || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if (typeof Proxy === "function") return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
          } catch (b) {
            return !1
          }
        }

        function PN(b) {
          return PN = Object.setPrototypeOf ? Object.getPrototypeOf : function(c) {
            return c.__proto__ || Object.getPrototypeOf(c)
          }, PN(b)
        }

        function Nz(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }
        var Ou = 100,
          Is = [{
            version: 0,
            minNpmVersion: '"<4.11.0"',
            maxNpmVersion: '"<4.11.0"'
          }, {
            version: 1,
            minNpmVersion: "4.13.0",
            maxNpmVersion: "4.21.0"
          }, {
            version: 2,
            minNpmVersion: "4.22.0",
            maxNpmVersion: null
          }],
          QI = Is[Is.length - 1],
          m$ = function(b) {
            RN(c, b);
            var a = DX(c);

            function c(s) {
              var r;
              return v4(this, c), r = a.call(this), Nz(t5(r), "_isShutdown", !1), Nz(t5(r), "_messageQueue", []), Nz(t5(r), "_timeoutID", null), Nz(t5(r), "_wallUnlisten", null), Nz(t5(r), "_flush", function() {
                if (r._timeoutID !== null) clearTimeout(r._timeoutID), r._timeoutID = null;
                if (r._messageQueue.length) {
                  for (var bA = 0; bA < r._messageQueue.length; bA += 2) {
                    var Y1;
                    (Y1 = r._wall).send.apply(Y1, [r._messageQueue[bA]].concat(wj(r._messageQueue[bA + 1])))
                  }
                  r._messageQueue.length = 0, r._timeoutID = setTimeout(r._flush, Ou)
                }
              }), Nz(t5(r), "overrideValueAtPath", function(bA) {
                var {
                  id: Y1,
                  path: B1,
                  rendererID: uA,
                  type: z1,
                  value: S1
                } = bA;
                switch (z1) {
                  case "context":
                    r.send("overrideContext", {
                      id: Y1,
                      path: B1,
                      rendererID: uA,
                      wasForwarded: !0,
                      value: S1
                    });
                    break;
                  case "hooks":
                    r.send("overrideHookState", {
                      id: Y1,
                      path: B1,
                      rendererID: uA,
                      wasForwarded: !0,
                      value: S1
                    });
                    break;
                  case "props":
                    r.send("overrideProps", {
                      id: Y1,
                      path: B1,
                      rendererID: uA,
                      wasForwarded: !0,
                      value: S1
                    });
                    break;
                  case "state":
                    r.send("overrideState", {
                      id: Y1,
                      path: B1,
                      rendererID: uA,
                      wasForwarded: !0,
                      value: S1
                    });
                    break
                }
              }), r._wall = s, r._wallUnlisten = s.listen(function(bA) {
                if (bA && bA.event) t5(r).emit(bA.event, bA.payload)
              }) || null, r.addListener("overrideValueAtPath", r.overrideValueAtPath), r
            }
            return Zs(c, [{
              key: "send",
              value: function(r) {
                if (this._isShutdown) {
                  console.warn('Cannot send message "'.concat(r, '" through a Bridge that has been shutdown.'));
                  return
                }
                for (var bA = arguments.length, Y1 = Array(bA > 1 ? bA - 1 : 0), B1 = 1; B1 < bA; B1++) Y1[B1 - 1] = arguments[B1];
                if (this._messageQueue.push(r, Y1), !this._timeoutID) this._timeoutID = setTimeout(this._flush, 0)
              }
            }, {
              key: "shutdown",
              value: function() {
                if (this._isShutdown) {
                  console.warn("Bridge was already shutdown.");
                  return
                }
                this.emit("shutdown"), this.send("shutdown"), this._isShutdown = !0, this.addListener = function() {}, this.emit = function() {}, this.removeAllListeners();
                var r = this._wallUnlisten;
                if (r) r();
                do this._flush(); while (this._messageQueue.length);
                if (this._timeoutID !== null) clearTimeout(this._timeoutID), this._timeoutID = null
              }
            }, {
              key: "wall",
              get: function() {
                return this._wall
              }
            }]), c
          }(W);
        let Ru = m$;

        function IR(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") IR = function(c) {
            return typeof c
          };
          else IR = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return IR(b)
        }

        function Lz(b, a) {
          if (!(b instanceof a)) throw TypeError("Cannot call a class as a function")
        }

        function Tu(b, a) {
          for (var c = 0; c < a.length; c++) {
            var s = a[c];
            if (s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s) s.writable = !0;
            Object.defineProperty(b, s.key, s)
          }
        }

        function Pu(b, a, c) {
          if (a) Tu(b.prototype, a);
          if (c) Tu(b, c);
          return b
        }

        function ju(b, a) {
          if (typeof a !== "function" && a !== null) throw TypeError("Super expression must either be null or a function");
          if (b.prototype = Object.create(a && a.prototype, {
              constructor: {
                value: b,
                writable: !0,
                configurable: !0
              }
            }), a) jN(b, a)
        }

        function jN(b, a) {
          return jN = Object.setPrototypeOf || function(s, r) {
            return s.__proto__ = r, s
          }, jN(b, a)
        }

        function Ys(b) {
          var a = d$();
          return function() {
            var s = vC(b),
              r;
            if (a) {
              var bA = vC(this).constructor;
              r = Reflect.construct(s, arguments, bA)
            } else r = s.apply(this, arguments);
            return SN(this, r)
          }
        }

        function SN(b, a) {
          if (a && (IR(a) === "object" || typeof a === "function")) return a;
          return Z4(b)
        }

        function Z4(b) {
          if (b === void 0) throw ReferenceError("this hasn't been initialised - super() hasn't been called");
          return b
        }

        function d$() {
          if (typeof Reflect > "u" || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if (typeof Proxy === "function") return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0
          } catch (b) {
            return !1
          }
        }

        function vC(b) {
          return vC = Object.setPrototypeOf ? Object.getPrototypeOf : function(c) {
            return c.__proto__ || Object.getPrototypeOf(c)
          }, vC(b)
        }

        function P4(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }
        var Mz = function(a) {
            if (H) {
              var c;
              for (var s = arguments.length, r = Array(s > 1 ? s - 1 : 0), bA = 1; bA < s; bA++) r[bA - 1] = arguments[bA];
              (c = console).log.apply(c, ["%cAgent %c".concat(a), "color: purple; font-weight: bold;", "font-weight: bold;"].concat(r))
            }
          },
          wBA = function(b) {
            ju(c, b);
            var a = Ys(c);

            function c(s) {
              var r;
              if (Lz(this, c), r = a.call(this), P4(Z4(r), "_isProfiling", !1), P4(Z4(r), "_recordChangeDescriptions", !1), P4(Z4(r), "_rendererInterfaces", {}), P4(Z4(r), "_persistedSelection", null), P4(Z4(r), "_persistedSelectionMatch", null), P4(Z4(r), "_traceUpdatesEnabled", !1), P4(Z4(r), "clearErrorsAndWarnings", function(uA) {
                  var z1 = uA.rendererID,
                    S1 = r._rendererInterfaces[z1];
                  if (S1 == null) console.warn('Invalid renderer id "'.concat(z1, '"'));
                  else S1.clearErrorsAndWarnings()
                }), P4(Z4(r), "clearErrorsForFiberID", function(uA) {
                  var {
                    id: z1,
                    rendererID: S1
                  } = uA, l1 = r._rendererInterfaces[S1];
                  if (l1 == null) console.warn('Invalid renderer id "'.concat(S1, '"'));
                  else l1.clearErrorsForFiberID(z1)
                }), P4(Z4(r), "clearWarningsForFiberID", function(uA) {
                  var {
                    id: z1,
                    rendererID: S1
                  } = uA, l1 = r._rendererInterfaces[S1];
                  if (l1 == null) console.warn('Invalid renderer id "'.concat(S1, '"'));
                  else l1.clearWarningsForFiberID(z1)
                }), P4(Z4(r), "copyElementPath", function(uA) {
                  var {
                    id: z1,
                    path: S1,
                    rendererID: l1
                  } = uA, n1 = r._rendererInterfaces[l1];
                  if (n1 == null) console.warn('Invalid renderer id "'.concat(l1, '" for element "').concat(z1, '"'));
                  else {
                    var ZQ = n1.getSerializedElementValueByPath(z1, S1);
                    if (ZQ != null) r._bridge.send("saveToClipboard", ZQ);
                    else console.warn('Unable to obtain serialized value for element "'.concat(z1, '"'))
                  }
                }), P4(Z4(r), "deletePath", function(uA) {
                  var {
                    hookID: z1,
                    id: S1,
                    path: l1,
                    rendererID: n1,
                    type: ZQ
                  } = uA, TQ = r._rendererInterfaces[n1];
                  if (TQ == null) console.warn('Invalid renderer id "'.concat(n1, '" for element "').concat(S1, '"'));
                  else TQ.deletePath(ZQ, S1, z1, l1)
                }), P4(Z4(r), "getBackendVersion", function() {
                  var uA = "4.28.5-ef8a840bd";
                  if (uA) r._bridge.send("backendVersion", uA)
                }), P4(Z4(r), "getBridgeProtocol", function() {
                  r._bridge.send("bridgeProtocol", QI)
                }), P4(Z4(r), "getProfilingData", function(uA) {
                  var z1 = uA.rendererID,
                    S1 = r._rendererInterfaces[z1];
                  if (S1 == null) console.warn('Invalid renderer id "'.concat(z1, '"'));
                  r._bridge.send("profilingData", S1.getProfilingData())
                }), P4(Z4(r), "getProfilingStatus", function() {
                  r._bridge.send("profilingStatus", r._isProfiling)
                }), P4(Z4(r), "getOwnersList", function(uA) {
                  var {
                    id: z1,
                    rendererID: S1
                  } = uA, l1 = r._rendererInterfaces[S1];
                  if (l1 == null) console.warn('Invalid renderer id "'.concat(S1, '" for element "').concat(z1, '"'));
                  else {
                    var n1 = l1.getOwnersList(z1);
                    r._bridge.send("ownersList", {
                      id: z1,
                      owners: n1
                    })
                  }
                }), P4(Z4(r), "inspectElement", function(uA) {
                  var {
                    forceFullData: z1,
                    id: S1,
                    path: l1,
                    rendererID: n1,
                    requestID: ZQ
                  } = uA, TQ = r._rendererInterfaces[n1];
                  if (TQ == null) console.warn('Invalid renderer id "'.concat(n1, '" for element "').concat(S1, '"'));
                  else if (r._bridge.send("inspectedElement", TQ.inspectElement(ZQ, S1, l1, z1)), r._persistedSelectionMatch === null || r._persistedSelectionMatch.id !== S1) r._persistedSelection = null, r._persistedSelectionMatch = null, TQ.setTrackedPath(null), r._throttledPersistSelection(n1, S1)
                }), P4(Z4(r), "logElementToConsole", function(uA) {
                  var {
                    id: z1,
                    rendererID: S1
                  } = uA, l1 = r._rendererInterfaces[S1];
                  if (l1 == null) console.warn('Invalid renderer id "'.concat(S1, '" for element "').concat(z1, '"'));
                  else l1.logElementToConsole(z1)
                }), P4(Z4(r), "overrideError", function(uA) {
                  var {
                    id: z1,
                    rendererID: S1,
                    forceError: l1
                  } = uA, n1 = r._rendererInterfaces[S1];
                  if (n1 == null) console.warn('Invalid renderer id "'.concat(S1, '" for element "').concat(z1, '"'));
                  else n1.overrideError(z1, l1)
                }), P4(Z4(r), "overrideSuspense", function(uA) {
                  var {
                    id: z1,
                    rendererID: S1,
                    forceFallback: l1
                  } = uA, n1 = r._rendererInterfaces[S1];
                  if (n1 == null) console.warn('Invalid renderer id "'.concat(S1, '" for element "').concat(z1, '"'));
                  else n1.overrideSuspense(z1, l1)
                }), P4(Z4(r), "overrideValueAtPath", function(uA) {
                  var {
                    hookID: z1,
                    id: S1,
                    path: l1,
                    rendererID: n1,
                    type: ZQ,
                    value: TQ
                  } = uA, M2 = r._rendererInterfaces[n1];
                  if (M2 == null) console.warn('Invalid renderer id "'.concat(n1, '" for element "').concat(S1, '"'));
                  else M2.overrideValueAtPath(ZQ, S1, z1, l1, TQ)
                }), P4(Z4(r), "overrideContext", function(uA) {
                  var {
                    id: z1,
                    path: S1,
                    rendererID: l1,
                    wasForwarded: n1,
                    value: ZQ
                  } = uA;
                  if (!n1) r.overrideValueAtPath({
                    id: z1,
                    path: S1,
                    rendererID: l1,
                    type: "context",
                    value: ZQ
                  })
                }), P4(Z4(r), "overrideHookState", function(uA) {
                  var {
                    id: z1,
                    hookID: S1,
                    path: l1,
                    rendererID: n1,
                    wasForwarded: ZQ,
                    value: TQ
                  } = uA;
                  if (!ZQ) r.overrideValueAtPath({
                    id: z1,
                    path: l1,
                    rendererID: n1,
                    type: "hooks",
                    value: TQ
                  })
                }), P4(Z4(r), "overrideProps", function(uA) {
                  var {
                    id: z1,
                    path: S1,
                    rendererID: l1,
                    wasForwarded: n1,
                    value: ZQ
                  } = uA;
                  if (!n1) r.overrideValueAtPath({
                    id: z1,
                    path: S1,
                    rendererID: l1,
                    type: "props",
                    value: ZQ
                  })
                }), P4(Z4(r), "overrideState", function(uA) {
                  var {
                    id: z1,
                    path: S1,
                    rendererID: l1,
                    wasForwarded: n1,
                    value: ZQ
                  } = uA;
                  if (!n1) r.overrideValueAtPath({
                    id: z1,
                    path: S1,
                    rendererID: l1,
                    type: "state",
                    value: ZQ
                  })
                }), P4(Z4(r), "reloadAndProfile", function(uA) {
                  EA(o, "true"), EA(m, uA ? "true" : "false"), r._bridge.send("reloadAppForProfiling")
                }), P4(Z4(r), "renamePath", function(uA) {
                  var {
                    hookID: z1,
                    id: S1,
                    newPath: l1,
                    oldPath: n1,
                    rendererID: ZQ,
                    type: TQ
                  } = uA, M2 = r._rendererInterfaces[ZQ];
                  if (M2 == null) console.warn('Invalid renderer id "'.concat(ZQ, '" for element "').concat(S1, '"'));
                  else M2.renamePath(TQ, S1, z1, n1, l1)
                }), P4(Z4(r), "setTraceUpdatesEnabled", function(uA) {
                  r._traceUpdatesEnabled = uA, E1(uA);
                  for (var z1 in r._rendererInterfaces) {
                    var S1 = r._rendererInterfaces[z1];
                    S1.setTraceUpdatesEnabled(uA)
                  }
                }), P4(Z4(r), "syncSelectionFromNativeElementsPanel", function() {
                  var uA = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;
                  if (uA == null) return;
                  r.selectNode(uA)
                }), P4(Z4(r), "shutdown", function() {
                  r.emit("shutdown")
                }), P4(Z4(r), "startProfiling", function(uA) {
                  r._recordChangeDescriptions = uA, r._isProfiling = !0;
                  for (var z1 in r._rendererInterfaces) {
                    var S1 = r._rendererInterfaces[z1];
                    S1.startProfiling(uA)
                  }
                  r._bridge.send("profilingStatus", r._isProfiling)
                }), P4(Z4(r), "stopProfiling", function() {
                  r._isProfiling = !1, r._recordChangeDescriptions = !1;
                  for (var uA in r._rendererInterfaces) {
                    var z1 = r._rendererInterfaces[uA];
                    z1.stopProfiling()
                  }
                  r._bridge.send("profilingStatus", r._isProfiling)
                }), P4(Z4(r), "stopInspectingNative", function(uA) {
                  r._bridge.send("stopInspectingNative", uA)
                }), P4(Z4(r), "storeAsGlobal", function(uA) {
                  var {
                    count: z1,
                    id: S1,
                    path: l1,
                    rendererID: n1
                  } = uA, ZQ = r._rendererInterfaces[n1];
                  if (ZQ == null) console.warn('Invalid renderer id "'.concat(n1, '" for element "').concat(S1, '"'));
                  else ZQ.storeAsGlobal(S1, l1, z1)
                }), P4(Z4(r), "updateConsolePatchSettings", function(uA) {
                  var {
                    appendComponentStack: z1,
                    breakOnConsoleErrors: S1,
                    showInlineWarningsAndErrors: l1,
                    hideConsoleLogsInStrictMode: n1,
                    browserTheme: ZQ
                  } = uA;
                  GR({
                    appendComponentStack: z1,
                    breakOnConsoleErrors: S1,
                    showInlineWarningsAndErrors: l1,
                    hideConsoleLogsInStrictMode: n1,
                    browserTheme: ZQ
                  })
                }), P4(Z4(r), "updateComponentFilters", function(uA) {
                  for (var z1 in r._rendererInterfaces) {
                    var S1 = r._rendererInterfaces[z1];
                    S1.updateComponentFilters(uA)
                  }
                }), P4(Z4(r), "viewAttributeSource", function(uA) {
                  var {
                    id: z1,
                    path: S1,
                    rendererID: l1
                  } = uA, n1 = r._rendererInterfaces[l1];
                  if (n1 == null) console.warn('Invalid renderer id "'.concat(l1, '" for element "').concat(z1, '"'));
                  else n1.prepareViewAttributeSource(z1, S1)
                }), P4(Z4(r), "viewElementSource", function(uA) {
                  var {
                    id: z1,
                    rendererID: S1
                  } = uA, l1 = r._rendererInterfaces[S1];
                  if (l1 == null) console.warn('Invalid renderer id "'.concat(S1, '" for element "').concat(z1, '"'));
                  else l1.prepareViewElementSource(z1)
                }), P4(Z4(r), "onTraceUpdates", function(uA) {
                  r.emit("traceUpdates", uA)
                }), P4(Z4(r), "onFastRefreshScheduled", function() {
                  if (H) Mz("onFastRefreshScheduled");
                  r._bridge.send("fastRefreshScheduled")
                }), P4(Z4(r), "onHookOperations", function(uA) {
                  if (H) Mz("onHookOperations", "(".concat(uA.length, ") [").concat(uA.join(", "), "]"));
                  if (r._bridge.send("operations", uA), r._persistedSelection !== null) {
                    var z1 = uA[0];
                    if (r._persistedSelection.rendererID === z1) {
                      var S1 = r._rendererInterfaces[z1];
                      if (S1 == null) console.warn('Invalid renderer id "'.concat(z1, '"'));
                      else {
                        var l1 = r._persistedSelectionMatch,
                          n1 = S1.getBestMatchForTrackedPath();
                        r._persistedSelectionMatch = n1;
                        var ZQ = l1 !== null ? l1.id : null,
                          TQ = n1 !== null ? n1.id : null;
                        if (ZQ !== TQ) {
                          if (TQ !== null) r._bridge.send("selectFiber", TQ)
                        }
                        if (n1 !== null && n1.isFullMatch) r._persistedSelection = null, r._persistedSelectionMatch = null, S1.setTrackedPath(null)
                      }
                    }
                  }
                }), P4(Z4(r), "_throttledPersistSelection", V()(function(uA, z1) {
                  var S1 = r._rendererInterfaces[uA],
                    l1 = S1 != null ? S1.getPathForElement(z1) : null;
                  if (l1 !== null) EA(u, JSON.stringify({
                    rendererID: uA,
                    path: l1
                  }));
                  else WA(u)
                }, 1000)), X1(o) === "true") r._recordChangeDescriptions = X1(m) === "true", r._isProfiling = !0, WA(m), WA(o);
              var bA = X1(u);
              if (bA != null) r._persistedSelection = JSON.parse(bA);
              if (r._bridge = s, s.addListener("clearErrorsAndWarnings", r.clearErrorsAndWarnings), s.addListener("clearErrorsForFiberID", r.clearErrorsForFiberID), s.addListener("clearWarningsForFiberID", r.clearWarningsForFiberID), s.addListener("copyElementPath", r.copyElementPath), s.addListener("deletePath", r.deletePath), s.addListener("getBackendVersion", r.getBackendVersion), s.addListener("getBridgeProtocol", r.getBridgeProtocol), s.addListener("getProfilingData", r.getProfilingData), s.addListener("getProfilingStatus", r.getProfilingStatus), s.addListener("getOwnersList", r.getOwnersList), s.addListener("inspectElement", r.inspectElement), s.addListener("logElementToConsole", r.logElementToConsole), s.addListener("overrideError", r.overrideError), s.addListener("overrideSuspense", r.overrideSuspense), s.addListener("overrideValueAtPath", r.overrideValueAtPath), s.addListener("reloadAndProfile", r.reloadAndProfile), s.addListener("renamePath", r.renamePath), s.addListener("setTraceUpdatesEnabled", r.setTraceUpdatesEnabled), s.addListener("startProfiling", r.startProfiling), s.addListener("stopProfiling", r.stopProfiling), s.addListener("storeAsGlobal", r.storeAsGlobal), s.addListener("syncSelectionFromNativeElementsPanel", r.syncSelectionFromNativeElementsPanel), s.addListener("shutdown", r.shutdown), s.addListener("updateConsolePatchSettings", r.updateConsolePatchSettings), s.addListener("updateComponentFilters", r.updateComponentFilters), s.addListener("viewAttributeSource", r.viewAttributeSource), s.addListener("viewElementSource", r.viewElementSource), s.addListener("overrideContext", r.overrideContext), s.addListener("overrideHookState", r.overrideHookState), s.addListener("overrideProps", r.overrideProps), s.addListener("overrideState", r.overrideState), r._isProfiling) s.send("profilingStatus", !0);
              var Y1 = "4.28.5-ef8a840bd";
              if (Y1) r._bridge.send("backendVersion", Y1);
              r._bridge.send("bridgeProtocol", QI);
              var B1 = !1;
              try {
                localStorage.getItem("test"), B1 = !0
              } catch (uA) {}
              return s.send("isBackendStorageAPISupported", B1), s.send("isSynchronousXHRSupported", O4()), f0(s, Z4(r)), sA(Z4(r)), r
            }
            return Pu(c, [{
              key: "getInstanceAndStyle",
              value: function(r) {
                var {
                  id: bA,
                  rendererID: Y1
                } = r, B1 = this._rendererInterfaces[Y1];
                if (B1 == null) return console.warn('Invalid renderer id "'.concat(Y1, '"')), null;
                return B1.getInstanceAndStyle(bA)
              }
            }, {
              key: "getBestMatchingRendererInterface",
              value: function(r) {
                var bA = null;
                for (var Y1 in this._rendererInterfaces) {
                  var B1 = this._rendererInterfaces[Y1],
                    uA = B1.getFiberForNative(r);
                  if (uA !== null) {
                    if (uA.stateNode === r) return B1;
                    else if (bA === null) bA = B1
                  }
                }
                return bA
              }
            }, {
              key: "getIDForNode",
              value: function(r) {
                var bA = this.getBestMatchingRendererInterface(r);
                if (bA != null) try {
                  return bA.getFiberIDForNative(r, !0)
                } catch (Y1) {}
                return null
              }
            }, {
              key: "selectNode",
              value: function(r) {
                var bA = this.getIDForNode(r);
                if (bA !== null) this._bridge.send("selectFiber", bA)
              }
            }, {
              key: "setRendererInterface",
              value: function(r, bA) {
                if (this._rendererInterfaces[r] = bA, this._isProfiling) bA.startProfiling(this._recordChangeDescriptions);
                bA.setTraceUpdatesEnabled(this._traceUpdatesEnabled);
                var Y1 = this._persistedSelection;
                if (Y1 !== null && Y1.rendererID === r) bA.setTrackedPath(Y1.path)
              }
            }, {
              key: "onUnsupportedRenderer",
              value: function(r) {
                this._bridge.send("unsupportedRendererVersion", r)
              }
            }, {
              key: "rendererInterfaces",
              get: function() {
                return this._rendererInterfaces
              }
            }]), c
          }(W);

        function E7(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") E7 = function(c) {
            return typeof c
          };
          else E7 = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return E7(b)
        }

        function Js(b) {
          return NBA(b) || cVA(b) || qBA(b) || Ws()
        }

        function Ws() {
          throw TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }

        function qBA(b, a) {
          if (!b) return;
          if (typeof b === "string") return gx(b, a);
          var c = Object.prototype.toString.call(b).slice(8, -1);
          if (c === "Object" && b.constructor) c = b.constructor.name;
          if (c === "Map" || c === "Set") return Array.from(b);
          if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)) return gx(b, a)
        }

        function cVA(b) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(b)) return Array.from(b)
        }

        function NBA(b) {
          if (Array.isArray(b)) return gx(b)
        }

        function gx(b, a) {
          if (a == null || a > b.length) a = b.length;
          for (var c = 0, s = Array(a); c < a; c++) s[c] = b[c];
          return s
        }

        function KF(b) {
          if (b.hasOwnProperty("__REACT_DEVTOOLS_GLOBAL_HOOK__")) return null;
          var a = console,
            c = {};
          for (var s in console) c[s] = console[s];

          function r(YB) {
            a = YB, c = {};
            for (var z2 in a) c[z2] = console[z2]
          }

          function bA(YB) {
            try {
              if (typeof YB.version === "string") {
                if (YB.bundleType > 0) return "development";
                return "production"
              }
              var z2 = Function.prototype.toString;
              if (YB.Mount && YB.Mount._renderNewRootComponent) {
                var A9 = z2.call(YB.Mount._renderNewRootComponent);
                if (A9.indexOf("function") !== 0) return "production";
                if (A9.indexOf("storedMeasure") !== -1) return "development";
                if (A9.indexOf("should be a pure function") !== -1) {
                  if (A9.indexOf("NODE_ENV") !== -1) return "development";
                  if (A9.indexOf("development") !== -1) return "development";
                  if (A9.indexOf("true") !== -1) return "development";
                  if (A9.indexOf("nextElement") !== -1 || A9.indexOf("nextComponent") !== -1) return "unminified";
                  else return "development"
                }
                if (A9.indexOf("nextElement") !== -1 || A9.indexOf("nextComponent") !== -1) return "unminified";
                return "outdated"
              }
            } catch (ZG) {}
            return "production"
          }

          function Y1(YB) {
            try {
              var z2 = Function.prototype.toString,
                A9 = z2.call(YB);
              if (A9.indexOf("^_^") > -1) ZQ = !0, setTimeout(function() {
                throw Error("React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build")
              })
            } catch (ZG) {}
          }

          function B1(YB, z2) {
            if (YB === void 0 || YB === null || YB.length === 0 || typeof YB[0] === "string" && YB[0].match(/([^%]|^)(%c)/g) || z2 === void 0) return YB;
            var A9 = /([^%]|^)((%%)*)(%([oOdisf]))/g;
            if (typeof YB[0] === "string" && YB[0].match(A9)) return ["%c".concat(YB[0]), z2].concat(Js(YB.slice(1)));
            else {
              var ZG = YB.reduce(function(_I, OG, ZI) {
                if (ZI > 0) _I += " ";
                switch (E7(OG)) {
                  case "string":
                  case "boolean":
                  case "symbol":
                    return _I += "%s";
                  case "number":
                    var II = Number.isInteger(OG) ? "%i" : "%f";
                    return _I += II;
                  default:
                    return _I += "%o"
                }
              }, "%c");
              return [ZG, z2].concat(Js(YB))
            }
          }
          var uA = null;

          function z1(YB) {
            var {
              hideConsoleLogsInStrictMode: z2,
              browserTheme: A9
            } = YB, ZG = ["error", "group", "groupCollapsed", "info", "log", "trace", "warn"];
            if (uA !== null) return;
            var _I = {};
            uA = function() {
              for (var ZI in _I) try {
                a[ZI] = _I[ZI]
              } catch (II) {}
            }, ZG.forEach(function(OG) {
              try {
                var ZI = _I[OG] = a[OG].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ ? a[OG].__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ : a[OG],
                  II = function() {
                    if (!z2) {
                      var XH;
                      switch (OG) {
                        case "warn":
                          XH = A9 === "light" ? "rgba(250, 180, 50, 0.75)" : "rgba(250, 180, 50, 0.5)";
                          break;
                        case "error":
                          XH = A9 === "light" ? "rgba(250, 123, 130, 0.75)" : "rgba(250, 123, 130, 0.5)";
                          break;
                        case "log":
                        default:
                          XH = A9 === "light" ? "rgba(125, 125, 125, 0.75)" : "rgba(125, 125, 125, 0.5)";
                          break
                      }
                      if (XH) {
                        for (var p$ = arguments.length, bC = Array(p$), Tz = 0; Tz < p$; Tz++) bC[Tz] = arguments[Tz];
                        ZI.apply(void 0, Js(B1(bC, "color: ".concat(XH))))
                      } else throw Error("Console color is not defined")
                    }
                  };
                II.__REACT_DEVTOOLS_STRICT_MODE_ORIGINAL_METHOD__ = ZI, ZI.__REACT_DEVTOOLS_STRICT_MODE_OVERRIDE_METHOD__ = II, a[OG] = II
              } catch (c$) {}
            })
          }

          function S1() {
            if (uA !== null) uA(), uA = null
          }
          var l1 = 0;

          function n1(YB) {
            var z2 = ++l1;
            i3.set(z2, YB);
            var A9 = ZQ ? "deadcode" : bA(YB);
            if (b.hasOwnProperty("__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__")) {
              var ZG = b.__REACT_DEVTOOLS_CONSOLE_FUNCTIONS__,
                _I = ZG.registerRendererWithConsole,
                OG = ZG.patchConsoleUsingWindowValues;
              if (typeof _I === "function" && typeof OG === "function") _I(YB), OG()
            }
            var ZI = b.__REACT_DEVTOOLS_ATTACH__;
            if (typeof ZI === "function") {
              var II = ZI(UV, z2, YB, b);
              UV.rendererInterfaces.set(z2, II)
            }
            return UV.emit("renderer", {
              id: z2,
              renderer: YB,
              reactBuildType: A9
            }), z2
          }
          var ZQ = !1;

          function TQ(YB, z2) {
            return UV.on(YB, z2),
              function() {
                return UV.off(YB, z2)
              }
          }

          function M2(YB, z2) {
            if (!r9[YB]) r9[YB] = [];
            r9[YB].push(z2)
          }

          function gQ(YB, z2) {
            if (!r9[YB]) return;
            var A9 = r9[YB].indexOf(z2);
            if (A9 !== -1) r9[YB].splice(A9, 1);
            if (!r9[YB].length) delete r9[YB]
          }

          function W9(YB, z2) {
            if (r9[YB]) r9[YB].map(function(A9) {
              return A9(z2)
            })
          }

          function p4(YB) {
            var z2 = GI;
            if (!z2[YB]) z2[YB] = new Set;
            return z2[YB]
          }

          function g5(YB, z2) {
            var A9 = v7.get(YB);
            if (A9 != null) A9.handleCommitFiberUnmount(z2)
          }

          function kB(YB, z2, A9) {
            var ZG = UV.getFiberRoots(YB),
              _I = z2.current,
              OG = ZG.has(z2),
              ZI = _I.memoizedState == null || _I.memoizedState.element == null;
            if (!OG && !ZI) ZG.add(z2);
            else if (OG && ZI) ZG.delete(z2);
            var II = v7.get(YB);
            if (II != null) II.handleCommitFiberRoot(z2, A9)
          }

          function U5(YB, z2) {
            var A9 = v7.get(YB);
            if (A9 != null) A9.handlePostCommitFiberRoot(z2)
          }

          function z7(YB, z2) {
            var A9 = v7.get(YB);
            if (A9 != null)
              if (z2) A9.patchConsoleForStrictMode();
              else A9.unpatchConsoleForStrictMode();
            else if (z2) {
              var ZG = window.__REACT_DEVTOOLS_HIDE_CONSOLE_LOGS_IN_STRICT_MODE__ === !0,
                _I = window.__REACT_DEVTOOLS_BROWSER_THEME__;
              z1({
                hideConsoleLogsInStrictMode: ZG,
                browserTheme: _I
              })
            } else S1()
          }
          var l4 = [],
            F8 = [];

          function L3(YB) {
            var z2 = YB.stack.split(`
`),
              A9 = z2.length > 1 ? z2[1] : null;
            return A9
          }

          function jY() {
            return F8
          }

          function D4(YB) {
            var z2 = L3(YB);
            if (z2 !== null) l4.push(z2)
          }

          function VJ(YB) {
            if (l4.length > 0) {
              var z2 = l4.pop(),
                A9 = L3(YB);
              if (A9 !== null) F8.push([z2, A9])
            }
          }
          var GI = {},
            v7 = new Map,
            r9 = {},
            i3 = new Map,
            FJ = new Map,
            UV = {
              rendererInterfaces: v7,
              listeners: r9,
              backends: FJ,
              renderers: i3,
              emit: W9,
              getFiberRoots: p4,
              inject: n1,
              on: M2,
              off: gQ,
              sub: TQ,
              supportsFiber: !0,
              checkDCE: Y1,
              onCommitFiberUnmount: g5,
              onCommitFiberRoot: kB,
              onPostCommitFiberRoot: U5,
              setStrictMode: z7,
              getInternalModuleRanges: jY,
              registerInternalModuleStart: D4,
              registerInternalModuleStop: VJ
            };
          return Object.defineProperty(b, "__REACT_DEVTOOLS_GLOBAL_HOOK__", {
            configurable: !1,
            enumerable: !1,
            get: function() {
              return UV
            }
          }), UV
        }

        function BI(b, a, c) {
          var s = b[a];
          return b[a] = function(r) {
            return c.call(this, s, arguments)
          }, s
        }

        function Xs(b, a) {
          var c = {};
          for (var s in a) c[s] = BI(b, s, a[s]);
          return c
        }

        function LBA(b, a) {
          for (var c in a) b[c] = a[c]
        }

        function PY(b) {
          if (typeof b.forceUpdate === "function") b.forceUpdate();
          else if (b.updater != null && typeof b.updater.enqueueForceUpdate === "function") b.updater.enqueueForceUpdate(this, function() {}, "forceUpdate")
        }

        function Oz(b, a) {
          var c = Object.keys(b);
          if (Object.getOwnPropertySymbols) {
            var s = Object.getOwnPropertySymbols(b);
            if (a) s = s.filter(function(r) {
              return Object.getOwnPropertyDescriptor(b, r).enumerable
            });
            c.push.apply(c, s)
          }
          return c
        }

        function vK(b) {
          for (var a = 1; a < arguments.length; a++) {
            var c = arguments[a] != null ? arguments[a] : {};
            if (a % 2) Oz(Object(c), !0).forEach(function(s) {
              ux(b, s, c[s])
            });
            else if (Object.getOwnPropertyDescriptors) Object.defineProperties(b, Object.getOwnPropertyDescriptors(c));
            else Oz(Object(c)).forEach(function(s) {
              Object.defineProperty(b, s, Object.getOwnPropertyDescriptor(c, s))
            })
          }
          return b
        }

        function ux(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }

        function YR(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") YR = function(c) {
            return typeof c
          };
          else YR = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return YR(b)
        }

        function _N(b) {
          var a = null,
            c = null;
          if (b._currentElement != null) {
            if (b._currentElement.key) c = String(b._currentElement.key);
            var s = b._currentElement.type;
            if (typeof s === "string") a = s;
            else if (typeof s === "function") a = m6(s)
          }
          return {
            displayName: a,
            key: c
          }
        }

        function zV(b) {
          if (b._currentElement != null) {
            var a = b._currentElement.type;
            if (typeof a === "function") {
              var c = b.getPublicInstance();
              if (c !== null) return sG;
              else return oW
            } else if (typeof a === "string") return q3
          }
          return BW
        }

        function Rz(b) {
          var a = [];
          if (YR(b) !== "object");
          else if (b._currentElement === null || b._currentElement === !1);
          else if (b._renderedComponent) {
            var c = b._renderedComponent;
            if (zV(c) !== BW) a.push(c)
          } else if (b._renderedChildren) {
            var s = b._renderedChildren;
            for (var r in s) {
              var bA = s[r];
              if (zV(bA) !== BW) a.push(bA)
            }
          }
          return a
        }

        function MBA(b, a, c, s) {
          var r = new Map,
            bA = new WeakMap,
            Y1 = new WeakMap,
            B1 = null,
            uA, z1 = function(IQ) {
              return null
            };
          if (c.ComponentTree) B1 = function(IQ, JQ) {
            var NQ = c.ComponentTree.getClosestInstanceFromNode(IQ);
            return bA.get(NQ) || null
          }, uA = function(IQ) {
            var JQ = r.get(IQ);
            return c.ComponentTree.getNodeFromInstance(JQ)
          }, z1 = function(IQ) {
            return c.ComponentTree.getClosestInstanceFromNode(IQ)
          };
          else if (c.Mount.getID && c.Mount.getNode) B1 = function(IQ, JQ) {
            return null
          }, uA = function(IQ) {
            return null
          };

          function S1(s0) {
            var IQ = r.get(s0);
            return IQ ? _N(IQ).displayName : null
          }

          function l1(s0) {
            if (YR(s0) !== "object" || s0 === null) throw Error("Invalid internal instance: " + s0);
            if (!bA.has(s0)) {
              var IQ = p3();
              bA.set(s0, IQ), r.set(IQ, s0)
            }
            return bA.get(s0)
          }

          function n1(s0, IQ) {
            if (s0.length !== IQ.length) return !1;
            for (var JQ = 0; JQ < s0.length; JQ++)
              if (s0[JQ] !== IQ[JQ]) return !1;
            return !0
          }
          var ZQ = [],
            TQ = null;
          if (c.Reconciler) TQ = Xs(c.Reconciler, {
            mountComponent: function(IQ, JQ) {
              var NQ = JQ[0],
                A2 = JQ[3];
              if (zV(NQ) === BW) return IQ.apply(this, JQ);
              if (A2._topLevelWrapper === void 0) return IQ.apply(this, JQ);
              var i4 = l1(NQ),
                b8 = ZQ.length > 0 ? ZQ[ZQ.length - 1] : 0;
              gQ(NQ, i4, b8), ZQ.push(i4), Y1.set(NQ, l1(A2._topLevelWrapper));
              try {
                var M3 = IQ.apply(this, JQ);
                return ZQ.pop(), M3
              } catch ($V) {
                throw ZQ = [], $V
              } finally {
                if (ZQ.length === 0) {
                  var DJ = Y1.get(NQ);
                  if (DJ === void 0) throw Error("Expected to find root ID.");
                  jY(DJ)
                }
              }
            },
            performUpdateIfNecessary: function(IQ, JQ) {
              var NQ = JQ[0];
              if (zV(NQ) === BW) return IQ.apply(this, JQ);
              var A2 = l1(NQ);
              ZQ.push(A2);
              var i4 = Rz(NQ);
              try {
                var b8 = IQ.apply(this, JQ),
                  M3 = Rz(NQ);
                if (!n1(i4, M3)) W9(NQ, A2, M3);
                return ZQ.pop(), b8
              } catch ($V) {
                throw ZQ = [], $V
              } finally {
                if (ZQ.length === 0) {
                  var DJ = Y1.get(NQ);
                  if (DJ === void 0) throw Error("Expected to find root ID.");
                  jY(DJ)
                }
              }
            },
            receiveComponent: function(IQ, JQ) {
              var NQ = JQ[0];
              if (zV(NQ) === BW) return IQ.apply(this, JQ);
              var A2 = l1(NQ);
              ZQ.push(A2);
              var i4 = Rz(NQ);
              try {
                var b8 = IQ.apply(this, JQ),
                  M3 = Rz(NQ);
                if (!n1(i4, M3)) W9(NQ, A2, M3);
                return ZQ.pop(), b8
              } catch ($V) {
                throw ZQ = [], $V
              } finally {
                if (ZQ.length === 0) {
                  var DJ = Y1.get(NQ);
                  if (DJ === void 0) throw Error("Expected to find root ID.");
                  jY(DJ)
                }
              }
            },
            unmountComponent: function(IQ, JQ) {
              var NQ = JQ[0];
              if (zV(NQ) === BW) return IQ.apply(this, JQ);
              var A2 = l1(NQ);
              ZQ.push(A2);
              try {
                var i4 = IQ.apply(this, JQ);
                return ZQ.pop(), p4(NQ, A2), i4
              } catch (M3) {
                throw ZQ = [], M3
              } finally {
                if (ZQ.length === 0) {
                  var b8 = Y1.get(NQ);
                  if (b8 === void 0) throw Error("Expected to find root ID.");
                  jY(b8)
                }
              }
            }
          });

          function M2() {
            if (TQ !== null)
              if (c.Component) LBA(c.Component.Mixin, TQ);
              else LBA(c.Reconciler, TQ);
            TQ = null
          }

          function gQ(s0, IQ, JQ) {
            var NQ = JQ === 0;
            if (H) console.log("%crecordMount()", "color: green; font-weight: bold;", IQ, _N(s0).displayName);
            if (NQ) {
              var A2 = s0._currentElement != null && s0._currentElement._owner != null;
              D4(E), D4(IQ), D4(x$), D4(0), D4(0), D4(0), D4(A2 ? 1 : 0)
            } else {
              var i4 = zV(s0),
                b8 = _N(s0),
                M3 = b8.displayName,
                DJ = b8.key,
                $V = s0._currentElement != null && s0._currentElement._owner != null ? l1(s0._currentElement._owner) : 0,
                Pz = VJ(M3),
                n3 = VJ(DJ);
              D4(E), D4(IQ), D4(i4), D4(JQ), D4($V), D4(Pz), D4(n3)
            }
          }

          function W9(s0, IQ, JQ) {
            D4(q), D4(IQ);
            var NQ = JQ.map(l1);
            D4(NQ.length);
            for (var A2 = 0; A2 < NQ.length; A2++) D4(NQ[A2])
          }

          function p4(s0, IQ) {
            l4.push(IQ), r.delete(IQ)
          }

          function g5(s0, IQ, JQ) {
            if (H) console.group("crawlAndRecordInitialMounts() id:", s0);
            var NQ = r.get(s0);
            if (NQ != null) Y1.set(NQ, JQ), gQ(NQ, s0, IQ), Rz(NQ).forEach(function(A2) {
              return g5(l1(A2), s0, JQ)
            });
            if (H) console.groupEnd()
          }

          function kB() {
            var s0 = c.Mount._instancesByReactRootID || c.Mount._instancesByContainerID;
            for (var IQ in s0) {
              var JQ = s0[IQ],
                NQ = l1(JQ);
              g5(NQ, 0, NQ), jY(NQ)
            }
          }
          var U5 = [],
            z7 = new Map,
            l4 = [],
            F8 = 0,
            L3 = null;

          function jY(s0) {
            if (U5.length === 0 && l4.length === 0 && L3 === null) return;
            var IQ = l4.length + (L3 === null ? 0 : 1),
              JQ = Array(3 + F8 + (IQ > 0 ? 2 + IQ : 0) + U5.length),
              NQ = 0;
            if (JQ[NQ++] = a, JQ[NQ++] = s0, JQ[NQ++] = F8, z7.forEach(function(b8, M3) {
                JQ[NQ++] = M3.length;
                var DJ = SK(M3);
                for (var $V = 0; $V < DJ.length; $V++) JQ[NQ + $V] = DJ[$V];
                NQ += M3.length
              }), IQ > 0) {
              JQ[NQ++] = U, JQ[NQ++] = IQ;
              for (var A2 = 0; A2 < l4.length; A2++) JQ[NQ++] = l4[A2];
              if (L3 !== null) JQ[NQ] = L3, NQ++
            }
            for (var i4 = 0; i4 < U5.length; i4++) JQ[NQ + i4] = U5[i4];
            if (NQ += U5.length, H) h5(JQ);
            b.emit("operations", JQ), U5.length = 0, l4 = [], L3 = null, z7.clear(), F8 = 0
          }

          function D4(s0) {
            U5.push(s0)
          }

          function VJ(s0) {
            if (s0 === null) return 0;
            var IQ = z7.get(s0);
            if (IQ !== void 0) return IQ;
            var JQ = z7.size + 1;
            return z7.set(s0, JQ), F8 += s0.length + 1, JQ
          }
          var GI = null,
            v7 = {};

          function r9(s0) {
            var IQ = v7;
            s0.forEach(function(JQ) {
              if (!IQ[JQ]) IQ[JQ] = {};
              IQ = IQ[JQ]
            })
          }

          function i3(s0) {
            return function(JQ) {
              var NQ = v7[s0];
              if (!NQ) return !1;
              for (var A2 = 0; A2 < JQ.length; A2++)
                if (NQ = NQ[JQ[A2]], !NQ) return !1;
              return !0
            }
          }

          function FJ(s0) {
            var IQ = null,
              JQ = null,
              NQ = r.get(s0);
            if (NQ != null) {
              IQ = NQ._instance || null;
              var A2 = NQ._currentElement;
              if (A2 != null && A2.props != null) JQ = A2.props.style || null
            }
            return {
              instance: IQ,
              style: JQ
            }
          }

          function UV(s0) {
            var IQ = r.get(s0);
            if (IQ == null) {
              console.warn('Could not find instance with id "'.concat(s0, '"'));
              return
            }
            switch (zV(IQ)) {
              case sG:
                s.$r = IQ._instance;
                break;
              case oW:
                var JQ = IQ._currentElement;
                if (JQ == null) {
                  console.warn('Could not find element with id "'.concat(s0, '"'));
                  return
                }
                s.$r = {
                  props: JQ.props,
                  type: JQ.type
                };
                break;
              default:
                s.$r = null;
                break
            }
          }

          function YB(s0, IQ, JQ) {
            var NQ = ZG(s0);
            if (NQ !== null) {
              var A2 = z0(NQ, IQ),
                i4 = "$reactTemp".concat(JQ);
              window[i4] = A2, console.log(i4), console.log(A2)
            }
          }

          function z2(s0, IQ) {
            var JQ = ZG(s0);
            if (JQ !== null) {
              var NQ = z0(JQ, IQ);
              return w9(NQ)
            }
          }

          function A9(s0, IQ, JQ, NQ) {
            if (NQ || GI !== IQ) GI = IQ, v7 = {};
            var A2 = ZG(IQ);
            if (A2 === null) return {
              id: IQ,
              responseID: s0,
              type: "not-found"
            };
            if (JQ !== null) r9(JQ);
            return UV(IQ), A2.context = IJ(A2.context, i3("context")), A2.props = IJ(A2.props, i3("props")), A2.state = IJ(A2.state, i3("state")), {
              id: IQ,
              responseID: s0,
              type: "full-data",
              value: A2
            }
          }

          function ZG(s0) {
            var IQ = r.get(s0);
            if (IQ == null) return null;
            var JQ = _N(IQ),
              NQ = JQ.displayName,
              A2 = JQ.key,
              i4 = zV(IQ),
              b8 = null,
              M3 = null,
              DJ = null,
              $V = null,
              Pz = null,
              n3 = IQ._currentElement;
            if (n3 !== null) {
              DJ = n3.props, Pz = n3._source != null ? n3._source : null;
              var jz = n3._owner;
              if (jz) {
                M3 = [];
                while (jz != null)
                  if (M3.push({
                      displayName: _N(jz).displayName || "Unknown",
                      id: l1(jz),
                      key: n3.key,
                      type: zV(jz)
                    }), jz._currentElement) jz = jz._currentElement._owner
              }
            }
            var mx = IQ._instance;
            if (mx != null) b8 = mx.context || null, $V = mx.state || null;
            var HJ = [],
              l$ = [];
            return {
              id: s0,
              canEditHooks: !1,
              canEditFunctionProps: !1,
              canEditHooksAndDeletePaths: !1,
              canEditHooksAndRenamePaths: !1,
              canEditFunctionPropsDeletePaths: !1,
              canEditFunctionPropsRenamePaths: !1,
              canToggleError: !1,
              isErrored: !1,
              targetErrorBoundaryID: null,
              canToggleSuspense: !1,
              canViewSource: i4 === sG || i4 === oW,
              hasLegacyContext: !0,
              displayName: NQ,
              type: i4,
              key: A2 != null ? A2 : null,
              context: b8,
              hooks: null,
              props: DJ,
              state: $V,
              errors: HJ,
              warnings: l$,
              owners: M3,
              source: Pz,
              rootType: null,
              rendererPackageName: null,
              rendererVersion: null,
              plugins: {
                stylex: null
              }
            }
          }

          function _I(s0) {
            var IQ = ZG(s0);
            if (IQ === null) {
              console.warn('Could not find element with id "'.concat(s0, '"'));
              return
            }
            var JQ = typeof console.groupCollapsed === "function";
            if (JQ) console.groupCollapsed("[Click to expand] %c<".concat(IQ.displayName || "Component", " />"), "color: var(--dom-tag-name-color); font-weight: normal;");
            if (IQ.props !== null) console.log("Props:", IQ.props);
            if (IQ.state !== null) console.log("State:", IQ.state);
            if (IQ.context !== null) console.log("Context:", IQ.context);
            var NQ = uA(s0);
            if (NQ !== null) console.log("Node:", NQ);
            if (window.chrome || /firefox/i.test(navigator.userAgent)) console.log("Right-click any value to save it as a global variable for further inspection.");
            if (JQ) console.groupEnd()
          }

          function OG(s0, IQ) {
            var JQ = ZG(s0);
            if (JQ !== null) window.$attribute = z0(JQ, IQ)
          }

          function ZI(s0) {
            var IQ = r.get(s0);
            if (IQ == null) {
              console.warn('Could not find instance with id "'.concat(s0, '"'));
              return
            }
            var JQ = IQ._currentElement;
            if (JQ == null) {
              console.warn('Could not find element with id "'.concat(s0, '"'));
              return
            }
            s.$type = JQ.type
          }

          function II(s0, IQ, JQ, NQ) {
            var A2 = r.get(IQ);
            if (A2 != null) {
              var i4 = A2._instance;
              if (i4 != null) switch (s0) {
                case "context":
                  rQ(i4.context, NQ), PY(i4);
                  break;
                case "hooks":
                  throw Error("Hooks not supported by this renderer");
                case "props":
                  var b8 = A2._currentElement;
                  A2._currentElement = vK(vK({}, b8), {}, {
                    props: d1(b8.props, NQ)
                  }), PY(i4);
                  break;
                case "state":
                  rQ(i4.state, NQ), PY(i4);
                  break
              }
            }
          }

          function c$(s0, IQ, JQ, NQ, A2) {
            var i4 = r.get(IQ);
            if (i4 != null) {
              var b8 = i4._instance;
              if (b8 != null) switch (s0) {
                case "context":
                  T2(b8.context, NQ, A2), PY(b8);
                  break;
                case "hooks":
                  throw Error("Hooks not supported by this renderer");
                case "props":
                  var M3 = i4._currentElement;
                  i4._currentElement = vK(vK({}, M3), {}, {
                    props: P0(M3.props, NQ, A2)
                  }), PY(b8);
                  break;
                case "state":
                  T2(b8.state, NQ, A2), PY(b8);
                  break
              }
            }
          }

          function XH(s0, IQ, JQ, NQ, A2) {
            var i4 = r.get(IQ);
            if (i4 != null) {
              var b8 = i4._instance;
              if (b8 != null) switch (s0) {
                case "context":
                  s9(b8.context, NQ, A2), PY(b8);
                  break;
                case "hooks":
                  throw Error("Hooks not supported by this renderer");
                case "props":
                  var M3 = i4._currentElement;
                  i4._currentElement = vK(vK({}, M3), {}, {
                    props: U0(M3.props, NQ, A2)
                  }), PY(b8);
                  break;
                case "state":
                  s9(b8.state, NQ, A2), PY(b8);
                  break
              }
            }
          }
          var p$ = function() {
              throw Error("getProfilingData not supported by this renderer")
            },
            bC = function() {
              throw Error("handleCommitFiberRoot not supported by this renderer")
            },
            Tz = function() {
              throw Error("handleCommitFiberUnmount not supported by this renderer")
            },
            KJ = function() {
              throw Error("handlePostCommitFiberRoot not supported by this renderer")
            },
            VH = function() {
              throw Error("overrideError not supported by this renderer")
            },
            yN = function() {
              throw Error("overrideSuspense not supported by this renderer")
            },
            Su = function() {},
            Ks = function() {};

          function NB() {
            return null
          }

          function h2(s0) {
            return null
          }

          function v8(s0) {}

          function p6(s0) {}

          function YI(s0) {}

          function RG(s0) {
            return null
          }

          function HX() {}

          function DF(s0) {}

          function ZW(s0) {}

          function fC() {}

          function xN() {}

          function XR(s0) {
            return r.has(s0)
          }
          return {
            clearErrorsAndWarnings: HX,
            clearErrorsForFiberID: DF,
            clearWarningsForFiberID: ZW,
            cleanup: M2,
            getSerializedElementValueByPath: z2,
            deletePath: II,
            flushInitialOperations: kB,
            getBestMatchForTrackedPath: NB,
            getDisplayNameForFiberID: S1,
            getFiberForNative: z1,
            getFiberIDForNative: B1,
            getInstanceAndStyle: FJ,
            findNativeNodesForFiberID: function(IQ) {
              var JQ = uA(IQ);
              return JQ == null ? null : [JQ]
            },
            getOwnersList: RG,
            getPathForElement: h2,
            getProfilingData: p$,
            handleCommitFiberRoot: bC,
            handleCommitFiberUnmount: Tz,
            handlePostCommitFiberRoot: KJ,
            hasFiberWithId: XR,
            inspectElement: A9,
            logElementToConsole: _I,
            overrideError: VH,
            overrideSuspense: yN,
            overrideValueAtPath: XH,
            renamePath: c$,
            patchConsoleForStrictMode: fC,
            prepareViewAttributeSource: OG,
            prepareViewElementSource: ZI,
            renderer: c,
            setTraceUpdatesEnabled: p6,
            setTrackedPath: YI,
            startProfiling: Su,
            stopProfiling: Ks,
            storeAsGlobal: YB,
            unpatchConsoleForStrictMode: xN,
            updateComponentFilters: v8
          }
        }

        function Vs(b) {
          return !rG(b)
        }

        function Fs(b, a, c) {
          if (b == null) return function() {};
          var s = [b.sub("renderer-attached", function(Y1) {
              var {
                id: B1,
                renderer: uA,
                rendererInterface: z1
              } = Y1;
              a.setRendererInterface(B1, z1), z1.flushInitialOperations()
            }), b.sub("unsupported-renderer-version", function(Y1) {
              a.onUnsupportedRenderer(Y1)
            }), b.sub("fastRefreshScheduled", a.onFastRefreshScheduled), b.sub("operations", a.onHookOperations), b.sub("traceUpdates", a.onTraceUpdates)],
            r = function(B1, uA) {
              if (!Vs(uA.reconcilerVersion || uA.version)) return;
              var z1 = b.rendererInterfaces.get(B1);
              if (z1 == null) {
                if (typeof uA.findFiberByHostInstance === "function") z1 = LN(b, B1, uA, c);
                else if (uA.ComponentTree) z1 = MBA(b, B1, uA, c);
                if (z1 != null) b.rendererInterfaces.set(B1, z1)
              }
              if (z1 != null) b.emit("renderer-attached", {
                id: B1,
                renderer: uA,
                rendererInterface: z1
              });
              else b.emit("unsupported-renderer-version", B1)
            };
          b.renderers.forEach(function(Y1, B1) {
            r(B1, Y1)
          }), s.push(b.sub("renderer", function(Y1) {
            var {
              id: B1,
              renderer: uA
            } = Y1;
            r(B1, uA)
          })), b.emit("react-devtools", a), b.reactDevtoolsAgent = a;
          var bA = function() {
            s.forEach(function(B1) {
              return B1()
            }), b.rendererInterfaces.forEach(function(B1) {
              B1.cleanup()
            }), b.reactDevtoolsAgent = null
          };
          return a.addListener("shutdown", bA), s.push(function() {
              a.removeListener("shutdown", bA)
            }),
            function() {
              s.forEach(function(Y1) {
                return Y1()
              })
            }
        }

        function kN(b, a) {
          var c = !1,
            s = {
              bottom: 0,
              left: 0,
              right: 0,
              top: 0
            },
            r = a[b];
          if (r != null) {
            for (var bA = 0, Y1 = Object.keys(s); bA < Y1.length; bA++) {
              var B1 = Y1[bA];
              s[B1] = r
            }
            c = !0
          }
          var uA = a[b + "Horizontal"];
          if (uA != null) s.left = uA, s.right = uA, c = !0;
          else {
            var z1 = a[b + "Left"];
            if (z1 != null) s.left = z1, c = !0;
            var S1 = a[b + "Right"];
            if (S1 != null) s.right = S1, c = !0;
            var l1 = a[b + "End"];
            if (l1 != null) s.right = l1, c = !0;
            var n1 = a[b + "Start"];
            if (n1 != null) s.left = n1, c = !0
          }
          var ZQ = a[b + "Vertical"];
          if (ZQ != null) s.bottom = ZQ, s.top = ZQ, c = !0;
          else {
            var TQ = a[b + "Bottom"];
            if (TQ != null) s.bottom = TQ, c = !0;
            var M2 = a[b + "Top"];
            if (M2 != null) s.top = M2, c = !0
          }
          return c ? s : null
        }

        function JR(b) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") JR = function(c) {
            return typeof c
          };
          else JR = function(c) {
            return c && typeof Symbol === "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c
          };
          return JR(b)
        }

        function WR(b, a, c) {
          if (a in b) Object.defineProperty(b, a, {
            value: c,
            enumerable: !0,
            configurable: !0,
            writable: !0
          });
          else b[a] = c;
          return b
        }

        function O(b, a, c, s) {
          b.addListener("NativeStyleEditor_measure", function(r) {
            var {
              id: bA,
              rendererID: Y1
            } = r;
            n(a, b, c, bA, Y1)
          }), b.addListener("NativeStyleEditor_renameAttribute", function(r) {
            var {
              id: bA,
              rendererID: Y1,
              oldName: B1,
              newName: uA,
              value: z1
            } = r;
            CA(a, bA, Y1, B1, uA, z1), setTimeout(function() {
              return n(a, b, c, bA, Y1)
            })
          }), b.addListener("NativeStyleEditor_setValue", function(r) {
            var {
              id: bA,
              rendererID: Y1,
              name: B1,
              value: uA
            } = r;
            G1(a, bA, Y1, B1, uA), setTimeout(function() {
              return n(a, b, c, bA, Y1)
            })
          }), b.send("isNativeStyleEditorSupported", {
            isSupported: !0,
            validAttributes: s
          })
        }
        var P = {
            top: 0,
            left: 0,
            right: 0,
            bottom: 0
          },
          f = new Map;

        function n(b, a, c, s, r) {
          var bA = b.getInstanceAndStyle({
            id: s,
            rendererID: r
          });
          if (!bA || !bA.style) {
            a.send("NativeStyleEditor_styleAndLayout", {
              id: s,
              layout: null,
              style: null
            });
            return
          }
          var {
            instance: Y1,
            style: B1
          } = bA, uA = c(B1), z1 = f.get(s);
          if (z1 != null) uA = Object.assign({}, uA, z1);
          if (!Y1 || typeof Y1.measure !== "function") {
            a.send("NativeStyleEditor_styleAndLayout", {
              id: s,
              layout: null,
              style: uA || null
            });
            return
          }
          Y1.measure(function(S1, l1, n1, ZQ, TQ, M2) {
            if (typeof S1 !== "number") {
              a.send("NativeStyleEditor_styleAndLayout", {
                id: s,
                layout: null,
                style: uA || null
              });
              return
            }
            var gQ = uA != null && kN("margin", uA) || P,
              W9 = uA != null && kN("padding", uA) || P;
            a.send("NativeStyleEditor_styleAndLayout", {
              id: s,
              layout: {
                x: S1,
                y: l1,
                width: n1,
                height: ZQ,
                left: TQ,
                top: M2,
                margin: gQ,
                padding: W9
              },
              style: uA || null
            })
          })
        }

        function t(b) {
          var a = {};
          for (var c in b) a[c] = b[c];
          return a
        }

        function CA(b, a, c, s, r, bA) {
          var Y1, B1 = b.getInstanceAndStyle({
            id: a,
            rendererID: c
          });
          if (!B1 || !B1.style) return;
          var {
            instance: uA,
            style: z1
          } = B1, S1 = r ? (Y1 = {}, WR(Y1, s, void 0), WR(Y1, r, bA), Y1) : WR({}, s, void 0), l1;
          if (uA !== null && typeof uA.setNativeProps === "function") {
            var n1 = f.get(a);
            if (!n1) f.set(a, S1);
            else Object.assign(n1, S1);
            uA.setNativeProps({
              style: S1
            })
          } else if (J8(z1)) {
            var ZQ = z1.length - 1;
            if (JR(z1[ZQ]) === "object" && !J8(z1[ZQ])) {
              if (l1 = t(z1[ZQ]), delete l1[s], r) l1[r] = bA;
              else l1[s] = void 0;
              b.overrideValueAtPath({
                type: "props",
                id: a,
                rendererID: c,
                path: ["style", ZQ],
                value: l1
              })
            } else b.overrideValueAtPath({
              type: "props",
              id: a,
              rendererID: c,
              path: ["style"],
              value: z1.concat([S1])
            })
          } else if (JR(z1) === "object") {
            if (l1 = t(z1), delete l1[s], r) l1[r] = bA;
            else l1[s] = void 0;
            b.overrideValueAtPath({
              type: "props",
              id: a,
              rendererID: c,
              path: ["style"],
              value: l1
            })
          } else b.overrideValueAtPath({
            type: "props",
            id: a,
            rendererID: c,
            path: ["style"],
            value: [z1, S1]
          });
          b.emit("hideNativeHighlight")
        }

        function G1(b, a, c, s, r) {
          var bA = b.getInstanceAndStyle({
            id: a,
            rendererID: c
          });
          if (!bA || !bA.style) return;
          var {
            instance: Y1,
            style: B1
          } = bA, uA = WR({}, s, r);
          if (Y1 !== null && typeof Y1.setNativeProps === "function") {
            var z1 = f.get(a);
            if (!z1) f.set(a, uA);
            else Object.assign(z1, uA);
            Y1.setNativeProps({
              style: uA
            })
          } else if (J8(B1)) {
            var S1 = B1.length - 1;
            if (JR(B1[S1]) === "object" && !J8(B1[S1])) b.overrideValueAtPath({
              type: "props",
              id: a,
              rendererID: c,
              path: ["style", S1, s],
              value: r
            });
            else b.overrideValueAtPath({
              type: "props",
              id: a,
              rendererID: c,
              path: ["style"],
              value: B1.concat([uA])
            })
          } else b.overrideValueAtPath({
            type: "props",
            id: a,
            rendererID: c,
            path: ["style"],
            value: [B1, uA]
          });
          b.emit("hideNativeHighlight")
        }

        function i1(b) {
          w0(b)
        }

        function w0(b) {
          if (b.getConsolePatchSettings == null) return;
          var a = b.getConsolePatchSettings();
          if (a == null) return;
          var c = HQ(a);
          if (c == null) return;
          Nu(c)
        }

        function HQ(b) {
          var a, c, s, r, bA, Y1 = JSON.parse(b !== null && b !== void 0 ? b : "{}"),
            B1 = Y1.appendComponentStack,
            uA = Y1.breakOnConsoleErrors,
            z1 = Y1.showInlineWarningsAndErrors,
            S1 = Y1.hideConsoleLogsInStrictMode,
            l1 = Y1.browserTheme;
          return {
            appendComponentStack: (a = GH(B1)) !== null && a !== void 0 ? a : !0,
            breakOnConsoleErrors: (c = GH(uA)) !== null && c !== void 0 ? c : !1,
            showInlineWarningsAndErrors: (s = GH(z1)) !== null && s !== void 0 ? s : !0,
            hideConsoleLogsInStrictMode: (r = GH(S1)) !== null && r !== void 0 ? r : !1,
            browserTheme: (bA = SC(l1)) !== null && bA !== void 0 ? bA : "dark"
          }
        }

        function dB(b, a) {
          if (b.setConsolePatchSettings == null) return;
          b.setConsolePatchSettings(JSON.stringify(a))
        }
        Gs(), KF(window);
        var J9 = window.__REACT_DEVTOOLS_GLOBAL_HOOK__,
          $B = MY();

        function e5(b) {
          if (H) {
            var a;
            for (var c = arguments.length, s = Array(c > 1 ? c - 1 : 0), r = 1; r < c; r++) s[r - 1] = arguments[r];
            (a = console).log.apply(a, ["%c[core/backend] %c".concat(b), "color: teal; font-weight: bold;", "font-weight: bold;"].concat(s))
          }
        }

        function l3(b) {
          if (J9 == null) return;
          var a = b || {},
            c = a.host,
            s = c === void 0 ? "localhost" : c,
            r = a.nativeStyleEditorValidAttributes,
            bA = a.useHttps,
            Y1 = bA === void 0 ? !1 : bA,
            B1 = a.port,
            uA = B1 === void 0 ? 8097 : B1,
            z1 = a.websocket,
            S1 = a.resolveRNStyle,
            l1 = S1 === void 0 ? null : S1,
            n1 = a.retryConnectionDelay,
            ZQ = n1 === void 0 ? 2000 : n1,
            TQ = a.isAppActive,
            M2 = TQ === void 0 ? function() {
              return !0
            } : TQ,
            gQ = a.devToolsSettingsManager,
            W9 = Y1 ? "wss" : "ws",
            p4 = null;

          function g5() {
            if (p4 === null) p4 = setTimeout(function() {
              return l3(b)
            }, ZQ)
          }
          if (gQ != null) try {
            i1(gQ)
          } catch (D4) {
            console.error(D4)
          }
          if (!M2()) {
            g5();
            return
          }
          var kB = null,
            U5 = [],
            z7 = W9 + "://" + s + ":" + uA,
            l4 = z1 ? z1 : new window.WebSocket(z7);
          l4.onclose = F8, l4.onerror = L3, l4.onmessage = jY, l4.onopen = function() {
            if (kB = new Ru({
                listen: function(i3) {
                  return U5.push(i3),
                    function() {
                      var FJ = U5.indexOf(i3);
                      if (FJ >= 0) U5.splice(FJ, 1)
                    }
                },
                send: function(i3, FJ, UV) {
                  if (l4.readyState === l4.OPEN) {
                    if (H) e5("wall.send()", i3, FJ);
                    l4.send(JSON.stringify({
                      event: i3,
                      payload: FJ
                    }))
                  } else {
                    if (H) e5("wall.send()", "Shutting down bridge because of closed WebSocket connection");
                    if (kB !== null) kB.shutdown();
                    g5()
                  }
                }
              }), kB.addListener("updateComponentFilters", function(r9) {
                $B = r9
              }), gQ != null && kB != null) kB.addListener("updateConsolePatchSettings", function(r9) {
              return dB(gQ, r9)
            });
            if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) kB.send("overrideComponentFilters", $B);
            var D4 = new wBA(kB);
            if (D4.addListener("shutdown", function() {
                J9.emit("shutdown")
              }), Fs(J9, D4, window), l1 != null || J9.resolveRNStyle != null) O(kB, D4, l1 || J9.resolveRNStyle, r || J9.nativeStyleEditorValidAttributes || null);
            else {
              var VJ, GI, v7 = function() {
                if (kB !== null) O(kB, D4, VJ, GI)
              };
              if (!J9.hasOwnProperty("resolveRNStyle")) Object.defineProperty(J9, "resolveRNStyle", {
                enumerable: !1,
                get: function() {
                  return VJ
                },
                set: function(i3) {
                  VJ = i3, v7()
                }
              });
              if (!J9.hasOwnProperty("nativeStyleEditorValidAttributes")) Object.defineProperty(J9, "nativeStyleEditorValidAttributes", {
                enumerable: !1,
                get: function() {
                  return GI
                },
                set: function(i3) {
                  GI = i3, v7()
                }
              })
            }
          };

          function F8() {
            if (H) e5("WebSocket.onclose");
            if (kB !== null) kB.emit("shutdown");
            g5()
          }

          function L3() {
            if (H) e5("WebSocket.onerror");
            g5()
          }

          function jY(D4) {
            var VJ;
            try {
              if (typeof D4.data === "string") {
                if (VJ = JSON.parse(D4.data), H) e5("WebSocket.onmessage", VJ)
              } else throw Error()
            } catch (GI) {
              console.error("[React DevTools] Failed to parse JSON: " + D4.data);
              return
            }
            U5.forEach(function(GI) {
              try {
                GI(VJ)
              } catch (v7) {
                throw console.log("[React DevTools] Error calling listener", VJ), console.log("error:", v7), v7
              }
            })
          }
        }
      })(), G
    })()
  })
})
// @from(Start 6290980, End 6290988)
kX6 = {}
// @from(Start 6290994, End 6290997)
WUB
// @from(Start 6291003, End 6291086)
XUB = L(() => {
  YUB();
  WUB = BA(JUB(), 1);
  WUB.default.connectToDevTools()
})
// @from(Start 6291092, End 6291095)
KUB
// @from(Start 6291097, End 6291421)
VUB = (A, Q) => {
    if (A === Q) return;
    if (!A) return Q;
    let B = {},
      G = !1;
    for (let Z of Object.keys(A))
      if (Q ? !Object.hasOwn(Q, Z) : !0) B[Z] = void 0, G = !0;
    if (Q) {
      for (let Z of Object.keys(Q))
        if (Q[Z] !== A[Z]) B[Z] = Q[Z], G = !0
    }
    return G ? B : void 0
  }
// @from(Start 6291425, End 6291536)
DUB = (A) => {
    if ("childNodes" in A)
      for (let Q of A.childNodes) DUB(Q);
    A.yogaNode = void 0
  }
// @from(Start 6291540, End 6291641)
FUB = (A) => {
    let Q = A.yogaNode;
    if (Q) Q.unsetMeasureFunc(), DUB(A), Q.freeRecursive()
  }
// @from(Start 6291645, End 6291647)
Ap
// @from(Start 6291653, End 6295711)
$g1 = L(() => {
  qEB();
  ft();
  EaA();
  GzB();
  KUB = BA(wEB(), 1);
  if (process.env.DEV === "true") try {
    Promise.resolve().then(() => XUB())
  } catch (A) {
    if (A.code === "ERR_MODULE_NOT_FOUND") console.warn(`
The environment variable DEV is set to true, so Ink tried to import \`react-devtools-core\`,
but this failed as it was not installed. Debugging with React Devtools requires it.

To install use this command:

$ npm install --save-dev react-devtools-core
				`.trim() + `
`);
    else throw A
  }
  Ap = KUB.default({
    getRootHostContext: () => ({
      isInsideText: !1
    }),
    prepareForCommit: () => null,
    preparePortalMount: () => null,
    clearContainer: () => !1,
    resetAfterCommit(A) {
      if (typeof A.onComputeLayout === "function") A.onComputeLayout();
      if (A.isStaticDirty) {
        if (A.isStaticDirty = !1, typeof A.onImmediateRender === "function") A.onImmediateRender();
        return
      }
      A.onRender?.()
    },
    getChildHostContext(A, Q) {
      let B = A.isInsideText,
        G = Q === "ink-text" || Q === "ink-virtual-text" || Q === "ink-link";
      if (B === G) return A;
      return {
        isInsideText: G
      }
    },
    shouldSetTextContent: () => !1,
    createInstance(A, Q, B, G) {
      if (G.isInsideText && A === "ink-box") throw Error("<Box> can’t be nested inside <Text> component");
      let Z = A === "ink-text" && G.isInsideText ? "ink-virtual-text" : A,
        I = DaA(Z);
      for (let [Y, J] of Object.entries(Q)) {
        if (Y === "children") continue;
        if (Y === "style") {
          if (Bg1(I, J), I.yogaNode) Gg1(I.yogaNode, J);
          continue
        }
        if (Y === "textStyles") {
          I.textStyles = J;
          continue
        }
        if (Y === "internal_static") {
          I.internal_static = !0;
          continue
        }
        Qg1(I, Y, J)
      }
      return I
    },
    createTextInstance(A, Q, B) {
      if (!B.isInsideText) throw Error(`Text string "${A}" must be rendered inside <Text> component`);
      return QzB(A)
    },
    resetTextContent() {},
    hideTextInstance(A) {
      kUA(A, "")
    },
    unhideTextInstance(A, Q) {
      kUA(A, Q)
    },
    getPublicInstance: (A) => A,
    hideInstance(A) {
      A.yogaNode?.setDisplay(CT.None)
    },
    unhideInstance(A) {
      A.yogaNode?.setDisplay(CT.Flex)
    },
    appendInitialChild: HaA,
    appendChild: HaA,
    insertBefore: Ag1,
    finalizeInitialChildren(A, Q, B, G) {
      if (A.internal_static) G.isStaticDirty = !0, G.staticNode = A;
      return !1
    },
    isPrimaryRenderer: !0,
    supportsMutation: !0,
    supportsPersistence: !1,
    supportsHydration: !1,
    scheduleTimeout: setTimeout,
    cancelTimeout: clearTimeout,
    noTimeout: -1,
    getCurrentEventPriority: () => hh1,
    beforeActiveInstanceBlur() {},
    afterActiveInstanceBlur() {},
    detachDeletedInstance() {},
    getInstanceFromNode: () => null,
    prepareScopeUpdate() {},
    getInstanceFromScope: () => null,
    appendChildToContainer: HaA,
    insertInContainerBefore: Ag1,
    removeChildFromContainer(A, Q) {
      _UA(A, Q), FUB(Q)
    },
    prepareUpdate(A, Q, B, G, Z) {
      if (A.internal_static) Z.isStaticDirty = !0;
      let I = VUB(B, G),
        Y = VUB(B.style, G.style);
      if (!I && !Y) return null;
      return {
        props: I,
        style: Y
      }
    },
    commitUpdate(A, Q) {
      let {
        props: B,
        style: G
      } = Q;
      if (B)
        for (let [Z, I] of Object.entries(B)) {
          if (Z === "style") {
            Bg1(A, I);
            continue
          }
          if (Z === "textStyles") {
            A.textStyles = I;
            continue
          }
          if (Z === "internal_static") {
            A.internal_static = !0;
            continue
          }
          Qg1(A, Z, I)
        }
      if (G && A.yogaNode) Gg1(A.yogaNode, G)
    },
    commitTextUpdate(A, Q, B) {
      kUA(A, B)
    },
    removeChild(A, Q) {
      _UA(A, Q), FUB(Q)
    }
  })
})
// @from(Start 6295714, End 6296330)
function wg1(A, Q = 1, B = {}) {
  let {
    indent: G = " ",
    includeEmptyLines: Z = !1
  } = B;
  if (typeof A !== "string") throw TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof A}\``);
  if (typeof Q !== "number") throw TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof Q}\``);
  if (Q < 0) throw RangeError(`Expected \`count\` to be at least 0, got \`${Q}\``);
  if (typeof G !== "string") throw TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof G}\``);
  if (Q === 0) return A;
  let I = Z ? /^/gm : /^(?!\s*$)/gm;
  return A.replace(I, G.repeat(Q))
}
// @from(Start 6296335, End 6296513)
yX6 = (A) => {
    return A.getComputedWidth() - A.getComputedPadding(_6.Left) - A.getComputedPadding(_6.Right) - A.getComputedBorder(_6.Left) - A.getComputedBorder(_6.Right)
  }
// @from(Start 6296517, End 6296520)
HUB
// @from(Start 6296526, End 6296564)
CUB = L(() => {
  ft();
  HUB = yX6
})
// @from(Start 6296570, End 6298050)
EUB = z((ac7, xX6) => {
  xX6.exports = {
    single: {
      topLeft: "┌",
      top: "─",
      topRight: "┐",
      right: "│",
      bottomRight: "┘",
      bottom: "─",
      bottomLeft: "└",
      left: "│"
    },
    double: {
      topLeft: "╔",
      top: "═",
      topRight: "╗",
      right: "║",
      bottomRight: "╝",
      bottom: "═",
      bottomLeft: "╚",
      left: "║"
    },
    round: {
      topLeft: "╭",
      top: "─",
      topRight: "╮",
      right: "│",
      bottomRight: "╯",
      bottom: "─",
      bottomLeft: "╰",
      left: "│"
    },
    bold: {
      topLeft: "┏",
      top: "━",
      topRight: "┓",
      right: "┃",
      bottomRight: "┛",
      bottom: "━",
      bottomLeft: "┗",
      left: "┃"
    },
    singleDouble: {
      topLeft: "╓",
      top: "─",
      topRight: "╖",
      right: "║",
      bottomRight: "╜",
      bottom: "─",
      bottomLeft: "╙",
      left: "║"
    },
    doubleSingle: {
      topLeft: "╒",
      top: "═",
      topRight: "╕",
      right: "│",
      bottomRight: "╛",
      bottom: "═",
      bottomLeft: "╘",
      left: "│"
    },
    classic: {
      topLeft: "+",
      top: "-",
      topRight: "+",
      right: "|",
      bottomRight: "+",
      bottom: "-",
      bottomLeft: "+",
      left: "|"
    },
    arrow: {
      topLeft: "↘",
      top: "↓",
      topRight: "↙",
      right: "←",
      bottomRight: "↖",
      bottom: "↑",
      bottomLeft: "↗",
      left: "→"
    }
  }
})
// @from(Start 6298056, End 6298150)
UUB = z((sc7, qg1) => {
  var zUB = EUB();
  qg1.exports = zUB;
  qg1.exports.default = zUB
})
// @from(Start 6298153, End 6298431)
function R7A(A) {
  switch (A) {
    case "light":
      return vX6;
    case "light-ansi":
      return bX6;
    case "dark-ansi":
      return fX6;
    case "light-daltonized":
      return hX6;
    case "dark-daltonized":
      return uX6;
    default:
      return gX6
  }
}
// @from(Start 6298436, End 6298439)
vX6
// @from(Start 6298441, End 6298444)
bX6
// @from(Start 6298446, End 6298449)
fX6
// @from(Start 6298451, End 6298454)
hX6
// @from(Start 6298456, End 6298459)
gX6
// @from(Start 6298461, End 6298464)
uX6
// @from(Start 6298470, End 6312651)
_aA = L(() => {
  vX6 = {
    autoAccept: "rgb(135,0,255)",
    bashBorder: "rgb(255,0,135)",
    claude: "rgb(215,119,87)",
    claudeShimmer: "rgb(245,149,117)",
    claudeBlue_FOR_SYSTEM_SPINNER: "rgb(87,105,247)",
    claudeBlueShimmer_FOR_SYSTEM_SPINNER: "rgb(117,135,255)",
    permission: "rgb(87,105,247)",
    permissionShimmer: "rgb(137,155,255)",
    planMode: "rgb(0,102,102)",
    ide: "rgb(71,130,200)",
    promptBorder: "rgb(153,153,153)",
    promptBorderShimmer: "rgb(183,183,183)",
    text: "rgb(0,0,0)",
    inverseText: "rgb(255,255,255)",
    inactive: "rgb(102,102,102)",
    subtle: "rgb(175,175,175)",
    suggestion: "rgb(87,105,247)",
    remember: "rgb(0,0,255)",
    background: "rgb(0,153,153)",
    success: "rgb(44,122,57)",
    error: "rgb(171,43,63)",
    warning: "rgb(150,108,30)",
    warningShimmer: "rgb(200,158,80)",
    diffAdded: "rgb(105,219,124)",
    diffRemoved: "rgb(255,168,180)",
    diffAddedDimmed: "rgb(199,225,203)",
    diffRemovedDimmed: "rgb(253,210,216)",
    diffAddedWord: "rgb(47,157,68)",
    diffRemovedWord: "rgb(209,69,75)",
    red_FOR_SUBAGENTS_ONLY: "rgb(220,38,38)",
    blue_FOR_SUBAGENTS_ONLY: "rgb(37,99,235)",
    green_FOR_SUBAGENTS_ONLY: "rgb(22,163,74)",
    yellow_FOR_SUBAGENTS_ONLY: "rgb(202,138,4)",
    purple_FOR_SUBAGENTS_ONLY: "rgb(147,51,234)",
    orange_FOR_SUBAGENTS_ONLY: "rgb(234,88,12)",
    pink_FOR_SUBAGENTS_ONLY: "rgb(219,39,119)",
    cyan_FOR_SUBAGENTS_ONLY: "rgb(8,145,178)",
    professionalBlue: "rgb(106,155,204)",
    rainbow_red: "rgb(235,95,87)",
    rainbow_orange: "rgb(245,139,87)",
    rainbow_yellow: "rgb(250,195,95)",
    rainbow_green: "rgb(145,200,130)",
    rainbow_blue: "rgb(130,170,220)",
    rainbow_indigo: "rgb(155,130,200)",
    rainbow_violet: "rgb(200,130,180)",
    rainbow_red_shimmer: "rgb(250,155,147)",
    rainbow_orange_shimmer: "rgb(255,185,137)",
    rainbow_yellow_shimmer: "rgb(255,225,155)",
    rainbow_green_shimmer: "rgb(185,230,180)",
    rainbow_blue_shimmer: "rgb(180,205,240)",
    rainbow_indigo_shimmer: "rgb(195,180,230)",
    rainbow_violet_shimmer: "rgb(230,180,210)",
    clawd_body: "rgb(215,119,87)",
    clawd_background: "rgb(0,0,0)",
    userMessageBackground: "rgb(240, 240, 240)",
    bashMessageBackgroundColor: "rgb(250, 245, 250)",
    memoryBackgroundColor: "rgb(230, 245, 250)",
    rate_limit_fill: "rgb(87,105,247)",
    rate_limit_empty: "rgb(39,47,111)"
  }, bX6 = {
    autoAccept: "ansi:magenta",
    bashBorder: "ansi:magenta",
    claude: "ansi:redBright",
    claudeShimmer: "ansi:yellowBright",
    claudeBlue_FOR_SYSTEM_SPINNER: "ansi:blue",
    claudeBlueShimmer_FOR_SYSTEM_SPINNER: "ansi:blueBright",
    permission: "ansi:blue",
    permissionShimmer: "ansi:blueBright",
    planMode: "ansi:cyan",
    ide: "ansi:blueBright",
    promptBorder: "ansi:white",
    promptBorderShimmer: "ansi:whiteBright",
    text: "ansi:black",
    inverseText: "ansi:white",
    inactive: "ansi:blackBright",
    subtle: "ansi:blackBright",
    suggestion: "ansi:blue",
    remember: "ansi:blue",
    background: "ansi:cyan",
    success: "ansi:green",
    error: "ansi:red",
    warning: "ansi:yellow",
    warningShimmer: "ansi:yellowBright",
    diffAdded: "ansi:green",
    diffRemoved: "ansi:red",
    diffAddedDimmed: "ansi:green",
    diffRemovedDimmed: "ansi:red",
    diffAddedWord: "ansi:greenBright",
    diffRemovedWord: "ansi:redBright",
    red_FOR_SUBAGENTS_ONLY: "ansi:red",
    blue_FOR_SUBAGENTS_ONLY: "ansi:blue",
    green_FOR_SUBAGENTS_ONLY: "ansi:green",
    yellow_FOR_SUBAGENTS_ONLY: "ansi:yellow",
    purple_FOR_SUBAGENTS_ONLY: "ansi:magenta",
    orange_FOR_SUBAGENTS_ONLY: "ansi:redBright",
    pink_FOR_SUBAGENTS_ONLY: "ansi:magentaBright",
    cyan_FOR_SUBAGENTS_ONLY: "ansi:cyan",
    professionalBlue: "ansi:blueBright",
    rainbow_red: "ansi:red",
    rainbow_orange: "ansi:redBright",
    rainbow_yellow: "ansi:yellow",
    rainbow_green: "ansi:green",
    rainbow_blue: "ansi:cyan",
    rainbow_indigo: "ansi:blue",
    rainbow_violet: "ansi:magenta",
    rainbow_red_shimmer: "ansi:redBright",
    rainbow_orange_shimmer: "ansi:yellow",
    rainbow_yellow_shimmer: "ansi:yellowBright",
    rainbow_green_shimmer: "ansi:greenBright",
    rainbow_blue_shimmer: "ansi:cyanBright",
    rainbow_indigo_shimmer: "ansi:blueBright",
    rainbow_violet_shimmer: "ansi:magentaBright",
    clawd_body: "ansi:redBright",
    clawd_background: "ansi:black",
    userMessageBackground: "ansi:white",
    bashMessageBackgroundColor: "ansi:whiteBright",
    memoryBackgroundColor: "ansi:white",
    rate_limit_fill: "ansi:yellow",
    rate_limit_empty: "ansi:black"
  }, fX6 = {
    autoAccept: "ansi:magentaBright",
    bashBorder: "ansi:magentaBright",
    claude: "ansi:redBright",
    claudeShimmer: "ansi:yellowBright",
    claudeBlue_FOR_SYSTEM_SPINNER: "ansi:blueBright",
    claudeBlueShimmer_FOR_SYSTEM_SPINNER: "ansi:blueBright",
    permission: "ansi:blueBright",
    permissionShimmer: "ansi:blueBright",
    planMode: "ansi:cyanBright",
    ide: "ansi:blue",
    promptBorder: "ansi:white",
    promptBorderShimmer: "ansi:whiteBright",
    text: "ansi:whiteBright",
    inverseText: "ansi:black",
    inactive: "ansi:white",
    subtle: "ansi:white",
    suggestion: "ansi:blueBright",
    remember: "ansi:blueBright",
    background: "ansi:cyanBright",
    success: "ansi:greenBright",
    error: "ansi:redBright",
    warning: "ansi:yellowBright",
    warningShimmer: "ansi:yellowBright",
    diffAdded: "ansi:green",
    diffRemoved: "ansi:red",
    diffAddedDimmed: "ansi:green",
    diffRemovedDimmed: "ansi:red",
    diffAddedWord: "ansi:greenBright",
    diffRemovedWord: "ansi:redBright",
    red_FOR_SUBAGENTS_ONLY: "ansi:redBright",
    blue_FOR_SUBAGENTS_ONLY: "ansi:blueBright",
    green_FOR_SUBAGENTS_ONLY: "ansi:greenBright",
    yellow_FOR_SUBAGENTS_ONLY: "ansi:yellowBright",
    purple_FOR_SUBAGENTS_ONLY: "ansi:magentaBright",
    orange_FOR_SUBAGENTS_ONLY: "ansi:redBright",
    pink_FOR_SUBAGENTS_ONLY: "ansi:magentaBright",
    cyan_FOR_SUBAGENTS_ONLY: "ansi:cyanBright",
    professionalBlue: "rgb(106,155,204)",
    rainbow_red: "ansi:red",
    rainbow_orange: "ansi:redBright",
    rainbow_yellow: "ansi:yellow",
    rainbow_green: "ansi:green",
    rainbow_blue: "ansi:cyan",
    rainbow_indigo: "ansi:blue",
    rainbow_violet: "ansi:magenta",
    rainbow_red_shimmer: "ansi:redBright",
    rainbow_orange_shimmer: "ansi:yellow",
    rainbow_yellow_shimmer: "ansi:yellowBright",
    rainbow_green_shimmer: "ansi:greenBright",
    rainbow_blue_shimmer: "ansi:cyanBright",
    rainbow_indigo_shimmer: "ansi:blueBright",
    rainbow_violet_shimmer: "ansi:magentaBright",
    clawd_body: "ansi:redBright",
    clawd_background: "ansi:black",
    userMessageBackground: "ansi:blackBright",
    bashMessageBackgroundColor: "ansi:black",
    memoryBackgroundColor: "ansi:blackBright",
    rate_limit_fill: "ansi:yellow",
    rate_limit_empty: "ansi:white"
  }, hX6 = {
    autoAccept: "rgb(135,0,255)",
    bashBorder: "rgb(0,102,204)",
    claude: "rgb(255,153,51)",
    claudeShimmer: "rgb(255,183,101)",
    claudeBlue_FOR_SYSTEM_SPINNER: "rgb(51,102,255)",
    claudeBlueShimmer_FOR_SYSTEM_SPINNER: "rgb(101,152,255)",
    permission: "rgb(51,102,255)",
    permissionShimmer: "rgb(101,152,255)",
    planMode: "rgb(51,102,102)",
    ide: "rgb(71,130,200)",
    promptBorder: "rgb(153,153,153)",
    promptBorderShimmer: "rgb(183,183,183)",
    text: "rgb(0,0,0)",
    inverseText: "rgb(255,255,255)",
    inactive: "rgb(102,102,102)",
    subtle: "rgb(175,175,175)",
    suggestion: "rgb(51,102,255)",
    remember: "rgb(51,102,255)",
    background: "rgb(0,153,153)",
    success: "rgb(0,102,153)",
    error: "rgb(204,0,0)",
    warning: "rgb(255,153,0)",
    warningShimmer: "rgb(255,183,50)",
    diffAdded: "rgb(153,204,255)",
    diffRemoved: "rgb(255,204,204)",
    diffAddedDimmed: "rgb(209,231,253)",
    diffRemovedDimmed: "rgb(255,233,233)",
    diffAddedWord: "rgb(51,102,204)",
    diffRemovedWord: "rgb(153,51,51)",
    red_FOR_SUBAGENTS_ONLY: "rgb(204,0,0)",
    blue_FOR_SUBAGENTS_ONLY: "rgb(0,102,204)",
    green_FOR_SUBAGENTS_ONLY: "rgb(0,204,0)",
    yellow_FOR_SUBAGENTS_ONLY: "rgb(255,204,0)",
    purple_FOR_SUBAGENTS_ONLY: "rgb(128,0,128)",
    orange_FOR_SUBAGENTS_ONLY: "rgb(255,128,0)",
    pink_FOR_SUBAGENTS_ONLY: "rgb(255,102,178)",
    cyan_FOR_SUBAGENTS_ONLY: "rgb(0,178,178)",
    professionalBlue: "rgb(106,155,204)",
    rainbow_red: "rgb(235,95,87)",
    rainbow_orange: "rgb(245,139,87)",
    rainbow_yellow: "rgb(250,195,95)",
    rainbow_green: "rgb(145,200,130)",
    rainbow_blue: "rgb(130,170,220)",
    rainbow_indigo: "rgb(155,130,200)",
    rainbow_violet: "rgb(200,130,180)",
    rainbow_red_shimmer: "rgb(250,155,147)",
    rainbow_orange_shimmer: "rgb(255,185,137)",
    rainbow_yellow_shimmer: "rgb(255,225,155)",
    rainbow_green_shimmer: "rgb(185,230,180)",
    rainbow_blue_shimmer: "rgb(180,205,240)",
    rainbow_indigo_shimmer: "rgb(195,180,230)",
    rainbow_violet_shimmer: "rgb(230,180,210)",
    clawd_body: "rgb(215,119,87)",
    clawd_background: "rgb(0,0,0)",
    userMessageBackground: "rgb(220, 220, 220)",
    bashMessageBackgroundColor: "rgb(250, 245, 250)",
    memoryBackgroundColor: "rgb(230, 245, 250)",
    rate_limit_fill: "rgb(51,102,255)",
    rate_limit_empty: "rgb(23,46,114)"
  }, gX6 = {
    autoAccept: "rgb(175,135,255)",
    bashBorder: "rgb(253,93,177)",
    claude: "rgb(215,119,87)",
    claudeShimmer: "rgb(235,159,127)",
    claudeBlue_FOR_SYSTEM_SPINNER: "rgb(147,165,255)",
    claudeBlueShimmer_FOR_SYSTEM_SPINNER: "rgb(177,195,255)",
    permission: "rgb(177,185,249)",
    permissionShimmer: "rgb(207,215,255)",
    planMode: "rgb(72,150,140)",
    ide: "rgb(71,130,200)",
    promptBorder: "rgb(136,136,136)",
    promptBorderShimmer: "rgb(166,166,166)",
    text: "rgb(255,255,255)",
    inverseText: "rgb(0,0,0)",
    inactive: "rgb(153,153,153)",
    subtle: "rgb(80,80,80)",
    suggestion: "rgb(177,185,249)",
    remember: "rgb(177,185,249)",
    background: "rgb(0,204,204)",
    success: "rgb(78,186,101)",
    error: "rgb(255,107,128)",
    warning: "rgb(255,193,7)",
    warningShimmer: "rgb(255,223,57)",
    diffAdded: "rgb(34,92,43)",
    diffRemoved: "rgb(122,41,54)",
    diffAddedDimmed: "rgb(71,88,74)",
    diffRemovedDimmed: "rgb(105,72,77)",
    diffAddedWord: "rgb(56,166,96)",
    diffRemovedWord: "rgb(179,89,107)",
    red_FOR_SUBAGENTS_ONLY: "rgb(220,38,38)",
    blue_FOR_SUBAGENTS_ONLY: "rgb(37,99,235)",
    green_FOR_SUBAGENTS_ONLY: "rgb(22,163,74)",
    yellow_FOR_SUBAGENTS_ONLY: "rgb(202,138,4)",
    purple_FOR_SUBAGENTS_ONLY: "rgb(147,51,234)",
    orange_FOR_SUBAGENTS_ONLY: "rgb(234,88,12)",
    pink_FOR_SUBAGENTS_ONLY: "rgb(219,39,119)",
    cyan_FOR_SUBAGENTS_ONLY: "rgb(8,145,178)",
    professionalBlue: "rgb(106,155,204)",
    rainbow_red: "rgb(235,95,87)",
    rainbow_orange: "rgb(245,139,87)",
    rainbow_yellow: "rgb(250,195,95)",
    rainbow_green: "rgb(145,200,130)",
    rainbow_blue: "rgb(130,170,220)",
    rainbow_indigo: "rgb(155,130,200)",
    rainbow_violet: "rgb(200,130,180)",
    rainbow_red_shimmer: "rgb(250,155,147)",
    rainbow_orange_shimmer: "rgb(255,185,137)",
    rainbow_yellow_shimmer: "rgb(255,225,155)",
    rainbow_green_shimmer: "rgb(185,230,180)",
    rainbow_blue_shimmer: "rgb(180,205,240)",
    rainbow_indigo_shimmer: "rgb(195,180,230)",
    rainbow_violet_shimmer: "rgb(230,180,210)",
    clawd_body: "rgb(215,119,87)",
    clawd_background: "rgb(0,0,0)",
    userMessageBackground: "rgb(55, 55, 55)",
    bashMessageBackgroundColor: "rgb(65, 60, 65)",
    memoryBackgroundColor: "rgb(55, 65, 70)",
    rate_limit_fill: "rgb(177,185,249)",
    rate_limit_empty: "rgb(80,83,112)"
  }, uX6 = {
    autoAccept: "rgb(175,135,255)",
    bashBorder: "rgb(51,153,255)",
    claude: "rgb(255,153,51)",
    claudeShimmer: "rgb(255,183,101)",
    claudeBlue_FOR_SYSTEM_SPINNER: "rgb(153,204,255)",
    claudeBlueShimmer_FOR_SYSTEM_SPINNER: "rgb(183,224,255)",
    permission: "rgb(153,204,255)",
    permissionShimmer: "rgb(183,224,255)",
    planMode: "rgb(102,153,153)",
    ide: "rgb(71,130,200)",
    promptBorder: "rgb(136,136,136)",
    promptBorderShimmer: "rgb(166,166,166)",
    text: "rgb(255,255,255)",
    inverseText: "rgb(0,0,0)",
    inactive: "rgb(153,153,153)",
    subtle: "rgb(80,80,80)",
    suggestion: "rgb(153,204,255)",
    remember: "rgb(153,204,255)",
    background: "rgb(0,204,204)",
    success: "rgb(51,153,255)",
    error: "rgb(255,102,102)",
    warning: "rgb(255,204,0)",
    warningShimmer: "rgb(255,234,50)",
    diffAdded: "rgb(0,68,102)",
    diffRemoved: "rgb(102,0,0)",
    diffAddedDimmed: "rgb(62,81,91)",
    diffRemovedDimmed: "rgb(62,44,44)",
    diffAddedWord: "rgb(0,119,179)",
    diffRemovedWord: "rgb(179,0,0)",
    red_FOR_SUBAGENTS_ONLY: "rgb(255,102,102)",
    blue_FOR_SUBAGENTS_ONLY: "rgb(102,178,255)",
    green_FOR_SUBAGENTS_ONLY: "rgb(102,255,102)",
    yellow_FOR_SUBAGENTS_ONLY: "rgb(255,255,102)",
    purple_FOR_SUBAGENTS_ONLY: "rgb(178,102,255)",
    orange_FOR_SUBAGENTS_ONLY: "rgb(255,178,102)",
    pink_FOR_SUBAGENTS_ONLY: "rgb(255,153,204)",
    cyan_FOR_SUBAGENTS_ONLY: "rgb(102,204,204)",
    professionalBlue: "rgb(106,155,204)",
    rainbow_red: "rgb(235,95,87)",
    rainbow_orange: "rgb(245,139,87)",
    rainbow_yellow: "rgb(250,195,95)",
    rainbow_green: "rgb(145,200,130)",
    rainbow_blue: "rgb(130,170,220)",
    rainbow_indigo: "rgb(155,130,200)",
    rainbow_violet: "rgb(200,130,180)",
    rainbow_red_shimmer: "rgb(250,155,147)",
    rainbow_orange_shimmer: "rgb(255,185,137)",
    rainbow_yellow_shimmer: "rgb(255,225,155)",
    rainbow_green_shimmer: "rgb(185,230,180)",
    rainbow_blue_shimmer: "rgb(180,205,240)",
    rainbow_indigo_shimmer: "rgb(195,180,230)",
    rainbow_violet_shimmer: "rgb(230,180,210)",
    clawd_body: "rgb(215,119,87)",
    clawd_background: "rgb(0,0,0)",
    userMessageBackground: "rgb(55, 55, 55)",
    bashMessageBackgroundColor: "rgb(65, 60, 65)",
    memoryBackgroundColor: "rgb(55, 65, 70)",
    rate_limit_fill: "rgb(153,204,255)",
    rate_limit_empty: "rgb(69,92,115)"
  }
})
// @from(Start 6312654, End 6313036)
function pUA(A, Q) {
  let B = A;
  if (Q.inverse) B = tA.inverse(B);
  if (Q.strikethrough) B = tA.strikethrough(B);
  if (Q.underline) B = tA.underline(B);
  if (Q.italic) B = tA.italic(B);
  if (Q.bold) B = tA.bold(B);
  if (Q.dim) B = tA.dim(B);
  if (Q.color) B = cUA(B, Q.color, "foreground");
  if (Q.backgroundColor) B = cUA(B, Q.backgroundColor, "background");
  return B
}
// @from(Start 6313038, End 6313113)
function lUA(A, Q) {
  if (!Q) return A;
  return cUA(A, Q, "foreground")
}
// @from(Start 6313115, End 6313355)
function ZB(A, Q, B = "foreground") {
  return (G) => {
    if (!A) return G;
    if (A.startsWith("rgb(") || A.startsWith("#") || A.startsWith("ansi256(") || A.startsWith("ansi:")) return cUA(G, A, B);
    return cUA(G, R7A(Q)[A], B)
  }
}
// @from(Start 6313360, End 6313363)
mX6
// @from(Start 6313365, End 6313368)
dX6
// @from(Start 6313370, End 6315407)
cUA = (A, Q, B) => {
  if (!Q) return A;
  if (Q.startsWith("ansi:")) switch (Q.substring(5)) {
    case "black":
      return B === "foreground" ? tA.black(A) : tA.bgBlack(A);
    case "red":
      return B === "foreground" ? tA.red(A) : tA.bgRed(A);
    case "green":
      return B === "foreground" ? tA.green(A) : tA.bgGreen(A);
    case "yellow":
      return B === "foreground" ? tA.yellow(A) : tA.bgYellow(A);
    case "blue":
      return B === "foreground" ? tA.blue(A) : tA.bgBlue(A);
    case "magenta":
      return B === "foreground" ? tA.magenta(A) : tA.bgMagenta(A);
    case "cyan":
      return B === "foreground" ? tA.cyan(A) : tA.bgCyan(A);
    case "white":
      return B === "foreground" ? tA.white(A) : tA.bgWhite(A);
    case "blackBright":
      return B === "foreground" ? tA.blackBright(A) : tA.bgBlackBright(A);
    case "redBright":
      return B === "foreground" ? tA.redBright(A) : tA.bgRedBright(A);
    case "greenBright":
      return B === "foreground" ? tA.greenBright(A) : tA.bgGreenBright(A);
    case "yellowBright":
      return B === "foreground" ? tA.yellowBright(A) : tA.bgYellowBright(A);
    case "blueBright":
      return B === "foreground" ? tA.blueBright(A) : tA.bgBlueBright(A);
    case "magentaBright":
      return B === "foreground" ? tA.magentaBright(A) : tA.bgMagentaBright(A);
    case "cyanBright":
      return B === "foreground" ? tA.cyanBright(A) : tA.bgCyanBright(A);
    case "whiteBright":
      return B === "foreground" ? tA.whiteBright(A) : tA.bgWhiteBright(A)
  }
  if (Q.startsWith("#")) return B === "foreground" ? tA.hex(Q)(A) : tA.bgHex(Q)(A);
  if (Q.startsWith("ansi256")) {
    let G = dX6.exec(Q);
    if (!G) return A;
    let Z = Number(G[1]);
    return B === "foreground" ? tA.ansi256(Z)(A) : tA.bgAnsi256(Z)(A)
  }
  if (Q.startsWith("rgb")) {
    let G = mX6.exec(Q);
    if (!G) return A;
    let Z = Number(G[1]),
      I = Number(G[2]),
      Y = Number(G[3]);
    return B === "foreground" ? tA.rgb(Z, I, Y)(A) : tA.bgRgb(Z, I, Y)(A)
  }
  return A
}
// @from(Start 6315413, End 6315531)
iUA = L(() => {
  F9();
  _aA();
  mX6 = /^rgb\(\s?(\d+),\s?(\d+),\s?(\d+)\s?\)$/, dX6 = /^ansi256\(\s?(\d+)\s?\)$/
})
// @from(Start 6315534, End 6315941)
function $UB(A, Q, B, G = 0, Z) {
  let I = xZ(Q),
    Y = A.length;
  if (I >= Y - 2) return Q.substring(0, Y);
  let J;
  if (B === "center") J = Math.floor((Y - I) / 2);
  else if (B === "start") J = G + 1;
  else J = Y - I - G - 1;
  J = Math.max(1, Math.min(J, Y - I - 1));
  let W = Z.repeat(J - 1),
    X = Z.repeat(Y - J - I - 1);
  return A.substring(0, 1) + W + Q + X + A.substring(A.length - 1)
}
// @from(Start 6315946, End 6315949)
wUB
// @from(Start 6315951, End 6315954)
cX6
// @from(Start 6315956, End 6318046)
pX6 = (A, Q, B, G) => {
    if (B.style.borderStyle) {
      let Z = Math.floor(B.yogaNode.getComputedWidth()),
        I = Math.floor(B.yogaNode.getComputedHeight()),
        Y = typeof B.style.borderStyle === "string" ? cX6[B.style.borderStyle] ?? wUB.default[B.style.borderStyle] : B.style.borderStyle,
        J = B.style.borderTopColor ?? B.style.borderColor,
        W = B.style.borderBottomColor ?? B.style.borderColor,
        X = B.style.borderLeftColor ?? B.style.borderColor,
        V = B.style.borderRightColor ?? B.style.borderColor,
        F = B.style.borderTopDimColor ?? B.style.borderDimColor,
        K = B.style.borderBottomDimColor ?? B.style.borderDimColor,
        D = B.style.borderLeftDimColor ?? B.style.borderDimColor,
        H = B.style.borderRightDimColor ?? B.style.borderDimColor,
        C = B.style.borderTop !== !1,
        E = B.style.borderBottom !== !1,
        U = B.style.borderLeft !== !1,
        q = B.style.borderRight !== !1,
        w = Math.max(0, Z - (U ? 1 : 0) - (q ? 1 : 0)),
        N = C ? (U ? Y.topLeft : "") + Y.top.repeat(w) + (q ? Y.topRight : "") : "";
      if (C && B.style.borderText?.position === "top") {
        let e = B.style.borderText;
        N = $UB(N, e.content, e.align, e.offset, Y.top)
      }
      let R = C ? lUA(N, J) : void 0;
      if (C && F) R = tA.dim(R);
      let T = I;
      if (C) T -= 1;
      if (E) T -= 1;
      T = Math.max(0, T);
      let y = (lUA(Y.left, X) + `
`).repeat(T);
      if (D) y = tA.dim(y);
      let v = (lUA(Y.right, V) + `
`).repeat(T);
      if (H) v = tA.dim(v);
      let x = E ? (U ? Y.bottomLeft : "") + Y.bottom.repeat(w) + (q ? Y.bottomRight : "") : "";
      if (E && B.style.borderText?.position === "bottom") {
        let e = B.style.borderText;
        x = $UB(x, e.content, e.align, e.offset, Y.bottom)
      }
      let p = E ? lUA(x, W) : void 0;
      if (E && K) p = tA.dim(p);
      let u = C ? 1 : 0;
      if (R) G.write(A, Q, R);
      if (U) G.write(A, Q + u, y);
      if (q) G.write(A + Z - 1, Q + u, v);
      if (p) G.write(A, Q + I - 1, p)
    }
  }
// @from(Start 6318050, End 6318053)
qUB
// @from(Start 6318059, End 6318327)
NUB = L(() => {
  F9();
  E7A();
  iUA();
  wUB = BA(UUB(), 1), cX6 = {
    dashed: {
      top: "╌",
      left: "╎",
      right: "╎",
      bottom: "╌",
      topLeft: " ",
      topRight: " ",
      bottomLeft: " ",
      bottomRight: " "
    }
  };
  qUB = pX6
})
// @from(Start 6318330, End 6318402)
function Ng1(A, Q) {
  return `${LUB}8;;${Q}${MUB}${A}${LUB}8;;${MUB}`
}
// @from(Start 6318404, End 6319743)
function lX6(A) {
  if (A.length === 0) return {};
  let Q = A[0].styles,
    B = A.slice(1),
    G = Q.color !== void 0 && B.every((F) => F.styles.color === Q.color) ? Q.color : void 0,
    Z = Q.backgroundColor !== void 0 && B.every((F) => F.styles.backgroundColor === Q.backgroundColor) ? Q.backgroundColor : void 0,
    I = Q.dim !== void 0 && B.every((F) => F.styles.dim === Q.dim) ? Q.dim : void 0,
    Y = Q.bold !== void 0 && B.every((F) => F.styles.bold === Q.bold) ? Q.bold : void 0,
    J = Q.italic !== void 0 && B.every((F) => F.styles.italic === Q.italic) ? Q.italic : void 0,
    W = Q.underline !== void 0 && B.every((F) => F.styles.underline === Q.underline) ? Q.underline : void 0,
    X = Q.strikethrough !== void 0 && B.every((F) => F.styles.strikethrough === Q.strikethrough) ? Q.strikethrough : void 0,
    V = Q.inverse !== void 0 && B.every((F) => F.styles.inverse === Q.inverse) ? Q.inverse : void 0;
  return {
    ...G !== void 0 && {
      color: G
    },
    ...Z !== void 0 && {
      backgroundColor: Z
    },
    ...I !== void 0 && {
      dim: I
    },
    ...Y !== void 0 && {
      bold: Y
    },
    ...J !== void 0 && {
      italic: J
    },
    ...W !== void 0 && {
      underline: W
    },
    ...X !== void 0 && {
      strikethrough: X
    },
    ...V !== void 0 && {
      inverse: V
    }
  }
}
// @from(Start 6319745, End 6319799)
function iX6(A) {
  return Object.keys(A).length > 0
}
// @from(Start 6319801, End 6319983)
function nX6(A, Q) {
  let B = A.childNodes[0]?.yogaNode;
  if (B) {
    let G = B.getComputedLeft(),
      Z = B.getComputedTop();
    Q = `
`.repeat(Z) + wg1(Q, G)
  }
  return Q
}
// @from(Start 6319985, End 6322177)
function OUB(A, Q, {
  offsetX: B = 0,
  offsetY: G = 0,
  skipStaticElements: Z
}) {
  if (Z && A.internal_static) return;
  let {
    yogaNode: I
  } = A;
  if (I) {
    if (I.getDisplay() === CT.None) return;
    let Y = B + I.getComputedLeft(),
      J = G + I.getComputedTop();
    if (A.nodeName === "ink-text") {
      let X = KaA(A),
        V = X.map((F) => F.text).join("");
      if (V.length > 0) {
        let F = HUB(I),
          K = A.style.textWrap ?? "wrap",
          H = C7A(V) > F,
          C;
        if (H && X.length === 1) {
          let E = X[0];
          C = ob(V, F, K).split(`
`).map((q) => {
            let w = pUA(q, E.styles);
            if (E.hyperlink) w = Ng1(w, E.hyperlink);
            return w
          }).join(`
`)
        } else if (H) {
          C = X.map((U) => {
            let q = pUA(U.text, U.styles);
            if (U.hyperlink) q = Ng1(q, U.hyperlink);
            return q
          }).join(""), C = ob(C, F, K);
          let E = lX6(X);
          if (iX6(E)) C = C.split(`
`).map((U) => pUA(U, E)).join(`
`)
        } else C = X.map((E) => {
          let U = pUA(E.text, E.styles);
          if (E.hyperlink) U = Ng1(U, E.hyperlink);
          return U
        }).join("");
        C = nX6(A, C), Q.write(Y, J, C)
      }
      return
    }
    let W = !1;
    if (A.nodeName === "ink-box") {
      qUB(Y, J, A, Q);
      let X = A.style.overflowX === "hidden" || A.style.overflow === "hidden",
        V = A.style.overflowY === "hidden" || A.style.overflow === "hidden";
      if (X || V) {
        let F = X ? Y + I.getComputedBorder(_6.Left) : void 0,
          K = X ? Y + I.getComputedWidth() - I.getComputedBorder(_6.Right) : void 0,
          D = V ? J + I.getComputedBorder(_6.Top) : void 0,
          H = V ? J + I.getComputedHeight() - I.getComputedBorder(_6.Bottom) : void 0;
        Q.clip({
          x1: F,
          x2: K,
          y1: D,
          y2: H
        }), W = !0
      }
    }
    if (A.nodeName === "ink-root" || A.nodeName === "ink-box") {
      for (let X of A.childNodes) OUB(X, Q, {
        offsetX: Y,
        offsetY: J,
        skipStaticElements: Z
      });
      if (W) Q.unclip()
    }
  }
}
// @from(Start 6322182, End 6322195)
LUB = "\x1B]"
// @from(Start 6322199, End 6322211)
MUB = "\x07"
// @from(Start 6322215, End 6322218)
Lg1
// @from(Start 6322224, End 6322316)
RUB = L(() => {
  YaA();
  ft();
  FaA();
  CUB();
  th1();
  NUB();
  iUA();
  Lg1 = OUB
})
// @from(Start 6322319, End 6322398)
function Mg1(A) {
  if (!Number.isInteger(A)) return !1;
  return ht(A) === 2
}
// @from(Start 6322403, End 6322429)
TUB = L(() => {
  PUA()
})
// @from(Start 6322432, End 6322676)
function oX6(A) {
  if (Rg1.has(A)) return A;
  if (Og1.has(A)) return Og1.get(A);
  if (A = A.slice(2), A.includes(";")) A = A[0] + "0";
  let Q = u7.codes.get(Number.parseInt(A, 10));
  if (Q) return u7.color.ansi(Q);
  return u7.reset.open
}
// @from(Start 6322678, End 6322821)
function tX6(A) {
  for (let Q = 0; Q < A.length; Q++) {
    let B = A.codePointAt(Q);
    if (B >= sX6 && B <= rX6) return Q
  }
  return -1
}
// @from(Start 6322823, End 6323003)
function eX6(A, Q) {
  A = A.slice(Q, Q + 19);
  let B = tX6(A);
  if (B !== -1) {
    let G = A.indexOf("m", B);
    if (G === -1) G = A.length;
    return A.slice(0, G + 1)
  }
}
// @from(Start 6323005, End 6323568)
function AV6(A, Q = Number.POSITIVE_INFINITY) {
  let B = [],
    G = 0,
    Z = 0;
  while (G < A.length) {
    let I = A.codePointAt(G);
    if (aX6.has(I)) {
      let W = eX6(A, G);
      if (W) {
        B.push({
          type: "ansi",
          code: W,
          endCode: oX6(W)
        }), G += W.length;
        continue
      }
    }
    let Y = Mg1(I),
      J = String.fromCodePoint(I);
    if (B.push({
        type: "character",
        value: J,
        isFullWidth: Y
      }), G += J.length, Z += Y ? 2 : J.length, Z >= Q) break
  }
  return B
}
// @from(Start 6323570, End 6323812)
function PUB(A) {
  let Q = [];
  for (let B of A)
    if (B.code === u7.reset.open) Q = [];
    else if (Rg1.has(B.code)) Q = Q.filter((G) => G.endCode !== B.code);
  else Q = Q.filter((G) => G.endCode !== B.endCode), Q.push(B);
  return Q
}
// @from(Start 6323814, End 6323901)
function QV6(A) {
  return PUB(A).map(({
    endCode: G
  }) => G).reverse().join("")
}
// @from(Start 6323903, End 6324338)
function ct(A, Q, B) {
  let G = AV6(A, B),
    Z = [],
    I = 0,
    Y = "",
    J = !1;
  for (let W of G) {
    if (B !== void 0 && I >= B) break;
    if (W.type === "ansi") {
      if (Z.push(W), J) Y += W.code
    } else {
      if (!J && I >= Q) J = !0, Z = PUB(Z), Y = Z.map(({
        code: X
      }) => X).join("");
      if (J) Y += W.value;
      I += W.isFullWidth ? 2 : W.value.length
    }
  }
  return Y += QV6(Z), Y
}
// @from(Start 6324343, End 6324346)
aX6
// @from(Start 6324348, End 6324351)
sX6
// @from(Start 6324353, End 6324356)
rX6
// @from(Start 6324358, End 6324361)
Rg1
// @from(Start 6324363, End 6324366)
Og1
// @from(Start 6324372, End 6324620)
Tg1 = L(() => {
  z7A();
  TUB();
  aX6 = new Set([27, 155]), sX6 = "0".codePointAt(0), rX6 = "9".codePointAt(0), Rg1 = new Set, Og1 = new Map;
  for (let [A, Q] of u7.codes) Rg1.add(u7.color.ansi(Q)), Og1.set(u7.color.ansi(A), u7.color.ansi(Q))
})
// @from(Start 6324623, End 6324968)
function Sg1(A) {
  if (kaA.has(A)) return A;
  if (Pg1.has(A)) return Pg1.get(A);
  if (A.startsWith(yaA)) return BV6;
  if (A = A.slice(2), A.startsWith("38")) return u7.color.close;
  else if (A.startsWith("48")) return u7.bgColor.close;
  let Q = u7.codes.get(parseInt(A, 10));
  if (Q) return u7.color.ansi(Q);
  else return u7.reset.open
}
// @from(Start 6324970, End 6325027)
function pt(A) {
  return A.map((Q) => Q.code).join("")
}
// @from(Start 6325032, End 6325035)
jUB
// @from(Start 6325037, End 6325040)
SUB
// @from(Start 6325042, End 6325045)
_UB
// @from(Start 6325047, End 6325050)
kaA
// @from(Start 6325052, End 6325055)
Pg1
// @from(Start 6325057, End 6325073)
yaA = "\x1B]8;;"
// @from(Start 6325077, End 6325080)
jg1
// @from(Start 6325082, End 6325094)
kUB = "\x07"
// @from(Start 6325098, End 6325101)
$p7
// @from(Start 6325103, End 6325106)
BV6
// @from(Start 6325112, End 6325451)
nUA = L(() => {
  z7A();
  jUB = new Set([27, 155]), SUB = "[".codePointAt(0), _UB = "]".codePointAt(0), kaA = new Set, Pg1 = new Map;
  for (let [A, Q] of u7.codes) kaA.add(u7.color.ansi(Q)), Pg1.set(u7.color.ansi(A), u7.color.ansi(Q));
  jg1 = yaA.split("").map((A) => A.charCodeAt(0)), $p7 = kUB.charCodeAt(0), BV6 = `\x1B]8;;${kUB}`
})
// @from(Start 6325454, End 6325493)
function _g1(A) {
  return xaA([], A)
}
// @from(Start 6325495, End 6325890)
function xaA(A, Q) {
  let B = [...A];
  for (let G of Q)
    if (G.code === u7.reset.open) B = [];
    else if (kaA.has(G.code)) B = B.filter((Z) => Z.endCode !== G.code);
  else if (G.code === u7.bold.open || G.code === u7.dim.open) {
    if (!B.find((I) => I.code === G.code && I.endCode === G.endCode)) B.push(G)
  } else B = B.filter((I) => I.endCode !== G.endCode), B.push(G);
  return B
}
// @from(Start 6325895, End 6325930)
vaA = L(() => {
  z7A();
  nUA()
})
// @from(Start 6325933, End 6326028)
function kg1(A) {
  return _g1(A).reverse().map((Q) => ({
    ...Q,
    code: Q.endCode
  }))
}
// @from(Start 6326033, End 6326059)
yg1 = L(() => {
  vaA()
})
// @from(Start 6326062, End 6326256)
function Qp(A, Q) {
  let B = new Set(Q.map((Z) => Z.endCode)),
    G = new Set(A.map((Z) => Z.code));
  return [...kg1(A.filter((Z) => !B.has(Z.endCode))), ...Q.filter((Z) => !G.has(Z.code))]
}
// @from(Start 6326261, End 6326287)
xg1 = L(() => {
  yg1()
})
// @from(Start 6326290, End 6326485)
function yUB(A) {
  let Q = [],
    B = [];
  for (let G of A)
    if (G.type === "ansi") Q = xaA(Q, [G]);
    else if (G.type === "char") B.push({
    ...G,
    styles: [...Q]
  });
  return B
}
// @from(Start 6326487, End 6326745)
function xUB(A) {
  let Q = "";
  for (let B = 0; B < A.length; B++) {
    let G = A[B];
    if (B === 0) Q += pt(G.styles);
    else Q += pt(Qp(A[B - 1].styles, G.styles));
    if (Q += G.value, B === A.length - 1) Q += pt(Qp(G.styles, []))
  }
  return Q
}
// @from(Start 6326750, End 6326794)
vUB = L(() => {
  nUA();
  xg1();
  vaA()
})
// @from(Start 6326797, End 6326881)
function vg1(A) {
  if (!Number.isInteger(A)) return !1;
  return RUA(A) || TUA(A)
}
// @from(Start 6326886, End 6326912)
bUB = L(() => {
  PUA()
})
// @from(Start 6326915, End 6327130)
function GV6(A, Q) {
  A = A.slice(Q);
  for (let G = 1; G < jg1.length; G++)
    if (A.charCodeAt(G) !== jg1[G]) return;
  let B = A.indexOf("\x07", yaA.length);
  if (B === -1) return;
  return A.slice(0, B + 1)
}
// @from(Start 6327132, End 6327343)
function WV6(A) {
  for (let Q = 2; Q < A.length; Q++) {
    let B = A.charCodeAt(Q);
    if (B === JV6) return Q;
    if (B === YV6) continue;
    if (B >= ZV6 && B <= IV6) continue;
    break
  }
  return -1
}
// @from(Start 6327345, End 6327454)
function XV6(A, Q) {
  A = A.slice(Q);
  let B = WV6(A);
  if (B === -1) return;
  return A.slice(0, B + 1)
}
// @from(Start 6327456, End 6327968)
function VV6(A) {
  if (!A.includes(";")) return [A];
  let Q = A.slice(2, -1).split(";"),
    B = [];
  for (let G = 0; G < Q.length; G++) {
    let Z = Q[G];
    if (Z === "38" || Z === "48") {
      if (G + 2 < Q.length && Q[G + 1] === "5") {
        B.push(Q.slice(G, G + 3).join(";")), G += 2;
        continue
      } else if (G + 4 < Q.length && Q[G + 1] === "2") {
        B.push(Q.slice(G, G + 5).join(";")), G += 4;
        continue
      }
    }
    B.push(Z)
  }
  return B.map((G) => `\x1B[${G}m`)
}
// @from(Start 6327970, End 6328822)
function fUB(A, Q = Number.POSITIVE_INFINITY) {
  let B = [],
    G = 0,
    Z = 0;
  while (G < A.length) {
    let I = A.codePointAt(G);
    if (jUB.has(I)) {
      let W, X = A.codePointAt(G + 1);
      if (X === _UB) {
        if (W = GV6(A, G), W) B.push({
          type: "ansi",
          code: W,
          endCode: Sg1(W)
        })
      } else if (X === SUB) {
        if (W = XV6(A, G), W) {
          let V = VV6(W);
          for (let F of V) B.push({
            type: "ansi",
            code: F,
            endCode: Sg1(F)
          })
        }
      }
      if (W) {
        G += W.length;
        continue
      }
    }
    let Y = vg1(I),
      J = String.fromCodePoint(I);
    if (B.push({
        type: "char",
        value: J,
        fullWidth: Y
      }), G += J.length, Z += Y ? 2 : J.length, Z >= Q) break
  }
  return B
}
// @from(Start 6328827, End 6328835)
ZV6 = 48
// @from(Start 6328839, End 6328847)
IV6 = 57
// @from(Start 6328851, End 6328859)
YV6 = 59
// @from(Start 6328863, End 6328872)
JV6 = 109
// @from(Start 6328878, End 6328913)
hUB = L(() => {
  bUB();
  nUA()
})
// @from(Start 6328919, End 6328990)
baA = L(() => {
  nUA();
  xg1();
  vaA();
  yg1();
  vUB();
  hUB()
})
// @from(Start 6328993, End 6329056)
function faA(A, Q) {
  return Q.x < A.width && Q.y < A.height
}
// @from(Start 6329058, End 6329210)
function OW(A, Q) {
  if (A === void 0) return;
  if (Number.isInteger(A)) return;
  g(`${Q} should be an integer, got ${A}`, {
    level: "warn"
  })
}
// @from(Start 6329215, End 6329240)
bg1 = L(() => {
  V0()
})
// @from(Start 6329246, End 6329265)
uUB = "\x1B[?2026h"
// @from(Start 6329269, End 6329288)
mUB = "\x1B[?2026l"
// @from(Start 6329292, End 6329304)
dUB = "\x1B"
// @from(Start 6329308, End 6329321)
fg1 = "\x1B]"
// @from(Start 6329325, End 6329337)
T7A = "\x07"
// @from(Start 6329341, End 6329350)
P7A = ";"
// @from(Start 6329353, End 6329391)
function lUB(A) {
  return A === pUB
}
// @from(Start 6329393, End 6329688)
function KV6(A, Q) {
  if (A.char !== Q.char || A.width !== Q.width) return !1;
  if (A.hyperlink !== Q.hyperlink) return !1;
  if (A.styles.length !== Q.styles.length) return !1;
  for (let B = 0; B < A.styles.length; B++)
    if (A.styles[B].code !== Q.styles[B].code) return !1;
  return !0
}
// @from(Start 6329690, End 6330010)
function j7A(A, Q) {
  if (OW(A, "createScreen width"), OW(Q, "createScreen height"), !Number.isInteger(A) || A < 0) A = Math.max(0, Math.floor(A) || 0);
  if (!Number.isInteger(Q) || Q < 0) Q = Math.max(0, Math.floor(Q) || 0);
  let B = Array(A * Q).fill(pUB);
  return {
    width: A,
    height: Q,
    cells: B
  }
}
// @from(Start 6330012, End 6330111)
function haA(A, Q) {
  if (!faA(A, Q)) return;
  let B = Q.y * A.width + Q.x;
  return A.cells[B]
}
// @from(Start 6330113, End 6330203)
function cUB(A, Q) {
  let {
    x: B,
    y: G
  } = Q, Z = A.width;
  return G * Z + B
}
// @from(Start 6330205, End 6330447)
function hg1(A, Q, B) {
  if (!faA(A, Q)) return;
  let G = cUB(A, Q);
  if (A.cells[G] = B, B.width === 1) {
    let Z = {
      x: Q.x + 1,
      y: Q.y
    };
    if (faA(A, Z)) {
      let I = cUB(A, Z);
      A.cells[I] = FV6
    }
  }
}
// @from(Start 6330449, End 6330569)
function nUB(A) {
  for (let Q of A) {
    let B = Q.code.match(iUB);
    if (B) return B[1] || null
  }
  return null
}
// @from(Start 6330571, End 6330634)
function aUB(A) {
  return A.filter((Q) => !iUB.test(Q.code))
}
// @from(Start 6330636, End 6331002)
function sUB(A, Q) {
  let B = [],
    G = Math.max(A.height, Q.height),
    Z = Math.max(A.width, Q.width);
  for (let I = 0; I < G; I += 1)
    for (let Y = 0; Y < Z; Y += 1) {
      let J = {
          x: Y,
          y: I
        },
        W = haA(A, J),
        X = haA(Q, J);
      if (W && X && KV6(W, X)) continue;
      B.push([J, W, X])
    }
  return B
}
// @from(Start 6331007, End 6331010)
pUB
// @from(Start 6331012, End 6331015)
FV6
// @from(Start 6331017, End 6331020)
iUB
// @from(Start 6331026, End 6331311)
aUA = L(() => {
  bg1();
  pUB = Object.freeze({
    char: " ",
    styles: [],
    width: 0,
    hyperlink: void 0
  });
  FV6 = Object.freeze({
    char: "",
    styles: [],
    width: 2,
    hyperlink: void 0
  });
  iUB = new RegExp(`^${dUB}\\]8${P7A}${P7A}([^${T7A}]*)${T7A}$`)
})
// @from(Start 6331313, End 6336502)
class sUA {
  width;
  height;
  ink2;
  operations = [];
  charCache;
  styledCharsToStringCache = {};
  constructor(A) {
    let {
      width: Q,
      height: B,
      ink2: G = !1,
      charCache: Z = new Map
    } = A;
    this.width = Q, this.height = B, this.ink2 = G, this.charCache = Z
  }
  write(A, Q, B) {
    if (!B) return;
    this.operations.push({
      type: "write",
      x: A,
      y: Q,
      text: B
    })
  }
  clip(A) {
    this.operations.push({
      type: "clip",
      clip: A
    })
  }
  unclip() {
    this.operations.push({
      type: "unclip"
    })
  }
  get() {
    let A = Array(this.height);
    for (let Z = 0; Z < this.height; Z++) A[Z] = Array(this.width).fill(rUB);
    let Q = j7A(this.width, this.height),
      B = [];
    for (let Z of this.operations) {
      if (Z.type === "clip") B.push(Z.clip);
      if (Z.type === "unclip") B.pop();
      if (Z.type === "write") {
        let {
          text: I
        } = Z, {
          x: Y,
          y: J
        } = Z, W = I.split(`
`), X = B.at(-1);
        if (X) {
          let F = typeof X?.x1 === "number" && typeof X?.x2 === "number",
            K = typeof X?.y1 === "number" && typeof X?.y2 === "number";
          if (F) {
            let D = C7A(I);
            if (Y + D < X.x1 || Y > X.x2) continue
          }
          if (K) {
            let D = W.length;
            if (J + D < X.y1 || J > X.y2) continue
          }
          if (F) {
            if (W = W.map((D) => {
                let H = Y < X.x1 ? X.x1 - Y : 0,
                  C = xZ(D),
                  E = Y + C > X.x2 ? X.x2 - Y : C;
                return ct(D, H, E)
              }), Y < X.x1) Y = X.x1
          }
          if (K) {
            let D = J < X.y1 ? X.y1 - J : 0,
              H = W.length,
              C = J + H > X.y2 ? X.y2 - J : H;
            if (W = W.slice(D, C), J < X.y1) J = X.y1
          }
        }
        let V = 0;
        for (let F of W) {
          let K = A[J + V];
          if (!K) continue;
          let D = this.charCache.get(F);
          if (!D) {
            let C = yUB(fUB(F));
            D = this.ink2 ? CV6(C) : C, this.charCache.set(F, D)
          }
          let H = Y;
          for (let C = 0; C < D.length; C++) {
            let E = D[C];
            if (this.ink2) {
              let q = E.value.codePointAt(0);
              if (q === 8203 || q === 8204 || q === 8205 || q === 65279 || q === 8288) continue;
              if (q !== void 0 && q <= 31) {
                if (q === 9) {
                  let N = 8 - H % 8;
                  for (let R = 0; R < N && H < this.width; R++) K[H] = rUB, hg1(Q, {
                    x: H,
                    y: J + V
                  }, {
                    char: " ",
                    styles: [],
                    width: 0,
                    hyperlink: void 0
                  }), H++
                } else if (q === 27) {
                  let w = D[C + 1]?.value,
                    N = w?.codePointAt(0);
                  if (w === "(" || w === ")" || w === "*" || w === "+") C += 2;
                  else if (w === "[") {
                    C++;
                    while (C < D.length - 1) {
                      C++;
                      let R = D[C]?.value.codePointAt(0);
                      if (R !== void 0 && R >= 64 && R <= 126) break
                    }
                  } else if (w === "]" || w === "P" || w === "_" || w === "^" || w === "X") {
                    C++;
                    while (C < D.length - 1) {
                      C++;
                      let R = D[C]?.value;
                      if (R === "\x07") break;
                      if (R === "\x1B") {
                        if (D[C + 1]?.value === "\\") {
                          C++;
                          break
                        }
                      }
                    }
                  } else if (N !== void 0 && N >= 48 && N <= 126) C++
                }
                continue
              }
            }
            K[H] = E;
            let U = E.fullWidth || E.value.length > 1;
            if (this.ink2) {
              let q = {
                  x: H,
                  y: J + V
                },
                w = nUB(E.styles),
                N = w ? aUB(E.styles) : E.styles;
              hg1(Q, q, {
                char: E.value,
                styles: N,
                width: U ? 1 : 0,
                hyperlink: w ?? void 0
              })
            }
            if (U) K[H + 1] = {
              type: "char",
              value: "",
              fullWidth: !1,
              styles: E.styles
            };
            H += U ? 2 : 1
          }
          V++
        }
      }
    }
    return {
      output: this.ink2 ? "" : A.map((Z) => {
        let I = Z.filter((J) => J !== void 0),
          Y = JSON.stringify(I);
        if (!Object.prototype.hasOwnProperty.call(this.styledCharsToStringCache, Y)) {
          let J = xUB(I).trimEnd();
          this.styledCharsToStringCache[Y] = J
        }
        return this.styledCharsToStringCache[Y]
      }).join(`
`),
      height: A.length,
      screen: Q
    }
  }
}
// @from(Start 6336504, End 6336717)
function HV6(A, Q) {
  if (A === Q) return !0;
  let B = A.length;
  if (B !== Q.length) return !1;
  if (B === 0) return !0;
  for (let G = 0; G < B; G++)
    if (A[G].code !== Q[G].code) return !1;
  return !0
}
// @from(Start 6336719, End 6337431)
function CV6(A) {
  let Q = A.length;
  if (Q === 0) return [];
  let B = [],
    G = [],
    Z = A[0].styles;
  for (let I = 0; I < Q; I++) {
    let Y = A[I],
      J = Y.styles;
    if (G.length > 0 && !HV6(J, Z)) {
      let W = G.join("");
      for (let {
          segment: X
        }
        of oUB.segment(W)) B.push({
        type: "char",
        value: X,
        fullWidth: $D(X) === 2,
        styles: Z
      });
      G.length = 0
    }
    G.push(Y.value), Z = J
  }
  if (G.length > 0) {
    let I = G.join("");
    for (let {
        segment: Y
      }
      of oUB.segment(I)) B.push({
      type: "char",
      value: Y,
      fullWidth: $D(Y) === 2,
      styles: Z
    })
  }
  return B
}
// @from(Start 6337436, End 6337439)
rUB
// @from(Start 6337441, End 6337444)
oUB
// @from(Start 6337450, End 6337647)
tUB = L(() => {
  Tg1();
  YaA();
  baA();
  E7A();
  aUA();
  jUA();
  rUB = Object.freeze({
    type: "char",
    value: " ",
    fullWidth: !1,
    styles: []
  });
  oUB = new Intl.Segmenter
})
// @from(Start 6337650, End 6339605)
function gg1(A) {
  let Q = new Map;
  return (B) => {
    let {
      terminalWidth: G,
      terminalRows: Z,
      isTTY: I,
      ink2: Y
    } = B, J = A.yogaNode?.getComputedHeight(), W = A.yogaNode?.getComputedWidth(), X = J === void 0 || !Number.isFinite(J) || J < 0, V = W === void 0 || !Number.isFinite(W) || W < 0;
    if (!A.yogaNode || X || V) {
      if (A.yogaNode && (X || V)) g(`Invalid yoga dimensions: width=${W}, height=${J}, childNodes=${A.childNodes.length}, terminalWidth=${G}, terminalRows=${Z}`);
      return {
        output: "",
        outputHeight: 0,
        staticOutput: "",
        rows: Z,
        columns: G,
        cursorVisible: !0,
        screen: j7A(G, 0),
        viewport: {
          width: G,
          height: 0
        },
        cursor: {
          x: 0,
          y: 0,
          visible: !0
        }
      }
    }
    let F = new sUA({
      width: Math.floor(A.yogaNode.getComputedWidth()),
      height: Math.floor(A.yogaNode.getComputedHeight()),
      ink2: Y,
      charCache: Y ? Q : new Map
    });
    Lg1(A, F, {
      skipStaticElements: !0
    });
    let K, D = A.staticNode,
      H = D?.yogaNode?.getComputedHeight(),
      C = D?.yogaNode?.getComputedWidth(),
      E = H !== void 0 && Number.isFinite(H) && H >= 0 && C !== void 0 && Number.isFinite(C) && C >= 0;
    if (!Y && D && D.yogaNode && E) K = new sUA({
      width: Math.floor(C),
      height: Math.floor(H),
      ink2: !1
    }), Lg1(D, K, {
      skipStaticElements: !1
    });
    let {
      output: U,
      height: q,
      screen: w
    } = F.get();
    return {
      output: U,
      outputHeight: q,
      staticOutput: K ? `${K.get().output}
` : "",
      rows: Z,
      columns: G,
      cursorVisible: !I || U === "",
      screen: w,
      viewport: {
        width: G,
        height: Z
      },
      cursor: {
        x: 0,
        y: w.height,
        visible: !0
      },
      progress: eUB(A)
    }
  }
}
// @from(Start 6339607, End 6339925)
function eUB(A) {
  if (A.nodeName === "ink-progress") {
    let Q = A.attributes.state;
    if (Q) return {
      state: Q,
      percentage: A.attributes.percentage
    }
  }
  for (let Q of A.childNodes)
    if ("nodeName" in Q && Q.nodeName !== "#text") {
      let B = eUB(Q);
      if (B) return B
    } return
}
// @from(Start 6339930, End 6339982)
A$B = L(() => {
  RUB();
  tUB();
  aUA();
  V0()
})
// @from(Start 6339985, End 6340273)
function gaA(A, Q) {
  return {
    output: "",
    outputHeight: 0,
    staticOutput: "",
    rows: A,
    columns: Q,
    cursorVisible: !0,
    screen: j7A(0, 0),
    viewport: {
      width: 0,
      height: 0
    },
    cursor: {
      x: 0,
      y: 0,
      visible: !0
    }
  }
}
// @from(Start 6340275, End 6340442)
function Q$B(A, Q) {
  let B = Q.rows !== A.rows || Q.columns !== A.columns,
    G = Q.outputHeight >= Q.rows,
    Z = A.outputHeight >= A.rows;
  return B || G || Z
}
// @from(Start 6340447, End 6340473)
ug1 = L(() => {
  aUA()
})
// @from(Start 6340475, End 6346300)
class pg1 {
  options;
  state;
  constructor(A, Q) {
    this.options = A;
    this.state = {
      fullStaticOutput: "",
      previousOutput: "",
      prevFrame: Q
    }
  }
  render(A) {
    let Q = this.options.ink2 ? this.render_v2(this.state.prevFrame, A) : this.render_v1(this.state.prevFrame, A);
    return this.state.prevFrame = A, Q
  }
  render_v1(A, Q) {
    if (this.options.debug) return this.getRenderOpsDebug_DEPRECATED(Q);
    if (!this.options.isTTY) return [{
      type: "stdout",
      content: Q.staticOutput
    }];
    if (Q$B(A, Q)) return this.getRenderOpsForAllOutput_CAUSES_FLICKER(Q, "resize");
    if (!(Q.staticOutput && Q.staticOutput !== `
`) && Q.output === A.output) return mg1([], A, Q);
    let G = [...this.getRenderOpsForClearAndRenderStaticOutput(A, Q), ...this.renderEfficiently(A, Q)];
    return mg1(G, A, Q)
  }
  renderPreviousOutput_DEPRECATED() {
    if (!this.options.isTTY) return [{
      type: "stdout",
      content: this.state.prevFrame.output
    }, {
      type: "stdout",
      content: `
`
    }];
    else if (!this.options.debug) return this.getRenderOpsForDone(this.state.prevFrame);
    return []
  }
  reset() {
    this.state.prevFrame = gaA(this.state.prevFrame.rows, this.state.prevFrame.columns), this.state.previousOutput = ""
  }
  renderEfficiently(A, Q) {
    let B = Q.output + `
`;
    if (B === this.state.previousOutput) return [];
    let G = this.state.previousOutput ? SUA(this.state.previousOutput, A.columns) : 0;
    this.state.previousOutput = B;
    let Z = [];
    if (!Q.cursorVisible && A.cursorVisible) Z.push({
      type: "cursorHide"
    });
    else if (Q.cursorVisible && !A.cursorVisible) Z.push({
      type: "cursorShow"
    });
    if (G > 0) Z.push({
      type: "clear",
      count: G
    });
    return Z.push({
      type: "stdout",
      content: Q.output
    }), Z.push({
      type: "stdout",
      content: `
`
    }), Z
  }
  getRenderOpsDebug_DEPRECATED(A) {
    if (A.staticOutput && A.staticOutput !== `
`) this.state.fullStaticOutput += A.staticOutput;
    return [{
      type: "stdout",
      content: this.state.fullStaticOutput
    }, {
      type: "stdout",
      content: A.output
    }]
  }
  getRenderOpsForAllOutput_CAUSES_FLICKER(A, Q) {
    if (A.staticOutput && A.staticOutput !== `
`) this.state.fullStaticOutput += A.staticOutput;
    this.state.previousOutput = A.output + `
`;
    let G = [];
    return G.push({
      type: "clearTerminal",
      reason: Q
    }), G.push({
      type: "stdout",
      content: this.state.fullStaticOutput
    }), G.push({
      type: "stdout",
      content: A.output
    }), G.push({
      type: "stdout",
      content: `
`
    }), G
  }
  getRenderOpsForClearAndRenderStaticOutput(A, Q) {
    if (!(Q.staticOutput && Q.staticOutput !== `
`)) return [];
    this.state.fullStaticOutput += Q.staticOutput;
    let G = this.state.previousOutput ? SUA(this.state.previousOutput, A.columns) : 0;
    this.state.previousOutput = "";
    let Z = [];
    if (G > 0) Z.push({
      type: "clear",
      count: G
    });
    return Z.push({
      type: "stdout",
      content: Q.staticOutput
    }), Z
  }
  getRenderOpsForDone(A) {
    if (this.state.previousOutput = "", !A.cursorVisible) return [{
      type: "cursorShow"
    }];
    return []
  }
  render_v2(A, Q) {
    if (Q.screen.height === 0 || Q.screen.width === 0) return [];
    if (Q.viewport.height < A.viewport.height || A.viewport.width !== 0 && Q.viewport.width !== A.viewport.width) return dg1(Q, "resize");
    let B = new lg1(A.cursor, Q.viewport.width),
      G = Math.max(Q.screen.height, 1) - Math.max(A.screen.height, 1),
      Z = G < 0,
      I = G > 0;
    if (Z) {
      let X = A.screen.height - Q.screen.height;
      if (X > A.viewport.height) return dg1(Q, "offscreen");
      B.txn((V) => [
        [{
          type: "clear",
          count: X
        }, {
          type: "cursorMove",
          x: 0,
          y: -1
        }], {
          dx: -V.x,
          dy: -X
        }
      ])
    }
    let Y = Math.max(A.screen.height, Q.screen.height) - Q.viewport.height,
      J = [],
      W = void 0;
    for (let [X, V, F] of sUB(A.screen, Q.screen)) {
      if (I && X.y >= A.screen.height) continue;
      if (F && (F.width === 2 || F.width === 3)) continue;
      if (V && (V.width === 2 || V.width === 3) && !F) continue;
      if (F && lUB(F) && !V) continue;
      if (X.y < Y) return dg1(Q, "offscreen");
      if (cg1(B, X), F) {
        let K = F.hyperlink;
        W = B$B(B.diff, W, K), J = Z$B(B, F, J)
      } else if (V) B.txn(() => [
        [{
          type: "stdout",
          content: " "
        }], {
          dx: 1,
          dy: 0
        }
      ])
    }
    if (J.length > 0) {
      let X = Qp(J, []);
      if (X.length > 0) B.diff.push({
        type: "style",
        codes: X
      });
      J = []
    }
    if (W !== void 0) B.diff.push({
      type: "hyperlink",
      uri: ""
    }), W = void 0;
    if (I) G$B(B, Q, A.screen.height, Q.screen.height);
    if (Q.cursor.y >= Q.screen.height) B.txn((X) => {
      let V = Q.cursor.y - X.y;
      if (V > 0) {
        let K = [{
          type: "carriageReturn"
        }];
        for (let D = 0; D < V; D++) K.push({
          type: "stdout",
          content: `
`
        });
        return [K, {
          dx: -X.x,
          dy: V
        }]
      }
      let F = Q.cursor.y - X.y;
      if (F !== 0 || X.x !== Q.cursor.x) return [
        [{
          type: "carriageReturn"
        }, {
          type: "cursorMove",
          x: Q.cursor.x,
          y: F
        }], {
          dx: Q.cursor.x - X.x,
          dy: F
        }
      ];
      return [
        [], {
          dx: 0,
          dy: 0
        }
      ]
    });
    else cg1(B, Q.cursor);
    return mg1(B.diff, A, Q)
  }
}
// @from(Start 6346302, End 6346646)
function mg1(A, Q, B) {
  let G = Q.progress,
    Z = B.progress;
  if (!(G?.state !== Z?.state || G?.percentage !== Z?.percentage)) return A;
  if (Z) return [...A, {
    type: "progress",
    state: Z
  }];
  else if (G) return [...A, {
    type: "progress",
    state: {
      state: "completed",
      percentage: 0
    }
  }];
  return A
}
// @from(Start 6346648, End 6346764)
function B$B(A, Q, B) {
  if (Q !== B) return A.push({
    type: "hyperlink",
    uri: B ?? ""
  }), B;
  return Q
}
// @from(Start 6346766, End 6346931)
function dg1(A, Q) {
  let B = new lg1({
    x: 0,
    y: 0
  }, A.viewport.width);
  return EV6(B, A), [{
    type: "clearTerminal",
    reason: Q
  }, ...B.diff]
}
// @from(Start 6346933, End 6346987)
function EV6(A, Q) {
  G$B(A, Q, 0, Q.screen.height)
}
// @from(Start 6346989, End 6347742)
function G$B(A, Q, B, G) {
  let Z = [],
    I = void 0;
  for (let Y = B; Y < G; Y += 1) {
    for (let J = 0; J < Q.screen.width; J += 1) {
      let W = {
          x: J,
          y: Y
        },
        X = haA(Q.screen, W);
      if (!X) continue;
      if (X.width === 2 || X.width === 3) continue;
      cg1(A, W);
      let V = X.hyperlink;
      I = B$B(A.diff, I, V), Z = Z$B(A, X, Z)
    }
    A.txn((J) => [
      [{
        type: "stdout",
        content: `
`
      }], {
        dx: -J.x,
        dy: 1
      }
    ])
  }
  if (I !== void 0) A.diff.push({
    type: "hyperlink",
    uri: ""
  });
  if (Z.length > 0) {
    let Y = Qp(Z, []);
    if (Y.length > 0) A.diff.push({
      type: "style",
      codes: Y
    })
  }
  return A
}
// @from(Start 6347744, End 6348177)
function Z$B(A, Q, B) {
  let G = Qp(B, Q.styles);
  return A.txn((Z) => {
    let I = Q.width === 1 ? 2 : 1,
      Y = Z.x >= A.viewportWidth ? I - Z.x : I,
      J = Z.x >= A.viewportWidth ? 1 : 0;
    return [G.length > 0 ? [{
      type: "style",
      codes: G
    }, {
      type: "stdout",
      content: Q.char
    }] : [{
      type: "stdout",
      content: Q.char
    }], {
      dx: Y,
      dy: J
    }]
  }), Q.styles
}
// @from(Start 6348179, End 6348910)
function cg1(A, Q) {
  A.txn((B) => {
    let G = Q.x - B.x,
      Z = Q.y - B.y;
    if (B.x >= A.viewportWidth && Z <= 0) {
      let Y = Z - 1;
      return [
        [{
          type: "resolvePendingWrap"
        }, {
          type: "carriageReturn"
        }, {
          type: "cursorMove",
          x: Q.x,
          y: Y
        }], {
          dx: G,
          dy: Z
        }
      ]
    }
    if (Z !== 0) return [
      [{
        type: "carriageReturn"
      }, {
        type: "cursorMove",
        x: Q.x,
        y: Z
      }], {
        dx: G,
        dy: Z
      }
    ];
    return [
      [{
        type: "cursorMove",
        x: G,
        y: Z
      }], {
        dx: G,
        dy: Z
      }
    ]
  })
}
// @from(Start 6348911, End 6349230)
class lg1 {
  viewportWidth;
  cursor;
  diff = [];
  constructor(A, Q) {
    this.viewportWidth = Q;
    this.cursor = {
      ...A
    }
  }
  txn(A) {
    let [Q, B] = A(this.cursor);
    for (let G of Q) this.diff.push(G);
    this.cursor = {
      x: this.cursor.x + B.dx,
      y: this.cursor.y + B.dy
    }
  }
}
// @from(Start 6349235, End 6349288)
I$B = L(() => {
  ph1();
  ug1();
  aUA();
  baA()
})
// @from(Start 6349294, End 6349297)
zV6
// @from(Start 6349299, End 6349301)
Qf
// @from(Start 6349307, End 6349351)
uaA = L(() => {
  zV6 = new Map, Qf = zV6
})
// @from(Start 6349353, End 6349564)
class S7A {
  _didStopImmediatePropagation = !1;
  didStopImmediatePropagation() {
    return this._didStopImmediatePropagation
  }
  stopImmediatePropagation() {
    this._didStopImmediatePropagation = !0
  }
}
// @from(Start 6349617, End 6349619)
Bp
// @from(Start 6349625, End 6349988)
maA = L(() => {
  Bp = class Bp extends UV6 {
    emit(A, ...Q) {
      if (A === "error") return super.emit(A, ...Q);
      let B = this.rawListeners(A);
      if (B.length === 0) return !1;
      let G = Q[0] instanceof S7A ? Q[0] : null;
      for (let Z of B)
        if (Z.apply(this, Q), G?.didStopImmediatePropagation()) break;
      return !0
    }
  }
})
// @from(Start 6349994, End 6349997)
Y$B
// @from(Start 6349999, End 6350002)
J$B
// @from(Start 6350004, End 6350007)
daA
// @from(Start 6350013, End 6350152)
ig1 = L(() => {
  Y$B = BA(VA(), 1), J$B = Y$B.createContext({
    exit() {}
  });
  J$B.displayName = "InternalAppContext";
  daA = J$B
})
// @from(Start 6350158, End 6350161)
W$B
// @from(Start 6350163, End 6350166)
X$B
// @from(Start 6350168, End 6350171)
caA
// @from(Start 6350177, End 6350452)
ng1 = L(() => {
  maA();
  W$B = BA(VA(), 1), X$B = W$B.createContext({
    stdin: process.stdin,
    internal_eventEmitter: new Bp,
    setRawMode() {},
    isRawModeSupported: !1,
    internal_exitOnCtrlC: !0
  });
  X$B.displayName = "InternalStdinContext";
  caA = X$B
})
// @from(Start 6350458, End 6350461)
V$B
// @from(Start 6350463, End 6350466)
F$B
// @from(Start 6350468, End 6350471)
paA
// @from(Start 6350477, End 6350801)
laA = L(() => {
  V$B = BA(VA(), 1), F$B = V$B.createContext({
    activeId: void 0,
    add() {},
    remove() {},
    activate() {},
    deactivate() {},
    enableFocus() {},
    disableFocus() {},
    focusNext() {},
    focusPrevious() {},
    focus() {}
  });
  F$B.displayName = "InternalFocusContext";
  paA = F$B
})
// @from(Start 6350807, End 6351001)
D$B = z((Ml7, K$B) => {
  var $V6 = /[|\\{}()[\]^$+*?.-]/g;
  K$B.exports = (A) => {
    if (typeof A !== "string") throw TypeError("Expected a string");
    return A.replace($V6, "\\$&")
  }
})
// @from(Start 6351007, End 6356053)
z$B = z((Ol7, E$B) => {
  var wV6 = D$B(),
    qV6 = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".",
    C$B = [].concat(UA("module").builtinModules, "bootstrap_node", "node").map((A) => new RegExp(`(?:\\((?:node:)?${A}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${A}(?:\\.js)?:\\d+:\\d+$)`));
  C$B.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
  class ag1 {
    constructor(A) {
      if (A = {
          ignoredPackages: [],
          ...A
        }, "internals" in A === !1) A.internals = ag1.nodeInternals();
      if ("cwd" in A === !1) A.cwd = qV6;
      this._cwd = A.cwd.replace(/\\/g, "/"), this._internals = [].concat(A.internals, NV6(A.ignoredPackages)), this._wrapCallSite = A.wrapCallSite || !1
    }
    static nodeInternals() {
      return [...C$B]
    }
    clean(A, Q = 0) {
      if (Q = " ".repeat(Q), !Array.isArray(A)) A = A.split(`
`);
      if (!/^\s*at /.test(A[0]) && /^\s*at /.test(A[1])) A = A.slice(1);
      let B = !1,
        G = null,
        Z = [];
      return A.forEach((I) => {
        if (I = I.replace(/\\/g, "/"), this._internals.some((J) => J.test(I))) return;
        let Y = /^\s*at /.test(I);
        if (B) I = I.trimEnd().replace(/^(\s+)at /, "$1");
        else if (I = I.trim(), Y) I = I.slice(3);
        if (I = I.replace(`${this._cwd}/`, ""), I)
          if (Y) {
            if (G) Z.push(G), G = null;
            Z.push(I)
          } else B = !0, G = I
      }), Z.map((I) => `${Q}${I}
`).join("")
    }
    captureString(A, Q = this.captureString) {
      if (typeof A === "function") Q = A, A = 1 / 0;
      let {
        stackTraceLimit: B
      } = Error;
      if (A) Error.stackTraceLimit = A;
      let G = {};
      Error.captureStackTrace(G, Q);
      let {
        stack: Z
      } = G;
      return Error.stackTraceLimit = B, this.clean(Z)
    }
    capture(A, Q = this.capture) {
      if (typeof A === "function") Q = A, A = 1 / 0;
      let {
        prepareStackTrace: B,
        stackTraceLimit: G
      } = Error;
      if (Error.prepareStackTrace = (Y, J) => {
          if (this._wrapCallSite) return J.map(this._wrapCallSite);
          return J
        }, A) Error.stackTraceLimit = A;
      let Z = {};
      Error.captureStackTrace(Z, Q);
      let {
        stack: I
      } = Z;
      return Object.assign(Error, {
        prepareStackTrace: B,
        stackTraceLimit: G
      }), I
    }
    at(A = this.at) {
      let [Q] = this.capture(1, A);
      if (!Q) return {};
      let B = {
        line: Q.getLineNumber(),
        column: Q.getColumnNumber()
      };
      if (H$B(B, Q.getFileName(), this._cwd), Q.isConstructor()) Object.defineProperty(B, "constructor", {
        value: !0,
        configurable: !0
      });
      if (Q.isEval()) B.evalOrigin = Q.getEvalOrigin();
      if (Q.isNative()) B.native = !0;
      let G;
      try {
        G = Q.getTypeName()
      } catch (Y) {}
      if (G && G !== "Object" && G !== "[object Object]") B.type = G;
      let Z = Q.getFunctionName();
      if (Z) B.function = Z;
      let I = Q.getMethodName();
      if (I && Z !== I) B.method = I;
      return B
    }
    parseLine(A) {
      let Q = A && A.match(LV6);
      if (!Q) return null;
      let B = Q[1] === "new",
        G = Q[2],
        Z = Q[3],
        I = Q[4],
        Y = Number(Q[5]),
        J = Number(Q[6]),
        W = Q[7],
        X = Q[8],
        V = Q[9],
        F = Q[10] === "native",
        K = Q[11] === ")",
        D, H = {};
      if (X) H.line = Number(X);
      if (V) H.column = Number(V);
      if (K && W) {
        let C = 0;
        for (let E = W.length - 1; E > 0; E--)
          if (W.charAt(E) === ")") C++;
          else if (W.charAt(E) === "(" && W.charAt(E - 1) === " ") {
          if (C--, C === -1 && W.charAt(E - 1) === " ") {
            let U = W.slice(0, E - 1);
            W = W.slice(E + 1), G += ` (${U}`;
            break
          }
        }
      }
      if (G) {
        let C = G.match(MV6);
        if (C) G = C[1], D = C[2]
      }
      if (H$B(H, W, this._cwd), B) Object.defineProperty(H, "constructor", {
        value: !0,
        configurable: !0
      });
      if (Z) H.evalOrigin = Z, H.evalLine = Y, H.evalColumn = J, H.evalFile = I && I.replace(/\\/g, "/");
      if (F) H.native = !0;
      if (G) H.function = G;
      if (D && G !== D) H.method = D;
      return H
    }
  }

  function H$B(A, Q, B) {
    if (Q) {
      if (Q = Q.replace(/\\/g, "/"), Q.startsWith(`${B}/`)) Q = Q.slice(B.length + 1);
      A.file = Q
    }
  }

  function NV6(A) {
    if (A.length === 0) return [];
    let Q = A.map((B) => wV6(B));
    return new RegExp(`[/\\\\]node_modules[/\\\\](?:${Q.join("|")})[/\\\\][^:]+:\\d+:\\d+`)
  }
  var LV6 = new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"),
    MV6 = /^(.*?) \[as (.*?)\]$/;
  E$B.exports = ag1
})
// @from(Start 6356059, End 6356148)
OV6 = (A, Q = 2) => {
    return A.replace(/^\t+/gm, (B) => " ".repeat(B.length * Q))
  }
// @from(Start 6356152, End 6356155)
U$B
// @from(Start 6356161, End 6356191)
$$B = L(() => {
  U$B = OV6
})
// @from(Start 6356197, End 6356325)
RV6 = (A, Q) => {
    let B = [],
      G = A - Q,
      Z = A + Q;
    for (let I = G; I <= Z; I++) B.push(I);
    return B
  }
// @from(Start 6356329, End 6356744)
TV6 = (A, Q, B = {}) => {
    var G;
    if (typeof A !== "string") throw TypeError("Source code is missing.");
    if (!Q || Q < 1) throw TypeError("Line number must start from `1`.");
    let Z = U$B(A).split(/\r?\n/);
    if (Q > Z.length) return;
    return RV6(Q, (G = B.around) !== null && G !== void 0 ? G : 3).filter((I) => Z[I - 1] !== void 0).map((I) => ({
      line: I,
      value: Z[I - 1]
    }))
  }
// @from(Start 6356748, End 6356751)
w$B
// @from(Start 6356757, End 6356796)
q$B = L(() => {
  $$B();
  w$B = TV6
})
// @from(Start 6356802, End 6356805)
iaA
// @from(Start 6356807, End 6356810)
N$B
// @from(Start 6356812, End 6356814)
VU
// @from(Start 6356820, End 6357898)
rUA = L(() => {
  bg1();
  iaA = BA(VA(), 1), N$B = iaA.forwardRef(({
    children: A,
    flexWrap: Q = "nowrap",
    flexDirection: B = "row",
    flexGrow: G = 0,
    flexShrink: Z = 1,
    ...I
  }, Y) => {
    return OW(I.margin, "margin"), OW(I.marginX, "marginX"), OW(I.marginY, "marginY"), OW(I.marginTop, "marginTop"), OW(I.marginBottom, "marginBottom"), OW(I.marginLeft, "marginLeft"), OW(I.marginRight, "marginRight"), OW(I.padding, "padding"), OW(I.paddingX, "paddingX"), OW(I.paddingY, "paddingY"), OW(I.paddingTop, "paddingTop"), OW(I.paddingBottom, "paddingBottom"), OW(I.paddingLeft, "paddingLeft"), OW(I.paddingRight, "paddingRight"), OW(I.gap, "gap"), OW(I.columnGap, "columnGap"), OW(I.rowGap, "rowGap"), iaA.default.createElement("ink-box", {
      ref: Y,
      style: {
        flexWrap: Q,
        flexDirection: B,
        flexGrow: G,
        flexShrink: Z,
        ...I,
        overflowX: I.overflowX ?? I.overflow ?? "visible",
        overflowY: I.overflowY ?? I.overflow ?? "visible"
      }
    }, A)
  });
  N$B.displayName = "Box";
  VU = N$B
})
// @from(Start 6357901, End 6358445)
function og1({
  children: A,
  initialState: Q
}) {
  let [B, G] = Gp.useState(Q), [Z, I] = Gp.useState(null), Y = naA.useMemo(() => ({
    theme: B,
    setTheme: (J) => {
      c0({
        ...N1(),
        theme: J
      }), G(J), sg1(J), I(null)
    },
    setPreviewTheme: (J) => {
      I(J), sg1(J)
    },
    savePreview: () => {
      if (Z !== null) c0({
        ...N1(),
        theme: Z
      }), G(Z), I(null)
    },
    currentTheme: Z ?? B
  }), [B, Z]);
  return naA.default.createElement(rg1.Provider, {
    value: Y
  }, A)
}
// @from(Start 6358447, End 6358551)
function qB() {
  let {
    currentTheme: A,
    setTheme: Q
  } = Gp.useContext(rg1);
  return [A, Q]
}
// @from(Start 6358553, End 6358706)
function tg1() {
  let {
    setPreviewTheme: A,
    savePreview: Q
  } = Gp.useContext(rg1);
  return {
    setPreviewTheme: A,
    savePreview: Q
  }
}
// @from(Start 6358711, End 6358714)
naA
// @from(Start 6358716, End 6358718)
Gp
// @from(Start 6358720, End 6358723)
rg1
// @from(Start 6358729, End 6358955)
oUA = L(() => {
  jQ();
  eg1();
  naA = BA(VA(), 1), Gp = BA(VA(), 1), rg1 = Gp.createContext({
    theme: null,
    setTheme: (A) => A,
    setPreviewTheme: (A) => A,
    savePreview: () => {},
    currentTheme: null
  })
})
// @from(Start 6358958, End 6359704)
function lt({
  color: A,
  backgroundColor: Q,
  bold: B,
  dim: G,
  italic: Z = !1,
  underline: I = !1,
  strikethrough: Y = !1,
  inverse: J = !1,
  wrap: W = "wrap",
  children: X
}) {
  if (X === void 0 || X === null) return null;
  let V = {
    ...A && {
      color: A
    },
    ...Q && {
      backgroundColor: Q
    },
    ...G && {
      dim: G
    },
    ...B && {
      bold: B
    },
    ...Z && {
      italic: Z
    },
    ...I && {
      underline: I
    },
    ...Y && {
      strikethrough: Y
    },
    ...J && {
      inverse: J
    }
  };
  return L$B.default.createElement("ink-text", {
    style: {
      flexGrow: 0,
      flexShrink: 1,
      flexDirection: "row",
      textWrap: W
    },
    textStyles: V
  }, X)
}
// @from(Start 6359709, End 6359712)
L$B
// @from(Start 6359718, End 6359756)
aaA = L(() => {
  L$B = BA(VA(), 1)
})
// @from(Start 6359759, End 6359925)
function PV6(A, Q) {
  if (!A) return;
  if (A.startsWith("rgb(") || A.startsWith("#") || A.startsWith("ansi256(") || A.startsWith("ansi:")) return A;
  return Q[A]
}
// @from(Start 6359927, End 6360401)
function $({
  color: A,
  backgroundColor: Q,
  dimColor: B = !1,
  bold: G = !1,
  italic: Z = !1,
  underline: I = !1,
  strikethrough: Y = !1,
  inverse: J = !1,
  wrap: W = "wrap",
  children: X
}) {
  let [V] = qB(), F = R7A(V), K = B ? F.inactive : PV6(A, F), D = Q ? F[Q] : void 0;
  return M$B.default.createElement(lt, {
    color: K,
    backgroundColor: D,
    bold: G,
    italic: Z,
    underline: I,
    strikethrough: Y,
    inverse: J,
    wrap: W
  }, X)
}
// @from(Start 6360406, End 6360409)
M$B
// @from(Start 6360415, End 6360480)
saA = L(() => {
  _aA();
  oUA();
  aaA();
  M$B = BA(VA(), 1)
})
// @from(Start 6360560, End 6362662)
function Qu1({
  error: A
}) {
  let Q = A.stack ? A.stack.split(`
`).slice(1) : void 0,
    B = Q ? R$B.parseLine(Q[0]) : void 0,
    G = O$B(B?.file),
    Z, I = 0;
  if (G && B?.line && raA.existsSync(G)) {
    let Y = raA.readFileSync(G, "utf8");
    if (Z = w$B(Y, B.line), Z)
      for (let {
          line: J
        }
        of Z) I = Math.max(I, String(J).length)
  }
  return gX.default.createElement(VU, {
    flexDirection: "column",
    padding: 1
  }, gX.default.createElement(VU, null, gX.default.createElement($, {
    backgroundColor: "error",
    color: "text"
  }, " ", "ERROR", " "), gX.default.createElement($, null, " ", A.message)), B && G && gX.default.createElement(VU, {
    marginTop: 1
  }, gX.default.createElement($, {
    dimColor: !0
  }, G, ":", B.line, ":", B.column)), B && Z && gX.default.createElement(VU, {
    marginTop: 1,
    flexDirection: "column"
  }, Z.map(({
    line: Y,
    value: J
  }) => gX.default.createElement(VU, {
    key: Y
  }, gX.default.createElement(VU, {
    width: I + 1
  }, gX.default.createElement($, {
    dimColor: Y !== B.line,
    backgroundColor: Y === B.line ? "error" : void 0,
    color: Y === B.line ? "text" : void 0
  }, String(Y).padStart(I, " "), ":")), gX.default.createElement($, {
    key: Y,
    backgroundColor: Y === B.line ? "error" : void 0,
    color: Y === B.line ? "text" : void 0
  }, " " + J)))), A.stack && gX.default.createElement(VU, {
    marginTop: 1,
    flexDirection: "column"
  }, A.stack.split(`
`).slice(1).map((Y) => {
    let J = R$B.parseLine(Y);
    if (!J) return gX.default.createElement(VU, {
      key: Y
    }, gX.default.createElement($, {
      dimColor: !0
    }, "- "), gX.default.createElement($, {
      dimColor: !0,
      bold: !0
    }, Y));
    return gX.default.createElement(VU, {
      key: Y
    }, gX.default.createElement($, {
      dimColor: !0
    }, "- "), gX.default.createElement($, {
      dimColor: !0,
      bold: !0
    }, J.function), gX.default.createElement($, {
      dimColor: !0
    }, " ", "(", O$B(J.file) ?? "", ":", J.line, ":", J.column, ")"))
  })))
}
// @from(Start 6362667, End 6362669)
gX
// @from(Start 6362671, End 6362674)
Au1
// @from(Start 6362676, End 6362740)
O$B = (A) => {
    return A?.replace(`file://${T$B()}/`, "")
  }
// @from(Start 6362744, End 6362747)
R$B
// @from(Start 6362753, End 6362926)
P$B = L(() => {
  q$B();
  rUA();
  saA();
  gX = BA(VA(), 1), Au1 = BA(z$B(), 1), R$B = new Au1.default({
    cwd: T$B(),
    internals: Au1.default.nodeInternals()
  })
})
// @from(Start 6362976, End 6363141)
function yV6(A) {
  return {
    name: "",
    fn: !1,
    ctrl: !1,
    meta: !1,
    shift: !1,
    option: !1,
    sequence: A,
    raw: A,
    isPasted: !0
  }
}
// @from(Start 6363143, End 6363401)
function bV6(A) {
  if (jV6.isBuffer(A))
    if (A[0] > 127 && A[1] === void 0) return A[0] -= 128, "\x1B" + String(A);
    else return String(A);
  else if (A !== void 0 && typeof A !== "string") return String(A);
  else if (!A) return "";
  else return A
}
// @from(Start 6363403, End 6364499)
function _$B(A, Q = "") {
  let B = Q === null,
    G = B ? "" : bV6(Q);
  if (A.mode === "IN_PASTE") {
    if ((A.incomplete.slice(-oaA.length + 1) + G).indexOf(oaA) === -1) return [
      [], {
        ...A,
        incomplete: A.incomplete + G
      }
    ]
  }
  let Z = A.incomplete + G,
    I = {
      ...A,
      incomplete: ""
    },
    Y = [],
    J = {
      NORMAL: () => {
        let W = xV6.exec(Z);
        Z = Z.substring(W[0].length);
        let X = W[1];
        if (!W[2] && !B) {
          let V = vV6.exec(X);
          I.incomplete = V[2], X = V[1]
        }
        if (X) Y.push(j$B(X));
        if (W[2] === kV6) I.mode = "IN_PASTE";
        else if (W[2]) Y.push(j$B(W[2]))
      },
      IN_PASTE: () => {
        let W = Z.indexOf(oaA);
        if (W === -1) {
          if (!B) {
            I.incomplete = Z, Z = "";
            return
          }
          W = Z.length
        }
        let X = Z.substring(0, W);
        if (X) Y.push(yV6(X));
        Z = Z.substring(W + oaA.length), I.mode = "NORMAL"
      }
    };
  while (Z) J[I.mode]();
  return [Y, I]
}
// @from(Start 6364504, End 6364507)
SV6
// @from(Start 6364509, End 6364512)
_V6
// @from(Start 6364514, End 6364531)
kV6 = "\x1B[200~"
// @from(Start 6364535, End 6364552)
oaA = "\x1B[201~"
// @from(Start 6364556, End 6364559)
xV6
// @from(Start 6364561, End 6364564)
vV6
// @from(Start 6364566, End 6364569)
S$B
// @from(Start 6364571, End 6364574)
k$B
// @from(Start 6364576, End 6364579)
y$B
// @from(Start 6364581, End 6364701)
fV6 = (A) => {
    return ["[a", "[b", "[c", "[d", "[e", "[2$", "[3$", "[5$", "[6$", "[7$", "[8$", "[Z"].includes(A)
  }
// @from(Start 6364705, End 6364819)
hV6 = (A) => {
    return ["Oa", "Ob", "Oc", "Od", "Oe", "[2^", "[3^", "[5^", "[6^", "[7^", "[8^"].includes(A)
  }
// @from(Start 6364823, End 6367851)
j$B = (A = "") => {
    let Q, B = {
      name: "",
      fn: !1,
      ctrl: !1,
      meta: !1,
      shift: !1,
      option: !1,
      sequence: A,
      raw: A,
      isPasted: !1
    };
    if (B.sequence = B.sequence || A || B.name, A === "\r") B.raw = void 0, B.name = "return";
    else if (A === `
`) B.name = "enter";
    else if (A === "\t") B.name = "tab";
    else if (A === "\b" || A === "\x1B\b") B.name = "backspace", B.meta = A.charAt(0) === "\x1B";
    else if (A === "" || A === "\x1B") B.name = "backspace", B.meta = A.charAt(0) === "\x1B";
    else if (A === "\x1B" || A === "\x1B\x1B") B.name = "escape", B.meta = A.length === 2;
    else if (A === " " || A === "\x1B ") B.name = "space", B.meta = A.length === 2;
    else if (A === "\x1F") B.name = "_", B.ctrl = !0;
    else if (A <= "\x1A" && A.length === 1) B.name = String.fromCharCode(A.charCodeAt(0) + 97 - 1), B.ctrl = !0;
    else if (A.length === 1 && A >= "0" && A <= "9") B.name = "number";
    else if (A.length === 1 && A >= "a" && A <= "z") B.name = A;
    else if (A.length === 1 && A >= "A" && A <= "Z") B.name = A.toLowerCase(), B.shift = !0;
    else if (Q = SV6.exec(A)) B.meta = !0, B.shift = /^[A-Z]$/.test(Q[1]);
    else if (Q = _V6.exec(A)) {
      let G = [...A];
      if (G[0] === "\x1B" && G[1] === "\x1B") B.option = !0;
      let Z = [Q[1], Q[2], Q[4], Q[6]].filter(Boolean).join(""),
        I = (Q[3] || Q[5] || 1) - 1;
      B.ctrl = !!(I & 4), B.meta = !!(I & 10), B.shift = !!(I & 1), B.code = Z, B.name = k$B[Z], B.shift = fV6(Z) || B.shift, B.ctrl = hV6(Z) || B.ctrl
    }
    if (B.raw === "\x1Bb") B.meta = !0, B.name = "left";
    else if (B.raw === "\x1Bf") B.meta = !0, B.name = "right";
    switch (A) {
      case "\x1B[1~":
        return {
          name: "home", ctrl: !1, meta: !1, shift: !1, option: !1, fn: !1, sequence: A, raw: A, isPasted: !1
        };
      case "\x1B[4~":
        return {
          name: "end", ctrl: !1, meta: !1, shift: !1, option: !1, fn: !1, sequence: A, raw: A, isPasted: !1
        };
      case "\x1B[5~":
        return {
          name: "pageup", ctrl: !1, meta: !1, shift: !1, option: !1, fn: !1, sequence: A, raw: A, isPasted: !1
        };
      case "\x1B[6~":
        return {
          name: "pagedown", ctrl: !1, meta: !1, shift: !1, option: !1, fn: !1, sequence: A, raw: A, isPasted: !1
        };
      case "\x1B[1;5D":
        return {
          name: "left", ctrl: !0, meta: !1, shift: !1, option: !1, fn: !1, sequence: A, raw: A, isPasted: !1
        };
      case "\x1B[1;5C":
        return {
          name: "right", ctrl: !0, meta: !1, shift: !1, option: !1, fn: !1, sequence: A, raw: A, isPasted: !1
        };
      case "\x1B[1~":
        return {
          name: "left", ctrl: !0, fn: !0, meta: !1, shift: !1, option: !1, sequence: A, raw: A, isPasted: !1
        };
      case "\x1B[4~":
        return {
          name: "right", ctrl: !0, fn: !0, meta: !1, shift: !1, option: !1, sequence: A, raw: A, isPasted: !1
        }
    }
    return B
  }
// @from(Start 6367857, End 6369790)
Bu1 = L(() => {
  SV6 = /^(?:\x1b)([a-zA-Z0-9])$/, _V6 = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
  xV6 = new RegExp("^(.*?)(" + ["\\x1b\\][0-9]*(?:;[^\\x07\\x1b]*)*(?:\\x07|\\x1b\\\\)", "\\x1bP[^\\x1b]*\\x1b\\\\", "\\x1b\\[[0-9]*(?:;[0-9]*)*[A-Za-z~]", "\\x1bO[A-Za-z]", "\\x1b[\\x00-\\x7F]", "\\x1b\\x1b", "$"].map((A) => `(?:${A})`).join("|") + ")", "s"), vV6 = new RegExp("(.*?)(" + ["\\x1b\\][0-9]*(?:;[^\\x07\\x1b]*)*$", "\\x1bP[^\\x1b]*$", "\\x1b\\[[0-9]*(?:;[0-9]*)*$", "\\x1bO$", "\\x1b$", "$"].map((A) => `(?:${A})`).join("|") + ")", "s"), S$B = {
    mode: "NORMAL",
    incomplete: ""
  };
  k$B = {
    OP: "f1",
    OQ: "f2",
    OR: "f3",
    OS: "f4",
    "[11~": "f1",
    "[12~": "f2",
    "[13~": "f3",
    "[14~": "f4",
    "[[A": "f1",
    "[[B": "f2",
    "[[C": "f3",
    "[[D": "f4",
    "[[E": "f5",
    "[15~": "f5",
    "[17~": "f6",
    "[18~": "f7",
    "[19~": "f8",
    "[20~": "f9",
    "[21~": "f10",
    "[23~": "f11",
    "[24~": "f12",
    "[A": "up",
    "[B": "down",
    "[C": "right",
    "[D": "left",
    "[E": "clear",
    "[F": "end",
    "[H": "home",
    OA: "up",
    OB: "down",
    OC: "right",
    OD: "left",
    OE: "clear",
    OF: "end",
    OH: "home",
    "[1~": "home",
    "[2~": "insert",
    "[3~": "delete",
    "[4~": "end",
    "[5~": "pageup",
    "[6~": "pagedown",
    "[[5~": "pageup",
    "[[6~": "pagedown",
    "[7~": "home",
    "[8~": "end",
    "[a": "up",
    "[b": "down",
    "[c": "right",
    "[d": "left",
    "[e": "clear",
    "[2$": "insert",
    "[3$": "delete",
    "[5$": "pageup",
    "[6$": "pagedown",
    "[7$": "home",
    "[8$": "end",
    Oa: "up",
    Ob: "down",
    Oc: "right",
    Od: "left",
    Oe: "clear",
    "[2^": "insert",
    "[3^": "delete",
    "[5^": "pageup",
    "[6^": "pagedown",
    "[7^": "home",
    "[8^": "end",
    "[Z": "tab"
  }, y$B = [...Object.values(k$B), "backspace"]
})
// @from(Start 6369796, End 6369799)
taA
// @from(Start 6369801, End 6369804)
il7
// @from(Start 6369806, End 6369809)
nl7
// @from(Start 6369811, End 6369814)
al7
// @from(Start 6369816, End 6369819)
sl7
// @from(Start 6369821, End 6369824)
rl7
// @from(Start 6369826, End 6369829)
ol7
// @from(Start 6369831, End 6369834)
tl7
// @from(Start 6369836, End 6369839)
el7
// @from(Start 6369841, End 6369844)
Ai7
// @from(Start 6369846, End 6369849)
tUA
// @from(Start 6369851, End 6369854)
Qi7
// @from(Start 6369856, End 6369859)
Bi7
// @from(Start 6369861, End 6369864)
Gi7
// @from(Start 6369866, End 6369869)
Zi7
// @from(Start 6369871, End 6369874)
Ii7
// @from(Start 6369880, End 6371484)
x$B = L(() => {
  taA = globalThis.window?.document !== void 0, il7 = globalThis.process?.versions?.node !== void 0, nl7 = globalThis.process?.versions?.bun !== void 0, al7 = globalThis.Deno?.version?.deno !== void 0, sl7 = globalThis.process?.versions?.electron !== void 0, rl7 = globalThis.navigator?.userAgent?.includes("jsdom") === !0, ol7 = typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope, tl7 = typeof DedicatedWorkerGlobalScope < "u" && globalThis instanceof DedicatedWorkerGlobalScope, el7 = typeof SharedWorkerGlobalScope < "u" && globalThis instanceof SharedWorkerGlobalScope, Ai7 = typeof ServiceWorkerGlobalScope < "u" && globalThis instanceof ServiceWorkerGlobalScope, tUA = globalThis.navigator?.userAgentData?.platform, Qi7 = tUA === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === !0 || globalThis.process?.platform === "darwin", Bi7 = tUA === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32", Gi7 = tUA === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === !0 || globalThis.navigator?.userAgent?.includes(" Linux ") === !0 || globalThis.process?.platform === "linux", Zi7 = tUA === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform), Ii7 = tUA === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === !0 || globalThis.process?.platform === "android"
})
// @from(Start 6371490, End 6371497)
XM = {}
// @from(Start 6372364, End 6372376)
P7 = "\x1B["
// @from(Start 6372380, End 6372393)
A$A = "\x1B]"
// @from(Start 6372397, End 6372409)
_7A = "\x07"
// @from(Start 6372413, End 6372422)
eUA = ";"
// @from(Start 6372426, End 6372429)
v$B
// @from(Start 6372431, End 6372434)
gV6
// @from(Start 6372436, End 6372439)
uV6
// @from(Start 6372441, End 6372646)
mV6 = (A, Q) => {
    if (typeof A !== "number") throw TypeError("The `x` argument is required");
    if (typeof Q !== "number") return P7 + (A + 1) + "G";
    return P7 + (Q + 1) + eUA + (A + 1) + "H"
  }
// @from(Start 6372650, End 6372928)
dV6 = (A, Q) => {
    if (typeof A !== "number") throw TypeError("The `x` argument is required");
    let B = "";
    if (A < 0) B += P7 + -A + "D";
    else if (A > 0) B += P7 + A + "C";
    if (Q < 0) B += P7 + -Q + "A";
    else if (Q > 0) B += P7 + Q + "B";
    return B
  }
// @from(Start 6372932, End 6372961)
b$B = (A = 1) => P7 + A + "A"
// @from(Start 6372965, End 6372994)
cV6 = (A = 1) => P7 + A + "B"
// @from(Start 6372998, End 6373027)
pV6 = (A = 1) => P7 + A + "C"
// @from(Start 6373031, End 6373060)
lV6 = (A = 1) => P7 + A + "D"
// @from(Start 6373064, End 6373067)
f$B
// @from(Start 6373069, End 6373072)
iV6
// @from(Start 6373074, End 6373077)
nV6
// @from(Start 6373079, End 6373082)
aV6
// @from(Start 6373084, End 6373087)
sV6
// @from(Start 6373089, End 6373092)
rV6
// @from(Start 6373094, End 6373097)
oV6
// @from(Start 6373099, End 6373102)
Iu1
// @from(Start 6373104, End 6373241)
tV6 = (A) => {
    let Q = "";
    for (let B = 0; B < A; B++) Q += h$B + (B < A - 1 ? b$B() : "");
    if (A) Q += f$B;
    return Q
  }
// @from(Start 6373245, End 6373248)
eV6
// @from(Start 6373250, End 6373253)
AF6
// @from(Start 6373255, End 6373258)
h$B
// @from(Start 6373260, End 6373263)
QF6
// @from(Start 6373265, End 6373268)
BF6
// @from(Start 6373270, End 6373273)
Gu1
// @from(Start 6373275, End 6373278)
GF6
// @from(Start 6373280, End 6373283)
ZF6
// @from(Start 6373285, End 6373298)
IF6 = "\x1Bc"
// @from(Start 6373302, End 6373305)
YF6
// @from(Start 6373307, End 6373310)
JF6
// @from(Start 6373312, End 6373315)
WF6
// @from(Start 6373317, End 6373320)
XF6
// @from(Start 6373322, End 6373403)
VF6 = (A, Q) => [A$A, "8", eUA, eUA, Q, _7A, A, A$A, "8", eUA, eUA, _7A].join("")
// @from(Start 6373407, End 6373692)
FF6 = (A, Q = {}) => {
    let B = `${A$A}1337;File=inline=1`;
    if (Q.width) B += `;width=${Q.width}`;
    if (Q.height) B += `;height=${Q.height}`;
    if (Q.preserveAspectRatio === !1) B += ";preserveAspectRatio=0";
    return B + ":" + Buffer.from(A).toString("base64") + _7A
  }
// @from(Start 6373696, End 6373699)
KF6
// @from(Start 6373705, End 6374889)
Yu1 = L(() => {
  x$B();
  v$B = !taA && Zu1.env.TERM_PROGRAM === "Apple_Terminal", gV6 = !taA && Zu1.platform === "win32", uV6 = taA ? () => {
    throw Error("`process.cwd()` only works in Node.js, not the browser.")
  } : Zu1.cwd, f$B = P7 + "G", iV6 = v$B ? "\x1B7" : P7 + "s", nV6 = v$B ? "\x1B8" : P7 + "u", aV6 = P7 + "6n", sV6 = P7 + "E", rV6 = P7 + "F", oV6 = P7 + "?25l", Iu1 = P7 + "?25h", eV6 = P7 + "K", AF6 = P7 + "1K", h$B = P7 + "2K", QF6 = P7 + "J", BF6 = P7 + "1J", Gu1 = P7 + "2J", GF6 = P7 + "S", ZF6 = P7 + "T", YF6 = gV6 ? `${Gu1}${P7}0f` : `${Gu1}${P7}3J${P7}H`, JF6 = P7 + "?1049h", WF6 = P7 + "?1049l", XF6 = _7A, KF6 = {
    setCwd: (A = uV6()) => `${A$A}50;CurrentDir=${A}${_7A}`,
    annotation(A, Q = {}) {
      let B = `${A$A}1337;`,
        G = Q.x !== void 0,
        Z = Q.y !== void 0;
      if ((G || Z) && !(G && Z && Q.length !== void 0)) throw Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      if (A = A.replaceAll("|", ""), B += Q.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", Q.length > 0) B += (G ? [A, Q.length, Q.x, Q.y] : [Q.length, A]).join("|");
      else B += A;
      return B + _7A
    }
  }
})
// @from(Start 6374895, End 6374930)
eaA = L(() => {
  Yu1();
  Yu1()
})
// @from(Start 6374933, End 6375801)
function DF6(A) {
  let Q = {
      upArrow: A.name === "up",
      downArrow: A.name === "down",
      leftArrow: A.name === "left",
      rightArrow: A.name === "right",
      pageDown: A.name === "pagedown",
      pageUp: A.name === "pageup",
      home: A.name === "home",
      end: A.name === "end",
      return: A.name === "return",
      escape: A.name === "escape",
      fn: A.fn,
      ctrl: A.ctrl,
      shift: A.shift,
      tab: A.name === "tab",
      backspace: A.name === "backspace",
      delete: A.name === "delete",
      meta: A.meta || A.name === "escape" || A.option
    },
    B = A.ctrl ? A.name : A.sequence;
  if (B === void 0) B = "";
  if (A.name && y$B.includes(A.name)) B = "";
  if (B.startsWith("\x1B")) B = B.slice(1);
  if (B.length === 1 && typeof B[0] === "string" && B[0].toUpperCase() === B[0]) Q.shift = !0;
  return [Q, B]
}
// @from(Start 6375806, End 6375809)
AsA
// @from(Start 6375815, End 6376035)
Ju1 = L(() => {
  Bu1();
  AsA = class AsA extends S7A {
    keypress;
    key;
    input;
    constructor(A) {
      super();
      let [Q, B] = DF6(A);
      this.keypress = A, this.key = Q, this.input = B
    }
  }
})
// @from(Start 6376041, End 6376044)
g$B
// @from(Start 6376046, End 6376048)
k_
// @from(Start 6376054, End 6376120)
k7A = L(() => {
  g$B = BA(VA(), 1), k_ = g$B.createContext(!1)
})
// @from(Start 6376126, End 6376129)
u$B
// @from(Start 6376131, End 6376134)
Q$A
// @from(Start 6376140, End 6376209)
QsA = L(() => {
  u$B = BA(VA(), 1), Q$A = u$B.createContext(null)
})
// @from(Start 6376215, End 6376217)
y_
// @from(Start 6376219, End 6376229)
HF6 = "\t"
// @from(Start 6376233, End 6376247)
CF6 = "\x1B[Z"
// @from(Start 6376251, End 6376263)
EF6 = "\x1B"
// @from(Start 6376267, End 6376270)
zF6
// @from(Start 6376272, End 6376275)
BsA
// @from(Start 6376281, End 6384443)
m$B = L(() => {
  maA();
  ig1();
  ng1();
  laA();
  P$B();
  Bu1();
  oUA();
  eaA();
  Ju1();
  k7A();
  QsA();
  y_ = BA(VA(), 1), zF6 = process.platform !== "win32";
  BsA = class BsA extends y_.PureComponent {
    static displayName = "InternalApp";
    static getDerivedStateFromError(A) {
      return {
        error: A
      }
    }
    state = {
      isFocusEnabled: !0,
      activeFocusId: void 0,
      focusables: [],
      error: void 0
    };
    rawModeEnabledCount = 0;
    internal_eventEmitter = new Bp;
    keyParseState = S$B;
    incompleteEscapeTimer = null;
    NORMAL_TIMEOUT = 50;
    PASTE_TIMEOUT = 500;
    isRawModeSupported() {
      return this.props.stdin.isTTY
    }
    render() {
      return y_.default.createElement(Q$A.Provider, {
        value: {
          columns: this.props.terminalColumns,
          rows: this.props.terminalRows
        }
      }, y_.default.createElement(k_.Provider, {
        value: this.props.ink2
      }, y_.default.createElement(daA.Provider, {
        value: {
          exit: this.handleExit
        }
      }, y_.default.createElement(og1, {
        initialState: this.props.initialTheme
      }, y_.default.createElement(caA.Provider, {
        value: {
          stdin: this.props.stdin,
          setRawMode: this.handleSetRawMode,
          isRawModeSupported: this.isRawModeSupported(),
          internal_exitOnCtrlC: this.props.exitOnCtrlC,
          internal_eventEmitter: this.internal_eventEmitter
        }
      }, y_.default.createElement(paA.Provider, {
        value: {
          activeId: this.state.activeFocusId,
          add: this.addFocusable,
          remove: this.removeFocusable,
          activate: this.activateFocusable,
          deactivate: this.deactivateFocusable,
          enableFocus: this.enableFocus,
          disableFocus: this.disableFocus,
          focusNext: this.focusNext,
          focusPrevious: this.focusPrevious,
          focus: this.focus
        }
      }, this.state.error ? y_.default.createElement(Qu1, {
        error: this.state.error
      }) : this.props.children))))))
    }
    componentDidMount() {
      if (this.props.stdout.isTTY) this.props.stdout.write(XM.cursorHide)
    }
    componentWillUnmount() {
      if (this.props.stdout.isTTY) this.props.stdout.write(XM.cursorShow);
      if (this.incompleteEscapeTimer) clearTimeout(this.incompleteEscapeTimer), this.incompleteEscapeTimer = null;
      if (this.isRawModeSupported()) this.handleSetRawMode(!1)
    }
    componentDidCatch(A) {
      this.handleExit(A)
    }
    handleSetRawMode = (A) => {
      let {
        stdin: Q
      } = this.props;
      if (!this.isRawModeSupported())
        if (Q === process.stdin) throw Error(`Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.
Read about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);
        else throw Error(`Raw mode is not supported on the stdin provided to Ink.
Read about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);
      if (Q.setEncoding("utf8"), A) {
        if (this.rawModeEnabledCount === 0) Q.ref(), Q.setRawMode(!0), Q.addListener("readable", this.handleReadable), this.props.stdout.write("\x1B[?2004h");
        this.rawModeEnabledCount++;
        return
      }
      if (--this.rawModeEnabledCount === 0) this.props.stdout.write("\x1B[?2004l"), Q.setRawMode(!1), Q.removeListener("readable", this.handleReadable), Q.unref()
    };
    flushIncomplete = () => {
      if (this.incompleteEscapeTimer = null, !this.keyParseState.incomplete) return;
      this.processInput(null)
    };
    processInput = (A) => {
      let [Q, B] = _$B(this.keyParseState, A);
      this.keyParseState = B;
      for (let G of Q) {
        this.handleInput(G.sequence);
        let Z = new AsA(G);
        this.internal_eventEmitter.emit("input", Z)
      }
      if (this.keyParseState.incomplete) {
        if (this.incompleteEscapeTimer) clearTimeout(this.incompleteEscapeTimer);
        this.incompleteEscapeTimer = setTimeout(this.flushIncomplete, this.keyParseState.mode === "IN_PASTE" ? this.PASTE_TIMEOUT : this.NORMAL_TIMEOUT)
      }
    };
    handleReadable = () => {
      let A;
      while ((A = this.props.stdin.read()) !== null) this.processInput(A)
    };
    handleInput = (A) => {
      if (A === "\x03" && this.props.exitOnCtrlC) this.handleExit();
      if (A === "\x1A" && zF6) this.handleSuspend();
      if (A === EF6 && this.state.activeFocusId) this.setState({
        activeFocusId: void 0
      });
      if (this.state.isFocusEnabled && this.state.focusables.length > 0) {
        if (A === HF6) this.focusNext();
        if (A === CF6) this.focusPrevious()
      }
    };
    handleExit = (A) => {
      if (this.isRawModeSupported()) this.handleSetRawMode(!1);
      this.props.onExit(A)
    };
    handleSuspend = () => {
      if (!this.isRawModeSupported()) return;
      let A = this.rawModeEnabledCount;
      while (this.rawModeEnabledCount > 0) this.handleSetRawMode(!1);
      if (this.props.stdout.isTTY) this.props.stdout.write(XM.cursorShow), this.props.stdout.write("\x1B[?1004l");
      this.internal_eventEmitter.emit("suspend");
      let Q = () => {
        for (let B = 0; B < A; B++)
          if (this.isRawModeSupported()) this.handleSetRawMode(!0);
        if (this.props.stdout.isTTY) this.props.stdout.write(XM.cursorHide), this.props.stdout.write("\x1B[?1004h");
        this.internal_eventEmitter.emit("resume"), process.removeListener("SIGCONT", Q)
      };
      process.on("SIGCONT", Q), process.kill(process.pid, "SIGSTOP")
    };
    enableFocus = () => {
      this.setState({
        isFocusEnabled: !0
      })
    };
    disableFocus = () => {
      this.setState({
        isFocusEnabled: !1
      })
    };
    focus = (A) => {
      this.setState((Q) => {
        if (!Q.focusables.some((G) => G?.id === A)) return Q;
        return {
          activeFocusId: A
        }
      })
    };
    focusNext = () => {
      this.setState((A) => {
        let Q = A.focusables.find((G) => G.isActive)?.id;
        return {
          activeFocusId: this.findNextFocusable(A) ?? Q
        }
      })
    };
    focusPrevious = () => {
      this.setState((A) => {
        let Q = A.focusables.findLast((G) => G.isActive)?.id;
        return {
          activeFocusId: this.findPreviousFocusable(A) ?? Q
        }
      })
    };
    addFocusable = (A, {
      autoFocus: Q
    }) => {
      this.setState((B) => {
        let G = B.activeFocusId;
        if (!G && Q) G = A;
        return {
          activeFocusId: G,
          focusables: [...B.focusables, {
            id: A,
            isActive: !0
          }]
        }
      })
    };
    removeFocusable = (A) => {
      this.setState((Q) => ({
        activeFocusId: Q.activeFocusId === A ? void 0 : Q.activeFocusId,
        focusables: Q.focusables.filter((B) => {
          return B.id !== A
        })
      }))
    };
    activateFocusable = (A) => {
      this.setState((Q) => ({
        focusables: Q.focusables.map((B) => {
          if (B.id !== A) return B;
          return {
            id: A,
            isActive: !0
          }
        })
      }))
    };
    deactivateFocusable = (A) => {
      this.setState((Q) => ({
        activeFocusId: Q.activeFocusId === A ? void 0 : Q.activeFocusId,
        focusables: Q.focusables.map((B) => {
          if (B.id !== A) return B;
          return {
            id: A,
            isActive: !1
          }
        })
      }))
    };
    findNextFocusable = (A) => {
      let Q = A.focusables.findIndex((B) => {
        return B.id === A.activeFocusId
      });
      for (let B = Q + 1; B < A.focusables.length; B++) {
        let G = A.focusables[B];
        if (G?.isActive) return G.id
      }
      return
    };
    findPreviousFocusable = (A) => {
      let Q = A.focusables.findIndex((B) => {
        return B.id === A.activeFocusId
      });
      for (let B = Q - 1; B >= 0; B--) {
        let G = A.focusables[B];
        if (G?.isActive) return G.id
      }
      return
    }
  }
})
// @from(Start 6384449, End 6384866)
B$A = z((Pi7, d$B) => {
  var UF6 = Number.MAX_SAFE_INTEGER || 9007199254740991,
    $F6 = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
  d$B.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: 16,
    MAX_SAFE_BUILD_LENGTH: 250,
    MAX_SAFE_INTEGER: UF6,
    RELEASE_TYPES: $F6,
    SEMVER_SPEC_VERSION: "2.0.0",
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }
})
// @from(Start 6384872, End 6385099)
G$A = z((ji7, c$B) => {
  var wF6 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...A) => console.error("SEMVER", ...A) : () => {};
  c$B.exports = wF6
})
// @from(Start 6385105, End 6389168)
y7A = z((x_, p$B) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH: Wu1,
    MAX_SAFE_BUILD_LENGTH: qF6,
    MAX_LENGTH: NF6
  } = B$A(), LF6 = G$A();
  x_ = p$B.exports = {};
  var MF6 = x_.re = [],
    OF6 = x_.safeRe = [],
    nB = x_.src = [],
    RF6 = x_.safeSrc = [],
    aB = x_.t = {},
    TF6 = 0,
    Xu1 = "[a-zA-Z0-9-]",
    PF6 = [
      ["\\s", 1],
      ["\\d", NF6],
      [Xu1, qF6]
    ],
    jF6 = (A) => {
      for (let [Q, B] of PF6) A = A.split(`${Q}*`).join(`${Q}{0,${B}}`).split(`${Q}+`).join(`${Q}{1,${B}}`);
      return A
    },
    U8 = (A, Q, B) => {
      let G = jF6(Q),
        Z = TF6++;
      LF6(A, Z, Q), aB[A] = Z, nB[Z] = Q, RF6[Z] = G, MF6[Z] = new RegExp(Q, B ? "g" : void 0), OF6[Z] = new RegExp(G, B ? "g" : void 0)
    };
  U8("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  U8("NUMERICIDENTIFIERLOOSE", "\\d+");
  U8("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${Xu1}*`);
  U8("MAINVERSION", `(${nB[aB.NUMERICIDENTIFIER]})\\.(${nB[aB.NUMERICIDENTIFIER]})\\.(${nB[aB.NUMERICIDENTIFIER]})`);
  U8("MAINVERSIONLOOSE", `(${nB[aB.NUMERICIDENTIFIERLOOSE]})\\.(${nB[aB.NUMERICIDENTIFIERLOOSE]})\\.(${nB[aB.NUMERICIDENTIFIERLOOSE]})`);
  U8("PRERELEASEIDENTIFIER", `(?:${nB[aB.NUMERICIDENTIFIER]}|${nB[aB.NONNUMERICIDENTIFIER]})`);
  U8("PRERELEASEIDENTIFIERLOOSE", `(?:${nB[aB.NUMERICIDENTIFIERLOOSE]}|${nB[aB.NONNUMERICIDENTIFIER]})`);
  U8("PRERELEASE", `(?:-(${nB[aB.PRERELEASEIDENTIFIER]}(?:\\.${nB[aB.PRERELEASEIDENTIFIER]})*))`);
  U8("PRERELEASELOOSE", `(?:-?(${nB[aB.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${nB[aB.PRERELEASEIDENTIFIERLOOSE]})*))`);
  U8("BUILDIDENTIFIER", `${Xu1}+`);
  U8("BUILD", `(?:\\+(${nB[aB.BUILDIDENTIFIER]}(?:\\.${nB[aB.BUILDIDENTIFIER]})*))`);
  U8("FULLPLAIN", `v?${nB[aB.MAINVERSION]}${nB[aB.PRERELEASE]}?${nB[aB.BUILD]}?`);
  U8("FULL", `^${nB[aB.FULLPLAIN]}$`);
  U8("LOOSEPLAIN", `[v=\\s]*${nB[aB.MAINVERSIONLOOSE]}${nB[aB.PRERELEASELOOSE]}?${nB[aB.BUILD]}?`);
  U8("LOOSE", `^${nB[aB.LOOSEPLAIN]}$`);
  U8("GTLT", "((?:<|>)?=?)");
  U8("XRANGEIDENTIFIERLOOSE", `${nB[aB.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  U8("XRANGEIDENTIFIER", `${nB[aB.NUMERICIDENTIFIER]}|x|X|\\*`);
  U8("XRANGEPLAIN", `[v=\\s]*(${nB[aB.XRANGEIDENTIFIER]})(?:\\.(${nB[aB.XRANGEIDENTIFIER]})(?:\\.(${nB[aB.XRANGEIDENTIFIER]})(?:${nB[aB.PRERELEASE]})?${nB[aB.BUILD]}?)?)?`);
  U8("XRANGEPLAINLOOSE", `[v=\\s]*(${nB[aB.XRANGEIDENTIFIERLOOSE]})(?:\\.(${nB[aB.XRANGEIDENTIFIERLOOSE]})(?:\\.(${nB[aB.XRANGEIDENTIFIERLOOSE]})(?:${nB[aB.PRERELEASELOOSE]})?${nB[aB.BUILD]}?)?)?`);
  U8("XRANGE", `^${nB[aB.GTLT]}\\s*${nB[aB.XRANGEPLAIN]}$`);
  U8("XRANGELOOSE", `^${nB[aB.GTLT]}\\s*${nB[aB.XRANGEPLAINLOOSE]}$`);
  U8("COERCEPLAIN", `(^|[^\\d])(\\d{1,${Wu1}})(?:\\.(\\d{1,${Wu1}}))?(?:\\.(\\d{1,${Wu1}}))?`);
  U8("COERCE", `${nB[aB.COERCEPLAIN]}(?:$|[^\\d])`);
  U8("COERCEFULL", nB[aB.COERCEPLAIN] + `(?:${nB[aB.PRERELEASE]})?(?:${nB[aB.BUILD]})?(?:$|[^\\d])`);
  U8("COERCERTL", nB[aB.COERCE], !0);
  U8("COERCERTLFULL", nB[aB.COERCEFULL], !0);
  U8("LONETILDE", "(?:~>?)");
  U8("TILDETRIM", `(\\s*)${nB[aB.LONETILDE]}\\s+`, !0);
  x_.tildeTrimReplace = "$1~";
  U8("TILDE", `^${nB[aB.LONETILDE]}${nB[aB.XRANGEPLAIN]}$`);
  U8("TILDELOOSE", `^${nB[aB.LONETILDE]}${nB[aB.XRANGEPLAINLOOSE]}$`);
  U8("LONECARET", "(?:\\^)");
  U8("CARETTRIM", `(\\s*)${nB[aB.LONECARET]}\\s+`, !0);
  x_.caretTrimReplace = "$1^";
  U8("CARET", `^${nB[aB.LONECARET]}${nB[aB.XRANGEPLAIN]}$`);
  U8("CARETLOOSE", `^${nB[aB.LONECARET]}${nB[aB.XRANGEPLAINLOOSE]}$`);
  U8("COMPARATORLOOSE", `^${nB[aB.GTLT]}\\s*(${nB[aB.LOOSEPLAIN]})$|^$`);
  U8("COMPARATOR", `^${nB[aB.GTLT]}\\s*(${nB[aB.FULLPLAIN]})$|^$`);
  U8("COMPARATORTRIM", `(\\s*)${nB[aB.GTLT]}\\s*(${nB[aB.LOOSEPLAIN]}|${nB[aB.XRANGEPLAIN]})`, !0);
  x_.comparatorTrimReplace = "$1$2$3";
  U8("HYPHENRANGE", `^\\s*(${nB[aB.XRANGEPLAIN]})\\s+-\\s+(${nB[aB.XRANGEPLAIN]})\\s*$`);
  U8("HYPHENRANGELOOSE", `^\\s*(${nB[aB.XRANGEPLAINLOOSE]})\\s+-\\s+(${nB[aB.XRANGEPLAINLOOSE]})\\s*$`);
  U8("STAR", "(<|>)?=?\\s*\\*");
  U8("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  U8("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
})
// @from(Start 6389174, End 6389413)
GsA = z((Si7, l$B) => {
  var SF6 = Object.freeze({
      loose: !0
    }),
    _F6 = Object.freeze({}),
    kF6 = (A) => {
      if (!A) return _F6;
      if (typeof A !== "object") return SF6;
      return A
    };
  l$B.exports = kF6
})
// @from(Start 6389419, End 6389766)
Vu1 = z((_i7, a$B) => {
  var i$B = /^[0-9]+$/,
    n$B = (A, Q) => {
      let B = i$B.test(A),
        G = i$B.test(Q);
      if (B && G) A = +A, Q = +Q;
      return A === Q ? 0 : B && !G ? -1 : G && !B ? 1 : A < Q ? -1 : 1
    },
    yF6 = (A, Q) => n$B(Q, A);
  a$B.exports = {
    compareIdentifiers: n$B,
    rcompareIdentifiers: yF6
  }
})
// @from(Start 6389772, End 6395799)
hH = z((ki7, t$B) => {
  var ZsA = G$A(),
    {
      MAX_LENGTH: s$B,
      MAX_SAFE_INTEGER: IsA
    } = B$A(),
    {
      safeRe: r$B,
      safeSrc: o$B,
      t: YsA
    } = y7A(),
    xF6 = GsA(),
    {
      compareIdentifiers: x7A
    } = Vu1();
  class UT {
    constructor(A, Q) {
      if (Q = xF6(Q), A instanceof UT)
        if (A.loose === !!Q.loose && A.includePrerelease === !!Q.includePrerelease) return A;
        else A = A.version;
      else if (typeof A !== "string") throw TypeError(`Invalid version. Must be a string. Got type "${typeof A}".`);
      if (A.length > s$B) throw TypeError(`version is longer than ${s$B} characters`);
      ZsA("SemVer", A, Q), this.options = Q, this.loose = !!Q.loose, this.includePrerelease = !!Q.includePrerelease;
      let B = A.trim().match(Q.loose ? r$B[YsA.LOOSE] : r$B[YsA.FULL]);
      if (!B) throw TypeError(`Invalid Version: ${A}`);
      if (this.raw = A, this.major = +B[1], this.minor = +B[2], this.patch = +B[3], this.major > IsA || this.major < 0) throw TypeError("Invalid major version");
      if (this.minor > IsA || this.minor < 0) throw TypeError("Invalid minor version");
      if (this.patch > IsA || this.patch < 0) throw TypeError("Invalid patch version");
      if (!B[4]) this.prerelease = [];
      else this.prerelease = B[4].split(".").map((G) => {
        if (/^[0-9]+$/.test(G)) {
          let Z = +G;
          if (Z >= 0 && Z < IsA) return Z
        }
        return G
      });
      this.build = B[5] ? B[5].split(".") : [], this.format()
    }
    format() {
      if (this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
      return this.version
    }
    toString() {
      return this.version
    }
    compare(A) {
      if (ZsA("SemVer.compare", this.version, this.options, A), !(A instanceof UT)) {
        if (typeof A === "string" && A === this.version) return 0;
        A = new UT(A, this.options)
      }
      if (A.version === this.version) return 0;
      return this.compareMain(A) || this.comparePre(A)
    }
    compareMain(A) {
      if (!(A instanceof UT)) A = new UT(A, this.options);
      return x7A(this.major, A.major) || x7A(this.minor, A.minor) || x7A(this.patch, A.patch)
    }
    comparePre(A) {
      if (!(A instanceof UT)) A = new UT(A, this.options);
      if (this.prerelease.length && !A.prerelease.length) return -1;
      else if (!this.prerelease.length && A.prerelease.length) return 1;
      else if (!this.prerelease.length && !A.prerelease.length) return 0;
      let Q = 0;
      do {
        let B = this.prerelease[Q],
          G = A.prerelease[Q];
        if (ZsA("prerelease compare", Q, B, G), B === void 0 && G === void 0) return 0;
        else if (G === void 0) return 1;
        else if (B === void 0) return -1;
        else if (B === G) continue;
        else return x7A(B, G)
      } while (++Q)
    }
    compareBuild(A) {
      if (!(A instanceof UT)) A = new UT(A, this.options);
      let Q = 0;
      do {
        let B = this.build[Q],
          G = A.build[Q];
        if (ZsA("build compare", Q, B, G), B === void 0 && G === void 0) return 0;
        else if (G === void 0) return 1;
        else if (B === void 0) return -1;
        else if (B === G) continue;
        else return x7A(B, G)
      } while (++Q)
    }
    inc(A, Q, B) {
      if (A.startsWith("pre")) {
        if (!Q && B === !1) throw Error("invalid increment argument: identifier is empty");
        if (Q) {
          let G = new RegExp(`^${this.options.loose?o$B[YsA.PRERELEASELOOSE]:o$B[YsA.PRERELEASE]}$`),
            Z = `-${Q}`.match(G);
          if (!Z || Z[1] !== Q) throw Error(`invalid identifier: ${Q}`)
        }
      }
      switch (A) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", Q, B);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", Q, B);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", Q, B), this.inc("pre", Q, B);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) this.inc("patch", Q, B);
          this.inc("pre", Q, B);
          break;
        case "release":
          if (this.prerelease.length === 0) throw Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
          this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
          this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) this.patch++;
          this.prerelease = [];
          break;
        case "pre": {
          let G = Number(B) ? 1 : 0;
          if (this.prerelease.length === 0) this.prerelease = [G];
          else {
            let Z = this.prerelease.length;
            while (--Z >= 0)
              if (typeof this.prerelease[Z] === "number") this.prerelease[Z]++, Z = -2;
            if (Z === -1) {
              if (Q === this.prerelease.join(".") && B === !1) throw Error("invalid increment argument: identifier already exists");
              this.prerelease.push(G)
            }
          }
          if (Q) {
            let Z = [Q, G];
            if (B === !1) Z = [Q];
            if (x7A(this.prerelease[0], Q) === 0) {
              if (isNaN(this.prerelease[1])) this.prerelease = Z
            } else this.prerelease = Z
          }
          break
        }
        default:
          throw Error(`invalid increment argument: ${A}`)
      }
      if (this.raw = this.format(), this.build.length) this.raw += `+${this.build.join(".")}`;
      return this
    }
  }
  t$B.exports = UT
})
// @from(Start 6395805, End 6396057)
it = z((yi7, AwB) => {
  var e$B = hH(),
    vF6 = (A, Q, B = !1) => {
      if (A instanceof e$B) return A;
      try {
        return new e$B(A, Q)
      } catch (G) {
        if (!B) return null;
        throw G
      }
    };
  AwB.exports = vF6
})
// @from(Start 6396063, End 6396215)
BwB = z((xi7, QwB) => {
  var bF6 = it(),
    fF6 = (A, Q) => {
      let B = bF6(A, Q);
      return B ? B.version : null
    };
  QwB.exports = fF6
})
// @from(Start 6396221, End 6396402)
ZwB = z((vi7, GwB) => {
  var hF6 = it(),
    gF6 = (A, Q) => {
      let B = hF6(A.trim().replace(/^[=v]+/, ""), Q);
      return B ? B.version : null
    };
  GwB.exports = gF6
})
// @from(Start 6396408, End 6396710)
JwB = z((bi7, YwB) => {
  var IwB = hH(),
    uF6 = (A, Q, B, G, Z) => {
      if (typeof B === "string") Z = G, G = B, B = void 0;
      try {
        return new IwB(A instanceof IwB ? A.version : A, B).inc(Q, G, Z).version
      } catch (I) {
        return null
      }
    };
  YwB.exports = uF6
})
// @from(Start 6396716, End 6397463)
VwB = z((fi7, XwB) => {
  var WwB = it(),
    mF6 = (A, Q) => {
      let B = WwB(A, null, !0),
        G = WwB(Q, null, !0),
        Z = B.compare(G);
      if (Z === 0) return null;
      let I = Z > 0,
        Y = I ? B : G,
        J = I ? G : B,
        W = !!Y.prerelease.length;
      if (!!J.prerelease.length && !W) {
        if (!J.patch && !J.minor) return "major";
        if (J.compareMain(Y) === 0) {
          if (J.minor && !J.patch) return "minor";
          return "patch"
        }
      }
      let V = W ? "pre" : "";
      if (B.major !== G.major) return V + "major";
      if (B.minor !== G.minor) return V + "minor";
      if (B.patch !== G.patch) return V + "patch";
      return "prerelease"
    };
  XwB.exports = mF6
})
// @from(Start 6397469, End 6397574)
KwB = z((hi7, FwB) => {
  var dF6 = hH(),
    cF6 = (A, Q) => new dF6(A, Q).major;
  FwB.exports = cF6
})
// @from(Start 6397580, End 6397685)
HwB = z((gi7, DwB) => {
  var pF6 = hH(),
    lF6 = (A, Q) => new pF6(A, Q).minor;
  DwB.exports = lF6
})
// @from(Start 6397691, End 6397796)
EwB = z((ui7, CwB) => {
  var iF6 = hH(),
    nF6 = (A, Q) => new iF6(A, Q).patch;
  CwB.exports = nF6
})
// @from(Start 6397802, End 6397980)
UwB = z((mi7, zwB) => {
  var aF6 = it(),
    sF6 = (A, Q) => {
      let B = aF6(A, Q);
      return B && B.prerelease.length ? B.prerelease : null
    };
  zwB.exports = sF6
})
// @from(Start 6397986, End 6398110)
VM = z((di7, wwB) => {
  var $wB = hH(),
    rF6 = (A, Q, B) => new $wB(A, B).compare(new $wB(Q, B));
  wwB.exports = rF6
})
// @from(Start 6398116, End 6398217)
NwB = z((ci7, qwB) => {
  var oF6 = VM(),
    tF6 = (A, Q, B) => oF6(Q, A, B);
  qwB.exports = tF6
})
// @from(Start 6398223, End 6398322)
MwB = z((pi7, LwB) => {
  var eF6 = VM(),
    AK6 = (A, Q) => eF6(A, Q, !0);
  LwB.exports = AK6
})
// @from(Start 6398328, End 6398527)
JsA = z((li7, RwB) => {
  var OwB = hH(),
    QK6 = (A, Q, B) => {
      let G = new OwB(A, B),
        Z = new OwB(Q, B);
      return G.compare(Z) || G.compareBuild(Z)
    };
  RwB.exports = QK6
})
// @from(Start 6398533, End 6398650)
PwB = z((ii7, TwB) => {
  var BK6 = JsA(),
    GK6 = (A, Q) => A.sort((B, G) => BK6(B, G, Q));
  TwB.exports = GK6
})
// @from(Start 6398656, End 6398773)
SwB = z((ni7, jwB) => {
  var ZK6 = JsA(),
    IK6 = (A, Q) => A.sort((B, G) => ZK6(G, B, Q));
  jwB.exports = IK6
})
// @from(Start 6398779, End 6398884)
Z$A = z((ai7, _wB) => {
  var YK6 = VM(),
    JK6 = (A, Q, B) => YK6(A, Q, B) > 0;
  _wB.exports = JK6
})
// @from(Start 6398890, End 6398995)
WsA = z((si7, kwB) => {
  var WK6 = VM(),
    XK6 = (A, Q, B) => WK6(A, Q, B) < 0;
  kwB.exports = XK6
})
// @from(Start 6399001, End 6399108)
Fu1 = z((ri7, ywB) => {
  var VK6 = VM(),
    FK6 = (A, Q, B) => VK6(A, Q, B) === 0;
  ywB.exports = FK6
})
// @from(Start 6399114, End 6399221)
Ku1 = z((oi7, xwB) => {
  var KK6 = VM(),
    DK6 = (A, Q, B) => KK6(A, Q, B) !== 0;
  xwB.exports = DK6
})
// @from(Start 6399227, End 6399333)
I$A = z((ti7, vwB) => {
  var HK6 = VM(),
    CK6 = (A, Q, B) => HK6(A, Q, B) >= 0;
  vwB.exports = CK6
})
// @from(Start 6399339, End 6399445)
XsA = z((ei7, bwB) => {
  var EK6 = VM(),
    zK6 = (A, Q, B) => EK6(A, Q, B) <= 0;
  bwB.exports = zK6
})
// @from(Start 6399451, End 6400365)
Du1 = z((An7, fwB) => {
  var UK6 = Fu1(),
    $K6 = Ku1(),
    wK6 = Z$A(),
    qK6 = I$A(),
    NK6 = WsA(),
    LK6 = XsA(),
    MK6 = (A, Q, B, G) => {
      switch (Q) {
        case "===":
          if (typeof A === "object") A = A.version;
          if (typeof B === "object") B = B.version;
          return A === B;
        case "!==":
          if (typeof A === "object") A = A.version;
          if (typeof B === "object") B = B.version;
          return A !== B;
        case "":
        case "=":
        case "==":
          return UK6(A, B, G);
        case "!=":
          return $K6(A, B, G);
        case ">":
          return wK6(A, B, G);
        case ">=":
          return qK6(A, B, G);
        case "<":
          return NK6(A, B, G);
        case "<=":
          return LK6(A, B, G);
        default:
          throw TypeError(`Invalid operator: ${Q}`)
      }
    };
  fwB.exports = MK6
})
// @from(Start 6400371, End 6401433)
Hu1 = z((Qn7, hwB) => {
  var OK6 = hH(),
    RK6 = it(),
    {
      safeRe: VsA,
      t: FsA
    } = y7A(),
    TK6 = (A, Q) => {
      if (A instanceof OK6) return A;
      if (typeof A === "number") A = String(A);
      if (typeof A !== "string") return null;
      Q = Q || {};
      let B = null;
      if (!Q.rtl) B = A.match(Q.includePrerelease ? VsA[FsA.COERCEFULL] : VsA[FsA.COERCE]);
      else {
        let W = Q.includePrerelease ? VsA[FsA.COERCERTLFULL] : VsA[FsA.COERCERTL],
          X;
        while ((X = W.exec(A)) && (!B || B.index + B[0].length !== A.length)) {
          if (!B || X.index + X[0].length !== B.index + B[0].length) B = X;
          W.lastIndex = X.index + X[1].length + X[2].length
        }
        W.lastIndex = -1
      }
      if (B === null) return null;
      let G = B[2],
        Z = B[3] || "0",
        I = B[4] || "0",
        Y = Q.includePrerelease && B[5] ? `-${B[5]}` : "",
        J = Q.includePrerelease && B[6] ? `+${B[6]}` : "";
      return RK6(`${G}.${Z}.${I}${Y}${J}`, Q)
    };
  hwB.exports = TK6
})
// @from(Start 6401439, End 6402011)
mwB = z((Bn7, uwB) => {
  class gwB {
    constructor() {
      this.max = 1000, this.map = new Map
    }
    get(A) {
      let Q = this.map.get(A);
      if (Q === void 0) return;
      else return this.map.delete(A), this.map.set(A, Q), Q
    }
    delete(A) {
      return this.map.delete(A)
    }
    set(A, Q) {
      if (!this.delete(A) && Q !== void 0) {
        if (this.map.size >= this.max) {
          let G = this.map.keys().next().value;
          this.delete(G)
        }
        this.map.set(A, Q)
      }
      return this
    }
  }
  uwB.exports = gwB
})
// @from(Start 6402017, End 6410389)
FM = z((Gn7, lwB) => {
  var PK6 = /\s+/g;
  class Y$A {
    constructor(A, Q) {
      if (Q = SK6(Q), A instanceof Y$A)
        if (A.loose === !!Q.loose && A.includePrerelease === !!Q.includePrerelease) return A;
        else return new Y$A(A.raw, Q);
      if (A instanceof Cu1) return this.raw = A.value, this.set = [
        [A]
      ], this.formatted = void 0, this;
      if (this.options = Q, this.loose = !!Q.loose, this.includePrerelease = !!Q.includePrerelease, this.raw = A.trim().replace(PK6, " "), this.set = this.raw.split("||").map((B) => this.parseRange(B.trim())).filter((B) => B.length), !this.set.length) throw TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        let B = this.set[0];
        if (this.set = this.set.filter((G) => !cwB(G[0])), this.set.length === 0) this.set = [B];
        else if (this.set.length > 1) {
          for (let G of this.set)
            if (G.length === 1 && fK6(G[0])) {
              this.set = [G];
              break
            }
        }
      }
      this.formatted = void 0
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let A = 0; A < this.set.length; A++) {
          if (A > 0) this.formatted += "||";
          let Q = this.set[A];
          for (let B = 0; B < Q.length; B++) {
            if (B > 0) this.formatted += " ";
            this.formatted += Q[B].toString().trim()
          }
        }
      }
      return this.formatted
    }
    format() {
      return this.range
    }
    toString() {
      return this.range
    }
    parseRange(A) {
      let B = ((this.options.includePrerelease && vK6) | (this.options.loose && bK6)) + ":" + A,
        G = dwB.get(B);
      if (G) return G;
      let Z = this.options.loose,
        I = Z ? FU[QE.HYPHENRANGELOOSE] : FU[QE.HYPHENRANGE];
      A = A.replace(I, nK6(this.options.includePrerelease)), HI("hyphen replace", A), A = A.replace(FU[QE.COMPARATORTRIM], kK6), HI("comparator trim", A), A = A.replace(FU[QE.TILDETRIM], yK6), HI("tilde trim", A), A = A.replace(FU[QE.CARETTRIM], xK6), HI("caret trim", A);
      let Y = A.split(" ").map((V) => hK6(V, this.options)).join(" ").split(/\s+/).map((V) => iK6(V, this.options));
      if (Z) Y = Y.filter((V) => {
        return HI("loose invalid filter", V, this.options), !!V.match(FU[QE.COMPARATORLOOSE])
      });
      HI("range list", Y);
      let J = new Map,
        W = Y.map((V) => new Cu1(V, this.options));
      for (let V of W) {
        if (cwB(V)) return [V];
        J.set(V.value, V)
      }
      if (J.size > 1 && J.has("")) J.delete("");
      let X = [...J.values()];
      return dwB.set(B, X), X
    }
    intersects(A, Q) {
      if (!(A instanceof Y$A)) throw TypeError("a Range is required");
      return this.set.some((B) => {
        return pwB(B, Q) && A.set.some((G) => {
          return pwB(G, Q) && B.every((Z) => {
            return G.every((I) => {
              return Z.intersects(I, Q)
            })
          })
        })
      })
    }
    test(A) {
      if (!A) return !1;
      if (typeof A === "string") try {
        A = new _K6(A, this.options)
      } catch (Q) {
        return !1
      }
      for (let Q = 0; Q < this.set.length; Q++)
        if (aK6(this.set[Q], A, this.options)) return !0;
      return !1
    }
  }
  lwB.exports = Y$A;
  var jK6 = mwB(),
    dwB = new jK6,
    SK6 = GsA(),
    Cu1 = J$A(),
    HI = G$A(),
    _K6 = hH(),
    {
      safeRe: FU,
      t: QE,
      comparatorTrimReplace: kK6,
      tildeTrimReplace: yK6,
      caretTrimReplace: xK6
    } = y7A(),
    {
      FLAG_INCLUDE_PRERELEASE: vK6,
      FLAG_LOOSE: bK6
    } = B$A(),
    cwB = (A) => A.value === "<0.0.0-0",
    fK6 = (A) => A.value === "",
    pwB = (A, Q) => {
      let B = !0,
        G = A.slice(),
        Z = G.pop();
      while (B && G.length) B = G.every((I) => {
        return Z.intersects(I, Q)
      }), Z = G.pop();
      return B
    },
    hK6 = (A, Q) => {
      return HI("comp", A, Q), A = mK6(A, Q), HI("caret", A), A = gK6(A, Q), HI("tildes", A), A = cK6(A, Q), HI("xrange", A), A = lK6(A, Q), HI("stars", A), A
    },
    BE = (A) => !A || A.toLowerCase() === "x" || A === "*",
    gK6 = (A, Q) => {
      return A.trim().split(/\s+/).map((B) => uK6(B, Q)).join(" ")
    },
    uK6 = (A, Q) => {
      let B = Q.loose ? FU[QE.TILDELOOSE] : FU[QE.TILDE];
      return A.replace(B, (G, Z, I, Y, J) => {
        HI("tilde", A, G, Z, I, Y, J);
        let W;
        if (BE(Z)) W = "";
        else if (BE(I)) W = `>=${Z}.0.0 <${+Z+1}.0.0-0`;
        else if (BE(Y)) W = `>=${Z}.${I}.0 <${Z}.${+I+1}.0-0`;
        else if (J) HI("replaceTilde pr", J), W = `>=${Z}.${I}.${Y}-${J} <${Z}.${+I+1}.0-0`;
        else W = `>=${Z}.${I}.${Y} <${Z}.${+I+1}.0-0`;
        return HI("tilde return", W), W
      })
    },
    mK6 = (A, Q) => {
      return A.trim().split(/\s+/).map((B) => dK6(B, Q)).join(" ")
    },
    dK6 = (A, Q) => {
      HI("caret", A, Q);
      let B = Q.loose ? FU[QE.CARETLOOSE] : FU[QE.CARET],
        G = Q.includePrerelease ? "-0" : "";
      return A.replace(B, (Z, I, Y, J, W) => {
        HI("caret", A, Z, I, Y, J, W);
        let X;
        if (BE(I)) X = "";
        else if (BE(Y)) X = `>=${I}.0.0${G} <${+I+1}.0.0-0`;
        else if (BE(J))
          if (I === "0") X = `>=${I}.${Y}.0${G} <${I}.${+Y+1}.0-0`;
          else X = `>=${I}.${Y}.0${G} <${+I+1}.0.0-0`;
        else if (W)
          if (HI("replaceCaret pr", W), I === "0")
            if (Y === "0") X = `>=${I}.${Y}.${J}-${W} <${I}.${Y}.${+J+1}-0`;
            else X = `>=${I}.${Y}.${J}-${W} <${I}.${+Y+1}.0-0`;
        else X = `>=${I}.${Y}.${J}-${W} <${+I+1}.0.0-0`;
        else if (HI("no pr"), I === "0")
          if (Y === "0") X = `>=${I}.${Y}.${J}${G} <${I}.${Y}.${+J+1}-0`;
          else X = `>=${I}.${Y}.${J}${G} <${I}.${+Y+1}.0-0`;
        else X = `>=${I}.${Y}.${J} <${+I+1}.0.0-0`;
        return HI("caret return", X), X
      })
    },
    cK6 = (A, Q) => {
      return HI("replaceXRanges", A, Q), A.split(/\s+/).map((B) => pK6(B, Q)).join(" ")
    },
    pK6 = (A, Q) => {
      A = A.trim();
      let B = Q.loose ? FU[QE.XRANGELOOSE] : FU[QE.XRANGE];
      return A.replace(B, (G, Z, I, Y, J, W) => {
        HI("xRange", A, G, Z, I, Y, J, W);
        let X = BE(I),
          V = X || BE(Y),
          F = V || BE(J),
          K = F;
        if (Z === "=" && K) Z = "";
        if (W = Q.includePrerelease ? "-0" : "", X)
          if (Z === ">" || Z === "<") G = "<0.0.0-0";
          else G = "*";
        else if (Z && K) {
          if (V) Y = 0;
          if (J = 0, Z === ">")
            if (Z = ">=", V) I = +I + 1, Y = 0, J = 0;
            else Y = +Y + 1, J = 0;
          else if (Z === "<=")
            if (Z = "<", V) I = +I + 1;
            else Y = +Y + 1;
          if (Z === "<") W = "-0";
          G = `${Z+I}.${Y}.${J}${W}`
        } else if (V) G = `>=${I}.0.0${W} <${+I+1}.0.0-0`;
        else if (F) G = `>=${I}.${Y}.0${W} <${I}.${+Y+1}.0-0`;
        return HI("xRange return", G), G
      })
    },
    lK6 = (A, Q) => {
      return HI("replaceStars", A, Q), A.trim().replace(FU[QE.STAR], "")
    },
    iK6 = (A, Q) => {
      return HI("replaceGTE0", A, Q), A.trim().replace(FU[Q.includePrerelease ? QE.GTE0PRE : QE.GTE0], "")
    },
    nK6 = (A) => (Q, B, G, Z, I, Y, J, W, X, V, F, K) => {
      if (BE(G)) B = "";
      else if (BE(Z)) B = `>=${G}.0.0${A?"-0":""}`;
      else if (BE(I)) B = `>=${G}.${Z}.0${A?"-0":""}`;
      else if (Y) B = `>=${B}`;
      else B = `>=${B}${A?"-0":""}`;
      if (BE(X)) W = "";
      else if (BE(V)) W = `<${+X+1}.0.0-0`;
      else if (BE(F)) W = `<${X}.${+V+1}.0-0`;
      else if (K) W = `<=${X}.${V}.${F}-${K}`;
      else if (A) W = `<${X}.${V}.${+F+1}-0`;
      else W = `<=${W}`;
      return `${B} ${W}`.trim()
    },
    aK6 = (A, Q, B) => {
      for (let G = 0; G < A.length; G++)
        if (!A[G].test(Q)) return !1;
      if (Q.prerelease.length && !B.includePrerelease) {
        for (let G = 0; G < A.length; G++) {
          if (HI(A[G].semver), A[G].semver === Cu1.ANY) continue;
          if (A[G].semver.prerelease.length > 0) {
            let Z = A[G].semver;
            if (Z.major === Q.major && Z.minor === Q.minor && Z.patch === Q.patch) return !0
          }
        }
        return !1
      }
      return !0
    }
})
// @from(Start 6410395, End 6412939)
J$A = z((Zn7, owB) => {
  var W$A = Symbol("SemVer ANY");
  class KsA {
    static get ANY() {
      return W$A
    }
    constructor(A, Q) {
      if (Q = iwB(Q), A instanceof KsA)
        if (A.loose === !!Q.loose) return A;
        else A = A.value;
      if (A = A.trim().split(/\s+/).join(" "), zu1("comparator", A, Q), this.options = Q, this.loose = !!Q.loose, this.parse(A), this.semver === W$A) this.value = "";
      else this.value = this.operator + this.semver.version;
      zu1("comp", this)
    }
    parse(A) {
      let Q = this.options.loose ? nwB[awB.COMPARATORLOOSE] : nwB[awB.COMPARATOR],
        B = A.match(Q);
      if (!B) throw TypeError(`Invalid comparator: ${A}`);
      if (this.operator = B[1] !== void 0 ? B[1] : "", this.operator === "=") this.operator = "";
      if (!B[2]) this.semver = W$A;
      else this.semver = new swB(B[2], this.options.loose)
    }
    toString() {
      return this.value
    }
    test(A) {
      if (zu1("Comparator.test", A, this.options.loose), this.semver === W$A || A === W$A) return !0;
      if (typeof A === "string") try {
        A = new swB(A, this.options)
      } catch (Q) {
        return !1
      }
      return Eu1(A, this.operator, this.semver, this.options)
    }
    intersects(A, Q) {
      if (!(A instanceof KsA)) throw TypeError("a Comparator is required");
      if (this.operator === "") {
        if (this.value === "") return !0;
        return new rwB(A.value, Q).test(this.value)
      } else if (A.operator === "") {
        if (A.value === "") return !0;
        return new rwB(this.value, Q).test(A.semver)
      }
      if (Q = iwB(Q), Q.includePrerelease && (this.value === "<0.0.0-0" || A.value === "<0.0.0-0")) return !1;
      if (!Q.includePrerelease && (this.value.startsWith("<0.0.0") || A.value.startsWith("<0.0.0"))) return !1;
      if (this.operator.startsWith(">") && A.operator.startsWith(">")) return !0;
      if (this.operator.startsWith("<") && A.operator.startsWith("<")) return !0;
      if (this.semver.version === A.semver.version && this.operator.includes("=") && A.operator.includes("=")) return !0;
      if (Eu1(this.semver, "<", A.semver, Q) && this.operator.startsWith(">") && A.operator.startsWith("<")) return !0;
      if (Eu1(this.semver, ">", A.semver, Q) && this.operator.startsWith("<") && A.operator.startsWith(">")) return !0;
      return !1
    }
  }
  owB.exports = KsA;
  var iwB = GsA(),
    {
      safeRe: nwB,
      t: awB
    } = y7A(),
    Eu1 = Du1(),
    zu1 = G$A(),
    swB = hH(),
    rwB = FM()
})
// @from(Start 6412945, End 6413148)
v7A = z((In7, twB) => {
  var sK6 = FM(),
    rK6 = (A, Q, B) => {
      try {
        Q = new sK6(Q, B)
      } catch (G) {
        return !1
      }
      return Q.test(A)
    };
  twB.exports = rK6
})
// @from(Start 6413154, End 6413319)
AqB = z((Yn7, ewB) => {
  var oK6 = FM(),
    tK6 = (A, Q) => new oK6(A, Q).set.map((B) => B.map((G) => G.value).join(" ").trim().split(" "));
  ewB.exports = tK6
})
// @from(Start 6413325, End 6413724)
BqB = z((Jn7, QqB) => {
  var eK6 = hH(),
    AD6 = FM(),
    QD6 = (A, Q, B) => {
      let G = null,
        Z = null,
        I = null;
      try {
        I = new AD6(Q, B)
      } catch (Y) {
        return null
      }
      return A.forEach((Y) => {
        if (I.test(Y)) {
          if (!G || Z.compare(Y) === -1) G = Y, Z = new eK6(G, B)
        }
      }), G
    };
  QqB.exports = QD6
})
// @from(Start 6413730, End 6414128)
ZqB = z((Wn7, GqB) => {
  var BD6 = hH(),
    GD6 = FM(),
    ZD6 = (A, Q, B) => {
      let G = null,
        Z = null,
        I = null;
      try {
        I = new GD6(Q, B)
      } catch (Y) {
        return null
      }
      return A.forEach((Y) => {
        if (I.test(Y)) {
          if (!G || Z.compare(Y) === 1) G = Y, Z = new BD6(G, B)
        }
      }), G
    };
  GqB.exports = ZD6
})
// @from(Start 6414134, End 6415182)
JqB = z((Xn7, YqB) => {
  var Uu1 = hH(),
    ID6 = FM(),
    IqB = Z$A(),
    YD6 = (A, Q) => {
      A = new ID6(A, Q);
      let B = new Uu1("0.0.0");
      if (A.test(B)) return B;
      if (B = new Uu1("0.0.0-0"), A.test(B)) return B;
      B = null;
      for (let G = 0; G < A.set.length; ++G) {
        let Z = A.set[G],
          I = null;
        if (Z.forEach((Y) => {
            let J = new Uu1(Y.semver.version);
            switch (Y.operator) {
              case ">":
                if (J.prerelease.length === 0) J.patch++;
                else J.prerelease.push(0);
                J.raw = J.format();
              case "":
              case ">=":
                if (!I || IqB(J, I)) I = J;
                break;
              case "<":
              case "<=":
                break;
              default:
                throw Error(`Unexpected operation: ${Y.operator}`)
            }
          }), I && (!B || IqB(B, I))) B = I
      }
      if (B && A.test(B)) return B;
      return null
    };
  YqB.exports = YD6
})
// @from(Start 6415188, End 6415383)
XqB = z((Vn7, WqB) => {
  var JD6 = FM(),
    WD6 = (A, Q) => {
      try {
        return new JD6(A, Q).range || "*"
      } catch (B) {
        return null
      }
    };
  WqB.exports = WD6
})
// @from(Start 6415389, End 6416591)
DsA = z((Fn7, DqB) => {
  var XD6 = hH(),
    KqB = J$A(),
    {
      ANY: VD6
    } = KqB,
    FD6 = FM(),
    KD6 = v7A(),
    VqB = Z$A(),
    FqB = WsA(),
    DD6 = XsA(),
    HD6 = I$A(),
    CD6 = (A, Q, B, G) => {
      A = new XD6(A, G), Q = new FD6(Q, G);
      let Z, I, Y, J, W;
      switch (B) {
        case ">":
          Z = VqB, I = DD6, Y = FqB, J = ">", W = ">=";
          break;
        case "<":
          Z = FqB, I = HD6, Y = VqB, J = "<", W = "<=";
          break;
        default:
          throw TypeError('Must provide a hilo val of "<" or ">"')
      }
      if (KD6(A, Q, G)) return !1;
      for (let X = 0; X < Q.set.length; ++X) {
        let V = Q.set[X],
          F = null,
          K = null;
        if (V.forEach((D) => {
            if (D.semver === VD6) D = new KqB(">=0.0.0");
            if (F = F || D, K = K || D, Z(D.semver, F.semver, G)) F = D;
            else if (Y(D.semver, K.semver, G)) K = D
          }), F.operator === J || F.operator === W) return !1;
        if ((!K.operator || K.operator === J) && I(A, K.semver)) return !1;
        else if (K.operator === W && Y(A, K.semver)) return !1
      }
      return !0
    };
  DqB.exports = CD6
})
// @from(Start 6416597, End 6416704)
CqB = z((Kn7, HqB) => {
  var ED6 = DsA(),
    zD6 = (A, Q, B) => ED6(A, Q, ">", B);
  HqB.exports = zD6
})
// @from(Start 6416710, End 6416817)
zqB = z((Dn7, EqB) => {
  var UD6 = DsA(),
    $D6 = (A, Q, B) => UD6(A, Q, "<", B);
  EqB.exports = $D6
})
// @from(Start 6416823, End 6416989)
wqB = z((Hn7, $qB) => {
  var UqB = FM(),
    wD6 = (A, Q, B) => {
      return A = new UqB(A, B), Q = new UqB(Q, B), A.intersects(Q, B)
    };
  $qB.exports = wD6
})
// @from(Start 6416995, End 6417716)
NqB = z((Cn7, qqB) => {
  var qD6 = v7A(),
    ND6 = VM();
  qqB.exports = (A, Q, B) => {
    let G = [],
      Z = null,
      I = null,
      Y = A.sort((V, F) => ND6(V, F, B));
    for (let V of Y)
      if (qD6(V, Q, B)) {
        if (I = V, !Z) Z = V
      } else {
        if (I) G.push([Z, I]);
        I = null, Z = null
      } if (Z) G.push([Z, null]);
    let J = [];
    for (let [V, F] of G)
      if (V === F) J.push(V);
      else if (!F && V === Y[0]) J.push("*");
    else if (!F) J.push(`>=${V}`);
    else if (V === Y[0]) J.push(`<=${F}`);
    else J.push(`${V} - ${F}`);
    let W = J.join(" || "),
      X = typeof Q.raw === "string" ? Q.raw : String(Q);
    return W.length < X.length ? W : Q
  }
})
// @from(Start 6417722, End 6421159)
PqB = z((En7, TqB) => {
  var LqB = FM(),
    wu1 = J$A(),
    {
      ANY: $u1
    } = wu1,
    X$A = v7A(),
    qu1 = VM(),
    LD6 = (A, Q, B = {}) => {
      if (A === Q) return !0;
      A = new LqB(A, B), Q = new LqB(Q, B);
      let G = !1;
      A: for (let Z of A.set) {
        for (let I of Q.set) {
          let Y = OD6(Z, I, B);
          if (G = G || Y !== null, Y) continue A
        }
        if (G) return !1
      }
      return !0
    },
    MD6 = [new wu1(">=0.0.0-0")],
    MqB = [new wu1(">=0.0.0")],
    OD6 = (A, Q, B) => {
      if (A === Q) return !0;
      if (A.length === 1 && A[0].semver === $u1)
        if (Q.length === 1 && Q[0].semver === $u1) return !0;
        else if (B.includePrerelease) A = MD6;
      else A = MqB;
      if (Q.length === 1 && Q[0].semver === $u1)
        if (B.includePrerelease) return !0;
        else Q = MqB;
      let G = new Set,
        Z, I;
      for (let D of A)
        if (D.operator === ">" || D.operator === ">=") Z = OqB(Z, D, B);
        else if (D.operator === "<" || D.operator === "<=") I = RqB(I, D, B);
      else G.add(D.semver);
      if (G.size > 1) return null;
      let Y;
      if (Z && I) {
        if (Y = qu1(Z.semver, I.semver, B), Y > 0) return null;
        else if (Y === 0 && (Z.operator !== ">=" || I.operator !== "<=")) return null
      }
      for (let D of G) {
        if (Z && !X$A(D, String(Z), B)) return null;
        if (I && !X$A(D, String(I), B)) return null;
        for (let H of Q)
          if (!X$A(D, String(H), B)) return !1;
        return !0
      }
      let J, W, X, V, F = I && !B.includePrerelease && I.semver.prerelease.length ? I.semver : !1,
        K = Z && !B.includePrerelease && Z.semver.prerelease.length ? Z.semver : !1;
      if (F && F.prerelease.length === 1 && I.operator === "<" && F.prerelease[0] === 0) F = !1;
      for (let D of Q) {
        if (V = V || D.operator === ">" || D.operator === ">=", X = X || D.operator === "<" || D.operator === "<=", Z) {
          if (K) {
            if (D.semver.prerelease && D.semver.prerelease.length && D.semver.major === K.major && D.semver.minor === K.minor && D.semver.patch === K.patch) K = !1
          }
          if (D.operator === ">" || D.operator === ">=") {
            if (J = OqB(Z, D, B), J === D && J !== Z) return !1
          } else if (Z.operator === ">=" && !X$A(Z.semver, String(D), B)) return !1
        }
        if (I) {
          if (F) {
            if (D.semver.prerelease && D.semver.prerelease.length && D.semver.major === F.major && D.semver.minor === F.minor && D.semver.patch === F.patch) F = !1
          }
          if (D.operator === "<" || D.operator === "<=") {
            if (W = RqB(I, D, B), W === D && W !== I) return !1
          } else if (I.operator === "<=" && !X$A(I.semver, String(D), B)) return !1
        }
        if (!D.operator && (I || Z) && Y !== 0) return !1
      }
      if (Z && X && !I && Y !== 0) return !1;
      if (I && V && !Z && Y !== 0) return !1;
      if (K || F) return !1;
      return !0
    },
    OqB = (A, Q, B) => {
      if (!A) return Q;
      let G = qu1(A.semver, Q.semver, B);
      return G > 0 ? A : G < 0 ? Q : Q.operator === ">" && A.operator === ">=" ? Q : A
    },
    RqB = (A, Q, B) => {
      if (!A) return Q;
      let G = qu1(A.semver, Q.semver, B);
      return G < 0 ? A : G > 0 ? Q : Q.operator === "<" && A.operator === "<=" ? Q : A
    };
  TqB.exports = LD6
})
// @from(Start 6421165, End 6422813)
KU = z((zn7, _qB) => {
  var Nu1 = y7A(),
    jqB = B$A(),
    RD6 = hH(),
    SqB = Vu1(),
    TD6 = it(),
    PD6 = BwB(),
    jD6 = ZwB(),
    SD6 = JwB(),
    _D6 = VwB(),
    kD6 = KwB(),
    yD6 = HwB(),
    xD6 = EwB(),
    vD6 = UwB(),
    bD6 = VM(),
    fD6 = NwB(),
    hD6 = MwB(),
    gD6 = JsA(),
    uD6 = PwB(),
    mD6 = SwB(),
    dD6 = Z$A(),
    cD6 = WsA(),
    pD6 = Fu1(),
    lD6 = Ku1(),
    iD6 = I$A(),
    nD6 = XsA(),
    aD6 = Du1(),
    sD6 = Hu1(),
    rD6 = J$A(),
    oD6 = FM(),
    tD6 = v7A(),
    eD6 = AqB(),
    AH6 = BqB(),
    QH6 = ZqB(),
    BH6 = JqB(),
    GH6 = XqB(),
    ZH6 = DsA(),
    IH6 = CqB(),
    YH6 = zqB(),
    JH6 = wqB(),
    WH6 = NqB(),
    XH6 = PqB();
  _qB.exports = {
    parse: TD6,
    valid: PD6,
    clean: jD6,
    inc: SD6,
    diff: _D6,
    major: kD6,
    minor: yD6,
    patch: xD6,
    prerelease: vD6,
    compare: bD6,
    rcompare: fD6,
    compareLoose: hD6,
    compareBuild: gD6,
    sort: uD6,
    rsort: mD6,
    gt: dD6,
    lt: cD6,
    eq: pD6,
    neq: lD6,
    gte: iD6,
    lte: nD6,
    cmp: aD6,
    coerce: sD6,
    Comparator: rD6,
    Range: oD6,
    satisfies: tD6,
    toComparators: eD6,
    maxSatisfying: AH6,
    minSatisfying: QH6,
    minVersion: BH6,
    validRange: GH6,
    outside: ZH6,
    gtr: IH6,
    ltr: YH6,
    intersects: JH6,
    simplifyRange: WH6,
    subset: XH6,
    SemVer: RD6,
    re: Nu1.re,
    src: Nu1.src,
    tokens: Nu1.t,
    SEMVER_SPEC_VERSION: jqB.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: jqB.RELEASE_TYPES,
    compareIdentifiers: SqB.compareIdentifiers,
    rcompareIdentifiers: SqB.rcompareIdentifiers
  }
})
// @from(Start 6422816, End 6422900)
function VH6() {
  return process.platform === "win32" && !!process.env.WT_SESSION
}
// @from(Start 6422902, End 6423080)
function FH6() {
  if (VH6()) return !0;
  if (process.platform === "win32" && process.env.TERM_PROGRAM === "vscode" && process.env.TERM_PROGRAM_VERSION) return !0;
  return !1
}
// @from(Start 6423082, End 6423253)
function Lu1() {
  if (process.platform === "win32")
    if (FH6()) return "\x1B[2J\x1B[3J\x1B[H";
    else return "\x1B[2J\x1B[0f";
  else return "\x1B[2J\x1B[3J\x1B[H"
}
// @from(Start 6423258, End 6423261)
Un7
// @from(Start 6423267, End 6423299)
kqB = L(() => {
  Un7 = Lu1()
})
// @from(Start 6423302, End 6423732)
function KH6() {
  if (!process.stdout.isTTY) return !1;
  if (process.env.WT_SESSION) return !1;
  if (process.env.ConEmuANSI || process.env.ConEmuPID || process.env.ConEmuTask) return !0;
  let A = V$A.coerce(process.env.TERM_PROGRAM_VERSION);
  if (!A) return !1;
  if (process.env.TERM_PROGRAM === "ghostty") return V$A.gte(A, "1.2.0");
  if (process.env.TERM_PROGRAM === "iTerm.app") return V$A.gte(A, "3.6.6");
  return !1
}
// @from(Start 6423734, End 6423794)
function DH6(A) {
  return `${fg1}8${P7A}${P7A}${A}${T7A}`
}
// @from(Start 6423796, End 6424625)
function Mu1(A, Q) {
  if (Q.length === 0) return;
  let B = uUB;
  for (let G of Q) switch (G.type) {
    case "stdout":
      B += G.content;
      break;
    case "clear":
      if (G.count > 0) B += XM.eraseLines(G.count);
      break;
    case "clearTerminal":
      B += Lu1();
      break;
    case "cursorHide":
      B += XM.cursorHide;
      break;
    case "cursorShow":
      B += XM.cursorShow;
      break;
    case "cursorMove":
      B += XM.cursorMove(G.x, G.y);
      break;
    case "carriageReturn":
      B += "\r";
      break;
    case "resolvePendingWrap":
      B += " \b";
      break;
    case "hyperlink":
      B += DH6(G.uri);
      break;
    case "style":
      B += pt(G.codes);
      break;
    case "progress":
      if (KH6()) B += HH6(G.state);
      break
  }
  B += mUB, A.stdout.write(B)
}
// @from(Start 6424627, End 6424785)
function HH6(A) {
  let Q = CH6(A.state),
    B = A.percentage ?? 0,
    G = Math.max(0, Math.min(100, Math.round(B)));
  return `${fg1}9;4;${Q};${G}${T7A}`
}
// @from(Start 6424787, End 6424974)
function CH6(A) {
  switch (A) {
    case "completed":
      return 0;
    case "error":
      return 2;
    case "indeterminate":
      return 3;
    case "running":
      return 1
  }
}
// @from(Start 6424979, End 6424982)
V$A
// @from(Start 6424988, End 6425053)
yqB = L(() => {
  baA();
  eaA();
  kqB();
  V$A = BA(KU(), 1)
})
// @from(Start 6425055, End 6430225)
class HsA {
  options;
  log;
  terminal;
  scheduleRender;
  isUnmounted = !1;
  isPaused = !1;
  container;
  rootNode;
  renderer;
  exitPromise;
  restoreConsole;
  unsubscribeTTYHandlers;
  terminalColumns;
  terminalRows;
  currentNode = null;
  constructor(A) {
    this.options = A;
    if (Oh1(this), this.options.patchConsole) this.restoreConsole = this.patchConsole();
    if (this.terminal = {
        stdout: A.stdout,
        stderr: A.stderr
      }, this.terminalColumns = A.stdout.columns || 80, this.terminalRows = A.stdout.rows || 24, this.log = new pg1({
        debug: A.debug,
        isTTY: A.stdout.isTTY || !1,
        onFlicker: A.onFlicker,
        ink2: A.ink2
      }, gaA(this.terminalRows, this.terminalColumns)), this.scheduleRender = A.debug ? this.onRender : Mh1(this.onRender, 32, {
        leading: !0,
        trailing: !0
      }), this.isUnmounted = !1, this.unsubscribeExit = SyA(this.unmount, {
        alwaysLast: !1
      }), A.stdout.isTTY) A.stdout.on("resize", this.handleResize), process.on("SIGCONT", this.handleResume), this.unsubscribeTTYHandlers = () => {
      A.stdout.off("resize", this.handleResize), process.off("SIGCONT", this.handleResume)
    };
    if (this.rootNode = DaA("ink-root"), this.renderer = gg1(this.rootNode), this.rootNode.onRender = this.scheduleRender, this.rootNode.onImmediateRender = this.onRender, this.rootNode.onComputeLayout = () => {
        if (this.isUnmounted) return;
        if (this.rootNode.yogaNode) this.rootNode.yogaNode.setWidth(this.terminalColumns), this.rootNode.yogaNode.calculateLayout(void 0, void 0, xt.LTR)
      }, this.container = Ap.createContainer(this.rootNode, 0, null, !1, null, "id", () => {}, null), process.env.DEV === "true") Ap.injectIntoDevTools({
      bundleType: 0,
      version: "16.13.1",
      rendererPackageName: "ink"
    })
  }
  handleResume = () => {
    if (!this.options.stdout.isTTY) return;
    this.log.reset()
  };
  handleResize = () => {
    if (this.terminalColumns = this.options.stdout.columns || 80, this.terminalRows = this.options.stdout.rows || 24, this.currentNode !== null) this.render(this.currentNode);
    this.scheduleRender()
  };
  resolveExitPromise = () => {};
  rejectExitPromise = () => {};
  unsubscribeExit = () => {};
  setTheme(A) {
    this.options.theme = A
  }
  onRender() {
    if (this.isUnmounted || this.isPaused) return;
    let A = this.options.stdout.rows || 24,
      Q = this.options.stdout.columns || 80,
      B = this.renderer({
        terminalWidth: Q,
        terminalRows: A,
        isTTY: this.options.stdout.isTTY,
        ink2: this.options.ink2
      }),
      G = this.log.render(B);
    for (let Z of G)
      if (Z.type === "clearTerminal") this.options.onFlicker?.(B.outputHeight, B.rows, this.options.ink2, Z.reason);
    Mu1(this.terminal, G)
  }
  pause() {
    Ap.flushSync(), this.onRender(), this.isPaused = !0
  }
  resume() {
    this.isPaused = !1, this.onRender()
  }
  stdinListeners = [];
  wasRawMode = !1;
  suspendStdin() {
    let A = this.options.stdin;
    if (!A.isTTY) return;
    A.listeners("readable").forEach((G) => {
      this.stdinListeners.push({
        event: "readable",
        listener: G
      }), A.removeListener("readable", G)
    });
    let B = A;
    if (B.isRaw && B.setRawMode) B.setRawMode(!1), this.wasRawMode = !0
  }
  resumeStdin() {
    let A = this.options.stdin;
    if (!A.isTTY) return;
    if (this.stdinListeners.forEach(({
        event: Q,
        listener: B
      }) => {
        A.addListener(Q, B)
      }), this.stdinListeners = [], this.wasRawMode) {
      let Q = A;
      if (Q.setRawMode) Q.setRawMode(!0);
      this.wasRawMode = !1
    }
  }
  render(A) {
    this.currentNode = A;
    let Q = xqB.default.createElement(BsA, {
      initialTheme: this.options.theme,
      stdin: this.options.stdin,
      stdout: this.options.stdout,
      stderr: this.options.stderr,
      exitOnCtrlC: this.options.exitOnCtrlC,
      onExit: this.unmount,
      ink2: this.options.ink2,
      terminalColumns: this.terminalColumns,
      terminalRows: this.terminalRows
    }, A);
    Ap.updateContainer(Q, this.container, null, ZKA)
  }
  unmount(A) {
    if (this.isUnmounted) return;
    if (this.onRender(), this.unsubscribeExit(), typeof this.restoreConsole === "function") this.restoreConsole();
    this.unsubscribeTTYHandlers?.();
    let Q = this.log.renderPreviousOutput_DEPRECATED();
    if (Mu1(this.terminal, Q), this.isUnmounted = !0, this.scheduleRender.cancel?.(), Ap.updateContainer(null, this.container, null, ZKA), Qf.delete(this.options.stdout), A instanceof Error) this.rejectExitPromise(A);
    else this.resolveExitPromise()
  }
  async waitUntilExit() {
    return this.exitPromise ||= new Promise((A, Q) => {
      this.resolveExitPromise = A, this.rejectExitPromise = Q
    }), this.exitPromise
  }
  resetLineCount() {
    if (this.options.stdout.isTTY && !this.options.debug) this.log.reset()
  }
  patchConsole() {
    if (this.options.debug) return;
    return VEB((A, Q) => {
      if (A === "stdout") g(`console.log: ${Q}`);
      if (A === "stderr") AA(Error(`console.error: ${Q}`))
    })
  }
}
// @from(Start 6430227, End 6430291)
function sg1(A) {
  Qf.forEach((Q) => {
    Q.setTheme(A)
  })
}
// @from(Start 6430296, End 6430299)
xqB
// @from(Start 6430305, End 6430475)
eg1 = L(() => {
  JEB();
  AD1();
  FEB();
  $g1();
  A$B();
  EaA();
  I$B();
  uaA();
  m$B();
  g1();
  V0();
  GH1();
  yqB();
  ug1();
  ft();
  xqB = BA(VA(), 1)
})
// @from(Start 6430478, End 6430550)
function gH() {
  if (_j(void 0)) return !1;
  return Y0(void 0) || !1
}
// @from(Start 6430555, End 6430587)
nt = L(() => {
  hQ();
  u2()
})
// @from(Start 6430640, End 6431174)
zH6 = (A, Q) => {
    let B = $H6(Q),
      G = {
        stdout: process.stdout,
        stdin: process.stdin,
        stderr: process.stderr,
        debug: !1,
        exitOnCtrlC: !0,
        patchConsole: !0,
        ...B,
        theme: B.theme ?? N1().theme,
        ink2: B.ink2 ?? gH()
      },
      Z = wH6(G.stdout, () => new HsA(G));
    return Z.render(A), {
      rerender: Z.render,
      unmount() {
        Z.unmount()
      },
      waitUntilExit: Z.waitUntilExit,
      cleanup: () => Qf.delete(G.stdout)
    }
  }
// @from(Start 6431178, End 6431239)
UH6 = async (A, Q) => {
    return await AzB(), zH6(A, Q)
  }
// @from(Start 6431241, End 6431243)
VG
// @from(Start 6431245, End 6431367)
$H6 = (A = {}) => {
    if (A instanceof EH6) return {
      stdout: A,
      stdin: process.stdin
    };
    return A
  }
// @from(Start 6431369, End 6431461)
wH6 = (A, Q) => {
    let B = Qf.get(A);
    if (!B) B = Q(), Qf.set(A, B);
    return B
  }
// @from(Start 6431467, End 6431539)
vqB = L(() => {
  eg1();
  EaA();
  uaA();
  jQ();
  nt();
  VG = UH6
})
// @from(Start 6431542, End 6431708)
function F$A(A, Q) {
  if (!A) return;
  if (A.startsWith("rgb(") || A.startsWith("#") || A.startsWith("ansi256(") || A.startsWith("ansi:")) return A;
  return Q[A]
}
// @from(Start 6431713, End 6431716)
CsA
// @from(Start 6431718, End 6431721)
bqB
// @from(Start 6431723, End 6431724)
S
// @from(Start 6431730, End 6432341)
fqB = L(() => {
  _aA();
  oUA();
  rUA();
  CsA = BA(VA(), 1);
  bqB = CsA.forwardRef(({
    borderColor: A,
    borderTopColor: Q,
    borderBottomColor: B,
    borderLeftColor: G,
    borderRightColor: Z,
    children: I,
    ...Y
  }, J) => {
    let [W] = qB(), X = R7A(W), V = F$A(A, X), F = F$A(Q, X), K = F$A(B, X), D = F$A(G, X), H = F$A(Z, X);
    return CsA.default.createElement(VU, {
      ref: J,
      borderColor: V,
      borderTopColor: F,
      borderBottomColor: K,
      borderLeftColor: D,
      borderRightColor: H,
      ...Y
    }, I)
  });
  bqB.displayName = "ThemedBox";
  S = bqB
})
// @from(Start 6432344, End 6432452)
function hqB({
  children: A
}) {
  return Ou1.default.createElement(NH6.Provider, {
    value: !0
  }, A)
}
// @from(Start 6432457, End 6432460)
Ou1
// @from(Start 6432462, End 6432465)
qH6
// @from(Start 6432467, End 6432470)
NH6
// @from(Start 6432476, End 6432570)
Ru1 = L(() => {
  Ou1 = BA(VA(), 1), qH6 = BA(VA(), 1), NH6 = Ou1.default.createContext(!1)
})
// @from(Start 6432573, End 6433228)
function Zp(A) {
  let {
    items: Q,
    children: B
  } = A, G = KM.useContext(k_), [Z, I] = KM.useState(0), Y = KM.useMemo(() => {
    return Q.slice(Z)
  }, [Q, Z]);
  if (KM.useLayoutEffect(() => {
      I(Q.length)
    }, [Q.length]), G) {
    let W = Q.map((X, V) => B(X, V));
    return KM.default.createElement("ink-box", {
      style: {
        flexDirection: "column"
      }
    }, W)
  }
  let J = Y.map((W, X) => {
    return B(W, Z + X)
  });
  return KM.default.createElement(hqB, null, KM.default.createElement("ink-box", {
    internal_static: !0,
    style: {
      position: "absolute",
      flexDirection: "column"
    }
  }, J))
}
// @from(Start 6433233, End 6433235)
KM
// @from(Start 6433241, End 6433296)
gqB = L(() => {
  Ru1();
  k7A();
  KM = BA(VA(), 1)
})
// @from(Start 6433302, End 6435453)
dqB = z((Ja7, mqB) => {
  var LH6 = UA("os"),
    uqB = UA("tty"),
    DM = uFA(),
    {
      env: vF
    } = process,
    Ip;
  if (DM("no-color") || DM("no-colors") || DM("color=false") || DM("color=never")) Ip = 0;
  else if (DM("color") || DM("colors") || DM("color=true") || DM("color=always")) Ip = 1;
  if ("FORCE_COLOR" in vF)
    if (vF.FORCE_COLOR === "true") Ip = 1;
    else if (vF.FORCE_COLOR === "false") Ip = 0;
  else Ip = vF.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(vF.FORCE_COLOR, 10), 3);

  function Tu1(A) {
    if (A === 0) return !1;
    return {
      level: A,
      hasBasic: !0,
      has256: A >= 2,
      has16m: A >= 3
    }
  }

  function Pu1(A, Q) {
    if (Ip === 0) return 0;
    if (DM("color=16m") || DM("color=full") || DM("color=truecolor")) return 3;
    if (DM("color=256")) return 2;
    if (A && !Q && Ip === void 0) return 0;
    let B = Ip || 0;
    if (vF.TERM === "dumb") return B;
    if (process.platform === "win32") {
      let G = LH6.release().split(".");
      if (Number(G[0]) >= 10 && Number(G[2]) >= 10586) return Number(G[2]) >= 14931 ? 3 : 2;
      return 1
    }
    if ("CI" in vF) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((G) => (G in vF)) || vF.CI_NAME === "codeship") return 1;
      return B
    }
    if ("TEAMCITY_VERSION" in vF) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(vF.TEAMCITY_VERSION) ? 1 : 0;
    if (vF.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in vF) {
      let G = parseInt((vF.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (vF.TERM_PROGRAM) {
        case "iTerm.app":
          return G >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2
      }
    }
    if (/-256(color)?$/i.test(vF.TERM)) return 2;
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(vF.TERM)) return 1;
    if ("COLORTERM" in vF) return 1;
    return B
  }

  function MH6(A) {
    let Q = Pu1(A, A && A.isTTY);
    return Tu1(Q)
  }
  mqB.exports = {
    supportsColor: MH6,
    stdout: Tu1(Pu1(!0, uqB.isatty(1))),
    stderr: Tu1(Pu1(!0, uqB.isatty(2)))
  }
})
// @from(Start 6435459, End 6437133)
lqB = z((Wa7, pqB) => {
  var OH6 = dqB(),
    b7A = uFA();

  function cqB(A) {
    if (/^\d{3,4}$/.test(A)) {
      let B = /(\d{1,2})(\d{2})/.exec(A);
      return {
        major: 0,
        minor: parseInt(B[1], 10),
        patch: parseInt(B[2], 10)
      }
    }
    let Q = (A || "").split(".").map((B) => parseInt(B, 10));
    return {
      major: Q[0],
      minor: Q[1],
      patch: Q[2]
    }
  }

  function ju1(A) {
    let {
      env: Q
    } = process;
    if ("FORCE_HYPERLINK" in Q) return !(Q.FORCE_HYPERLINK.length > 0 && parseInt(Q.FORCE_HYPERLINK, 10) === 0);
    if (b7A("no-hyperlink") || b7A("no-hyperlinks") || b7A("hyperlink=false") || b7A("hyperlink=never")) return !1;
    if (b7A("hyperlink=true") || b7A("hyperlink=always")) return !0;
    if ("NETLIFY" in Q) return !0;
    if (!OH6.supportsColor(A)) return !1;
    if (A && !A.isTTY) return !1;
    if (process.platform === "win32") return !1;
    if ("CI" in Q) return !1;
    if ("TEAMCITY_VERSION" in Q) return !1;
    if ("TERM_PROGRAM" in Q) {
      let B = cqB(Q.TERM_PROGRAM_VERSION);
      switch (Q.TERM_PROGRAM) {
        case "iTerm.app":
          if (B.major === 3) return B.minor >= 1;
          return B.major > 3;
        case "WezTerm":
          return B.major >= 20200620;
        case "vscode":
          return B.major > 1 || B.major === 1 && B.minor >= 72
      }
    }
    if ("VTE_VERSION" in Q) {
      if (Q.VTE_VERSION === "0.50.0") return !1;
      let B = cqB(Q.VTE_VERSION);
      return B.major > 0 || B.minor >= 50
    }
    return !1
  }
  pqB.exports = {
    supportsHyperlink: ju1,
    stdout: ju1(process.stdout),
    stderr: ju1(process.stderr)
  }
})
// @from(Start 6437136, End 6437332)
function EsA() {
  if (iqB.default.stdout) return !0;
  let A = process.env.TERM_PROGRAM;
  if (A && RH6.includes(A)) return !0;
  if (process.env.TERM?.includes("kitty")) return !0;
  return !1
}
// @from(Start 6437337, End 6437340)
iqB
// @from(Start 6437342, End 6437345)
RH6
// @from(Start 6437351, End 6437440)
Su1 = L(() => {
  iqB = BA(lqB(), 1), RH6 = ["ghostty", "Hyper", "kitty", "alacritty"]
})
// @from(Start 6437443, End 6437691)
function h4({
  children: A,
  url: Q,
  fallback: B
}) {
  let G = A ?? Q;
  if (EsA()) return zsA.default.createElement(lt, null, zsA.default.createElement("ink-link", {
    href: Q
  }, G));
  return zsA.default.createElement(lt, null, B ?? G)
}
// @from(Start 6437696, End 6437699)
zsA
// @from(Start 6437705, End 6437761)
nqB = L(() => {
  Su1();
  aaA();
  zsA = BA(VA(), 1)
})
// @from(Start 6437764, End 6437867)
function bF({
  count: A = 1
}) {
  return aqB.default.createElement("ink-text", null, `
`.repeat(A))
}
// @from(Start 6437872, End 6437875)
aqB
// @from(Start 6437881, End 6437919)
sqB = L(() => {
  aqB = BA(VA(), 1)
})
// @from(Start 6437925, End 6437928)
TH6
// @from(Start 6437934, End 6437981)
rqB = L(() => {
  rUA();
  TH6 = BA(VA(), 1)
})
// @from(Start 6437984, End 6438123)
function UsA({
  state: A,
  percentage: Q
}) {
  return oqB.default.createElement("ink-progress", {
    state: A,
    percentage: Q
  })
}
// @from(Start 6438128, End 6438131)
oqB
// @from(Start 6438137, End 6438175)
tqB = L(() => {
  oqB = BA(VA(), 1)
})
// @from(Start 6438181, End 6438184)
eqB
// @from(Start 6438186, End 6438217)
PH6 = () => eqB.useContext(caA)
// @from(Start 6438221, End 6438223)
Yp
// @from(Start 6438229, End 6438286)
$sA = L(() => {
  ng1();
  eqB = BA(VA(), 1), Yp = PH6
})
// @from(Start 6438292, End 6438295)
_u1
// @from(Start 6438297, End 6438957)
jH6 = (A, Q = {}) => {
    let {
      stdin: B,
      setRawMode: G,
      internal_exitOnCtrlC: Z,
      internal_eventEmitter: I
    } = Yp();
    _u1.useEffect(() => {
      if (Q.isActive === !1) return;
      return G(!0), () => {
        G(!1)
      }
    }, [Q.isActive, G]), _u1.useEffect(() => {
      if (Q.isActive === !1) return;
      let Y = (J) => {
        let {
          input: W,
          key: X
        } = J;
        if (!(W === "c" && X.ctrl) || !Z) Ap.batchedUpdates(() => {
          A(W, X, J)
        })
      };
      return I?.on("input", Y), () => {
        I?.removeListener("input", Y)
      }
    }, [Q.isActive, B, Z, A])
  }
// @from(Start 6438961, End 6438963)
f1
// @from(Start 6438969, End 6439035)
ANB = L(() => {
  $g1();
  $sA();
  _u1 = BA(VA(), 1), f1 = jH6
})
// @from(Start 6439041, End 6439044)
QNB
// @from(Start 6439046, End 6439077)
SH6 = () => QNB.useContext(daA)
// @from(Start 6439081, End 6439084)
ku1
// @from(Start 6439090, End 6439148)
BNB = L(() => {
  ig1();
  QNB = BA(VA(), 1), ku1 = SH6
})
// @from(Start 6439154, End 6439157)
yu1
// @from(Start 6439163, End 6439219)
GNB = L(() => {
  laA();
  $sA();
  yu1 = BA(VA(), 1)
})
// @from(Start 6439225, End 6439228)
_H6
// @from(Start 6439234, End 6439281)
ZNB = L(() => {
  laA();
  _H6 = BA(VA(), 1)
})
// @from(Start 6439287, End 6439404)
kH6 = (A) => ({
    width: A.yogaNode?.getComputedWidth() ?? 0,
    height: A.yogaNode?.getComputedHeight() ?? 0
  })
// @from(Start 6439408, End 6439411)
xu1
// @from(Start 6439417, End 6439447)
INB = L(() => {
  xu1 = kH6
})
// @from(Start 6439453, End 6439456)
f7A
// @from(Start 6439462, End 6439509)
YNB = L(() => {
  QsA();
  f7A = BA(VA(), 1)
})
// @from(Start 6439515, End 6439738)
hA = L(() => {
  vqB();
  rUA();
  fqB();
  aaA();
  saA();
  gqB();
  nqB();
  sqB();
  rqB();
  tqB();
  ANB();
  BNB();
  $sA();
  GNB();
  ZNB();
  INB();
  Ru1();
  oUA();
  iUA();
  FaA();
  Ju1();
  maA();
  YNB()
})
// @from(Start 6439741, End 6440259)
function Bf(A, Q, B) {
  let G = Jp.useRef(0),
    Z = Jp.useRef(void 0),
    I = Jp.useCallback(() => {
      if (Z.current) clearTimeout(Z.current), Z.current = void 0
    }, []);
  return Jp.useEffect(() => {
    return () => {
      I()
    }
  }, [I]), Jp.useCallback(() => {
    let Y = Date.now();
    if (Y - G.current <= JNB && Z.current !== void 0) I(), A(!1), Q();
    else B?.(), A(!0), I(), Z.current = setTimeout(() => {
      A(!1), Z.current = void 0
    }, JNB);
    G.current = Y
  }, [A, Q, B, I])
}
// @from(Start 6440264, End 6440266)
Jp
// @from(Start 6440268, End 6440277)
JNB = 800
// @from(Start 6440283, End 6440320)
wsA = L(() => {
  Jp = BA(VA(), 1)
})
// @from(Start 6440326, End 6442133)
DNB = z((Xs7, KNB) => {
  var FNB = UA("child_process"),
    WNB = FNB.spawn,
    yH6 = FNB.exec;
  KNB.exports = function(A, Q, B) {
    if (typeof Q === "function" && B === void 0) B = Q, Q = void 0;
    if (A = parseInt(A), Number.isNaN(A))
      if (B) return B(Error("pid must be a number"));
      else throw Error("pid must be a number");
    var G = {},
      Z = {};
    switch (G[A] = [], Z[A] = 1, process.platform) {
      case "win32":
        yH6("taskkill /pid " + A + " /T /F", B);
        break;
      case "darwin":
        vu1(A, G, Z, function(I) {
          return WNB("pgrep", ["-P", I])
        }, function() {
          XNB(G, Q, B)
        });
        break;
      default:
        vu1(A, G, Z, function(I) {
          return WNB("ps", ["-o", "pid", "--no-headers", "--ppid", I])
        }, function() {
          XNB(G, Q, B)
        });
        break
    }
  };

  function XNB(A, Q, B) {
    var G = {};
    try {
      Object.keys(A).forEach(function(Z) {
        if (A[Z].forEach(function(I) {
            if (!G[I]) VNB(I, Q), G[I] = 1
          }), !G[Z]) VNB(Z, Q), G[Z] = 1
      })
    } catch (Z) {
      if (B) return B(Z);
      else throw Z
    }
    if (B) return B()
  }

  function VNB(A, Q) {
    try {
      process.kill(parseInt(A, 10), Q)
    } catch (B) {
      if (B.code !== "ESRCH") throw B
    }
  }

  function vu1(A, Q, B, G, Z) {
    var I = G(A),
      Y = "";
    I.stdout.on("data", function(X) {
      var X = X.toString("ascii");
      Y += X
    });
    var J = function(W) {
      if (delete B[A], W != 0) {
        if (Object.keys(B).length == 0) Z();
        return
      }
      Y.match(/\d+/g).forEach(function(X) {
        X = parseInt(X, 10), Q[A].push(X), Q[X] = [], B[X] = 1, vu1(X, Q, B, G, Z)
      })
    };
    I.on("close", J)
  }
})
// @from(Start 6442135, End 6443053)
class K$A {
  capacity;
  buffer;
  head = 0;
  size = 0;
  constructor(A) {
    this.capacity = A;
    this.buffer = Array(A)
  }
  add(A) {
    if (this.buffer[this.head] = A, this.head = (this.head + 1) % this.capacity, this.size < this.capacity) this.size++
  }
  addAll(A) {
    for (let Q of A) this.add(Q)
  }
  getRecent(A) {
    let Q = [],
      B = this.size < this.capacity ? 0 : this.head,
      G = Math.min(A, this.size);
    for (let Z = 0; Z < G; Z++) {
      let I = (B + this.size - G + Z) % this.capacity;
      Q.push(this.buffer[I])
    }
    return Q
  }
  toArray() {
    if (this.size === 0) return [];
    let A = [],
      Q = this.size < this.capacity ? 0 : this.head;
    for (let B = 0; B < this.size; B++) {
      let G = (Q + B) % this.capacity;
      A.push(this.buffer[G])
    }
    return A
  }
  clear() {
    this.head = 0, this.size = 0
  }
  length() {
    return this.size
  }
}
// @from(Start 6443055, End 6443400)
function bu1(A, Q = ",", B = 67108736) {
  let Z = "";
  for (let I of A) {
    let Y = Z ? Q : "",
      J = Y + I;
    if (Z.length + J.length <= B) Z += J;
    else {
      let W = B - Z.length - Y.length - 14;
      if (W > 0) Z += Y + I.slice(0, W) + "...[truncated]";
      else Z += "...[truncated]";
      return Z
    }
  }
  return Z
}
// @from(Start 6443401, End 6444410)
class h7A {
  maxSize;
  content = "";
  isTruncated = !1;
  totalBytesReceived = 0;
  constructor(A = 67108736) {
    this.maxSize = A
  }
  append(A) {
    let Q = typeof A === "string" ? A : A.toString();
    if (this.totalBytesReceived += Q.length, this.isTruncated && this.content.length >= this.maxSize) return;
    if (this.content.length + Q.length > this.maxSize) {
      let B = this.maxSize - this.content.length;
      if (B > 0) this.content += Q.slice(0, B);
      this.isTruncated = !0
    } else this.content += Q
  }
  toString() {
    if (!this.isTruncated) return this.content;
    let A = this.totalBytesReceived - this.maxSize,
      Q = Math.round(A / 1024);
    return this.content + `
... [output truncated - ${Q}KB removed]`
  }
  clear() {
    this.content = "", this.isTruncated = !1, this.totalBytesReceived = 0
  }
  get length() {
    return this.content.length
  }
  get truncated() {
    return this.isTruncated
  }
  get totalBytes() {
    return this.totalBytesReceived
  }
}
// @from(Start 6444412, End 6444591)
function HNB(A, Q) {
  if (A.length <= Q) return A;
  let B = A.length - Q,
    Z = `

... [tool result truncated - ${Math.round(B/1024)}KB removed]`;
  return A.slice(0, Q) + Z
}
// @from(Start 6444640, End 6444942)
function zNB(A) {
  let Q = null,
    B = new h7A;
  A.on("data", (Z) => {
    if (Q) Q.write(Z);
    else B.append(Z)
  });
  let G = () => B.toString();
  return {
    get: G,
    asStream() {
      return Q = new xH6({
        highWaterMark: 10485760
      }), Q.write(G()), B.clear(), Q
    }
  }
}
// @from(Start 6444944, End 6446818)
function qsA(A, Q, B, G, Z = !1) {
  let I = "running",
    Y, J = zNB(A.stdout),
    W = zNB(A.stderr);
  if (G) {
    let E = new K$A(1000),
      U = 0,
      q = (w) => {
        let R = w.toString().split(`
`).filter((y) => y.trim());
        E.addAll(R), U += R.length;
        let T = E.getRecent(5);
        if (T.length > 0) G(bu1(T, `
`), bu1(E.getRecent(100), `
`), U)
      };
    A.stdout.on("data", q), A.stderr.on("data", q)
  }
  let X = (E) => {
      if (I = "killed", A.pid) UNB.default(A.pid, "SIGKILL")
    },
    V = null,
    F, K, D = (E) => {
      if (I === "running") return Y = E, I = "backgrounded", F(), {
        stdoutStream: J.asStream(),
        stderrStream: W.asStream()
      };
      return null
    },
    H = new Promise((E) => {
      let U = () => X();
      F = () => {
        if (V) clearTimeout(V), V = null;
        Q.removeEventListener("abort", U)
      }, Q.addEventListener("abort", U, {
        once: !0
      }), new Promise((q) => {
        let w = X;
        X = (N) => {
          w(), q(N || CNB)
        }, V = setTimeout(() => {
          if (Z && K) K(D);
          else X(ENB)
        }, B), A.on("close", (N, R) => {
          q(N !== null && N !== void 0 ? N : R === "SIGTERM" ? 144 : 1)
        }), A.on("error", () => q(1))
      }).then((q) => {
        if (F(), I === "running" || I === "backgrounded") I = "completed";
        let w = {
          code: q,
          stdout: J.get(),
          stderr: W.get(),
          interrupted: q === CNB,
          backgroundTaskId: Y
        };
        if (q === ENB) w.stderr = [`Command timed out after ${eC(B)}`, w.stderr].filter(Boolean).join(" ");
        E(w)
      })
    }),
    C = {
      get status() {
        return I
      },
      background: D,
      kill: () => X(),
      result: H
    };
  if (Z) C.onTimeout = (E) => {
    K = E
  };
  return C
}
// @from(Start 6446820, End 6447121)
function $NB(A) {
  return {
    get status() {
      return "killed"
    },
    background: () => null,
    kill: () => {},
    result: Promise.resolve({
      code: 145,
      stdout: "",
      stderr: "Command aborted before execution",
      interrupted: !0,
      backgroundTaskId: A
    })
  }
}
// @from(Start 6447126, End 6447129)
UNB
// @from(Start 6447131, End 6447140)
CNB = 137
// @from(Start 6447144, End 6447153)
ENB = 143
// @from(Start 6447159, End 6447198)
fu1 = L(() => {
  UNB = BA(DNB(), 1)
})
// @from(Start 6447201, End 6447410)
function NsA(A, Q) {
  let B = A.lastIndexOf(" -");
  if (B > 0) {
    let G = A.substring(0, B),
      Z = A.substring(B + 1);
    return `${z8([G])} ${Z} ${z8([Q])}`
  } else return `${z8([A])} ${z8([Q])}`
}
// @from(Start 6447415, End 6447440)
hu1 = L(() => {
  dK()
})
// @from(Start 6447598, End 6447702)
function NNB() {
  let A = gu1(MQ(), "session-env", e1());
  return vH6(A, {
    recursive: !0
  }), A
}
// @from(Start 6447704, End 6447759)
function LsA(A) {
  return gu1(NNB(), `hook-${A}.sh`)
}
// @from(Start 6447761, End 6447838)
function LNB() {
  g("Invalidating session environment cache"), Wp = void 0
}
// @from(Start 6447840, End 6449086)
function MNB() {
  if (dQ() === "windows") return g("Session environment not yet supported on Windows"), null;
  if (Wp !== void 0) return Wp;
  let A = [],
    Q = process.env.CLAUDE_ENV_FILE;
  if (Q && qNB(Q)) try {
    let G = wNB(Q, "utf8").trim();
    if (G) A.push(G), g(`Session environment loaded from CLAUDE_ENV_FILE: ${Q} (${G.length} chars)`)
  } catch (G) {
    g(`Failed to read CLAUDE_ENV_FILE: ${G instanceof Error?G.message:String(G)}`)
  }
  let B = NNB();
  if (qNB(B)) try {
    let Z = bH6(B).filter((I) => I.startsWith("hook-") && I.endsWith(".sh")).sort((I, Y) => {
      let J = parseInt(I.match(/hook-(\d+)\.sh/)?.[1] || "0", 10),
        W = parseInt(Y.match(/hook-(\d+)\.sh/)?.[1] || "0", 10);
      return J - W
    });
    for (let I of Z) {
      let Y = gu1(B, I),
        J = wNB(Y, "utf8").trim();
      if (J) A.push(J)
    }
    if (Z.length > 0) g(`Session environment loaded from ${Z.length} hook file(s)`)
  } catch (G) {
    g(`Failed to load session environment from hooks: ${G instanceof Error?G.message:String(G)}`)
  }
  if (A.length === 0) return g("No session environment scripts found"), Wp = null, Wp;
  return Wp = A.join(`
`), g(`Session environment script ready (${Wp.length} chars total)`), Wp
}
// @from(Start 6449091, End 6449102)
Wp = void 0
// @from(Start 6449108, End 6449157)
D$A = L(() => {
  V0();
  Q3();
  hQ();
  _0()
})
// @from(Start 6449160, End 6449894)
function Xp({
  isFocused: A,
  isSelected: Q,
  children: B,
  description: G,
  shouldShowDownArrow: Z,
  shouldShowUpArrow: I
}) {
  return v_.default.createElement(S, {
    flexDirection: "column"
  }, v_.default.createElement(S, {
    flexDirection: "row",
    gap: 1
  }, A ? v_.default.createElement($, {
    color: "suggestion"
  }, H1.pointer) : Z ? v_.default.createElement($, {
    dimColor: !0
  }, H1.arrowDown) : I ? v_.default.createElement($, {
    dimColor: !0
  }, H1.arrowUp) : v_.default.createElement($, null, " "), B, Q && v_.default.createElement($, {
    color: "success"
  }, H1.tick)), G && v_.default.createElement(S, {
    paddingLeft: 5
  }, v_.default.createElement($, {
    color: "inactive"
  }, G)))
}
// @from(Start 6449899, End 6449901)
v_
// @from(Start 6449907, End 6449960)
MsA = L(() => {
  V9();
  hA();
  v_ = BA(VA(), 1)
})
// @from(Start 6449966, End 6449969)
OsA
// @from(Start 6449975, End 6450473)
ONB = L(() => {
  OsA = class OsA extends Map {
    first;
    last;
    constructor(A) {
      let Q = [],
        B, G, Z, I = 0;
      for (let Y of A) {
        let J = {
          label: Y.label,
          value: Y.value,
          description: Y.description,
          previous: Z,
          next: void 0,
          index: I
        };
        if (Z) Z.next = J;
        B ||= J, G = J, Q.push([Y.value, J]), I++, Z = J
      }
      super(Q);
      this.first = B, this.last = G
    }
  }
})
// @from(Start 6450532, End 6452459)
function RsA({
  visibleOptionCount: A = 5,
  options: Q,
  initialFocusValue: B,
  onFocus: G,
  focusValue: Z
}) {
  let [I, Y] = uH.useReducer(hH6, {
    visibleOptionCount: A,
    options: Q,
    initialFocusValue: Z || B
  }, RNB), [J, W] = uH.useState(Q);
  if (Q !== J && !fH6(Q, J)) Y({
    type: "reset",
    state: RNB({
      visibleOptionCount: A,
      options: Q,
      initialFocusValue: Z ?? I.focusedValue ?? B,
      currentViewport: {
        visibleFromIndex: I.visibleFromIndex,
        visibleToIndex: I.visibleToIndex
      }
    })
  }), W(Q);
  let X = uH.useCallback(() => {
      Y({
        type: "focus-next-option"
      })
    }, []),
    V = uH.useCallback(() => {
      Y({
        type: "focus-previous-option"
      })
    }, []),
    F = uH.useCallback(() => {
      Y({
        type: "focus-next-page"
      })
    }, []),
    K = uH.useCallback(() => {
      Y({
        type: "focus-previous-page"
      })
    }, []),
    D = uH.useCallback((E) => {
      if (E !== void 0) Y({
        type: "set-focus",
        value: E
      })
    }, []),
    H = uH.useMemo(() => {
      return Q.map((E, U) => ({
        ...E,
        index: U
      })).slice(I.visibleFromIndex, I.visibleToIndex)
    }, [Q, I.visibleFromIndex, I.visibleToIndex]);
  uH.useEffect(() => {
    if (I.focusedValue !== void 0) G?.(I.focusedValue)
  }, [I.focusedValue, G]), uH.useEffect(() => {
    if (Z !== void 0) Y({
      type: "set-focus",
      value: Z
    })
  }, [Z]);
  let C = uH.useMemo(() => {
    return Q.find((U) => U.value === I.focusedValue)?.type === "input"
  }, [I.focusedValue, Q]);
  return {
    focusedValue: I.focusedValue,
    visibleFromIndex: I.visibleFromIndex,
    visibleToIndex: I.visibleToIndex,
    visibleOptions: H,
    isInInput: C ?? !1,
    focusNextOption: X,
    focusPreviousOption: V,
    focusNextPage: F,
    focusPreviousPage: K,
    focusOption: D,
    options: Q
  }
}
// @from(Start 6452464, End 6452466)
uH
// @from(Start 6452468, End 6456098)
hH6 = (A, Q) => {
    switch (Q.type) {
      case "focus-next-option": {
        if (A.focusedValue === void 0) return A;
        let B = A.optionMap.get(A.focusedValue);
        if (!B) return A;
        let G = B.next || A.optionMap.first;
        if (!G) return A;
        if (!B.next && G === A.optionMap.first) return {
          ...A,
          focusedValue: G.value,
          visibleFromIndex: 0,
          visibleToIndex: A.visibleOptionCount
        };
        if (!(G.index >= A.visibleToIndex)) return {
          ...A,
          focusedValue: G.value
        };
        let I = Math.min(A.optionMap.size, A.visibleToIndex + 1),
          Y = I - A.visibleOptionCount;
        return {
          ...A,
          focusedValue: G.value,
          visibleFromIndex: Y,
          visibleToIndex: I
        }
      }
      case "focus-previous-option": {
        if (A.focusedValue === void 0) return A;
        let B = A.optionMap.get(A.focusedValue);
        if (!B) return A;
        let G = B.previous || A.optionMap.last;
        if (!G) return A;
        if (!B.previous && G === A.optionMap.last) {
          let J = A.optionMap.size,
            W = Math.max(0, J - A.visibleOptionCount);
          return {
            ...A,
            focusedValue: G.value,
            visibleFromIndex: W,
            visibleToIndex: J
          }
        }
        if (!(G.index <= A.visibleFromIndex)) return {
          ...A,
          focusedValue: G.value
        };
        let I = Math.max(0, A.visibleFromIndex - 1),
          Y = I + A.visibleOptionCount;
        return {
          ...A,
          focusedValue: G.value,
          visibleFromIndex: I,
          visibleToIndex: Y
        }
      }
      case "focus-next-page": {
        if (A.focusedValue === void 0) return A;
        let B = A.optionMap.get(A.focusedValue);
        if (!B) return A;
        let G = Math.min(A.optionMap.size - 1, B.index + A.visibleOptionCount),
          Z = A.optionMap.first;
        while (Z && Z.index < G)
          if (Z.next) Z = Z.next;
          else break;
        if (!Z) return A;
        let I = Math.min(A.optionMap.size, Z.index + 1),
          Y = Math.max(0, I - A.visibleOptionCount);
        return {
          ...A,
          focusedValue: Z.value,
          visibleFromIndex: Y,
          visibleToIndex: I
        }
      }
      case "focus-previous-page": {
        if (A.focusedValue === void 0) return A;
        let B = A.optionMap.get(A.focusedValue);
        if (!B) return A;
        let G = Math.max(0, B.index - A.visibleOptionCount),
          Z = A.optionMap.first;
        while (Z && Z.index < G)
          if (Z.next) Z = Z.next;
          else break;
        if (!Z) return A;
        let I = Math.max(0, Z.index),
          Y = Math.min(A.optionMap.size, I + A.visibleOptionCount);
        return {
          ...A,
          focusedValue: Z.value,
          visibleFromIndex: I,
          visibleToIndex: Y
        }
      }
      case "reset":
        return Q.state;
      case "set-focus": {
        let B = A.optionMap.get(Q.value);
        if (!B) return A;
        if (B.index >= A.visibleFromIndex && B.index < A.visibleToIndex) return {
          ...A,
          focusedValue: Q.value
        };
        let G, Z;
        if (B.index < A.visibleFromIndex) G = B.index, Z = Math.min(A.optionMap.size, G + A.visibleOptionCount);
        else Z = Math.min(A.optionMap.size, B.index + 1), G = Math.max(0, Z - A.visibleOptionCount);
        return {
          ...A,
          focusedValue: Q.value,
          visibleFromIndex: G,
          visibleToIndex: Z
        }
      }
    }
  }
// @from(Start 6456102, End 6456940)
RNB = ({
    visibleOptionCount: A,
    options: Q,
    initialFocusValue: B,
    currentViewport: G
  }) => {
    let Z = typeof A === "number" ? Math.min(A, Q.length) : Q.length,
      I = new OsA(Q),
      Y = B !== void 0 && I.get(B),
      J = Y ? B : I.first?.value,
      W = 0,
      X = Z;
    if (Y && G) {
      let V = Y.index;
      if (V >= G.visibleFromIndex && V < G.visibleToIndex) W = G.visibleFromIndex, X = Math.min(I.size, G.visibleToIndex);
      else if (V < G.visibleFromIndex) W = V, X = Math.min(I.size, W + Z);
      else X = Math.min(I.size, V + 1), W = Math.max(0, X - Z);
      W = Math.max(0, Math.min(W, I.size - 1)), X = Math.min(I.size, Math.max(Z, X))
    }
    return {
      optionMap: I,
      visibleOptionCount: Z,
      focusedValue: J,
      visibleFromIndex: W,
      visibleToIndex: X
    }
  }
// @from(Start 6456946, End 6456992)
uu1 = L(() => {
  ONB();
  uH = BA(VA(), 1)
})
// @from(Start 6456995, End 6457468)
function TNB({
  visibleOptionCount: A = 5,
  options: Q,
  defaultValue: B,
  onChange: G,
  onCancel: Z,
  onFocus: I,
  focusValue: Y
}) {
  let [J, W] = TsA.useState(B), X = RsA({
    visibleOptionCount: A,
    options: Q,
    initialFocusValue: void 0,
    onFocus: I,
    focusValue: Y
  }), V = TsA.useCallback(() => {
    W(X.focusedValue)
  }, [X.focusedValue]);
  return {
    ...X,
    value: J,
    selectFocusedOption: V,
    onChange: G,
    onCancel: Z
  }
}
// @from(Start 6457473, End 6457476)
TsA
// @from(Start 6457482, End 6457529)
PNB = L(() => {
  uu1();
  TsA = BA(VA(), 1)
})
// @from(Start 6457535, End 6458781)
jNB = ({
  isDisabled: A = !1,
  disableSelection: Q = !1,
  state: B,
  options: G,
  isMultiSelect: Z = !1
}) => {
  f1((I, Y) => {
    let J = G.find((X) => X.value === B.focusedValue);
    if (J?.type === "input") {
      if (!(Y.upArrow || Y.downArrow || Y.escape || Y.ctrl && (I === "n" || I === "p"))) return
    }
    if (Y.downArrow || Y.ctrl && I === "n" || !Y.ctrl && !Y.shift && I === "j") B.focusNextOption();
    if (Y.upArrow || Y.ctrl && I === "p" || !Y.ctrl && !Y.shift && I === "k") B.focusPreviousOption();
    if (Y.pageDown) B.focusNextPage();
    if (Y.pageUp) B.focusPreviousPage();
    if (Q !== !0) {
      if ((Z ? Y.return || I === " " : Y.return) && B.focusedValue !== void 0) {
        if (J?.disabled !== !0) B.selectFocusedOption?.(), B.onChange?.(B.focusedValue)
      }
      if (Q !== "numeric" && /^[0-9]+$/.test(I)) {
        let V = parseInt(I) - 1;
        if (V >= 0 && V < B.options.length) {
          let F = B.options[V];
          if (F.disabled === !0) return;
          if (F.type === "input") {
            B.focusOption(F.value);
            return
          }
          B.onChange?.(F.value);
          return
        }
      }
    }
    if (Y.escape) B.onCancel?.()
  }, {
    isActive: !A
  })
}
// @from(Start 6458787, End 6458812)
SNB = L(() => {
  hA()
})
// @from(Start 6458815, End 6458932)
function SsA(A, Q = !1) {
  if (A.length > 0) {
    if (Q && mu1) PsA = A + PsA;
    else PsA = A;
    mu1 = !0
  }
}
// @from(Start 6458934, End 6458965)
function _NB() {
  return PsA
}
// @from(Start 6458967, End 6458996)
function _sA() {
  mu1 = !1
}
// @from(Start 6458997, End 6467555)
class j7 {
  measuredText;
  selection;
  offset;
  constructor(A, Q = 0, B = 0) {
    this.measuredText = A;
    this.selection = B;
    this.offset = Math.max(0, Math.min(this.text.length, Q))
  }
  static fromText(A, Q, B = 0, G = 0) {
    return new j7(new kNB(A, Q - 1), B, G)
  }
  render(A, Q, B) {
    let {
      line: G,
      column: Z
    } = this.getPosition();
    return this.measuredText.getWrappedText().map((I, Y, J) => {
      let W = I;
      if (Q && Y === J.length - 1) {
        let C = Math.max(0, I.length - 6);
        W = Q.repeat(C) + I.slice(C)
      }
      if (G !== Y) return W.trimEnd();
      let X = this.measuredText.displayWidthToStringIndex(W, Z),
        V = Array.from(du1.segment(W)).map(({
          segment: C,
          index: E
        }) => ({
          segment: C,
          index: E
        })),
        F = "",
        K = A,
        D = "";
      for (let {
          segment: C,
          index: E
        }
        of V) {
        let U = E + C.length;
        if (U <= X) F += C;
        else if (E < X && U > X) K = C;
        else if (E === X) K = C;
        else D += C
      }
      let H = A ? B(K) : K;
      return F + H + D.trimEnd()
    }).join(`
`)
  }
  left() {
    if (this.offset === 0) return this;
    let A = this.measuredText.prevOffset(this.offset);
    return new j7(this.measuredText, A)
  }
  right() {
    if (this.offset >= this.text.length) return this;
    let A = this.measuredText.nextOffset(this.offset);
    return new j7(this.measuredText, Math.min(A, this.text.length))
  }
  up() {
    let {
      line: A,
      column: Q
    } = this.getPosition();
    if (A === 0) return this;
    let B = this.measuredText.getWrappedText()[A - 1];
    if (!B) return this;
    let G = xZ(B);
    if (Q > G) {
      let I = this.getOffset({
        line: A - 1,
        column: G
      });
      return new j7(this.measuredText, I, 0)
    }
    let Z = this.getOffset({
      line: A - 1,
      column: Q
    });
    return new j7(this.measuredText, Z, 0)
  }
  down() {
    let {
      line: A,
      column: Q
    } = this.getPosition();
    if (A >= this.measuredText.lineCount - 1) return this;
    let B = this.measuredText.getWrappedText()[A + 1];
    if (!B) return this;
    let G = xZ(B);
    if (Q > G) {
      let I = this.getOffset({
        line: A + 1,
        column: G
      });
      return new j7(this.measuredText, I, 0)
    }
    let Z = this.getOffset({
      line: A + 1,
      column: Q
    });
    return new j7(this.measuredText, Z, 0)
  }
  startOfLine() {
    let {
      line: A
    } = this.getPosition();
    return new j7(this.measuredText, this.getOffset({
      line: A,
      column: 0
    }), 0)
  }
  firstNonBlankInLine() {
    let {
      line: A
    } = this.getPosition(), B = (this.measuredText.getWrappedText()[A] || "").match(/^\s*\S/), G = B?.index ? B.index + B[0].length - 1 : 0, Z = this.getOffset({
      line: A,
      column: G
    });
    return new j7(this.measuredText, Z, 0)
  }
  endOfLine() {
    let {
      line: A
    } = this.getPosition(), Q = this.measuredText.getLineLength(A), B = this.getOffset({
      line: A,
      column: Q
    });
    return new j7(this.measuredText, B, 0)
  }
  findLogicalLineStart(A = this.offset) {
    let Q = this.text.lastIndexOf(`
`, A - 1);
    return Q === -1 ? 0 : Q + 1
  }
  findLogicalLineEnd(A = this.offset) {
    let Q = this.text.indexOf(`
`, A);
    return Q === -1 ? this.text.length : Q
  }
  getLogicalLineBounds() {
    return {
      start: this.findLogicalLineStart(),
      end: this.findLogicalLineEnd()
    }
  }
  createCursorWithColumn(A, Q, B) {
    let G = Q - A,
      Z = Math.min(B, G);
    return new j7(this.measuredText, A + Z, 0)
  }
  endOfLogicalLine() {
    return new j7(this.measuredText, this.findLogicalLineEnd(), 0)
  }
  startOfLogicalLine() {
    return new j7(this.measuredText, this.findLogicalLineStart(), 0)
  }
  firstNonBlankInLogicalLine() {
    let {
      start: A,
      end: Q
    } = this.getLogicalLineBounds(), G = this.text.slice(A, Q).match(/\S/), Z = A + (G?.index ?? 0);
    return new j7(this.measuredText, Z, 0)
  }
  upLogicalLine() {
    let {
      start: A
    } = this.getLogicalLineBounds();
    if (A === 0) return new j7(this.measuredText, 0, 0);
    let Q = this.offset - A,
      B = A - 1,
      G = this.findLogicalLineStart(B);
    return this.createCursorWithColumn(G, B, Q)
  }
  downLogicalLine() {
    let {
      start: A,
      end: Q
    } = this.getLogicalLineBounds();
    if (Q >= this.text.length) return new j7(this.measuredText, this.text.length, 0);
    let B = this.offset - A,
      G = Q + 1,
      Z = this.findLogicalLineEnd(G);
    return this.createCursorWithColumn(G, Z, B)
  }
  nextWord() {
    let A = this;
    while (A.isOverWordChar() && !A.isAtEnd()) A = A.right();
    while (!A.isOverWordChar() && !A.isAtEnd()) A = A.right();
    return A
  }
  endOfWord() {
    let A = this;
    if (A.isOverWordChar() && (!A.right().isOverWordChar() || A.right().isAtEnd())) return A = A.right(), A.endOfWord();
    if (!A.isOverWordChar()) A = A.nextWord();
    while (A.right().isOverWordChar() && !A.isAtEnd()) A = A.right();
    return A
  }
  prevWord() {
    let A = this;
    if (!A.left().isOverWordChar()) A = A.left();
    while (!A.isOverWordChar() && !A.isAtStart()) A = A.left();
    if (A.isOverWordChar())
      while (A.left().isOverWordChar() && !A.isAtStart()) A = A.left();
    return A
  }
  nextWORD() {
    let A = this;
    while (!A.isOverWhitespace() && !A.isAtEnd()) A = A.right();
    while (A.isOverWhitespace() && !A.isAtEnd()) A = A.right();
    return A
  }
  endOfWORD() {
    let A = this;
    if (!A.isOverWhitespace() && (A.right().isOverWhitespace() || A.right().isAtEnd())) return A = A.right(), A.endOfWORD();
    if (A.isOverWhitespace()) A = A.nextWORD();
    while (!A.right().isOverWhitespace() && !A.isAtEnd()) A = A.right();
    return A
  }
  prevWORD() {
    let A = this;
    if (A.left().isOverWhitespace()) A = A.left();
    while (A.isOverWhitespace() && !A.isAtStart()) A = A.left();
    if (!A.isOverWhitespace())
      while (!A.left().isOverWhitespace() && !A.isAtStart()) A = A.left();
    return A
  }
  modifyText(A, Q = "") {
    let B = this.offset,
      G = A.offset,
      Z = this.text.slice(0, B) + Q + this.text.slice(G);
    return j7.fromText(Z, this.columns, B + Q.normalize("NFC").length)
  }
  insert(A) {
    return this.modifyText(this, A)
  }
  del() {
    if (this.isAtEnd()) return this;
    return this.modifyText(this.right())
  }
  backspace() {
    if (this.isAtStart()) return this;
    return this.left().modifyText(this)
  }
  deleteToLineStart() {
    let A = this.startOfLine(),
      Q = this.text.slice(A.offset, this.offset);
    return {
      cursor: A.modifyText(this),
      killed: Q
    }
  }
  deleteToLineEnd() {
    if (this.text[this.offset] === `
`) return {
      cursor: this.modifyText(this.right()),
      killed: `
`
    };
    let A = this.endOfLine(),
      Q = this.text.slice(this.offset, A.offset);
    return {
      cursor: this.modifyText(A),
      killed: Q
    }
  }
  deleteToLogicalLineEnd() {
    if (this.text[this.offset] === `
`) return this.modifyText(this.right());
    return this.modifyText(this.endOfLogicalLine())
  }
  deleteWordBefore() {
    if (this.isAtStart()) return {
      cursor: this,
      killed: ""
    };
    let A = this.prevWord(),
      Q = this.text.slice(A.offset, this.offset);
    return {
      cursor: A.modifyText(this),
      killed: Q
    }
  }
  deleteWordAfter() {
    if (this.isAtEnd()) return this;
    return this.modifyText(this.nextWord())
  }
  isOverWordChar() {
    let A = this.text[this.offset] ?? "";
    return /\w/.test(A)
  }
  isOverWhitespace() {
    let A = this.text[this.offset] ?? "";
    return /\s/.test(A)
  }
  equals(A) {
    return this.offset === A.offset && this.measuredText === A.measuredText
  }
  isAtStart() {
    return this.offset === 0
  }
  isAtEnd() {
    return this.offset >= this.text.length
  }
  startOfFirstLine() {
    return new j7(this.measuredText, 0, 0)
  }
  startOfLastLine() {
    let A = this.text.lastIndexOf(`
`);
    if (A === -1) return this.startOfLine();
    return new j7(this.measuredText, A + 1, 0)
  }
  get text() {
    return this.measuredText.text
  }
  get columns() {
    return this.measuredText.columns + 1
  }
  getPosition() {
    return this.measuredText.getPositionFromOffset(this.offset)
  }
  getOffset(A) {
    return this.measuredText.getOffsetFromPosition(A)
  }
}
// @from(Start 6467556, End 6467949)
class jsA {
  text;
  startOffset;
  isPrecededByNewline;
  endsWithNewline;
  constructor(A, Q, B, G = !1) {
    this.text = A;
    this.startOffset = Q;
    this.isPrecededByNewline = B;
    this.endsWithNewline = G
  }
  equals(A) {
    return this.text === A.text && this.startOffset === A.startOffset
  }
  get length() {
    return this.text.length + (this.endsWithNewline ? 1 : 0)
  }
}
// @from(Start 6556765, End 6568846)
nLB = z((Jr7, iLB) => {
  var CE6 = msA(),
    H0 = b_(),
    lLB = {
      integer: "integer",
      float: "float",
      approximate: "approximate"
    };

  function EE6(A, Q) {
    if (this.options.useExifOrientation || this.options.angle || this.options.rotationAngle) this.options.debuglog("ignoring previous rotate options");
    if (!H0.defined(A)) this.options.useExifOrientation = !0;
    else if (H0.integer(A) && !(A % 90)) this.options.angle = A;
    else if (H0.number(A)) {
      if (this.options.rotationAngle = A, H0.object(Q) && Q.background) {
        let B = CE6(Q.background);
        this.options.rotationBackground = [B.red(), B.green(), B.blue(), Math.round(B.alpha() * 255)]
      }
    } else throw H0.invalidParameterError("angle", "numeric", A);
    return this
  }

  function zE6(A) {
    return this.options.flip = H0.bool(A) ? A : !0, this
  }

  function UE6(A) {
    return this.options.flop = H0.bool(A) ? A : !0, this
  }

  function $E6(A, Q) {
    let B = [].concat(...A);
    if (B.length === 4 && B.every(H0.number)) this.options.affineMatrix = B;
    else throw H0.invalidParameterError("matrix", "1x4 or 2x2 array", A);
    if (H0.defined(Q))
      if (H0.object(Q)) {
        if (this._setBackgroundColourOption("affineBackground", Q.background), H0.defined(Q.idx))
          if (H0.number(Q.idx)) this.options.affineIdx = Q.idx;
          else throw H0.invalidParameterError("options.idx", "number", Q.idx);
        if (H0.defined(Q.idy))
          if (H0.number(Q.idy)) this.options.affineIdy = Q.idy;
          else throw H0.invalidParameterError("options.idy", "number", Q.idy);
        if (H0.defined(Q.odx))
          if (H0.number(Q.odx)) this.options.affineOdx = Q.odx;
          else throw H0.invalidParameterError("options.odx", "number", Q.odx);
        if (H0.defined(Q.ody))
          if (H0.number(Q.ody)) this.options.affineOdy = Q.ody;
          else throw H0.invalidParameterError("options.ody", "number", Q.ody);
        if (H0.defined(Q.interpolator))
          if (H0.inArray(Q.interpolator, Object.values(this.constructor.interpolators))) this.options.affineInterpolator = Q.interpolator;
          else throw H0.invalidParameterError("options.interpolator", "valid interpolator name", Q.interpolator)
      } else throw H0.invalidParameterError("options", "object", Q);
    return this
  }

  function wE6(A, Q, B) {
    if (!H0.defined(A)) this.options.sharpenSigma = -1;
    else if (H0.bool(A)) this.options.sharpenSigma = A ? -1 : 0;
    else if (H0.number(A) && H0.inRange(A, 0.01, 1e4)) {
      if (this.options.sharpenSigma = A, H0.defined(Q))
        if (H0.number(Q) && H0.inRange(Q, 0, 1e4)) this.options.sharpenM1 = Q;
        else throw H0.invalidParameterError("flat", "number between 0 and 10000", Q);
      if (H0.defined(B))
        if (H0.number(B) && H0.inRange(B, 0, 1e4)) this.options.sharpenM2 = B;
        else throw H0.invalidParameterError("jagged", "number between 0 and 10000", B)
    } else if (H0.plainObject(A)) {
      if (H0.number(A.sigma) && H0.inRange(A.sigma, 0.000001, 10)) this.options.sharpenSigma = A.sigma;
      else throw H0.invalidParameterError("options.sigma", "number between 0.000001 and 10", A.sigma);
      if (H0.defined(A.m1))
        if (H0.number(A.m1) && H0.inRange(A.m1, 0, 1e6)) this.options.sharpenM1 = A.m1;
        else throw H0.invalidParameterError("options.m1", "number between 0 and 1000000", A.m1);
      if (H0.defined(A.m2))
        if (H0.number(A.m2) && H0.inRange(A.m2, 0, 1e6)) this.options.sharpenM2 = A.m2;
        else throw H0.invalidParameterError("options.m2", "number between 0 and 1000000", A.m2);
      if (H0.defined(A.x1))
        if (H0.number(A.x1) && H0.inRange(A.x1, 0, 1e6)) this.options.sharpenX1 = A.x1;
        else throw H0.invalidParameterError("options.x1", "number between 0 and 1000000", A.x1);
      if (H0.defined(A.y2))
        if (H0.number(A.y2) && H0.inRange(A.y2, 0, 1e6)) this.options.sharpenY2 = A.y2;
        else throw H0.invalidParameterError("options.y2", "number between 0 and 1000000", A.y2);
      if (H0.defined(A.y3))
        if (H0.number(A.y3) && H0.inRange(A.y3, 0, 1e6)) this.options.sharpenY3 = A.y3;
        else throw H0.invalidParameterError("options.y3", "number between 0 and 1000000", A.y3)
    } else throw H0.invalidParameterError("sigma", "number between 0.01 and 10000", A);
    return this
  }

  function qE6(A) {
    if (!H0.defined(A)) this.options.medianSize = 3;
    else if (H0.integer(A) && H0.inRange(A, 1, 1000)) this.options.medianSize = A;
    else throw H0.invalidParameterError("size", "integer between 1 and 1000", A);
    return this
  }

  function NE6(A) {
    let Q;
    if (H0.number(A)) Q = A;
    else if (H0.plainObject(A)) {
      if (!H0.number(A.sigma)) throw H0.invalidParameterError("options.sigma", "number between 0.3 and 1000", Q);
      if (Q = A.sigma, "precision" in A)
        if (H0.string(lLB[A.precision])) this.options.precision = lLB[A.precision];
        else throw H0.invalidParameterError("precision", "one of: integer, float, approximate", A.precision);
      if ("minAmplitude" in A)
        if (H0.number(A.minAmplitude) && H0.inRange(A.minAmplitude, 0.001, 1)) this.options.minAmpl = A.minAmplitude;
        else throw H0.invalidParameterError("minAmplitude", "number between 0.001 and 1", A.minAmplitude)
    }
    if (!H0.defined(A)) this.options.blurSigma = -1;
    else if (H0.bool(A)) this.options.blurSigma = A ? -1 : 0;
    else if (H0.number(Q) && H0.inRange(Q, 0.3, 1000)) this.options.blurSigma = Q;
    else throw H0.invalidParameterError("sigma", "number between 0.3 and 1000", Q);
    return this
  }

  function LE6(A) {
    if (this.options.flatten = H0.bool(A) ? A : !0, H0.object(A)) this._setBackgroundColourOption("flattenBackground", A.background);
    return this
  }

  function ME6() {
    return this.options.unflatten = !0, this
  }

  function OE6(A, Q) {
    if (!H0.defined(A)) this.options.gamma = 2.2;
    else if (H0.number(A) && H0.inRange(A, 1, 3)) this.options.gamma = A;
    else throw H0.invalidParameterError("gamma", "number between 1.0 and 3.0", A);
    if (!H0.defined(Q)) this.options.gammaOut = this.options.gamma;
    else if (H0.number(Q) && H0.inRange(Q, 1, 3)) this.options.gammaOut = Q;
    else throw H0.invalidParameterError("gammaOut", "number between 1.0 and 3.0", Q);
    return this
  }

  function RE6(A) {
    if (this.options.negate = H0.bool(A) ? A : !0, H0.plainObject(A) && "alpha" in A)
      if (!H0.bool(A.alpha)) throw H0.invalidParameterError("alpha", "should be boolean value", A.alpha);
      else this.options.negateAlpha = A.alpha;
    return this
  }

  function TE6(A) {
    if (H0.plainObject(A)) {
      if (H0.defined(A.lower))
        if (H0.number(A.lower) && H0.inRange(A.lower, 0, 99)) this.options.normaliseLower = A.lower;
        else throw H0.invalidParameterError("lower", "number between 0 and 99", A.lower);
      if (H0.defined(A.upper))
        if (H0.number(A.upper) && H0.inRange(A.upper, 1, 100)) this.options.normaliseUpper = A.upper;
        else throw H0.invalidParameterError("upper", "number between 1 and 100", A.upper)
    }
    if (this.options.normaliseLower >= this.options.normaliseUpper) throw H0.invalidParameterError("range", "lower to be less than upper", `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);
    return this.options.normalise = !0, this
  }

  function PE6(A) {
    return this.normalise(A)
  }

  function jE6(A) {
    if (H0.plainObject(A)) {
      if (H0.integer(A.width) && A.width > 0) this.options.claheWidth = A.width;
      else throw H0.invalidParameterError("width", "integer greater than zero", A.width);
      if (H0.integer(A.height) && A.height > 0) this.options.claheHeight = A.height;
      else throw H0.invalidParameterError("height", "integer greater than zero", A.height);
      if (H0.defined(A.maxSlope))
        if (H0.integer(A.maxSlope) && H0.inRange(A.maxSlope, 0, 100)) this.options.claheMaxSlope = A.maxSlope;
        else throw H0.invalidParameterError("maxSlope", "integer between 0 and 100", A.maxSlope)
    } else throw H0.invalidParameterError("options", "plain object", A);
    return this
  }

  function SE6(A) {
    if (!H0.object(A) || !Array.isArray(A.kernel) || !H0.integer(A.width) || !H0.integer(A.height) || !H0.inRange(A.width, 3, 1001) || !H0.inRange(A.height, 3, 1001) || A.height * A.width !== A.kernel.length) throw Error("Invalid convolution kernel");
    if (!H0.integer(A.scale)) A.scale = A.kernel.reduce(function(Q, B) {
      return Q + B
    }, 0);
    if (A.scale < 1) A.scale = 1;
    if (!H0.integer(A.offset)) A.offset = 0;
    return this.options.convKernel = A, this
  }

  function _E6(A, Q) {
    if (!H0.defined(A)) this.options.threshold = 128;
    else if (H0.bool(A)) this.options.threshold = A ? 128 : 0;
    else if (H0.integer(A) && H0.inRange(A, 0, 255)) this.options.threshold = A;
    else throw H0.invalidParameterError("threshold", "integer between 0 and 255", A);
    if (!H0.object(Q) || Q.greyscale === !0 || Q.grayscale === !0) this.options.thresholdGrayscale = !0;
    else this.options.thresholdGrayscale = !1;
    return this
  }

  function kE6(A, Q, B) {
    if (this.options.boolean = this._createInputDescriptor(A, B), H0.string(Q) && H0.inArray(Q, ["and", "or", "eor"])) this.options.booleanOp = Q;
    else throw H0.invalidParameterError("operator", "one of: and, or, eor", Q);
    return this
  }

  function yE6(A, Q) {
    if (!H0.defined(A) && H0.number(Q)) A = 1;
    else if (H0.number(A) && !H0.defined(Q)) Q = 0;
    if (!H0.defined(A)) this.options.linearA = [];
    else if (H0.number(A)) this.options.linearA = [A];
    else if (Array.isArray(A) && A.length && A.every(H0.number)) this.options.linearA = A;
    else throw H0.invalidParameterError("a", "number or array of numbers", A);
    if (!H0.defined(Q)) this.options.linearB = [];
    else if (H0.number(Q)) this.options.linearB = [Q];
    else if (Array.isArray(Q) && Q.length && Q.every(H0.number)) this.options.linearB = Q;
    else throw H0.invalidParameterError("b", "number or array of numbers", Q);
    if (this.options.linearA.length !== this.options.linearB.length) throw Error("Expected a and b to be arrays of the same length");
    return this
  }

  function xE6(A) {
    if (!Array.isArray(A)) throw H0.invalidParameterError("inputMatrix", "array", A);
    if (A.length !== 3 && A.length !== 4) throw H0.invalidParameterError("inputMatrix", "3x3 or 4x4 array", A.length);
    let Q = A.flat().map(Number);
    if (Q.length !== 9 && Q.length !== 16) throw H0.invalidParameterError("inputMatrix", "cardinality of 9 or 16", Q.length);
    return this.options.recombMatrix = Q, this
  }

  function vE6(A) {
    if (!H0.plainObject(A)) throw H0.invalidParameterError("options", "plain object", A);
    if ("brightness" in A)
      if (H0.number(A.brightness) && A.brightness >= 0) this.options.brightness = A.brightness;
      else throw H0.invalidParameterError("brightness", "number above zero", A.brightness);
    if ("saturation" in A)
      if (H0.number(A.saturation) && A.saturation >= 0) this.options.saturation = A.saturation;
      else throw H0.invalidParameterError("saturation", "number above zero", A.saturation);
    if ("hue" in A)
      if (H0.integer(A.hue)) this.options.hue = A.hue % 360;
      else throw H0.invalidParameterError("hue", "number", A.hue);
    if ("lightness" in A)
      if (H0.number(A.lightness)) this.options.lightness = A.lightness;
      else throw H0.invalidParameterError("lightness", "number", A.lightness);
    return this
  }
  iLB.exports = function(A) {
    Object.assign(A.prototype, {
      rotate: EE6,
      flip: zE6,
      flop: UE6,
      affine: $E6,
      sharpen: wE6,
      median: qE6,
      blur: NE6,
      flatten: LE6,
      unflatten: ME6,
      gamma: OE6,
      negate: RE6,
      normalise: TE6,
      normalize: PE6,
      clahe: jE6,
      convolve: SE6,
      threshold: _E6,
      boolean: kE6,
      linear: yE6,
      recomb: xE6,
      modulate: vE6
    })
  }
})
// @from(Start 6568852, End 6570313)
rLB = z((Wr7, sLB) => {
  var bE6 = msA(),
    Gf = b_(),
    aLB = {
      multiband: "multiband",
      "b-w": "b-w",
      bw: "b-w",
      cmyk: "cmyk",
      srgb: "srgb"
    };

  function fE6(A) {
    return this._setBackgroundColourOption("tint", A), this
  }

  function hE6(A) {
    return this.options.greyscale = Gf.bool(A) ? A : !0, this
  }

  function gE6(A) {
    return this.greyscale(A)
  }

  function uE6(A) {
    if (!Gf.string(A)) throw Gf.invalidParameterError("colourspace", "string", A);
    return this.options.colourspacePipeline = A, this
  }

  function mE6(A) {
    return this.pipelineColourspace(A)
  }

  function dE6(A) {
    if (!Gf.string(A)) throw Gf.invalidParameterError("colourspace", "string", A);
    return this.options.colourspace = A, this
  }

  function cE6(A) {
    return this.toColourspace(A)
  }

  function pE6(A, Q) {
    if (Gf.defined(Q))
      if (Gf.object(Q) || Gf.string(Q)) {
        let B = bE6(Q);
        this.options[A] = [B.red(), B.green(), B.blue(), Math.round(B.alpha() * 255)]
      } else throw Gf.invalidParameterError("background", "object or string", Q)
  }
  sLB.exports = function(A) {
    Object.assign(A.prototype, {
      tint: fE6,
      greyscale: hE6,
      grayscale: gE6,
      pipelineColourspace: uE6,
      pipelineColorspace: mE6,
      toColourspace: dE6,
      toColorspace: cE6,
      _setBackgroundColourOption: pE6
    }), A.colourspace = aLB, A.colorspace = aLB
  }
})
// @from(Start 6570319, End 6571786)
tLB = z((Xr7, oLB) => {
  var g_ = b_(),
    lE6 = {
      and: "and",
      or: "or",
      eor: "eor"
    };

  function iE6() {
    return this.options.removeAlpha = !0, this
  }

  function nE6(A) {
    if (g_.defined(A))
      if (g_.number(A) && g_.inRange(A, 0, 1)) this.options.ensureAlpha = A;
      else throw g_.invalidParameterError("alpha", "number between 0 and 1", A);
    else this.options.ensureAlpha = 1;
    return this
  }

  function aE6(A) {
    let Q = {
      red: 0,
      green: 1,
      blue: 2,
      alpha: 3
    };
    if (Object.keys(Q).includes(A)) A = Q[A];
    if (g_.integer(A) && g_.inRange(A, 0, 4)) this.options.extractChannel = A;
    else throw g_.invalidParameterError("channel", "integer or one of: red, green, blue, alpha", A);
    return this
  }

  function sE6(A, Q) {
    if (Array.isArray(A)) A.forEach(function(B) {
      this.options.joinChannelIn.push(this._createInputDescriptor(B, Q))
    }, this);
    else this.options.joinChannelIn.push(this._createInputDescriptor(A, Q));
    return this
  }

  function rE6(A) {
    if (g_.string(A) && g_.inArray(A, ["and", "or", "eor"])) this.options.bandBoolOp = A;
    else throw g_.invalidParameterError("boolOp", "one of: and, or, eor", A);
    return this
  }
  oLB.exports = function(A) {
    Object.assign(A.prototype, {
      removeAlpha: iE6,
      ensureAlpha: nE6,
      extractChannel: aE6,
      joinChannel: sE6,
      bandbool: rE6
    }), A.bool = lE6
  }
})
// @from(Start 6571792, End 6596866)
ZMB = z((Vr7, GMB) => {
  var Zm1 = UA("node:path"),
    I1 = b_(),
    p7A = H$A(),
    eLB = new Map([
      ["heic", "heif"],
      ["heif", "heif"],
      ["avif", "avif"],
      ["jpeg", "jpeg"],
      ["jpg", "jpeg"],
      ["jpe", "jpeg"],
      ["tile", "tile"],
      ["dz", "tile"],
      ["png", "png"],
      ["raw", "raw"],
      ["tiff", "tiff"],
      ["tif", "tiff"],
      ["webp", "webp"],
      ["gif", "gif"],
      ["jp2", "jp2"],
      ["jpx", "jp2"],
      ["j2k", "jp2"],
      ["j2c", "jp2"],
      ["jxl", "jxl"]
    ]),
    oE6 = /\.(jp[2x]|j2[kc])$/i,
    AMB = () => Error("JP2 output requires libvips with support for OpenJPEG"),
    QMB = (A) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(A)));

  function tE6(A, Q) {
    let B;
    if (!I1.string(A)) B = Error("Missing output file path");
    else if (I1.string(this.options.input.file) && Zm1.resolve(this.options.input.file) === Zm1.resolve(A)) B = Error("Cannot use same file for input and output");
    else if (oE6.test(Zm1.extname(A)) && !this.constructor.format.jp2k.output.file) B = AMB();
    if (B)
      if (I1.fn(Q)) Q(B);
      else return Promise.reject(B);
    else {
      this.options.fileOut = A;
      let G = Error();
      return this._pipeline(Q, G)
    }
    return this
  }

  function eE6(A, Q) {
    if (I1.object(A)) this._setBooleanOption("resolveWithObject", A.resolveWithObject);
    else if (this.options.resolveWithObject) this.options.resolveWithObject = !1;
    this.options.fileOut = "";
    let B = Error();
    return this._pipeline(I1.fn(A) ? A : Q, B)
  }

  function Az6() {
    return this.options.keepMetadata |= 1, this
  }

  function Qz6(A) {
    if (I1.object(A))
      for (let [Q, B] of Object.entries(A))
        if (I1.object(B))
          for (let [G, Z] of Object.entries(B))
            if (I1.string(Z)) this.options.withExif[`exif-${Q.toLowerCase()}-${G}`] = Z;
            else throw I1.invalidParameterError(`${Q}.${G}`, "string", Z);
    else throw I1.invalidParameterError(Q, "object", B);
    else throw I1.invalidParameterError("exif", "object", A);
    return this.options.withExifMerge = !1, this.keepExif()
  }

  function Bz6(A) {
    return this.withExif(A), this.options.withExifMerge = !0, this
  }

  function Gz6() {
    return this.options.keepMetadata |= 8, this
  }

  function Zz6(A, Q) {
    if (I1.string(A)) this.options.withIccProfile = A;
    else throw I1.invalidParameterError("icc", "string", A);
    if (this.keepIccProfile(), I1.object(Q)) {
      if (I1.defined(Q.attach))
        if (I1.bool(Q.attach)) {
          if (!Q.attach) this.options.keepMetadata &= -9
        } else throw I1.invalidParameterError("attach", "boolean", Q.attach)
    }
    return this
  }

  function Iz6() {
    return this.options.keepMetadata = 31, this
  }

  function Yz6(A) {
    if (this.keepMetadata(), this.withIccProfile("srgb"), I1.object(A)) {
      if (I1.defined(A.orientation))
        if (I1.integer(A.orientation) && I1.inRange(A.orientation, 1, 8)) this.options.withMetadataOrientation = A.orientation;
        else throw I1.invalidParameterError("orientation", "integer between 1 and 8", A.orientation);
      if (I1.defined(A.density))
        if (I1.number(A.density) && A.density > 0) this.options.withMetadataDensity = A.density;
        else throw I1.invalidParameterError("density", "positive number", A.density);
      if (I1.defined(A.icc)) this.withIccProfile(A.icc);
      if (I1.defined(A.exif)) this.withExifMerge(A.exif)
    }
    return this
  }

  function Jz6(A, Q) {
    let B = eLB.get((I1.object(A) && I1.string(A.id) ? A.id : A).toLowerCase());
    if (!B) throw I1.invalidParameterError("format", `one of: ${[...eLB.keys()].join(", ")}`, A);
    return this[B](Q)
  }

  function Wz6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.quality))
        if (I1.integer(A.quality) && I1.inRange(A.quality, 1, 100)) this.options.jpegQuality = A.quality;
        else throw I1.invalidParameterError("quality", "integer between 1 and 100", A.quality);
      if (I1.defined(A.progressive)) this._setBooleanOption("jpegProgressive", A.progressive);
      if (I1.defined(A.chromaSubsampling))
        if (I1.string(A.chromaSubsampling) && I1.inArray(A.chromaSubsampling, ["4:2:0", "4:4:4"])) this.options.jpegChromaSubsampling = A.chromaSubsampling;
        else throw I1.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", A.chromaSubsampling);
      let Q = I1.bool(A.optimizeCoding) ? A.optimizeCoding : A.optimiseCoding;
      if (I1.defined(Q)) this._setBooleanOption("jpegOptimiseCoding", Q);
      if (I1.defined(A.mozjpeg))
        if (I1.bool(A.mozjpeg)) {
          if (A.mozjpeg) this.options.jpegTrellisQuantisation = !0, this.options.jpegOvershootDeringing = !0, this.options.jpegOptimiseScans = !0, this.options.jpegProgressive = !0, this.options.jpegQuantisationTable = 3
        } else throw I1.invalidParameterError("mozjpeg", "boolean", A.mozjpeg);
      let B = I1.bool(A.trellisQuantization) ? A.trellisQuantization : A.trellisQuantisation;
      if (I1.defined(B)) this._setBooleanOption("jpegTrellisQuantisation", B);
      if (I1.defined(A.overshootDeringing)) this._setBooleanOption("jpegOvershootDeringing", A.overshootDeringing);
      let G = I1.bool(A.optimizeScans) ? A.optimizeScans : A.optimiseScans;
      if (I1.defined(G)) {
        if (this._setBooleanOption("jpegOptimiseScans", G), G) this.options.jpegProgressive = !0
      }
      let Z = I1.number(A.quantizationTable) ? A.quantizationTable : A.quantisationTable;
      if (I1.defined(Z))
        if (I1.integer(Z) && I1.inRange(Z, 0, 8)) this.options.jpegQuantisationTable = Z;
        else throw I1.invalidParameterError("quantisationTable", "integer between 0 and 8", Z)
    }
    return this._updateFormatOut("jpeg", A)
  }

  function Xz6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.progressive)) this._setBooleanOption("pngProgressive", A.progressive);
      if (I1.defined(A.compressionLevel))
        if (I1.integer(A.compressionLevel) && I1.inRange(A.compressionLevel, 0, 9)) this.options.pngCompressionLevel = A.compressionLevel;
        else throw I1.invalidParameterError("compressionLevel", "integer between 0 and 9", A.compressionLevel);
      if (I1.defined(A.adaptiveFiltering)) this._setBooleanOption("pngAdaptiveFiltering", A.adaptiveFiltering);
      let Q = A.colours || A.colors;
      if (I1.defined(Q))
        if (I1.integer(Q) && I1.inRange(Q, 2, 256)) this.options.pngBitdepth = QMB(Q);
        else throw I1.invalidParameterError("colours", "integer between 2 and 256", Q);
      if (I1.defined(A.palette)) this._setBooleanOption("pngPalette", A.palette);
      else if ([A.quality, A.effort, A.colours, A.colors, A.dither].some(I1.defined)) this._setBooleanOption("pngPalette", !0);
      if (this.options.pngPalette) {
        if (I1.defined(A.quality))
          if (I1.integer(A.quality) && I1.inRange(A.quality, 0, 100)) this.options.pngQuality = A.quality;
          else throw I1.invalidParameterError("quality", "integer between 0 and 100", A.quality);
        if (I1.defined(A.effort))
          if (I1.integer(A.effort) && I1.inRange(A.effort, 1, 10)) this.options.pngEffort = A.effort;
          else throw I1.invalidParameterError("effort", "integer between 1 and 10", A.effort);
        if (I1.defined(A.dither))
          if (I1.number(A.dither) && I1.inRange(A.dither, 0, 1)) this.options.pngDither = A.dither;
          else throw I1.invalidParameterError("dither", "number between 0.0 and 1.0", A.dither)
      }
    }
    return this._updateFormatOut("png", A)
  }

  function Vz6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.quality))
        if (I1.integer(A.quality) && I1.inRange(A.quality, 1, 100)) this.options.webpQuality = A.quality;
        else throw I1.invalidParameterError("quality", "integer between 1 and 100", A.quality);
      if (I1.defined(A.alphaQuality))
        if (I1.integer(A.alphaQuality) && I1.inRange(A.alphaQuality, 0, 100)) this.options.webpAlphaQuality = A.alphaQuality;
        else throw I1.invalidParameterError("alphaQuality", "integer between 0 and 100", A.alphaQuality);
      if (I1.defined(A.lossless)) this._setBooleanOption("webpLossless", A.lossless);
      if (I1.defined(A.nearLossless)) this._setBooleanOption("webpNearLossless", A.nearLossless);
      if (I1.defined(A.smartSubsample)) this._setBooleanOption("webpSmartSubsample", A.smartSubsample);
      if (I1.defined(A.preset))
        if (I1.string(A.preset) && I1.inArray(A.preset, ["default", "photo", "picture", "drawing", "icon", "text"])) this.options.webpPreset = A.preset;
        else throw I1.invalidParameterError("preset", "one of: default, photo, picture, drawing, icon, text", A.preset);
      if (I1.defined(A.effort))
        if (I1.integer(A.effort) && I1.inRange(A.effort, 0, 6)) this.options.webpEffort = A.effort;
        else throw I1.invalidParameterError("effort", "integer between 0 and 6", A.effort);
      if (I1.defined(A.minSize)) this._setBooleanOption("webpMinSize", A.minSize);
      if (I1.defined(A.mixed)) this._setBooleanOption("webpMixed", A.mixed)
    }
    return BMB(A, this.options), this._updateFormatOut("webp", A)
  }

  function Fz6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.reuse)) this._setBooleanOption("gifReuse", A.reuse);
      if (I1.defined(A.progressive)) this._setBooleanOption("gifProgressive", A.progressive);
      let Q = A.colours || A.colors;
      if (I1.defined(Q))
        if (I1.integer(Q) && I1.inRange(Q, 2, 256)) this.options.gifBitdepth = QMB(Q);
        else throw I1.invalidParameterError("colours", "integer between 2 and 256", Q);
      if (I1.defined(A.effort))
        if (I1.number(A.effort) && I1.inRange(A.effort, 1, 10)) this.options.gifEffort = A.effort;
        else throw I1.invalidParameterError("effort", "integer between 1 and 10", A.effort);
      if (I1.defined(A.dither))
        if (I1.number(A.dither) && I1.inRange(A.dither, 0, 1)) this.options.gifDither = A.dither;
        else throw I1.invalidParameterError("dither", "number between 0.0 and 1.0", A.dither);
      if (I1.defined(A.interFrameMaxError))
        if (I1.number(A.interFrameMaxError) && I1.inRange(A.interFrameMaxError, 0, 32)) this.options.gifInterFrameMaxError = A.interFrameMaxError;
        else throw I1.invalidParameterError("interFrameMaxError", "number between 0.0 and 32.0", A.interFrameMaxError);
      if (I1.defined(A.interPaletteMaxError))
        if (I1.number(A.interPaletteMaxError) && I1.inRange(A.interPaletteMaxError, 0, 256)) this.options.gifInterPaletteMaxError = A.interPaletteMaxError;
        else throw I1.invalidParameterError("interPaletteMaxError", "number between 0.0 and 256.0", A.interPaletteMaxError)
    }
    return BMB(A, this.options), this._updateFormatOut("gif", A)
  }

  function Kz6(A) {
    if (!this.constructor.format.jp2k.output.buffer) throw AMB();
    if (I1.object(A)) {
      if (I1.defined(A.quality))
        if (I1.integer(A.quality) && I1.inRange(A.quality, 1, 100)) this.options.jp2Quality = A.quality;
        else throw I1.invalidParameterError("quality", "integer between 1 and 100", A.quality);
      if (I1.defined(A.lossless))
        if (I1.bool(A.lossless)) this.options.jp2Lossless = A.lossless;
        else throw I1.invalidParameterError("lossless", "boolean", A.lossless);
      if (I1.defined(A.tileWidth))
        if (I1.integer(A.tileWidth) && I1.inRange(A.tileWidth, 1, 32768)) this.options.jp2TileWidth = A.tileWidth;
        else throw I1.invalidParameterError("tileWidth", "integer between 1 and 32768", A.tileWidth);
      if (I1.defined(A.tileHeight))
        if (I1.integer(A.tileHeight) && I1.inRange(A.tileHeight, 1, 32768)) this.options.jp2TileHeight = A.tileHeight;
        else throw I1.invalidParameterError("tileHeight", "integer between 1 and 32768", A.tileHeight);
      if (I1.defined(A.chromaSubsampling))
        if (I1.string(A.chromaSubsampling) && I1.inArray(A.chromaSubsampling, ["4:2:0", "4:4:4"])) this.options.jp2ChromaSubsampling = A.chromaSubsampling;
        else throw I1.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", A.chromaSubsampling)
    }
    return this._updateFormatOut("jp2", A)
  }

  function BMB(A, Q) {
    if (I1.object(A) && I1.defined(A.loop))
      if (I1.integer(A.loop) && I1.inRange(A.loop, 0, 65535)) Q.loop = A.loop;
      else throw I1.invalidParameterError("loop", "integer between 0 and 65535", A.loop);
    if (I1.object(A) && I1.defined(A.delay))
      if (I1.integer(A.delay) && I1.inRange(A.delay, 0, 65535)) Q.delay = [A.delay];
      else if (Array.isArray(A.delay) && A.delay.every(I1.integer) && A.delay.every((B) => I1.inRange(B, 0, 65535))) Q.delay = A.delay;
    else throw I1.invalidParameterError("delay", "integer or an array of integers between 0 and 65535", A.delay)
  }

  function Dz6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.quality))
        if (I1.integer(A.quality) && I1.inRange(A.quality, 1, 100)) this.options.tiffQuality = A.quality;
        else throw I1.invalidParameterError("quality", "integer between 1 and 100", A.quality);
      if (I1.defined(A.bitdepth))
        if (I1.integer(A.bitdepth) && I1.inArray(A.bitdepth, [1, 2, 4, 8])) this.options.tiffBitdepth = A.bitdepth;
        else throw I1.invalidParameterError("bitdepth", "1, 2, 4 or 8", A.bitdepth);
      if (I1.defined(A.tile)) this._setBooleanOption("tiffTile", A.tile);
      if (I1.defined(A.tileWidth))
        if (I1.integer(A.tileWidth) && A.tileWidth > 0) this.options.tiffTileWidth = A.tileWidth;
        else throw I1.invalidParameterError("tileWidth", "integer greater than zero", A.tileWidth);
      if (I1.defined(A.tileHeight))
        if (I1.integer(A.tileHeight) && A.tileHeight > 0) this.options.tiffTileHeight = A.tileHeight;
        else throw I1.invalidParameterError("tileHeight", "integer greater than zero", A.tileHeight);
      if (I1.defined(A.miniswhite)) this._setBooleanOption("tiffMiniswhite", A.miniswhite);
      if (I1.defined(A.pyramid)) this._setBooleanOption("tiffPyramid", A.pyramid);
      if (I1.defined(A.xres))
        if (I1.number(A.xres) && A.xres > 0) this.options.tiffXres = A.xres;
        else throw I1.invalidParameterError("xres", "number greater than zero", A.xres);
      if (I1.defined(A.yres))
        if (I1.number(A.yres) && A.yres > 0) this.options.tiffYres = A.yres;
        else throw I1.invalidParameterError("yres", "number greater than zero", A.yres);
      if (I1.defined(A.compression))
        if (I1.string(A.compression) && I1.inArray(A.compression, ["none", "jpeg", "deflate", "packbits", "ccittfax4", "lzw", "webp", "zstd", "jp2k"])) this.options.tiffCompression = A.compression;
        else throw I1.invalidParameterError("compression", "one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k", A.compression);
      if (I1.defined(A.predictor))
        if (I1.string(A.predictor) && I1.inArray(A.predictor, ["none", "horizontal", "float"])) this.options.tiffPredictor = A.predictor;
        else throw I1.invalidParameterError("predictor", "one of: none, horizontal, float", A.predictor);
      if (I1.defined(A.resolutionUnit))
        if (I1.string(A.resolutionUnit) && I1.inArray(A.resolutionUnit, ["inch", "cm"])) this.options.tiffResolutionUnit = A.resolutionUnit;
        else throw I1.invalidParameterError("resolutionUnit", "one of: inch, cm", A.resolutionUnit)
    }
    return this._updateFormatOut("tiff", A)
  }

  function Hz6(A) {
    return this.heif({
      ...A,
      compression: "av1"
    })
  }

  function Cz6(A) {
    if (I1.object(A)) {
      if (I1.string(A.compression) && I1.inArray(A.compression, ["av1", "hevc"])) this.options.heifCompression = A.compression;
      else throw I1.invalidParameterError("compression", "one of: av1, hevc", A.compression);
      if (I1.defined(A.quality))
        if (I1.integer(A.quality) && I1.inRange(A.quality, 1, 100)) this.options.heifQuality = A.quality;
        else throw I1.invalidParameterError("quality", "integer between 1 and 100", A.quality);
      if (I1.defined(A.lossless))
        if (I1.bool(A.lossless)) this.options.heifLossless = A.lossless;
        else throw I1.invalidParameterError("lossless", "boolean", A.lossless);
      if (I1.defined(A.effort))
        if (I1.integer(A.effort) && I1.inRange(A.effort, 0, 9)) this.options.heifEffort = A.effort;
        else throw I1.invalidParameterError("effort", "integer between 0 and 9", A.effort);
      if (I1.defined(A.chromaSubsampling))
        if (I1.string(A.chromaSubsampling) && I1.inArray(A.chromaSubsampling, ["4:2:0", "4:4:4"])) this.options.heifChromaSubsampling = A.chromaSubsampling;
        else throw I1.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", A.chromaSubsampling);
      if (I1.defined(A.bitdepth))
        if (I1.integer(A.bitdepth) && I1.inArray(A.bitdepth, [8, 10, 12])) {
          if (A.bitdepth !== 8 && this.constructor.versions.heif) throw I1.invalidParameterError("bitdepth when using prebuilt binaries", 8, A.bitdepth);
          this.options.heifBitdepth = A.bitdepth
        } else throw I1.invalidParameterError("bitdepth", "8, 10 or 12", A.bitdepth)
    } else throw I1.invalidParameterError("options", "Object", A);
    return this._updateFormatOut("heif", A)
  }

  function Ez6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.quality))
        if (I1.integer(A.quality) && I1.inRange(A.quality, 1, 100)) this.options.jxlDistance = A.quality >= 30 ? 0.1 + (100 - A.quality) * 0.09 : 0.017666666666666667 * A.quality * A.quality - 1.15 * A.quality + 25;
        else throw I1.invalidParameterError("quality", "integer between 1 and 100", A.quality);
      else if (I1.defined(A.distance))
        if (I1.number(A.distance) && I1.inRange(A.distance, 0, 15)) this.options.jxlDistance = A.distance;
        else throw I1.invalidParameterError("distance", "number between 0.0 and 15.0", A.distance);
      if (I1.defined(A.decodingTier))
        if (I1.integer(A.decodingTier) && I1.inRange(A.decodingTier, 0, 4)) this.options.jxlDecodingTier = A.decodingTier;
        else throw I1.invalidParameterError("decodingTier", "integer between 0 and 4", A.decodingTier);
      if (I1.defined(A.lossless))
        if (I1.bool(A.lossless)) this.options.jxlLossless = A.lossless;
        else throw I1.invalidParameterError("lossless", "boolean", A.lossless);
      if (I1.defined(A.effort))
        if (I1.integer(A.effort) && I1.inRange(A.effort, 3, 9)) this.options.jxlEffort = A.effort;
        else throw I1.invalidParameterError("effort", "integer between 3 and 9", A.effort)
    }
    return this._updateFormatOut("jxl", A)
  }

  function zz6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.depth))
        if (I1.string(A.depth) && I1.inArray(A.depth, ["char", "uchar", "short", "ushort", "int", "uint", "float", "complex", "double", "dpcomplex"])) this.options.rawDepth = A.depth;
        else throw I1.invalidParameterError("depth", "one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex", A.depth)
    }
    return this._updateFormatOut("raw")
  }

  function Uz6(A) {
    if (I1.object(A)) {
      if (I1.defined(A.size))
        if (I1.integer(A.size) && I1.inRange(A.size, 1, 8192)) this.options.tileSize = A.size;
        else throw I1.invalidParameterError("size", "integer between 1 and 8192", A.size);
      if (I1.defined(A.overlap))
        if (I1.integer(A.overlap) && I1.inRange(A.overlap, 0, 8192)) {
          if (A.overlap > this.options.tileSize) throw I1.invalidParameterError("overlap", `<= size (${this.options.tileSize})`, A.overlap);
          this.options.tileOverlap = A.overlap
        } else throw I1.invalidParameterError("overlap", "integer between 0 and 8192", A.overlap);
      if (I1.defined(A.container))
        if (I1.string(A.container) && I1.inArray(A.container, ["fs", "zip"])) this.options.tileContainer = A.container;
        else throw I1.invalidParameterError("container", "one of: fs, zip", A.container);
      if (I1.defined(A.layout))
        if (I1.string(A.layout) && I1.inArray(A.layout, ["dz", "google", "iiif", "iiif3", "zoomify"])) this.options.tileLayout = A.layout;
        else throw I1.invalidParameterError("layout", "one of: dz, google, iiif, iiif3, zoomify", A.layout);
      if (I1.defined(A.angle))
        if (I1.integer(A.angle) && !(A.angle % 90)) this.options.tileAngle = A.angle;
        else throw I1.invalidParameterError("angle", "positive/negative multiple of 90", A.angle);
      if (this._setBackgroundColourOption("tileBackground", A.background), I1.defined(A.depth))
        if (I1.string(A.depth) && I1.inArray(A.depth, ["onepixel", "onetile", "one"])) this.options.tileDepth = A.depth;
        else throw I1.invalidParameterError("depth", "one of: onepixel, onetile, one", A.depth);
      if (I1.defined(A.skipBlanks))
        if (I1.integer(A.skipBlanks) && I1.inRange(A.skipBlanks, -1, 65535)) this.options.tileSkipBlanks = A.skipBlanks;
        else throw I1.invalidParameterError("skipBlanks", "integer between -1 and 255/65535", A.skipBlanks);
      else if (I1.defined(A.layout) && A.layout === "google") this.options.tileSkipBlanks = 5;
      let Q = I1.bool(A.center) ? A.center : A.centre;
      if (I1.defined(Q)) this._setBooleanOption("tileCentre", Q);
      if (I1.defined(A.id))
        if (I1.string(A.id)) this.options.tileId = A.id;
        else throw I1.invalidParameterError("id", "string", A.id);
      if (I1.defined(A.basename))
        if (I1.string(A.basename)) this.options.tileBasename = A.basename;
        else throw I1.invalidParameterError("basename", "string", A.basename)
    }
    if (I1.inArray(this.options.formatOut, ["jpeg", "png", "webp"])) this.options.tileFormat = this.options.formatOut;
    else if (this.options.formatOut !== "input") throw I1.invalidParameterError("format", "one of: jpeg, png, webp", this.options.formatOut);
    return this._updateFormatOut("dz")
  }

  function $z6(A) {
    if (!I1.plainObject(A)) throw I1.invalidParameterError("options", "object", A);
    if (I1.integer(A.seconds) && I1.inRange(A.seconds, 0, 3600)) this.options.timeoutSeconds = A.seconds;
    else throw I1.invalidParameterError("seconds", "integer between 0 and 3600", A.seconds);
    return this
  }

  function wz6(A, Q) {
    if (!(I1.object(Q) && Q.force === !1)) this.options.formatOut = A;
    return this
  }

  function qz6(A, Q) {
    if (I1.bool(Q)) this.options[A] = Q;
    else throw I1.invalidParameterError(A, "boolean", Q)
  }

  function Nz6() {
    if (!this.options.streamOut) {
      this.options.streamOut = !0;
      let A = Error();
      this._pipeline(void 0, A)
    }
  }

  function Lz6(A, Q) {
    if (typeof A === "function") {
      if (this._isStreamInput()) this.on("finish", () => {
        this._flattenBufferIn(), p7A.pipeline(this.options, (B, G, Z) => {
          if (B) A(I1.nativeError(B, Q));
          else A(null, G, Z)
        })
      });
      else p7A.pipeline(this.options, (B, G, Z) => {
        if (B) A(I1.nativeError(B, Q));
        else A(null, G, Z)
      });
      return this
    } else if (this.options.streamOut) {
      if (this._isStreamInput()) {
        if (this.once("finish", () => {
            this._flattenBufferIn(), p7A.pipeline(this.options, (B, G, Z) => {
              if (B) this.emit("error", I1.nativeError(B, Q));
              else this.emit("info", Z), this.push(G);
              this.push(null), this.on("end", () => this.emit("close"))
            })
          }), this.streamInFinished) this.emit("finish")
      } else p7A.pipeline(this.options, (B, G, Z) => {
        if (B) this.emit("error", I1.nativeError(B, Q));
        else this.emit("info", Z), this.push(G);
        this.push(null), this.on("end", () => this.emit("close"))
      });
      return this
    } else if (this._isStreamInput()) return new Promise((B, G) => {
      this.once("finish", () => {
        this._flattenBufferIn(), p7A.pipeline(this.options, (Z, I, Y) => {
          if (Z) G(I1.nativeError(Z, Q));
          else if (this.options.resolveWithObject) B({
            data: I,
            info: Y
          });
          else B(I)
        })
      })
    });
    else return new Promise((B, G) => {
      p7A.pipeline(this.options, (Z, I, Y) => {
        if (Z) G(I1.nativeError(Z, Q));
        else if (this.options.resolveWithObject) B({
          data: I,
          info: Y
        });
        else B(I)
      })
    })
  }
  GMB.exports = function(A) {
    Object.assign(A.prototype, {
      toFile: tE6,
      toBuffer: eE6,
      keepExif: Az6,
      withExif: Qz6,
      withExifMerge: Bz6,
      keepIccProfile: Gz6,
      withIccProfile: Zz6,
      keepMetadata: Iz6,
      withMetadata: Yz6,
      toFormat: Jz6,
      jpeg: Wz6,
      jp2: Kz6,
      png: Xz6,
      webp: Vz6,
      tiff: Dz6,
      avif: Hz6,
      heif: Cz6,
      jxl: Ez6,
      gif: Fz6,
      raw: zz6,
      tile: Uz6,
      timeout: $z6,
      _updateFormatOut: wz6,
      _setBooleanOption: qz6,
      _read: Nz6,
      _pipeline: Lz6
    })
  }
})
// @from(Start 6596872, End 6599464)
WMB = z((Fr7, JMB) => {
  var Mz6 = UA("node:events"),
    csA = xsA(),
    HM = b_(),
    {
      runtimePlatformArch: Oz6
    } = iu1(),
    GE = H$A(),
    IMB = Oz6(),
    Im1 = GE.libvipsVersion(),
    Hp = GE.format();
  Hp.heif.output.alias = ["avif", "heic"];
  Hp.jpeg.output.alias = ["jpe", "jpg"];
  Hp.tiff.output.alias = ["tif"];
  Hp.jp2k.output.alias = ["j2c", "j2k", "jp2", "jpx"];
  var Rz6 = {
      nearest: "nearest",
      bilinear: "bilinear",
      bicubic: "bicubic",
      locallyBoundedBicubic: "lbb",
      nohalo: "nohalo",
      vertexSplitQuadraticBasisSpline: "vsqbs"
    },
    l7A = {
      vips: Im1.semver
    };
  if (!Im1.isGlobal)
    if (!Im1.isWasm) try {
      l7A = UA(`@img/sharp-${IMB}/versions`)
    } catch (A) {
      try {
        l7A = UA(`@img/sharp-libvips-${IMB}/versions`)
      } catch (Q) {}
    } else try {
      l7A = (() => {
        throw new Error("Cannot require module " + "@img/sharp-wasm32/versions");
      })()
    } catch (A) {}
  l7A.sharp = pu1().version;
  if (l7A.heif && Hp.heif) Hp.heif.input.fileSuffix = [".avif"], Hp.heif.output.alias = ["avif"];

  function YMB(A) {
    if (HM.bool(A))
      if (A) return GE.cache(50, 20, 100);
      else return GE.cache(0, 0, 0);
    else if (HM.object(A)) return GE.cache(A.memory, A.files, A.items);
    else return GE.cache()
  }
  YMB(!0);

  function Tz6(A) {
    return GE.concurrency(HM.integer(A) ? A : null)
  }
  if (csA.familySync() === csA.GLIBC && !GE._isUsingJemalloc()) GE.concurrency(1);
  else if (csA.familySync() === csA.MUSL && GE.concurrency() === 1024) GE.concurrency(UA("node:os").availableParallelism());
  var Pz6 = new Mz6.EventEmitter;

  function jz6() {
    return GE.counters()
  }

  function Sz6(A) {
    return GE.simd(HM.bool(A) ? A : null)
  }

  function _z6(A) {
    if (HM.object(A))
      if (Array.isArray(A.operation) && A.operation.every(HM.string)) GE.block(A.operation, !0);
      else throw HM.invalidParameterError("operation", "Array<string>", A.operation);
    else throw HM.invalidParameterError("options", "object", A)
  }

  function kz6(A) {
    if (HM.object(A))
      if (Array.isArray(A.operation) && A.operation.every(HM.string)) GE.block(A.operation, !1);
      else throw HM.invalidParameterError("operation", "Array<string>", A.operation);
    else throw HM.invalidParameterError("options", "object", A)
  }
  JMB.exports = function(A) {
    A.cache = YMB, A.concurrency = Tz6, A.counters = jz6, A.simd = Sz6, A.format = Hp, A.interpolators = Rz6, A.versions = l7A, A.queue = Pz6, A.block = _z6, A.unblock = kz6
  }
})
// @from(Start 6599470, End 6599637)
psA = z((Dr7, XMB) => {
  var Zf = ELB();
  bLB()(Zf);
  dLB()(Zf);
  pLB()(Zf);
  nLB()(Zf);
  rLB()(Zf);
  tLB()(Zf);
  ZMB()(Zf);
  WMB()(Zf);
  XMB.exports = Zf
})
// @from(Start 6599639, End 6600692)
async function i7A(A, Q, B) {
  try {
    let G = await Promise.resolve().then(() => BA(psA(), 1)),
      I = (G.default || G)(A),
      Y = await I.metadata();
    if (!Y.width || !Y.height) {
      if (Q > $$A) return {
        buffer: await I.jpeg({
          quality: 80
        }).toBuffer(),
        mediaType: "jpeg"
      }
    }
    let J = Y.width || 0,
      W = Y.height || 0,
      X = Y.format ?? B,
      V = X === "jpg" ? "jpeg" : X;
    if (Q <= $$A && J <= lsA && W <= isA) return {
      buffer: A,
      mediaType: V
    };
    if (J > lsA) W = Math.round(W * lsA / J), J = lsA;
    if (W > isA) J = Math.round(J * isA / W), W = isA;
    let F = await I.resize(J, W, {
      fit: "inside",
      withoutEnlargement: !0
    }).toBuffer();
    if (F.length > $$A) return {
      buffer: await I.jpeg({
        quality: 80
      }).toBuffer(),
      mediaType: "jpeg"
    };
    return {
      buffer: F,
      mediaType: V
    }
  } catch (G) {
    return AA(G), {
      buffer: A,
      mediaType: B === "jpg" ? "jpeg" : B
    }
  }
}
// @from(Start 6600693, End 6601067)
async function VMB(A) {
  if (A.source.type !== "base64") return A;
  let Q = Buffer.from(A.source.data, "base64"),
    B = Q.length,
    Z = A.source.media_type?.split("/")[1] || "png",
    I = await i7A(Q, B, Z);
  return {
    type: "image",
    source: {
      type: "base64",
      media_type: `image/${I.mediaType}`,
      data: I.buffer.toString("base64")
    }
  }
}
// @from(Start 6601068, End 6601878)
async function rt(A, Q = $$A, B) {
  let G = B?.split("/")[1] || "jpeg",
    Z = G === "jpg" ? "jpeg" : G;
  try {
    let I = await Promise.resolve().then(() => BA(psA(), 1)),
      Y = I.default || I,
      J = await Y(A).metadata(),
      W = J.format || Z,
      X = A.length,
      V = {
        imageBuffer: A,
        metadata: J,
        format: W,
        maxBytes: Q,
        originalSize: X,
        sharp: Y
      };
    if (X <= Q) return w$A(A, W, X);
    let F = await yz6(V);
    if (F) return F;
    if (W === "png") {
      let D = await vz6(V);
      if (D) return D
    }
    let K = await bz6(V, 50);
    if (K) return K;
    return await fz6(V)
  } catch (I) {
    return AA(I), {
      base64: A.toString("base64"),
      mediaType: `image/${Z}`,
      originalSize: A.length
    }
  }
}
// @from(Start 6601879, End 6601994)
async function FMB(A, Q, B) {
  let G = Math.floor(Q / 0.125),
    Z = Math.floor(G * 0.75);
  return rt(A, Z, B)
}
// @from(Start 6601995, End 6602306)
async function KMB(A, Q = $$A) {
  if (A.source.type !== "base64") return A;
  let B = Buffer.from(A.source.data, "base64");
  if (B.length <= Q) return A;
  let G = await rt(B, Q);
  return {
    type: "image",
    source: {
      type: "base64",
      media_type: G.mediaType,
      data: G.base64
    }
  }
}
// @from(Start 6602308, End 6602467)
function w$A(A, Q, B) {
  let G = Q === "jpg" ? "jpeg" : Q;
  return {
    base64: A.toString("base64"),
    mediaType: `image/${G}`,
    originalSize: B
  }
}
// @from(Start 6602468, End 6602917)
async function yz6(A) {
  let Q = [1, 0.75, 0.5, 0.25];
  for (let B of Q) {
    let G = Math.round((A.metadata.width || 2000) * B),
      Z = Math.round((A.metadata.height || 2000) * B),
      I = A.sharp(A.imageBuffer).resize(G, Z, {
        fit: "inside",
        withoutEnlargement: !0
      });
    I = xz6(I, A.format);
    let Y = await I.toBuffer();
    if (Y.length <= A.maxBytes) return w$A(Y, A.format, A.originalSize)
  }
  return null
}
// @from(Start 6602919, End 6603238)
function xz6(A, Q) {
  switch (Q) {
    case "png":
      return A.png({
        compressionLevel: 9,
        palette: !0
      });
    case "jpeg":
    case "jpg":
      return A.jpeg({
        quality: 80
      });
    case "webp":
      return A.webp({
        quality: 80
      });
    default:
      return A
  }
}
// @from(Start 6603239, End 6603535)
async function vz6(A) {
  let Q = await A.sharp(A.imageBuffer).resize(800, 800, {
    fit: "inside",
    withoutEnlargement: !0
  }).png({
    compressionLevel: 9,
    palette: !0,
    colors: 64
  }).toBuffer();
  if (Q.length <= A.maxBytes) return w$A(Q, "png", A.originalSize);
  return null
}
// @from(Start 6603536, End 6603795)
async function bz6(A, Q) {
  let B = await A.sharp(A.imageBuffer).resize(600, 600, {
    fit: "inside",
    withoutEnlargement: !0
  }).jpeg({
    quality: Q
  }).toBuffer();
  if (B.length <= A.maxBytes) return w$A(B, "jpeg", A.originalSize);
  return null
}
// @from(Start 6603796, End 6604010)
async function fz6(A) {
  let Q = await A.sharp(A.imageBuffer).resize(400, 400, {
    fit: "inside",
    withoutEnlargement: !0
  }).jpeg({
    quality: 20
  }).toBuffer();
  return w$A(Q, "jpeg", A.originalSize)
}
// @from(Start 6604015, End 6604028)
$$A = 3932160
// @from(Start 6604032, End 6604042)
lsA = 2000
// @from(Start 6604046, End 6604056)
isA = 2000
// @from(Start 6604062, End 6604086)
ot = L(() => {
  g1()
})
// @from(Start 6604221, End 6604625)
function mz6() {
  let A = process.platform,
    Q = {
      darwin: "No image found in clipboard. Use Cmd + Ctrl + Shift + 4 to copy a screenshot to clipboard.",
      win32: "No image found in clipboard. Use Print Screen to copy a screenshot to clipboard.",
      linux: "No image found in clipboard. Use appropriate screenshot tool to copy a screenshot to clipboard."
    };
  return Q[A] || Q.linux
}
// @from(Start 6604627, End 6606340)
function DMB() {
  let A = process.platform,
    Q = {
      darwin: "/tmp/claude_cli_latest_screenshot.png",
      linux: "/tmp/claude_cli_latest_screenshot.png",
      win32: process.env.TEMP ? `${process.env.TEMP}\\claude_cli_latest_screenshot.png` : "C:\\Temp\\claude_cli_latest_screenshot.png"
    },
    B = Q[A] || Q.linux,
    G = {
      darwin: {
        checkImage: "osascript -e 'the clipboard as «class PNGf»'",
        saveImage: `osascript -e 'set png_data to (the clipboard as «class PNGf»)' -e 'set fp to open for access POSIX file "${B}" with write permission' -e 'write png_data to fp' -e 'close access fp'`,
        getPath: "osascript -e 'get POSIX path of (the clipboard as «class furl»)'",
        deleteFile: `rm -f "${B}"`
      },
      linux: {
        checkImage: 'xclip -selection clipboard -t TARGETS -o 2>/dev/null | grep -E "image/(png|jpeg|jpg|gif|webp)" || wl-paste -l 2>/dev/null | grep -E "image/(png|jpeg|jpg|gif|webp)"',
        saveImage: `xclip -selection clipboard -t image/png -o > "${B}" 2>/dev/null || wl-paste --type image/png > "${B}"`,
        getPath: "xclip -selection clipboard -t text/plain -o 2>/dev/null || wl-paste 2>/dev/null",
        deleteFile: `rm -f "${B}"`
      },
      win32: {
        checkImage: 'powershell -NoProfile -Command "(Get-Clipboard -Format Image) -ne $null"',
        saveImage: `powershell -NoProfile -Command "$img = Get-Clipboard -Format Image; if ($img) { $img.Save('${B.replace(/\\/g,"\\\\")}', [System.Drawing.Imaging.ImageFormat]::Png) }"`,
        getPath: 'powershell -NoProfile -Command "Get-Clipboard"',
        deleteFile: `del /f "${B}"`
      }
    };
  return {
    commands: G[A] || G.linux,
    screenshotPath: B
  }
}
// @from(Start 6606341, End 6606829)
async function ssA() {
  let {
    commands: A,
    screenshotPath: Q
  } = DMB();
  try {
    nsA(A.checkImage, {
      stdio: "ignore"
    }), nsA(A.saveImage, {
      stdio: "ignore"
    });
    let B = RA().readFileBytesSync(Q),
      {
        buffer: G
      } = await i7A(B, B.length, "png"),
      Z = G.toString("base64"),
      I = CMB(Z);
    return nsA(A.deleteFile, {
      stdio: "ignore"
    }), {
      base64: Z,
      mediaType: I
    }
  } catch {
    return null
  }
}
// @from(Start 6606831, End 6607003)
function dz6() {
  let {
    commands: A
  } = DMB();
  try {
    return nsA(A.getPath, {
      encoding: "utf-8"
    }).trim()
  } catch (Q) {
    return AA(Q), null
  }
}
// @from(Start 6607005, End 6607589)
function CMB(A) {
  try {
    let Q = Buffer.from(A, "base64");
    if (Q.length < 4) return "image/png";
    if (Q[0] === 137 && Q[1] === 80 && Q[2] === 78 && Q[3] === 71) return "image/png";
    if (Q[0] === 255 && Q[1] === 216 && Q[2] === 255) return "image/jpeg";
    if (Q[0] === 71 && Q[1] === 73 && Q[2] === 70) return "image/gif";
    if (Q[0] === 82 && Q[1] === 73 && Q[2] === 70 && Q[3] === 70) {
      if (Q.length >= 12 && Q[8] === 87 && Q[9] === 69 && Q[10] === 66 && Q[11] === 80) return "image/webp"
    }
    return "image/png"
  } catch {
    return "image/png"
  }
}
// @from(Start 6607591, End 6607728)
function EMB(A) {
  if (A.startsWith('"') && A.endsWith('"') || A.startsWith("'") && A.endsWith("'")) return A.slice(1, -1);
  return A
}
// @from(Start 6607730, End 6607918)
function zMB(A) {
  if (process.platform === "win32") return A;
  let B = "__DOUBLE_BACKSLASH__";
  return A.replace(/\\\\/g, B).replace(/\\(.)/g, "$1").replace(new RegExp(B, "g"), "\\")
}
// @from(Start 6607920, End 6608001)
function Ym1(A) {
  let Q = EMB(A.trim()),
    B = zMB(Q);
  return HMB.test(B)
}
// @from(Start 6608003, End 6608106)
function cz6(A) {
  let Q = EMB(A.trim()),
    B = zMB(Q);
  if (HMB.test(B)) return B;
  return null
}
// @from(Start 6608107, End 6608624)
async function UMB(A) {
  let Q = cz6(A);
  if (!Q) return null;
  let B = Q,
    G;
  try {
    if (uz6(B)) G = RA().readFileBytesSync(B);
    else {
      let W = dz6();
      if (W && B === hz6(W)) G = RA().readFileBytesSync(W)
    }
  } catch (W) {
    return AA(W), null
  }
  if (!G) return null;
  let Z = gz6(B).slice(1).toLowerCase() || "png",
    {
      buffer: I
    } = await i7A(G, G.length, Z),
    Y = I.toString("base64"),
    J = CMB(Y);
  return {
    path: B,
    base64: Y,
    mediaType: J
  }
}
// @from(Start 6608629, End 6608632)
qr7
// @from(Start 6608634, End 6608643)
asA = 800
// @from(Start 6608647, End 6608650)
HMB
// @from(Start 6608656, End 6608748)
rsA = L(() => {
  AQ();
  g1();
  ot();
  qr7 = mz6();
  HMB = /\.(png|jpe?g|gif|webp)$/i
})
// @from(Start 6608751, End 6609012)
function osA({
  children: A
}) {
  let {
    marker: Q
  } = Cp.useContext(pz6);
  return Cp.default.createElement(S, {
    gap: 1
  }, Cp.default.createElement($, {
    dimColor: !0
  }, Q), Cp.default.createElement(S, {
    flexDirection: "column"
  }, A))
}
// @from(Start 6609017, End 6609019)
Cp
// @from(Start 6609021, End 6609024)
pz6
// @from(Start 6609030, End 6609121)
$MB = L(() => {
  hA();
  Cp = BA(VA(), 1), pz6 = Cp.createContext({
    marker: ""
  })
})
// @from(Start 6609124, End 6609797)
function qMB({
  children: A
}) {
  let {
    marker: Q
  } = DU.useContext(wMB), B = 0;
  for (let Z of DU.default.Children.toArray(A)) {
    if (!DU.isValidElement(Z) || Z.type !== osA) continue;
    B++
  }
  let G = String(B).length;
  return DU.default.createElement(S, {
    flexDirection: "column"
  }, DU.default.Children.map(A, (Z, I) => {
    if (!DU.isValidElement(Z) || Z.type !== osA) return Z;
    let Y = `${String(I+1).padStart(G)}.`,
      J = `${Q}${Y}`;
    return DU.default.createElement(wMB.Provider, {
      value: {
        marker: J
      }
    }, DU.default.createElement(lz6.Provider, {
      value: {
        marker: J
      }
    }, Z))
  }))
}
// @from(Start 6609802, End 6609804)
DU
// @from(Start 6609806, End 6609809)
wMB
// @from(Start 6609811, End 6609814)
lz6
// @from(Start 6609816, End 6609819)
q$A
// @from(Start 6609825, End 6610002)
Jm1 = L(() => {
  hA();
  $MB();
  DU = BA(VA(), 1), wMB = DU.createContext({
    marker: ""
  }), lz6 = DU.createContext({
    marker: ""
  });
  qMB.Item = osA;
  q$A = qMB
})
// @from(Start 6610043, End 6610179)
function LMB() {
  return Wm1().filter(({
    isCompletable: A,
    isEnabled: Q
  }) => A && Q).every(({
    isComplete: A
  }) => A)
}
// @from(Start 6610181, End 6610322)
function n7A() {
  let A = j5();
  if (LMB() && !A.hasCompletedProjectOnboarding) AY({
    ...A,
    hasCompletedProjectOnboarding: !0
  })
}
// @from(Start 6610324, End 6610744)
function Wm1() {
  let A = RA().existsSync(nz6(W0(), "CLAUDE.md")),
    Q = RMB(W0());
  return [{
    key: "workspace",
    text: "Ask Claude to create a new app or clone a repository",
    isComplete: !1,
    isCompletable: !0,
    isEnabled: Q
  }, {
    key: "claudemd",
    text: "Run /init to create a CLAUDE.md file with instructions for Claude",
    isComplete: A,
    isCompletable: !0,
    isEnabled: !Q
  }]
}
// @from(Start 6610746, End 6610867)
function OMB() {
  let A = j5();
  AY({
    ...A,
    projectOnboardingSeenCount: A.projectOnboardingSeenCount + 1
  })
}
// @from(Start 6610872, End 6610875)
iz6
// @from(Start 6610877, End 6610880)
NMB
// @from(Start 6610882, End 6610885)
MMB
// @from(Start 6610891, End 6611133)
N$A = L(() => {
  Jm1();
  hA();
  jQ();
  R9();
  U2();
  AQ();
  l2();
  iz6 = BA(VA(), 1), NMB = BA(VA(), 1);
  MMB = s1(() => {
    if (LMB() || j5().projectOnboardingSeenCount >= 4 || process.env.IS_DEMO) return !1;
    return !0
  })
})
// @from(Start 6611213, End 6611324)
function rz6(A) {
  let Q = N1();
  Q.appleTerminalSetupInProgress = !0, Q.appleTerminalBackupPath = A, c0(Q)
}
// @from(Start 6611326, End 6611405)
function L$A() {
  let A = N1();
  A.appleTerminalSetupInProgress = !1, c0(A)
}
// @from(Start 6611407, End 6611560)
function oz6() {
  let A = N1();
  return {
    inProgress: A.appleTerminalSetupInProgress ?? !1,
    backupPath: A.appleTerminalBackupPath || null
  }
}
// @from(Start 6611562, End 6611654)
function a7A() {
  return sz6(az6(), "Library", "Preferences", "com.apple.Terminal.plist")
}
// @from(Start 6611655, End 6612049)
async function TMB() {
  let A = a7A(),
    Q = `${A}.bak`;
  try {
    let {
      code: B
    } = await QQ("defaults", ["export", "com.apple.Terminal", A]);
    if (B !== 0) return null;
    if (RA().existsSync(A)) return await QQ("defaults", ["export", "com.apple.Terminal", Q]), rz6(Q), Q;
    return null
  } catch (B) {
    return AA(B instanceof Error ? B : Error(String(B))), null
  }
}
// @from(Start 6612050, End 6612675)
async function tsA() {
  let {
    inProgress: A,
    backupPath: Q
  } = oz6();
  if (!A) return {
    status: "no_backup"
  };
  if (!Q || !RA().existsSync(Q)) return L$A(), {
    status: "no_backup"
  };
  try {
    let {
      code: B
    } = await QQ("defaults", ["import", "com.apple.Terminal", Q]);
    if (B !== 0) return {
      status: "failed",
      backupPath: Q
    };
    return await QQ("killall", ["cfprefsd"]), L$A(), {
      status: "restored"
    }
  } catch (B) {
    return AA(Error(`Failed to restore Terminal.app settings with: ${B}`)), L$A(), {
      status: "failed",
      backupPath: Q
    }
  }
}
// @from(Start 6612680, End 6612729)
Xm1 = L(() => {
  _8();
  g1();
  jQ();
  AQ()
})
// @from(Start 6612809, End 6612906)
function AU6(A) {
  let Q = N1();
  Q.iterm2SetupInProgress = !0, Q.iterm2BackupPath = A, c0(Q)
}
// @from(Start 6612908, End 6612980)
function s7A() {
  let A = N1();
  A.iterm2SetupInProgress = !1, c0(A)
}
// @from(Start 6612982, End 6613121)
function QU6() {
  let A = N1();
  return {
    inProgress: A.iterm2SetupInProgress ?? !1,
    backupPath: A.iterm2BackupPath || null
  }
}
// @from(Start 6613123, End 6613218)
function esA() {
  return ez6(tz6(), "Library", "Preferences", "com.googlecode.iterm2.plist")
}
// @from(Start 6613219, End 6613520)
async function PMB() {
  let A = esA(),
    Q = `${A}.bak`;
  try {
    if (await QQ("defaults", ["export", "com.googlecode.iterm2", A]), RA().existsSync(A)) return RA().copyFileSync(A, Q), AU6(Q), Q;
    return null
  } catch (B) {
    return AA(B instanceof Error ? B : Error(String(B))), null
  }
}
// @from(Start 6613522, End 6613961)
function jMB() {
  let {
    inProgress: A,
    backupPath: Q
  } = QU6();
  if (!A) return {
    status: "no_backup"
  };
  if (!Q || !RA().existsSync(Q)) return s7A(), {
    status: "no_backup"
  };
  try {
    return RA().copyFileSync(Q, esA()), s7A(), {
      status: "restored"
    }
  } catch (B) {
    return AA(Error(`Failed to restore iTerm2 settings with: ${B}`)), s7A(), {
      status: "failed",
      backupPath: Q
    }
  }
}
// @from(Start 6613966, End 6614015)
Vm1 = L(() => {
  _8();
  g1();
  jQ();
  AQ()
})
// @from(Start 6614191, End 6614450)
function M$A() {
  return QrA() === "darwin" && (d0.terminal === "iTerm.app" || d0.terminal === "Apple_Terminal") || d0.terminal === "vscode" || d0.terminal === "cursor" || d0.terminal === "windsurf" || d0.terminal === "ghostty" || d0.terminal === "WezTerm"
}
// @from(Start 6614451, End 6615227)
async function Dm1(A) {
  let Q = "";
  switch (d0.terminal) {
    case "iTerm.app":
      Q = await YU6(A);
      break;
    case "Apple_Terminal":
      Q = await JU6(A);
      break;
    case "vscode":
      Q = Fm1("VSCode", A);
      break;
    case "cursor":
      Q = Fm1("Cursor", A);
      break;
    case "windsurf":
      Q = Fm1("Windsurf", A);
      break;
    case "ghostty":
      Q = await IU6(A);
      break;
    case "WezTerm":
      Q = await ZU6(A);
      break;
    case null:
      break
  }
  let B = N1();
  if (["iTerm.app", "vscode", "cursor", "windsurf", "ghostty", "WezTerm"].includes(d0.terminal ?? "")) B.shiftEnterKeyBindingInstalled = !0;
  else if (d0.terminal === "Apple_Terminal") B.optionAsMetaKeyInstalled = !0;
  return c0(B), n7A(), Q
}
// @from(Start 6615229, End 6615298)
function kMB() {
  return N1().shiftEnterKeyBindingInstalled === !0
}
// @from(Start 6615300, End 6615364)
function yMB() {
  return N1().optionAsMetaKeyInstalled === !0
}
// @from(Start 6615366, End 6615428)
function xMB() {
  return N1().hasUsedBackslashReturn === !0
}
// @from(Start 6615430, End 6615548)
function vMB() {
  let A = N1();
  if (!A.hasUsedBackslashReturn) c0({
    ...A,
    hasUsedBackslashReturn: !0
  })
}
// @from(Start 6615549, End 6617624)
async function ZU6(A) {
  let B = If(ArA(), ".wezterm.lua");
  try {
    let G = "",
      Z = !1;
    if (RA().existsSync(B)) {
      if (Z = !0, G = RA().readFileSync(B, {
          encoding: "utf-8"
        }), G.includes('mods="SHIFT"') && G.includes('key="Enter"')) return `${ZB("warning",A)("Found existing WezTerm Shift+Enter key binding. Remove it to continue.")}${m7}${tA.dim(`See ${B}`)}${m7}`;
      let I = Km1(4).toString("hex"),
        Y = `${B}.${I}.bak`;
      try {
        RA().copyFileSync(B, Y)
      } catch (J) {
        return AA(J instanceof Error ? J : Error(String(J))), `${ZB("warning",A)("Error backing up existing WezTerm config. Bailing out.")}${m7}${tA.dim(`See ${B}`)}${m7}${tA.dim(`Backup path: ${Y}`)}${m7}`
      }
    }
    if (!Z) G = `local wezterm = require 'wezterm'
local config = wezterm.config_builder()

config.keys = {
  {key="Enter", mods="SHIFT", action=wezterm.action{SendString="\\x1b\\r"}},
}

return config
`;
    else {
      let I = G.match(/config\.keys\s*=\s*\{([^}]*)\}/s);
      if (I) {
        let Y = I[1] ?? "",
          J = Y.trim() ? `${Y.trim()},
  {key="Enter", mods="SHIFT", action=wezterm.action{SendString="\\x1b\\r"}},` : `
  {key="Enter", mods="SHIFT", action=wezterm.action{SendString="\\x1b\\r"}},
`;
        G = G.replace(/config\.keys\s*=\s*\{[^}]*\}/s, `config.keys = {${J}}`)
      } else if (G.match(/return\s+config/s)) G = G.replace(/return\s+config/s, `config.keys = {
  {key="Enter", mods="SHIFT", action=wezterm.action{SendString="\\x1b\\r"}},
}

return config`);
      else G += `
config.keys = {
  {key="Enter", mods="SHIFT", action=wezterm.action{SendString="\\x1b\\r"}},
}
`
    }
    return RA().writeFileSync(B, G, {
      encoding: "utf-8",
      flush: !1
    }), `${ZB("success",A)("Installed WezTerm Shift+Enter key binding")}${m7}${ZB("success",A)("You may need to restart WezTerm for changes to take effect")}${m7}${tA.dim(`See ${B}`)}${m7}`
  } catch (G) {
    throw AA(G instanceof Error ? G : Error(String(G))), Error("Failed to install WezTerm Shift+Enter key binding")
  }
}
// @from(Start 6617625, End 6619299)
async function IU6(A) {
  let B = [],
    G = process.env.XDG_CONFIG_HOME;
  if (G) B.push(If(G, "ghostty", "config"));
  else B.push(If(ArA(), ".config", "ghostty", "config"));
  if (QrA() === "darwin") B.push(If(ArA(), "Library", "Application Support", "com.mitchellh.ghostty", "config"));
  let Z = null,
    I = !1;
  for (let Y of B)
    if (RA().existsSync(Y)) {
      Z = Y, I = !0;
      break
    } if (!Z) Z = B[0] ?? null, I = !1;
  if (!Z) throw Error("No valid config path found for Ghostty");
  try {
    let Y = "";
    if (I) {
      if (Y = RA().readFileSync(Z, {
          encoding: "utf-8"
        }), Y.includes("shift+enter")) return `${ZB("warning",A)("Found existing Ghostty Shift+Enter key binding. Remove it to continue.")}${m7}${tA.dim(`See ${Z}`)}${m7}`;
      let W = Km1(4).toString("hex"),
        X = `${Z}.${W}.bak`;
      try {
        RA().copyFileSync(Z, X)
      } catch {
        return `${ZB("warning",A)("Error backing up existing Ghostty config. Bailing out.")}${m7}${tA.dim(`See ${Z}`)}${m7}${tA.dim(`Backup path: ${X}`)}${m7}`
      }
    } else {
      let W = BU6(Z);
      if (!RA().existsSync(W)) RA().mkdirSync(W)
    }
    let J = Y;
    if (Y && !Y.endsWith(`
`)) J += `
`;
    return J += `keybind = shift+enter=text:\\x1b\\r
`, RA().writeFileSync(Z, J, {
      encoding: "utf-8",
      flush: !1
    }), `${ZB("success",A)("Installed Ghostty Shift+Enter key binding")}${m7}${ZB("success",A)("You may need to restart Ghostty for changes to take effect")}${m7}${tA.dim(`See ${Z}`)}${m7}`
  } catch (Y) {
    throw AA(Y instanceof Error ? Y : Error(String(Y))), Error("Failed to install Ghostty Shift+Enter key binding")
  }
}
// @from(Start 6619300, End 6620785)
async function YU6(A) {
  let Q = esA();
  try {
    if (!await PMB()) throw Error("Failed to create backup of iTerm2 preferences, bailing out");
    let {
      code: G
    } = await QQ("defaults", ["write", "com.googlecode.iterm2", "GlobalKeyMap", "-dict-add", "0xd-0x20000-0x24", `<dict>
        <key>Text</key>
        <string>\\n</string>
        <key>Action</key>
        <integer>12</integer>
        <key>Version</key>
        <integer>1</integer>
        <key>Keycode</key>
        <integer>13</integer>
        <key>Modifiers</key>
        <integer>131072</integer>
      </dict>`]);
    if (G !== 0) throw Error("Failed to install iTerm2 Shift+Enter key binding");
    return await QQ("defaults", ["export", "com.googlecode.iterm2", Q]), s7A(), `${ZB("success",A)("Installed iTerm2 Shift+Enter key binding")}${m7}${tA.dim("See iTerm2 → Preferences → Keys")}${m7}`
  } catch (B) {
    AA(B instanceof Error ? B : Error(String(B)));
    let G = N1().iterm2BackupPath,
      Z = !1;
    if (G && RA().existsSync(G)) try {
      await QQ("defaults", ["import", "com.googlecode.iterm2", G]), Z = !0, s7A()
    } catch (I) {
      AA(Error(`Failed to restore from backup: ${String(I)}`))
    }
    throw Error(`Failed to install iTerm2 Shift+Enter key binding. ${Z?"Your settings have been restored from backup.":G&&RA().existsSync(G)?`Restoring from backup failed, try manually with: defaults import com.googlecode.iterm2 ${G}`:"No backup was available to restore from."}`)
  }
}
// @from(Start 6620787, End 6622379)
function Fm1(A = "VSCode", Q) {
  let B = A === "VSCode" ? "Code" : A,
    G = If(ArA(), QrA() === "win32" ? If("AppData", "Roaming", B, "User") : QrA() === "darwin" ? If("Library", "Application Support", B, "User") : If(".config", B, "User")),
    Z = If(G, "keybindings.json");
  try {
    let I = "[]",
      Y = [];
    if (!RA().existsSync(G)) RA().mkdirSync(G);
    if (RA().existsSync(Z)) {
      I = RA().readFileSync(Z, {
        encoding: "utf-8"
      }), Y = Pr0(I) ?? [];
      let V = Km1(4).toString("hex"),
        F = `${Z}.${V}.bak`;
      try {
        RA().copyFileSync(Z, F)
      } catch {
        return `${ZB("warning",Q)(`Error backing up existing ${A} terminal keybindings. Bailing out.`)}${m7}${tA.dim(`See ${Z}`)}${m7}${tA.dim(`Backup path: ${F}`)}${m7}`
      }
    }
    if (Y.find((V) => V.key === "shift+enter" && V.command === "workbench.action.terminal.sendSequence" && V.when === "terminalFocus")) return `${ZB("warning",Q)(`Found existing ${A} terminal Shift+Enter key binding. Remove it to continue.`)}${m7}${tA.dim(`See ${Z}`)}${m7}`;
    let X = jr0(I, {
      key: "shift+enter",
      command: "workbench.action.terminal.sendSequence",
      args: {
        text: "\x1B\r"
      },
      when: "terminalFocus"
    });
    return RA().writeFileSync(Z, X, {
      encoding: "utf-8",
      flush: !1
    }), `${ZB("success",Q)(`Installed ${A} terminal Shift+Enter key binding`)}${m7}${tA.dim(`See ${Z}`)}${m7}`
  } catch (I) {
    throw AA(I instanceof Error ? I : Error(String(I))), Error(`Failed to install ${A} terminal Shift+Enter key binding`)
  }
}
// @from(Start 6622380, End 6622827)
async function SMB(A) {
  let {
    code: Q
  } = await QQ("/usr/libexec/PlistBuddy", ["-c", `Add :'Window Settings':'${A}':useOptionAsMetaKey bool true`, a7A()]);
  if (Q !== 0) {
    let {
      code: B
    } = await QQ("/usr/libexec/PlistBuddy", ["-c", `Set :'Window Settings':'${A}':useOptionAsMetaKey true`, a7A()]);
    if (B !== 0) return AA(Error(`Failed to enable Option as Meta key for Terminal.app profile: ${A}`)), !1
  }
  return !0
}
// @from(Start 6622828, End 6623242)
async function _MB(A) {
  let {
    code: Q
  } = await QQ("/usr/libexec/PlistBuddy", ["-c", `Add :'Window Settings':'${A}':Bell bool false`, a7A()]);
  if (Q !== 0) {
    let {
      code: B
    } = await QQ("/usr/libexec/PlistBuddy", ["-c", `Set :'Window Settings':'${A}':Bell false`, a7A()]);
    if (B !== 0) return AA(Error(`Failed to disable audio bell for Terminal.app profile: ${A}`)), !1
  }
  return !0
}
// @from(Start 6623243, End 6625020)
async function JU6(A) {
  try {
    if (!await TMB()) throw Error("Failed to create backup of Terminal.app preferences, bailing out");
    let {
      stdout: B,
      code: G
    } = await QQ("defaults", ["read", "com.apple.Terminal", "Default Window Settings"]);
    if (G !== 0 || !B.trim()) throw Error("Failed to read default Terminal.app profile");
    let {
      stdout: Z,
      code: I
    } = await QQ("defaults", ["read", "com.apple.Terminal", "Startup Window Settings"]);
    if (I !== 0 || !Z.trim()) throw Error("Failed to read startup Terminal.app profile");
    let Y = !1,
      J = B.trim(),
      W = await SMB(J),
      X = await _MB(J);
    if (W || X) Y = !0;
    let V = Z.trim();
    if (V !== J) {
      let F = await SMB(V),
        K = await _MB(V);
      if (F || K) Y = !0
    }
    if (!Y) throw Error("Failed to enable Option as Meta key or disable audio bell for any Terminal.app profile");
    return await QQ("killall", ["cfprefsd"]), L$A(), `${ZB("success",A)("Configured Terminal.app settings:")}${m7}${ZB("success",A)('- Enabled "Use Option as Meta key"')}${m7}${ZB("success",A)("- Switched to visual bell")}${m7}${tA.dim("Option+Enter will now enter a newline.")}${m7}${tA.dim("You must restart Terminal.app for changes to take effect.",A)}${m7}`
  } catch (Q) {
    AA(Q instanceof Error ? Q : Error(String(Q)));
    let B = await tsA(),
      G = "Failed to enable Option as Meta key for Terminal.app.";
    if (B.status === "restored") throw Error(`${G} Your settings have been restored from backup.`);
    else if (B.status === "failed") throw Error(`${G} Restoring from backup failed, try manually with: defaults import com.apple.Terminal ${B.backupPath}`);
    else throw Error(`${G} No backup was available to restore from.`)
  }
}
// @from(Start 6625025, End 6625028)
GU6
// @from(Start 6625030, End 6625032)
Ep
// @from(Start 6625038, End 6626352)
r7A = L(() => {
  F9();
  N$A();
  Xm1();
  jQ();
  c5();
  _8();
  AQ();
  Vm1();
  LF();
  g1();
  hA();
  Q3();
  GU6 = {
    type: "local-jsx",
    name: "terminal-setup",
    userFacingName() {
      return "terminal-setup"
    },
    description: d0.terminal === "Apple_Terminal" ? "Enable Option+Enter key binding for newlines and visual bell" : "Install Shift+Enter key binding for newlines",
    isEnabled: () => !0,
    isHidden: !1,
    async call(A, Q) {
      if (!M$A()) {
        let G = d0.terminal || "your current terminal",
          Z = dQ(),
          I = "";
        if (Z === "macos") I = `   • macOS: iTerm2, Apple Terminal
`;
        else if (Z === "windows") I = `   • Windows: Windows Terminal
`;
        let Y = `Terminal setup cannot be run from ${G}.

This command configures a convenient Shift+Enter shortcut for multi-line prompts.
${tA.dim("Note: You can already use backslash (\\) + return to add newlines.")}

To set up the shortcut (optional):
1. Exit tmux/screen temporarily
2. Run /terminal-setup directly in one of these terminals:
${I}   • IDE: VSCode, Cursor, Windsurf
   • Other: Ghostty, WezTerm
3. Return to tmux/screen - settings will persist`;
        return A(Y), null
      }
      let B = await Dm1(Q.options.theme);
      return A(B), null
    }
  };
  Ep = GU6
})
// @from(Start 6626393, End 6626459)
function GrA(A) {
  return (A.match(/\r\n|\r|\n/g) || []).length
}
// @from(Start 6626461, End 6626571)
function gMB(A, Q) {
  if (Q === 0) return `[Pasted text #${A}]`;
  return `[Pasted text #${A} +${Q} lines]`
}
// @from(Start 6626573, End 6626617)
function uMB(A) {
  return `[Image #${A}]`
}
// @from(Start 6626619, End 6626845)
function mMB(A) {
  let Q = /\[(Pasted text|Image|\.\.\.Truncated text) #(\d+)(?: \+\d+ lines)?(\.)*\]/g;
  return [...A.matchAll(Q)].map((G) => ({
    id: parseInt(G[2] || "0"),
    match: G[0]
  })).filter((G) => G.id > 0)
}
// @from(Start 6626847, End 6626889)
function VU6(A) {
  return JSON.parse(A)
}
// @from(Start 6626890, End 6627161)
async function* ZrA() {
  for (let B = Yf.length - 1; B >= 0; B--) yield Yf[B];
  let A = fMB(MQ(), "history.jsonl");
  if (!RA().existsSync(A)) return;
  for await (let B of fH0(A)) try {
    yield VU6(B)
  } catch (G) {
    g(`Failed to parse history line: ${G}`)
  }
}
// @from(Start 6627162, End 6627308)
async function* Cm1() {
  let A = uQ(),
    Q = 0;
  for await (let B of ZrA()) if (B.project === A) {
    if (yield B, Q++, Q >= WU6) break
  }
}
// @from(Start 6627309, End 6627898)
async function dMB() {
  if (Yf.length === 0) return;
  let A;
  try {
    let Q = fMB(MQ(), "history.jsonl"),
      B = RA();
    if (!B.existsSync(Q)) B.writeFileSync(Q, "", {
      encoding: "utf8",
      flush: !0,
      mode: 384
    });
    A = await hMB.lock(Q, {
      stale: 1e4,
      retries: {
        retries: 3,
        minTimeout: 50
      }
    });
    let G = Yf.map((Z) => JSON.stringify(Z) + `
`);
    Yf = [], B.appendFileSync(Q, G.join(""), {
      mode: 384
    })
  } catch (Q) {
    g(`Failed to write prompt history: ${Q}`)
  } finally {
    if (A) await A()
  }
}
// @from(Start 6627899, End 6628127)
async function cMB(A) {
  if (Hm1 || Yf.length === 0) return;
  if (A > 5) return;
  Hm1 = !0;
  try {
    await dMB()
  } finally {
    if (Hm1 = !1, Yf.length > 0) await new Promise((Q) => setTimeout(Q, 500)), cMB(A + 1)
  }
}
// @from(Start 6628128, End 6628559)
async function FU6(A) {
  let Q = typeof A === "string" ? {
      display: A,
      pastedContents: {}
    } : A,
    B = {};
  if (Q.pastedContents) {
    for (let [Z, I] of Object.entries(Q.pastedContents))
      if (I.type !== "image" && I.content.length <= XU6) B[Number(Z)] = I
  }
  let G = {
    ...Q,
    pastedContents: B,
    timestamp: Date.now(),
    project: uQ(),
    sessionId: e1()
  };
  Yf.push(G), BrA = cMB(0)
}
// @from(Start 6628561, End 6628692)
function Jf(A) {
  if (!bMB) bMB = !0, PG(async () => {
    if (BrA) await BrA;
    if (Yf.length > 0) await dMB()
  });
  FU6(A)
}
// @from(Start 6628697, End 6628700)
hMB
// @from(Start 6628702, End 6628711)
WU6 = 100
// @from(Start 6628715, End 6628725)
XU6 = 1024
// @from(Start 6628729, End 6628731)
Yf
// @from(Start 6628733, End 6628741)
Hm1 = !1
// @from(Start 6628745, End 6628755)
BrA = null
// @from(Start 6628759, End 6628767)
bMB = !1
// @from(Start 6628773, End 6628862)
zp = L(() => {
  hQ();
  AQ();
  _0();
  V0();
  HH();
  hMB = BA(T4A(), 1);
  Yf = []
})
// @from(Start 6628868, End 6628871)
Em1
// @from(Start 6628873, End 6628876)
KU6
// @from(Start 6628878, End 6628880)
HU
// @from(Start 6628882, End 6628884)
tt
// @from(Start 6628890, End 6629492)
Up = L(() => {
  Q3();
  Em1 = BA(KU(), 1), KU6 = dQ() !== "windows" || (ms() ? Em1.default.satisfies(process.versions.bun, ">=1.2.23") : Em1.default.satisfies(process.versions.node, ">=22.17.0 <23.0.0 || >=24.2.0")), HU = !KU6 ? {
    displayText: "alt+m",
    check: (A, Q) => Q.meta && (A === "m" || A === "M")
  } : {
    displayText: "shift+tab",
    check: (A, Q) => Q.tab && Q.shift
  }, tt = dQ() === "windows" ? {
    displayText: "alt+v",
    check: (A, Q) => Q.meta && (A === "v" || A === "V")
  } : {
    displayText: "ctrl+v",
    check: (A, Q) => Q.ctrl && (A === "v" || A === "V")
  }
})
// @from(Start 6629495, End 6629695)
function pMB(A, Q) {
  switch (Q) {
    case "bash":
      return `!${A}`;
    case "memorySelect":
      return `#${A}`;
    case "background":
      return `&${A}`;
    default:
      return A
  }
}
// @from(Start 6629697, End 6629886)
function Wf(A) {
  if (A.startsWith("!")) return "bash";
  if (A.startsWith("#")) return "memory";
  if (A.startsWith("&") && o2("tengu_web_tasks")) return "background";
  return "prompt"
}
// @from(Start 6629888, End 6629962)
function et(A) {
  if (Wf(A) === "prompt") return A;
  return A.slice(1)
}
// @from(Start 6629964, End 6630053)
function lMB(A) {
  return A === "!" || A === "#" || o2("tengu_web_tasks") && A === "&"
}
// @from(Start 6630058, End 6630083)
o7A = L(() => {
  u2()
})
// @from(Start 6630086, End 6630163)
function $p(A) {
  return A.filter((Q) => Q.data?.type !== "hook_progress")
}
// @from(Start 6630168, End 6630352)
ZE = () => ({
  mode: "default",
  additionalWorkingDirectories: new Map,
  alwaysAllowRules: {},
  alwaysDenyRules: {},
  alwaysAskRules: {},
  isBypassPermissionsModeAvailable: !1
})
// @from(Start 6630355, End 6630505)
function t7A(A) {
  let Q = IrA.useCallback((B) => {
    e7A();
    let G = l0();
    A(B, G)
  }, [A]);
  IrA.useEffect(() => fm.subscribe(Q), [Q])
}
// @from(Start 6630510, End 6630513)
IrA
// @from(Start 6630519, End 6630574)
YrA = L(() => {
  qKA();
  MB();
  IrA = BA(VA(), 1)
})
// @from(Start 6630577, End 6630706)
function WrA(A) {
  let Q = A.toLowerCase();
  return Q === "ultrathink" || Q === "think ultra hard" || Q === "think ultrahard"
}
// @from(Start 6630708, End 6630785)
function O$A(A, Q = !1) {
  let B = Q ? HU6 : DU6;
  return B[A % B.length]
}
// @from(Start 6630787, End 6631176)
function nMB(A, Q) {
  let B = [],
    G = 0;
  for (let Z of Q) {
    if (Z.start > G) B.push({
      text: A.slice(G, Z.start),
      isTrigger: !1,
      start: G
    });
    B.push({
      text: A.slice(Z.start, Z.end),
      isTrigger: !0,
      start: Z.start
    }), G = Z.end
  }
  if (G < A.length) B.push({
    text: A.slice(G),
    isTrigger: !1,
    start: G
  });
  return B
}
// @from(Start 6631178, End 6631491)
function Xf(A, Q) {
  if (process.env.MAX_THINKING_TOKENS) {
    let B = parseInt(process.env.MAX_THINKING_TOKENS, 10);
    if (B > 0) GA("tengu_thinking", {
      provider: _R(),
      tokenCount: B
    });
    return B
  }
  return Math.max(...A.filter((B) => B.type === "user" && !B.isMeta).map(zU6), Q ?? 0)
}
// @from(Start 6631493, End 6631555)
function EU6(A) {
  return A === "high" ? zm1.ULTRATHINK : 0
}
// @from(Start 6631557, End 6631994)
function zU6(A) {
  if (A.isMeta) return 0;
  if (A.thinkingMetadata) {
    let {
      level: G,
      disabled: Z
    } = A.thinkingMetadata;
    if (Z) return 0;
    let I = EU6(G);
    if (I > 0) GA("tengu_thinking", {
      provider: _R(),
      tokenCount: I
    });
    return I
  }
  let Q = UU6(A),
    {
      tokens: B
    } = Ae(Q);
  if (B > 0) GA("tengu_thinking", {
    provider: _R(),
    tokenCount: B
  });
  return B
}
// @from(Start 6631996, End 6632166)
function UU6(A) {
  if (typeof A.message.content === "string") return A.message.content;
  return A.message.content.map((Q) => Q.type === "text" ? Q.text : "").join("")
}
// @from(Start 6632168, End 6632312)
function Ae(A) {
  let Q = /\bultrathink\b/i.test(A);
  return {
    tokens: Q ? zm1.ULTRATHINK : zm1.NONE,
    level: Q ? "high" : "none"
  }
}
// @from(Start 6632314, End 6632520)
function XrA(A) {
  let Q = [],
    B = A.matchAll(CU6);
  for (let G of B)
    if (G.index !== void 0) Q.push({
      word: G[0],
      start: G.index,
      end: G.index + G[0].length
    });
  return Q
}
// @from(Start 6632522, End 6632888)
function VrA() {
  if (process.env.MAX_THINKING_TOKENS) return parseInt(process.env.MAX_THINKING_TOKENS, 10) > 0;
  let Q = l0().alwaysThinkingEnabled;
  if (Q === !0 || Q === !1) return Q;
  let B = k3();
  if (B.includes("claude-sonnet-4-5")) return !0;
  if (B.includes("claude-opus-4-5")) return BZ("tengu_deep_ocean_current", "on_by_default", !1);
  return !1
}
// @from(Start 6632893, End 6632896)
JrA
// @from(Start 6632898, End 6632901)
iMB
// @from(Start 6632903, End 6632906)
DU6
// @from(Start 6632908, End 6632911)
HU6
// @from(Start 6632913, End 6632916)
zm1
// @from(Start 6632918, End 6632921)
CU6
// @from(Start 6632927, End 6633495)
CU = L(() => {
  q0();
  u2();
  lK();
  MB();
  t2();
  JrA = {
    none: "text",
    high: "claude"
  }, iMB = {
    none: "promptBorderShimmer",
    high: "claudeShimmer"
  }, DU6 = ["rainbow_red", "rainbow_orange", "rainbow_yellow", "rainbow_green", "rainbow_blue", "rainbow_indigo", "rainbow_violet"], HU6 = ["rainbow_red_shimmer", "rainbow_orange_shimmer", "rainbow_yellow_shimmer", "rainbow_green_shimmer", "rainbow_blue_shimmer", "rainbow_indigo_shimmer", "rainbow_violet_shimmer"];
  zm1 = {
    ULTRATHINK: 31999,
    NONE: 0
  }, CU6 = /\bultrathink\b/gi
})
// @from(Start 6633498, End 6634642)
function wp() {
  return {
    settings: $T(),
    backgroundTasks: {},
    verbose: !1,
    mainLoopModel: null,
    mainLoopModelForSession: null,
    statusLineText: void 0,
    showExpandedTodos: !1,
    toolPermissionContext: ZE(),
    agentDefinitions: {
      activeAgents: [],
      allAgents: []
    },
    fileHistory: {
      snapshots: [],
      trackedFiles: new Set
    },
    mcp: {
      clients: [],
      tools: [],
      commands: [],
      resources: {}
    },
    plugins: {
      enabled: [],
      disabled: [],
      commands: [],
      agents: [],
      errors: [],
      installationStatus: {
        marketplaces: [],
        plugins: []
      }
    },
    todos: {},
    notifications: {
      current: null,
      queue: []
    },
    elicitation: {
      queue: []
    },
    thinkingEnabled: VrA(),
    feedbackSurvey: {
      timeLastShown: null,
      submitCountAtLastAppearance: null
    },
    sessionHooks: {},
    promptSuggestion: {
      text: null,
      shownAt: 0
    },
    queuedCommands: [],
    gitDiff: {
      stats: null,
      hunks: new Map,
      lastUpdated: 0,
      version: 0
    }
  }
}
// @from(Start 6634644, End 6635672)
function yG({
  children: A,
  initialState: Q,
  onChangeAppState: B
}) {
  if (IE.useContext(aMB)) throw Error("AppStateProvider can not be nested within another AppStateProvider");
  let [Z, I] = IE.useState({
    currentState: Q ?? wp(),
    previousState: null
  }), Y = IE.useCallback((W) => {
    I(({
      currentState: X
    }) => {
      let V = {
        currentState: W(X),
        previousState: X
      };
      return B?.({
        newState: V.currentState,
        oldState: V.previousState
      }), V
    })
  }, [B]), J = IE.useMemo(() => {
    let W = [Z.currentState, Y];
    return W.__IS_INITIALIZED__ = !0, W
  }, [Z.currentState, Y]);
  return t7A(IE.useCallback((W, X) => {
    g(`Settings changed from ${W}, updating AppState`);
    let V = IxA();
    Y((F) => ({
      ...F,
      settings: X,
      toolPermissionContext: rMB(F.toolPermissionContext, V)
    }))
  }, [Y])), IE.default.createElement(aMB.Provider, {
    value: !0
  }, IE.default.createElement(sMB.Provider, {
    value: J
  }, A))
}
// @from(Start 6635674, End 6635850)
function OQ() {
  let A = IE.useContext(sMB);
  if (!A.__IS_INITIALIZED__) throw ReferenceError("useAppState cannot be called outside of an <AppStateProvider />");
  return A
}
// @from(Start 6635855, End 6635857)
IE
// @from(Start 6635859, End 6635862)
sMB
// @from(Start 6635864, End 6635867)
aMB
// @from(Start 6635873, End 6636044)
z9 = L(() => {
  YrA();
  AZ();
  is();
  CU();
  MB();
  V0();
  IE = BA(VA(), 1);
  sMB = IE.default.createContext([{}, (A) => A]), aMB = IE.default.createContext(!1)
})
// @from(Start 6636047, End 6638109)
function vZ() {
  let [A, Q] = OQ(), B = R$A.useCallback(() => {
    Q((Z) => {
      let I = $U6(Z.notifications.queue);
      if (Z.notifications.current !== null || !I) return Z;
      return Qe = setTimeout(() => {
        Qe = null, Q((Y) => {
          if (Y.notifications.current?.key !== I.key) return Y;
          return {
            ...Y,
            notifications: {
              queue: Y.notifications.queue,
              current: null
            }
          }
        }), B()
      }, I.timeoutMs ?? oMB), {
        ...Z,
        notifications: {
          queue: Z.notifications.queue.filter((Y) => Y !== I),
          current: I
        }
      }
    })
  }, [Q]), G = R$A.useCallback((Z) => {
    if (Z.priority === "immediate") {
      if (Qe) clearTimeout(Qe), Qe = null;
      Qe = setTimeout(() => {
        Qe = null, Q((I) => {
          if (I.notifications.current?.key !== Z.key) return I;
          return {
            ...I,
            notifications: {
              queue: I.notifications.queue.filter((Y) => !Z.invalidates?.includes(Y.key)),
              current: null
            }
          }
        }), B()
      }, Z.timeoutMs ?? oMB), Q((I) => ({
        ...I,
        notifications: {
          current: Z,
          queue: [...I.notifications.current ? [I.notifications.current] : [], ...I.notifications.queue].filter((Y) => Y.priority !== "immediate" && !Z.invalidates?.includes(Y.key))
        }
      }));
      return
    }
    Q((I) => {
      if (Z.priority === "immediate") return I;
      let J = !new Set(I.notifications.queue.map((W) => W.key)).has(Z.key) && I.notifications.current?.key !== Z.key;
      return {
        ...I,
        notifications: {
          current: I.notifications.current,
          queue: J ? [...I.notifications.queue.filter((W) => W.priority !== "immediate" && !Z.invalidates?.includes(W.key)), Z] : I.notifications.queue
        }
      }
    }), B()
  }, [Q, B]);
  return R$A.useEffect(() => {
    if (A.notifications.queue.length > 0) B()
  }, []), {
    addNotification: G
  }
}
// @from(Start 6638111, End 6638253)
function $U6(A) {
  return A.sort((Q, B) => {
    let G = tMB[Q.priority] ?? 999,
      Z = tMB[B.priority] ?? 999;
    return G - Z
  })[0]
}
// @from(Start 6638258, End 6638261)
R$A
// @from(Start 6638263, End 6638273)
oMB = 8000
// @from(Start 6638277, End 6638286)
Qe = null
// @from(Start 6638290, End 6638293)
tMB
// @from(Start 6638299, End 6638416)
EU = L(() => {
  z9();
  R$A = BA(VA(), 1);
  tMB = {
    immediate: 0,
    high: 1,
    medium: 2,
    low: 3
  }
})
// @from(Start 6638419, End 6638513)
function eMB(A) {
  return function(Q) {
    return (new Map(A).get(Q) ?? (() => {}))(Q)
  }
}
// @from(Start 6638515, End 6644036)
function FrA({
  value: A,
  onChange: Q,
  onSubmit: B,
  onExit: G,
  onExitMessage: Z,
  onHistoryUp: I,
  onHistoryDown: Y,
  onHistoryReset: J,
  mask: W = "",
  multiline: X = !1,
  cursorChar: V,
  invert: F,
  columns: K,
  onImagePaste: D,
  disableCursorMovementForUpDownKeys: H = !1,
  externalOffset: C,
  onOffsetChange: E,
  inputFilter: U
}) {
  let q = C,
    w = E,
    N = j7.fromText(A, K, q),
    {
      addNotification: R
    } = vZ(),
    T = Bf((qA) => {
      Z?.(qA, "Ctrl-C")
    }, () => G?.(), () => {
      if (A) Q(""), w(0), J?.()
    }),
    y = Bf((qA) => {
      if (!A || !qA) return;
      R({
        key: "escape-again-to-clear",
        text: "Press Escape again to clear",
        priority: "immediate",
        timeoutMs: 1000
      })
    }, () => {
      if (A) {
        if (A.trim() !== "") Jf(A);
        Q(""), w(0), J?.()
      }
    });

  function v() {
    if (A.trim() !== "") Jf(A), J?.();
    return j7.fromText("", K, 0)
  }
  let x = Bf((qA) => {
    if (A !== "") return;
    Z?.(qA, "Ctrl-D")
  }, () => {
    if (A !== "") return;
    G?.()
  });

  function p() {
    if (N.text === "") return x(), N;
    return N.del()
  }

  function u() {
    if (!D) return;
    ssA().then((qA) => {
      if (qA) D(qA.base64, qA.mediaType);
      else R({
        key: "no-image-in-clipboard",
        text: `No image found in clipboard. Use ${tt.displayText} to paste images.`,
        priority: "immediate",
        timeoutMs: 1000
      })
    })
  }

  function e() {
    let {
      cursor: qA,
      killed: KA
    } = N.deleteToLineEnd();
    return SsA(KA, !0), qA
  }

  function l() {
    let {
      cursor: qA,
      killed: KA
    } = N.deleteToLineStart();
    return SsA(KA, !0), qA
  }

  function k() {
    let {
      cursor: qA,
      killed: KA
    } = N.deleteWordBefore();
    return SsA(KA, !0), qA
  }

  function m() {
    let qA = _NB();
    if (qA.length > 0) return N.insert(qA);
    return N
  }
  let o = eMB([
      ["a", () => N.startOfLine()],
      ["b", () => N.left()],
      ["c", T],
      ["d", p],
      ["e", () => N.endOfLine()],
      ["f", () => N.right()],
      ["h", () => N.backspace()],
      ["k", e],
      ["l", () => v()],
      ["n", () => NA()],
      ["p", () => zA()],
      ["u", l],
      ["w", k],
      ["y", m]
    ]),
    IA = eMB([
      ["b", () => N.prevWord()],
      ["f", () => N.nextWord()],
      ["d", () => N.deleteWordAfter()]
    ]);

  function FA(qA) {
    if (X && N.offset > 0 && N.text[N.offset - 1] === "\\") return vMB(), N.backspace().insert(`
`);
    if (qA.meta) return N.insert(`
`);
    B?.(A)
  }

  function zA() {
    if (H) return I?.(), N;
    let qA = N.up();
    if (!qA.equals(N)) return qA;
    if (X) {
      let KA = N.upLogicalLine();
      if (!KA.equals(N)) return KA
    }
    return I?.(), N
  }

  function NA() {
    if (H) return Y?.(), N;
    let qA = N.down();
    if (!qA.equals(N)) return qA;
    if (X) {
      let KA = N.downLogicalLine();
      if (!KA.equals(N)) return KA
    }
    return Y?.(), N
  }

  function OA(qA) {
    switch (!0) {
      case qA.escape:
        return () => {
          return y(), N
        };
      case (qA.leftArrow && (qA.ctrl || qA.meta || qA.fn)):
        return () => N.prevWord();
      case (qA.rightArrow && (qA.ctrl || qA.meta || qA.fn)):
        return () => N.nextWord();
      case qA.backspace:
        return qA.meta ? k : () => N.backspace();
      case qA.delete:
        return qA.meta ? e : () => N.del();
      case qA.ctrl:
        return o;
      case qA.home:
        return () => N.startOfLine();
      case qA.end:
        return () => N.endOfLine();
      case qA.pageDown:
        return () => N.endOfLine();
      case qA.pageUp:
        return () => N.startOfLine();
      case qA.meta:
        return IA;
      case qA.return:
        return () => FA(qA);
      case qA.tab:
        return () => N;
      case qA.upArrow:
        return zA;
      case qA.downArrow:
        return NA;
      case qA.leftArrow:
        return () => N.left();
      case qA.rightArrow:
        return () => N.right();
      default:
        return function(KA) {
          switch (!0) {
            case (KA === "\x1B[H" || KA === "\x1B[1~"):
              return N.startOfLine();
            case (KA === "\x1B[F" || KA === "\x1B[4~"):
              return N.endOfLine();
            default:
              if (N.isAtStart() && lMB(KA)) return N.insert(cY(KA).replace(/\r/g, `
`)).left();
              return N.insert(cY(KA).replace(/\r/g, `
`))
          }
        }
    }
  }

  function mA(qA, KA) {
    if (qA.ctrl && (KA === "k" || KA === "u" || KA === "w")) return !0;
    if (qA.meta && (qA.backspace || qA.delete)) return !0;
    return !1
  }

  function wA(qA, KA) {
    if (tt.check(qA, KA) && D) {
      u(), _sA();
      return
    }
    let yA = U ? U(qA, KA) : qA;
    if (yA === "" && qA !== "") return;
    if (!KA.backspace && !KA.delete && qA.includes("")) {
      let X1 = (qA.match(/\x7f/g) || []).length,
        WA = N;
      for (let EA = 0; EA < X1; EA++) WA = WA.backspace();
      if (!N.equals(WA)) {
        if (N.text !== WA.text) Q(WA.text);
        w(WA.offset)
      }
      _sA();
      return
    }
    if (!mA(KA, yA)) _sA();
    let oA = OA(KA)(yA);
    if (oA) {
      if (!N.equals(oA)) {
        if (N.text !== oA.text) Q(oA.text);
        w(oA.offset)
      }
    }
  }
  return {
    onInput: wA,
    renderedValue: N.render(V, W, F),
    offset: q,
    setOffset: w
  }
}
// @from(Start 6644041, End 6644135)
Um1 = L(() => {
  ET();
  wsA();
  cu1();
  rsA();
  r7A();
  zp();
  Up();
  o7A();
  EU()
})
// @from(Start 6644141, End 6646851)
GOB = z((Qt7, BOB) => {
  var wU6 = "Expected a function",
    AOB = NaN,
    qU6 = "[object Symbol]",
    NU6 = /^\s+|\s+$/g,
    LU6 = /^[-+]0x[0-9a-f]+$/i,
    MU6 = /^0b[01]+$/i,
    OU6 = /^0o[0-7]+$/i,
    RU6 = parseInt,
    TU6 = typeof global == "object" && global && global.Object === Object && global,
    PU6 = typeof self == "object" && self && self.Object === Object && self,
    jU6 = TU6 || PU6 || Function("return this")(),
    SU6 = Object.prototype,
    _U6 = SU6.toString,
    kU6 = Math.max,
    yU6 = Math.min,
    $m1 = function() {
      return jU6.Date.now()
    };

  function xU6(A, Q, B) {
    var G, Z, I, Y, J, W, X = 0,
      V = !1,
      F = !1,
      K = !0;
    if (typeof A != "function") throw TypeError(wU6);
    if (Q = QOB(Q) || 0, wm1(B)) V = !!B.leading, F = "maxWait" in B, I = F ? kU6(QOB(B.maxWait) || 0, Q) : I, K = "trailing" in B ? !!B.trailing : K;

    function D(T) {
      var y = G,
        v = Z;
      return G = Z = void 0, X = T, Y = A.apply(v, y), Y
    }

    function H(T) {
      return X = T, J = setTimeout(U, Q), V ? D(T) : Y
    }

    function C(T) {
      var y = T - W,
        v = T - X,
        x = Q - y;
      return F ? yU6(x, I - v) : x
    }

    function E(T) {
      var y = T - W,
        v = T - X;
      return W === void 0 || y >= Q || y < 0 || F && v >= I
    }

    function U() {
      var T = $m1();
      if (E(T)) return q(T);
      J = setTimeout(U, C(T))
    }

    function q(T) {
      if (J = void 0, K && G) return D(T);
      return G = Z = void 0, Y
    }

    function w() {
      if (J !== void 0) clearTimeout(J);
      X = 0, G = W = Z = J = void 0
    }

    function N() {
      return J === void 0 ? Y : q($m1())
    }

    function R() {
      var T = $m1(),
        y = E(T);
      if (G = arguments, Z = this, W = T, y) {
        if (J === void 0) return H(W);
        if (F) return J = setTimeout(U, Q), D(W)
      }
      if (J === void 0) J = setTimeout(U, Q);
      return Y
    }
    return R.cancel = w, R.flush = N, R
  }

  function wm1(A) {
    var Q = typeof A;
    return !!A && (Q == "object" || Q == "function")
  }

  function vU6(A) {
    return !!A && typeof A == "object"
  }

  function bU6(A) {
    return typeof A == "symbol" || vU6(A) && _U6.call(A) == qU6
  }

  function QOB(A) {
    if (typeof A == "number") return A;
    if (bU6(A)) return AOB;
    if (wm1(A)) {
      var Q = typeof A.valueOf == "function" ? A.valueOf() : A;
      A = wm1(Q) ? Q + "" : Q
    }
    if (typeof A != "string") return A === 0 ? A : +A;
    A = A.replace(NU6, "");
    var B = MU6.test(A);
    return B || OU6.test(A) ? RU6(A.slice(2), B ? 2 : 8) : LU6.test(A) ? AOB : +A
  }
  BOB.exports = xU6
})
// @from(Start 6646854, End 6647110)
function CI(A, Q) {
  let B = YE.useRef(A);
  fU6(() => {
    B.current = A
  }, [A]), YE.useEffect(() => {
    if (Q === null) return;
    let G = setInterval(() => {
      B.current()
    }, Q);
    return () => {
      clearInterval(G)
    }
  }, [Q])
}
// @from(Start 6647112, End 6647224)
function hU6(A) {
  let Q = YE.useRef(A);
  Q.current = A, YE.useEffect(() => () => {
    Q.current()
  }, [])
}
// @from(Start 6647226, End 6647715)
function qp(A, Q = 500, B) {
  let G = YE.useRef();
  hU6(() => {
    if (G.current) G.current.cancel()
  });
  let Z = YE.useMemo(() => {
    let I = qm1.default(A, Q, B),
      Y = (...J) => {
        return I(...J)
      };
    return Y.cancel = () => {
      I.cancel()
    }, Y.isPending = () => {
      return !!G.current
    }, Y.flush = () => {
      return I.flush()
    }, Y
  }, [A, Q, B]);
  return YE.useEffect(() => {
    G.current = qm1.default(A, Q, B)
  }, [A, Q, B]), Z
}
// @from(Start 6647720, End 6647722)
YE
// @from(Start 6647724, End 6647727)
qm1
// @from(Start 6647729, End 6647732)
fU6
// @from(Start 6647738, End 6647857)
JE = L(() => {
  YE = BA(VA(), 1), qm1 = BA(GOB(), 1), fU6 = typeof window < "u" ? YE.useLayoutEffect : YE.useEffect
})
// @from(Start 6647860, End 6650447)
function ZOB({
  onPaste: A,
  onInput: Q,
  onImagePaste: B
}) {
  let [G, Z] = wT.default.useState({
    chunks: [],
    timeoutId: null
  }), [I, Y] = wT.default.useState(!1), J = wT.default.useRef(!1), W = wT.default.useRef(!1), X = wT.default.useRef(!0), V = wT.default.useMemo(() => dQ() === "macos", []);
  wT.default.useEffect(() => {
    return () => {
      X.current = !1
    }
  }, []);
  let F = wT.default.useCallback(() => {
      if (!B || !X.current) return;
      ssA().then((E) => {
        if (E && X.current) B(E.base64, E.mediaType)
      }).catch((E) => {
        if (X.current) AA(E)
      }).finally(() => {
        if (X.current) Y(!1)
      })
    }, [B]),
    K = qp(F, gU6),
    D = wT.default.useCallback((E) => {
      if (E) clearTimeout(E);
      return setTimeout(() => {
        Z(({
          chunks: U
        }) => {
          let q = U.join("").replace(/\[I$/, "").replace(/\[O$/, "");
          if (B && Ym1(q)) {
            let w = /\/TemporaryItems\/.*screencaptureui.*\/Screenshot/i.test(q);
            return UMB(q).then((N) => {
              if (N) B(N.base64, N.mediaType);
              else if (w && V) K();
              else {
                if (A) A(q);
                Y(!1)
              }
            }), {
              chunks: [],
              timeoutId: null
            }
          }
          if (V && B && q.length === 0) return K(), {
            chunks: [],
            timeoutId: null
          };
          if (A) A(q);
          return Y(!1), {
            chunks: [],
            timeoutId: null
          }
        })
      }, uU6)
    }, [K, V, B, A]),
    {
      stdin: H
    } = Yp();
  return wT.default.useEffect(() => {
    if (!H) return;
    let E = (U) => {
      let q = U.toString();
      if (q.includes("\x1B[200~")) Y(!0), J.current = !0, W.current = !1;
      if (q.includes("\x1B[201~")) {
        if (Y(!1), V && J.current && !W.current && B) K();
        J.current = !1, W.current = !1, Z({
          chunks: [],
          timeoutId: null
        })
      }
    };
    return H.on("data", E), () => {
      H.off("data", E), Y(!1)
    }
  }, [H, B, K, V]), {
    wrappedOnInput: (E, U) => {
      if (J.current) W.current = !0;
      let q = Ym1(E);
      if (A && (E.length > asA || G.timeoutId || q || I)) {
        Z(({
          chunks: N,
          timeoutId: R
        }) => {
          return {
            chunks: [...N, E],
            timeoutId: D(R)
          }
        });
        return
      }
      if (Q(E, U), E.length > 10) Y(!1)
    },
    pasteState: G,
    isPasting: I
  }
}
// @from(Start 6650452, End 6650454)
wT
// @from(Start 6650456, End 6650464)
gU6 = 50
// @from(Start 6650468, End 6650477)
uU6 = 100
// @from(Start 6650483, End 6650561)
IOB = L(() => {
  hA();
  JE();
  rsA();
  Q3();
  g1();
  wT = BA(VA(), 1)
})
// @from(Start 6650564, End 6650918)
function YOB({
  placeholder: A,
  value: Q,
  showCursor: B,
  focus: G,
  terminalFocus: Z = !0
}) {
  let I = void 0;
  if (A) {
    if (I = tA.dim(A), B && G && Z) I = A.length > 0 ? tA.inverse(A[0]) + tA.dim(A.slice(1)) : tA.inverse(" ")
  }
  let Y = Q.length === 0 && Boolean(A);
  return {
    renderedPlaceholder: I,
    showPlaceholder: Y
  }
}
// @from(Start 6650923, End 6650948)
JOB = L(() => {
  F9()
})
// @from(Start 6650951, End 6651167)
function AGA({
  char: A,
  index: Q,
  glimmerIndex: B,
  messageColor: G,
  shimmerColor: Z
}) {
  let I = Q === B,
    Y = Math.abs(Q - B) === 1;
  return Nm1.createElement($, {
    color: I || Y ? Z : G
  }, A)
}
// @from(Start 6651172, End 6651175)
Nm1
// @from(Start 6651181, End 6651227)
KrA = L(() => {
  hA();
  Nm1 = BA(VA(), 1)
})
// @from(Start 6651230, End 6651740)
function T$A(A, Q, B, G) {
  let Z = QGA.useRef(Date.now()),
    [I, Y] = QGA.useState(A === "requesting" ? -1 : 10),
    J = QGA.useMemo(() => {
      if (A === "requesting") return 50;
      return 200
    }, [A]);
  return CI(() => {
    if (B === !1 || G) return;
    let W = Date.now() - Z.current,
      X = Math.floor(W / J),
      V = Q.length,
      F = V + 20;
    if (A === "requesting") {
      let K = X % F - 10;
      Y(K)
    } else {
      let K = V + 10 - X % F;
      Y(K)
    }
  }, J), I
}
// @from(Start 6651745, End 6651748)
QGA
// @from(Start 6651754, End 6651800)
Lm1 = L(() => {
  JE();
  QGA = BA(VA(), 1)
})
// @from(Start 6651803, End 6652610)
function WOB(A, Q) {
  if (Q.length === 0) return [{
    text: A,
    start: 0
  }];
  let B = [...Q].sort((W, X) => {
      if (W.start !== X.start) return W.start - X.start;
      return X.priority - W.priority
    }),
    G = [],
    Z = [];
  for (let W of B)
    if (!Z.some((V) => W.start >= V.start && W.start < V.end || W.end > V.start && W.end <= V.end || W.start <= V.start && W.end >= V.end)) G.push(W), Z.push({
      start: W.start,
      end: W.end
    });
  let I = [],
    Y = 0,
    J = cY(A).length;
  for (let W of G) {
    if (W.start > Y) I.push({
      text: ct(A, Y, W.start),
      start: Y
    });
    I.push({
      text: ct(A, W.start, W.end),
      start: W.start,
      highlight: W
    }), Y = W.end
  }
  if (Y < J) I.push({
    text: ct(A, Y),
    start: Y
  });
  return I
}
// @from(Start 6652615, End 6652649)
XOB = L(() => {
  Tg1();
  ET()
})
// @from(Start 6652652, End 6653781)
function VOB({
  text: A,
  highlights: Q = []
}) {
  let B = WOB(A, Q),
    G = T$A("requesting", A, !0, !1);
  return mH.createElement(mH.Fragment, null, B.map((Z, I) => {
    if (!Z.highlight) return mH.createElement($, {
      key: I
    }, Z.text);
    let {
      style: Y
    } = Z.highlight;
    if (Y.type === "rainbow") return Z.text.split("").map((J, W) => {
      let X = Z.start + W,
        V = O$A(W, !1),
        F = O$A(W, !0);
      return mH.createElement(AGA, {
        key: `${I}-${W}`,
        char: J,
        index: X,
        glimmerIndex: G,
        messageColor: V,
        shimmerColor: F
      })
    });
    else if (Y.type === "shimmer") return Z.text.split("").map((J, W) => {
      let X = Z.start + W;
      return mH.createElement(AGA, {
        key: `${I}-${W}`,
        char: J,
        index: X,
        glimmerIndex: G,
        messageColor: Y.baseColor,
        shimmerColor: Y.shimmerColor
      })
    });
    else if (Y.type === "solid") return mH.createElement($, {
      key: I,
      color: Y.color
    }, Z.text);
    return mH.createElement($, {
      key: I
    }, Z.text)
  }))
}
// @from(Start 6653786, End 6653788)
mH
// @from(Start 6653794, End 6653874)
FOB = L(() => {
  hA();
  KrA();
  Lm1();
  CU();
  XOB();
  mH = BA(VA(), 1)
})
// @from(Start 6653877, End 6655205)
function DrA({
  inputState: A,
  children: Q,
  terminalFocus: B,
  ...G
}) {
  let {
    onInput: Z,
    renderedValue: I
  } = A, {
    wrappedOnInput: Y,
    isPasting: J
  } = ZOB({
    onPaste: G.onPaste,
    onInput: (C, E) => {
      if (J && E.return) return;
      Z(C, E)
    },
    onImagePaste: G.onImagePaste
  }), {
    onIsPastingChange: W
  } = G;
  BGA.default.useEffect(() => {
    if (W) W(J)
  }, [J, W]);
  let {
    showPlaceholder: X,
    renderedPlaceholder: V
  } = YOB({
    placeholder: G.placeholder,
    value: G.value,
    showCursor: G.showCursor,
    focus: G.focus,
    terminalFocus: B
  });
  f1(Y, {
    isActive: G.focus
  });
  let F = G.value && G.value.trim().indexOf(" ") === -1 || G.value && G.value.endsWith(" "),
    K = Boolean(G.argumentHint && G.value && F && G.value.startsWith("/")),
    D = G.showCursor && G.highlights ? G.highlights.filter((C) => G.cursorOffset < C.start || G.cursorOffset >= C.end) : G.highlights,
    H = D && D.length > 0;
  return BGA.default.createElement(S, null, BGA.default.createElement($, {
    wrap: "truncate-end",
    dimColor: G.dimColor
  }, X ? V : H ? BGA.default.createElement(VOB, {
    text: I,
    highlights: D
  }) : I, K && BGA.default.createElement($, {
    dimColor: !0
  }, G.value?.endsWith(" ") ? "" : " ", G.argumentHint), Q))
}
// @from(Start 6655210, End 6655213)
BGA
// @from(Start 6655219, End 6655292)
Mm1 = L(() => {
  hA();
  IOB();
  JOB();
  FOB();
  BGA = BA(VA(), 1)
})
// @from(Start 6655295, End 6655465)
function Rm1(A) {
  let Q = A.toString();
  if (Q.includes("\x1B[I")) Om1 = !0, Be.forEach((B) => B(!0));
  if (Q.includes("\x1B[O")) Om1 = !1, Be.forEach((B) => B(!1))
}
// @from(Start 6655467, End 6655635)
function KOB() {
  let A = () => {
    if (Be.size === 0) return;
    process.stdin.off("data", Rm1), process.stdout.write("\x1B[?1004l")
  };
  process.on("exit", A)
}
// @from(Start 6655637, End 6656412)
function HrA() {
  let [A, Q] = Vf.useState(Om1), [B, G] = Vf.useState(!1), Z = Vf.useCallback((Y) => {
    Q(Y), G(!1)
  }, []);
  Vf.useEffect(() => {
    if (!process.stdout.isTTY) return;
    if (Be.add(Z), Be.size === 1) process.stdout.write("\x1B[?1004h"), process.stdin.on("data", Rm1);
    return () => {
      if (Be.delete(Z), Be.size === 0) process.stdin.off("data", Rm1), process.stdout.write("\x1B[?1004l")
    }
  }, [Z]), Vf.useEffect(() => {
    if (!A && B) GA("tengu_typing_without_terminal_focus", {})
  }, [A, B]);
  let I = Vf.useCallback((Y, J) => {
    if (Y === "\x1B[I" || Y === "\x1B[O" || Y === "[I" || Y === "[O") return "";
    if ((Y || J) && !A) G(!0);
    return Y
  }, [A]);
  return {
    isFocused: A || B,
    filterFocusSequences: I
  }
}
// @from(Start 6656417, End 6656419)
Vf
// @from(Start 6656421, End 6656429)
Om1 = !0
// @from(Start 6656433, End 6656435)
Be
// @from(Start 6656441, End 6656500)
CrA = L(() => {
  q0();
  Vf = BA(VA(), 1), Be = new Set
})
// @from(Start 6656503, End 6657438)
function s4(A) {
  let [Q] = qB(), {
    isFocused: B,
    filterFocusSequences: G
  } = HrA(), Z = FrA({
    value: A.value,
    onChange: A.onChange,
    onSubmit: A.onSubmit,
    onExit: A.onExit,
    onExitMessage: A.onExitMessage,
    onHistoryReset: A.onHistoryReset,
    onHistoryUp: A.onHistoryUp,
    onHistoryDown: A.onHistoryDown,
    focus: A.focus,
    mask: A.mask,
    multiline: A.multiline,
    cursorChar: A.showCursor ? " " : "",
    highlightPastedText: A.highlightPastedText,
    invert: B ? tA.inverse : (I) => I,
    themeText: ZB("text", Q),
    columns: A.columns,
    onImagePaste: A.onImagePaste,
    disableCursorMovementForUpDownKeys: A.disableCursorMovementForUpDownKeys,
    externalOffset: A.cursorOffset,
    onOffsetChange: A.onChangeCursorOffset,
    inputFilter: G
  });
  return DOB.default.createElement(DrA, {
    inputState: Z,
    terminalFocus: B,
    highlights: A.highlights,
    ...A
  })
}
// @from(Start 6657443, End 6657446)
DOB
// @from(Start 6657452, End 6657532)
ZY = L(() => {
  F9();
  Um1();
  Mm1();
  CrA();
  hA();
  DOB = BA(VA(), 1)
})
// @from(Start 6657535, End 6659048)
function GGA({
  option: A,
  isFocused: Q,
  isSelected: B,
  shouldShowDownArrow: G,
  shouldShowUpArrow: Z,
  maxIndexWidth: I,
  index: Y,
  inputValue: J,
  onInputChange: W,
  onSubmit: X,
  onExit: V,
  layout: F,
  children: K
}) {
  let [D, H] = Qq.useState(0), C = F === "expanded" ? I + 3 : I + 4;
  return Qq.default.createElement(S, {
    flexDirection: "column",
    flexShrink: 0
  }, Qq.default.createElement(Xp, {
    isFocused: Q,
    isSelected: B,
    shouldShowDownArrow: G,
    shouldShowUpArrow: Z
  }, Qq.default.createElement(S, {
    flexDirection: "row",
    flexShrink: F === "compact" ? 0 : void 0
  }, Qq.default.createElement($, {
    color: B ? "success" : Q ? "suggestion" : void 0
  }, tA.dim(`${Y}.`.padEnd(I + 1)), " "), K, Q ? Qq.default.createElement(s4, {
    value: J,
    onChange: (E) => {
      W(E), A.onChange(E)
    },
    onSubmit: X,
    onExit: V,
    placeholder: A.placeholder || A.label,
    focus: !0,
    showCursor: !0,
    cursorOffset: D,
    onChangeCursorOffset: H,
    columns: 80
  }) : Qq.default.createElement(S, {
    width: 80
  }, Qq.default.createElement($, {
    color: B ? "success" : Q ? "suggestion" : J ? void 0 : "inactive"
  }, J || A.placeholder || A.label)))), A.description && Qq.default.createElement(S, {
    paddingLeft: C
  }, Qq.default.createElement($, {
    dimColor: A.dimDescription !== !1,
    color: B ? "success" : Q ? "suggestion" : void 0
  }, A.description)), F === "expanded" && Qq.default.createElement($, null, " "))
}
// @from(Start 6659053, End 6659055)
Qq
// @from(Start 6659061, End 6659131)
Tm1 = L(() => {
  hA();
  MsA();
  ZY();
  F9();
  Qq = BA(VA(), 1)
})
// @from(Start 6659134, End 6666936)
function M0({
  isDisabled: A = !1,
  hideIndexes: Q = !1,
  visibleOptionCount: B = 5,
  highlightText: G,
  options: Z,
  defaultValue: I,
  onCancel: Y,
  onChange: J,
  onFocus: W,
  focusValue: X,
  layout: V = "compact",
  disableSelection: F = !1
}) {
  let [K, D] = V3.useState(() => {
    let N = new Map;
    return Z.forEach((R) => {
      if (R.type === "input" && R.initialValue) N.set(R.value, R.initialValue)
    }), N
  }), H = TNB({
    visibleOptionCount: B,
    options: Z,
    defaultValue: I,
    onChange: J,
    onCancel: Y,
    onFocus: W,
    focusValue: X
  });
  jNB({
    isDisabled: A,
    disableSelection: F || (Q ? "numeric" : !1),
    state: H,
    options: Z,
    isMultiSelect: !1
  });
  let C = {
    container: () => ({
      flexDirection: "column"
    }),
    highlightedText: () => ({
      bold: !0
    })
  };
  if (V === "expanded") {
    let N = H.options.length.toString().length;
    return V3.default.createElement(S, {
      ...C.container()
    }, H.visibleOptions.map((R, T) => {
      let y = R.index === H.visibleFromIndex,
        v = R.index === H.visibleToIndex - 1,
        x = H.visibleToIndex < Z.length,
        p = H.visibleFromIndex > 0,
        u = H.visibleFromIndex + T + 1,
        e = !A && H.focusedValue === R.value,
        l = H.value === R.value;
      if (R.type === "input") {
        let FA = K.get(R.value) || "";
        return V3.default.createElement(GGA, {
          key: String(R.value),
          option: R,
          isFocused: e,
          isSelected: l,
          shouldShowDownArrow: x && v,
          shouldShowUpArrow: p && y,
          maxIndexWidth: N,
          index: u,
          inputValue: FA,
          onInputChange: (zA) => {
            D((NA) => {
              let OA = new Map(NA);
              return OA.set(R.value, zA), OA
            })
          },
          onSubmit: (zA) => {
            if (zA.trim()) J?.(R.value)
          },
          onExit: Y,
          layout: "expanded"
        })
      }
      let k = R.label,
        m = k;
      if (G && k.includes(G)) {
        let FA = k.indexOf(G);
        m = V3.default.createElement(V3.default.Fragment, null, k.slice(0, FA), V3.default.createElement($, {
          ...C.highlightedText()
        }, G), k.slice(FA + G.length))
      }
      let o = R.disabled === !0,
        IA = o ? void 0 : l ? "success" : e ? "suggestion" : void 0;
      return V3.default.createElement(S, {
        key: String(R.value),
        flexDirection: "column",
        flexShrink: 0
      }, V3.default.createElement(Xp, {
        isFocused: e,
        isSelected: l,
        shouldShowDownArrow: x && v,
        shouldShowUpArrow: p && y
      }, V3.default.createElement($, {
        dimColor: o,
        color: IA
      }, m)), R.description && V3.default.createElement(S, {
        paddingLeft: 2
      }, V3.default.createElement($, {
        dimColor: o || R.dimDescription !== !1,
        color: IA
      }, R.description)), V3.default.createElement($, null, " "))
    }))
  }
  if (V === "compact-vertical") {
    let N = Q ? 0 : H.options.length.toString().length;
    return V3.default.createElement(S, {
      ...C.container()
    }, H.visibleOptions.map((R, T) => {
      let y = R.index === H.visibleFromIndex,
        v = R.index === H.visibleToIndex - 1,
        x = H.visibleToIndex < Z.length,
        p = H.visibleFromIndex > 0,
        u = H.visibleFromIndex + T + 1,
        e = !A && H.focusedValue === R.value,
        l = H.value === R.value;
      if (R.type === "input") {
        let IA = K.get(R.value) || "";
        return V3.default.createElement(GGA, {
          key: String(R.value),
          option: R,
          isFocused: e,
          isSelected: l,
          shouldShowDownArrow: x && v,
          shouldShowUpArrow: p && y,
          maxIndexWidth: N,
          index: u,
          inputValue: IA,
          onInputChange: (FA) => {
            D((zA) => {
              let NA = new Map(zA);
              return NA.set(R.value, FA), NA
            })
          },
          onSubmit: (FA) => {
            if (FA.trim()) J?.(R.value)
          },
          onExit: Y,
          layout: "compact"
        })
      }
      let k = R.label,
        m = k;
      if (G && k.includes(G)) {
        let IA = k.indexOf(G);
        m = V3.default.createElement(V3.default.Fragment, null, k.slice(0, IA), V3.default.createElement($, {
          ...C.highlightedText()
        }, G), k.slice(IA + G.length))
      }
      let o = R.disabled === !0;
      return V3.default.createElement(S, {
        key: String(R.value),
        flexDirection: "column",
        flexShrink: 0
      }, V3.default.createElement(Xp, {
        isFocused: e,
        isSelected: l,
        shouldShowDownArrow: x && v,
        shouldShowUpArrow: p && y
      }, V3.default.createElement($, {
        dimColor: o,
        color: o ? void 0 : l ? "success" : e ? "suggestion" : void 0
      }, !Q && tA.dim(`${u}.`.padEnd(N + 2)), m)), R.description && V3.default.createElement(S, {
        paddingLeft: Q ? 2 : N + 4
      }, V3.default.createElement($, {
        dimColor: o || R.dimDescription !== !1,
        color: o ? void 0 : l ? "success" : e ? "suggestion" : void 0
      }, R.description)))
    }))
  }
  let E = Q ? 0 : H.options.length.toString().length,
    U = Math.max(...H.options.map((N) => N.label.length)),
    q = Q ? 0 : 2,
    w = E + U + q;
  return V3.default.createElement(S, {
    ...C.container()
  }, H.visibleOptions.map((N, R) => {
    if (N.type === "input") {
      let o = K.get(N.value) || "",
        IA = N.index === H.visibleFromIndex,
        FA = N.index === H.visibleToIndex - 1,
        zA = H.visibleToIndex < Z.length,
        NA = H.visibleFromIndex > 0,
        OA = H.visibleFromIndex + R + 1,
        mA = !A && H.focusedValue === N.value,
        wA = H.value === N.value;
      return V3.default.createElement(GGA, {
        key: String(N.value),
        option: N,
        isFocused: mA,
        isSelected: wA,
        shouldShowDownArrow: zA && FA,
        shouldShowUpArrow: NA && IA,
        maxIndexWidth: E,
        index: OA,
        inputValue: o,
        onInputChange: (qA) => {
          D((KA) => {
            let yA = new Map(KA);
            return yA.set(N.value, qA), yA
          })
        },
        onSubmit: (qA) => {
          if (qA.trim()) J?.(N.value)
        },
        onExit: Y,
        layout: "compact"
      })
    }
    let T = N.label,
      y = T;
    if (G && T.includes(G)) {
      let o = T.indexOf(G);
      y = V3.default.createElement(V3.default.Fragment, null, T.slice(0, o), V3.default.createElement($, {
        ...C.highlightedText()
      }, G), T.slice(o + G.length))
    }
    let v = N.index === H.visibleFromIndex,
      x = N.index === H.visibleToIndex - 1,
      p = H.visibleToIndex < Z.length,
      u = H.visibleFromIndex > 0,
      e = H.visibleFromIndex + R + 1,
      l = !A && H.focusedValue === N.value,
      k = H.value === N.value,
      m = N.disabled === !0;
    return V3.default.createElement(Xp, {
      key: String(N.value),
      isFocused: l,
      isSelected: k,
      shouldShowDownArrow: p && x,
      shouldShowUpArrow: u && v
    }, V3.default.createElement(S, {
      flexDirection: "row",
      flexShrink: 0,
      width: N.description ? w : void 0
    }, V3.default.createElement($, {
      dimColor: m,
      color: m ? void 0 : k ? "success" : l ? "suggestion" : void 0
    }, !Q && tA.dim(`${e}.`.padEnd(E + 2)), y)), N.description && V3.default.createElement(S, {
      flexShrink: 99,
      marginLeft: 2
    }, V3.default.createElement($, {
      wrap: "wrap-trim",
      dimColor: m || N.dimDescription !== !1,
      color: m ? void 0 : k ? "success" : l ? "suggestion" : void 0
    }, N.description)))
  }))
}
// @from(Start 6666941, End 6666943)
V3
// @from(Start 6666949, End 6667037)
S5 = L(() => {
  hA();
  MsA();
  PNB();
  SNB();
  F9();
  Tm1();
  V3 = BA(VA(), 1)
})
// @from(Start 6667043, End 6667081)
HOB = "https://claude.com/claude-code"
// @from(Start 6667084, End 6667246)
function ErA() {
  let A = process.env.BASH_DEFAULT_TIMEOUT_MS;
  if (A) {
    let Q = parseInt(A, 10);
    if (!isNaN(Q) && Q > 0) return Q
  }
  return 120000
}
// @from(Start 6667248, End 6667440)
function COB() {
  let A = process.env.BASH_MAX_TIMEOUT_MS;
  if (A) {
    let Q = parseInt(A, 10);
    if (!isNaN(Q) && Q > 0) return Math.max(Q, ErA())
  }
  return Math.max(600000, ErA())
}
// @from(Start 6667442, End 6667611)
function Ge() {
  let A = DkA.validate(process.env.BASH_MAX_OUTPUT_LENGTH);
  if (A.status === "capped") g(`BASH_MAX_OUTPUT_LENGTH ${A.message}`);
  return A.effective
}
// @from(Start 6667613, End 6667646)
function ZGA() {
  return ErA()
}
// @from(Start 6667648, End 6667681)
function zrA() {
  return COB()
}
// @from(Start 6667683, End 6667974)
function mU6() {
  if (!(((l0() || {}).includeCoAuthoredBy ?? !0) && qkA() !== "remote")) return {
    commit: "",
    pr: ""
  };
  let B = `\uD83E\uDD16 Generated with [Claude Code](${HOB})`;
  return {
    commit: `${B}

   Co-Authored-By: Claude <noreply@anthropic.com>`,
    pr: B
  }
}
// @from(Start 6667976, End 6671559)
function dU6() {
  if (!nQ.isSandboxingEnabled()) return "";
  let A = nQ.getFsReadConfig(),
    Q = nQ.getFsWriteConfig(),
    B = nQ.getNetworkRestrictionConfig(),
    G = nQ.getAllowUnixSockets(),
    Z = nQ.getIgnoreViolations(),
    I = nQ.areUnsandboxedCommandsAllowed(),
    Y = {
      read: A,
      write: Q
    },
    J = {
      ...B?.allowedHosts && {
        allowedHosts: B.allowedHosts
      },
      ...B?.deniedHosts && {
        deniedHosts: B.deniedHosts
      },
      ...G && {
        allowUnixSockets: G
      }
    },
    W = [];
  if (Object.keys(Y).length > 0) W.push(`    - Filesystem: ${JSON.stringify(Y,null,2).split(`
`).join(`
      `)}`);
  if (Object.keys(J).length > 0) W.push(`    - Network: ${JSON.stringify(J,null,2).split(`
`).join(`
      `)}`);
  if (Z) W.push(`    - Ignored violations: ${JSON.stringify(Z,null,2).split(`
`).join(`
      `)}`);
  let X = bZ() ? "    - EXCEPTION: `mcp-cli` commands must always be called with `dangerouslyDisableSandbox: true` as they do not work properly in sandboxed mode\n" : "",
    V = I ? `  - CRITICAL: Commands run in sandbox mode by default - do NOT set \`dangerouslyDisableSandbox\`
    - Even if you have recently run commands with \`dangerouslyDisableSandbox: true\`, you MUST NOT continue that pattern
    - VERY IMPORTANT: Do NOT learn from or repeat the pattern of overriding sandbox - each command should run sandboxed by default
${X}    - Set \`dangerouslyDisableSandbox: true\` if:
      1. The user *explicitly* asks to bypass sandbox, OR
      2. A command just failed and you see evidence of sandbox restrictions causing the failure
    - When analyzing failures:
      - Commands can fail for many reasons unrelated to the sandbox (missing files, wrong arguments, network issues, etc.)
      - Evidence of sandbox-caused failures includes:
        - "Operation not permitted" errors for file/network operations
        - Access denied to specific paths outside allowed directories
        - Network connection failures to non-whitelisted hosts
        - Unix socket connection errors
      - Sandbox violation logs can be noisy, but clear permission errors are strong indicators
    - When you see evidence of sandbox-caused failure:
      - IMMEDIATELY retry with \`dangerouslyDisableSandbox: true\` (don't ask, just do it)
      - Briefly explain what sandbox restriction likely caused the failure
      - Mention: "Use \`/sandbox\` to manage restrictions"
      - This will prompt the user for permission
    - Example of normal usage: { "command": "ls", "description": "List files" }
    - Example of override: { "command": "my-tool", "description": "Run my-tool", "dangerouslyDisableSandbox": true }
    - DO NOT suggest adding sensitive paths like ~/.bashrc, ~/.zshrc, ~/.ssh/*, or credential files to the allowlist` : "  - CRITICAL: All commands MUST run in sandbox mode - the `dangerouslyDisableSandbox` parameter is disabled by policy\n    - Commands cannot run outside the sandbox under any circumstances\n    - If a command fails due to sandbox restrictions, work with the user to adjust sandbox settings instead";
  return `- Commands run in a sandbox by default with the following restrictions:
${W.join(`
`)}
${V}
  - IMPORTANT: For temporary files, use \`/tmp/claude/\` as your temporary directory
    - The TMPDIR environment variable is automatically set to \`/tmp/claude\` when running in sandbox mode
    - Do NOT use \`/tmp\` directly - use \`/tmp/claude/\` or rely on TMPDIR instead
    - Most programs that respect TMPDIR will automatically use \`/tmp/claude/\``
}
// @from(Start 6671561, End 6675285)
function EOB() {
  return `Executes a given bash command in a persistent shell session with optional timeout, ensuring proper handling and security measures.

IMPORTANT: This tool is for terminal operations like git, npm, docker, etc. DO NOT use it for file operations (reading, writing, editing, searching, finding files) - use the specialized tools for this instead.

Before executing the command, please follow these steps:

1. Directory Verification:
   - If the command will create new directories or files, first use \`ls\` to verify the parent directory exists and is the correct location
   - For example, before running "mkdir foo/bar", first use \`ls foo\` to check that "foo" exists and is the intended parent directory

2. Command Execution:
   - Always quote file paths that contain spaces with double quotes (e.g., cd "path with spaces/file.txt")
   - Examples of proper quoting:
     - cd "/Users/name/My Documents" (correct)
     - cd /Users/name/My Documents (incorrect - will fail)
     - python "/path/with spaces/script.py" (correct)
     - python /path/with spaces/script.py (incorrect - will fail)
   - After ensuring proper quoting, execute the command.
   - Capture the output of the command.

Usage notes:
  - The command argument is required.
  - You can specify an optional timeout in milliseconds (up to ${zrA()}ms / ${zrA()/60000} minutes). If not specified, commands will timeout after ${ZGA()}ms (${ZGA()/60000} minutes).
  - It is very helpful if you write a clear, concise description of what this command does in 5-10 words.
  - If the output exceeds ${Ge()} characters, output will be truncated before being returned to you.
  - You can use the \`run_in_background\` parameter to run the command in the background, which allows you to continue working while the command runs. You can monitor the output using the ${C9} tool as it becomes available. You do not need to use '&' at the end of the command when using this parameter.
  ${dU6()}
  - Avoid using Bash with the \`find\`, \`grep\`, \`cat\`, \`head\`, \`tail\`, \`sed\`, \`awk\`, or \`echo\` commands, unless explicitly instructed or when these commands are truly necessary for the task. Instead, always prefer using the dedicated tools for these commands:
    - File search: Use ${iK} (NOT find or ls)
    - Content search: Use ${xY} (NOT grep or rg)
    - Read files: Use ${d5} (NOT cat/head/tail)
    - Edit files: Use ${$5} (NOT sed/awk)
    - Write files: Use ${wX} (NOT echo >/cat <<EOF)
    - Communication: Output text directly (NOT echo/printf)
  - When issuing multiple commands:
    - If the commands are independent and can run in parallel, make multiple ${C9} tool calls in a single message. For example, if you need to run "git status" and "git diff", send a single message with two ${C9} tool calls in parallel.
    - If the commands depend on each other and must run sequentially, use a single ${C9} call with '&&' to chain them together (e.g., \`git add . && git commit -m "message" && git push\`). For instance, if one operation must complete before another starts (like mkdir before cp, Write before Bash for git operations, or git add before git commit), run these operations sequentially instead.
    - Use ';' only when you need to run commands sequentially but don't care if earlier commands fail
    - DO NOT use newlines to separate commands (newlines are ok in quoted strings)
  - Try to maintain your current working directory throughout the session by using absolute paths and avoiding usage of \`cd\`. You may use \`cd\` if the User explicitly requests it.
    <good-example>
    pytest /foo/bar/tests
    </good-example>
    <bad-example>
    cd /foo/bar && pytest tests
    </bad-example>

${cU6()}`
}
// @from(Start 6675287, End 6681536)
function cU6() {
  let {
    commit: Q,
    pr: B
  } = mU6();
  return `# Committing changes with git

Only create commits when requested by the user. If unclear, ask first. When the user asks you to create a new git commit, follow these steps carefully:

Git Safety Protocol:
- NEVER update the git config
- NEVER run destructive/irreversible git commands (like push --force, hard reset, etc) unless the user explicitly requests them 
- NEVER skip hooks (--no-verify, --no-gpg-sign, etc) unless the user explicitly requests it
- NEVER run force push to main/master, warn the user if they request it
- Avoid git commit --amend.  ONLY use --amend when either (1) user explicitly requested amend OR (2) adding edits from pre-commit hook (additional instructions below) 
- Before amending: ALWAYS check authorship (git log -1 --format='%an %ae')
- NEVER commit changes unless the user explicitly asks you to. It is VERY IMPORTANT to only commit when explicitly asked, otherwise the user will feel that you are being too proactive.

1. You can call multiple tools in a single response. When multiple independent pieces of information are requested and all commands are likely to succeed, run multiple tool calls in parallel for optimal performance. run the following bash commands in parallel, each using the ${C9} tool:
  - Run a git status command to see all untracked files.
  - Run a git diff command to see both staged and unstaged changes that will be committed.
  - Run a git log command to see recent commit messages, so that you can follow this repository's commit message style.
2. Analyze all staged changes (both previously staged and newly added) and draft a commit message:
  - Summarize the nature of the changes (eg. new feature, enhancement to an existing feature, bug fix, refactoring, test, docs, etc.). Ensure the message accurately reflects the changes and their purpose (i.e. "add" means a wholly new feature, "update" means an enhancement to an existing feature, "fix" means a bug fix, etc.).
  - Do not commit files that likely contain secrets (.env, credentials.json, etc). Warn the user if they specifically request to commit those files
  - Draft a concise (1-2 sentences) commit message that focuses on the "why" rather than the "what"
  - Ensure it accurately reflects the changes and their purpose
3. You can call multiple tools in a single response. When multiple independent pieces of information are requested and all commands are likely to succeed, run multiple tool calls in parallel for optimal performance. run the following commands:
   - Add relevant untracked files to the staging area.
   - Create the commit with a message${Q?` ending with:
   ${Q}`:"."}
   - Run git status after the commit completes to verify success.
   Note: git status depends on the commit completing, so run it sequentially after the commit.
4. If the commit fails due to pre-commit hook changes, retry ONCE. If it succeeds but files were modified by the hook, verify it's safe to amend:
   - Check HEAD commit: git log -1 --format='[%h] (%an <%ae>) %s'. VERIFY it matches your commit
   - Check not pushed: git status shows "Your branch is ahead"
   - If both true: amend your commit. Otherwise: create NEW commit (never amend other developers' commits)

Important notes:
- NEVER run additional commands to read or explore code, besides git bash commands
- NEVER use the ${BY.name} or ${A6} tools
- DO NOT push to the remote repository unless the user explicitly asks you to do so
- IMPORTANT: Never use git commands with the -i flag (like git rebase -i or git add -i) since they require interactive input which is not supported.
- If there are no changes to commit (i.e., no untracked files and no modifications), do not create an empty commit
- In order to ensure good formatting, ALWAYS pass the commit message via a HEREDOC, a la this example:
<example>
git commit -m "$(cat <<'EOF'
   Commit message here.${Q?`

   ${Q}`:""}
   EOF
   )"
</example>

# Creating pull requests
Use the gh command via the Bash tool for ALL GitHub-related tasks including working with issues, pull requests, checks, and releases. If given a Github URL use the gh command to get the information needed.

IMPORTANT: When the user asks you to create a pull request, follow these steps carefully:

1. You can call multiple tools in a single response. When multiple independent pieces of information are requested and all commands are likely to succeed, run multiple tool calls in parallel for optimal performance. run the following bash commands in parallel using the ${C9} tool, in order to understand the current state of the branch since it diverged from the main branch:
   - Run a git status command to see all untracked files
   - Run a git diff command to see both staged and unstaged changes that will be committed
   - Check if the current branch tracks a remote branch and is up to date with the remote, so you know if you need to push to the remote
   - Run a git log command and \`git diff [base-branch]...HEAD\` to understand the full commit history for the current branch (from the time it diverged from the base branch)
2. Analyze all changes that will be included in the pull request, making sure to look at all relevant commits (NOT just the latest commit, but ALL commits that will be included in the pull request!!!), and draft a pull request summary
3. You can call multiple tools in a single response. When multiple independent pieces of information are requested and all commands are likely to succeed, run multiple tool calls in parallel for optimal performance. run the following commands in parallel:
   - Create new branch if needed
   - Push to remote with -u flag if needed
   - Create PR using gh pr create with the format below. Use a HEREDOC to pass the body to ensure correct formatting.
<example>
gh pr create --title "the pr title" --body "$(cat <<'EOF'
## Summary
<1-3 bullet points>

## Test plan
[Bulleted markdown checklist of TODOs for testing the pull request...]${B?`

${B}`:""}
EOF
)"
</example>

Important:
- DO NOT use the ${BY.name} or ${A6} tools
- Return the PR URL when you're done, so the user can see it

# Other common operations
- View comments on a Github PR: gh api repos/foo/bar/pulls/123/comments`
}
// @from(Start 6681541, End 6681639)
IGA = L(() => {
  yR();
  MB();
  wF();
  YS();
  kt();
  V0();
  CkA();
  _0();
  $J();
  dH()
})
// @from(Start 6681642, End 6681827)
function Pm1(A) {
  if (/\d\s*<<\s*\d/.test(A) || /\[\[\s*\d+\s*<<\s*\d+\s*\]\]/.test(A) || /\$\(\(.*<<.*\)\)/.test(A)) return !1;
  return /<<-?\s*(?:(['"]?)(\w+)\1|\\(\w+))/.test(A)
}
// @from(Start 6681829, End 6681974)
function pU6(A) {
  let Q = /'(?:[^'\\]|\\.)*\n(?:[^'\\]|\\.)*'/,
    B = /"(?:[^"\\]|\\.)*\n(?:[^"\\]|\\.)*"/;
  return Q.test(A) || B.test(A)
}
// @from(Start 6681976, End 6682201)
function zOB(A, Q = !0) {
  if (Pm1(A) || pU6(A)) {
    let G = `'${A.replace(/'/g,`'"'"'`)}'`;
    if (Pm1(A)) return G;
    return Q ? `${G} < /dev/null` : G
  }
  if (Q) return z8([A, "<", "/dev/null"]);
  return z8([A])
}
// @from(Start 6682203, End 6682270)
function lU6(A) {
  return /(?:^|[\s;&|])<(?![<(])\s*\S+/.test(A)
}
// @from(Start 6682272, End 6682353)
function UOB(A) {
  if (Pm1(A)) return !1;
  if (lU6(A)) return !1;
  return !0
}
// @from(Start 6682358, End 6682383)
$OB = L(() => {
  dK()
})
// @from(Start 6682386, End 6682710)
function qOB(A) {
  if (A.includes("`")) return z8([A, "<", "/dev/null"]);
  let Q = JW(A);
  if (!Q.success) return z8([A, "<", "/dev/null"]);
  let B = Q.tokens,
    G = iU6(B);
  if (G <= 0) return z8([A, "<", "/dev/null"]);
  let Z = [...wOB(B, 0, G), "< /dev/null", ...wOB(B, G, B.length)];
  return z8([Z.join(" ")])
}
// @from(Start 6682712, End 6682834)
function iU6(A) {
  for (let Q = 0; Q < A.length; Q++) {
    let B = A[Q];
    if (jm1(B, "|")) return Q
  }
  return -1
}
// @from(Start 6682836, End 6683925)
function wOB(A, Q, B) {
  let G = [],
    Z = !1;
  for (let I = Q; I < B; I++) {
    let Y = A[I];
    if (typeof Y === "string" && /^[012]$/.test(Y) && I + 2 < B && jm1(A[I + 1])) {
      let J = A[I + 1],
        W = A[I + 2];
      if (J.op === ">&" && typeof W === "string" && /^[012]$/.test(W)) {
        G.push(`${Y}>&${W}`), I += 2;
        continue
      }
      if (J.op === ">" && W === "/dev/null") {
        G.push(`${Y}>/dev/null`), I += 2;
        continue
      }
      if (J.op === ">" && typeof W === "string" && W.startsWith("&")) {
        let X = W.slice(1);
        if (/^[012]$/.test(X)) {
          G.push(`${Y}>&${X}`), I += 2;
          continue
        }
      }
    }
    if (typeof Y === "string")
      if (!Z && nU6(Y)) {
        let W = Y.indexOf("="),
          X = Y.slice(0, W),
          V = Y.slice(W + 1),
          F = z8([V]);
        G.push(`${X}=${F}`)
      } else Z = !0, G.push(z8([Y]));
    else if (jm1(Y)) {
      if (Y.op === "glob" && "pattern" in Y) G.push(Y.pattern);
      else if (G.push(Y.op), aU6(Y.op)) Z = !1
    }
  }
  return G
}
// @from(Start 6683927, End 6683990)
function nU6(A) {
  return /^[A-Za-z_][A-Za-z0-9_]*=/.test(A)
}
// @from(Start 6683992, End 6684058)
function aU6(A) {
  return A === "&&" || A === "||" || A === ";"
}
// @from(Start 6684060, End 6684173)
function jm1(A, Q) {
  if (!A || typeof A !== "object" || !("op" in A)) return !1;
  return Q ? A.op === Q : !0
}
// @from(Start 6684178, End 6684203)
NOB = L(() => {
  dK()
})
// @from(Start 6684465, End 6684619)
function A$6() {
  let A = Y9A(),
    Q = z8([A.rgPath]),
    B = A.rgArgs.map((G) => z8([G]));
  return A.rgArgs.length > 0 ? `${Q} ${B.join(" ")}` : Q
}
// @from(Start 6684621, End 6684757)
function km1(A) {
  let Q = A.includes("zsh") ? ".zshrc" : A.includes("bash") ? ".bashrc" : ".profile";
  return _m1(UrA.homedir(), Q)
}
// @from(Start 6684759, End 6686830)
function Q$6(A) {
  let Q = A.endsWith(".zshrc"),
    B = "";
  if (Q) B += `
      echo "# Functions" >> "$SNAPSHOT_FILE"

      # Force autoload all functions first
      typeset -f > /dev/null 2>&1

      # Now get user function names - filter system ones and write directly to file
      typeset +f | grep -vE '^(_|__)' | while read func; do
        typeset -f "$func" >> "$SNAPSHOT_FILE"
      done
    `;
  else B += `
      echo "# Functions" >> "$SNAPSHOT_FILE"

      # Force autoload all functions first
      declare -f > /dev/null 2>&1

      # Now get user function names - filter system ones and give the rest to eval in b64 encoding
      declare -F | cut -d' ' -f3 | grep -vE '^(_|__)' | while read func; do
        # Encode the function to base64, preserving all special characters
        encoded_func=$(declare -f "$func" | base64 )
        # Write the function definition to the snapshot
        echo "eval ${Sm1}"${Sm1}$(echo '$encoded_func' | base64 -d)${Sm1}" > /dev/null 2>&1" >> "$SNAPSHOT_FILE"
      done
    `;
  if (Q) B += `
      echo "# Shell Options" >> "$SNAPSHOT_FILE"
      setopt | sed 's/^/setopt /' | head -n 1000 >> "$SNAPSHOT_FILE"
    `;
  else B += `
      echo "# Shell Options" >> "$SNAPSHOT_FILE"
      shopt -p | head -n 1000 >> "$SNAPSHOT_FILE"
      set -o | grep "on" | awk '{print "set -o " $1}' | head -n 1000 >> "$SNAPSHOT_FILE"
      echo "shopt -s expand_aliases" >> "$SNAPSHOT_FILE"
    `;
  return B += `
      echo "# Aliases" >> "$SNAPSHOT_FILE"
      # Filter out winpty aliases on Windows to avoid "stdin is not a tty" errors
      # Git Bash automatically creates aliases like "alias node='winpty node.exe'" for
      # programs that need Win32 Console in mintty, but winpty fails when there's no TTY
      if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]]; then
        alias | grep -v "='winpty " | sed 's/^alias //g' | sed 's/^/alias -- /' | head -n 1000 >> "$SNAPSHOT_FILE"
      else
        alias | sed 's/^alias //g' | sed 's/^/alias -- /' | head -n 1000 >> "$SNAPSHOT_FILE"
      fi
  `, B
}
// @from(Start 6686832, End 6687191)
function B$6() {
  if (!bZ()) return null;
  try {
    let A = UX() ? process.execPath : process.argv[1];
    if (!A) return null;
    try {
      A = oU6(A)
    } catch {}
    if (dQ() === "windows") A = rj(A);
    return {
      cliPath: A,
      args: ["--mcp-cli"]
    }
  } catch (A) {
    return AA(A instanceof Error ? A : Error(String(A))), null
  }
}
// @from(Start 6687193, End 6688231)
function G$6() {
  let A = process.env.PATH;
  if (dQ() === "windows") try {
    A = tU6("echo $PATH", {
      encoding: "utf8"
    }).trim()
  } catch {}
  let Q = A$6(),
    B = B$6(),
    G = "";
  if (G += `
      # Check for rg availability
      echo "# Check for rg availability" >> "$SNAPSHOT_FILE"
      echo "if ! command -v rg >/dev/null 2>&1; then" >> "$SNAPSHOT_FILE"
      echo '  alias rg='"'${Q.replace(/'/g,"'\\''")}'" >> "$SNAPSHOT_FILE"
      echo "fi" >> "$SNAPSHOT_FILE"
  `, B) {
    let Z = z8([B.cliPath]),
      I = B.args.map((J) => z8([J])),
      Y = `${Z} ${I.join(" ")}`;
    G += `

      # Check for mcp-cli availability
      echo "# Check for mcp-cli availability" >> "$SNAPSHOT_FILE"
      echo "if ! command -v mcp-cli >/dev/null 2>&1; then" >> "$SNAPSHOT_FILE"
      echo '  alias mcp-cli='"'${Y.replace(/'/g,"'\\''")}'" >> "$SNAPSHOT_FILE"
      echo "fi" >> "$SNAPSHOT_FILE"
    `
  }
  return G += `

      # Add PATH to the file
      echo "export PATH=${z8([A||""])}" >> "$SNAPSHOT_FILE"
  `, G
}
// @from(Start 6688233, End 6689258)
function Z$6(A, Q, B) {
  let G = km1(A),
    Z = G.endsWith(".zshrc"),
    I = B ? Q$6(G) : !Z ? 'echo "shopt -s expand_aliases" >> "$SNAPSHOT_FILE"' : "",
    Y = G$6();
  return `SNAPSHOT_FILE=${z8([Q])}
      ${B?`source "${G}" < /dev/null`:"# No user config file to source"}

      # First, create/clear the snapshot file
      echo "# Snapshot file" >| "$SNAPSHOT_FILE"

      # When this file is sourced, we first unalias to avoid conflicts
      # This is necessary because aliases get "frozen" inside function definitions at definition time,
      # which can cause unexpected behavior when functions use commands that conflict with aliases
      echo "# Unset all aliases to avoid conflicts with functions" >> "$SNAPSHOT_FILE"
      echo "unalias -a 2>/dev/null || true" >> "$SNAPSHOT_FILE"

      ${I}

      ${Y}

      # Exit silently on success, only report errors
      if [ ! -f "$SNAPSHOT_FILE" ]; then
        echo "Error: Snapshot file was not created at $SNAPSHOT_FILE" >&2
        exit 1
      fi
    `
}
// @from(Start 6689263, End 6689273)
Sm1 = "\\"
// @from(Start 6689277, End 6689286)
LOB = 1e4
// @from(Start 6689290, End 6692616)
MOB = async (A) => {
    let Q = A.includes("zsh") ? "zsh" : A.includes("bash") ? "bash" : "sh";
    return g(`Creating shell snapshot for ${Q} (${A})`), new Promise(async (B) => {
      try {
        let G = km1(A);
        g(`Looking for shell config file: ${G}`);
        let Z = P$A(G);
        if (!Z) g(`Shell config file not found: ${G}, creating snapshot with Claude Code defaults only`);
        let I = Date.now(),
          Y = Math.random().toString(36).substring(2, 8),
          J = _m1(MQ(), "shell-snapshots");
        g(`Snapshots directory: ${J}`);
        let W = _m1(J, `snapshot-${Q}-${I}-${Y}.sh`);
        rU6(J, {
          recursive: !0
        });
        let X = Z$6(A, W, Z);
        g(`Creating snapshot at: ${W}`), g(`Shell binary exists: ${P$A(A)}`), g(`Execution timeout: ${LOB}ms`), eU6(A, ["-c", "-l", X], {
          env: {
            ...process.env.CLAUDE_CODE_DONT_INHERIT_ENV ? {} : process.env,
            SHELL: A,
            GIT_EDITOR: "true",
            CLAUDECODE: "1"
          },
          timeout: LOB,
          maxBuffer: 1048576,
          encoding: "utf8"
        }, async (V, F, K) => {
          if (V) {
            let D = V;
            if (g(`Shell snapshot creation failed: ${V.message}`), g("Error details:"), g(`  - Error code: ${D?.code}`), g(`  - Error signal: ${D?.signal}`), g(`  - Error killed: ${D?.killed}`), g(`  - Shell path: ${A}`), g(`  - Config file: ${km1(A)}`), g(`  - Config file exists: ${Z}`), g(`  - Working directory: ${W0()}`), g(`  - Claude home: ${MQ()}`), g(`Full snapshot script:
${X}`), F) g(`stdout output (${F.length} chars):
${F}`);
            else g("No stdout output captured");
            if (K) g(`stderr output (${K.length} chars): ${K}`);
            else g("No stderr output captured");
            AA(Error(`Failed to create shell snapshot: ${V.message}`));
            let H = D?.signal ? UrA.constants.signals[D.signal] : void 0;
            GA("tengu_shell_snapshot_failed", {
              stderr_length: K?.length || 0,
              has_error_code: !!D?.code,
              error_signal_number: H,
              error_killed: D?.killed
            }), B(void 0)
          } else if (P$A(W)) {
            let D = sU6(W).size;
            g(`Shell snapshot created successfully (${D} bytes)`), PG(async () => {
              try {
                if (P$A(W)) RA().unlinkSync(W), g(`Cleaned up session snapshot: ${W}`)
              } catch (H) {
                g(`Error cleaning up session snapshot: ${H}`)
              }
            }), B(W)
          } else {
            g(`Shell snapshot file not found after creation: ${W}`), g(`Checking if parent directory still exists: ${J}`);
            let D = P$A(J);
            if (g(`Parent directory exists: ${D}`), D) try {
              let H = RA().readdirSync(J);
              g(`Directory contains ${H.length} files`)
            } catch (H) {
              g(`Could not read directory contents: ${H}`)
            }
            GA("tengu_shell_unknown_error", {}), B(void 0)
          }
        })
      } catch (G) {
        if (g(`Unexpected error during snapshot creation: ${G}`), G instanceof Error) g(`Error stack trace: ${G.stack}`);
        AA(G instanceof Error ? G : Error(String(G))), GA("tengu_shell_snapshot_error", {}), B(void 0)
      }
    })
  }
// @from(Start 6692622, End 6692736)
OOB = L(() => {
  dK();
  g1();
  q0();
  hQ();
  HH();
  AQ();
  Q3();
  V0();
  sj();
  U2();
  H9A();
  dH()
})
// @from(Start 6693042, End 6693264)
function ROB(A) {
  try {
    return F$6(A, I$6.X_OK), !0
  } catch (Q) {
    try {
      return TOB(`${A} --version`, {
        timeout: 1000,
        stdio: "ignore"
      }), !0
    } catch {
      return !1
    }
  }
}
// @from(Start 6693266, End 6693425)
function D$6(A) {
  if (A.includes("zsh") || A.includes("bash")) return "{ shopt -u extglob || setopt NO_EXTENDED_GLOB; } 2>/dev/null || true";
  return null
}
// @from(Start 6693427, End 6694369)
function H$6() {
  let A = (V) => {
      try {
        return TOB(`which ${V}`, {
          stdio: ["ignore", "pipe", "ignore"]
        }).toString().trim()
      } catch {
        return null
      }
    },
    Q = process.env.SHELL,
    B = Q && (Q.includes("bash") || Q.includes("zsh")),
    G = Q?.includes("bash"),
    Z = A("zsh"),
    I = A("bash"),
    Y = ["/bin", "/usr/bin", "/usr/local/bin", "/opt/homebrew/bin"],
    W = (G ? ["bash", "zsh"] : ["zsh", "bash"]).flatMap((V) => Y.map((F) => `${F}/${V}`));
  if (G) {
    if (I) W.unshift(I);
    if (Z) W.push(Z)
  } else {
    if (Z) W.unshift(Z);
    if (I) W.push(I)
  }
  if (B && ROB(Q)) W.unshift(Q);
  let X = W.find((V) => V && ROB(V));
  if (!X) {
    let V = "No suitable shell found. Claude CLI requires a Posix shell environment. Please ensure you have a valid shell installed and the SHELL environment variable set.";
    throw AA(Error(V)), Error(V)
  }
  return X
}
// @from(Start 6694370, End 6694582)
async function C$6() {
  let A = H$6(),
    Q;
  try {
    Q = await MOB(A)
  } catch (B) {
    g(`Failed to create shell snapshot: ${B}`), Q = void 0
  }
  return {
    binShell: A,
    snapshotFilePath: Q
  }
}
// @from(Start 6694583, End 6696957)
async function $rA(A, Q, B, G, Z, I, Y, J) {
  let W = B || K$6,
    {
      binShell: X,
      snapshotFilePath: V
    } = await j$A();
  if (G) X = G, V = void 0;
  let F = Math.floor(Math.random() * 65536).toString(16).padStart(4, "0"),
    K = POB.tmpdir();
  if (dQ() === "windows") K = rj(K);
  let D = `${K}/claude-${F}-cwd`,
    H = UOB(A),
    C = zOB(A, H);
  if (!Y && A.includes("|") && H) C = qOB(A);
  let E = [];
  if (V) {
    if (!J$6(V)) g(`Snapshot file missing, recreating: ${V}`), j$A.cache?.clear?.(), V = (await j$A()).snapshotFilePath;
    if (V) {
      let y = dQ() === "windows" ? rj(V) : V;
      E.push(`source ${z8([y])}`)
    }
  }
  let U = MNB();
  if (U) E.push(U);
  let q = D$6(X);
  if (q) E.push(q);
  E.push(`eval ${C}`), E.push(`pwd -P >| ${D}`);
  let w = E.join(" && ");
  if (process.env.CLAUDE_CODE_SHELL_PREFIX) w = NsA(process.env.CLAUDE_CODE_SHELL_PREFIX, w);
  let N = UD1();
  if (Q.aborted) return $NB();
  if (Y) {
    w = await nQ.wrapWithSandbox(w, X, void 0, Q);
    try {
      let y = RA(),
        v = "/tmp/claude";
      if (!y.existsSync("/tmp/claude")) y.mkdirSync("/tmp/claude")
    } catch (y) {
      g(`Failed to create /tmp/claude directory: ${y}`)
    }
  }
  let R = (process.env.CLAUDE_BASH_NO_LOGIN === "true" || process.env.CLAUDE_BASH_NO_LOGIN === "1") && V !== void 0,
    T = ["-c", ...R ? [] : ["-l"], w];
  if (R) g("Spawning shell without login (-l flag skipped)");
  try {
    let y = W$6(X, T, {
        env: {
          ...process.env,
          SHELL: X,
          GIT_EDITOR: "true",
          CLAUDECODE: "1",
          ...{},
          ...Y ? {
            TMPDIR: "/tmp/claude"
          } : {}
        },
        cwd: N,
        detached: !0
      }),
      v = qsA(y, Q, W, Z, J);
    return v.result.then(async (x) => {
      if (x && !I && !x.backgroundTaskId) try {
        Bq(Y$6(D, {
          encoding: "utf8"
        }).trim(), N)
      } catch {
        GA("tengu_shell_set_cwd", {
          success: !1
        })
      }
    }), v
  } catch (y) {
    return g(`Shell exec error: ${y instanceof Error?y.message:String(y)}`), {
      status: "killed",
      background: () => null,
      kill: () => {},
      result: Promise.resolve({
        code: 126,
        stdout: "",
        stderr: y instanceof Error ? y.message : String(y),
        interrupted: !1
      })
    }
  }
}
// @from(Start 6696959, End 6697222)
function Bq(A, Q) {
  let B = X$6(A) ? A : V$6(Q || RA().cwd(), A);
  if (!RA().existsSync(B)) throw Error(`Path "${B}" does not exist`);
  let G = RA().realpathSync(B);
  LE0(G);
  try {
    GA("tengu_shell_set_cwd", {
      success: !0
    })
  } catch (Z) {}
}
// @from(Start 6697227, End 6697240)
K$6 = 1800000
// @from(Start 6697244, End 6697247)
j$A
// @from(Start 6697253, End 6697429)
u_ = L(() => {
  dK();
  hu1();
  $OB();
  g1();
  q0();
  fu1();
  AQ();
  _0();
  H9A();
  Q3();
  V0();
  NOB();
  OOB();
  l2();
  U2();
  $J();
  D$A();
  j$A = s1(C$6)
})
// @from(Start 6697470, End 6697704)
function Ff(A) {
  let Q = A.split(`
`),
    B = 0;
  while (B < Q.length && Q[B]?.trim() === "") B++;
  let G = Q.length - 1;
  while (G >= 0 && Q[G]?.trim() === "") G--;
  if (B > G) return "";
  return Q.slice(B, G + 1).join(`
`)
}
// @from(Start 6697706, End 6698194)
function m_(A) {
  let Q = /^data:image\/[a-z0-9.+_-]+;base64,/i.test(A);
  if (Q) return {
    totalLines: 1,
    truncatedContent: A,
    isImage: Q
  };
  let B = Ge();
  if (A.length <= B) return {
    totalLines: A.split(`
`).length,
    truncatedContent: A,
    isImage: Q
  };
  let G = A.slice(0, B),
    Z = A.slice(B).split(`
`).length,
    I = `${G}

... [${Z} lines truncated] ...`;
  return {
    totalLines: A.split(`
`).length,
    truncatedContent: I,
    isImage: Q
  }
}
// @from(Start 6698196, End 6698347)
function qrA(A) {
  if (IX1() || !qT(W0(), A)) {
    if (Bq(uQ()), !IX1()) return GA("tengu_bash_tool_reset_to_original_dir", {}), !0
  }
  return !1
}
// @from(Start 6698348, End 6699917)
async function SOB(A, Q, B, G) {
  let I = (await uX({
    systemPrompt: [`Extract any file paths that this command reads or modifies. For commands like "git diff" and "cat", include the paths of files being shown. Use paths verbatim -- don't add any slashes or try to resolve them. Do not try to infer paths that were not explicitly listed in the command output.

IMPORTANT: Commands that do not display the contents of the files should not return any filepaths. For eg. "ls", pwd", "find". Even more complicated commands that don't display the contents should not be considered: eg "find . -type f -exec ls -la {} + | sort -k5 -nr | head -5"

First, determine if the command displays the contents of the files. If it does, then <is_displaying_contents> tag should be true. If it does not, then <is_displaying_contents> tag should be false.

Format your response as:
<is_displaying_contents>
true
</is_displaying_contents>

<filepaths>
path/to/file1
path/to/file2
</filepaths>

If no files are read or modified, return empty filepaths tags:
<filepaths>
</filepaths>

Do not include any other text in your response.`],
    userPrompt: `Command: ${A}
Output: ${Q}`,
    enablePromptCaching: !0,
    signal: B,
    options: {
      querySource: "bash_extract_command_paths",
      agents: [],
      isNonInteractiveSession: G,
      hasAppendSystemPrompt: !1,
      mcpTools: [],
      agentIdOrSessionId: e1()
    }
  })).message.content.filter((Y) => Y.type === "text").map((Y) => Y.text).join("");
  return B9(I, "filepaths")?.trim().split(`
`).filter(Boolean) || []
}
// @from(Start 6699919, End 6700431)
function _OB(A, Q) {
  let B = RA(),
    G = e1(),
    Z = jOB("/tmp/claude/mcp-outputs", G),
    I = new Date().toISOString().replace(/[:.]/g, "-"),
    J = `mcp-output-${Q.replace(/[^a-zA-Z0-9_-]/g,"_").slice(0,50)}-${I}.json`,
    W = jOB(Z, J);
  if (!NrA(Z)) return AA(Error(`Failed to create directory for MCP output: ${Z}`)), "";
  try {
    return B.writeFileSync(W, A, {
      encoding: "utf8",
      flush: !0
    }), W
  } catch (X) {
    return AA(X instanceof Error ? X : Error(String(X))), ""
  }
}
// @from(Start 6700433, End 6700879)
function kOB(A) {
  let Q = [],
    B = 0,
    G = 0;
  for (let I of A)
    if (I.type === "image") G++;
    else if (I.type === "text" && "text" in I) {
    B++;
    let Y = I.text.slice(0, 200);
    Q.push(Y + (I.text.length > 200 ? "..." : ""))
  }
  let Z = [];
  if (G > 0) Z.push(`[${G} image${G>1?"s":""}]`);
  if (B > 0) Z.push(`[${B} text block${B>1?"s":""}]`);
  return `MCP Result: ${Z.join(", ")}${Q.length>0?`

`+Q.join(`

`):""}`
}
// @from(Start 6700884, End 6700941)
wrA = (A) => `${A.trim()}
Shell cwd was reset to ${uQ()}`
// @from(Start 6700947, End 6701060)
Np = L(() => {
  hQ();
  fZ();
  cQ();
  IGA();
  EJ();
  _0();
  q0();
  U2();
  u_();
  AQ();
  R9();
  g1()
})
// @from(Start 6701063, End 6703754)
function yOB() {
  return `You are analyzing output from a bash command to determine if it should be summarized.

Your task is to:
1. Determine if the output contains mostly repetitive logs, verbose build output, or other "log spew"
2. If it does, extract only the relevant information (errors, test results, completion status, etc.)
3. Consider the conversation context - if the user specifically asked to see detailed output, preserve it

You MUST output your response using XML tags in the following format:
<should_summarize>true/false</should_summarize>
<reason>reason for why you decided to summarize or not summarize the output</reason>
<summary>markdown summary as described below (only if should_summarize is true)</summary>

If should_summarize is true, include all three tags with a comprehensive summary.
If should_summarize is false, include only the first two tags and omit the summary tag.

Summary: The summary should be extremely comprehensive and detailed in markdown format. Especially consider the converstion context to determine what to focus on.
Freely copy parts of the output verbatim into the summary if you think it is relevant to the conversation context or what the user is asking for.
It's fine if the summary is verbose. The summary should contain the following sections: (Make sure to include all of these sections)
1. Overview: An overview of the output including the most interesting information summarized.
2. Detailed summary: An extremely detailed summary of the output.
3. Errors: List of relevant errors that were encountered. Include snippets of the output wherever possible.
4. Verbatim output: Copy any parts of the provided output verbatim that are relevant to the conversation context. This is critical. Make sure to include ATLEAST 3 snippets of the output verbatim. 
5. DO NOT provide a recommendation. Just summarize the facts.

Reason: If providing a reason, it should comprehensively explain why you decided not to summarize the output.

Examples of when to summarize:
- Verbose build logs with only the final status being important. Eg. if we are running npm run build to test if our code changes build.
- Test output where only the pass/fail results matter
- Repetitive debug logs with a few key errors

Examples of when NOT to summarize:
- User explicitly asked to see the full output
- Output contains unique, non-repetitive information
- Error messages that need full stack traces for debugging


CRITICAL: You MUST start your response with the <should_summarize> tag as the very first thing. Do not include any other text before the first tag. The summary tag can contain markdown format, but ensure all XML tags are properly closed.`
}
// @from(Start 6703756, End 6704022)
function xOB(A, Q, B) {
  return `Command executed: \`${A}\`

Recent conversation context:
${Q||"No recent conversation context"}

Bash output to analyze:
${B}

Should this output be summarized? If yes, provide a summary focusing on the most relevant information.`
}
// @from(Start 6704108, End 6704269)
function q$6(A) {
  let Q = new Date().toISOString().replace(/[:.]/g, "-"),
    B = z$6("sha256").update(A).digest("hex").slice(0, 8);
  return `${Q}-${B}.txt`
}
// @from(Start 6704271, End 6704349)
function N$6(A, Q, B) {
  return `COMMAND: ${A}

STDOUT:
${Q}

STDERR:
${B}`
}
// @from(Start 6704351, End 6704736)
function L$6(A, Q, B) {
  let G = RA(),
    Z = e1(),
    I = vOB(cH(uQ()), w$6, Z),
    Y = vOB(I, q$6(B));
  if (!NrA(I)) return AA(Error(`Failed to create directory for bash output: ${I}`)), "";
  try {
    return G.writeFileSync(Y, N$6(B, A, Q), {
      encoding: "utf-8",
      flush: !0
    }), Y
  } catch (J) {
    return AA(J instanceof Error ? J : Error(String(J))), ""
  }
}
// @from(Start 6704738, End 6704824)
function M$6(A) {
  let Q = A.slice(-$$6),
    B = WZ(Q);
  return JSON.stringify(B)
}
// @from(Start 6704825, End 6706497)
async function bOB(A, Q, B, G, Z = []) {
  let I = [A, Q].filter(Boolean).join(`
`),
    {
      isImage: Y
    } = m_(Ff(A));
  if (Y) return {
    shouldSummarize: !1,
    reason: "image_data"
  };
  if (I.length < U$6) return {
    shouldSummarize: !1,
    reason: "below_threshold"
  };
  try {
    let J = M$6(Z),
      W = yOB(),
      X = xOB(B, J, I),
      V = Date.now(),
      F = await uX({
        systemPrompt: [W],
        userPrompt: X,
        enablePromptCaching: !0,
        options: {
          querySource: "bash_output_summarization",
          hasAppendSystemPrompt: !1,
          isNonInteractiveSession: !1,
          agents: [],
          mcpTools: [],
          agentIdOrSessionId: e1()
        },
        signal: G.signal
      }),
      K = Date.now() - V,
      D = F.message.content.filter((q) => q.type === "text").map((q) => q.text).join(""),
      H = B9(D, "should_summarize"),
      C = B9(D, "reason"),
      E = B9(D, "summary")?.trim() || "";
    if (!H) return {
      shouldSummarize: !1,
      reason: "parse_error",
      queryDurationMs: K
    };
    if (H === "true" && E) {
      let q = L$6(A, Q, B);
      return {
        shouldSummarize: !0,
        summary: O$6(E, q),
        rawOutputPath: q,
        queryDurationMs: K,
        ...C ? {
          modelReason: C
        } : {}
      }
    }
    return {
      shouldSummarize: !1,
      reason: "model_decided_user_needs_full_output",
      queryDurationMs: K,
      ...C ? {
        modelReason: C
      } : {}
    }
  } catch (J) {
    return AA(J instanceof Error ? J : Error(String(J))), {
      shouldSummarize: !1,
      reason: "summarization_error"
    }
  }
}
// @from(Start 6706499, End 6706734)
function O$6(A, Q) {
  let G = Q ? `

Note: The complete bash output is available at ${Q}. You can use Read or Grep tools to search for specific information not included in this summary.` : "";
  return `[Summarized output]
${A}${G}`
}
// @from(Start 6706739, End 6706749)
U$6 = 5000
// @from(Start 6706753, End 6706761)
$$6 = 10
// @from(Start 6706765, End 6706785)
w$6 = "bash-outputs"
// @from(Start 6706791, End 6706872)
fOB = L(() => {
  fZ();
  Np();
  AQ();
  g1();
  cQ();
  S7();
  _0();
  R9()
})
// @from(Start 6706875, End 6707018)
function ym1(A) {
  if (!A) return "";
  let Q = Array.isArray(A) ? A.join("") : A,
    {
      truncatedContent: B
    } = m_(Q);
  return B
}
// @from(Start 6707020, End 6707321)
function R$6(A) {
  if (typeof A["image/png"] === "string") return {
    image_data: A["image/png"].replace(/\s/g, ""),
    media_type: "image/png"
  };
  if (typeof A["image/jpeg"] === "string") return {
    image_data: A["image/jpeg"].replace(/\s/g, ""),
    media_type: "image/jpeg"
  };
  return
}
// @from(Start 6707323, End 6707785)
function T$6(A) {
  switch (A.output_type) {
    case "stream":
      return {
        output_type: A.output_type, text: ym1(A.text)
      };
    case "execute_result":
    case "display_data":
      return {
        output_type: A.output_type, text: ym1(A.data?.["text/plain"]), image: A.data && R$6(A.data)
      };
    case "error":
      return {
        output_type: A.output_type, text: ym1(`${A.ename}: ${A.evalue}
${A.traceback.join(`
`)}`)
      }
  }
}
// @from(Start 6707787, End 6708444)
function hOB(A, Q, B, G) {
  let Z = A.id ?? `cell-${Q}`,
    I = {
      cellType: A.cell_type,
      source: Array.isArray(A.source) ? A.source.join("") : A.source,
      execution_count: A.cell_type === "code" ? A.execution_count || void 0 : void 0,
      cell_id: Z
    };
  if (A.cell_type === "code") I.language = B;
  if (A.cell_type === "code" && A.outputs?.length) {
    let Y = A.outputs.map(T$6);
    if (!G && JSON.stringify(Y).length > 1e4) I.outputs = [{
      output_type: "stream",
      text: `Outputs are too large to include. Use ${C9} with: cat <notebook_path> | jq '.cells[${Q}].outputs'`
    }];
    else I.outputs = Y
  }
  return I
}
// @from(Start 6708446, End 6708777)
function P$6(A) {
  let Q = [];
  if (A.cellType !== "code") Q.push(`<cell_type>${A.cellType}</cell_type>`);
  if (A.language !== "python" && A.cellType === "code") Q.push(`<language>${A.language}</language>`);
  return {
    text: `<cell id="${A.cell_id}">${Q.join("")}${A.source}</cell id="${A.cell_id}">`,
    type: "text"
  }
}
// @from(Start 6708779, End 6709053)
function j$6(A) {
  let Q = [];
  if (A.text) Q.push({
    text: `
${A.text}`,
    type: "text"
  });
  if (A.image) Q.push({
    type: "image",
    source: {
      data: A.image.image_data,
      media_type: A.image.media_type,
      type: "base64"
    }
  });
  return Q
}
// @from(Start 6709055, End 6709150)
function S$6(A) {
  let Q = P$6(A),
    B = A.outputs?.flatMap(j$6);
  return [Q, ...B ?? []]
}
// @from(Start 6709152, End 6709555)
function gOB(A, Q) {
  let B = b9(A),
    G = RA().readFileSync(B, {
      encoding: "utf-8"
    }),
    Z = JSON.parse(G),
    I = Z.metadata.language_info?.name ?? "python";
  if (Q) {
    let Y = Z.cells.find((J) => J.id === Q);
    if (!Y) throw Error(`Cell with ID "${Q}" not found in notebook`);
    return [hOB(Y, Z.cells.indexOf(Y), I, !0)]
  }
  return Z.cells.map((Y, J) => hOB(Y, J, I, !1))
}
// @from(Start 6709557, End 6709891)
function uOB(A, Q) {
  let B = A.flatMap(S$6);
  return {
    tool_use_id: Q,
    type: "tool_result",
    content: B.reduce((G, Z) => {
      if (G.length === 0) return [Z];
      let I = G[G.length - 1];
      if (I && I.type === "text" && Z.type === "text") return I.text += `
` + Z.text, G;
      return [...G, Z]
    }, [])
  }
}
// @from(Start 6709893, End 6710044)
function S$A(A) {
  let Q = A.match(/^cell-(\d+)$/);
  if (Q && Q[1]) {
    let B = parseInt(Q[1], 10);
    return isNaN(B) ? void 0 : B
  }
  return
}
// @from(Start 6710049, End 6710090)
LrA = L(() => {
  Np();
  yI();
  AQ()
})
// @from(Start 6710096, End 6710447)
xm1 = function() {
  let {
    crypto: A
  } = globalThis;
  if (A?.randomUUID) return xm1 = A.randomUUID.bind(A), A.randomUUID();
  let Q = new Uint8Array(1),
    B = A ? () => A.getRandomValues(Q)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (G) => (+G ^ B() & 15 >> +G / 4).toString(16))
}
// @from(Start 6710453, End 6710502)
mOB = (A) => new Promise((Q) => setTimeout(Q, A))
// @from(Start 6710508, End 6710521)
Lp = "0.70.0"
// @from(Start 6710524, End 6710804)
function _$6() {
  if (typeof Deno < "u" && Deno.build != null) return "deno";
  if (typeof EdgeRuntime < "u") return "edge";
  if (Object.prototype.toString.call(typeof globalThis.process < "u" ? globalThis.process : 0) === "[object process]") return "node";
  return "unknown"
}
// @from(Start 6710806, End 6711680)
function y$6() {
  if (typeof navigator > "u" || !navigator) return null;
  let A = [{
    key: "edge",
    pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
  }, {
    key: "ie",
    pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
  }, {
    key: "ie",
    pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/
  }, {
    key: "chrome",
    pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
  }, {
    key: "firefox",
    pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
  }, {
    key: "safari",
    pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/
  }];
  for (let {
      key: Q,
      pattern: B
    }
    of A) {
    let G = B.exec(navigator.userAgent);
    if (G) {
      let Z = G[1] || 0,
        I = G[2] || 0,
        Y = G[3] || 0;
      return {
        browser: Q,
        version: `${Z}.${I}.${Y}`
      }
    }
  }
  return null
}
// @from(Start 6711685, End 6711791)
lOB = () => {
    return typeof window < "u" && typeof window.document < "u" && typeof navigator < "u"
  }
// @from(Start 6711795, End 6713406)
k$6 = () => {
    let A = _$6();
    if (A === "deno") return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Lp,
      "X-Stainless-OS": cOB(Deno.build.os),
      "X-Stainless-Arch": dOB(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
    if (typeof EdgeRuntime < "u") return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Lp,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
    if (A === "node") return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Lp,
      "X-Stainless-OS": cOB(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": dOB(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
    let Q = y$6();
    if (Q) return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Lp,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${Q.browser}`,
      "X-Stainless-Runtime-Version": Q.version
    };
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": Lp,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": "unknown",
      "X-Stainless-Runtime-Version": "unknown"
    }
  }
// @from(Start 6713410, End 6713662)
dOB = (A) => {
    if (A === "x32") return "x32";
    if (A === "x86_64" || A === "x64") return "x64";
    if (A === "arm") return "arm";
    if (A === "aarch64" || A === "arm64") return "arm64";
    if (A) return `other:${A}`;
    return "unknown"
  }
// @from(Start 6713666, End 6714048)
cOB = (A) => {
    if (A = A.toLowerCase(), A.includes("ios")) return "iOS";
    if (A === "android") return "Android";
    if (A === "darwin") return "MacOS";
    if (A === "win32") return "Windows";
    if (A === "freebsd") return "FreeBSD";
    if (A === "openbsd") return "OpenBSD";
    if (A === "linux") return "Linux";
    if (A) return `Other:${A}`;
    return "Unknown"
  }
// @from(Start 6714052, End 6714055)
pOB
// @from(Start 6714057, End 6714106)
iOB = () => {
    return pOB ?? (pOB = k$6())
  }
// @from(Start 6714112, End 6714126)
vm1 = () => {}
// @from(Start 6714132, End 6714284)
nOB = ({
  headers: A,
  body: Q
}) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(Q)
  }
}
// @from(Start 6714286, End 6715165)
async function MrA(A, Q) {
  let {
    response: B,
    requestLogID: G,
    retryOfRequestLogID: Z,
    startTime: I
  } = Q, Y = await (async () => {
    if (Q.options.stream) {
      if (qF(A).debug("response", B.status, B.url, B.headers, B.body), Q.options.__streamClass) return Q.options.__streamClass.fromSSEResponse(B, Q.controller);
      return lC.fromSSEResponse(B, Q.controller)
    }
    if (B.status === 204) return null;
    if (Q.options.__binaryResponse) return B;
    let W = B.headers.get("content-type")?.split(";")[0]?.trim();
    if (W?.includes("application/json") || W?.endsWith("+json")) {
      let F = await B.json();
      return bm1(F, B)
    }
    return await B.text()
  })();
  return qF(A).debug(`[${G}] response parsed`, Hv({
    retryOfRequestLogID: Z,
    url: B.url,
    status: B.status,
    body: Y,
    durationMs: Date.now() - I
  })), Y
}
// @from(Start 6715167, End 6715369)
function bm1(A, Q) {
  if (!A || typeof A !== "object" || Array.isArray(A)) return A;
  return Object.defineProperty(A, "_request_id", {
    value: Q.headers.get("request-id"),
    enumerable: !1
  })
}
// @from(Start 6715374, End 6715409)
fm1 = L(() => {
  IC1();
  AvA()
})
// @from(Start 6715415, End 6715418)
_$A
// @from(Start 6715420, End 6715422)
Ze
// @from(Start 6715428, End 6716517)
OrA = L(() => {
  Kv();
  fm1();
  Ze = class Ze extends Promise {
    constructor(A, Q, B = MrA) {
      super((G) => {
        G(null)
      });
      this.responsePromise = Q, this.parseResponse = B, _$A.set(this, void 0), fB(this, _$A, A, "f")
    }
    _thenUnwrap(A) {
      return new Ze(N0(this, _$A, "f"), this.responsePromise, async (Q, B) => bm1(A(await this.parseResponse(Q, B), B), B.response))
    }
    asResponse() {
      return this.responsePromise.then((A) => A.response)
    }
    async withResponse() {
      let [A, Q] = await Promise.all([this.parse(), this.asResponse()]);
      return {
        data: A,
        response: Q,
        request_id: Q.headers.get("request-id")
      }
    }
    parse() {
      if (!this.parsedPromise) this.parsedPromise = this.responsePromise.then((A) => this.parseResponse(N0(this, _$A, "f"), A));
      return this.parsedPromise
    }
    then(A, Q) {
      return this.parse().then(A, Q)
    } catch (A) {
      return this.parse().catch(A)
    } finally(A) {
      return this.parse().finally(A)
    }
  };
  _$A = new WeakMap
})
// @from(Start 6716523, End 6716526)
RrA
// @from(Start 6716528, End 6716531)
hm1
// @from(Start 6716533, End 6716536)
TrA
// @from(Start 6716538, End 6716540)
NT
// @from(Start 6716542, End 6716545)
k$A
// @from(Start 6716551, End 6719192)
d_ = L(() => {
  Kv();
  pC();
  fm1();
  OrA();
  Jr();
  hm1 = class hm1 {
    constructor(A, Q, B, G) {
      RrA.set(this, void 0), fB(this, RrA, A, "f"), this.options = G, this.response = Q, this.body = B
    }
    hasNextPage() {
      if (!this.getPaginatedItems().length) return !1;
      return this.nextPageRequestOptions() != null
    }
    async getNextPage() {
      let A = this.nextPageRequestOptions();
      if (!A) throw new vB("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
      return await N0(this, RrA, "f").requestAPIList(this.constructor, A)
    }
    async * iterPages() {
      let A = this;
      yield A;
      while (A.hasNextPage()) A = await A.getNextPage(), yield A
    }
    async * [(RrA = new WeakMap, Symbol.asyncIterator)]() {
      for await (let A of this.iterPages()) for (let Q of A.getPaginatedItems()) yield Q
    }
  };
  TrA = class TrA extends Ze {
    constructor(A, Q, B) {
      super(A, Q, async (G, Z) => new B(G, Z.response, await MrA(G, Z), Z.options))
    }
    async * [Symbol.asyncIterator]() {
      let A = await this;
      for await (let Q of A) yield Q
    }
  };
  NT = class NT extends hm1 {
    constructor(A, Q, B, G) {
      super(A, Q, B, G);
      this.data = B.data || [], this.has_more = B.has_more || !1, this.first_id = B.first_id || null, this.last_id = B.last_id || null
    }
    getPaginatedItems() {
      return this.data ?? []
    }
    hasNextPage() {
      if (this.has_more === !1) return !1;
      return super.hasNextPage()
    }
    nextPageRequestOptions() {
      if (this.options.query?.before_id) {
        let Q = this.first_id;
        if (!Q) return null;
        return {
          ...this.options,
          query: {
            ...rxA(this.options.query),
            before_id: Q
          }
        }
      }
      let A = this.last_id;
      if (!A) return null;
      return {
        ...this.options,
        query: {
          ...rxA(this.options.query),
          after_id: A
        }
      }
    }
  };
  k$A = class k$A extends hm1 {
    constructor(A, Q, B, G) {
      super(A, Q, B, G);
      this.data = B.data || [], this.has_more = B.has_more || !1, this.next_page = B.next_page || null
    }
    getPaginatedItems() {
      return this.data ?? []
    }
    hasNextPage() {
      if (this.has_more === !1) return !1;
      return super.hasNextPage()
    }
    nextPageRequestOptions() {
      let A = this.next_page;
      if (!A) return null;
      return {
        ...this.options,
        query: {
          ...rxA(this.options.query),
          page: A
        }
      }
    }
  }
})
// @from(Start 6719195, End 6719271)
function Ie(A, Q, B) {
  return um1(), new File(A, Q ?? "unknown_file", B)
}
// @from(Start 6719273, End 6719567)
function y$A(A) {
  return (typeof A === "object" && A !== null && (("name" in A) && A.name && String(A.name) || ("url" in A) && A.url && String(A.url) || ("filename" in A) && A.filename && String(A.filename) || ("path" in A) && A.path && String(A.path)) || "").split(/[\\/]/).pop() || void 0
}
// @from(Start 6719569, End 6719962)
function b$6(A) {
  let Q = typeof A === "function" ? A : A.fetch,
    B = aOB.get(Q);
  if (B) return B;
  let G = (async () => {
    try {
      let Z = "Response" in Q ? Q.Response : (await Q("data:,")).constructor,
        I = new FormData;
      if (I.toString() === await new Z(I).text()) return !1;
      return !0
    } catch {
      return !0
    }
  })();
  return aOB.set(Q, G), G
}
// @from(Start 6719967, End 6720358)
um1 = () => {
    if (typeof File > "u") {
      let {
        process: A
      } = globalThis, Q = typeof A?.versions?.node === "string" && parseInt(A.versions.node.split(".")) < 20;
      throw Error("`File` is not defined as a global, which is required for file uploads." + (Q ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""))
    }
  }
// @from(Start 6720362, End 6720458)
mm1 = (A) => A != null && typeof A === "object" && typeof A[Symbol.asyncIterator] === "function"
// @from(Start 6720462, End 6720553)
YGA = async (A, Q) => {
    return {
      ...A,
      body: await f$6(A.body, Q)
    }
  }
// @from(Start 6720555, End 6720558)
aOB
// @from(Start 6720560, End 6720841)
f$6 = async (A, Q) => {
    if (!await b$6(Q)) throw TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
    let B = new FormData;
    return await Promise.all(Object.entries(A || {}).map(([G, Z]) => gm1(B, G, Z))), B
  }
// @from(Start 6720843, End 6720890)
h$6 = (A) => A instanceof Blob && ("name" in A)
// @from(Start 6720892, End 6721880)
gm1 = async (A, Q, B) => {
    if (B === void 0) return;
    if (B == null) throw TypeError(`Received null for "${Q}"; to pass null in FormData, you must use the string 'null'`);
    if (typeof B === "string" || typeof B === "number" || typeof B === "boolean") A.append(Q, String(B));
    else if (B instanceof Response) {
      let G = {},
        Z = B.headers.get("Content-Type");
      if (Z) G = {
        type: Z
      };
      A.append(Q, Ie([await B.blob()], y$A(B), G))
    } else if (mm1(B)) A.append(Q, Ie([await new Response(sxA(B)).blob()], y$A(B)));
    else if (h$6(B)) A.append(Q, Ie([B], y$A(B), {
      type: B.type
    }));
    else if (Array.isArray(B)) await Promise.all(B.map((G) => gm1(A, Q + "[]", G)));
    else if (typeof B === "object") await Promise.all(Object.entries(B).map(([G, Z]) => gm1(A, `${Q}[${G}]`, Z)));
    else throw TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${B} instead`)
  }
// @from(Start 6721886, End 6721924)
JGA = L(() => {
  aOB = new WeakMap
})
// @from(Start 6721926, End 6722559)
async function PrA(A, Q, B) {
  if (um1(), A = await A, Q || (Q = y$A(A)), g$6(A)) {
    if (A instanceof File && Q == null && B == null) return A;
    return Ie([await A.arrayBuffer()], Q ?? A.name, {
      type: A.type,
      lastModified: A.lastModified,
      ...B
    })
  }
  if (u$6(A)) {
    let Z = await A.blob();
    return Q || (Q = new URL(A.url).pathname.split(/[\\/]/).pop()), Ie(await dm1(Z), Q, B)
  }
  let G = await dm1(A);
  if (!B?.type) {
    let Z = G.find((I) => typeof I === "object" && ("type" in I) && I.type);
    if (typeof Z === "string") B = {
      ...B,
      type: Z
    }
  }
  return Ie(G, Q, B)
}
// @from(Start 6722560, End 6722986)
async function dm1(A) {
  let Q = [];
  if (typeof A === "string" || ArrayBuffer.isView(A) || A instanceof ArrayBuffer) Q.push(A);
  else if (sOB(A)) Q.push(A instanceof Blob ? A : await A.arrayBuffer());
  else if (mm1(A))
    for await (let B of A) Q.push(...await dm1(B));
  else {
    let B = A?.constructor?.name;
    throw Error(`Unexpected data type: ${typeof A}${B?`; constructor: ${B}`:""}${m$6(A)}`)
  }
  return Q
}
// @from(Start 6722988, End 6723146)
function m$6(A) {
  if (typeof A !== "object" || A === null) return "";
  return `; props: [${Object.getOwnPropertyNames(A).map((B)=>`"${B}"`).join(", ")}]`
}
// @from(Start 6723151, End 6723362)
sOB = (A) => A != null && typeof A === "object" && typeof A.size === "number" && typeof A.type === "string" && typeof A.text === "function" && typeof A.slice === "function" && typeof A.arrayBuffer === "function"
// @from(Start 6723366, End 6723491)
g$6 = (A) => A != null && typeof A === "object" && typeof A.name === "string" && typeof A.lastModified === "number" && sOB(A)
// @from(Start 6723495, End 6723603)
u$6 = (A) => A != null && typeof A === "object" && typeof A.url === "string" && typeof A.blob === "function"
// @from(Start 6723609, End 6723644)
rOB = L(() => {
  JGA();
  JGA()
})
// @from(Start 6723650, End 6723676)
cm1 = L(() => {
  rOB()
})
// @from(Start 6723682, End 6723696)
oOB = () => {}
// @from(Start 6723698, End 6723754)
class pY {
  constructor(A) {
    this._client = A
  }
}
// @from(Start 6723756, End 6724387)
function* c$6(A) {
  if (!A) return;
  if (tOB in A) {
    let {
      values: G,
      nulls: Z
    } = A;
    yield* G.entries();
    for (let I of Z) yield [I, null];
    return
  }
  let Q = !1,
    B;
  if (A instanceof Headers) B = A.entries();
  else if (GC1(A)) B = A;
  else Q = !0, B = Object.entries(A ?? {});
  for (let G of B) {
    let Z = G[0];
    if (typeof Z !== "string") throw TypeError("expected header name to be a string");
    let I = GC1(G[1]) ? G[1] : [G[1]],
      Y = !1;
    for (let J of I) {
      if (J === void 0) continue;
      if (Q && !Y) Y = !0, yield [Z, null];
      yield [Z, J]
    }
  }
}
// @from(Start 6724392, End 6724395)
tOB
// @from(Start 6724397, End 6724754)
r4 = (A) => {
  let Q = new Headers,
    B = new Set;
  for (let G of A) {
    let Z = new Set;
    for (let [I, Y] of c$6(G)) {
      let J = I.toLowerCase();
      if (!Z.has(J)) Q.delete(I), Z.add(J);
      if (Y === null) Q.delete(I), B.add(J);
      else Q.append(I, Y), B.delete(J)
    }
  }
  return {
    [tOB]: !0,
    values: Q,
    nulls: B
  }
}
// @from(Start 6724760, End 6724836)
CM = L(() => {
  Jr();
  tOB = Symbol.for("brand.privateNullableHeaders")
})
// @from(Start 6724839, End 6724933)
function ARB(A) {
  return A.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent)
}
// @from(Start 6724938, End 6724941)
eOB
// @from(Start 6724943, End 6726307)
p$6 = (A = ARB) => function(B, ...G) {
    if (B.length === 1) return B[0];
    let Z = !1,
      I = [],
      Y = B.reduce((V, F, K) => {
        if (/[?#]/.test(F)) Z = !0;
        let D = G[K],
          H = (Z ? encodeURIComponent : A)("" + D);
        if (K !== G.length && (D == null || typeof D === "object" && D.toString === Object.getPrototypeOf(Object.getPrototypeOf(D.hasOwnProperty ?? eOB) ?? eOB)?.toString)) H = D + "", I.push({
          start: V.length + F.length,
          length: H.length,
          error: `Value of type ${Object.prototype.toString.call(D).slice(8,-1)} is not a valid path parameter`
        });
        return V + F + (K === G.length ? "" : H)
      }, ""),
      J = Y.split(/[?#]/, 1)[0],
      W = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi,
      X;
    while ((X = W.exec(J)) !== null) I.push({
      start: X.index,
      length: X[0].length,
      error: `Value "${X[0]}" can't be safely passed as a path parameter`
    });
    if (I.sort((V, F) => V.start - F.start), I.length > 0) {
      let V = 0,
        F = I.reduce((K, D) => {
          let H = " ".repeat(D.start - V),
            C = "^".repeat(D.length);
          return V = D.start + D.length, K + H + C
        }, "");
      throw new vB(`Path parameters result in path with invalid segments:
${I.map((K)=>K.error).join(`
`)}
${Y}
${F}`)
    }
    return Y
  }
// @from(Start 6726311, End 6726313)
IY
// @from(Start 6726319, End 6726402)
Mp = L(() => {
  pC();
  eOB = Object.freeze(Object.create(null)), IY = p$6(ARB)
})
// @from(Start 6726408, End 6726411)
x$A
// @from(Start 6726417, End 6728052)
pm1 = L(() => {
  d_();
  CM();
  JGA();
  Mp();
  x$A = class x$A extends pY {
    list(A = {}, Q) {
      let {
        betas: B,
        ...G
      } = A ?? {};
      return this._client.getAPIList("/v1/files", NT, {
        query: G,
        ...Q,
        headers: r4([{
          "anthropic-beta": [...B ?? [], "files-api-2025-04-14"].toString()
        }, Q?.headers])
      })
    }
    delete(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.delete(IY`/v1/files/${A}`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "files-api-2025-04-14"].toString()
        }, B?.headers])
      })
    }
    download(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.get(IY`/v1/files/${A}/content`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "files-api-2025-04-14"].toString(),
          Accept: "application/binary"
        }, B?.headers]),
        __binaryResponse: !0
      })
    }
    retrieveMetadata(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.get(IY`/v1/files/${A}`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "files-api-2025-04-14"].toString()
        }, B?.headers])
      })
    }
    upload(A, Q) {
      let {
        betas: B,
        ...G
      } = A;
      return this._client.post("/v1/files", YGA({
        body: G,
        ...Q,
        headers: r4([{
          "anthropic-beta": [...B ?? [], "files-api-2025-04-14"].toString()
        }, Q?.headers])
      }, this._client))
    }
  }
})
// @from(Start 6728058, End 6728061)
v$A
// @from(Start 6728067, End 6728813)
lm1 = L(() => {
  d_();
  CM();
  Mp();
  v$A = class v$A extends pY {
    retrieve(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.get(IY`/v1/models/${A}?beta=true`, {
        ...B,
        headers: r4([{
          ...G?.toString() != null ? {
            "anthropic-beta": G?.toString()
          } : void 0
        }, B?.headers])
      })
    }
    list(A = {}, Q) {
      let {
        betas: B,
        ...G
      } = A ?? {};
      return this._client.getAPIList("/v1/models?beta=true", NT, {
        query: G,
        ...Q,
        headers: r4([{
          ...B?.toString() != null ? {
            "anthropic-beta": B?.toString()
          } : void 0
        }, Q?.headers])
      })
    }
  }
})
// @from(Start 6728819, End 6728822)
jrA
// @from(Start 6728828, End 6729176)
im1 = L(() => {
  jrA = {
    "claude-opus-4-20250514": 8192,
    "claude-opus-4-0": 8192,
    "claude-4-opus-20250514": 8192,
    "anthropic.claude-opus-4-20250514-v1:0": 8192,
    "claude-opus-4@20250514": 8192,
    "claude-opus-4-1-20250805": 8192,
    "anthropic.claude-opus-4-1-20250805-v1:0": 8192,
    "claude-opus-4-1@20250805": 8192
  }
})
// @from(Start 6729179, End 6729318)
function QRB() {
  let A, Q;
  return {
    promise: new Promise((G, Z) => {
      A = G, Q = Z
    }),
    resolve: A,
    reject: Q
  }
}
// @from(Start 6729319, End 6730322)
async function n$6(A, Q = A.messages.at(-1)) {
  if (!Q || Q.role !== "assistant" || !Q.content || typeof Q.content === "string") return null;
  let B = Q.content.filter((Z) => Z.type === "tool_use");
  if (B.length === 0) return null;
  return {
    role: "user",
    content: await Promise.all(B.map(async (Z) => {
      let I = A.tools.find((Y) => Y.name === Z.name);
      if (!I || !("run" in I)) return {
        type: "tool_result",
        tool_use_id: Z.id,
        content: `Error: Tool '${Z.name}' not found`,
        is_error: !0
      };
      try {
        let Y = Z.input;
        if ("parse" in I && I.parse) Y = I.parse(Y);
        let J = await I.run(Y);
        return {
          type: "tool_result",
          tool_use_id: Z.id,
          content: J
        }
      } catch (Y) {
        return {
          type: "tool_result",
          tool_use_id: Z.id,
          content: `Error: ${Y instanceof Error?Y.message:String(Y)}`,
          is_error: !0
        }
      }
    }))
  }
}
// @from(Start 6730327, End 6730330)
SrA
// @from(Start 6730332, End 6730335)
WGA
// @from(Start 6730337, End 6730339)
Ye
// @from(Start 6730341, End 6730343)
zU
// @from(Start 6730345, End 6730348)
b$A
// @from(Start 6730350, End 6730352)
LT
// @from(Start 6730354, End 6730356)
Kf
// @from(Start 6730358, End 6730360)
Op
// @from(Start 6730362, End 6730365)
f$A
// @from(Start 6730367, End 6730370)
nm1
// @from(Start 6730372, End 6730375)
h$A
// @from(Start 6730381, End 6734132)
am1 = L(() => {
  Kv();
  pC();
  CM();
  h$A = class h$A {
    constructor(A, Q, B) {
      SrA.add(this), this.client = A, WGA.set(this, !1), Ye.set(this, !1), zU.set(this, void 0), b$A.set(this, void 0), LT.set(this, void 0), Kf.set(this, void 0), Op.set(this, void 0), f$A.set(this, 0), fB(this, zU, {
        params: {
          ...Q,
          messages: structuredClone(Q.messages)
        }
      }, "f"), fB(this, b$A, {
        ...B,
        headers: r4([{
          "x-stainless-helper": "BetaToolRunner"
        }, B?.headers])
      }, "f"), fB(this, Op, QRB(), "f")
    }
    async * [(WGA = new WeakMap, Ye = new WeakMap, zU = new WeakMap, b$A = new WeakMap, LT = new WeakMap, Kf = new WeakMap, Op = new WeakMap, f$A = new WeakMap, SrA = new WeakSet, Symbol.asyncIterator)]() {
      var A;
      if (N0(this, WGA, "f")) throw new vB("Cannot iterate over a consumed stream");
      fB(this, WGA, !0, "f"), fB(this, Ye, !0, "f"), fB(this, Kf, void 0, "f");
      try {
        while (!0) {
          let Q;
          try {
            if (N0(this, zU, "f").params.max_iterations && N0(this, f$A, "f") >= N0(this, zU, "f").params.max_iterations) break;
            fB(this, Ye, !1, "f"), fB(this, LT, void 0, "f"), fB(this, Kf, void 0, "f"), fB(this, f$A, (A = N0(this, f$A, "f"), A++, A), "f");
            let {
              max_iterations: B,
              ...G
            } = N0(this, zU, "f").params;
            if (G.stream) Q = this.client.beta.messages.stream({
              ...G
            }, N0(this, b$A, "f")), fB(this, LT, Q.finalMessage(), "f"), N0(this, LT, "f").catch(() => {}), yield Q;
            else fB(this, LT, this.client.beta.messages.create({
              ...G,
              stream: !1
            }, N0(this, b$A, "f")), "f"), yield N0(this, LT, "f");
            if (!N0(this, Ye, "f")) {
              let {
                role: I,
                content: Y
              } = await N0(this, LT, "f");
              N0(this, zU, "f").params.messages.push({
                role: I,
                content: Y
              })
            }
            let Z = await N0(this, SrA, "m", nm1).call(this, N0(this, zU, "f").params.messages.at(-1));
            if (Z) N0(this, zU, "f").params.messages.push(Z);
            if (!Z && !N0(this, Ye, "f")) break
          } finally {
            if (Q) Q.abort()
          }
        }
        if (!N0(this, LT, "f")) throw new vB("ToolRunner concluded without a message from the server");
        N0(this, Op, "f").resolve(await N0(this, LT, "f"))
      } catch (Q) {
        throw fB(this, WGA, !1, "f"), N0(this, Op, "f").promise.catch(() => {}), N0(this, Op, "f").reject(Q), fB(this, Op, QRB(), "f"), Q
      }
    }
    setMessagesParams(A) {
      if (typeof A === "function") N0(this, zU, "f").params = A(N0(this, zU, "f").params);
      else N0(this, zU, "f").params = A;
      fB(this, Ye, !0, "f"), fB(this, Kf, void 0, "f")
    }
    async generateToolResponse() {
      let A = await N0(this, LT, "f") ?? this.params.messages.at(-1);
      if (!A) return null;
      return N0(this, SrA, "m", nm1).call(this, A)
    }
    done() {
      return N0(this, Op, "f").promise
    }
    async runUntilDone() {
      if (!N0(this, WGA, "f"))
        for await (let A of this);
      return this.done()
    }
    get params() {
      return N0(this, zU, "f").params
    }
    pushMessages(...A) {
      this.setMessagesParams((Q) => ({
        ...Q,
        messages: [...Q.messages, ...A]
      }))
    }
    then(A, Q) {
      return this.runUntilDone().then(A, Q)
    }
  };
  nm1 = async function(Q) {
    if (N0(this, Kf, "f") !== void 0) return N0(this, Kf, "f");
    return fB(this, Kf, n$6(N0(this, zU, "f").params, Q), "f"), N0(this, Kf, "f")
  }
})
// @from(Start 6734138, End 6734141)
XGA
// @from(Start 6734147, End 6734996)
sm1 = L(() => {
  pC();
  QC1();
  XGA = class XGA {
    constructor(A, Q) {
      this.iterator = A, this.controller = Q
    }
    async * decoder() {
      let A = new gm;
      for await (let Q of this.iterator) for (let B of A.decode(Q)) yield JSON.parse(B);
      for (let Q of A.flush()) yield JSON.parse(Q)
    } [Symbol.asyncIterator]() {
      return this.decoder()
    }
    static fromResponse(A, Q) {
      if (!A.body) {
        if (Q.abort(), typeof globalThis.navigator < "u" && globalThis.navigator.product === "ReactNative") throw new vB("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api");
        throw new vB("Attempted to iterate over a response with no body")
      }
      return new XGA(_KA(A.body), Q)
    }
  }
})
// @from(Start 6735002, End 6735005)
g$A
// @from(Start 6735011, End 6737301)
rm1 = L(() => {
  d_();
  CM();
  sm1();
  Yr();
  Mp();
  g$A = class g$A extends pY {
    create(A, Q) {
      let {
        betas: B,
        ...G
      } = A;
      return this._client.post("/v1/messages/batches?beta=true", {
        body: G,
        ...Q,
        headers: r4([{
          "anthropic-beta": [...B ?? [], "message-batches-2024-09-24"].toString()
        }, Q?.headers])
      })
    }
    retrieve(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.get(IY`/v1/messages/batches/${A}?beta=true`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "message-batches-2024-09-24"].toString()
        }, B?.headers])
      })
    }
    list(A = {}, Q) {
      let {
        betas: B,
        ...G
      } = A ?? {};
      return this._client.getAPIList("/v1/messages/batches?beta=true", NT, {
        query: G,
        ...Q,
        headers: r4([{
          "anthropic-beta": [...B ?? [], "message-batches-2024-09-24"].toString()
        }, Q?.headers])
      })
    }
    delete(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.delete(IY`/v1/messages/batches/${A}?beta=true`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "message-batches-2024-09-24"].toString()
        }, B?.headers])
      })
    }
    cancel(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.post(IY`/v1/messages/batches/${A}/cancel?beta=true`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "message-batches-2024-09-24"].toString()
        }, B?.headers])
      })
    }
    async results(A, Q = {}, B) {
      let G = await this.retrieve(A);
      if (!G.results_url) throw new vB(`No batch \`results_url\`; Has it finished processing? ${G.processing_status} - ${G.id}`);
      let {
        betas: Z
      } = Q ?? {};
      return this._client.get(G.results_url, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...Z ?? [], "message-batches-2024-09-24"].toString(),
          Accept: "application/binary"
        }, B?.headers]),
        stream: !0,
        __binaryResponse: !0
      })._thenUnwrap((I, Y) => XGA.fromResponse(Y.response, Y.controller))
    }
  }
})
// @from(Start 6737307, End 6737310)
BRB
// @from(Start 6737312, End 6737314)
Je
// @from(Start 6737320, End 6739673)
om1 = L(() => {
  im1();
  CM();
  WC1();
  DC1();
  am1();
  rm1();
  rm1();
  am1();
  BRB = {
    "claude-1.3": "November 6th, 2024",
    "claude-1.3-100k": "November 6th, 2024",
    "claude-instant-1.1": "November 6th, 2024",
    "claude-instant-1.1-100k": "November 6th, 2024",
    "claude-instant-1.2": "November 6th, 2024",
    "claude-3-sonnet-20240229": "July 21st, 2025",
    "claude-3-opus-20240229": "January 5th, 2026",
    "claude-2.1": "July 21st, 2025",
    "claude-2.0": "July 21st, 2025",
    "claude-3-7-sonnet-latest": "February 19th, 2026",
    "claude-3-7-sonnet-20250219": "February 19th, 2026"
  };
  Je = class Je extends pY {
    constructor() {
      super(...arguments);
      this.batches = new g$A(this._client)
    }
    create(A, Q) {
      let {
        betas: B,
        ...G
      } = A;
      if (G.model in BRB) console.warn(`The model '${G.model}' is deprecated and will reach end-of-life on ${BRB[G.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
      let Z = this._client._options.timeout;
      if (!G.stream && Z == null) {
        let I = jrA[G.model] ?? void 0;
        Z = this._client.calculateNonstreamingTimeout(G.max_tokens, I)
      }
      return this._client.post("/v1/messages?beta=true", {
        body: G,
        timeout: Z ?? 600000,
        ...Q,
        headers: r4([{
          ...B?.toString() != null ? {
            "anthropic-beta": B?.toString()
          } : void 0
        }, Q?.headers]),
        stream: A.stream ?? !1
      })
    }
    parse(A, Q) {
      return Q = {
        ...Q,
        headers: r4([{
          "anthropic-beta": [...A.betas ?? [], "structured-outputs-2025-09-17"].toString()
        }, Q?.headers])
      }, this.create(A, Q).then((B) => JC1(B, A))
    }
    stream(A, Q) {
      return Wr.createMessage(this, A, Q)
    }
    countTokens(A, Q) {
      let {
        betas: B,
        ...G
      } = A;
      return this._client.post("/v1/messages/count_tokens?beta=true", {
        body: G,
        ...Q,
        headers: r4([{
          "anthropic-beta": [...B ?? [], "token-counting-2024-11-01"].toString()
        }, Q?.headers])
      })
    }
    toolRunner(A, Q) {
      return new h$A(this._client, A, Q)
    }
  };
  Je.Batches = g$A;
  Je.BetaToolRunner = h$A
})
// @from(Start 6739679, End 6739682)
u$A
// @from(Start 6739688, End 6741086)
tm1 = L(() => {
  d_();
  CM();
  JGA();
  Mp();
  u$A = class u$A extends pY {
    create(A, Q = {}, B) {
      let {
        betas: G,
        ...Z
      } = Q ?? {};
      return this._client.post(IY`/v1/skills/${A}/versions?beta=true`, YGA({
        body: Z,
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "skills-2025-10-02"].toString()
        }, B?.headers])
      }, this._client))
    }
    retrieve(A, Q, B) {
      let {
        skill_id: G,
        betas: Z
      } = Q;
      return this._client.get(IY`/v1/skills/${G}/versions/${A}?beta=true`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...Z ?? [], "skills-2025-10-02"].toString()
        }, B?.headers])
      })
    }
    list(A, Q = {}, B) {
      let {
        betas: G,
        ...Z
      } = Q ?? {};
      return this._client.getAPIList(IY`/v1/skills/${A}/versions?beta=true`, k$A, {
        query: Z,
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "skills-2025-10-02"].toString()
        }, B?.headers])
      })
    }
    delete(A, Q, B) {
      let {
        skill_id: G,
        betas: Z
      } = Q;
      return this._client.delete(IY`/v1/skills/${G}/versions/${A}?beta=true`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...Z ?? [], "skills-2025-10-02"].toString()
        }, B?.headers])
      })
    }
  }
})
// @from(Start 6741092, End 6741095)
VGA
// @from(Start 6741101, End 6742550)
em1 = L(() => {
  tm1();
  tm1();
  d_();
  CM();
  JGA();
  Mp();
  VGA = class VGA extends pY {
    constructor() {
      super(...arguments);
      this.versions = new u$A(this._client)
    }
    create(A = {}, Q) {
      let {
        betas: B,
        ...G
      } = A ?? {};
      return this._client.post("/v1/skills?beta=true", YGA({
        body: G,
        ...Q,
        headers: r4([{
          "anthropic-beta": [...B ?? [], "skills-2025-10-02"].toString()
        }, Q?.headers])
      }, this._client))
    }
    retrieve(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.get(IY`/v1/skills/${A}?beta=true`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "skills-2025-10-02"].toString()
        }, B?.headers])
      })
    }
    list(A = {}, Q) {
      let {
        betas: B,
        ...G
      } = A ?? {};
      return this._client.getAPIList("/v1/skills?beta=true", k$A, {
        query: G,
        ...Q,
        headers: r4([{
          "anthropic-beta": [...B ?? [], "skills-2025-10-02"].toString()
        }, Q?.headers])
      })
    }
    delete(A, Q = {}, B) {
      let {
        betas: G
      } = Q ?? {};
      return this._client.delete(IY`/v1/skills/${A}?beta=true`, {
        ...B,
        headers: r4([{
          "anthropic-beta": [...G ?? [], "skills-2025-10-02"].toString()
        }, B?.headers])
      })
    }
  };
  VGA.Versions = u$A
})
// @from(Start 6742556, End 6742558)
pH
// @from(Start 6742564, End 6742969)
Ad1 = L(() => {
  pm1();
  pm1();
  lm1();
  lm1();
  om1();
  om1();
  em1();
  em1();
  pH = class pH extends pY {
    constructor() {
      super(...arguments);
      this.models = new v$A(this._client), this.messages = new Je(this._client), this.files = new x$A(this._client), this.skills = new VGA(this._client)
    }
  };
  pH.Models = v$A;
  pH.Messages = Je;
  pH.Files = x$A;
  pH.Skills = VGA
})
// @from(Start 6742975, End 6742977)
Rp
// @from(Start 6742983, End 6743453)
Qd1 = L(() => {
  CM();
  Rp = class Rp extends pY {
    create(A, Q) {
      let {
        betas: B,
        ...G
      } = A;
      return this._client.post("/v1/complete", {
        body: G,
        timeout: this._client._options.timeout ?? 600000,
        ...Q,
        headers: r4([{
          ...B?.toString() != null ? {
            "anthropic-beta": B?.toString()
          } : void 0
        }, Q?.headers]),
        stream: A.stream ?? !1
      })
    }
  }
})
// @from(Start 6743456, End 6743538)
function YRB(A) {
  return A.type === "tool_use" || A.type === "server_tool_use"
}
// @from(Start 6743540, End 6743558)
function JRB(A) {}
// @from(Start 6743563, End 6743565)
EM
// @from(Start 6743567, End 6743569)
Tp
// @from(Start 6743571, End 6743574)
m$A
// @from(Start 6743576, End 6743579)
_rA
// @from(Start 6743581, End 6743584)
d$A
// @from(Start 6743586, End 6743589)
c$A
// @from(Start 6743591, End 6743594)
krA
// @from(Start 6743596, End 6743599)
p$A
// @from(Start 6743601, End 6743603)
Df
// @from(Start 6743605, End 6743608)
l$A
// @from(Start 6743610, End 6743613)
yrA
// @from(Start 6743615, End 6743618)
xrA
// @from(Start 6743620, End 6743623)
FGA
// @from(Start 6743625, End 6743628)
vrA
// @from(Start 6743630, End 6743633)
brA
// @from(Start 6743635, End 6743638)
Bd1
// @from(Start 6743640, End 6743643)
GRB
// @from(Start 6743645, End 6743648)
Gd1
// @from(Start 6743650, End 6743653)
Zd1
// @from(Start 6743655, End 6743658)
Id1
// @from(Start 6743660, End 6743663)
Yd1
// @from(Start 6743665, End 6743668)
ZRB
// @from(Start 6743670, End 6743688)
IRB = "__json_buf"
// @from(Start 6743692, End 6743695)
i$A