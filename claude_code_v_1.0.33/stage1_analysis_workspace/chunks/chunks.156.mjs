
// @from(Start 14716022, End 14722269)
function Wg3({
  theme: A,
  welcomeMessage: Q
}) {
  if (["light", "light-daltonized", "light-ansi"].includes(A)) return T0.default.createElement(S, {
    width: tJ1
  }, T0.default.createElement($, null, T0.default.createElement($, null, T0.default.createElement($, {
    color: "claude"
  }, Q, " "), T0.default.createElement($, {
    dimColor: !0
  }, "v", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION, " ")), T0.default.createElement($, null, "…………………………………………………………………………………………………………………………………………………………"), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "            ░░░░░░                                        "), T0.default.createElement($, null, "    ░░░   ░░░░░░░░░░                                      "), T0.default.createElement($, null, "   ░░░░░░░░░░░░░░░░░░░                                    "), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, T0.default.createElement($, {
    dimColor: !0
  }, "                           ░░░░"), T0.default.createElement($, null, "                     ██    ")), T0.default.createElement($, null, T0.default.createElement($, {
    dimColor: !0
  }, "                         ░░░░░░░░░░"), T0.default.createElement($, null, "               ██▒▒██  ")), T0.default.createElement($, null, "                                            ▒▒      ██   ▒"), T0.default.createElement($, null, "                                          ▒▒░░▒▒      ▒ ▒▒"), T0.default.createElement($, null, "      ", T0.default.createElement($, {
    color: "clawd_body"
  }, "▗"), T0.default.createElement($, {
    color: "clawd_background",
    backgroundColor: "clawd_body"
  }, " ", "▗", "     ", "▖", " "), T0.default.createElement($, {
    color: "clawd_body"
  }, "▖"), "                           ▒▒         ▒▒ "), T0.default.createElement($, null, "       ", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " ".repeat(9)), "                           ░          ▒   "), T0.default.createElement($, null, "…………………", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, "   "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), "……………………………………………………………………░…………………………▒…………")));
  return T0.default.createElement(S, {
    width: tJ1
  }, T0.default.createElement($, null, T0.default.createElement($, null, T0.default.createElement($, {
    color: "claude"
  }, Q, " "), T0.default.createElement($, {
    dimColor: !0
  }, "v", {
    ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
    PACKAGE_URL: "@anthropic-ai/claude-code",
    README_URL: "https://code.claude.com/docs/en/overview",
    VERSION: "2.0.59",
    FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
  }.VERSION, " ")), T0.default.createElement($, null, "…………………………………………………………………………………………………………………………………………………………"), T0.default.createElement($, null, "                                                          "), T0.default.createElement($, null, "     *                                       █████▓▓░     "), T0.default.createElement($, null, "                                 *         ███▓░     ░░   "), T0.default.createElement($, null, "            ░░░░░░                        ███▓░           "), T0.default.createElement($, null, "    ░░░   ░░░░░░░░░░                      ███▓░           "), T0.default.createElement($, null, T0.default.createElement($, null, "   ░░░░░░░░░░░░░░░░░░░    "), T0.default.createElement($, {
    bold: !0
  }, "*"), T0.default.createElement($, null, "                ██▓░░      ▓   ")), T0.default.createElement($, null, "                                             ░▓▓███▓▓░    "), T0.default.createElement($, {
    dimColor: !0
  }, " *                                 ░░░░                   "), T0.default.createElement($, {
    dimColor: !0
  }, "                                 ░░░░░░░░                 "), T0.default.createElement($, {
    dimColor: !0
  }, "                               ░░░░░░░░░░░░░░░░           "), T0.default.createElement($, null, "                                                      ", T0.default.createElement($, {
    dimColor: !0
  }, "*"), T0.default.createElement($, null, " ")), T0.default.createElement($, null, "        ", T0.default.createElement($, {
    color: "clawd_body"
  }, "▗"), T0.default.createElement($, {
    color: "clawd_background",
    backgroundColor: "clawd_body"
  }, " ", "▗", "     ", "▖", " "), T0.default.createElement($, {
    color: "clawd_body"
  }, "▖"), T0.default.createElement($, null, "                       "), T0.default.createElement($, {
    bold: !0
  }, "*"), T0.default.createElement($, null, "                ")), T0.default.createElement($, null, "        ", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " ".repeat(9)), "      *                                   "), T0.default.createElement($, null, "…………………", T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, "   "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), T0.default.createElement($, null, " "), T0.default.createElement($, {
    backgroundColor: "clawd_body"
  }, " "), "………………………………………………………………………………………………………………")))
}
// @from(Start 14722274, End 14722276)
T0
// @from(Start 14722278, End 14722286)
tJ1 = 58
// @from(Start 14722292, End 14722345)
WD0 = L(() => {
  hA();
  c5();
  T0 = BA(VA(), 1)
})
// @from(Start 14722348, End 14726677)
function aU9({
  onDone: A
}) {
  let [Q, B] = R8.useState(0), G = JU(), [Z, I] = qB();
  R8.useEffect(() => {
    GA("tengu_began_setup", {
      oauthEnabled: G
    })
  }, [G]);

  function Y() {
    if (Q < D.length - 1) {
      let H = Q + 1;
      B(H), GA("tengu_onboarding_step", {
        oauthEnabled: G,
        stepId: D[H]?.id
      })
    } else A()
  }

  function J(H) {
    I(H), Y()
  }
  let W = EQ();
  f1(async (H, C) => {
    let E = D[Q];
    if (C.return && E && E.id === "security")
      if (Q === D.length - 1) {
        A();
        return
      } else Y();
    else if (C.escape && E?.id === "terminal-setup") Y()
  });
  let X = R8.default.createElement(bY1, {
      initialTheme: Z,
      onThemeSelect: J,
      showIntroText: !0,
      helpText: "To change this later, run /theme",
      hideEscToCancel: !0,
      skipExitHandling: !0
    }),
    V = R8.default.createElement(S, {
      flexDirection: "column",
      gap: 1,
      paddingLeft: 1
    }, R8.default.createElement($, {
      bold: !0
    }, "Security notes:"), R8.default.createElement(S, {
      flexDirection: "column",
      width: 70
    }, R8.default.createElement(q$A, null, R8.default.createElement(q$A.Item, null, R8.default.createElement($, null, "Claude can make mistakes"), R8.default.createElement($, {
      dimColor: !0,
      wrap: "wrap"
    }, "You should always review Claude's responses, especially when", R8.default.createElement(bF, null), "running code.", R8.default.createElement(bF, null))), R8.default.createElement(q$A.Item, null, R8.default.createElement($, null, "Due to prompt injection risks, only use it with code you trust"), R8.default.createElement($, {
      dimColor: !0,
      wrap: "wrap"
    }, "For more details see:", R8.default.createElement(bF, null), R8.default.createElement(h4, {
      url: "https://code.claude.com/docs/en/security"
    }))))), R8.default.createElement(pY1, null)),
    F = R8.default.createElement(iU9, {
      onSuccess: Y
    }),
    K = R8.useMemo(() => {
      if (!process.env.ANTHROPIC_API_KEY) return "";
      let H = dw(process.env.ANTHROPIC_API_KEY);
      if (TiA(H) === "new") return H
    }, []),
    D = [];
  if (G) D.push({
    id: "preflight",
    component: F
  });
  if (D.push({
      id: "theme",
      component: X
    }), G) D.push({
    id: "oauth",
    component: R8.default.createElement(Vn, {
      onDone: Y
    })
  });
  if (K) D.push({
    id: "api-key",
    component: R8.default.createElement(oJ1, {
      customApiKeyTruncated: K,
      onDone: Y
    })
  });
  if (D.push({
      id: "security",
      component: V
    }), M$A()) D.push({
    id: "terminal-setup",
    component: R8.default.createElement(S, {
      flexDirection: "column",
      gap: 1,
      paddingLeft: 1
    }, R8.default.createElement($, {
      bold: !0
    }, "Use Claude Code's terminal setup?"), R8.default.createElement(S, {
      flexDirection: "column",
      width: 70,
      gap: 1
    }, R8.default.createElement($, null, "For the optimal coding experience, enable the recommended settings", R8.default.createElement(bF, null), "for your terminal:", " ", d0.terminal === "Apple_Terminal" ? "Option+Enter for newlines and visual bell" : "Shift+Enter for newlines"), R8.default.createElement(M0, {
      options: [{
        label: "Yes, use recommended settings",
        value: "install"
      }, {
        label: "No, maybe later with /terminal-setup",
        value: "no"
      }],
      onChange: (H) => {
        if (H === "install") Dm1(Z).then(() => {
          Y()
        });
        else Y()
      },
      onCancel: () => Y()
    }), R8.default.createElement($, {
      dimColor: !0
    }, W.pending ? R8.default.createElement(R8.default.Fragment, null, "Press ", W.keyName, " again to exit") : R8.default.createElement(R8.default.Fragment, null, "Enter to confirm · Esc to skip"))))
  });
  return R8.default.createElement(S, {
    flexDirection: "column"
  }, R8.default.createElement(Zp, {
    items: [R8.default.createElement(eJ1, {
      key: "welcome"
    })]
  }, (H) => H), R8.default.createElement(S, {
    flexDirection: "column",
    marginTop: 1
  }, D[Q]?.component, W.pending && R8.default.createElement(S, {
    padding: 1
  }, R8.default.createElement($, {
    dimColor: !0
  }, "Press ", W.keyName, " again to exit"))))
}
// @from(Start 14726682, End 14726684)
R8
// @from(Start 14726690, End 14726872)
sU9 = L(() => {
  hA();
  jQ();
  vzA();
  Jm1();
  Q4();
  SRA();
  JD0();
  gB();
  hA();
  oV0();
  nU9();
  mV0();
  q0();
  c5();
  S5();
  r7A();
  WD0();
  R8 = BA(VA(), 1)
})
// @from(Start 14726912, End 14727233)
function VD0(A) {
  let Q = Hi();
  if (A === Q.HOME) return "home";
  if (A === Q.DESKTOP || A.startsWith(Q.DESKTOP + XD0)) return "desktop";
  if (A === Q.DOCUMENTS || A.startsWith(Q.DOCUMENTS + XD0)) return "documents";
  if (A === Q.DOWNLOADS || A.startsWith(Q.DOWNLOADS + XD0)) return "downloads";
  return "other"
}
// @from(Start 14727235, End 14727447)
function rU9(A) {
  if (A === null || A.disableAllHooks) return !1;
  if (A.statusLine) return !0;
  if (!A.hooks) return !1;
  for (let Q of Object.values(A.hooks))
    if (Q.length > 0) return !0;
  return !1
}
// @from(Start 14727449, End 14727654)
function Q$9() {
  let A = [],
    Q = OB("projectSettings");
  if (rU9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (rU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14727656, End 14727804)
function oU9(A) {
  return A.some((Q) => Q.ruleBehavior === "allow" && (Q.ruleValue.toolName === C9 || Q.ruleValue.toolName.startsWith(C9 + "(")))
}
// @from(Start 14727806, End 14728013)
function B$9() {
  let A = [],
    Q = YxA("projectSettings");
  if (oU9(Q)) A.push(".claude/settings.json");
  let B = YxA("localSettings");
  if (oU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14728015, End 14728449)
function cSA(A, Q) {
  if (A.length === 0) return "";
  let B = Q === 0 ? void 0 : Q;
  if (!B || A.length <= B) {
    if (A.length === 1) return A[0];
    if (A.length === 2) return `${A[0]} and ${A[1]}`;
    let I = A[A.length - 1];
    return `${A.slice(0,-1).join(", ")}, and ${I}`
  }
  let G = A.slice(0, B),
    Z = A.length - B;
  if (G.length === 1) return `${G[0]} and ${Z} more`;
  return `${G.join(", ")}, and ${Z} more`
}
// @from(Start 14728451, End 14728502)
function tU9(A) {
  return !!A?.otelHeadersHelper
}
// @from(Start 14728504, End 14728709)
function G$9() {
  let A = [],
    Q = OB("projectSettings");
  if (tU9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (tU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14728711, End 14728757)
function eU9(A) {
  return !!A?.apiKeyHelper
}
// @from(Start 14728759, End 14728964)
function Z$9() {
  let A = [],
    Q = OB("projectSettings");
  if (eU9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (eU9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14728966, End 14729042)
function A$9(A) {
  return !!(A?.awsAuthRefresh || A?.awsCredentialExport)
}
// @from(Start 14729044, End 14729249)
function I$9() {
  let A = [],
    Q = OB("projectSettings");
  if (A$9(Q)) A.push(".claude/settings.json");
  let B = OB("localSettings");
  if (A$9(B)) A.push(".claude/settings.local.json");
  return A
}
// @from(Start 14729254, End 14729296)
Y$9 = L(() => {
  is();
  MB();
  QMA()
})
// @from(Start 14729302, End 14729305)
J$9
// @from(Start 14729311, End 14731069)
W$9 = L(() => {
  J$9 = {
    control: {
      title: "Do you trust the files in this folder?",
      bodyText: null,
      showDetailedPermissions: !0,
      learnMoreText: "Learn more",
      yesButtonLabel: "Yes, proceed",
      noButtonLabel: "No, exit"
    },
    variant_positive_attitude: {
      title: "Ready to code here?",
      bodyText: `I'll need permission to work with your files.

This means I can:
- Read any file in this folder
- Create, edit, or delete files
- Run commands (like npm, git, tests, ls, rm)
- Use tools defined in .mcp.json`,
      showDetailedPermissions: !1,
      learnMoreText: "Learn more",
      yesButtonLabel: "Yes, continue",
      noButtonLabel: "No, exit"
    },
    variant_normalize_action: {
      title: "Accessing workspace:",
      bodyText: `Quick safety check: Is this a project you created or one you trust? (Like your own code, a well-known open source project, or work from your team). If not, take a moment to review what's in this folder first.

Claude Code'll be able to read, edit, and execute files here.`,
      showDetailedPermissions: !1,
      learnMoreText: "Security guide",
      yesButtonLabel: "Yes, I trust this folder",
      noButtonLabel: "No, exit"
    },
    variant_explicit: {
      title: "Do you want to work in this folder?",
      bodyText: `In order to work in this folder, we need your permission for Claude Code to read, edit, and execute files.

If this folder has malicious code or untrusted scripts, Claude Code could run them while trying to help.

Only continue if this is your code or a project you trust.`,
      showDetailedPermissions: !1,
      learnMoreText: "Security details",
      yesButtonLabel: "Yes, continue",
      noButtonLabel: "No, exit"
    }
  }
})
// @from(Start 14731111, End 14736412)
function V$9({
  onDone: A,
  commands: Q
}) {
  let {
    servers: B
  } = sX("project"), G = BZ("trust_folder_dialog_copy", "variant", "control"), Z = J$9[G], I = Object.keys(B).length > 0, Y = Q$9(), J = Y.length > 0, W = B$9(), X = Z$9(), V = X.length > 0, F = I$9(), K = F.length > 0, D = G$9(), H = D.length > 0, C = [...new Set([...Y, ...W, ...X, ...F, ...D])], E = Q?.filter((m) => m.type === "prompt" && m.source === "projectSettings" && !m.isSkill && m.allowedTools?.some((o) => o === C9 || o.startsWith(C9 + "("))) ?? [], U = Q?.filter((m) => m.type === "prompt" && m.source === "localSettings" && m.isSkill && m.allowedTools?.some((o) => o === C9 || o.startsWith(C9 + "("))) ?? [], q = E.length > 0, w = U.length > 0, N = E.map((m) => m.name), R = U.map((m) => m.name), T = W.length > 0 || q || w, y = TJ(J || T || V || K || H), x = [{
    name: "MCP servers",
    shouldShowWarning: () => I,
    onChange: () => {
      let m = {
        enabledMcpjsonServers: Object.keys(B),
        enableAllProjectMcpServers: !0
      };
      cB("localSettings", m)
    }
  }, {
    name: "hooks",
    shouldShowWarning: () => J
  }, {
    name: "bash commands",
    shouldShowWarning: () => T
  }, {
    name: "OpenTelemetry headers helper commands",
    shouldShowWarning: () => H
  }].filter((m) => m.shouldShowWarning()), p = new Set(x.map((m) => m.name)), u = Object.keys(B);

  function e() {
    let m = ["files"];
    if (p.has("MCP servers")) m.push("MCP servers");
    if (p.has("hooks")) m.push("hooks");
    if (p.has("bash commands")) m.push("bash commands");
    if (p.has("OpenTelemetry headers helper commands")) m.push("OpenTelemetry headers helper commands");
    return cSA(m)
  }
  v5.default.useEffect(() => {
    let m = X$9() === W0();
    GA("tengu_trust_dialog_shown", {
      isHomeDir: m,
      hasMcpServers: I,
      hasHooks: J,
      hasBashExecution: T,
      hasApiKeyHelper: V,
      hasAwsCommands: K,
      hasOtelHeadersHelper: H,
      folderType: VD0(W0()),
      copyVariant: G
    })
  }, [I, J, T, V, K, H, G]);

  function l(m) {
    let o = j5();
    if (m === "exit") {
      l5(1);
      return
    }
    let IA = X$9() === W0();
    if (GA("tengu_trust_dialog_accept", {
        isHomeDir: IA,
        hasMcpServers: I,
        hasHooks: J,
        hasBashExecution: T,
        hasApiKeyHelper: V,
        hasAwsCommands: K,
        hasOtelHeadersHelper: H,
        enableMcp: !0,
        folderType: VD0(W0()),
        copyVariant: G
      }), !IA) AY({
      ...o,
      hasTrustDialogAccepted: !0
    });
    x.forEach((FA) => {
      if (FA.onChange !== void 0) FA.onChange()
    }), A()
  }
  let k = EQ();
  if (f1((m, o) => {
      if (o.escape) {
        l5(0);
        return
      }
    }), y) return setTimeout(A), null;
  return v5.default.createElement(uJ, {
    color: "warning",
    titleColor: "warning",
    title: Z.title
  }, v5.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    paddingTop: 1
  }, v5.default.createElement($, {
    bold: !0
  }, RA().cwd()), Z.bodyText !== null ? v5.default.createElement($, null, Z.bodyText) : v5.default.createElement($, null, "Claude Code may read, write, or execute files contained in this directory. This can pose security risks, so only use", " ", e(), " from trusted sources."), Z.showDetailedPermissions && (I || J || T || V || K || H) && v5.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, v5.default.createElement($, {
    dimColor: !0
  }, "Execution allowed by:"), I && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, ".mcp.json"), u.length > 0 && v5.default.createElement($, {
    dimColor: !0
  }, " ", "(", cSA(u, 3), ")"))), C.length > 0 && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, C.join(", ")))), q && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, ".claude/commands"), v5.default.createElement($, {
    dimColor: !0
  }, " ", "(", cSA(N, 3), ")"))), w && v5.default.createElement(S, {
    paddingLeft: 2
  }, v5.default.createElement($, null, v5.default.createElement($, {
    dimColor: !0
  }, "• "), v5.default.createElement($, {
    bold: !0
  }, ".claude/skills"), v5.default.createElement($, {
    dimColor: !0
  }, " (", cSA(R, 3), ")")))), v5.default.createElement($, {
    dimColor: !0
  }, v5.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/security"
  }, Z.learnMoreText)), v5.default.createElement(M0, {
    options: [{
      label: Z.yesButtonLabel,
      value: "enable_all"
    }, {
      label: Z.noButtonLabel,
      value: "exit"
    }],
    onChange: (m) => l(m),
    onCancel: () => l("exit")
  }), v5.default.createElement($, {
    dimColor: !0
  }, k.pending ? v5.default.createElement(v5.default.Fragment, null, "Press ", k.keyName, " again to exit") : v5.default.createElement(v5.default.Fragment, null, "Enter to confirm · Esc to exit"))))
}
// @from(Start 14736417, End 14736419)
v5
// @from(Start 14736425, End 14736584)
F$9 = L(() => {
  hA();
  J5();
  jQ();
  tM();
  MB();
  u2();
  q0();
  Q4();
  U2();
  hA();
  AQ();
  kW();
  Y$9();
  W$9();
  wO();
  v5 = BA(VA(), 1)
})
// @from(Start 14736590, End 14736593)
AW1
// @from(Start 14736599, End 14736686)
K$9 = L(() => {
  GJ1();
  g1();
  S7();
  g1();
  kW();
  i8();
  AW1 = BA(VA(), 1)
})
// @from(Start 14736689, End 14738892)
function D$9({
  commands: A,
  initialLogs: Q,
  initialTools: B,
  mcpClients: G,
  dynamicMcpConfig: Z,
  mcpCliEndpoint: I,
  appState: Y,
  onChangeAppState: J,
  debug: W,
  strictMcpConfig: X = !1,
  systemPrompt: V,
  appendSystemPrompt: F,
  initialSearchQuery: K
}) {
  let {
    rows: D
  } = WB(), [H, C] = qY.default.useState(Q), [E, U] = qY.default.useState(!1), [q, w] = qY.default.useState(!1), [N, R] = qY.default.useState(null), [T, y] = qY.default.useState(null), v = H.filter((k) => !k.isSidechain);
  EQ();
  let x = ug(),
    p = qY.default.useCallback((k) => {
      U(!0), (k ? YJ1 : eP)().then((o) => {
        C(o)
      }).catch((o) => {
        AA(o)
      }).finally(() => {
        U(!1)
      })
    }, []);
  qY.default.useEffect(() => {
    p(q)
  }, [p, q]);
  let u = qY.default.useCallback(() => {
    w((k) => !k)
  }, []);

  function e() {
    process.exit(1)
  }
  async function l(k) {
    let m = IJ1(k, q);
    if (m.isCrossProject) {
      await La(m.command), y(m.command);
      return
    }
    try {
      let o = await ki(k, void 0);
      if (!o) throw Error("Failed to load conversation");
      if (!gH()) await kJ();
      R(o)
    } catch (o) {
      throw AA(o), o
    }
  }
  if (T) return qY.default.createElement(Xg3, {
    command: T
  });
  if (N) return qY.default.createElement(yG, {
    initialState: Y,
    onChangeAppState: J
  }, qY.default.createElement(WVA, {
    initialPrompt: "",
    debug: W,
    commands: A,
    initialTools: B,
    initialMessages: N.messages,
    initialFileHistorySnapshots: N.fileHistorySnapshots,
    mcpClients: G,
    dynamicMcpConfig: Z,
    mcpCliEndpoint: I,
    strictMcpConfig: X,
    systemPrompt: V,
    appendSystemPrompt: F
  }));
  if (E) return qY.default.createElement(S, null, qY.default.createElement(g4, null), qY.default.createElement($, null, " Loading conversations…"));
  return qY.default.createElement(yG, {
    initialState: Y,
    onChangeAppState: J
  }, qY.default.createElement(USA, {
    logs: v,
    maxHeight: D,
    onCancel: e,
    onSelect: l,
    onLogsChanged: x ? () => p(q) : void 0,
    initialSearchQuery: K,
    showAllProjects: q,
    onToggleAllProjects: u
  }))
}
// @from(Start 14738894, End 14739484)
function Xg3({
  command: A
}) {
  return qY.default.useEffect(() => {
    let Q = setTimeout(() => {
      process.exit(0)
    }, 100);
    return () => clearTimeout(Q)
  }, []), qY.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, qY.default.createElement($, null, "This conversation is from a different directory."), qY.default.createElement(S, {
    flexDirection: "column"
  }, qY.default.createElement($, null, "To resume, run:"), qY.default.createElement($, null, " ", A)), qY.default.createElement($, {
    dimColor: !0
  }, "(Command copied to clipboard)"))
}
// @from(Start 14739489, End 14739491)
qY
// @from(Start 14739497, End 14739651)
H$9 = L(() => {
  hA();
  DY();
  ZY1();
  GJ1();
  g1();
  S7();
  Bh();
  nt();
  Q4();
  z9();
  vYA();
  i8();
  $SA();
  TF0();
  qY = BA(VA(), 1)
})
// @from(Start 14739657, End 14739660)
C$9
// @from(Start 14739662, End 14739665)
FD0
// @from(Start 14739671, End 14745556)
E$9 = L(() => {
  Ht1();
  SD();
  C$9 = BA(QQ1(), 1);
  FD0 = class FD0 extends QLA {
    constructor(A, Q) {
      var B;
      super(Q);
      this._serverInfo = A, this._capabilities = (B = Q === null || Q === void 0 ? void 0 : Q.capabilities) !== null && B !== void 0 ? B : {}, this._instructions = Q === null || Q === void 0 ? void 0 : Q.instructions, this.setRequestHandler(eo1, (G) => this._oninitialize(G)), this.setNotificationHandler(_01, () => {
        var G;
        return (G = this.oninitialized) === null || G === void 0 ? void 0 : G.call(this)
      })
    }
    registerCapabilities(A) {
      if (this.transport) throw Error("Cannot register capabilities after connecting to transport");
      this._capabilities = b01(this._capabilities, A)
    }
    assertCapabilityForMethod(A) {
      var Q, B, G;
      switch (A) {
        case "sampling/createMessage":
          if (!((Q = this._clientCapabilities) === null || Q === void 0 ? void 0 : Q.sampling)) throw Error(`Client does not support sampling (required for ${A})`);
          break;
        case "elicitation/create":
          if (!((B = this._clientCapabilities) === null || B === void 0 ? void 0 : B.elicitation)) throw Error(`Client does not support elicitation (required for ${A})`);
          break;
        case "roots/list":
          if (!((G = this._clientCapabilities) === null || G === void 0 ? void 0 : G.roots)) throw Error(`Client does not support listing roots (required for ${A})`);
          break;
        case "ping":
          break
      }
    }
    assertNotificationCapability(A) {
      switch (A) {
        case "notifications/message":
          if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${A})`);
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources) throw Error(`Server does not support notifying about resources (required for ${A})`);
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools) throw Error(`Server does not support notifying of tool list changes (required for ${A})`);
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts) throw Error(`Server does not support notifying of prompt list changes (required for ${A})`);
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break
      }
    }
    assertRequestHandlerCapability(A) {
      switch (A) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling) throw Error(`Server does not support sampling (required for ${A})`);
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging) throw Error(`Server does not support logging (required for ${A})`);
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts) throw Error(`Server does not support prompts (required for ${A})`);
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources) throw Error(`Server does not support resources (required for ${A})`);
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools) throw Error(`Server does not support tools (required for ${A})`);
          break;
        case "ping":
        case "initialize":
          break
      }
    }
    async _oninitialize(A) {
      let Q = A.params.protocolVersion;
      return this._clientCapabilities = A.params.capabilities, this._clientVersion = A.params.clientInfo, {
        protocolVersion: R01.includes(Q) ? Q : hl,
        capabilities: this.getCapabilities(),
        serverInfo: this._serverInfo,
        ...this._instructions && {
          instructions: this._instructions
        }
      }
    }
    getClientCapabilities() {
      return this._clientCapabilities
    }
    getClientVersion() {
      return this._clientVersion
    }
    getCapabilities() {
      return this._capabilities
    }
    async ping() {
      return this.request({
        method: "ping"
      }, Ih)
    }
    async createMessage(A, Q) {
      return this.request({
        method: "sampling/createMessage",
        params: A
      }, Xt1, Q)
    }
    async elicitInput(A, Q) {
      let B = await this.request({
        method: "elicitation/create",
        params: A
      }, Vt1, Q);
      if (B.action === "accept" && B.content) try {
        let G = new C$9.default,
          Z = G.compile(A.requestedSchema);
        if (!Z(B.content)) throw new ME(LE.InvalidParams, `Elicitation response content does not match requested schema: ${G.errorsText(Z.errors)}`)
      } catch (G) {
        if (G instanceof ME) throw G;
        throw new ME(LE.InternalError, `Error validating elicitation response: ${G}`)
      }
      return B
    }
    async listRoots(A, Q) {
      return this.request({
        method: "roots/list",
        params: A
      }, Dt1, Q)
    }
    async sendLoggingMessage(A) {
      return this.notification({
        method: "notifications/message",
        params: A
      })
    }
    async sendResourceUpdated(A) {
      return this.notification({
        method: "notifications/resources/updated",
        params: A
      })
    }
    async sendResourceListChanged() {
      return this.notification({
        method: "notifications/resources/list_changed"
      })
    }
    async sendToolListChanged() {
      return this.notification({
        method: "notifications/tools/list_changed"
      })
    }
    async sendPromptListChanged() {
      return this.notification({
        method: "notifications/prompts/list_changed"
      })
    }
  }
})
// @from(Start 14745590, End 14746947)
class KD0 {
  constructor(A = z$9.stdin, Q = z$9.stdout) {
    this._stdin = A, this._stdout = Q, this._readBuffer = new GLA, this._started = !1, this._ondata = (B) => {
      this._readBuffer.append(B), this.processReadBuffer()
    }, this._onerror = (B) => {
      var G;
      (G = this.onerror) === null || G === void 0 || G.call(this, B)
    }
  }
  async start() {
    if (this._started) throw Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    this._started = !0, this._stdin.on("data", this._ondata), this._stdin.on("error", this._onerror)
  }
  processReadBuffer() {
    var A, Q;
    while (!0) try {
      let B = this._readBuffer.readMessage();
      if (B === null) break;
      (A = this.onmessage) === null || A === void 0 || A.call(this, B)
    } catch (B) {
      (Q = this.onerror) === null || Q === void 0 || Q.call(this, B)
    }
  }
  async close() {
    var A;
    if (this._stdin.off("data", this._ondata), this._stdin.off("error", this._onerror), this._stdin.listenerCount("data") === 0) this._stdin.pause();
    this._readBuffer.clear(), (A = this.onclose) === null || A === void 0 || A.call(this)
  }
  send(A) {
    return new Promise((Q) => {
      let B = GQ1(A);
      if (this._stdout.write(B)) Q();
      else this._stdout.once("drain", Q)
    })
  }
}
// @from(Start 14746952, End 14746978)
U$9 = L(() => {
  gt1()
})
// @from(Start 14746980, End 14750665)
async function w$9(A, Q, B) {
  let Z = Gh(100);
  Bq(A);
  let I = new FD0({
    name: "claude/tengu",
    version: {
      ISSUES_EXPLAINER: "report the issue at https://github.com/anthropics/claude-code/issues",
      PACKAGE_URL: "@anthropic-ai/claude-code",
      README_URL: "https://code.claude.com/docs/en/overview",
      VERSION: "2.0.59",
      FEEDBACK_CHANNEL: "https://github.com/anthropics/claude-code/issues"
    }.VERSION
  }, {
    capabilities: {
      tools: {}
    }
  });
  I.setRequestHandler(Jt1, async () => {
    let J = ZE(),
      W = LC(J);
    return {
      tools: await Promise.all(W.map(async (X) => {
        let V;
        if (X.outputSchema) {
          let F = sRA(X.outputSchema);
          if (typeof F === "object" && F !== null && "type" in F && F.type === "object") V = F
        }
        return {
          ...X,
          description: await X.prompt({
            getToolPermissionContext: async () => J,
            tools: W,
            agents: []
          }),
          inputSchema: sRA(X.inputSchema),
          outputSchema: V
        }
      }))
    }
  }), I.setRequestHandler(Wt1, async ({
    params: {
      name: J,
      arguments: W
    }
  }) => {
    let X = ZE(),
      V = LC(X),
      F = V.find((K) => K.name === J);
    if (!F) throw Error(`Tool ${J} not found`);
    try {
      if (!F.isEnabled()) throw Error(`Tool ${J} is not enabled`);
      let K = k3(),
        D = await F.validateInput?.(W ?? {}, {
          abortController: o9(),
          options: {
            commands: $$9,
            tools: V,
            mainLoopModel: K,
            maxThinkingTokens: 0,
            mcpClients: [],
            mcpResources: {},
            isNonInteractiveSession: !0,
            hasAppendSystemPrompt: !1,
            debug: Q,
            verbose: B,
            agentDefinitions: {
              activeAgents: [],
              allAgents: []
            }
          },
          getAppState: async () => wp(),
          setAppState: () => {},
          messages: [],
          setMessages: () => {},
          readFileState: Z,
          setInProgressToolUseIDs: () => {},
          setResponseLength: () => {},
          updateFileHistoryState: () => {},
          agentId: e1()
        });
      if (D && !D.result) throw Error(`Tool ${J} input is invalid: ${D.message}`);
      let H = await F.call(W ?? {}, {
        abortController: o9(),
        options: {
          commands: $$9,
          tools: V,
          mainLoopModel: k3(),
          maxThinkingTokens: 0,
          mcpClients: [],
          mcpResources: {},
          isNonInteractiveSession: !0,
          hasAppendSystemPrompt: !1,
          debug: Q,
          verbose: B,
          agentDefinitions: {
            activeAgents: [],
            allAgents: []
          }
        },
        getAppState: async () => wp(),
        setAppState: () => {},
        messages: [],
        setMessages: () => {},
        readFileState: Z,
        setInProgressToolUseIDs: () => {},
        setResponseLength: () => {},
        updateFileHistoryState: () => {},
        agentId: e1()
      }, M$, uD({
        content: []
      }));
      return {
        content: [{
          type: "text",
          text: typeof H === "string" ? H : JSON.stringify(H.data)
        }]
      }
    } catch (K) {
      return AA(K instanceof Error ? K : Error(String(K))), {
        isError: !0,
        content: [{
          type: "text",
          text: (K instanceof Error ? NV0(K) : [String(K)]).filter(Boolean).join(`
`).trim() || "Error"
        }]
      }
    }
  });
  async function Y() {
    let J = new KD0;
    await I.connect(J)
  }
  return await Y()
}
// @from(Start 14750670, End 14750673)
$$9
// @from(Start 14750679, End 14750843)
q$9 = L(() => {
  E$9();
  U$9();
  SD();
  D30();
  AZ();
  u_();
  t2();
  g1();
  vM();
  Ca();
  _0();
  jF0();
  cQ();
  yq();
  OZ();
  z9();
  $$9 = [JJ1]
})
// @from(Start 14750846, End 14751073)
function DD0(A, Q, B) {
  let G = "";
  if (Object.keys(B?.enabledPlugins || {}).forEach((Z) => {
      if (Z === A || Z === Q.name || Z.startsWith(`${Q.name}@`)) G = Z
    }), !G) G = A.includes("@") ? A : Q.name;
  return G
}
// @from(Start 14751075, End 14751243)
function N$9(A) {
  if (A.includes("@")) {
    let Q = A.split("@");
    return {
      name: Q[0] || "",
      marketplace: Q[1]
    }
  }
  return {
    name: A
  }
}
// @from(Start 14751245, End 14751488)
function HD0(A, Q) {
  let {
    name: B,
    marketplace: G
  } = N$9(A);
  return Q.find((Z) => {
    if (Z.name === A || Z.name === B) return !0;
    if (G && Z.source) return Z.name === B && Z.source.includes(`@${G}`);
    return !1
  })
}
// @from(Start 14751490, End 14751787)
function CD0(A, Q, B) {
  let Z = {
    ...OB("userSettings")?.enabledPlugins
  };
  Object.keys(Z).forEach((Y) => {
    if (Y === A || Y === B.name || Y.startsWith(`${B.name}@`)) Z[Y] = Q
  });
  let {
    error: I
  } = cB("userSettings", {
    enabledPlugins: Z
  });
  if (I) throw I;
  AF()
}
// @from(Start 14751789, End 14751964)
function QW1(A, Q) {
  AA(A instanceof Error ? A : Error(String(A))), console.error(`${H1.cross} Failed to ${Q}: ${A instanceof Error?A.message:String(A)}`), process.exit(1)
}
// @from(Start 14751965, End 14753019)
async function L$9(A) {
  try {
    let {
      name: Q,
      marketplace: B
    } = N$9(A), G = await pZ(), Z, I;
    for (let [X] of Object.entries(G)) {
      if (B && X !== B) continue;
      let F = (await _D(X)).plugins.find((K) => K.name === Q);
      if (F) {
        Z = F, I = X;
        break
      }
    }
    if (!Z || !I) {
      let X = B ? `marketplace "${B}"` : "any configured marketplace";
      throw Error(`Plugin "${Q}" not found in ${X}`)
    }
    if (typeof Z.source !== "string") console.log(`Installing plugin "${Q}" from marketplace "${I}"...`), await SIA(Z.source, {
      manifest: {
        name: Z.name
      }
    });
    let Y = `${Z.name}@${I}`,
      W = {
        ...OB("userSettings")?.enabledPlugins,
        [Y]: !0
      };
    cB("userSettings", {
      enabledPlugins: W
    }), AF(), console.log(`${H1.tick} Successfully installed plugin: ${Y}`), GA("tengu_plugin_installed_cli", {
      plugin_id: Y,
      marketplace_name: I
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `install plugin "${A}"`)
  }
}
// @from(Start 14753020, End 14753801)
async function M$9(A) {
  try {
    let {
      enabled: Q,
      disabled: B
    } = await l7(), G = [...Q, ...B], Z = HD0(A, G);
    if (!Z) throw Error(`Plugin "${A}" not found in installed plugins`);
    let I = OB("userSettings"),
      Y = DD0(A, Z, I);
    if (I?.enabledPlugins?.[Y] === !1) throw Error(`Plugin "${A}" is already uninstalled`);
    CD0(Y, !1, Z);
    let F = yQA().plugins[Y]?.find((H) => H.scope === "user")?.installPath;
    pI1(Y, "user");
    let D = yQA().plugins[Y];
    if ((!D || D.length === 0) && F) try {
      lI1(F)
    } catch {}
    console.log(`${H1.tick} Successfully uninstalled plugin: ${Z.name}`), GA("tengu_plugin_uninstalled_cli", {
      plugin_id: Y
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `uninstall plugin "${A}"`)
  }
}
// @from(Start 14753802, End 14754242)
async function O$9(A) {
  try {
    let {
      disabled: Q
    } = await l7(), B = HD0(A, Q);
    if (!B) throw Error(`Plugin "${A}" not found in disabled plugins`);
    let G = OB("userSettings"),
      Z = DD0(A, B, G);
    CD0(Z, !0, B), console.log(`${H1.tick} Successfully enabled plugin: ${B.name}`), GA("tengu_plugin_enabled_cli", {
      plugin_id: Z
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `enable plugin "${A}"`)
  }
}
// @from(Start 14754243, End 14754684)
async function R$9(A) {
  try {
    let {
      enabled: Q
    } = await l7(), B = HD0(A, Q);
    if (!B) throw Error(`Plugin "${A}" not found in enabled plugins`);
    let G = OB("userSettings"),
      Z = DD0(A, B, G);
    CD0(Z, !1, B), console.log(`${H1.tick} Successfully disabled plugin: ${B.name}`), GA("tengu_plugin_disabled_cli", {
      plugin_id: Z
    }), process.exit(0)
  } catch (Q) {
    QW1(Q, `disable plugin "${A}"`)
  }
}
// @from(Start 14754689, End 14754771)
T$9 = L(() => {
  V9();
  g1();
  q0();
  fV();
  za();
  oH();
  MB();
  sQA()
})
// @from(Start 14754811, End 14754936)
function pSA() {
  let B = ((l0() || {}).cleanupPeriodDays ?? Vg3) * 24 * 60 * 60 * 1000;
  return new Date(Date.now() - B)
}
// @from(Start 14754938, End 14755046)
function Fg3(A, Q) {
  return {
    messages: A.messages + Q.messages,
    errors: A.errors + Q.errors
  }
}
// @from(Start 14755048, End 14755177)
function Kg3(A) {
  let Q = A.split(".")[0].replace(/T(\d{2})-(\d{2})-(\d{2})-(\d{3})Z/, "T$1:$2:$3.$4Z");
  return new Date(Q)
}
// @from(Start 14755179, End 14755571)
function P$9(A, Q, B) {
  let G = {
    messages: 0,
    errors: 0
  };
  try {
    let Z = RA().readdirSync(A);
    for (let I of Z) try {
      if (Kg3(I.name) < Q)
        if (RA().unlinkSync(k$(A, I.name)), B) G.messages++;
        else G.errors++
    } catch (Y) {
      AA(Y)
    }
  } catch (Z) {
    if (Z instanceof Error && "code" in Z && Z.code !== "ENOENT") AA(Z)
  }
  return G
}
// @from(Start 14755572, End 14756112)
async function Dg3() {
  let A = RA(),
    Q = pSA(),
    B = mj.errors(),
    G = mj.baseLogs(),
    Z = P$9(B, Q, !1);
  try {
    if (A.existsSync(G)) {
      let Y = A.readdirSync(G).filter((J) => J.isDirectory() && J.name.startsWith("mcp-logs-")).map((J) => k$(G, J.name));
      for (let J of Y) {
        Z = Fg3(Z, P$9(J, Q, !0));
        try {
          if (A.isDirEmptySync(J)) A.rmdirSync(J)
        } catch {}
      }
    }
  } catch (I) {
    if (I instanceof Error && "code" in I && I.code !== "ENOENT") AA(I)
  }
  return Z
}
// @from(Start 14756114, End 14756540)
function BW1(A, Q, B, G) {
  let Z = {
    messages: 0,
    errors: 0
  };
  if (!G.existsSync(A)) return Z;
  let Y = G.readdirSync(A).filter((J) => J.isFile() && J.name.endsWith(B));
  for (let J of Y) try {
    let W = k$(A, J.name);
    if (G.statSync(W).mtime < Q) G.unlinkSync(W), Z.messages++
  } catch {
    Z.errors++
  }
  try {
    if (G.isDirEmptySync(A)) G.rmdirSync(A)
  } catch {
    Z.errors++
  }
  return Z
}
// @from(Start 14756542, End 14758422)
function Hg3() {
  let A = pSA(),
    Q = {
      messages: 0,
      errors: 0
    },
    B = PVA(),
    G = RA();
  try {
    if (!G.existsSync(B)) return Q;
    let I = G.readdirSync(B).filter((Y) => Y.isDirectory()).map((Y) => k$(B, Y.name));
    for (let Y of I) try {
      let J = BW1(Y, A, ".jsonl", G);
      Q.messages += J.messages, Q.errors += J.errors;
      let W = k$(Y, "bash-outputs");
      if (G.existsSync(W)) try {
        let X = G.readdirSync(W);
        for (let V of X)
          if (V.isDirectory()) {
            let F = k$(W, V.name),
              K = BW1(F, A, ".txt", G);
            Q.messages += K.messages, Q.errors += K.errors
          } if (G.isDirEmptySync(W)) G.rmdirSync(W)
      } catch {
        Q.errors++
      }
      if (G.existsSync(Y)) try {
        let X = G.readdirSync(Y);
        for (let V of X) {
          if (!V.isDirectory()) continue;
          if (V.name === "bash-outputs") continue;
          let F = k$(Y, V.name, CV0);
          if (!G.existsSync(F)) continue;
          try {
            let K = G.readdirSync(F);
            for (let D of K) {
              if (!D.isDirectory()) continue;
              let H = k$(F, D.name),
                C = BW1(H, A, "", G);
              Q.messages += C.messages, Q.errors += C.errors;
              try {
                if (G.isDirEmptySync(H)) G.rmdirSync(H)
              } catch {}
            }
            try {
              if (G.isDirEmptySync(F)) G.rmdirSync(F)
            } catch {}
            try {
              let D = k$(Y, V.name);
              if (G.isDirEmptySync(D)) G.rmdirSync(D)
            } catch {}
          } catch {}
        }
      } catch {
        Q.errors++
      }
      try {
        if (G.isDirEmptySync(Y)) G.rmdirSync(Y)
      } catch {}
    } catch {
      Q.errors++;
      continue
    }
  } catch {
    Q.errors++
  }
  return Q
}
// @from(Start 14758424, End 14758778)
function Cg3(A, Q, B = !0) {
  let G = pSA(),
    Z = {
      messages: 0,
      errors: 0
    },
    I = RA();
  try {
    if (!I.existsSync(A)) return Z;
    let Y = BW1(A, G, Q, I);
    if (Z.messages += Y.messages, Z.errors += Y.errors, B) try {
      if (I.isDirEmptySync(A)) I.rmdirSync(A)
    } catch {}
  } catch {
    Z.errors++
  }
  return Z
}
// @from(Start 14758780, End 14758850)
function Eg3() {
  let A = k$(MQ(), "plans");
  return Cg3(A, ".md")
}
// @from(Start 14758852, End 14759462)
function zg3() {
  let A = pSA(),
    Q = {
      messages: 0,
      errors: 0
    },
    B = RA();
  try {
    let G = MQ(),
      Z = k$(G, "file-history");
    if (!B.existsSync(Z)) return Q;
    let Y = B.readdirSync(Z).filter((J) => J.isDirectory()).map((J) => k$(Z, J.name));
    for (let J of Y) try {
      if (!B.existsSync(J)) continue;
      if (B.statSync(J).mtime < A) B.rmSync(J, {
        recursive: !0,
        force: !0
      }), Q.messages++
    } catch {
      Q.errors++
    }
    try {
      if (B.isDirEmptySync(Z)) B.rmdirSync(Z)
    } catch {}
  } catch (G) {
    AA(G)
  }
  return Q
}
// @from(Start 14759464, End 14760073)
function Ug3() {
  let A = pSA(),
    Q = {
      messages: 0,
      errors: 0
    },
    B = RA();
  try {
    let G = MQ(),
      Z = k$(G, "session-env");
    if (!B.existsSync(Z)) return Q;
    let Y = B.readdirSync(Z).filter((J) => J.isDirectory()).map((J) => k$(Z, J.name));
    for (let J of Y) try {
      if (!B.existsSync(J)) continue;
      if (B.statSync(J).mtime < A) B.rmSync(J, {
        recursive: !0,
        force: !0
      }), Q.messages++
    } catch {
      Q.errors++
    }
    try {
      if (B.isDirEmptySync(Z)) B.rmdirSync(Z)
    } catch {}
  } catch (G) {
    AA(G)
  }
  return Q
}
// @from(Start 14760075, End 14760167)
function j$9() {
  setImmediate(() => {
    Dg3(), Hg3(), Eg3(), zg3(), Ug3()
  }).unref()
}
// @from(Start 14760172, End 14760180)
Vg3 = 30
// @from(Start 14760186, End 14760276)
S$9 = L(() => {
  LY1();
  g1();
  R9();
  AQ();
  MB();
  S7();
  hQ();
  jQ();
  V0()
})
// @from(Start 14760282, End 14760333)
_$9 = "com.anthropic.claude_code_browser_extension"
// @from(Start 14760337, End 14760340)
GkI
// @from(Start 14760342, End 14760345)
ZkI
// @from(Start 14760351, End 14760501)
k$9 = L(() => {
  Q3();
  V0();
  g1();
  _8();
  hQ();
  GkI = `${_$9}.json`, ZkI = `HKCU\\Software\\Google\\Chrome\\NativeMessagingHosts\\${_$9}`
})
// @from(Start 14760561, End 14760671)
function qg3() {
  let A = MW(),
    Q = su(A);
  if (Q <= y$9) return Math.floor(Q * 0.8);
  return Q - y$9
}
// @from(Start 14760673, End 14761175)
function Ng3(A) {
  return nJ(A).map((Q) => {
    if (Q.type === "user") {
      if (typeof Q.message.content === "string") return `User: ${Q.message.content}`;
      else if (Array.isArray(Q.message.content)) return `User: ${Q.message.content.filter((B)=>B.type==="text").map((B)=>B.type==="text"?B.text:"").join(`
`).trim()}`
    } else if (Q.type === "assistant") {
      let B = ji(Q);
      if (B) return `Claude: ${RMA(B).trim()}`
    }
    return null
  }).filter((Q) => Q !== null).join(`

`)
}
// @from(Start 14761176, End 14762382)
async function Lg3(A, Q) {
  if (!A.length) throw Error("Can't summarize empty conversation");
  let B = [],
    G = 0,
    Z = qg3(),
    I = null;
  for (let F = A.length - 1; F >= 0; F--) {
    let K = A[F];
    if (!K) continue;
    let D = ZK([K]),
      H = 0;
    if (I !== null && D > 0 && D < I) H = I - D;
    if (G + H > Z) break;
    if (B.unshift(K), G += H, D > 0) I = D
  }
  let Y = B.length < A.length;
  g(Y ? `Summarizing last ${B.length} of ${A.length} messages (~${G} tokens)` : `Summarizing all ${A.length} messages (~${G} tokens)`);
  let J = Ng3(B),
    X = [`Please write a 5-10 word title for the following conversation:

${Y?`[Last ${B.length} of ${A.length} messages]

`:""}${J}
`, "Respond with the title for the conversation and nothing else."];
  return (await uX({
    systemPrompt: [wg3],
    userPrompt: X.join(`
`),
    enablePromptCaching: !0,
    signal: new AbortController().signal,
    options: {
      querySource: "summarize_for_resume",
      agents: [],
      isNonInteractiveSession: Q,
      hasAppendSystemPrompt: !1,
      mcpTools: [],
      agentIdOrSessionId: e1()
    }
  })).message.content.filter((F) => F.type === "text").map((F) => F.text).join("")
}
// @from(Start 14762384, End 14762456)
function Mg3(A) {
  return x$9(PVA(), A.replace(/[^a-zA-Z0-9]/g, "-"))
}
// @from(Start 14762458, End 14762767)
function Og3(A) {
  let Q = RA();
  try {
    Q.statSync(A)
  } catch {
    return []
  }
  return Q.readdirSync(A).filter((G) => G.isFile() && G.name.endsWith(".jsonl")).map((G) => x$9(A, G.name)).sort((G, Z) => {
    let I = Q.statSync(G);
    return Q.statSync(Z).mtime.getTime() - I.mtime.getTime()
  })
}
// @from(Start 14762769, End 14762986)
function Rg3(A, Q) {
  let B = [],
    G = A;
  while (G) {
    let {
      isSidechain: Z,
      parentUuid: I,
      ...Y
    } = G;
    B.unshift(Y), G = G.parentUuid ? Q.get(G.parentUuid) : void 0
  }
  return B
}
// @from(Start 14762988, End 14763149)
function Tg3(A) {
  let Q = new Set([...A.values()].map((B) => B.parentUuid).filter((B) => B !== null));
  return [...A.values()].filter((B) => !Q.has(B.uuid))
}
// @from(Start 14763151, End 14763485)
function Pg3(A) {
  let Q = RA();
  try {
    let {
      buffer: B
    } = Q.readSync(A, {
      length: 512
    }), G = B.toString("utf8"), Z = G.indexOf(`
`);
    if (Z === -1) return JSON.parse(G.trim()).type === "summary";
    let I = G.substring(0, Z);
    return JSON.parse(I).type === "summary"
  } catch {
    return !1
  }
}
// @from(Start 14763486, End 14764097)
async function v$9(A) {
  if (N6()) return;
  let Q = Mg3(W0()),
    B = Og3(Q);
  for (let G of B) try {
    if (Pg3(G)) break;
    if (!nE($g3(G, ".jsonl"))) continue;
    let {
      messages: Y,
      summaries: J
    } = await jVA(G), W = Tg3(Y);
    for (let X of W) {
      if (J.has(X.uuid)) continue;
      let V = Rg3(X, Y);
      if (V.length === 0) continue;
      try {
        let F = await Lg3(V, A);
        if (F) await eE9(X.uuid, F)
      } catch (F) {
        AA(F instanceof Error ? F : Error(String(F)))
      }
    }
  } catch (Z) {
    AA(Z instanceof Error ? Z : Error(String(Z)))
  }
}
// @from(Start 14764102, End 14764105)
wg3
// @from(Start 14764107, End 14764118)
y$9 = 50000
// @from(Start 14764124, End 14764382)
b$9 = L(() => {
  fZ();
  cQ();
  S7();
  g1();
  V0();
  AQ();
  Sy();
  U2();
  GO();
  t2();
  _0();
  wg3 = `
Summarize this coding conversation in under 50 characters.
Capture the main task, key files, problems addressed, and current status.
`.trim()
})
// @from(Start 14764385, End 14764674)
function GW1() {
  return ED0.default.createElement($, null, "MCP servers may execute code or access system resources. All tool calls require approval. Learn more in the", " ", ED0.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/mcp"
  }, "MCP documentation"), ".")
}
// @from(Start 14764679, End 14764682)
ED0
// @from(Start 14764688, End 14764742)
zD0 = L(() => {
  hA();
  hA();
  ED0 = BA(VA(), 1)
})
// @from(Start 14764745, End 14766515)
function f$9({
  serverNames: A,
  onDone: Q
}) {
  function B(Z) {
    let I = l0() || {},
      Y = I.enabledMcpjsonServers || [],
      J = I.disabledMcpjsonServers || [],
      [W, X] = pu0(A, (V) => Z.includes(V));
    if (GA("tengu_mcp_multidialog_choice", {
        approved: W.length,
        rejected: X.length
      }), W.length > 0) {
      let V = [...new Set([...Y, ...W])];
      cB("localSettings", {
        enabledMcpjsonServers: V
      })
    }
    if (X.length > 0) {
      let V = [...new Set([...J, ...X])];
      cB("localSettings", {
        disabledMcpjsonServers: V
      })
    }
    Q()
  }
  let G = EQ();
  return f1((Z, I) => {
    if (I.escape) {
      let J = (l0() || {}).disabledMcpjsonServers || [],
        W = [...new Set([...J, ...A])];
      cB("localSettings", {
        disabledMcpjsonServers: W
      }), Q();
      return
    }
  }), y$.default.createElement(y$.default.Fragment, null, y$.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "warning"
  }, y$.default.createElement($, {
    bold: !0,
    color: "warning"
  }, A.length, " new MCP servers found in .mcp.json"), y$.default.createElement($, null, "Select any you wish to enable."), y$.default.createElement(GW1, null), y$.default.createElement(rJ1, {
    options: A.map((Z) => ({
      label: Z,
      value: Z
    })),
    defaultValue: A,
    onSubmit: B
  })), y$.default.createElement(S, {
    marginLeft: 3
  }, y$.default.createElement($, {
    dimColor: !0
  }, G.pending ? y$.default.createElement(y$.default.Fragment, null, "Press ", G.keyName, " again to exit") : y$.default.createElement(y$.default.Fragment, null, "Space to select · Enter to confirm · Esc to reject all"))))
}
// @from(Start 14766520, End 14766522)
y$
// @from(Start 14766528, End 14766624)
h$9 = L(() => {
  hA();
  ID0();
  MB();
  lu0();
  zD0();
  Q4();
  q0();
  y$ = BA(VA(), 1)
})
// @from(Start 14766627, End 14768443)
function g$9({
  serverName: A,
  onDone: Q
}) {
  function B(Z) {
    switch (GA("tengu_mcp_dialog_choice", {
        choice: Z
      }), Z) {
      case "yes":
      case "yes_all": {
        let Y = (l0() || {}).enabledMcpjsonServers || [];
        if (!Y.includes(A)) cB("localSettings", {
          enabledMcpjsonServers: [...Y, A]
        });
        if (Z === "yes_all") cB("localSettings", {
          enableAllProjectMcpServers: !0
        });
        Q();
        break
      }
      case "no": {
        let Y = (l0() || {}).disabledMcpjsonServers || [];
        if (!Y.includes(A)) cB("localSettings", {
          disabledMcpjsonServers: [...Y, A]
        });
        Q();
        break
      }
    }
  }
  let G = EQ();
  return f1((Z, I) => {
    if (I.escape) {
      Q();
      return
    }
  }), KN.default.createElement(KN.default.Fragment, null, KN.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "warning"
  }, KN.default.createElement($, {
    bold: !0,
    color: "warning"
  }, "New MCP server found in .mcp.json: ", A), KN.default.createElement(GW1, null), KN.default.createElement(M0, {
    options: [{
      label: "Use this and all future MCP servers in this project",
      value: "yes_all"
    }, {
      label: "Use this MCP server",
      value: "yes"
    }, {
      label: "Continue without using this MCP server",
      value: "no"
    }],
    onChange: (Z) => B(Z),
    onCancel: () => B("no")
  })), KN.default.createElement(S, {
    marginLeft: 3
  }, KN.default.createElement($, {
    dimColor: !0
  }, G.pending ? KN.default.createElement(KN.default.Fragment, null, "Press ", G.keyName, " again to exit") : KN.default.createElement(KN.default.Fragment, null, "Enter to confirm · Esc to reject"))))
}
// @from(Start 14768448, End 14768450)
KN
// @from(Start 14768456, End 14768542)
u$9 = L(() => {
  hA();
  J5();
  MB();
  zD0();
  Q4();
  q0();
  KN = BA(VA(), 1)
})
// @from(Start 14768544, End 14769361)
async function m$9() {
  let {
    servers: A
  } = sX("project"), Q = Object.keys(A).filter((B) => C21(B) === "pending");
  if (Q.length === 0) return;
  await new Promise(async (B) => {
    let G = () => {
      process.stdout.write("\x1B[2J\x1B[3J\x1B[H", () => {
        B()
      })
    };
    if (Q.length === 1 && Q[0] !== void 0) {
      let Z = await VG(lSA.default.createElement(yG, null, lSA.default.createElement(g$9, {
        serverName: Q[0],
        onDone: () => {
          Z.unmount?.(), G()
        }
      })), {
        exitOnCtrlC: !1
      })
    } else {
      let Z = await VG(lSA.default.createElement(yG, null, lSA.default.createElement(f$9, {
        serverNames: Q,
        onDone: () => {
          Z.unmount?.(), G()
        }
      })), {
        exitOnCtrlC: !1
      })
    }
  })
}
// @from(Start 14769366, End 14769369)
lSA
// @from(Start 14769375, End 14769463)
d$9 = L(() => {
  hA();
  h$9();
  u$9();
  z9();
  tM();
  nX();
  lSA = BA(VA(), 1)
})
// @from(Start 14769466, End 14769544)
function c$9(A) {
  return A.replace(/[A-Z]/g, (Q) => `_${Q.toLowerCase()}`)
}
// @from(Start 14769545, End 14769861)
async function UD0() {
  if (iSA.length === 0) return;
  let A = [...iSA];
  iSA = [];
  try {
    await YQ.post(jg3, A, {
      headers: {
        "Content-Type": "application/json",
        "DD-API-KEY": Sg3
      },
      timeout: yg3
    })
  } catch (Q) {
    AA(Q instanceof Error ? Q : Error(String(Q)))
  }
}
// @from(Start 14769863, End 14769964)
function bg3() {
  if (Iu) return;
  Iu = setTimeout(() => {
    Iu = null, UD0()
  }, _g3).unref()
}
// @from(Start 14769965, End 14771328)
async function $D0(A, Q) {
  if (!await fg3() || !xg3.has(A)) return;
  try {
    let G = await lc({
        model: Q.model
      }),
      {
        envContext: Z,
        ...I
      } = G,
      Y = {
        ...I,
        ...Z,
        ...Q
      };
    if (typeof Y.toolName === "string" && Y.toolName.startsWith("mcp__")) Y.toolName = "mcp";
    if (typeof Y.model === "string" && !Y.model.startsWith("claude-")) Y.model = "other";
    if (typeof Y.version === "string") Y.version = Y.version.replace(/^(\d+\.\d+\.\d+-dev\.\d{8})\.t\d+\.sha[a-f0-9]+$/, "$1");
    if (Y.status !== void 0 && Y.status !== null) {
      let V = String(Y.status);
      Y.http_status = V;
      let F = V.charAt(0);
      if (F >= "1" && F <= "5") Y.http_status_range = `${F}xx`;
      delete Y.status
    }
    let J = Y,
      X = {
        ddsource: "nodejs",
        ddtags: vg3.filter((V) => J[V] !== void 0 && J[V] !== null).map((V) => `${c$9(V)}:${J[V]}`).join(","),
        message: A,
        service: "claude-code",
        hostname: "claude-code",
        env: "external"
      };
    for (let [V, F] of Object.entries(Y))
      if (F !== void 0 && F !== null) X[c$9(V)] = F;
    if (iSA.push(X), iSA.length >= kg3) {
      if (Iu) clearTimeout(Iu), Iu = null;
      await UD0()
    } else bg3()
  } catch (G) {
    AA(G instanceof Error ? G : Error(String(G)))
  }
}
// @from(Start 14771333, End 14771391)
jg3 = "https://http-intake.logs.datadoghq.com/api/v2/logs"
// @from(Start 14771395, End 14771438)
Sg3 = "pubbc113c03434b701e6e00977875d7382f"
// @from(Start 14771442, End 14771453)
_g3 = 15000
// @from(Start 14771457, End 14771466)
kg3 = 100
// @from(Start 14771470, End 14771480)
yg3 = 5000
// @from(Start 14771484, End 14771487)
xg3
// @from(Start 14771489, End 14771492)
vg3
// @from(Start 14771494, End 14771497)
iSA
// @from(Start 14771499, End 14771508)
Iu = null
// @from(Start 14771512, End 14771515)
fg3
// @from(Start 14771521, End 14772359)
p$9 = L(() => {
  O3();
  l2();
  g1();
  B7A();
  Ft();
  xg3 = new Set(["tengu_api_error", "tengu_api_success", "tengu_compact_failed", "tengu_model_fallback_triggered", "tengu_oauth_error", "tengu_oauth_success", "tengu_oauth_token_refresh_failure", "tengu_oauth_token_refresh_success", "tengu_query_error", "tengu_tool_use_error", "tengu_tool_use_success"]), vg3 = ["arch", "clientType", "errorType", "http_status_range", "http_status", "model", "platform", "provider", "toolName", "userType", "version", "versionBase"];
  iSA = [];
  fg3 = s1(async () => {
    if (fX()) return !1;
    try {
      let A = async () => {
        if (Iu) clearTimeout(Iu), Iu = null;
        await UD0()
      };
      return process.on("beforeExit", A), !0
    } catch (A) {
      return AA(A instanceof Error ? A : Error(String(A))), !1
    }
  })
})
// @from(Start 14772362, End 14772498)
function n$9() {
  if (wD0 !== void 0) return wD0;
  try {
    return N1().cachedStatsigGates[l$9] ?? !1
  } catch {
    return !1
  }
}
// @from(Start 14772500, End 14772636)
function a$9() {
  if (qD0 !== void 0) return qD0;
  try {
    return N1().cachedStatsigGates[i$9] ?? !1
  } catch {
    return !1
  }
}
// @from(Start 14772638, End 14772835)
function hg3(A, Q) {
  let B = Qh1(A);
  if (B === 0) return;
  let G = B !== null ? {
    ...Q,
    sample_rate: B
  } : Q;
  if (SCB(A, G), n$9()) TW0(A, G);
  if (a$9()) $D0(A, G);
  Gh1(A, G)
}
// @from(Start 14772836, End 14773093)
async function gg3(A, Q) {
  let B = Qh1(A);
  if (B === 0) return;
  let G = B !== null ? {
      ...Q,
      sample_rate: B
    } : Q,
    Z = [Hh1(A, G)];
  if (n$9()) Z.push(TW0(A, G));
  if (a$9()) Z.push($D0(A, G));
  Gh1(A, G), await Promise.all(Z)
}
// @from(Start 14773094, End 14773161)
async function s$9() {
  wD0 = await hX(l$9), qD0 = await hX(i$9)
}
// @from(Start 14773163, End 14773236)
function r$9() {
  Hz0({
    logEvent: hg3,
    logEventAsync: gg3
  })
}
// @from(Start 14773241, End 14773273)
l$9 = "tengu_log_segment_events"
// @from(Start 14773277, End 14773309)
i$9 = "tengu_log_datadog_events"
// @from(Start 14773313, End 14773325)
wD0 = void 0
// @from(Start 14773329, End 14773341)
qD0 = void 0
// @from(Start 14773347, End 14773415)
o$9 = L(() => {
  u2();
  PW0();
  p$9();
  jQ();
  CUA();
  q0()
})
// @from(Start 14773421, End 14773424)
ug3
// @from(Start 14773430, End 14773469)
t$9 = L(() => {
  ug3 = BA(p21(), 1)
})
// @from(Start 14773472, End 14775507)
function e$9({
  onAccept: A
}) {
  PK.default.useEffect(() => {
    GA("tengu_bypass_permissions_mode_dialog_shown", {})
  }, []);

  function Q(G) {
    let Z = N1();
    switch (G) {
      case "accept": {
        GA("tengu_bypass_permissions_mode_dialog_accept", {}), c0({
          ...Z,
          bypassPermissionsModeAccepted: !0
        }), A();
        break
      }
      case "decline": {
        l5(1);
        break
      }
    }
  }
  let B = EQ();
  return f1((G, Z) => {
    if (Z.escape) {
      l5(0);
      return
    }
  }), PK.default.createElement(PK.default.Fragment, null, PK.default.createElement(S, {
    flexDirection: "column",
    gap: 1,
    padding: 1,
    borderStyle: "round",
    borderColor: "error"
  }, PK.default.createElement($, {
    bold: !0,
    color: "error"
  }, "WARNING: Claude Code running in Bypass Permissions mode"), PK.default.createElement(S, {
    flexDirection: "column",
    gap: 1
  }, PK.default.createElement($, null, "In Bypass Permissions mode, Claude Code will not ask for your approval before running potentially dangerous commands.", PK.default.createElement(bF, null), "This mode should only be used in a sandboxed container/VM that has restricted internet access and can easily be restored if damaged."), PK.default.createElement($, null, "By proceeding, you accept all responsibility for actions taken while running in Bypass Permissions mode."), PK.default.createElement(h4, {
    url: "https://code.claude.com/docs/en/security"
  })), PK.default.createElement(M0, {
    options: [{
      label: "No, exit",
      value: "decline"
    }, {
      label: "Yes, I accept",
      value: "accept"
    }],
    onChange: (G) => Q(G),
    onCancel: () => Q("decline")
  })), PK.default.createElement(S, {
    marginLeft: 3
  }, PK.default.createElement($, {
    dimColor: !0
  }, B.pending ? PK.default.createElement(PK.default.Fragment, null, "Press ", B.keyName, " again to exit") : PK.default.createElement(PK.default.Fragment, null, "Enter to confirm · Esc to exit"))))
}
// @from(Start 14775512, End 14775514)
PK
// @from(Start 14775520, End 14775613)
Aw9 = L(() => {
  hA();
  J5();
  jQ();
  q0();
  Q4();
  hA();
  kW();
  PK = BA(VA(), 1)
})
// @from(Start 14775616, End 14777004)
function Yu({
  newState: A,
  oldState: Q
}) {
  if (A.mainLoopModel !== Q.mainLoopModel && A.mainLoopModel === null) cB("userSettings", {
    model: void 0
  }), Ts(null);
  if (A.mainLoopModel !== Q.mainLoopModel && A.mainLoopModel !== null) cB("userSettings", {
    model: A.mainLoopModel
  }), Ts(A.mainLoopModel);
  if (A.showExpandedTodos !== Q.showExpandedTodos && N1().showExpandedTodos !== A.showExpandedTodos) c0({
    ...N1(),
    showExpandedTodos: A.showExpandedTodos
  });
  if (Q !== null && A.todos !== Q.todos)
    for (let B in A.todos) UYA(A.todos[B], B);
  if (A.verbose !== Q.verbose && N1().verbose !== A.verbose) c0({
    ...N1(),
    verbose: A.verbose
  });
  if (A.thinkingEnabled !== Q.thinkingEnabled) cB("userSettings", {
    alwaysThinkingEnabled: A.thinkingEnabled
  });
  if (A.feedbackSurvey.timeLastShown !== Q.feedbackSurvey.timeLastShown && A.feedbackSurvey.timeLastShown !== null) c0({
    ...N1(),
    feedbackSurveyState: {
      lastShownTime: A.feedbackSurvey.timeLastShown
    }
  });
  if (bZ() && (A.mcp.tools.length > 0 || A.mcp.clients.length > 0 || Object.keys(A.mcp.resources).length > 0 || A.mcp !== Q.mcp)) {
    if (Yz9(A.mcp.clients, A.mcp.tools, A.mcp.resources), xVA()) pJ1()
  }
  if (A.settings !== Q.settings) try {
    LiA(), MiA()
  } catch (B) {
    AA(B instanceof Error ? B : Error(`Failed to clear auth caches: ${B}`))
  }
}
// @from(Start 14777009, End 14777108)
Qw9 = L(() => {
  jQ();
  jQ();
  _0();
  MB();
  Ti();
  _VA();
  dH();
  lJ1();
  gB();
  g1()
})
// @from(Start 14777111, End 14777812)
function Bw9() {
  let A = N1();
  if (A.autoUpdates !== !1 || A.autoUpdatesProtectedForNative === !0) return;
  try {
    let Q = OB("userSettings") || {};
    cB("userSettings", {
      ...Q,
      env: {
        ...Q.env,
        DISABLE_AUTOUPDATER: "1"
      }
    }), GA("tengu_migrate_autoupdates_to_settings", {
      was_user_preference: !0,
      already_had_env_var: !!Q.env?.DISABLE_AUTOUPDATER
    }), process.env.DISABLE_AUTOUPDATER = "1";
    let {
      autoUpdates: B,
      autoUpdatesProtectedForNative: G,
      ...Z
    } = A;
    c0(Z)
  } catch (Q) {
    AA(Error(`Failed to migrate auto-updates: ${Q}`)), GA("tengu_migrate_autoupdates_error", {
      has_error: !0
    })
  }
}
// @from(Start 14777817, End 14777866)
Gw9 = L(() => {
  jQ();
  MB();
  q0();
  g1()
})
// @from(Start 14777869, End 14779384)
function Zw9() {
  let A = j5(),
    Q = A.enableAllProjectMcpServers !== void 0,
    B = A.enabledMcpjsonServers && A.enabledMcpjsonServers.length > 0,
    G = A.disabledMcpjsonServers && A.disabledMcpjsonServers.length > 0;
  if (!Q && !B && !G) return;
  try {
    let Z = OB("localSettings") || {},
      I = {},
      Y = [];
    if (Q && Z.enableAllProjectMcpServers === void 0) I.enableAllProjectMcpServers = A.enableAllProjectMcpServers, Y.push("enableAllProjectMcpServers");
    else if (Q) Y.push("enableAllProjectMcpServers");
    if (B && A.enabledMcpjsonServers) {
      let J = Z.enabledMcpjsonServers || [];
      I.enabledMcpjsonServers = [...new Set([...J, ...A.enabledMcpjsonServers])], Y.push("enabledMcpjsonServers")
    }
    if (G && A.disabledMcpjsonServers) {
      let J = Z.disabledMcpjsonServers || [];
      I.disabledMcpjsonServers = [...new Set([...J, ...A.disabledMcpjsonServers])], Y.push("disabledMcpjsonServers")
    }
    if (Object.keys(I).length > 0) cB("localSettings", I);
    if (Y.length > 0) {
      let J = j5(),
        {
          enableAllProjectMcpServers: W,
          enabledMcpjsonServers: X,
          disabledMcpjsonServers: V,
          ...F
        } = J;
      if (Y.includes("enableAllProjectMcpServers") || Y.includes("enabledMcpjsonServers") || Y.includes("disabledMcpjsonServers")) AY(F)
    }
    GA("tengu_migrate_mcp_approval_fields_success", {
      migratedCount: Y.length
    })
  } catch {
    GA("tengu_migrate_mcp_approval_fields_error", {})
  }
}
// @from(Start 14779389, End 14779430)
Iw9 = L(() => {
  jQ();
  MB();
  q0()
})
// @from(Start 14779472, End 14779640)
function dg3(A) {
  let Q = VxA(A).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  return mg3.isAbsolute(Q) && !Q.startsWith("//") ? "/" + Q : Q
}
// @from(Start 14779642, End 14780545)
function Yw9() {
  let A = j5(),
    Q = A.ignorePatterns;
  if (!Q || !Array.isArray(Q) || Q.length === 0) return;
  let B = [];
  for (let I of Q) {
    let Y = dg3(I);
    B.push({
      toolName: "Read",
      ruleContent: Y
    }, {
      toolName: "Edit",
      ruleContent: Y
    })
  }
  if (JxA({
      ruleValues: B,
      ruleBehavior: "deny"
    }, "localSettings")) try {
    delete A.ignorePatterns, AY(A), GA("tengu_migrate_ignore_patterns_success", {
      ignore_patterns_count: Q.length
    })
  } catch (I) {
    AA(Error(`Failed to remove ignorePatterns from config: ${I instanceof Error?I.message:String(I)}`)), GA("tengu_migrate_ignore_patterns_config_cleanup_error", {
      ignore_patterns_count: Q.length
    })
  } else AA(Error("Failed to migrate ignorePatterns to settings permissions")), GA("tengu_migrate_ignore_patterns_error", {
    ignore_patterns_count: Q.length
  })
}
// @from(Start 14780550, End 14780607)
Jw9 = L(() => {
  jQ();
  q0();
  g1();
  EJ();
  is()
})
// @from(Start 14780610, End 14781029)
function Ww9() {
  if (N1().sonnet45MigrationComplete) return;
  if (V6() !== "firstParty") {
    c0({
      ...N1(),
      sonnet45MigrationComplete: !0
    });
    return
  }
  if (l0()?.model !== void 0) cB("userSettings", {
    model: void 0
  }), c0({
    ...N1(),
    sonnet45MigrationComplete: !0,
    sonnet45MigrationTimestamp: Date.now()
  });
  else c0({
    ...N1(),
    sonnet45MigrationComplete: !0
  })
}
// @from(Start 14781034, End 14781075)
Xw9 = L(() => {
  jQ();
  MB();
  lK()
})
// @from(Start 14781078, End 14781427)
function Vw9() {
  if (N1().opus45MigrationComplete) return;
  let Q = V6(),
    B = UUA() || $UA();
  if (Q !== "firstParty" || !B) {
    c0({
      ...N1(),
      opus45MigrationComplete: !0
    });
    return
  }
  if (l0()?.model !== void 0) cB("userSettings", {
    model: void 0
  });
  c0({
    ...N1(),
    opus45MigrationComplete: !0
  })
}
// @from(Start 14781432, End 14781481)
Fw9 = L(() => {
  jQ();
  MB();
  lK();
  t2()
})
// @from(Start 14781484, End 14782005)
function nSA(A, Q, B, G) {
  let Z = {
    type: "permissionPromptTool",
    permissionPromptToolName: Q.name,
    toolResult: A
  };
  if (A.behavior === "allow") {
    let I = A.updatedPermissions;
    if (I) G.setAppState((Y) => ({
      ...Y,
      toolPermissionContext: jm(Y.toolPermissionContext, I)
    })), QKA(I);
    return {
      ...A,
      decisionReason: Z
    }
  } else if (A.behavior === "deny" && A.interrupt) G.abortController.abort("tool-rejection");
  return {
    ...A,
    decisionReason: Z
  }
}
// @from(Start 14782010, End 14782013)
tyI
// @from(Start 14782015, End 14782018)
cg3
// @from(Start 14782020, End 14782023)
pg3
// @from(Start 14782025, End 14782028)
ZW1
// @from(Start 14782034, End 14782719)
ND0 = L(() => {
  Q2();
  _00();
  cK();
  tyI = W2.object({
    tool_name: W2.string().describe("The name of the tool requesting permission"),
    input: W2.record(W2.unknown()).describe("The input for the tool"),
    tool_use_id: W2.string().optional().describe("The unique tool use request ID")
  }), cg3 = W2.object({
    behavior: W2.literal("allow"),
    updatedInput: W2.record(W2.unknown()),
    updatedPermissions: W2.array(A91).optional(),
    toolUseID: W2.string().optional()
  }), pg3 = W2.object({
    behavior: W2.literal("deny"),
    message: W2.string(),
    interrupt: W2.boolean().optional(),
    toolUseID: W2.string().optional()
  }), ZW1 = W2.union([cg3, pg3])
})
// @from(Start 14782768, End 14783094)
function ig3(A) {
  if (!A) return;
  switch (A.type) {
    case "rule":
    case "mode":
    case "subcommandResults":
    case "permissionPromptTool":
      return;
    case "hook":
    case "asyncAgent":
    case "sandboxOverride":
    case "classifier":
    case "workingDir":
    case "other":
      return A.reason
  }
}
// @from(Start 14783095, End 14787850)
class aSA {
  input;
  replayUserMessages;
  structuredInput;
  pendingRequests = new Map;
  inputClosed = !1;
  unexpectedResponseCallback;
  constructor(A, Q) {
    this.input = A;
    this.replayUserMessages = Q;
    this.input = A, this.structuredInput = this.read()
  }
  async * read() {
    let A = "";
    for await (let Q of this.input) {
      A += Q;
      let B;
      while ((B = A.indexOf(`
`)) !== -1) {
        let G = A.slice(0, B);
        A = A.slice(B + 1);
        let Z = await this.processLine(G);
        if (Z) yield Z
      }
    }
    if (A) {
      let Q = await this.processLine(A);
      if (Q) yield Q
    }
    this.inputClosed = !0;
    for (let Q of this.pendingRequests.values()) Q.reject(Error("Tool permission stream closed before response received"))
  }
  getPendingPermissionRequests() {
    return this.pendingRequests.values().map((A) => A.request).filter((A) => A.request.subtype === "can_use_tool").toArray()
  }
  setUnexpectedResponseCallback(A) {
    this.unexpectedResponseCallback = A
  }
  async processLine(A) {
    try {
      let Q = JSON.parse(A);
      if (Q.type === "keep_alive") return;
      if (Q.type === "control_response") {
        let B = this.pendingRequests.get(Q.response.request_id);
        if (!B) {
          if (this.unexpectedResponseCallback) await this.unexpectedResponseCallback(Q);
          return
        }
        if (this.pendingRequests.delete(Q.response.request_id), Q.response.subtype === "error") {
          B.reject(Error(Q.response.error));
          return
        }
        let G = Q.response.response;
        if (B.schema) try {
          B.resolve(B.schema.parse(G))
        } catch (Z) {
          B.reject(Z)
        } else B.resolve({});
        if (this.replayUserMessages) return Q;
        return
      }
      if (Q.type !== "user" && Q.type !== "control_request") LD0(`Error: Expected message type 'user' or 'control', got '${Q.type}'`);
      if (Q.type === "control_request") {
        if (!Q.request) LD0("Error: Missing request on control_request");
        return Q
      }
      if (Q.message.role !== "user") LD0(`Error: Expected message role 'user', got '${Q.message.role}'`);
      return Q
    } catch (Q) {
      console.error(`Error parsing streaming input line: ${A}: ${Q}`), process.exit(1)
    }
  }
  write(A) {
    L9(JSON.stringify(A) + `
`)
  }
  async sendRequest(A, Q, B) {
    let G = lg3(),
      Z = {
        type: "control_request",
        request_id: G,
        request: A
      };
    if (this.inputClosed) throw Error("Stream closed");
    if (B?.aborted) throw Error("Request aborted");
    this.write(Z);
    let I = () => {
      this.write({
        type: "control_cancel_request",
        request_id: G
      });
      let Y = this.pendingRequests.get(G);
      if (Y) Y.reject(new WW)
    };
    if (B) B.addEventListener("abort", I, {
      once: !0
    });
    try {
      return await new Promise((Y, J) => {
        this.pendingRequests.set(G, {
          request: {
            type: "control_request",
            request_id: G,
            request: A
          },
          resolve: (W) => {
            Y(W)
          },
          reject: J,
          schema: Q
        })
      })
    } finally {
      if (B) B.removeEventListener("abort", I);
      this.pendingRequests.delete(G)
    }
  }
  createCanUseTool() {
    return async (A, Q, B, G, Z) => {
      let I = await M$(A, Q, B, G, Z);
      if (I.behavior === "allow" || I.behavior === "deny") return I;
      try {
        let Y = await this.sendRequest({
          subtype: "can_use_tool",
          tool_name: A.name,
          input: Q,
          permission_suggestions: I.suggestions,
          blocked_path: I.blockedPath,
          decision_reason: ig3(I.decisionReason),
          tool_use_id: Z,
          agent_id: B.agentId
        }, ZW1, B.abortController.signal);
        return nSA(Y, A, Q, B)
      } catch (Y) {
        return nSA({
          behavior: "deny",
          message: `Tool permission request failed: ${Y}`,
          toolUseID: Z
        }, A, Q, B)
      }
    }
  }
  createHookCallback(A, Q) {
    return {
      type: "callback",
      timeout: Q,
      callback: async (B, G, Z) => {
        try {
          return await this.sendRequest({
            subtype: "hook_callback",
            callback_id: A,
            input: B,
            tool_use_id: G || void 0
          }, Q91, Z)
        } catch (I) {
          return console.error(`Error in hook callback ${A}:`, I), {}
        }
      }
    }
  }
  async sendMcpMessage(A, Q) {
    return (await this.sendRequest({
      subtype: "mcp_message",
      server_name: A,
      message: Q
    }, j.object({
      mcp_response: j.any()
    }))).mcp_response
  }
}
// @from(Start 14787852, End 14787907)
function LD0(A) {
  console.error(A), process.exit(1)
}
// @from(Start 14787912, End 14787971)
MD0 = L(() => {
  AZ();
  Q2();
  ND0();
  k00();
  RZ()
})
// @from(Start 14787973, End 14793201)
class OD0 {
  ws = null;
  lastSentId = null;
  url;
  state = "idle";
  onData;
  onCloseCallback;
  headers;
  reconnectAttempts = 0;
  reconnectTimer = null;
  pingInterval = null;
  messageBuffer;
  constructor(A, Q = {}) {
    this.url = A, this.headers = Q, this.messageBuffer = new K$A(ng3)
  }
  connect() {
    if (this.state !== "idle" && this.state !== "reconnecting") {
      g(`WebSocketTransport: Cannot connect, current state is ${this.state}`, {
        level: "error"
      }), k6("error", "cli_websocket_connect_failed");
      return
    }
    this.state = "reconnecting", g(`WebSocketTransport: Opening ${this.url.href}`), k6("info", "cli_websocket_connect_opening");
    let A = {
      ...this.headers
    };
    if (this.lastSentId) A["X-Last-Request-Id"] = this.lastSentId, g(`WebSocketTransport: Adding X-Last-Request-Id header: ${this.lastSentId}`);
    this.ws = new __(this.url.href, {
      headers: A,
      agent: RzA(this.url.href)
    }), this.ws.on("open", () => {
      g("WebSocketTransport: Connected"), k6("info", "cli_websocket_connect_connected");
      let Q = this.ws.upgradeReq;
      if (Q?.headers?.["x-last-request-id"]) {
        let B = Q.headers["x-last-request-id"];
        this.replayBufferedMessages(B)
      }
      this.reconnectAttempts = 0, this.state = "connected", this.startPingInterval()
    }), this.ws.on("message", (Q) => {
      let B = Q.toString();
      if (this.onData) this.onData(B)
    }), this.ws.on("error", (Q) => {
      g(`WebSocketTransport: Error: ${Q.message}`, {
        level: "error"
      }), k6("error", "cli_websocket_connect_error"), this.handleConnectionError()
    }), this.ws.on("close", (Q, B) => {
      g(`WebSocketTransport: Closed: ${Q}`, {
        level: "error"
      }), k6("error", "cli_websocket_connect_closed"), this.handleConnectionError()
    })
  }
  sendLine(A) {
    if (!this.ws || this.state !== "connected") return g("WebSocketTransport: Not connected"), k6("info", "cli_websocket_send_not_connected"), !1;
    try {
      return this.ws.send(A), !0
    } catch (Q) {
      return g(`WebSocketTransport: Failed to send: ${Q}`, {
        level: "error"
      }), k6("error", "cli_websocket_send_error"), this.ws = null, this.handleConnectionError(), !1
    }
  }
  doDisconnect() {
    if (this.stopPingInterval(), this.ws) this.ws.close(), this.ws = null
  }
  handleConnectionError() {
    if (g(`WebSocketTransport: Disconnected from ${this.url.href}`), k6("info", "cli_websocket_disconnected"), this.doDisconnect(), this.state === "closing" || this.state === "closed") return;
    if (this.reconnectAttempts < Kw9) {
      if (this.reconnectTimer) clearTimeout(this.reconnectTimer), this.reconnectTimer = null;
      this.state = "reconnecting", this.reconnectAttempts++;
      let A = Math.min(ag3 * Math.pow(2, this.reconnectAttempts - 1), sg3);
      g(`WebSocketTransport: Reconnecting in ${A}ms (attempt ${this.reconnectAttempts}/${Kw9})`), k6("error", "cli_websocket_reconnect_attempt", {
        reconnectAttempts: this.reconnectAttempts
      }), this.reconnectTimer = setTimeout(() => {
        this.reconnectTimer = null, this.connect()
      }, A)
    } else if (g(`WebSocketTransport: Max reconnection attempts reached for ${this.url.href}`, {
        level: "error"
      }), k6("error", "cli_websocket_reconnect_exhausted", {
        reconnectAttempts: this.reconnectAttempts
      }), this.state = "closed", this.onCloseCallback) this.onCloseCallback()
  }
  close() {
    if (this.reconnectTimer) clearTimeout(this.reconnectTimer), this.reconnectTimer = null;
    this.stopPingInterval(), this.state = "closing", this.doDisconnect()
  }
  replayBufferedMessages(A) {
    let Q = this.messageBuffer.toArray();
    if (Q.length === 0) return;
    let B = 0;
    if (A) {
      let Z = Q.findIndex((I) => ("uuid" in I) && I.uuid === A);
      if (Z >= 0) B = Z + 1
    }
    let G = Q.slice(B);
    if (G.length === 0) {
      g("WebSocketTransport: No new messages to replay"), k6("info", "cli_websocket_no_messages_to_replay");
      return
    }
    g(`WebSocketTransport: Replaying ${G.length} buffered messages`), k6("info", "cli_websocket_messages_to_replay", {
      count: G.length
    });
    for (let Z of G) {
      let I = JSON.stringify(Z) + `
`;
      if (!this.sendLine(I)) {
        this.handleConnectionError();
        break
      }
    }
  }
  isConnectedStatus() {
    return this.state === "connected"
  }
  setOnData(A) {
    this.onData = A
  }
  setOnClose(A) {
    this.onCloseCallback = A
  }
  write(A) {
    if ("uuid" in A && typeof A.uuid === "string") this.messageBuffer.add(A), this.lastSentId = A.uuid;
    let Q = JSON.stringify(A) + `
`;
    if (this.state !== "connected") return;
    this.sendLine(Q)
  }
  startPingInterval() {
    this.stopPingInterval(), this.pingInterval = setInterval(() => {
      if (this.state === "connected" && this.ws) try {
        this.ws.ping()
      } catch (A) {
        g(`WebSocketTransport: Ping failed: ${A}`, {
          level: "error"
        }), k6("error", "cli_websocket_ping_failed")
      }
    }, rg3)
  }
  stopPingInterval() {
    if (this.pingInterval) clearInterval(this.pingInterval), this.pingInterval = null
  }
}
// @from(Start 14793206, End 14793216)
ng3 = 1000
// @from(Start 14793220, End 14793227)
Kw9 = 3
// @from(Start 14793231, End 14793241)
ag3 = 1000
// @from(Start 14793245, End 14793256)
sg3 = 30000
// @from(Start 14793260, End 14793269)
rg3 = 1e4
// @from(Start 14793275, End 14793326)
Dw9 = L(() => {
  dUA();
  V0();
  _c();
  NIA()
})
// @from(Start 14793329, End 14793489)
function Hw9(A, Q = {}) {
  if (A.protocol === "ws:" || A.protocol === "wss:") return new OD0(A, Q);
  else throw Error(`Unsupported protocol: ${A.protocol}`)
}
// @from(Start 14793494, End 14793520)
Cw9 = L(() => {
  Dw9()
})
// @from(Start 14793609, End 14793612)
RD0
// @from(Start 14793618, End 14794512)
Ew9 = L(() => {
  MD0();
  Cw9();
  HH();
  yQ1();
  RD0 = class RD0 extends aSA {
    url;
    transport;
    inputStream;
    constructor(A, Q, B) {
      let G = new tg3({
        encoding: "utf8"
      });
      super(G, B);
      this.inputStream = G, this.url = new og3(A);
      let Z = {},
        I = cAA();
      if (I) Z.Authorization = `Bearer ${I}`;
      if (this.transport = Hw9(this.url, Z), this.transport.setOnData((Y) => {
          this.inputStream.write(Y)
        }), this.transport.setOnClose(() => {
          this.inputStream.end()
        }), this.transport.connect(), PG(async () => this.close()), Q) {
        let Y = this.inputStream;
        (async () => {
          for await (let J of Q) Y.write(J + `
`)
        })()
      }
    }
    write(A) {
      this.transport.write(A)
    }
    close() {
      this.transport.close(), this.inputStream.end()
    }
  }
})
// @from(Start 14794515, End 14794987)
function zw9(A) {
  let Q = process.env.CLAUDE_CODE_EXIT_AFTER_STOP_DELAY,
    B = Q ? parseInt(Q, 10) : null,
    G = B && !isNaN(B) && B > 0,
    Z = null,
    I = 0;
  return {
    start() {
      if (Z) clearTimeout(Z), Z = null;
      if (G) I = Date.now(), Z = setTimeout(() => {
        let Y = Date.now() - I;
        if (A() && Y >= B) g(`Exiting after ${B}ms of idle time`), l5()
      }, B)
    },
    stop() {
      if (Z) clearTimeout(Z), Z = null
    }
  }
}
// @from(Start 14794992, End 14795025)
Uw9 = L(() => {
  V0();
  kW()
})
// @from(Start 14795074, End 14795575)
function ww9(A) {
  try {
    let Q = new URL(A);
    return {
      sessionId: $w9(),
      ingressUrl: Q.href,
      isUrl: !0,
      jsonlFile: null,
      isJsonlFile: !1
    }
  } catch {
    if (nE(A)) return {
      sessionId: A,
      ingressUrl: null,
      isUrl: !1,
      jsonlFile: null,
      isJsonlFile: !1
    };
    if (A.endsWith(".jsonl")) return {
      sessionId: $w9(),
      ingressUrl: null,
      isUrl: !1,
      jsonlFile: A,
      isJsonlFile: !0
    }
  }
  return null
}
// @from(Start 14795580, End 14795605)
qw9 = L(() => {
  Sy()
})
// @from(Start 14795608, End 14796091)
function Nw9(A) {
  let Q = A.find((B) => B.name === "claude-vscode");
  if (Q && Q.type === "connected") {
    Q.client.setNotificationHandler(eg3, async (G) => {
      let {
        eventName: Z,
        eventData: I
      } = G.params;
      GA(`tengu_vscode_${Z}`, I)
    });
    let B = {
      tengu_vscode_review_upsell: o2("tengu_vscode_review_upsell")
    };
    Q.client.notification({
      method: "experiment_gates",
      params: {
        gates: B
      }
    })
  }
}
// @from(Start 14796096, End 14796099)
eg3
// @from(Start 14796105, End 14796310)
Lw9 = L(() => {
  Q2();
  q0();
  u2();
  eg3 = j.object({
    method: j.literal("log_event"),
    params: j.object({
      eventName: j.string(),
      eventData: j.object({}).passthrough()
    })
  })
})
// @from(Start 14796398, End 14799141)
async function Rw9(A, Q, B, G, Z, I, Y, J) {
  if (await fYA()) await $D9();
  if (nQ.isSandboxingEnabled()) try {
    await nQ.initialize()
  } catch (q) {
    process.stderr.write(`
❌ Sandbox Error: ${q instanceof Error?q.message:String(q)}
`), l5(1, "other");
    return
  }
  if (J.resumeSessionAt && !J.resume) {
    process.stderr.write(`Error: --resume-session-at requires --resume
`), l5(1);
    return
  }
  let W = await Q(),
    X = await Ju3(B, {
      continue: J.continue,
      teleport: J.teleport,
      resume: J.resume,
      resumeSessionAt: J.resumeSessionAt,
      forkSession: J.forkSession
    }),
    V = typeof J.resume === "string" && (Boolean(nE(J.resume)) || J.resume.endsWith(".jsonl")),
    F = Boolean(J.sdkUrl);
  if (!A && !V && !F) {
    process.stderr.write(`Error: Input must be provided either through stdin or as a prompt argument when using --print
`), l5(1);
    return
  }
  if (J.outputFormat === "stream-json" && !J.verbose) {
    process.stderr.write(`Error: When using --print, --output-format=stream-json requires --verbose
`), l5(1);
    return
  }
  let K = bZ() ? Z : [...Z, ...W.mcp.tools],
    D = Wu3(A, J),
    H = J.sdkUrl ? "stdio" : J.permissionPromptToolName,
    C = Gu3(H, D, W.mcp.tools);
  if (J.permissionPromptToolName) K = K.filter((q) => q.name !== J.permissionPromptToolName);
  let E = [];
  for await (let q of Qu3(D, W.mcp.clients, [...G, ...W.mcp.commands], K, X, C, I, Q, B, Y, J)) {
    if (J.outputFormat === "stream-json" && J.verbose) D.write(q);
    if (q.type !== "control_response" && q.type !== "control_request" && q.type !== "control_cancel_request" && q.type !== "stream_event" && q.type !== "keep_alive") E.push(q)
  }
  let U = dC(E);
  switch (J.outputFormat) {
    case "json":
      if (!U || U.type !== "result") throw Error("No messages returned");
      if (J.verbose) {
        L9(JSON.stringify(E) + `
`);
        break
      }
      L9(JSON.stringify(U) + `
`);
      break;
    case "stream-json":
      break;
    default:
      if (!U || U.type !== "result") throw Error("No messages returned");
      switch (U.subtype) {
        case "success":
          L9(U.result.endsWith(`
`) ? U.result : U.result + `
`);
          break;
        case "error_during_execution":
          L9("Execution error");
          break;
        case "error_max_turns":
          L9(`Error: Reached max turns (${J.maxTurns})`);
          break;
        case "error_max_budget_usd":
          L9(`Error: Exceeded USD budget (${J.maxBudgetUsd})`);
          break;
        case "error_max_structured_output_retries":
          L9("Error: Failed to provide valid structured output after maximum retries")
      }
  }
  l5(U?.type === "result" && U?.is_error ? 1 : 0)
}
// @from(Start 14799143, End 14806690)
function Qu3(A, Q, B, G, Z, I, Y, J, W, X, V) {
  let F = !1,
    K = !1,
    D, H = new YSA;
  if (V.enableAuthStatus) vH.getInstance().subscribe((k) => {
    H.enqueue({
      type: "auth_status",
      isAuthenticating: k.isAuthenticating,
      output: k.output,
      error: k.error,
      uuid: IW1(),
      session_id: e1()
    })
  });
  let C = VQ9(Z),
    E = [],
    U = !1,
    q = Z;
  for (let l of C)
    if (l.type === "system" && l.subtype === "hook_response" && l.hook_event === "SessionStart") E.push(l);
  let N = lnA().map((l) => {
      return {
        value: l.value === null ? "default" : l.value,
        displayName: l.label,
        description: l.description
      }
    }),
    R = V.userSpecifiedModel,
    T = [],
    y = [];
  async function v() {
    let l = new Set(Object.keys(Y)),
      k = new Set(T.map((FA) => FA.name)),
      m = Array.from(l).some((FA) => !k.has(FA)),
      o = Array.from(k).some((FA) => !l.has(FA));
    if (m || o) {
      for (let zA of T)
        if (!l.has(zA.name)) {
          if (zA.type === "connected") await zA.cleanup()
        } let FA = await x32(Y, (zA, NA) => A.sendMcpMessage(zA, NA));
      T = FA.clients, y = FA.tools, Nw9(T)
    }
  }
  v();
  let x = zw9(() => !F),
    p = async () => {
      if (F) return;
      if (F = !0, x.stop(), !U) {
        U = !0;
        for (let o of E) H.enqueue(o)
      }
      await v();
      let l = [...Q, ...T],
        k = [...G, ...y],
        m = xX1();
      if (m && !V.jsonSchema) {
        let o = yI1(m);
        if (o) k = [...k, o]
      }
      try {
        let o;
        while (o = await n89(J, W)) {
          if (o.mode !== "prompt" && o.mode !== "orphaned-permission") throw Error("only prompt commands are supported in streaming mode");
          let IA = o.value;
          D = o9();
          for await (let FA of o59({
            commands: B,
            prompt: IA,
            promptUuid: o.uuid,
            cwd: Au3(),
            tools: k,
            verbose: V.verbose,
            mcpClients: l,
            maxThinkingTokens: V.maxThinkingTokens,
            maxTurns: V.maxTurns,
            maxBudgetUsd: V.maxBudgetUsd,
            canUseTool: I,
            userSpecifiedModel: R,
            fallbackModel: V.fallbackModel,
            jsonSchema: xX1() ?? V.jsonSchema,
            sdkBetas: V.sdkBetas,
            mutableMessages: q,
            customSystemPrompt: V.systemPrompt,
            appendSystemPrompt: V.appendSystemPrompt,
            getAppState: J,
            setAppState: W,
            abortController: D,
            replayUserMessages: V.replayUserMessages,
            includePartialMessages: V.includePartialMessages,
            agents: X,
            orphanedPermission: o.orphanedPermission,
            setSDKStatus: (zA) => {
              H.enqueue({
                type: "system",
                subtype: "status",
                status: zA,
                session_id: e1(),
                uuid: IW1()
              })
            }
          })) {
            let zA = (FA.type === "assistant" || FA.type === "user") && FA.parent_tool_use_id,
              NA = FA.type === "user" && "isReplay" in FA && FA.isReplay;
            if (!zA && !NA && FA.type !== "stream_event") C.push(FA);
            H.enqueue(FA)
          }
        }
      } catch (o) {
        try {
          A.write({
            type: "result",
            subtype: "error_during_execution",
            duration_ms: 0,
            duration_api_ms: 0,
            is_error: !0,
            num_turns: 0,
            session_id: e1(),
            total_cost_usd: 0,
            usage: bO,
            modelUsage: {},
            permission_denials: [],
            uuid: IW1(),
            errors: [o instanceof Error ? o.message : String(o), ...z2A().map((IA) => IA.error)]
          })
        } catch {}
        l5(1);
        return
      } finally {
        F = !1, x.start()
      }
      if (K) H.done()
    }, u = function(l, k) {
      H.enqueue({
        type: "control_response",
        response: {
          subtype: "success",
          request_id: l.request_id,
          response: k
        }
      })
    }, e = function(l, k) {
      H.enqueue({
        type: "control_response",
        response: {
          subtype: "error",
          request_id: l.request_id,
          error: k
        }
      })
    };
  return A.setUnexpectedResponseCallback(async (l) => {
    await Xu3({
      message: l,
      setAppState: W,
      onEnqueued: () => {
        p()
      }
    })
  }), (async () => {
    let l = !1;
    for await (let k of A.structuredInput) {
      if (k.type === "control_request") {
        if (k.request.subtype === "interrupt") {
          if (D) D.abort();
          u(k)
        } else if (k.request.subtype === "initialize") {
          if (k.request.sdkMcpServers && k.request.sdkMcpServers.length > 0)
            for (let m of k.request.sdkMcpServers) Y[m] = {
              type: "sdk",
              name: m
            };
          await Zu3(k.request, k.request_id, l, H, B, N, A, !!V.enableAuthStatus, V, X), l = !0
        } else if (k.request.subtype === "set_permission_mode") {
          let m = k.request;
          W((o) => ({
            ...o,
            toolPermissionContext: Yu3(m, k.request_id, o.toolPermissionContext, H)
          })), u(k)
        } else if (k.request.subtype === "set_model") {
          let m = k.request.model === "default" ? jt() : k.request.model;
          R = m, Ts(m), u(k)
        } else if (k.request.subtype === "set_max_thinking_tokens") {
          if (k.request.max_thinking_tokens === null) V.maxThinkingTokens = void 0;
          else V.maxThinkingTokens = k.request.max_thinking_tokens;
          u(k)
        } else if (k.request.subtype === "mcp_status") {
          let m = [...Q, ...T].map((o) => {
            return {
              name: o.name,
              status: o.type,
              serverInfo: o.type === "connected" ? o.serverInfo : void 0
            }
          });
          u(k, {
            mcpServers: m
          })
        } else if (k.request.subtype === "mcp_message") {
          let m = k.request,
            o = T.find((IA) => IA.name === m.server_name);
          if (o && o.type === "connected") {
            if (o.client.transport?.onmessage) o.client.transport.onmessage(m.message)
          }
          u(k)
        } else if (k.request.subtype === "rewind_code") {
          let m = await J(),
            o = await Iu3(k.request.user_message_id, m, W);
          if (!o) u(k);
          else e(k, o)
        }
        continue
      } else if (k.type === "control_response") {
        if (V.replayUserMessages) H.enqueue(k);
        continue
      } else if (k.type === "keep_alive") continue;
      if (l = !0, k.uuid) {
        let m = e1();
        if (await Qz9(m, k.uuid) || Mw9.has(k.uuid)) {
          if (g(`Skipping duplicate user message: ${k.uuid}`), V.replayUserMessages) g(`Sending acknowledgment for duplicate user message: ${k.uuid}`), H.enqueue({
            type: "user",
            message: k.message,
            session_id: m,
            parent_tool_use_id: null,
            uuid: k.uuid,
            isReplay: !0
          });
          continue
        }
        Mw9.add(k.uuid)
      }
      W((m) => ({
        ...m,
        queuedCommands: [...m.queuedCommands, {
          mode: "prompt",
          value: k.message.content,
          uuid: k.uuid
        }]
      })), p()
    }
    if (K = !0, !F) H.done()
  })(), H
}
// @from(Start 14806692, End 14807644)
function Bu3(A) {
  let Q = async (B, G, Z, I, Y) => {
    let J = await M$(B, G, Z, I, Y);
    if (J.behavior === "allow" || J.behavior === "deny") return J;
    let W = await A.call({
      tool_name: B.name,
      input: G,
      tool_use_id: Y
    }, Z, Q, I);
    if (Z.abortController.signal.aborted) return {
      behavior: "deny",
      message: "Permission prompt was aborted.",
      decisionReason: {
        type: "permissionPromptTool",
        permissionPromptToolName: B.name,
        toolResult: W
      }
    };
    let X = A.mapToolResultToToolResultBlockParam(W.data, "1");
    if (!X.content || !Array.isArray(X.content) || !X.content[0] || X.content[0].type !== "text" || typeof X.content[0].text !== "string") throw Error('Permission prompt tool returned an invalid result. Expected a single text block param with type="text" and a string text value.');
    return nSA(ZW1.parse(f7(X.content[0].text)), A, G, Z)
  };
  return Q
}
// @from(Start 14807646, End 14808227)
function Gu3(A, Q, B) {
  if (A === "stdio") return Q.createCanUseTool();
  else if (A) {
    let G = B.find((Z) => Z.name === A);
    if (!G) {
      let Z = `Error: MCP tool ${A} (passed via --permission-prompt-tool) not found. Available MCP tools: ${B.map((I)=>I.name).join(", ")||"none"}`;
      throw process.stderr.write(`${Z}
`), l5(1), Error(Z)
    }
    if (!G.inputJSONSchema) {
      let Z = `Error: tool ${A} (passed via --permission-prompt-tool) must be an MCP tool`;
      throw process.stderr.write(`${Z}
`), l5(1), Error(Z)
    }
    return Bu3(G)
  }
  return M$
}
// @from(Start 14808228, End 14810101)
async function Zu3(A, Q, B, G, Z, I, Y, J, W, X) {
  if (B) {
    G.enqueue({
      type: "control_response",
      response: {
        subtype: "error",
        error: "Already initialized",
        request_id: Q,
        pending_permission_requests: Y.getPendingPermissionRequests()
      }
    });
    return
  }
  if (A.systemPrompt !== void 0) W.systemPrompt = A.systemPrompt;
  if (A.appendSystemPrompt !== void 0) W.appendSystemPrompt = A.appendSystemPrompt;
  if (A.agents) {
    let H = A31(A.agents, "flagSettings");
    X.push(...H)
  }
  let F = l0()?.outputStyle || wK,
    K = await cQA(),
    D = RiA();
  if (A.hooks) {
    let H = {};
    for (let [C, E] of Object.entries(A.hooks)) H[C] = E.map((U) => {
      let q = U.hookCallbackIds.map((w) => {
        return Y.createHookCallback(w, U.timeout)
      });
      return {
        matcher: U.matcher,
        hooks: q
      }
    });
    LkA(H)
  }
  if (A.jsonSchema) Wz0(A.jsonSchema);
  if (G.enqueue({
      type: "control_response",
      response: {
        subtype: "success",
        request_id: Q,
        response: {
          commands: Z.map((H) => ({
            name: H.userFacingName(),
            description: H.description,
            argumentHint: H.argumentHint || ""
          })),
          output_style: F,
          available_output_styles: Object.keys(K),
          models: I,
          account: {
            email: D?.email,
            organization: D?.organization,
            subscriptionType: D?.subscription,
            tokenSource: D?.tokenSource,
            apiKeySource: D?.apiKeySource
          }
        }
      }
    }), J) {
    let C = vH.getInstance().getStatus();
    if (C) G.enqueue({
      type: "auth_status",
      isAuthenticating: C.isAuthenticating,
      output: C.output,
      error: C.error,
      uuid: IW1(),
      session_id: e1()
    })
  }
}