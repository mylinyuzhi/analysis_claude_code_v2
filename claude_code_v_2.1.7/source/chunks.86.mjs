
// @from(Ln 249999, Col 0)
function Z12() {
  let A = BY0(Q12),
    Q = BY0(G12),
    B = BY0(B12);
  return `${A}-${Q}-${B}`
}
// @from(Ln 250005, Col 4)
Q12
// @from(Ln 250005, Col 9)
B12
// @from(Ln 250005, Col 14)
G12
// @from(Ln 250005, Col 19)
zIZ
// @from(Ln 250006, Col 4)
Y12 = w(() => {
  Q12 = ["abundant", "ancient", "bright", "calm", "cheerful", "clever", "cozy", "curious", "dapper", "dazzling", "deep", "delightful", "eager", "elegant", "enchanted", "fancy", "fluffy", "gentle", "gleaming", "golden", "graceful", "happy", "hidden", "humble", "jolly", "joyful", "keen", "kind", "lively", "lovely", "lucky", "luminous", "magical", "majestic", "mellow", "merry", "mighty", "misty", "noble", "peaceful", "playful", "polished", "precious", "proud", "quiet", "quirky", "radiant", "rosy", "serene", "shiny", "silly", "sleepy", "smooth", "snazzy", "snug", "snuggly", "soft", "sparkling", "spicy", "splendid", "sprightly", "starry", "steady", "sunny", "swift", "tender", "tidy", "toasty", "tranquil", "twinkly", "valiant", "vast", "velvet", "vivid", "warm", "whimsical", "wild", "wise", "witty", "wondrous", "zany", "zesty", "zippy", "breezy", "bubbly", "buzzing", "cheeky", "cosmic", "cozy", "crispy", "crystalline", "cuddly", "drifting", "dreamy", "effervescent", "ethereal", "fizzy", "flickering", "floating", "floofy", "fluttering", "foamy", "frolicking", "fuzzy", "giggly", "glimmering", "glistening", "glittery", "glowing", "goofy", "groovy", "harmonic", "hazy", "humming", "iridescent", "jaunty", "jazzy", "jiggly", "melodic", "moonlit", "mossy", "nifty", "peppy", "prancy", "purrfect", "purring", "quizzical", "rippling", "rustling", "shimmering", "shimmying", "snappy", "snoopy", "squishy", "swirling", "ticklish", "tingly", "twinkling", "velvety", "wiggly", "wobbly", "woolly", "zazzy", "abstract", "adaptive", "agile", "async", "atomic", "binary", "cached", "compiled", "composed", "compressed", "concurrent", "cryptic", "curried", "declarative", "delegated", "distributed", "dynamic", "eager", "elegant", "encapsulated", "enumerated", "eventual", "expressive", "federated", "functional", "generic", "greedy", "hashed", "idempotent", "immutable", "imperative", "indexed", "inherited", "iterative", "lazy", "lexical", "linear", "linked", "logical", "memoized", "modular", "mutable", "nested", "optimized", "parallel", "parsed", "partitioned", "piped", "polymorphic", "pure", "reactive", "recursive", "refactored", "reflective", "replicated", "resilient", "robust", "scalable", "sequential", "serialized", "sharded", "sorted", "staged", "stateful", "stateless", "streamed", "structured", "synchronous", "synthetic", "temporal", "transient", "typed", "unified", "validated", "vectorized", "virtual"], B12 = ["aurora", "avalanche", "blossom", "breeze", "brook", "bubble", "canyon", "cascade", "cloud", "clover", "comet", "coral", "cosmos", "creek", "crescent", "crystal", "dawn", "dewdrop", "dusk", "eclipse", "ember", "feather", "fern", "firefly", "flame", "flurry", "fog", "forest", "frost", "galaxy", "garden", "glacier", "glade", "grove", "harbor", "horizon", "island", "lagoon", "lake", "leaf", "lightning", "meadow", "meteor", "mist", "moon", "moonbeam", "mountain", "nebula", "nova", "ocean", "orbit", "pebble", "petal", "pine", "planet", "pond", "puddle", "quasar", "rain", "rainbow", "reef", "ripple", "river", "shore", "sky", "snowflake", "spark", "spring", "star", "stardust", "starlight", "storm", "stream", "summit", "sun", "sunbeam", "sunrise", "sunset", "thunder", "tide", "twilight", "valley", "volcano", "waterfall", "wave", "willow", "wind", "alpaca", "axolotl", "badger", "bear", "beaver", "bee", "bird", "bumblebee", "bunny", "cat", "chipmunk", "crab", "crane", "deer", "dolphin", "dove", "dragon", "dragonfly", "duckling", "eagle", "elephant", "falcon", "finch", "flamingo", "fox", "frog", "giraffe", "goose", "hamster", "hare", "hedgehog", "hippo", "hummingbird", "jellyfish", "kitten", "koala", "ladybug", "lark", "lemur", "llama", "lobster", "lynx", "manatee", "meerkat", "moth", "narwhal", "newt", "octopus", "otter", "owl", "panda", "parrot", "peacock", "pelican", "penguin", "phoenix", "piglet", "platypus", "pony", "porcupine", "puffin", "puppy", "quail", "quokka", "rabbit", "raccoon", "raven", "robin", "salamander", "seahorse", "seal", "sloth", "snail", "sparrow", "sphinx", "squid", "squirrel", "starfish", "swan", "tiger", "toucan", "turtle", "unicorn", "walrus", "whale", "wolf", "wombat", "wren", "yeti", "zebra", "acorn", "anchor", "balloon", "beacon", "biscuit", "blanket", "bonbon", "book", "boot", "cake", "candle", "candy", "castle", "charm", "clock", "cocoa", "cookie", "crayon", "crown", "cupcake", "donut", "dream", "fairy", "fiddle", "flask", "flute", "fountain", "gadget", "gem", "gizmo", "globe", "goblet", "hammock", "harp", "haven", "hearth", "honey", "journal", "kazoo", "kettle", "key", "kite", "lantern", "lemon", "lighthouse", "locket", "lollipop", "mango", "map", "marble", "marshmallow", "melody", "mitten", "mochi", "muffin", "music", "nest", "noodle", "oasis", "origami", "pancake", "parasol", "peach", "pearl", "pebble", "pie", "pillow", "pinwheel", "pixel", "pizza", "plum", "popcorn", "pretzel", "prism", "pudding", "pumpkin", "puzzle", "quiche", "quill", "quilt", "riddle", "rocket", "rose", "scone", "scroll", "shell", "sketch", "snowglobe", "sonnet", "sparkle", "spindle", "sprout", "sundae", "swing", "taco", "teacup", "teapot", "thimble", "toast", "token", "tome", "tower", "treasure", "treehouse", "trinket", "truffle", "tulip", "umbrella", "waffle", "wand", "whisper", "whistle", "widget", "wreath", "zephyr", "abelson", "adleman", "aho", "allen", "babbage", "bachman", "backus", "barto", "bengio", "bentley", "blum", "boole", "brooks", "catmull", "cerf", "cherny", "church", "clarke", "cocke", "codd", "conway", "cook", "corbato", "cray", "curry", "dahl", "diffie", "dijkstra", "dongarra", "eich", "emerson", "engelbart", "feigenbaum", "floyd", "gosling", "graham", "gray", "hamming", "hanrahan", "hartmanis", "hejlsberg", "hellman", "hennessy", "hickey", "hinton", "hoare", "hollerith", "hopcroft", "hopper", "iverson", "kahan", "kahn", "karp", "kay", "kernighan", "knuth", "kurzweil", "lamport", "lampson", "lecun", "lerdorf", "liskov", "lovelace", "matsumoto", "mccarthy", "metcalfe", "micali", "milner", "minsky", "moler", "moore", "naur", "neumann", "newell", "nygaard", "papert", "parnas", "pascal", "patterson", "pearl", "perlis", "pike", "pnueli", "rabin", "reddy", "ritchie", "rivest", "rossum", "russell", "scott", "sedgewick", "shamir", "shannon", "sifakis", "simon", "stallman", "stearns", "steele", "stonebraker", "stroustrup", "sutherland", "sutton", "tarjan", "thacker", "thompson", "torvalds", "turing", "ullman", "valiant", "wadler", "wall", "wigderson", "wilkes", "wilkinson", "wirth", "wozniak", "yao"], G12 = ["baking", "beaming", "booping", "bouncing", "brewing", "bubbling", "chasing", "churning", "coalescing", "conjuring", "cooking", "crafting", "crunching", "cuddling", "dancing", "dazzling", "discovering", "doodling", "dreaming", "drifting", "enchanting", "exploring", "finding", "floating", "fluttering", "foraging", "forging", "frolicking", "gathering", "giggling", "gliding", "greeting", "growing", "hatching", "herding", "honking", "hopping", "hugging", "humming", "imagining", "inventing", "jingling", "juggling", "jumping", "kindling", "knitting", "launching", "leaping", "mapping", "marinating", "meandering", "mixing", "moseying", "munching", "napping", "nibbling", "noodling", "orbiting", "painting", "percolating", "petting", "plotting", "pondering", "popping", "prancing", "purring", "puzzling", "questing", "riding", "roaming", "rolling", "sauteeing", "scribbling", "seeking", "shimmying", "singing", "skipping", "sleeping", "snacking", "sniffing", "snuggling", "soaring", "sparking", "spinning", "splashing", "sprouting", "squishing", "stargazing", "stirring", "strolling", "swimming", "swinging", "tickling", "tinkering", "toasting", "tumbling", "twirling", "waddling", "wandering", "watching", "weaving", "whistling", "wibbling", "wiggling", "wishing", "wobbling", "wondering", "yawning", "zooming"];
  zIZ = Q12.length * G12.length * B12.length
})
// @from(Ln 250014, Col 0)
function GY0(A) {
  let Q = A ?? q0(),
    B = Z7A(),
    G = B.get(Q);
  if (!G) {
    let Z = NN();
    for (let Y = 0; Y < Fe8; Y++) {
      G = Z12();
      let J = tSA(Z, `${G}.md`);
      if (!vA().existsSync(J)) break
    }
    B.set(Q, G)
  }
  return G
}
// @from(Ln 250030, Col 0)
function ZY0(A, Q) {
  Z7A().set(A, Q)
}
// @from(Ln 250034, Col 0)
function J12(A) {
  let Q = A ?? q0();
  Z7A().delete(Q)
}
// @from(Ln 250039, Col 0)
function NN() {
  let A = tSA(zQ(), "plans");
  if (!vA().existsSync(A)) try {
    vA().mkdirSync(A)
  } catch (Q) {
    e(Q instanceof Error ? Q : Error(String(Q)))
  }
  return A
}
// @from(Ln 250049, Col 0)
function dC(A) {
  let Q = GY0(q0());
  if (!A) return tSA(NN(), `${Q}.md`);
  return tSA(NN(), `${Q}-agent-${A}.md`)
}
// @from(Ln 250055, Col 0)
function AK(A) {
  let Q = dC(A);
  if (!vA().existsSync(Q)) return null;
  try {
    return vA().readFileSync(Q, {
      encoding: "utf-8"
    })
  } catch (B) {
    return e(B instanceof Error ? B : Error(String(B))), null
  }
}
// @from(Ln 250067, Col 0)
function W71(A, Q) {
  let B = A.messages.find((Y) => Y.slug)?.slug;
  if (!B) return !1;
  let G = Q ?? q0();
  ZY0(G, B);
  let Z = tSA(NN(), `${B}.md`);
  return vA().existsSync(Z)
}
// @from(Ln 250075, Col 4)
Fe8 = 10
// @from(Ln 250076, Col 4)
UF = w(() => {
  C0();
  DQ();
  fQ();
  v1();
  Y12()
})
// @from(Ln 250100, Col 0)
function eSA() {
  return YY0(V71(), "tasks")
}
// @from(Ln 250104, Col 0)
function JY0() {
  let A = eSA();
  if (!h9A(A)) W12(A, {
    recursive: !0
  })
}
// @from(Ln 250111, Col 0)
function aY(A) {
  return YY0(eSA(), `${A}.output`)
}
// @from(Ln 250115, Col 0)
function g9A(A, Q) {
  try {
    JY0();
    let Y = aY(A),
      J = Ce8(Y);
    if (!h9A(J)) W12(J, {
      recursive: !0
    })
  } catch (Y) {
    e(Y instanceof Error ? Y : Error(String(Y)));
    return
  }
  let B = aY(A),
    Z = (X12.get(A) ?? Promise.resolve()).then(async () => {
      try {
        await $e8(B, Q, "utf8")
      } catch (Y) {
        e(Y instanceof Error ? Y : Error(String(Y)))
      }
    });
  X12.set(A, Z)
}
// @from(Ln 250138, Col 0)
function XY0(A, Q) {
  try {
    let B = aY(A);
    if (!h9A(B)) return {
      content: "",
      newOffset: Q
    };
    let Z = He8(B).size;
    if (Z <= Q) return {
      content: "",
      newOffset: Q
    };
    return {
      content: I12(B, "utf8").slice(Q),
      newOffset: Z
    }
  } catch (B) {
    return e(B instanceof Error ? B : Error(String(B))), {
      content: "",
      newOffset: Q
    }
  }
}
// @from(Ln 250162, Col 0)
function K71(A) {
  try {
    let Q = aY(A);
    if (!h9A(Q)) return "";
    return I12(Q, "utf8")
  } catch (Q) {
    return e(Q instanceof Error ? Q : Error(String(Q))), ""
  }
}
// @from(Ln 250172, Col 0)
function Zr(A) {
  JY0();
  let Q = aY(A);
  if (!h9A(Q)) bB(Q, "", "utf8");
  return Q
}
// @from(Ln 250179, Col 0)
function OKA(A, Q) {
  try {
    JY0();
    let B = aY(A);
    if (h9A(B)) D12(B);
    return ze8(Q, B), B
  } catch (B) {
    return e(B instanceof Error ? B : Error(String(B))), Zr(A)
  }
}
// @from(Ln 250190, Col 0)
function K12() {
  try {
    let A = eSA();
    if (!h9A(A)) return;
    let Q = Ee8(A);
    for (let B of Q)
      if (B.endsWith(".output")) try {
        D12(YY0(A, B))
      } catch {}
  } catch {}
}
// @from(Ln 250201, Col 4)
X12
// @from(Ln 250202, Col 4)
cC = w(() => {
  A0();
  v1();
  AY();
  X12 = new Map
})
// @from(Ln 250209, Col 0)
function F71(A) {
  let Q = `${eSA()}/`,
    B = ".output";
  if (A.startsWith(Q) && A.endsWith(".output")) {
    let G = A.slice(Q.length, -7);
    if (G.length > 0 && G.length <= 20 && /^[a-zA-Z0-9_-]+$/.test(G)) return G
  }
  return null
}
// @from(Ln 250219, Col 0)
function V12({
  file_path: A,
  offset: Q,
  limit: B
}, {
  verbose: G
}) {
  if (!A) return null;
  if (F71(A)) return "";
  let Z = G ? A : k6(A);
  if (G && (Q || B)) {
    let Y = Q ?? 1,
      J = B ? `lines ${Y}-${Y+B-1}` : `from line ${Y}`;
    return X3.createElement(X3.Fragment, null, X3.createElement(zb, {
      filePath: A
    }, Z), ` Â· ${J}`)
  }
  return X3.createElement(zb, {
    filePath: A
  }, Z)
}
// @from(Ln 250241, Col 0)
function F12({
  file_path: A
}) {
  let Q = A ? F71(A) : null;
  if (!Q) return null;
  return X3.createElement(T, {
    flexWrap: "nowrap",
    marginLeft: 1
  }, X3.createElement(C, {
    dimColor: !0
  }, Q))
}
// @from(Ln 250254, Col 0)
function H12() {
  return null
}
// @from(Ln 250258, Col 0)
function E12(A) {
  switch (A.type) {
    case "image": {
      let {
        originalSize: Q
      } = A.file, B = xD(Q);
      return X3.createElement(x0, {
        height: 1
      }, X3.createElement(C, null, "Read image (", B, ")"))
    }
    case "notebook": {
      let {
        cells: Q
      } = A.file;
      if (!Q || Q.length < 1) return X3.createElement(C, {
        color: "error"
      }, "No cells found in notebook");
      return X3.createElement(x0, {
        height: 1
      }, X3.createElement(C, null, "Read ", X3.createElement(C, {
        bold: !0
      }, Q.length), " cells"))
    }
    case "pdf": {
      let {
        originalSize: Q
      } = A.file, B = xD(Q);
      return X3.createElement(x0, {
        height: 1
      }, X3.createElement(C, null, "Read PDF (", B, ")"))
    }
    case "text": {
      let {
        numLines: Q
      } = A.file;
      return X3.createElement(x0, {
        height: 1
      }, X3.createElement(C, null, "Read ", X3.createElement(C, {
        bold: !0
      }, Q), " ", Q === 1 ? "line" : "lines"))
    }
  }
}
// @from(Ln 250302, Col 0)
function z12() {
  return X3.createElement(w7, null)
}
// @from(Ln 250306, Col 0)
function $12(A, {
  verbose: Q
}) {
  if (!Q && typeof A === "string" && Q9(A, "tool_use_error")) return X3.createElement(x0, null, X3.createElement(C, {
    color: "error"
  }, "Error reading file"));
  return X3.createElement(X5, {
    result: A,
    verbose: Q
  })
}
// @from(Ln 250318, Col 0)
function C12(A) {
  if (A?.file_path?.startsWith(NN())) return "Reading Plan";
  if (A?.file_path && F71(A.file_path)) return "Read agent output";
  return "Read"
}
// @from(Ln 250324, Col 0)
function U12(A) {
  if (!A?.file_path) return null;
  let Q = F71(A.file_path);
  if (Q) return Q;
  return k6(A.file_path)
}
// @from(Ln 250330, Col 4)
X3
// @from(Ln 250331, Col 4)
q12 = w(() => {
  fA();
  tH();
  eW();
  sSA();
  c4();
  y9();
  tQ();
  UF();
  cC();
  X3 = c(QA(), 1)
})
// @from(Ln 250347, Col 0)
function Ue8(A) {
  return N12("sha256").update(A).digest("hex").slice(0, 16)
}
// @from(Ln 250351, Col 0)
function qe8(A) {
  return N12("sha256").update(A).digest("hex")
}
// @from(Ln 250355, Col 0)
function $b(A) {
  let Q = {
    operation: A.operation,
    tool: A.tool,
    filePathHash: Ue8(A.filePath)
  };
  if (A.content !== void 0 && A.content.length <= Ne8) Q.contentHash = qe8(A.content);
  if (A.type !== void 0) Q.type = A.type;
  l("tengu_file_operation", Q)
}
// @from(Ln 250365, Col 4)
Ne8 = 102400
// @from(Ln 250366, Col 4)
H71 = w(() => {
  Z0()
})
// @from(Ln 250375, Col 0)
function WY0() {
  let A = process.env.CLAUDE_CODE_FILE_READ_MAX_OUTPUT_TOKENS;
  if (A) {
    let Q = parseInt(A, 10);
    if (!isNaN(Q) && Q > 0) return Q
  }
  return Me8
}
// @from(Ln 250384, Col 0)
function _e8(A) {
  let Q = zQ();
  if (!A.startsWith(Q)) return null;
  let B = A.split(Le8.sep).join(we8.sep);
  if (B.includes("/session-memory/") && B.endsWith(".md")) return "session_memory";
  if (B.includes("/projects/") && B.endsWith(".jsonl")) return "session_transcript";
  return null
}
// @from(Ln 250392, Col 0)
async function w12(A, Q, {
  maxSizeBytes: B = AxA,
  maxTokens: G
}) {
  let Z = G ?? WY0();
  if (!E71.has(Q) && A.length > B) throw Error(DY0(A.length, B));
  let Y = l7(A);
  if (!Y || Y <= Z / 4) return;
  let X = await ieB(A) ?? Y;
  if (X > Z) throw new $71(X, Z)
}
// @from(Ln 250404, Col 0)
function z71(A, Q, B, G) {
  return {
    type: "image",
    file: {
      base64: A.toString("base64"),
      type: `image/${Q}`,
      originalSize: B,
      dimensions: G
    }
  }
}
// @from(Ln 250415, Col 0)
async function xe8(A, Q) {
  let G = vA().statSync(A).size,
    Z = vA().readFileBytesSync(A),
    Y = c51(Z);
  try {
    let J = await LeB(Z, Q, Y);
    return {
      type: "image",
      file: {
        base64: J.base64,
        type: J.mediaType,
        originalSize: G
      }
    }
  } catch (J) {
    e(J);
    try {
      let X = await Promise.resolve().then(() => c(EZ0(), 1)),
        D = await (X.default || X)(Z).resize(400, 400, {
          fit: "inside",
          withoutEnlargement: !0
        }).jpeg({
          quality: 20
        }).toBuffer();
      return z71(D, "jpeg", G)
    } catch (X) {
      e(X);
      let I = Y.split("/")[1] || "png";
      return z71(Z, I, G)
    }
  }
}
// @from(Ln 250447, Col 0)
async function ye8(A, Q) {
  let G = vA().statSync(A).size;
  if (G === 0) throw Error(`Image file is empty: ${A}`);
  let Z = vA().readFileBytesSync(A),
    J = c51(Z).split("/")[1] || "png";
  try {
    let X = await KKA(Z, G, J);
    return z71(X.buffer, X.mediaType, G, X.dimensions)
  } catch (X) {
    return e(X), z71(Z, J, G)
  }
}
// @from(Ln 250459, Col 0)
async function KY0(A, Q = WY0(), B = A.split(".").pop()?.toLowerCase() || "png") {
  let G = await ye8(A, B);
  if (Math.ceil(G.file.base64.length * 0.125) > Q) return await xe8(A, Q);
  return G
}
// @from(Ln 250464, Col 4)
Oe8
// @from(Ln 250464, Col 9)
Me8 = 25000
// @from(Ln 250465, Col 2)
$71
// @from(Ln 250465, Col 7)
E71
// @from(Ln 250465, Col 12)
Re8
// @from(Ln 250465, Col 17)
je8
// @from(Ln 250465, Col 22)
Te8
// @from(Ln 250465, Col 27)
Pe8
// @from(Ln 250465, Col 32)
v5
// @from(Ln 250465, Col 36)
Se8 = `

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
`
// @from(Ln 250471, Col 2)
DY0 = (A, Q = AxA) => `File content (${xD(A)}) exceeds maximum allowed size (${xD(Q)}). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.`
// @from(Ln 250472, Col 4)
T_ = w(() => {
  j9();
  V2();
  C0();
  fQ();
  Ib();
  mSA();
  y9();
  G71();
  v1();
  cW();
  AY();
  dr1();
  tQ();
  qN();
  DQ();
  q12();
  H71();
  Z0();
  y9();
  A0();
  Oe8 = [];
  $71 = class $71 extends Error {
    tokenCount;
    maxTokens;
    constructor(A, Q) {
      super(`File content (${A} tokens) exceeds maximum allowed tokens (${Q}). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.`);
      this.tokenCount = A;
      this.maxTokens = Q;
      this.name = "MaxFileReadTokenExceededError"
    }
  };
  E71 = new Set(["png", "jpg", "jpeg", "gif", "webp"]), Re8 = new Set(["mp3", "wav", "flac", "ogg", "aac", "m4a", "wma", "aiff", "opus", "mp4", "avi", "mov", "wmv", "flv", "mkv", "webm", "m4v", "mpeg", "mpg", "zip", "rar", "tar", "gz", "bz2", "7z", "xz", "z", "tgz", "iso", "exe", "dll", "so", "dylib", "app", "msi", "deb", "rpm", "bin", "dat", "db", "sqlite", "sqlite3", "mdb", "idx", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "odt", "ods", "odp", "ttf", "otf", "woff", "woff2", "eot", "psd", "ai", "eps", "sketch", "fig", "xd", "blend", "obj", "3ds", "max", "class", "jar", "war", "pyc", "pyo", "rlib", "swf", "fla"]);
  je8 = m.strictObject({
    file_path: m.string().describe("The absolute path to the file to read"),
    offset: m.number().optional().describe("The line number to start reading from. Only provide if the file is too large to read at once"),
    limit: m.number().optional().describe("The number of lines to read. Only provide if the file is too large to read at once.")
  }), Te8 = m.enum(["image/jpeg", "image/png", "image/gif", "image/webp"]), Pe8 = m.discriminatedUnion("type", [m.object({
    type: m.literal("text"),
    file: m.object({
      filePath: m.string().describe("The path to the file that was read"),
      content: m.string().describe("The content of the file"),
      numLines: m.number().describe("Number of lines in the returned content"),
      startLine: m.number().describe("The starting line number"),
      totalLines: m.number().describe("Total number of lines in the file")
    })
  }), m.object({
    type: m.literal("image"),
    file: m.object({
      base64: m.string().describe("Base64-encoded image data"),
      type: Te8.describe("The MIME type of the image"),
      originalSize: m.number().describe("Original file size in bytes"),
      dimensions: m.object({
        originalWidth: m.number().optional().describe("Original image width in pixels"),
        originalHeight: m.number().optional().describe("Original image height in pixels"),
        displayWidth: m.number().optional().describe("Displayed image width in pixels (after resizing)"),
        displayHeight: m.number().optional().describe("Displayed image height in pixels (after resizing)")
      }).optional().describe("Image dimension info for coordinate mapping")
    })
  }), m.object({
    type: m.literal("notebook"),
    file: m.object({
      filePath: m.string().describe("The path to the notebook file"),
      cells: m.array(m.any()).describe("Array of notebook cells")
    })
  }), m.object({
    type: m.literal("pdf"),
    file: m.object({
      filePath: m.string().describe("The path to the PDF file"),
      base64: m.string().describe("Base64-encoded PDF data"),
      originalSize: m.number().describe("Original file size in bytes")
    })
  })]), v5 = {
    name: z3,
    maxResultSizeChars: 1e5,
    strict: !0,
    input_examples: [{
      file_path: "/Users/username/project/src/index.ts"
    }, {
      file_path: "/Users/username/project/README.md",
      limit: 100,
      offset: 50
    }],
    async description() {
      return PEB
    },
    async prompt() {
      return SEB
    },
    inputSchema: je8,
    outputSchema: Pe8,
    userFacingName: C12,
    getToolUseSummary: U12,
    isEnabled() {
      return !0
    },
    isConcurrencySafe() {
      return !0
    },
    isReadOnly() {
      return !0
    },
    isSearchOrReadCommand() {
      return {
        isSearch: !1,
        isRead: !0
      }
    },
    getPath({
      file_path: A
    }) {
      return A || o1()
    },
    async checkPermissions(A, Q) {
      let B = await Q.getAppState();
      return Jr(v5, A, B.toolPermissionContext)
    },
    renderToolUseMessage: V12,
    renderToolUseTag: F12,
    renderToolUseProgressMessage: H12,
    renderToolResultMessage: E12,
    renderToolUseRejectedMessage: z12,
    renderToolUseErrorMessage: $12,
    async validateInput({
      file_path: A,
      offset: Q,
      limit: B
    }, G) {
      let Z = vA(),
        Y = Yr(A),
        J = await G.getAppState();
      if (AE(Y, J.toolPermissionContext, "read", "deny") !== null) return {
        result: !1,
        message: "File is in a directory that is denied by your permission settings.",
        errorCode: 1
      };
      if (Y.startsWith("\\\\") || Y.startsWith("//")) return {
        result: !0
      };
      if (!Z.existsSync(Y)) {
        let H = C71(Y),
          E = "File does not exist.",
          z = o1(),
          $ = EQ();
        if (z !== $) E += ` Current working directory: ${z}`;
        if (H) E += ` Did you mean ${H}?`;
        return {
          result: !1,
          message: E,
          errorCode: 2
        }
      }
      let D = IY0.extname(Y).toLowerCase();
      if (Re8.has(D.slice(1)) && !(IIA() && a01(D))) return {
        result: !1,
        message: `This tool cannot read binary files. The file appears to be a binary ${D} file. Please use appropriate tools for binary file analysis.`,
        errorCode: 4
      };
      let K = Z.statSync(Y).size;
      if (K === 0) {
        if (E71.has(D.slice(1))) return {
          result: !1,
          message: "Empty image files cannot be processed.",
          errorCode: 5
        }
      }
      let V = D === ".ipynb",
        F = IIA() && a01(D);
      if (!E71.has(D.slice(1)) && !V && !F) {
        if (!U71(Y) && !Q && !B) return {
          result: !1,
          message: DY0(K),
          meta: {
            fileSize: K
          },
          errorCode: 6
        }
      }
      return {
        result: !0
      }
    },
    async call({
      file_path: A,
      offset: Q = 1,
      limit: B = void 0
    }, G) {
      let {
        readFileState: Z,
        fileReadingLimits: Y
      } = G, J = AxA, X = Y?.maxTokens ?? WY0(), I = IY0.extname(A).toLowerCase().slice(1), D = Yr(A);
      if (I === "ipynb") {
        let z = gA2(D),
          $ = eA(z);
        if ($.length > J) throw Error(`Notebook content (${xD($.length)}) exceeds maximum allowed size (${xD(J)}). Use ${X9} with jq to read specific portions:
  cat "${A}" | jq '.cells[:20]' # First 20 cells
  cat "${A}" | jq '.cells[100:120]' # Cells 100-120
  cat "${A}" | jq '.cells | length' # Count total cells
  cat "${A}" | jq '.cells[] | select(.cell_type=="code") | .source' # All code sources`);
        await w12($, I, {
          maxSizeBytes: J,
          maxTokens: X
        }), Z.set(D, {
          content: $,
          timestamp: mz(D),
          offset: Q,
          limit: B
        }), G.nestedMemoryAttachmentTriggers?.add(D);
        let O = {
          type: "notebook",
          file: {
            filePath: A,
            cells: z
          }
        };
        return $b({
          operation: "read",
          tool: "FileReadTool",
          filePath: D,
          content: $
        }), {
          data: O
        }
      }
      if (E71.has(I)) {
        let z = await KY0(D, X, I);
        G.nestedMemoryAttachmentTriggers?.add(D), $b({
          operation: "read",
          tool: "FileReadTool",
          filePath: D,
          content: z.file.base64
        });
        let $ = z.file.dimensions ? VKA(z.file.dimensions) : null;
        return {
          data: z,
          ...$ && {
            newMessages: [H0({
              content: $,
              isMeta: !0
            })]
          }
        }
      }
      if (IIA() && a01(I)) {
        let z = await TEB(D);
        return $b({
          operation: "read",
          tool: "FileReadTool",
          filePath: D,
          content: z.file.base64
        }), {
          data: z,
          newMessages: [H0({
            content: [{
              type: "document",
              source: {
                type: "base64",
                media_type: "application/pdf",
                data: z.file.base64
              }
            }],
            isMeta: !0
          })]
        }
      }
      let W = Q === 0 ? 0 : Q - 1,
        {
          content: K,
          lineCount: V,
          totalLines: F
        } = L12(D, W, B);
      if (K.length > J) throw Error(DY0(K.length, J));
      await w12(K, I, {
        maxSizeBytes: J,
        maxTokens: X
      }), Z.set(D, {
        content: K,
        timestamp: mz(D),
        offset: Q,
        limit: B
      }), G.nestedMemoryAttachmentTriggers?.add(D);
      for (let z of Oe8) z(D, K);
      let H = {
        type: "text",
        file: {
          filePath: A,
          content: K,
          numLines: V,
          startLine: Q,
          totalLines: F
        }
      };
      $b({
        operation: "read",
        tool: "FileReadTool",
        filePath: D,
        content: K
      });
      let E = _e8(D);
      if (E) l("tengu_session_file_read", {
        is_session_memory: E === "session_memory",
        is_session_transcript: E === "session_transcript"
      });
      return {
        data: H
      }
    },
    mapToolResultToToolResultBlockParam(A, Q) {
      switch (A.type) {
        case "image":
          return {
            tool_use_id: Q, type: "tool_result", content: [{
              type: "image",
              source: {
                type: "base64",
                data: A.file.base64,
                media_type: A.file.type
              }
            }]
          };
        case "notebook":
          return uA2(A.file.cells, Q);
        case "pdf":
          return {
            tool_use_id: Q, type: "tool_result", content: `PDF file read: ${A.file.filePath} (${xD(A.file.originalSize)})`
          };
        case "text": {
          let B;
          if (A.file.content) B = Xr(A.file) + Se8;
          else B = A.file.totalLines === 0 ? "<system-reminder>Warning: the file exists but the contents are empty.</system-reminder>" : `<system-reminder>Warning: the file exists but is shorter than the provided offset (${A.file.startLine}). The file has ${A.file.totalLines} lines.</system-reminder>`;
          return {
            tool_use_id: Q,
            type: "tool_result",
            content: B
          }
        }
      }
    }
  }
})
// @from(Ln 250813, Col 0)
function Id(A, Q = ve8) {
  return new jT({
    max: A,
    maxSize: Q,
    sizeCalculation: (B) => Math.max(1, Buffer.byteLength(B.content))
  })
}
// @from(Ln 250821, Col 0)
function O12(A) {
  return Object.fromEntries(A.entries())
}
// @from(Ln 250825, Col 0)
function FS(A) {
  return Array.from(A.keys())
}
// @from(Ln 250829, Col 0)
function m9A(A) {
  let Q = Id(A.max, A.maxSize);
  return Q.load(A.dump()), Q
}
// @from(Ln 250834, Col 0)
function MKA(A, Q) {
  let B = m9A(A);
  for (let [G, Z] of Q.entries()) {
    let Y = B.get(G);
    if (!Y || Z.timestamp > Y.timestamp) B.set(G, Z)
  }
  return B
}
// @from(Ln 250842, Col 4)
u9A = 100
// @from(Ln 250843, Col 2)
ve8 = 26214400
// @from(Ln 250844, Col 4)
pC = w(() => {
  eqA()
})
// @from(Ln 250848, Col 0)
function q71(A, Q) {
  return
}
// @from(Ln 250851, Col 4)
ke8
// @from(Ln 250851, Col 9)
be8
// @from(Ln 250852, Col 4)
VY0 = w(() => {
  DQ();
  Z0();
  Y9();
  A0();
  ke8 = W0(() => {
    return null
  }), be8 = W0(() => {
    return null
  })
})
// @from(Ln 250867, Col 0)
function FY0() {
  let A = N71(zQ(), "todos");
  if (!vA().existsSync(A)) vA().mkdirSync(A);
  return A
}
// @from(Ln 250873, Col 0)
function Ir(A) {
  let Q = `${q0()}-agent-${A}.json`;
  return N71(FY0(), Q)
}
// @from(Ln 250878, Col 0)
function Cb(A) {
  return M12(Ir(A))
}
// @from(Ln 250882, Col 0)
function d9A(A, Q) {
  R12(A, Ir(Q))
}
// @from(Ln 250886, Col 0)
function w71(A) {
  if (A.messages.length > 0) {
    let Q = A.messages[0];
    if (Q && "sessionId" in Q) fe8(Q.sessionId, q0())
  }
  HY0()
}
// @from(Ln 250894, Col 0)
function fe8(A, Q) {
  let B = N71(FY0(), `${A}-agent-${A}.json`),
    G = N71(FY0(), `${Q}-agent-${Q}.json`);
  try {
    let Z = M12(B);
    if (Z.length === 0) return !1;
    return R12(Z, G), !0
  } catch (Z) {
    return e(Z instanceof Error ? Z : Error(String(Z))), !1
  }
}
// @from(Ln 250906, Col 0)
function M12(A) {
  if (!vA().existsSync(A)) return [];
  try {
    let Q = AQ(vA().readFileSync(A, {
      encoding: "utf-8"
    }));
    return jIA.parse(Q)
  } catch (Q) {
    return e(Q instanceof Error ? Q : Error(String(Q))), []
  }
}
// @from(Ln 250918, Col 0)
function R12(A, Q) {
  try {
    yR(Q, eA(A, null, 2))
  } catch (B) {
    e(B instanceof Error ? B : Error(String(B)))
  }
}
// @from(Ln 250926, Col 0)
function HY0() {
  if (!Gm()) return;
  let A = q0(),
    Q = PIA(),
    B = RBA(Q);
  if (B.length > 0) {
    k(`[Todo Migration] Skipping migration - ${B.length} tasks already exist`);
    return
  }
  let G = Cb(A);
  if (G.length === 0) return;
  k(`[Todo Migration] Migrating ${G.length} todos to v2`);
  for (let Z of G) _CB(Q, {
    subject: Z.content,
    description: "",
    activeForm: Z.activeForm,
    status: Z.status,
    blocks: [],
    blockedBy: []
  });
  d9A([], A), k(`[Todo Migration] Successfully migrated ${G.length} todos to v2`)
}
// @from(Ln 250948, Col 4)
Dd = w(() => {
  y9();
  C0();
  DQ();
  fQ();
  v1();
  T1();
  a10();
  A0();
  Oa()
})
// @from(Ln 250959, Col 4)
_12 = w(() => {
  EC()
})
// @from(Ln 250962, Col 4)
j12 = () => {}
// @from(Ln 250963, Col 4)
T12 = () => {}
// @from(Ln 250964, Col 4)
P12 = () => {}
// @from(Ln 250965, Col 4)
S12 = () => {}
// @from(Ln 250966, Col 4)
x12 = w(() => {
  EC();
  FQ1();
  P12();
  S12();
  _12();
  j12();
  T12()
})
// @from(Ln 250975, Col 4)
y12 = w(() => {
  x12()
})
// @from(Ln 250978, Col 4)
v12 = w(() => {
  y12()
})
// @from(Ln 250982, Col 0)
function Dr(A) {
  return !!A._zod
}
// @from(Ln 250986, Col 0)
function lC(A, Q) {
  if (Dr(A)) return HIA(A, Q);
  return A.safeParse(Q)
}
// @from(Ln 250991, Col 0)
function RKA(A) {
  var Q, B;
  if (!A) return;
  let G;
  if (Dr(A)) G = (B = (Q = A._zod) === null || Q === void 0 ? void 0 : Q.def) === null || B === void 0 ? void 0 : B.shape;
  else G = A.shape;
  if (!G) return;
  if (typeof G === "function") try {
    return G()
  } catch (Z) {
    return
  }
  return G
}
// @from(Ln 251006, Col 0)
function k12(A) {
  var Q;
  if (Dr(A)) {
    let J = (Q = A._zod) === null || Q === void 0 ? void 0 : Q.def;
    if (J) {
      if (J.value !== void 0) return J.value;
      if (Array.isArray(J.values) && J.values.length > 0) return J.values[0]
    }
  }
  let G = A._def;
  if (G) {
    if (G.value !== void 0) return G.value;
    if (Array.isArray(G.values) && G.values.length > 0) return G.values[0]
  }
  let Z = A.value;
  if (Z !== void 0) return Z;
  return
}
// @from(Ln 251024, Col 4)
QxA = w(() => {
  v12()
})
// @from(Ln 251027, Col 4)
Wr = "2025-11-25"
// @from(Ln 251028, Col 2)
O71
// @from(Ln 251028, Col 7)
qb = "io.modelcontextprotocol/related-task"
// @from(Ln 251029, Col 2)
M71 = "2.0"
// @from(Ln 251030, Col 2)
Ub
// @from(Ln 251030, Col 6)
b12
// @from(Ln 251030, Col 11)
f12
// @from(Ln 251030, Col 16)
me8
// @from(Ln 251030, Col 21)
EY0
// @from(Ln 251030, Col 26)
de8
// @from(Ln 251030, Col 31)
wN
// @from(Ln 251030, Col 35)
QE
// @from(Ln 251030, Col 39)
c9A
// @from(Ln 251030, Col 44)
P_
// @from(Ln 251030, Col 48)
dz
// @from(Ln 251030, Col 52)
R71
// @from(Ln 251030, Col 57)
h12
// @from(Ln 251030, Col 62)
BxA = (A) => h12.safeParse(A).success
// @from(Ln 251031, Col 2)
g12
// @from(Ln 251031, Col 7)
u12 = (A) => g12.safeParse(A).success
// @from(Ln 251032, Col 2)
m12
// @from(Ln 251032, Col 7)
p9A = (A) => m12.safeParse(A).success
// @from(Ln 251033, Col 2)
q4
// @from(Ln 251033, Col 6)
d12
// @from(Ln 251033, Col 11)
c12 = (A) => d12.safeParse(A).success
// @from(Ln 251034, Col 2)
Nb
// @from(Ln 251034, Col 6)
Wd
// @from(Ln 251034, Col 10)
ce8
// @from(Ln 251034, Col 15)
_71
// @from(Ln 251034, Col 20)
pe8
// @from(Ln 251034, Col 25)
GxA
// @from(Ln 251034, Col 30)
_KA
// @from(Ln 251034, Col 35)
p12
// @from(Ln 251034, Col 40)
le8
// @from(Ln 251034, Col 45)
ie8
// @from(Ln 251034, Col 50)
ne8
// @from(Ln 251034, Col 55)
ae8
// @from(Ln 251034, Col 60)
oe8
// @from(Ln 251034, Col 65)
re8
// @from(Ln 251034, Col 70)
zY0
// @from(Ln 251034, Col 75)
se8
// @from(Ln 251034, Col 80)
$Y0
// @from(Ln 251034, Col 85)
j71
// @from(Ln 251034, Col 90)
l12 = (A) => j71.safeParse(A).success
// @from(Ln 251035, Col 2)
T71
// @from(Ln 251035, Col 7)
te8
// @from(Ln 251035, Col 12)
ee8
// @from(Ln 251035, Col 17)
P71
// @from(Ln 251035, Col 22)
AA5
// @from(Ln 251035, Col 27)
ZxA
// @from(Ln 251035, Col 32)
YxA
// @from(Ln 251035, Col 37)
JxA
// @from(Ln 251035, Col 42)
Kd
// @from(Ln 251035, Col 46)
QA5
// @from(Ln 251035, Col 51)
XxA
// @from(Ln 251035, Col 56)
S71
// @from(Ln 251035, Col 61)
x71
// @from(Ln 251035, Col 66)
y71
// @from(Ln 251035, Col 71)
v71
// @from(Ln 251035, Col 76)
k71
// @from(Ln 251035, Col 81)
i12
// @from(Ln 251035, Col 86)
n12
// @from(Ln 251035, Col 91)
a12
// @from(Ln 251035, Col 96)
o12
// @from(Ln 251035, Col 101)
CY0
// @from(Ln 251035, Col 106)
r12
// @from(Ln 251035, Col 111)
jKA
// @from(Ln 251035, Col 116)
s12
// @from(Ln 251035, Col 121)
BA5
// @from(Ln 251035, Col 126)
GA5
// @from(Ln 251035, Col 131)
l9A
// @from(Ln 251035, Col 136)
ZA5
// @from(Ln 251035, Col 141)
UY0
// @from(Ln 251035, Col 146)
qY0
// @from(Ln 251035, Col 151)
YA5
// @from(Ln 251035, Col 156)
JA5
// @from(Ln 251035, Col 161)
i9A
// @from(Ln 251035, Col 166)
NY0
// @from(Ln 251035, Col 171)
XA5
// @from(Ln 251035, Col 176)
IA5
// @from(Ln 251035, Col 181)
DA5
// @from(Ln 251035, Col 186)
WA5
// @from(Ln 251035, Col 191)
KA5
// @from(Ln 251035, Col 196)
VA5
// @from(Ln 251035, Col 201)
FA5
// @from(Ln 251035, Col 206)
HA5
// @from(Ln 251035, Col 211)
EA5
// @from(Ln 251035, Col 216)
IxA
// @from(Ln 251035, Col 221)
zA5
// @from(Ln 251035, Col 226)
$A5
// @from(Ln 251035, Col 231)
wY0
// @from(Ln 251035, Col 236)
LY0
// @from(Ln 251035, Col 241)
OY0
// @from(Ln 251035, Col 246)
CA5
// @from(Ln 251035, Col 251)
UA5
// @from(Ln 251035, Col 256)
qA5
// @from(Ln 251035, Col 261)
MY0
// @from(Ln 251035, Col 266)
NA5
// @from(Ln 251035, Col 271)
RY0
// @from(Ln 251035, Col 276)
_Y0
// @from(Ln 251035, Col 281)
wA5
// @from(Ln 251035, Col 286)
LA5
// @from(Ln 251035, Col 291)
t12
// @from(Ln 251035, Col 296)
DxA
// @from(Ln 251035, Col 301)
WxA
// @from(Ln 251035, Col 306)
iC
// @from(Ln 251035, Col 310)
lDZ
// @from(Ln 251035, Col 315)
OA5
// @from(Ln 251035, Col 320)
n9A
// @from(Ln 251035, Col 325)
jY0
// @from(Ln 251035, Col 330)
KxA
// @from(Ln 251035, Col 335)
MA5
// @from(Ln 251035, Col 340)
TY0
// @from(Ln 251035, Col 345)
RA5
// @from(Ln 251035, Col 350)
_A5
// @from(Ln 251035, Col 355)
jA5
// @from(Ln 251035, Col 360)
TA5
// @from(Ln 251035, Col 365)
PA5
// @from(Ln 251035, Col 370)
SA5
// @from(Ln 251035, Col 375)
xA5
// @from(Ln 251035, Col 380)
L71
// @from(Ln 251035, Col 385)
yA5
// @from(Ln 251035, Col 390)
vA5
// @from(Ln 251035, Col 395)
PY0
// @from(Ln 251035, Col 400)
VxA
// @from(Ln 251035, Col 405)
SY0
// @from(Ln 251035, Col 410)
kA5
// @from(Ln 251035, Col 415)
bA5
// @from(Ln 251035, Col 420)
fA5
// @from(Ln 251035, Col 425)
hA5
// @from(Ln 251035, Col 430)
gA5
// @from(Ln 251035, Col 435)
uA5
// @from(Ln 251035, Col 440)
mA5
// @from(Ln 251035, Col 445)
dA5
// @from(Ln 251035, Col 450)
cA5
// @from(Ln 251035, Col 455)
pA5
// @from(Ln 251035, Col 460)
lA5
// @from(Ln 251035, Col 465)
iA5
// @from(Ln 251035, Col 470)
nA5
// @from(Ln 251035, Col 475)
aA5
// @from(Ln 251035, Col 480)
oA5
// @from(Ln 251035, Col 485)
b71
// @from(Ln 251035, Col 490)
rA5
// @from(Ln 251035, Col 495)
sA5
// @from(Ln 251035, Col 500)
TKA
// @from(Ln 251035, Col 505)
tA5
// @from(Ln 251035, Col 510)
eA5
// @from(Ln 251035, Col 515)
A15
// @from(Ln 251035, Col 520)
Q15
// @from(Ln 251035, Col 525)
xY0
// @from(Ln 251035, Col 530)
B15
// @from(Ln 251035, Col 535)
yY0
// @from(Ln 251035, Col 540)
vY0
// @from(Ln 251035, Col 545)
G15
// @from(Ln 251035, Col 550)
iDZ
// @from(Ln 251035, Col 555)
nDZ
// @from(Ln 251035, Col 560)
aDZ
// @from(Ln 251035, Col 565)
oDZ
// @from(Ln 251035, Col 570)
rDZ
// @from(Ln 251035, Col 575)
sDZ
// @from(Ln 251035, Col 580)
P9
// @from(Ln 251035, Col 584)
e12
// @from(Ln 251036, Col 4)
eK = w(() => {
  j9();
  O71 = [Wr, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"], Ub = L10((A) => A !== null && (typeof A === "object" || typeof A === "function")), b12 = _Z([h1(), c7().int()]), f12 = h1(), me8 = hH({
    ttl: _Z([c7(), aRA()]).optional(),
    pollInterval: c7().optional()
  }), EY0 = hH({
    taskId: h1()
  }), de8 = hH({
    progressToken: b12.optional(),
    [qb]: EY0.optional()
  }), wN = hH({
    task: me8.optional(),
    _meta: de8.optional()
  }), QE = CB({
    method: h1(),
    params: wN.optional()
  }), c9A = hH({
    _meta: CB({
      [qb]: w9(EY0)
    }).passthrough().optional()
  }), P_ = CB({
    method: h1(),
    params: c9A.optional()
  }), dz = hH({
    _meta: hH({
      [qb]: EY0.optional()
    }).optional()
  }), R71 = _Z([h1(), c7().int()]), h12 = CB({
    jsonrpc: I9(M71),
    id: R71,
    ...QE.shape
  }).strict(), g12 = CB({
    jsonrpc: I9(M71),
    ...P_.shape
  }).strict(), m12 = CB({
    jsonrpc: I9(M71),
    id: R71,
    result: dz
  }).strict();
  (function (A) {
    A[A.ConnectionClosed = -32000] = "ConnectionClosed", A[A.RequestTimeout = -32001] = "RequestTimeout", A[A.ParseError = -32700] = "ParseError", A[A.InvalidRequest = -32600] = "InvalidRequest", A[A.MethodNotFound = -32601] = "MethodNotFound", A[A.InvalidParams = -32602] = "InvalidParams", A[A.InternalError = -32603] = "InternalError", A[A.UrlElicitationRequired = -32042] = "UrlElicitationRequired"
  })(q4 || (q4 = {}));
  d12 = CB({
    jsonrpc: I9(M71),
    id: R71,
    error: CB({
      code: c7().int(),
      message: h1(),
      data: w9(yD())
    })
  }).strict(), Nb = _Z([h12, g12, m12, d12]), Wd = dz.strict(), ce8 = c9A.extend({
    requestId: R71,
    reason: h1().optional()
  }), _71 = P_.extend({
    method: I9("notifications/cancelled"),
    params: ce8
  }), pe8 = CB({
    src: h1(),
    mimeType: h1().optional(),
    sizes: iB(h1()).optional()
  }), GxA = CB({
    icons: iB(pe8).optional()
  }), _KA = CB({
    name: h1(),
    title: h1().optional()
  }), p12 = _KA.extend({
    ..._KA.shape,
    ...GxA.shape,
    version: h1(),
    websiteUrl: h1().optional()
  }), le8 = oRA(CB({
    applyDefaults: RZ().optional()
  }), pI(h1(), yD())), ie8 = sQ1((A) => {
    if (A && typeof A === "object" && !Array.isArray(A)) {
      if (Object.keys(A).length === 0) return {
        form: {}
      }
    }
    return A
  }, oRA(CB({
    form: le8.optional(),
    url: Ub.optional()
  }), pI(h1(), yD()).optional())), ne8 = CB({
    list: w9(CB({}).passthrough()),
    cancel: w9(CB({}).passthrough()),
    requests: w9(CB({
      sampling: w9(CB({
        createMessage: w9(CB({}).passthrough())
      }).passthrough()),
      elicitation: w9(CB({
        create: w9(CB({}).passthrough())
      }).passthrough())
    }).passthrough())
  }).passthrough(), ae8 = CB({
    list: w9(CB({}).passthrough()),
    cancel: w9(CB({}).passthrough()),
    requests: w9(CB({
      tools: w9(CB({
        call: w9(CB({}).passthrough())
      }).passthrough())
    }).passthrough())
  }).passthrough(), oe8 = CB({
    experimental: pI(h1(), Ub).optional(),
    sampling: CB({
      context: Ub.optional(),
      tools: Ub.optional()
    }).optional(),
    elicitation: ie8.optional(),
    roots: CB({
      listChanged: RZ().optional()
    }).optional(),
    tasks: w9(ne8)
  }), re8 = wN.extend({
    protocolVersion: h1(),
    capabilities: oe8,
    clientInfo: p12
  }), zY0 = QE.extend({
    method: I9("initialize"),
    params: re8
  }), se8 = CB({
    experimental: pI(h1(), Ub).optional(),
    logging: Ub.optional(),
    completions: Ub.optional(),
    prompts: w9(CB({
      listChanged: w9(RZ())
    })),
    resources: CB({
      subscribe: RZ().optional(),
      listChanged: RZ().optional()
    }).optional(),
    tools: CB({
      listChanged: RZ().optional()
    }).optional(),
    tasks: w9(ae8)
  }).passthrough(), $Y0 = dz.extend({
    protocolVersion: h1(),
    capabilities: se8,
    serverInfo: p12,
    instructions: h1().optional()
  }), j71 = P_.extend({
    method: I9("notifications/initialized")
  }), T71 = QE.extend({
    method: I9("ping")
  }), te8 = CB({
    progress: c7(),
    total: w9(c7()),
    message: w9(h1())
  }), ee8 = CB({
    ...c9A.shape,
    ...te8.shape,
    progressToken: b12
  }), P71 = P_.extend({
    method: I9("notifications/progress"),
    params: ee8
  }), AA5 = wN.extend({
    cursor: f12.optional()
  }), ZxA = QE.extend({
    params: AA5.optional()
  }), YxA = dz.extend({
    nextCursor: w9(f12)
  }), JxA = CB({
    taskId: h1(),
    status: YF(["working", "input_required", "completed", "failed", "cancelled"]),
    ttl: _Z([c7(), aRA()]),
    createdAt: h1(),
    lastUpdatedAt: h1(),
    pollInterval: w9(c7()),
    statusMessage: w9(h1())
  }), Kd = dz.extend({
    task: JxA
  }), QA5 = c9A.merge(JxA), XxA = P_.extend({
    method: I9("notifications/tasks/status"),
    params: QA5
  }), S71 = QE.extend({
    method: I9("tasks/get"),
    params: wN.extend({
      taskId: h1()
    })
  }), x71 = dz.merge(JxA), y71 = QE.extend({
    method: I9("tasks/result"),
    params: wN.extend({
      taskId: h1()
    })
  }), v71 = ZxA.extend({
    method: I9("tasks/list")
  }), k71 = YxA.extend({
    tasks: iB(JxA)
  }), i12 = QE.extend({
    method: I9("tasks/cancel"),
    params: wN.extend({
      taskId: h1()
    })
  }), n12 = dz.merge(JxA), a12 = CB({
    uri: h1(),
    mimeType: w9(h1()),
    _meta: pI(h1(), yD()).optional()
  }), o12 = a12.extend({
    text: h1()
  }), CY0 = h1().refine((A) => {
    try {
      return atob(A), !0
    } catch (Q) {
      return !1
    }
  }, {
    message: "Invalid Base64 string"
  }), r12 = a12.extend({
    blob: CY0
  }), jKA = CB({
    audience: iB(YF(["user", "assistant"])).optional(),
    priority: c7().min(0).max(1).optional(),
    lastModified: wIA.datetime({
      offset: !0
    }).optional()
  }), s12 = CB({
    ..._KA.shape,
    ...GxA.shape,
    uri: h1(),
    description: w9(h1()),
    mimeType: w9(h1()),
    annotations: jKA.optional(),
    _meta: w9(hH({}))
  }), BA5 = CB({
    ..._KA.shape,
    ...GxA.shape,
    uriTemplate: h1(),
    description: w9(h1()),
    mimeType: w9(h1()),
    annotations: jKA.optional(),
    _meta: w9(hH({}))
  }), GA5 = ZxA.extend({
    method: I9("resources/list")
  }), l9A = YxA.extend({
    resources: iB(s12)
  }), ZA5 = ZxA.extend({
    method: I9("resources/templates/list")
  }), UY0 = YxA.extend({
    resourceTemplates: iB(BA5)
  }), qY0 = wN.extend({
    uri: h1()
  }), YA5 = qY0, JA5 = QE.extend({
    method: I9("resources/read"),
    params: YA5
  }), i9A = dz.extend({
    contents: iB(_Z([o12, r12]))
  }), NY0 = P_.extend({
    method: I9("notifications/resources/list_changed")
  }), XA5 = qY0, IA5 = QE.extend({
    method: I9("resources/subscribe"),
    params: XA5
  }), DA5 = qY0, WA5 = QE.extend({
    method: I9("resources/unsubscribe"),
    params: DA5
  }), KA5 = c9A.extend({
    uri: h1()
  }), VA5 = P_.extend({
    method: I9("notifications/resources/updated"),
    params: KA5
  }), FA5 = CB({
    name: h1(),
    description: w9(h1()),
    required: w9(RZ())
  }), HA5 = CB({
    ..._KA.shape,
    ...GxA.shape,
    description: w9(h1()),
    arguments: w9(iB(FA5)),
    _meta: w9(hH({}))
  }), EA5 = ZxA.extend({
    method: I9("prompts/list")
  }), IxA = YxA.extend({
    prompts: iB(HA5)
  }), zA5 = wN.extend({
    name: h1(),
    arguments: pI(h1(), h1()).optional()
  }), $A5 = QE.extend({
    method: I9("prompts/get"),
    params: zA5
  }), wY0 = CB({
    type: I9("text"),
    text: h1(),
    annotations: jKA.optional(),
    _meta: pI(h1(), yD()).optional()
  }), LY0 = CB({
    type: I9("image"),
    data: CY0,
    mimeType: h1(),
    annotations: jKA.optional(),
    _meta: pI(h1(), yD()).optional()
  }), OY0 = CB({
    type: I9("audio"),
    data: CY0,
    mimeType: h1(),
    annotations: jKA.optional(),
    _meta: pI(h1(), yD()).optional()
  }), CA5 = CB({
    type: I9("tool_use"),
    name: h1(),
    id: h1(),
    input: CB({}).passthrough(),
    _meta: w9(CB({}).passthrough())
  }).passthrough(), UA5 = CB({
    type: I9("resource"),
    resource: _Z([o12, r12]),
    annotations: jKA.optional(),
    _meta: pI(h1(), yD()).optional()
  }), qA5 = s12.extend({
    type: I9("resource_link")
  }), MY0 = _Z([wY0, LY0, OY0, qA5, UA5]), NA5 = CB({
    role: YF(["user", "assistant"]),
    content: MY0
  }), RY0 = dz.extend({
    description: w9(h1()),
    messages: iB(NA5)
  }), _Y0 = P_.extend({
    method: I9("notifications/prompts/list_changed")
  }), wA5 = CB({
    title: h1().optional(),
    readOnlyHint: RZ().optional(),
    destructiveHint: RZ().optional(),
    idempotentHint: RZ().optional(),
    openWorldHint: RZ().optional()
  }), LA5 = CB({
    taskSupport: YF(["required", "optional", "forbidden"]).optional()
  }), t12 = CB({
    ..._KA.shape,
    ...GxA.shape,
    description: h1().optional(),
    inputSchema: CB({
      type: I9("object"),
      properties: pI(h1(), Ub).optional(),
      required: iB(h1()).optional()
    }).catchall(yD()),
    outputSchema: CB({
      type: I9("object"),
      properties: pI(h1(), Ub).optional(),
      required: iB(h1()).optional()
    }).catchall(yD()).optional(),
    annotations: w9(wA5),
    execution: w9(LA5),
    _meta: pI(h1(), yD()).optional()
  }), DxA = ZxA.extend({
    method: I9("tools/list")
  }), WxA = YxA.extend({
    tools: iB(t12)
  }), iC = dz.extend({
    content: iB(MY0).default([]),
    structuredContent: pI(h1(), yD()).optional(),
    isError: w9(RZ())
  }), lDZ = iC.or(dz.extend({
    toolResult: yD()
  })), OA5 = wN.extend({
    name: h1(),
    arguments: w9(pI(h1(), yD()))
  }), n9A = QE.extend({
    method: I9("tools/call"),
    params: OA5
  }), jY0 = P_.extend({
    method: I9("notifications/tools/list_changed")
  }), KxA = YF(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]), MA5 = wN.extend({
    level: KxA
  }), TY0 = QE.extend({
    method: I9("logging/setLevel"),
    params: MA5
  }), RA5 = c9A.extend({
    level: KxA,
    logger: h1().optional(),
    data: yD()
  }), _A5 = P_.extend({
    method: I9("notifications/message"),
    params: RA5
  }), jA5 = CB({
    name: h1().optional()
  }), TA5 = CB({
    hints: w9(iB(jA5)),
    costPriority: w9(c7().min(0).max(1)),
    speedPriority: w9(c7().min(0).max(1)),
    intelligencePriority: w9(c7().min(0).max(1))
  }), PA5 = CB({
    mode: w9(YF(["auto", "required", "none"]))
  }), SA5 = CB({
    type: I9("tool_result"),
    toolUseId: h1().describe("The unique identifier for the corresponding tool call."),
    content: iB(MY0).default([]),
    structuredContent: CB({}).passthrough().optional(),
    isError: w9(RZ()),
    _meta: w9(CB({}).passthrough())
  }).passthrough(), xA5 = oQ1("type", [wY0, LY0, OY0]), L71 = oQ1("type", [wY0, LY0, OY0, CA5, SA5]), yA5 = CB({
    role: YF(["user", "assistant"]),
    content: _Z([L71, iB(L71)]),
    _meta: w9(CB({}).passthrough())
  }).passthrough(), vA5 = wN.extend({
    messages: iB(yA5),
    modelPreferences: TA5.optional(),
    systemPrompt: h1().optional(),
    includeContext: YF(["none", "thisServer", "allServers"]).optional(),
    temperature: c7().optional(),
    maxTokens: c7().int(),
    stopSequences: iB(h1()).optional(),
    metadata: Ub.optional(),
    tools: w9(iB(t12)),
    toolChoice: w9(PA5)
  }), PY0 = QE.extend({
    method: I9("sampling/createMessage"),
    params: vA5
  }), VxA = dz.extend({
    model: h1(),
    stopReason: w9(YF(["endTurn", "stopSequence", "maxTokens"]).or(h1())),
    role: YF(["user", "assistant"]),
    content: xA5
  }), SY0 = dz.extend({
    model: h1(),
    stopReason: w9(YF(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(h1())),
    role: YF(["user", "assistant"]),
    content: _Z([L71, iB(L71)])
  }), kA5 = CB({
    type: I9("boolean"),
    title: h1().optional(),
    description: h1().optional(),
    default: RZ().optional()
  }), bA5 = CB({
    type: I9("string"),
    title: h1().optional(),
    description: h1().optional(),
    minLength: c7().optional(),
    maxLength: c7().optional(),
    format: YF(["email", "uri", "date", "date-time"]).optional(),
    default: h1().optional()
  }), fA5 = CB({
    type: YF(["number", "integer"]),
    title: h1().optional(),
    description: h1().optional(),
    minimum: c7().optional(),
    maximum: c7().optional(),
    default: c7().optional()
  }), hA5 = CB({
    type: I9("string"),
    title: h1().optional(),
    description: h1().optional(),
    enum: iB(h1()),
    default: h1().optional()
  }), gA5 = CB({
    type: I9("string"),
    title: h1().optional(),
    description: h1().optional(),
    oneOf: iB(CB({
      const: h1(),
      title: h1()
    })),
    default: h1().optional()
  }), uA5 = CB({
    type: I9("string"),
    title: h1().optional(),
    description: h1().optional(),
    enum: iB(h1()),
    enumNames: iB(h1()).optional(),
    default: h1().optional()
  }), mA5 = _Z([hA5, gA5]), dA5 = CB({
    type: I9("array"),
    title: h1().optional(),
    description: h1().optional(),
    minItems: c7().optional(),
    maxItems: c7().optional(),
    items: CB({
      type: I9("string"),
      enum: iB(h1())
    }),
    default: iB(h1()).optional()
  }), cA5 = CB({
    type: I9("array"),
    title: h1().optional(),
    description: h1().optional(),
    minItems: c7().optional(),
    maxItems: c7().optional(),
    items: CB({
      anyOf: iB(CB({
        const: h1(),
        title: h1()
      }))
    }),
    default: iB(h1()).optional()
  }), pA5 = _Z([dA5, cA5]), lA5 = _Z([uA5, mA5, pA5]), iA5 = _Z([lA5, kA5, bA5, fA5]), nA5 = wN.extend({
    mode: I9("form").optional(),
    message: h1(),
    requestedSchema: CB({
      type: I9("object"),
      properties: pI(h1(), iA5),
      required: iB(h1()).optional()
    })
  }), aA5 = wN.extend({
    mode: I9("url"),
    message: h1(),
    elicitationId: h1(),
    url: h1().url()
  }), oA5 = _Z([nA5, aA5]), b71 = QE.extend({
    method: I9("elicitation/create"),
    params: oA5
  }), rA5 = c9A.extend({
    elicitationId: h1()
  }), sA5 = P_.extend({
    method: I9("notifications/elicitation/complete"),
    params: rA5
  }), TKA = dz.extend({
    action: YF(["accept", "decline", "cancel"]),
    content: sQ1((A) => A === null ? void 0 : A, pI(h1(), _Z([h1(), c7(), RZ(), iB(h1())])).optional())
  }), tA5 = CB({
    type: I9("ref/resource"),
    uri: h1()
  }), eA5 = CB({
    type: I9("ref/prompt"),
    name: h1()
  }), A15 = wN.extend({
    ref: _Z([eA5, tA5]),
    argument: CB({
      name: h1(),
      value: h1()
    }),
    context: CB({
      arguments: pI(h1(), h1()).optional()
    }).optional()
  }), Q15 = QE.extend({
    method: I9("completion/complete"),
    params: A15
  }), xY0 = dz.extend({
    completion: hH({
      values: iB(h1()).max(100),
      total: w9(c7().int()),
      hasMore: w9(RZ())
    })
  }), B15 = CB({
    uri: h1().startsWith("file://"),
    name: h1().optional(),
    _meta: pI(h1(), yD()).optional()
  }), yY0 = QE.extend({
    method: I9("roots/list")
  }), vY0 = dz.extend({
    roots: iB(B15)
  }), G15 = P_.extend({
    method: I9("notifications/roots/list_changed")
  }), iDZ = _Z([T71, zY0, Q15, TY0, $A5, EA5, GA5, ZA5, JA5, IA5, WA5, n9A, DxA, S71, y71, v71]), nDZ = _Z([_71, P71, j71, G15, XxA]), aDZ = _Z([Wd, VxA, SY0, TKA, vY0, x71, k71, Kd]), oDZ = _Z([T71, PY0, b71, yY0, S71, y71, v71]), rDZ = _Z([_71, P71, _A5, VA5, NY0, jY0, _Y0, XxA, sA5]), sDZ = _Z([Wd, $Y0, xY0, RY0, IxA, l9A, UY0, i9A, iC, WxA, x71, k71, Kd]);
  P9 = class P9 extends Error {
    constructor(A, Q, B) {
      super(`MCP error ${A}: ${Q}`);
      this.code = A, this.data = B, this.name = "McpError"
    }
    static fromError(A, Q, B) {
      if (A === q4.UrlElicitationRequired && B) {
        let G = B;
        if (G.elicitations) return new e12(G.elicitations, Q)
      }
      return new P9(A, Q, B)
    }
  };
  e12 = class e12 extends P9 {
    constructor(A, Q = `URL elicitation${A.length>1?"s":""} required`) {
      super(q4.UrlElicitationRequired, Q, {
        elicitations: A
      })
    }
    get elicitations() {
      var A, Q;
      return (Q = (A = this.data) === null || A === void 0 ? void 0 : A.elicitations) !== null && Q !== void 0 ? Q : []
    }
  }
})
// @from(Ln 251602, Col 0)
function Kr(A) {
  return A === "completed" || A === "failed" || A === "cancelled"
}
// @from(Ln 251605, Col 4)
Z15
// @from(Ln 251606, Col 4)
f71 = w(() => {
  Z15 = Symbol("Let zodToJsonSchema decide on which parser to use")
})
// @from(Ln 251609, Col 4)
kY0 = w(() => {
  f71()
})
// @from(Ln 251612, Col 4)
S_ = () => {}
// @from(Ln 251613, Col 4)
bY0 = w(() => {
  QK()
})
// @from(Ln 251616, Col 4)
fY0 = () => {}
// @from(Ln 251617, Col 4)
h71 = w(() => {
  QK()
})
// @from(Ln 251620, Col 4)
hY0 = w(() => {
  QK()
})
// @from(Ln 251623, Col 4)
gY0 = () => {}
// @from(Ln 251624, Col 4)
uY0 = w(() => {
  QK()
})
// @from(Ln 251627, Col 4)
mY0 = w(() => {
  QK();
  S_()
})
// @from(Ln 251631, Col 4)
dY0 = w(() => {
  QK()
})
// @from(Ln 251634, Col 4)
PWZ
// @from(Ln 251635, Col 4)
g71 = w(() => {
  PWZ = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789")
})
// @from(Ln 251638, Col 4)
u71 = w(() => {
  QK();
  g71();
  h71();
  S_()
})
// @from(Ln 251644, Col 4)
cY0 = w(() => {
  QK();
  u71();
  S_()
})
// @from(Ln 251649, Col 4)
pY0 = w(() => {
  S_()
})
// @from(Ln 251652, Col 4)
m71 = w(() => {
  QK()
})
// @from(Ln 251655, Col 4)
lY0 = w(() => {
  QK();
  m71()
})
// @from(Ln 251659, Col 4)
iY0 = () => {}
// @from(Ln 251660, Col 4)
nY0 = w(() => {
  QK()
})
// @from(Ln 251663, Col 4)
aY0 = w(() => {
  QK();
  S_()
})
// @from(Ln 251667, Col 4)
oY0 = w(() => {
  QK()
})
// @from(Ln 251670, Col 4)
rY0 = w(() => {
  QK()
})
// @from(Ln 251673, Col 4)
sY0 = w(() => {
  QK()
})
// @from(Ln 251676, Col 4)
tY0 = w(() => {
  QK()
})
// @from(Ln 251679, Col 4)
eY0 = w(() => {
  S_()
})
// @from(Ln 251682, Col 4)
AJ0 = w(() => {
  S_()
})
// @from(Ln 251685, Col 4)
QJ0 = w(() => {
  QK()
})
// @from(Ln 251688, Col 4)
BJ0 = w(() => {
  S_();
  bY0();
  fY0();
  h71();
  hY0();
  gY0();
  uY0();
  mY0();
  dY0();
  cY0();
  pY0();
  lY0();
  iY0();
  nY0();
  aY0();
  oY0();
  rY0();
  u71();
  sY0();
  g71();
  tY0();
  eY0();
  m71();
  AJ0();
  QJ0()
})
// @from(Ln 251715, Col 4)
QK = w(() => {
  f71();
  BJ0();
  S_()
})
// @from(Ln 251720, Col 4)
A02 = () => {}
// @from(Ln 251721, Col 4)
GJ0 = w(() => {
  QK();
  kY0();
  S_()
})
// @from(Ln 251726, Col 4)
Q02 = w(() => {
  GJ0();
  f71();
  kY0();
  QK();
  A02();
  S_();
  bY0();
  fY0();
  h71();
  hY0();
  gY0();
  uY0();
  mY0();
  dY0();
  cY0();
  pY0();
  lY0();
  iY0();
  nY0();
  aY0();
  oY0();
  rY0();
  QJ0();
  u71();
  sY0();
  g71();
  tY0();
  eY0();
  m71();
  AJ0();
  BJ0();
  GJ0()
})
// @from(Ln 251761, Col 0)
function ZJ0(A) {
  let Q = RKA(A),
    B = Q === null || Q === void 0 ? void 0 : Q.method;
  if (!B) throw Error("Schema is missing a method literal");
  let G = k12(B);
  if (typeof G !== "string") throw Error("Schema method literal must be a string");
  return G
}
// @from(Ln 251770, Col 0)
function YJ0(A, Q) {
  let B = lC(A, Q);
  if (!B.success) throw B.error;
  return B.data
}
// @from(Ln 251775, Col 4)
B02 = w(() => {
  QxA();
  Q02()
})
// @from(Ln 251779, Col 0)
class HxA {
  constructor(A) {
    if (this._options = A, this._requestMessageId = 0, this._requestHandlers = new Map, this._requestHandlerAbortControllers = new Map, this._notificationHandlers = new Map, this._responseHandlers = new Map, this._progressHandlers = new Map, this._timeoutInfo = new Map, this._pendingDebouncedNotifications = new Set, this._taskProgressTokens = new Map, this._requestResolvers = new Map, this.setNotificationHandler(_71, (Q) => {
        this._oncancel(Q)
      }), this.setNotificationHandler(P71, (Q) => {
        this._onprogress(Q)
      }), this.setRequestHandler(T71, (Q) => ({})), this._taskStore = A === null || A === void 0 ? void 0 : A.taskStore, this._taskMessageQueue = A === null || A === void 0 ? void 0 : A.taskMessageQueue, this._taskStore) this.setRequestHandler(S71, async (Q, B) => {
      let G = await this._taskStore.getTask(Q.params.taskId, B.sessionId);
      if (!G) throw new P9(q4.InvalidParams, "Failed to retrieve task: Task not found");
      return {
        ...G
      }
    }), this.setRequestHandler(y71, async (Q, B) => {
      let G = async () => {
        var Z;
        let Y = Q.params.taskId;
        if (this._taskMessageQueue) {
          let X;
          while (X = await this._taskMessageQueue.dequeue(Y, B.sessionId)) {
            if (X.type === "response" || X.type === "error") {
              let I = X.message,
                D = I.id,
                W = this._requestResolvers.get(D);
              if (W)
                if (this._requestResolvers.delete(D), X.type === "response") W(I);
                else {
                  let K = I,
                    V = new P9(K.error.code, K.error.message, K.error.data);
                  W(V)
                }
              else {
                let K = X.type === "response" ? "Response" : "Error";
                this._onerror(Error(`${K} handler missing for request ${D}`))
              }
              continue
            }
            await ((Z = this._transport) === null || Z === void 0 ? void 0 : Z.send(X.message, {
              relatedRequestId: B.requestId
            }))
          }
        }
        let J = await this._taskStore.getTask(Y, B.sessionId);
        if (!J) throw new P9(q4.InvalidParams, `Task not found: ${Y}`);
        if (!Kr(J.status)) return await this._waitForTaskUpdate(Y, B.signal), await G();
        if (Kr(J.status)) {
          let X = await this._taskStore.getTaskResult(Y, B.sessionId);
          return this._clearTaskQueue(Y), {
            ...X,
            _meta: {
              ...X._meta,
              [qb]: {
                taskId: Y
              }
            }
          }
        }
        return await G()
      };
      return await G()
    }), this.setRequestHandler(v71, async (Q, B) => {
      var G;
      try {
        let {
          tasks: Z,
          nextCursor: Y
        } = await this._taskStore.listTasks((G = Q.params) === null || G === void 0 ? void 0 : G.cursor, B.sessionId);
        return {
          tasks: Z,
          nextCursor: Y,
          _meta: {}
        }
      } catch (Z) {
        throw new P9(q4.InvalidParams, `Failed to list tasks: ${Z instanceof Error?Z.message:String(Z)}`)
      }
    }), this.setRequestHandler(i12, async (Q, B) => {
      try {
        let G = await this._taskStore.getTask(Q.params.taskId, B.sessionId);
        if (!G) throw new P9(q4.InvalidParams, `Task not found: ${Q.params.taskId}`);
        if (Kr(G.status)) throw new P9(q4.InvalidParams, `Cannot cancel task in terminal status: ${G.status}`);
        await this._taskStore.updateTaskStatus(Q.params.taskId, "cancelled", "Client cancelled task execution.", B.sessionId), this._clearTaskQueue(Q.params.taskId);
        let Z = await this._taskStore.getTask(Q.params.taskId, B.sessionId);
        if (!Z) throw new P9(q4.InvalidParams, `Task not found after cancellation: ${Q.params.taskId}`);
        return {
          _meta: {},
          ...Z
        }
      } catch (G) {
        if (G instanceof P9) throw G;
        throw new P9(q4.InvalidRequest, `Failed to cancel task: ${G instanceof Error?G.message:String(G)}`)
      }
    })
  }
  async _oncancel(A) {
    let Q = this._requestHandlerAbortControllers.get(A.params.requestId);
    Q === null || Q === void 0 || Q.abort(A.params.reason)
  }
  _setupTimeout(A, Q, B, G, Z = !1) {
    this._timeoutInfo.set(A, {
      timeoutId: setTimeout(G, Q),
      startTime: Date.now(),
      timeout: Q,
      maxTotalTimeout: B,
      resetTimeoutOnProgress: Z,
      onTimeout: G
    })
  }
  _resetTimeout(A) {
    let Q = this._timeoutInfo.get(A);
    if (!Q) return !1;
    let B = Date.now() - Q.startTime;
    if (Q.maxTotalTimeout && B >= Q.maxTotalTimeout) throw this._timeoutInfo.delete(A), P9.fromError(q4.RequestTimeout, "Maximum total timeout exceeded", {
      maxTotalTimeout: Q.maxTotalTimeout,
      totalElapsed: B
    });
    return clearTimeout(Q.timeoutId), Q.timeoutId = setTimeout(Q.onTimeout, Q.timeout), !0
  }
  _cleanupTimeout(A) {
    let Q = this._timeoutInfo.get(A);
    if (Q) clearTimeout(Q.timeoutId), this._timeoutInfo.delete(A)
  }
  async connect(A) {
    var Q, B, G;
    this._transport = A;
    let Z = (Q = this.transport) === null || Q === void 0 ? void 0 : Q.onclose;
    this._transport.onclose = () => {
      Z === null || Z === void 0 || Z(), this._onclose()
    };
    let Y = (B = this.transport) === null || B === void 0 ? void 0 : B.onerror;
    this._transport.onerror = (X) => {
      Y === null || Y === void 0 || Y(X), this._onerror(X)
    };
    let J = (G = this._transport) === null || G === void 0 ? void 0 : G.onmessage;
    this._transport.onmessage = (X, I) => {
      if (J === null || J === void 0 || J(X, I), p9A(X) || c12(X)) this._onresponse(X);
      else if (BxA(X)) this._onrequest(X, I);
      else if (u12(X)) this._onnotification(X);
      else this._onerror(Error(`Unknown message type: ${JSON.stringify(X)}`))
    }, await this._transport.start()
  }
  _onclose() {
    var A;
    let Q = this._responseHandlers;
    this._responseHandlers = new Map, this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
    let B = P9.fromError(q4.ConnectionClosed, "Connection closed");
    this._transport = void 0, (A = this.onclose) === null || A === void 0 || A.call(this);
    for (let G of Q.values()) G(B)
  }
  _onerror(A) {
    var Q;
    (Q = this.onerror) === null || Q === void 0 || Q.call(this, A)
  }
  _onnotification(A) {
    var Q;
    let B = (Q = this._notificationHandlers.get(A.method)) !== null && Q !== void 0 ? Q : this.fallbackNotificationHandler;
    if (B === void 0) return;
    Promise.resolve().then(() => B(A)).catch((G) => this._onerror(Error(`Uncaught error in notification handler: ${G}`)))
  }
  _onrequest(A, Q) {
    var B, G, Z, Y, J, X;
    let I = (B = this._requestHandlers.get(A.method)) !== null && B !== void 0 ? B : this.fallbackRequestHandler,
      D = this._transport,
      W = (Y = (Z = (G = A.params) === null || G === void 0 ? void 0 : G._meta) === null || Z === void 0 ? void 0 : Z[qb]) === null || Y === void 0 ? void 0 : Y.taskId;
    if (I === void 0) {
      let E = {
        jsonrpc: "2.0",
        id: A.id,
        error: {
          code: q4.MethodNotFound,
          message: "Method not found"
        }
      };
      if (W && this._taskMessageQueue) this._enqueueTaskMessage(W, {
        type: "error",
        message: E,
        timestamp: Date.now()
      }, D === null || D === void 0 ? void 0 : D.sessionId).catch((z) => this._onerror(Error(`Failed to enqueue error response: ${z}`)));
      else D === null || D === void 0 || D.send(E).catch((z) => this._onerror(Error(`Failed to send an error response: ${z}`)));
      return
    }
    let K = new AbortController;
    this._requestHandlerAbortControllers.set(A.id, K);
    let V = (J = A.params) === null || J === void 0 ? void 0 : J.task,
      F = this._taskStore ? this.requestTaskStore(A, D === null || D === void 0 ? void 0 : D.sessionId) : void 0,
      H = {
        signal: K.signal,
        sessionId: D === null || D === void 0 ? void 0 : D.sessionId,
        _meta: (X = A.params) === null || X === void 0 ? void 0 : X._meta,
        sendNotification: async (E) => {
          let z = {
            relatedRequestId: A.id
          };
          if (W) z.relatedTask = {
            taskId: W
          };
          await this.notification(E, z)
        },
        sendRequest: async (E, z, $) => {
          var O, L;
          let M = {
            ...$,
            relatedRequestId: A.id
          };
          if (W && !M.relatedTask) M.relatedTask = {
            taskId: W
          };
          let _ = (L = (O = M.relatedTask) === null || O === void 0 ? void 0 : O.taskId) !== null && L !== void 0 ? L : W;
          if (_ && F) await F.updateTaskStatus(_, "input_required");
          return await this.request(E, z, M)
        },
        authInfo: Q === null || Q === void 0 ? void 0 : Q.authInfo,
        requestId: A.id,
        requestInfo: Q === null || Q === void 0 ? void 0 : Q.requestInfo,
        taskId: W,
        taskStore: F,
        taskRequestedTtl: V === null || V === void 0 ? void 0 : V.ttl,
        closeSSEStream: Q === null || Q === void 0 ? void 0 : Q.closeSSEStream,
        closeStandaloneSSEStream: Q === null || Q === void 0 ? void 0 : Q.closeStandaloneSSEStream
      };
    Promise.resolve().then(() => {
      if (V) this.assertTaskHandlerCapability(A.method)
    }).then(() => I(A, H)).then(async (E) => {
      if (K.signal.aborted) return;
      let z = {
        result: E,
        jsonrpc: "2.0",
        id: A.id
      };
      if (W && this._taskMessageQueue) await this._enqueueTaskMessage(W, {
        type: "response",
        message: z,
        timestamp: Date.now()
      }, D === null || D === void 0 ? void 0 : D.sessionId);
      else await (D === null || D === void 0 ? void 0 : D.send(z))
    }, async (E) => {
      var z;
      if (K.signal.aborted) return;
      let $ = {
        jsonrpc: "2.0",
        id: A.id,
        error: {
          code: Number.isSafeInteger(E.code) ? E.code : q4.InternalError,
          message: (z = E.message) !== null && z !== void 0 ? z : "Internal error",
          ...E.data !== void 0 && {
            data: E.data
          }
        }
      };
      if (W && this._taskMessageQueue) await this._enqueueTaskMessage(W, {
        type: "error",
        message: $,
        timestamp: Date.now()
      }, D === null || D === void 0 ? void 0 : D.sessionId);
      else await (D === null || D === void 0 ? void 0 : D.send($))
    }).catch((E) => this._onerror(Error(`Failed to send response: ${E}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(A.id)
    })
  }
  _onprogress(A) {
    let {
      progressToken: Q,
      ...B
    } = A.params, G = Number(Q), Z = this._progressHandlers.get(G);
    if (!Z) {
      this._onerror(Error(`Received a progress notification for an unknown token: ${JSON.stringify(A)}`));
      return
    }
    let Y = this._responseHandlers.get(G),
      J = this._timeoutInfo.get(G);
    if (J && Y && J.resetTimeoutOnProgress) try {
      this._resetTimeout(G)
    } catch (X) {
      this._responseHandlers.delete(G), this._progressHandlers.delete(G), this._cleanupTimeout(G), Y(X);
      return
    }
    Z(B)
  }
  _onresponse(A) {
    let Q = Number(A.id),
      B = this._requestResolvers.get(Q);
    if (B) {
      if (this._requestResolvers.delete(Q), p9A(A)) B(A);
      else {
        let Y = new P9(A.error.code, A.error.message, A.error.data);
        B(Y)
      }
      return
    }
    let G = this._responseHandlers.get(Q);
    if (G === void 0) {
      this._onerror(Error(`Received a response for an unknown message ID: ${JSON.stringify(A)}`));
      return
    }
    this._responseHandlers.delete(Q), this._cleanupTimeout(Q);
    let Z = !1;
    if (p9A(A) && A.result && typeof A.result === "object") {
      let Y = A.result;
      if (Y.task && typeof Y.task === "object") {
        let J = Y.task;
        if (typeof J.taskId === "string") Z = !0, this._taskProgressTokens.set(J.taskId, Q)
      }
    }
    if (!Z) this._progressHandlers.delete(Q);
    if (p9A(A)) G(A);
    else {
      let Y = P9.fromError(A.error.code, A.error.message, A.error.data);
      G(Y)
    }
  }
  get transport() {
    return this._transport
  }
  async close() {
    var A;
    await ((A = this._transport) === null || A === void 0 ? void 0 : A.close())
  }
  async * requestStream(A, Q, B) {
    var G, Z, Y, J;
    let {
      task: X
    } = B !== null && B !== void 0 ? B : {};
    if (!X) {
      try {
        yield {
          type: "result",
          result: await this.request(A, Q, B)
        }
      } catch (D) {
        yield {
          type: "error",
          error: D instanceof P9 ? D : new P9(q4.InternalError, String(D))
        }
      }
      return
    }
    let I;
    try {
      let D = await this.request(A, Kd, B);
      if (D.task) I = D.task.taskId, yield {
        type: "taskCreated",
        task: D.task
      };
      else throw new P9(q4.InternalError, "Task creation did not return a task");
      while (!0) {
        let W = await this.getTask({
          taskId: I
        }, B);
        if (yield {
            type: "taskStatus",
            task: W
          }, Kr(W.status)) {
          if (W.status === "completed") yield {
            type: "result",
            result: await this.getTaskResult({
              taskId: I
            }, Q, B)
          };
          else if (W.status === "failed") yield {
            type: "error",
            error: new P9(q4.InternalError, `Task ${I} failed`)
          };
          else if (W.status === "cancelled") yield {
            type: "error",
            error: new P9(q4.InternalError, `Task ${I} was cancelled`)
          };
          return
        }
        if (W.status === "input_required") {
          yield {
            type: "result",
            result: await this.getTaskResult({
              taskId: I
            }, Q, B)
          };
          return
        }
        let K = (Y = (G = W.pollInterval) !== null && G !== void 0 ? G : (Z = this._options) === null || Z === void 0 ? void 0 : Z.defaultTaskPollInterval) !== null && Y !== void 0 ? Y : 1000;
        await new Promise((V) => setTimeout(V, K)), (J = B === null || B === void 0 ? void 0 : B.signal) === null || J === void 0 || J.throwIfAborted()
      }
    } catch (D) {
      yield {
        type: "error",
        error: D instanceof P9 ? D : new P9(q4.InternalError, String(D))
      }
    }
  }
  request(A, Q, B) {
    let {
      relatedRequestId: G,
      resumptionToken: Z,
      onresumptiontoken: Y,
      task: J,
      relatedTask: X
    } = B !== null && B !== void 0 ? B : {};
    return new Promise((I, D) => {
      var W, K, V, F, H, E, z;
      let $ = (b) => {
        D(b)
      };
      if (!this._transport) {
        $(Error("Not connected"));
        return
      }
      if (((W = this._options) === null || W === void 0 ? void 0 : W.enforceStrictCapabilities) === !0) try {
        if (this.assertCapabilityForMethod(A.method), J) this.assertTaskCapability(A.method)
      } catch (b) {
        $(b);
        return
      }(K = B === null || B === void 0 ? void 0 : B.signal) === null || K === void 0 || K.throwIfAborted();
      let O = this._requestMessageId++,
        L = {
          ...A,
          jsonrpc: "2.0",
          id: O
        };
      if (B === null || B === void 0 ? void 0 : B.onprogress) this._progressHandlers.set(O, B.onprogress), L.params = {
        ...A.params,
        _meta: {
          ...((V = A.params) === null || V === void 0 ? void 0 : V._meta) || {},
          progressToken: O
        }
      };
      if (J) L.params = {
        ...L.params,
        task: J
      };
      if (X) L.params = {
        ...L.params,
        _meta: {
          ...((F = L.params) === null || F === void 0 ? void 0 : F._meta) || {},
          [qb]: X
        }
      };
      let M = (b) => {
        var S;
        this._responseHandlers.delete(O), this._progressHandlers.delete(O), this._cleanupTimeout(O), (S = this._transport) === null || S === void 0 || S.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: O,
            reason: String(b)
          }
        }, {
          relatedRequestId: G,
          resumptionToken: Z,
          onresumptiontoken: Y
        }).catch((f) => this._onerror(Error(`Failed to send cancellation: ${f}`)));
        let u = b instanceof P9 ? b : new P9(q4.RequestTimeout, String(b));
        D(u)
      };
      this._responseHandlers.set(O, (b) => {
        var S;
        if ((S = B === null || B === void 0 ? void 0 : B.signal) === null || S === void 0 ? void 0 : S.aborted) return;
        if (b instanceof Error) return D(b);
        try {
          let u = lC(Q, b.result);
          if (!u.success) D(u.error);
          else I(u.data)
        } catch (u) {
          D(u)
        }
      }), (H = B === null || B === void 0 ? void 0 : B.signal) === null || H === void 0 || H.addEventListener("abort", () => {
        var b;
        M((b = B === null || B === void 0 ? void 0 : B.signal) === null || b === void 0 ? void 0 : b.reason)
      });
      let _ = (E = B === null || B === void 0 ? void 0 : B.timeout) !== null && E !== void 0 ? E : W15,
        j = () => M(P9.fromError(q4.RequestTimeout, "Request timed out", {
          timeout: _
        }));
      this._setupTimeout(O, _, B === null || B === void 0 ? void 0 : B.maxTotalTimeout, j, (z = B === null || B === void 0 ? void 0 : B.resetTimeoutOnProgress) !== null && z !== void 0 ? z : !1);
      let x = X === null || X === void 0 ? void 0 : X.taskId;
      if (x) {
        let b = (S) => {
          let u = this._responseHandlers.get(O);
          if (u) u(S);
          else this._onerror(Error(`Response handler missing for side-channeled request ${O}`))
        };
        this._requestResolvers.set(O, b), this._enqueueTaskMessage(x, {
          type: "request",
          message: L,
          timestamp: Date.now()
        }).catch((S) => {
          this._cleanupTimeout(O), D(S)
        })
      } else this._transport.send(L, {
        relatedRequestId: G,
        resumptionToken: Z,
        onresumptiontoken: Y
      }).catch((b) => {
        this._cleanupTimeout(O), D(b)
      })
    })
  }
  async getTask(A, Q) {
    return this.request({
      method: "tasks/get",
      params: A
    }, x71, Q)
  }
  async getTaskResult(A, Q, B) {
    return this.request({
      method: "tasks/result",
      params: A
    }, Q, B)
  }
  async listTasks(A, Q) {
    return this.request({
      method: "tasks/list",
      params: A
    }, k71, Q)
  }
  async cancelTask(A, Q) {
    return this.request({
      method: "tasks/cancel",
      params: A
    }, n12, Q)
  }
  async notification(A, Q) {
    var B, G, Z, Y, J;
    if (!this._transport) throw Error("Not connected");
    this.assertNotificationCapability(A.method);
    let X = (B = Q === null || Q === void 0 ? void 0 : Q.relatedTask) === null || B === void 0 ? void 0 : B.taskId;
    if (X) {
      let K = {
        ...A,
        jsonrpc: "2.0",
        params: {
          ...A.params,
          _meta: {
            ...((G = A.params) === null || G === void 0 ? void 0 : G._meta) || {},
            [qb]: Q.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(X, {
        type: "notification",
        message: K,
        timestamp: Date.now()
      });
      return
    }
    if (((Y = (Z = this._options) === null || Z === void 0 ? void 0 : Z.debouncedNotificationMethods) !== null && Y !== void 0 ? Y : []).includes(A.method) && !A.params && !(Q === null || Q === void 0 ? void 0 : Q.relatedRequestId) && !(Q === null || Q === void 0 ? void 0 : Q.relatedTask)) {
      if (this._pendingDebouncedNotifications.has(A.method)) return;
      this._pendingDebouncedNotifications.add(A.method), Promise.resolve().then(() => {
        var K, V;
        if (this._pendingDebouncedNotifications.delete(A.method), !this._transport) return;
        let F = {
          ...A,
          jsonrpc: "2.0"
        };
        if (Q === null || Q === void 0 ? void 0 : Q.relatedTask) F = {
          ...F,
          params: {
            ...F.params,
            _meta: {
              ...((K = F.params) === null || K === void 0 ? void 0 : K._meta) || {},
              [qb]: Q.relatedTask
            }
          }
        };
        (V = this._transport) === null || V === void 0 || V.send(F, Q).catch((H) => this._onerror(H))
      });
      return
    }
    let W = {
      ...A,
      jsonrpc: "2.0"
    };
    if (Q === null || Q === void 0 ? void 0 : Q.relatedTask) W = {
      ...W,
      params: {
        ...W.params,
        _meta: {
          ...((J = W.params) === null || J === void 0 ? void 0 : J._meta) || {},
          [qb]: Q.relatedTask
        }
      }
    };
    await this._transport.send(W, Q)
  }
  setRequestHandler(A, Q) {
    let B = ZJ0(A);
    this.assertRequestHandlerCapability(B), this._requestHandlers.set(B, (G, Z) => {
      let Y = YJ0(A, G);
      return Promise.resolve(Q(Y, Z))
    })
  }
  removeRequestHandler(A) {
    this._requestHandlers.delete(A)
  }
  assertCanSetRequestHandler(A) {
    if (this._requestHandlers.has(A)) throw Error(`A request handler for ${A} already exists, which would be overridden`)
  }
  setNotificationHandler(A, Q) {
    let B = ZJ0(A);
    this._notificationHandlers.set(B, (G) => {
      let Z = YJ0(A, G);
      return Promise.resolve(Q(Z))
    })
  }
  removeNotificationHandler(A) {
    this._notificationHandlers.delete(A)
  }
  _cleanupTaskProgressHandler(A) {
    let Q = this._taskProgressTokens.get(A);
    if (Q !== void 0) this._progressHandlers.delete(Q), this._taskProgressTokens.delete(A)
  }
  async _enqueueTaskMessage(A, Q, B) {
    var G;
    if (!this._taskStore || !this._taskMessageQueue) throw Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    let Z = (G = this._options) === null || G === void 0 ? void 0 : G.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(A, Q, B, Z)
  }
  async _clearTaskQueue(A, Q) {
    if (this._taskMessageQueue) {
      let B = await this._taskMessageQueue.dequeueAll(A, Q);
      for (let G of B)
        if (G.type === "request" && BxA(G.message)) {
          let Z = G.message.id,
            Y = this._requestResolvers.get(Z);
          if (Y) Y(new P9(q4.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(Z);
          else this._onerror(Error(`Resolver missing for request ${Z} during task ${A} cleanup`))
        }
    }
  }
  async _waitForTaskUpdate(A, Q) {
    var B, G, Z;
    let Y = (G = (B = this._options) === null || B === void 0 ? void 0 : B.defaultTaskPollInterval) !== null && G !== void 0 ? G : 1000;
    try {
      let J = await ((Z = this._taskStore) === null || Z === void 0 ? void 0 : Z.getTask(A));
      if (J === null || J === void 0 ? void 0 : J.pollInterval) Y = J.pollInterval
    } catch (J) {}
    return new Promise((J, X) => {
      if (Q.aborted) {
        X(new P9(q4.InvalidRequest, "Request cancelled"));
        return
      }
      let I = setTimeout(J, Y);
      Q.addEventListener("abort", () => {
        clearTimeout(I), X(new P9(q4.InvalidRequest, "Request cancelled"))
      }, {
        once: !0
      })
    })
  }
  requestTaskStore(A, Q) {
    let B = this._taskStore;
    if (!B) throw Error("No task store configured");
    return {
      createTask: async (G) => {
        if (!A) throw Error("No request provided");
        return await B.createTask(G, A.id, {
          method: A.method,
          params: A.params
        }, Q)
      },
      getTask: async (G) => {
        let Z = await B.getTask(G, Q);
        if (!Z) throw new P9(q4.InvalidParams, "Failed to retrieve task: Task not found");
        return Z
      },
      storeTaskResult: async (G, Z, Y) => {
        await B.storeTaskResult(G, Z, Y, Q);
        let J = await B.getTask(G, Q);
        if (J) {
          let X = XxA.parse({
            method: "notifications/tasks/status",
            params: J
          });
          if (await this.notification(X), Kr(J.status)) this._cleanupTaskProgressHandler(G)
        }
      },
      getTaskResult: (G) => {
        return B.getTaskResult(G, Q)
      },
      updateTaskStatus: async (G, Z, Y) => {
        let J = await B.getTask(G, Q);
        if (!J) throw new P9(q4.InvalidParams, `Task "${G}" not found - it may have been cleaned up`);
        if (Kr(J.status)) throw new P9(q4.InvalidParams, `Cannot update task "${G}" from terminal status "${J.status}" to "${Z}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        await B.updateTaskStatus(G, Z, Y, Q);
        let X = await B.getTask(G, Q);
        if (X) {
          let I = XxA.parse({
            method: "notifications/tasks/status",
            params: X
          });
          if (await this.notification(I), Kr(X.status)) this._cleanupTaskProgressHandler(G)
        }
      },
      listTasks: (G) => {
        return B.listTasks(G, Q)
      }
    }
  }
}
// @from(Ln 252474, Col 0)
function G02(A) {
  return A !== null && typeof A === "object" && !Array.isArray(A)
}
// @from(Ln 252478, Col 0)
function d71(A, Q) {
  let B = {
    ...A
  };
  for (let G in Q) {
    let Z = G,
      Y = Q[Z];
    if (Y === void 0) continue;
    let J = B[Z];
    if (G02(J) && G02(Y)) B[Z] = {
      ...J,
      ...Y
    };
    else B[Z] = Y
  }
  return B
}
// @from(Ln 252495, Col 4)
W15 = 60000
// @from(Ln 252496, Col 4)
JJ0 = w(() => {
  QxA();
  eK();
  B02()
})
// @from(Ln 252501, Col 4)
zxA = U((J02) => {
  Object.defineProperty(J02, "__esModule", {
    value: !0
  });
  J02.regexpCode = J02.getEsmExportName = J02.getProperty = J02.safeStringify = J02.stringify = J02.strConcat = J02.addCodeArg = J02.str = J02._ = J02.nil = J02._Code = J02.Name = J02.IDENTIFIER = J02._CodeOrName = void 0;
  class c71 {}
  J02._CodeOrName = c71;
  J02.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class PKA extends c71 {
    constructor(A) {
      super();
      if (!J02.IDENTIFIER.test(A)) throw Error("CodeGen: name must be a valid identifier");
      this.str = A
    }
    toString() {
      return this.str
    }
    emptyStr() {
      return !1
    }
    get names() {
      return {
        [this.str]: 1
      }
    }
  }
  J02.Name = PKA;
  class HS extends c71 {
    constructor(A) {
      super();
      this._items = typeof A === "string" ? [A] : A
    }
    toString() {
      return this.str
    }
    emptyStr() {
      if (this._items.length > 1) return !1;
      let A = this._items[0];
      return A === "" || A === '""'
    }
    get str() {
      var A;
      return (A = this._str) !== null && A !== void 0 ? A : this._str = this._items.reduce((Q, B) => `${Q}${B}`, "")
    }
    get names() {
      var A;
      return (A = this._names) !== null && A !== void 0 ? A : this._names = this._items.reduce((Q, B) => {
        if (B instanceof PKA) Q[B.str] = (Q[B.str] || 0) + 1;
        return Q
      }, {})
    }
  }
  J02._Code = HS;
  J02.nil = new HS("");

  function Z02(A, ...Q) {
    let B = [A[0]],
      G = 0;
    while (G < Q.length) IJ0(B, Q[G]), B.push(A[++G]);
    return new HS(B)
  }
  J02._ = Z02;
  var XJ0 = new HS("+");

  function Y02(A, ...Q) {
    let B = [ExA(A[0])],
      G = 0;
    while (G < Q.length) B.push(XJ0), IJ0(B, Q[G]), B.push(XJ0, ExA(A[++G]));
    return K15(B), new HS(B)
  }
  J02.str = Y02;

  function IJ0(A, Q) {
    if (Q instanceof HS) A.push(...Q._items);
    else if (Q instanceof PKA) A.push(Q);
    else A.push(H15(Q))
  }
  J02.addCodeArg = IJ0;

  function K15(A) {
    let Q = 1;
    while (Q < A.length - 1) {
      if (A[Q] === XJ0) {
        let B = V15(A[Q - 1], A[Q + 1]);
        if (B !== void 0) {
          A.splice(Q - 1, 3, B);
          continue
        }
        A[Q++] = "+"
      }
      Q++
    }
  }

  function V15(A, Q) {
    if (Q === '""') return A;
    if (A === '""') return Q;
    if (typeof A == "string") {
      if (Q instanceof PKA || A[A.length - 1] !== '"') return;
      if (typeof Q != "string") return `${A.slice(0,-1)}${Q}"`;
      if (Q[0] === '"') return A.slice(0, -1) + Q.slice(1);
      return
    }
    if (typeof Q == "string" && Q[0] === '"' && !(A instanceof PKA)) return `"${A}${Q.slice(1)}`;
    return
  }

  function F15(A, Q) {
    return Q.emptyStr() ? A : A.emptyStr() ? Q : Y02`${A}${Q}`
  }
  J02.strConcat = F15;

  function H15(A) {
    return typeof A == "number" || typeof A == "boolean" || A === null ? A : ExA(Array.isArray(A) ? A.join(",") : A)
  }

  function E15(A) {
    return new HS(ExA(A))
  }
  J02.stringify = E15;

  function ExA(A) {
    return JSON.stringify(A).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
  }
  J02.safeStringify = ExA;

  function z15(A) {
    return typeof A == "string" && J02.IDENTIFIER.test(A) ? new HS(`.${A}`) : Z02`[${A}]`
  }
  J02.getProperty = z15;

  function $15(A) {
    if (typeof A == "string" && J02.IDENTIFIER.test(A)) return new HS(`${A}`);
    throw Error(`CodeGen: invalid export name: ${A}, use explicit $id name mapping`)
  }
  J02.getEsmExportName = $15;

  function C15(A) {
    return new HS(A.toString())
  }
  J02.regexpCode = C15
})
// @from(Ln 252643, Col 4)
VJ0 = U((W02) => {
  Object.defineProperty(W02, "__esModule", {
    value: !0
  });
  W02.ValueScope = W02.ValueScopeName = W02.Scope = W02.varKinds = W02.UsedValueState = void 0;
  var LN = zxA();
  class I02 extends Error {
    constructor(A) {
      super(`CodeGen: "code" for ${A} not defined`);
      this.value = A.value
    }
  }
  var l71;
  (function (A) {
    A[A.Started = 0] = "Started", A[A.Completed = 1] = "Completed"
  })(l71 || (W02.UsedValueState = l71 = {}));
  W02.varKinds = {
    const: new LN.Name("const"),
    let: new LN.Name("let"),
    var: new LN.Name("var")
  };
  class WJ0 {
    constructor({
      prefixes: A,
      parent: Q
    } = {}) {
      this._names = {}, this._prefixes = A, this._parent = Q
    }
    toName(A) {
      return A instanceof LN.Name ? A : this.name(A)
    }
    name(A) {
      return new LN.Name(this._newName(A))
    }
    _newName(A) {
      let Q = this._names[A] || this._nameGroup(A);
      return `${A}${Q.index++}`
    }
    _nameGroup(A) {
      var Q, B;
      if (((B = (Q = this._parent) === null || Q === void 0 ? void 0 : Q._prefixes) === null || B === void 0 ? void 0 : B.has(A)) || this._prefixes && !this._prefixes.has(A)) throw Error(`CodeGen: prefix "${A}" is not allowed in this scope`);
      return this._names[A] = {
        prefix: A,
        index: 0
      }
    }
  }
  W02.Scope = WJ0;
  class KJ0 extends LN.Name {
    constructor(A, Q) {
      super(Q);
      this.prefix = A
    }
    setValue(A, {
      property: Q,
      itemIndex: B
    }) {
      this.value = A, this.scopePath = LN._`.${new LN.Name(Q)}[${B}]`
    }
  }
  W02.ValueScopeName = KJ0;
  var S15 = LN._`\n`;
  class D02 extends WJ0 {
    constructor(A) {
      super(A);
      this._values = {}, this._scope = A.scope, this.opts = {
        ...A,
        _n: A.lines ? S15 : LN.nil
      }
    }
    get() {
      return this._scope
    }
    name(A) {
      return new KJ0(A, this._newName(A))
    }
    value(A, Q) {
      var B;
      if (Q.ref === void 0) throw Error("CodeGen: ref must be passed in value");
      let G = this.toName(A),
        {
          prefix: Z
        } = G,
        Y = (B = Q.key) !== null && B !== void 0 ? B : Q.ref,
        J = this._values[Z];
      if (J) {
        let D = J.get(Y);
        if (D) return D
      } else J = this._values[Z] = new Map;
      J.set(Y, G);
      let X = this._scope[Z] || (this._scope[Z] = []),
        I = X.length;
      return X[I] = Q.ref, G.setValue(Q, {
        property: Z,
        itemIndex: I
      }), G
    }
    getValue(A, Q) {
      let B = this._values[A];
      if (!B) return;
      return B.get(Q)
    }
    scopeRefs(A, Q = this._values) {
      return this._reduceValues(Q, (B) => {
        if (B.scopePath === void 0) throw Error(`CodeGen: name "${B}" has no value`);
        return LN._`${A}${B.scopePath}`
      })
    }
    scopeCode(A = this._values, Q, B) {
      return this._reduceValues(A, (G) => {
        if (G.value === void 0) throw Error(`CodeGen: name "${G}" has no value`);
        return G.value.code
      }, Q, B)
    }
    _reduceValues(A, Q, B = {}, G) {
      let Z = LN.nil;
      for (let Y in A) {
        let J = A[Y];
        if (!J) continue;
        let X = B[Y] = B[Y] || new Map;
        J.forEach((I) => {
          if (X.has(I)) return;
          X.set(I, l71.Started);
          let D = Q(I);
          if (D) {
            let W = this.opts.es5 ? W02.varKinds.var : W02.varKinds.const;
            Z = LN._`${Z}${W} ${I} = ${D};${this.opts._n}`
          } else if (D = G === null || G === void 0 ? void 0 : G(I)) Z = LN._`${Z}${D}${this.opts._n}`;
          else throw new I02(I);
          X.set(I, l71.Completed)
        })
      }
      return Z
    }
  }
  W02.ValueScope = D02
})