
// @from(Ln 262171, Col 4)
aX0 = U((T85) => {
  function o42() {
    var A = {};
    return A["align-content"] = !1, A["align-items"] = !1, A["align-self"] = !1, A["alignment-adjust"] = !1, A["alignment-baseline"] = !1, A.all = !1, A["anchor-point"] = !1, A.animation = !1, A["animation-delay"] = !1, A["animation-direction"] = !1, A["animation-duration"] = !1, A["animation-fill-mode"] = !1, A["animation-iteration-count"] = !1, A["animation-name"] = !1, A["animation-play-state"] = !1, A["animation-timing-function"] = !1, A.azimuth = !1, A["backface-visibility"] = !1, A.background = !0, A["background-attachment"] = !0, A["background-clip"] = !0, A["background-color"] = !0, A["background-image"] = !0, A["background-origin"] = !0, A["background-position"] = !0, A["background-repeat"] = !0, A["background-size"] = !0, A["baseline-shift"] = !1, A.binding = !1, A.bleed = !1, A["bookmark-label"] = !1, A["bookmark-level"] = !1, A["bookmark-state"] = !1, A.border = !0, A["border-bottom"] = !0, A["border-bottom-color"] = !0, A["border-bottom-left-radius"] = !0, A["border-bottom-right-radius"] = !0, A["border-bottom-style"] = !0, A["border-bottom-width"] = !0, A["border-collapse"] = !0, A["border-color"] = !0, A["border-image"] = !0, A["border-image-outset"] = !0, A["border-image-repeat"] = !0, A["border-image-slice"] = !0, A["border-image-source"] = !0, A["border-image-width"] = !0, A["border-left"] = !0, A["border-left-color"] = !0, A["border-left-style"] = !0, A["border-left-width"] = !0, A["border-radius"] = !0, A["border-right"] = !0, A["border-right-color"] = !0, A["border-right-style"] = !0, A["border-right-width"] = !0, A["border-spacing"] = !0, A["border-style"] = !0, A["border-top"] = !0, A["border-top-color"] = !0, A["border-top-left-radius"] = !0, A["border-top-right-radius"] = !0, A["border-top-style"] = !0, A["border-top-width"] = !0, A["border-width"] = !0, A.bottom = !1, A["box-decoration-break"] = !0, A["box-shadow"] = !0, A["box-sizing"] = !0, A["box-snap"] = !0, A["box-suppress"] = !0, A["break-after"] = !0, A["break-before"] = !0, A["break-inside"] = !0, A["caption-side"] = !1, A.chains = !1, A.clear = !0, A.clip = !1, A["clip-path"] = !1, A["clip-rule"] = !1, A.color = !0, A["color-interpolation-filters"] = !0, A["column-count"] = !1, A["column-fill"] = !1, A["column-gap"] = !1, A["column-rule"] = !1, A["column-rule-color"] = !1, A["column-rule-style"] = !1, A["column-rule-width"] = !1, A["column-span"] = !1, A["column-width"] = !1, A.columns = !1, A.contain = !1, A.content = !1, A["counter-increment"] = !1, A["counter-reset"] = !1, A["counter-set"] = !1, A.crop = !1, A.cue = !1, A["cue-after"] = !1, A["cue-before"] = !1, A.cursor = !1, A.direction = !1, A.display = !0, A["display-inside"] = !0, A["display-list"] = !0, A["display-outside"] = !0, A["dominant-baseline"] = !1, A.elevation = !1, A["empty-cells"] = !1, A.filter = !1, A.flex = !1, A["flex-basis"] = !1, A["flex-direction"] = !1, A["flex-flow"] = !1, A["flex-grow"] = !1, A["flex-shrink"] = !1, A["flex-wrap"] = !1, A.float = !1, A["float-offset"] = !1, A["flood-color"] = !1, A["flood-opacity"] = !1, A["flow-from"] = !1, A["flow-into"] = !1, A.font = !0, A["font-family"] = !0, A["font-feature-settings"] = !0, A["font-kerning"] = !0, A["font-language-override"] = !0, A["font-size"] = !0, A["font-size-adjust"] = !0, A["font-stretch"] = !0, A["font-style"] = !0, A["font-synthesis"] = !0, A["font-variant"] = !0, A["font-variant-alternates"] = !0, A["font-variant-caps"] = !0, A["font-variant-east-asian"] = !0, A["font-variant-ligatures"] = !0, A["font-variant-numeric"] = !0, A["font-variant-position"] = !0, A["font-weight"] = !0, A.grid = !1, A["grid-area"] = !1, A["grid-auto-columns"] = !1, A["grid-auto-flow"] = !1, A["grid-auto-rows"] = !1, A["grid-column"] = !1, A["grid-column-end"] = !1, A["grid-column-start"] = !1, A["grid-row"] = !1, A["grid-row-end"] = !1, A["grid-row-start"] = !1, A["grid-template"] = !1, A["grid-template-areas"] = !1, A["grid-template-columns"] = !1, A["grid-template-rows"] = !1, A["hanging-punctuation"] = !1, A.height = !0, A.hyphens = !1, A.icon = !1, A["image-orientation"] = !1, A["image-resolution"] = !1, A["ime-mode"] = !1, A["initial-letters"] = !1, A["inline-box-align"] = !1, A["justify-content"] = !1, A["justify-items"] = !1, A["justify-self"] = !1, A.left = !1, A["letter-spacing"] = !0, A["lighting-color"] = !0, A["line-box-contain"] = !1, A["line-break"] = !1, A["line-grid"] = !1, A["line-height"] = !1, A["line-snap"] = !1, A["line-stacking"] = !1, A["line-stacking-ruby"] = !1, A["line-stacking-shift"] = !1, A["line-stacking-strategy"] = !1, A["list-style"] = !0, A["list-style-image"] = !0, A["list-style-position"] = !0, A["list-style-type"] = !0, A.margin = !0, A["margin-bottom"] = !0, A["margin-left"] = !0, A["margin-right"] = !0, A["margin-top"] = !0, A["marker-offset"] = !1, A["marker-side"] = !1, A.marks = !1, A.mask = !1, A["mask-box"] = !1, A["mask-box-outset"] = !1, A["mask-box-repeat"] = !1, A["mask-box-slice"] = !1, A["mask-box-source"] = !1, A["mask-box-width"] = !1, A["mask-clip"] = !1, A["mask-image"] = !1, A["mask-origin"] = !1, A["mask-position"] = !1, A["mask-repeat"] = !1, A["mask-size"] = !1, A["mask-source-type"] = !1, A["mask-type"] = !1, A["max-height"] = !0, A["max-lines"] = !1, A["max-width"] = !0, A["min-height"] = !0, A["min-width"] = !0, A["move-to"] = !1, A["nav-down"] = !1, A["nav-index"] = !1, A["nav-left"] = !1, A["nav-right"] = !1, A["nav-up"] = !1, A["object-fit"] = !1, A["object-position"] = !1, A.opacity = !1, A.order = !1, A.orphans = !1, A.outline = !1, A["outline-color"] = !1, A["outline-offset"] = !1, A["outline-style"] = !1, A["outline-width"] = !1, A.overflow = !1, A["overflow-wrap"] = !1, A["overflow-x"] = !1, A["overflow-y"] = !1, A.padding = !0, A["padding-bottom"] = !0, A["padding-left"] = !0, A["padding-right"] = !0, A["padding-top"] = !0, A.page = !1, A["page-break-after"] = !1, A["page-break-before"] = !1, A["page-break-inside"] = !1, A["page-policy"] = !1, A.pause = !1, A["pause-after"] = !1, A["pause-before"] = !1, A.perspective = !1, A["perspective-origin"] = !1, A.pitch = !1, A["pitch-range"] = !1, A["play-during"] = !1, A.position = !1, A["presentation-level"] = !1, A.quotes = !1, A["region-fragment"] = !1, A.resize = !1, A.rest = !1, A["rest-after"] = !1, A["rest-before"] = !1, A.richness = !1, A.right = !1, A.rotation = !1, A["rotation-point"] = !1, A["ruby-align"] = !1, A["ruby-merge"] = !1, A["ruby-position"] = !1, A["shape-image-threshold"] = !1, A["shape-outside"] = !1, A["shape-margin"] = !1, A.size = !1, A.speak = !1, A["speak-as"] = !1, A["speak-header"] = !1, A["speak-numeral"] = !1, A["speak-punctuation"] = !1, A["speech-rate"] = !1, A.stress = !1, A["string-set"] = !1, A["tab-size"] = !1, A["table-layout"] = !1, A["text-align"] = !0, A["text-align-last"] = !0, A["text-combine-upright"] = !0, A["text-decoration"] = !0, A["text-decoration-color"] = !0, A["text-decoration-line"] = !0, A["text-decoration-skip"] = !0, A["text-decoration-style"] = !0, A["text-emphasis"] = !0, A["text-emphasis-color"] = !0, A["text-emphasis-position"] = !0, A["text-emphasis-style"] = !0, A["text-height"] = !0, A["text-indent"] = !0, A["text-justify"] = !0, A["text-orientation"] = !0, A["text-overflow"] = !0, A["text-shadow"] = !0, A["text-space-collapse"] = !0, A["text-transform"] = !0, A["text-underline-position"] = !0, A["text-wrap"] = !0, A.top = !1, A.transform = !1, A["transform-origin"] = !1, A["transform-style"] = !1, A.transition = !1, A["transition-delay"] = !1, A["transition-duration"] = !1, A["transition-property"] = !1, A["transition-timing-function"] = !1, A["unicode-bidi"] = !1, A["vertical-align"] = !1, A.visibility = !1, A["voice-balance"] = !1, A["voice-duration"] = !1, A["voice-family"] = !1, A["voice-pitch"] = !1, A["voice-range"] = !1, A["voice-rate"] = !1, A["voice-stress"] = !1, A["voice-volume"] = !1, A.volume = !1, A["white-space"] = !1, A.widows = !1, A.width = !0, A["will-change"] = !1, A["word-break"] = !0, A["word-spacing"] = !0, A["word-wrap"] = !0, A["wrap-flow"] = !1, A["wrap-through"] = !1, A["writing-mode"] = !1, A["z-index"] = !1, A
  }

  function M85(A, Q, B) {}

  function R85(A, Q, B) {}
  var _85 = /javascript\s*\:/img;

  function j85(A, Q) {
    if (_85.test(Q)) return "";
    return Q
  }
  T85.whiteList = o42();
  T85.getDefaultWhiteList = o42;
  T85.onAttr = M85;
  T85.onIgnoreAttr = R85;
  T85.safeAttrValue = j85
})
// @from(Ln 262192, Col 4)
oX0 = U((y$Z, r42) => {
  r42.exports = {
    indexOf: function (A, Q) {
      var B, G;
      if (Array.prototype.indexOf) return A.indexOf(Q);
      for (B = 0, G = A.length; B < G; B++)
        if (A[B] === Q) return B;
      return -1
    },
    forEach: function (A, Q, B) {
      var G, Z;
      if (Array.prototype.forEach) return A.forEach(Q, B);
      for (G = 0, Z = A.length; G < Z; G++) Q.call(B, A[G], G, A)
    },
    trim: function (A) {
      if (String.prototype.trim) return A.trim();
      return A.replace(/(^\s*)|(\s*$)/g, "")
    },
    trimRight: function (A) {
      if (String.prototype.trimRight) return A.trimRight();
      return A.replace(/(\s*$)/g, "")
    }
  }
})
// @from(Ln 262216, Col 4)
t42 = U((v$Z, s42) => {
  var nxA = oX0();

  function k85(A, Q) {
    if (A = nxA.trimRight(A), A[A.length - 1] !== ";") A += ";";
    var B = A.length,
      G = !1,
      Z = 0,
      Y = 0,
      J = "";

    function X() {
      if (!G) {
        var W = nxA.trim(A.slice(Z, Y)),
          K = W.indexOf(":");
        if (K !== -1) {
          var V = nxA.trim(W.slice(0, K)),
            F = nxA.trim(W.slice(K + 1));
          if (V) {
            var H = Q(Z, J.length, V, F, W);
            if (H) J += H + "; "
          }
        }
      }
      Z = Y + 1
    }
    for (; Y < B; Y++) {
      var I = A[Y];
      if (I === "/" && A[Y + 1] === "*") {
        var D = A.indexOf("*/", Y + 2);
        if (D === -1) break;
        Y = D + 1, Z = Y + 1, G = !1
      } else if (I === "(") G = !0;
      else if (I === ")") G = !1;
      else if (I === ";")
        if (G);
        else X();
      else if (I === `
`) X()
    }
    return nxA.trim(J)
  }
  s42.exports = k85
})
// @from(Ln 262260, Col 4)
B62 = U((b$Z, Q62) => {
  var WZ1 = aX0(),
    b85 = t42(),
    k$Z = oX0();

  function e42(A) {
    return A === void 0 || A === null
  }

  function f85(A) {
    var Q = {};
    for (var B in A) Q[B] = A[B];
    return Q
  }

  function A62(A) {
    A = f85(A || {}), A.whiteList = A.whiteList || WZ1.whiteList, A.onAttr = A.onAttr || WZ1.onAttr, A.onIgnoreAttr = A.onIgnoreAttr || WZ1.onIgnoreAttr, A.safeAttrValue = A.safeAttrValue || WZ1.safeAttrValue, this.options = A
  }
  A62.prototype.process = function (A) {
    if (A = A || "", A = A.toString(), !A) return "";
    var Q = this,
      B = Q.options,
      G = B.whiteList,
      Z = B.onAttr,
      Y = B.onIgnoreAttr,
      J = B.safeAttrValue,
      X = b85(A, function (I, D, W, K, V) {
        var F = G[W],
          H = !1;
        if (F === !0) H = F;
        else if (typeof F === "function") H = F(K);
        else if (F instanceof RegExp) H = F.test(K);
        if (H !== !0) H = !1;
        if (K = J(W, K), !K) return;
        var E = {
          position: D,
          sourcePosition: I,
          source: V,
          isWhite: H
        };
        if (H) {
          var z = Z(W, K, E);
          if (e42(z)) return W + ":" + K;
          else return z
        } else {
          var z = Y(W, K, E);
          if (!e42(z)) return z
        }
      });
    return X
  };
  Q62.exports = A62
})
// @from(Ln 262313, Col 4)
FZ1 = U((VZ1, rX0) => {
  var G62 = aX0(),
    Z62 = B62();

  function h85(A, Q) {
    var B = new Z62(Q);
    return B.process(A)
  }
  VZ1 = rX0.exports = h85;
  VZ1.FilterCSS = Z62;
  for (KZ1 in G62) VZ1[KZ1] = G62[KZ1];
  var KZ1;
  if (typeof window < "u") window.filterCSS = rX0.exports
})
// @from(Ln 262327, Col 4)
HZ1 = U((f$Z, Y62) => {
  Y62.exports = {
    indexOf: function (A, Q) {
      var B, G;
      if (Array.prototype.indexOf) return A.indexOf(Q);
      for (B = 0, G = A.length; B < G; B++)
        if (A[B] === Q) return B;
      return -1
    },
    forEach: function (A, Q, B) {
      var G, Z;
      if (Array.prototype.forEach) return A.forEach(Q, B);
      for (G = 0, Z = A.length; G < Z; G++) Q.call(B, A[G], G, A)
    },
    trim: function (A) {
      if (String.prototype.trim) return A.trim();
      return A.replace(/(^\s*)|(\s*$)/g, "")
    },
    spaceIndex: function (A) {
      var Q = /\s|\n|\t/,
        B = Q.exec(A);
      return B ? B.index : -1
    }
  }
})
// @from(Ln 262352, Col 4)
sX0 = U((G55) => {
  var g85 = FZ1().FilterCSS,
    u85 = FZ1().getDefaultWhiteList,
    zZ1 = HZ1();

  function I62() {
    return {
      a: ["target", "href", "title"],
      abbr: ["title"],
      address: [],
      area: ["shape", "coords", "href", "alt"],
      article: [],
      aside: [],
      audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"],
      b: [],
      bdi: ["dir"],
      bdo: ["dir"],
      big: [],
      blockquote: ["cite"],
      br: [],
      caption: [],
      center: [],
      cite: [],
      code: [],
      col: ["align", "valign", "span", "width"],
      colgroup: ["align", "valign", "span", "width"],
      dd: [],
      del: ["datetime"],
      details: ["open"],
      div: [],
      dl: [],
      dt: [],
      em: [],
      figcaption: [],
      figure: [],
      font: ["color", "size", "face"],
      footer: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      header: [],
      hr: [],
      i: [],
      img: ["src", "alt", "title", "width", "height", "loading"],
      ins: ["datetime"],
      kbd: [],
      li: [],
      mark: [],
      nav: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      section: [],
      small: [],
      span: [],
      sub: [],
      summary: [],
      sup: [],
      strong: [],
      strike: [],
      table: ["width", "border", "align", "valign"],
      tbody: ["align", "valign"],
      td: ["width", "rowspan", "colspan", "align", "valign"],
      tfoot: ["align", "valign"],
      th: ["width", "rowspan", "colspan", "align", "valign"],
      thead: ["align", "valign"],
      tr: ["rowspan", "align", "valign"],
      tt: [],
      u: [],
      ul: [],
      video: ["autoplay", "controls", "crossorigin", "loop", "muted", "playsinline", "poster", "preload", "src", "height", "width"]
    }
  }
  var D62 = new g85;

  function m85(A, Q, B) {}

  function d85(A, Q, B) {}

  function c85(A, Q, B) {}

  function p85(A, Q, B) {}

  function W62(A) {
    return A.replace(i85, "&lt;").replace(n85, "&gt;")
  }

  function l85(A, Q, B, G) {
    if (B = z62(B), Q === "href" || Q === "src") {
      if (B = zZ1.trim(B), B === "#") return "#";
      if (!(B.substr(0, 7) === "http://" || B.substr(0, 8) === "https://" || B.substr(0, 7) === "mailto:" || B.substr(0, 4) === "tel:" || B.substr(0, 11) === "data:image/" || B.substr(0, 6) === "ftp://" || B.substr(0, 2) === "./" || B.substr(0, 3) === "../" || B[0] === "#" || B[0] === "/")) return ""
    } else if (Q === "background") {
      if (EZ1.lastIndex = 0, EZ1.test(B)) return ""
    } else if (Q === "style") {
      if (J62.lastIndex = 0, J62.test(B)) return "";
      if (X62.lastIndex = 0, X62.test(B)) {
        if (EZ1.lastIndex = 0, EZ1.test(B)) return ""
      }
      if (G !== !1) G = G || D62, B = G.process(B)
    }
    return B = $62(B), B
  }
  var i85 = /</g,
    n85 = />/g,
    a85 = /"/g,
    o85 = /&quot;/g,
    r85 = /&#([a-zA-Z0-9]*);?/gim,
    s85 = /&colon;?/gim,
    t85 = /&newline;?/gim,
    EZ1 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi,
    J62 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,
    X62 = /u\s*r\s*l\s*\(.*/gi;

  function K62(A) {
    return A.replace(a85, "&quot;")
  }

  function V62(A) {
    return A.replace(o85, '"')
  }

  function F62(A) {
    return A.replace(r85, function (B, G) {
      return G[0] === "x" || G[0] === "X" ? String.fromCharCode(parseInt(G.substr(1), 16)) : String.fromCharCode(parseInt(G, 10))
    })
  }

  function H62(A) {
    return A.replace(s85, ":").replace(t85, " ")
  }

  function E62(A) {
    var Q = "";
    for (var B = 0, G = A.length; B < G; B++) Q += A.charCodeAt(B) < 32 ? " " : A.charAt(B);
    return zZ1.trim(Q)
  }

  function z62(A) {
    return A = V62(A), A = F62(A), A = H62(A), A = E62(A), A
  }

  function $62(A) {
    return A = K62(A), A = W62(A), A
  }

  function e85() {
    return ""
  }

  function A55(A, Q) {
    if (typeof Q !== "function") Q = function () {};
    var B = !Array.isArray(A);

    function G(J) {
      if (B) return !0;
      return zZ1.indexOf(A, J) !== -1
    }
    var Z = [],
      Y = !1;
    return {
      onIgnoreTag: function (J, X, I) {
        if (G(J))
          if (I.isClosing) {
            var D = "[/removed]",
              W = I.position + D.length;
            return Z.push([Y !== !1 ? Y : I.position, W]), Y = !1, D
          } else {
            if (!Y) Y = I.position;
            return "[removed]"
          }
        else return Q(J, X, I)
      },
      remove: function (J) {
        var X = "",
          I = 0;
        return zZ1.forEach(Z, function (D) {
          X += J.slice(I, D[0]), I = D[1]
        }), X += J.slice(I), X
      }
    }
  }

  function Q55(A) {
    var Q = "",
      B = 0;
    while (B < A.length) {
      var G = A.indexOf("<!--", B);
      if (G === -1) {
        Q += A.slice(B);
        break
      }
      Q += A.slice(B, G);
      var Z = A.indexOf("-->", G);
      if (Z === -1) break;
      B = Z + 3
    }
    return Q
  }

  function B55(A) {
    var Q = A.split("");
    return Q = Q.filter(function (B) {
      var G = B.charCodeAt(0);
      if (G === 127) return !1;
      if (G <= 31) {
        if (G === 10 || G === 13) return !0;
        return !1
      }
      return !0
    }), Q.join("")
  }
  G55.whiteList = I62();
  G55.getDefaultWhiteList = I62;
  G55.onTag = m85;
  G55.onIgnoreTag = d85;
  G55.onTagAttr = c85;
  G55.onIgnoreTagAttr = p85;
  G55.safeAttrValue = l85;
  G55.escapeHtml = W62;
  G55.escapeQuote = K62;
  G55.unescapeQuote = V62;
  G55.escapeHtmlEntities = F62;
  G55.escapeDangerHtml5Entities = H62;
  G55.clearNonPrintableCharacter = E62;
  G55.friendlyAttrValue = z62;
  G55.escapeAttrValue = $62;
  G55.onIgnoreTagStripAll = e85;
  G55.StripTagBody = A55;
  G55.stripCommentTag = Q55;
  G55.stripBlankChar = B55;
  G55.attributeWrapSign = '"';
  G55.cssFilter = D62;
  G55.getDefaultCSSWhiteList = u85
})
// @from(Ln 262590, Col 4)
tX0 = U((k55) => {
  var Lr = HZ1();

  function R55(A) {
    var Q = Lr.spaceIndex(A),
      B;
    if (Q === -1) B = A.slice(1, -1);
    else B = A.slice(1, Q + 1);
    if (B = Lr.trim(B).toLowerCase(), B.slice(0, 1) === "/") B = B.slice(1);
    if (B.slice(-1) === "/") B = B.slice(0, -1);
    return B
  }

  function _55(A) {
    return A.slice(0, 2) === "</"
  }

  function j55(A, Q, B) {
    var G = "",
      Z = 0,
      Y = !1,
      J = !1,
      X = 0,
      I = A.length,
      D = "",
      W = "";
    A: for (X = 0; X < I; X++) {
      var K = A.charAt(X);
      if (Y === !1) {
        if (K === "<") {
          Y = X;
          continue
        }
      } else if (J === !1) {
        if (K === "<") {
          G += B(A.slice(Z, X)), Y = X, Z = X;
          continue
        }
        if (K === ">" || X === I - 1) {
          G += B(A.slice(Z, Y)), W = A.slice(Y, X + 1), D = R55(W), G += Q(Y, G.length, D, W, _55(W)), Z = X + 1, Y = !1;
          continue
        }
        if (K === '"' || K === "'") {
          var V = 1,
            F = A.charAt(X - V);
          while (F.trim() === "" || F === "=") {
            if (F === "=") {
              J = K;
              continue A
            }
            F = A.charAt(X - ++V)
          }
        }
      } else if (K === J) {
        J = !1;
        continue
      }
    }
    if (Z < I) G += B(A.substr(Z));
    return G
  }
  var T55 = /[^a-zA-Z0-9\\_:.-]/gim;

  function P55(A, Q) {
    var B = 0,
      G = 0,
      Z = [],
      Y = !1,
      J = A.length;

    function X(V, F) {
      if (V = Lr.trim(V), V = V.replace(T55, "").toLowerCase(), V.length < 1) return;
      var H = Q(V, F || "");
      if (H) Z.push(H)
    }
    for (var I = 0; I < J; I++) {
      var D = A.charAt(I),
        W, K;
      if (Y === !1 && D === "=") {
        Y = A.slice(B, I), B = I + 1, G = A.charAt(B) === '"' || A.charAt(B) === "'" ? B : x55(A, I + 1);
        continue
      }
      if (Y !== !1) {
        if (I === G)
          if (K = A.indexOf(D, I + 1), K === -1) break;
          else {
            W = Lr.trim(A.slice(G + 1, K)), X(Y, W), Y = !1, I = K, B = I + 1;
            continue
          }
      }
      if (/\s|\n|\t/.test(D))
        if (A = A.replace(/\s|\n|\t/g, " "), Y === !1)
          if (K = S55(A, I), K === -1) {
            W = Lr.trim(A.slice(B, I)), X(W), Y = !1, B = I + 1;
            continue
          } else {
            I = K - 1;
            continue
          }
      else if (K = y55(A, I - 1), K === -1) {
        W = Lr.trim(A.slice(B, I)), W = C62(W), X(Y, W), Y = !1, B = I + 1;
        continue
      } else continue
    }
    if (B < A.length)
      if (Y === !1) X(A.slice(B));
      else X(Y, C62(Lr.trim(A.slice(B))));
    return Lr.trim(Z.join(" "))
  }

  function S55(A, Q) {
    for (; Q < A.length; Q++) {
      var B = A[Q];
      if (B === " ") continue;
      if (B === "=") return Q;
      return -1
    }
  }

  function x55(A, Q) {
    for (; Q < A.length; Q++) {
      var B = A[Q];
      if (B === " ") continue;
      if (B === "'" || B === '"') return Q;
      return -1
    }
  }

  function y55(A, Q) {
    for (; Q > 0; Q--) {
      var B = A[Q];
      if (B === " ") continue;
      if (B === "=") return Q;
      return -1
    }
  }

  function v55(A) {
    if (A[0] === '"' && A[A.length - 1] === '"' || A[0] === "'" && A[A.length - 1] === "'") return !0;
    else return !1
  }

  function C62(A) {
    if (v55(A)) return A.substr(1, A.length - 2);
    else return A
  }
  k55.parseTag = j55;
  k55.parseAttr = P55
})
// @from(Ln 262739, Col 4)
w62 = U((u$Z, N62) => {
  var h55 = FZ1().FilterCSS,
    k_ = sX0(),
    U62 = tX0(),
    g55 = U62.parseTag,
    u55 = U62.parseAttr,
    CZ1 = HZ1();

  function $Z1(A) {
    return A === void 0 || A === null
  }

  function m55(A) {
    var Q = CZ1.spaceIndex(A);
    if (Q === -1) return {
      html: "",
      closing: A[A.length - 2] === "/"
    };
    A = CZ1.trim(A.slice(Q + 1, -1));
    var B = A[A.length - 1] === "/";
    if (B) A = CZ1.trim(A.slice(0, -1));
    return {
      html: A,
      closing: B
    }
  }

  function d55(A) {
    var Q = {};
    for (var B in A) Q[B] = A[B];
    return Q
  }

  function c55(A) {
    var Q = {};
    for (var B in A)
      if (Array.isArray(A[B])) Q[B.toLowerCase()] = A[B].map(function (G) {
        return G.toLowerCase()
      });
      else Q[B.toLowerCase()] = A[B];
    return Q
  }

  function q62(A) {
    if (A = d55(A || {}), A.stripIgnoreTag) {
      if (A.onIgnoreTag) console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time');
      A.onIgnoreTag = k_.onIgnoreTagStripAll
    }
    if (A.whiteList || A.allowList) A.whiteList = c55(A.whiteList || A.allowList);
    else A.whiteList = k_.whiteList;
    if (this.attributeWrapSign = A.singleQuotedAttributeValue === !0 ? "'" : k_.attributeWrapSign, A.onTag = A.onTag || k_.onTag, A.onTagAttr = A.onTagAttr || k_.onTagAttr, A.onIgnoreTag = A.onIgnoreTag || k_.onIgnoreTag, A.onIgnoreTagAttr = A.onIgnoreTagAttr || k_.onIgnoreTagAttr, A.safeAttrValue = A.safeAttrValue || k_.safeAttrValue, A.escapeHtml = A.escapeHtml || k_.escapeHtml, this.options = A, A.css === !1) this.cssFilter = !1;
    else A.css = A.css || {}, this.cssFilter = new h55(A.css)
  }
  q62.prototype.process = function (A) {
    if (A = A || "", A = A.toString(), !A) return "";
    var Q = this,
      B = Q.options,
      G = B.whiteList,
      Z = B.onTag,
      Y = B.onIgnoreTag,
      J = B.onTagAttr,
      X = B.onIgnoreTagAttr,
      I = B.safeAttrValue,
      D = B.escapeHtml,
      W = Q.attributeWrapSign,
      K = Q.cssFilter;
    if (B.stripBlankChar) A = k_.stripBlankChar(A);
    if (!B.allowCommentTag) A = k_.stripCommentTag(A);
    var V = !1;
    if (B.stripIgnoreTagBody) V = k_.StripTagBody(B.stripIgnoreTagBody, Y), Y = V.onIgnoreTag;
    var F = g55(A, function (H, E, z, $, O) {
      var L = {
          sourcePosition: H,
          position: E,
          isClosing: O,
          isWhite: Object.prototype.hasOwnProperty.call(G, z)
        },
        M = Z(z, $, L);
      if (!$Z1(M)) return M;
      if (L.isWhite) {
        if (L.isClosing) return "</" + z + ">";
        var _ = m55($),
          j = G[z],
          x = u55(_.html, function (b, S) {
            var u = CZ1.indexOf(j, b) !== -1,
              f = J(z, b, S, u);
            if (!$Z1(f)) return f;
            if (u)
              if (S = I(z, b, S, K), S) return b + "=" + W + S + W;
              else return b;
            else {
              if (f = X(z, b, S, u), !$Z1(f)) return f;
              return
            }
          });
        if ($ = "<" + z, x) $ += " " + x;
        if (_.closing) $ += " /";
        return $ += ">", $
      } else {
        if (M = Y(z, $, L), !$Z1(M)) return M;
        return D($)
      }
    }, D);
    if (V) F = V.remove(F);
    return F
  };
  N62.exports = q62
})
// @from(Ln 262847, Col 4)
_62 = U((AVA, UZ1) => {
  var L62 = sX0(),
    O62 = tX0(),
    M62 = w62();

  function R62(A, Q) {
    var B = new M62(Q);
    return B.process(A)
  }
  AVA = UZ1.exports = R62;
  AVA.filterXSS = R62;
  AVA.FilterXSS = M62;
  (function () {
    for (var A in L62) AVA[A] = L62[A];
    for (var Q in O62) AVA[Q] = O62[Q]
  })();
  if (typeof window < "u") window.filterXSS = UZ1.exports;

  function p55() {
    return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope
  }
  if (p55()) self.filterXSS = UZ1.exports
})
// @from(Ln 262881, Col 0)
function j62(A) {
  try {
    let Q = new URL(A);
    for (let B of o55)
      if (Q.searchParams.has(B)) Q.searchParams.set(B, "[REDACTED]");
    return Q.toString()
  } catch {
    return A
  }
}
// @from(Ln 262892, Col 0)
function r55() {
  return async (A, Q) => {
    let B = AbortSignal.timeout(a55);
    if (!Q?.signal) return fetch(A, {
      ...Q,
      signal: B
    });
    let G = new AbortController,
      Z = () => G.abort();
    Q.signal.addEventListener("abort", Z), B.addEventListener("abort", Z);
    let Y = () => {
      Q.signal?.removeEventListener("abort", Z), B.removeEventListener("abort", Z)
    };
    if (Q.signal.aborted) G.abort();
    try {
      let J = await fetch(A, {
        ...Q,
        signal: G.signal
      });
      return Y(), J
    } catch (J) {
      throw Y(), J
    }
  }
}
// @from(Ln 262918, Col 0)
function P62(A = QI0) {
  return `http://localhost:${A}/callback`
}
// @from(Ln 262922, Col 0)
function t55() {
  let A = parseInt(process.env.MCP_OAUTH_CALLBACK_PORT || "", 10);
  return A > 0 ? A : void 0
}
// @from(Ln 262926, Col 0)
async function e55() {
  let A = t55();
  if (A) return A;
  let {
    min: Q,
    max: B
  } = s55, G = B - Q + 1, Z = Math.min(G, 100);
  for (let Y = 0; Y < Z; Y++) {
    let J = Q + Math.floor(Math.random() * G);
    try {
      return await new Promise((X, I) => {
        let D = eX0();
        D.once("error", I), D.listen(J, () => {
          D.close(() => X())
        })
      }), J
    } catch {
      continue
    }
  }
  try {
    return await new Promise((Y, J) => {
      let X = eX0();
      X.once("error", J), X.listen(QI0, () => {
        X.close(() => Y())
      })
    }), QI0
  } catch {
    throw Error("No available ports for OAuth redirect")
  }
}
// @from(Ln 262958, Col 0)
function J4A(A, Q) {
  let B = eA({
      type: Q.type,
      url: Q.url,
      headers: Q.headers || {}
    }),
    G = i55("sha256").update(B).digest("hex").substring(0, 16);
  return `${A}|${G}`
}
// @from(Ln 262967, Col 0)
async function T62({
  serverName: A,
  endpoint: Q,
  token: B,
  tokenTypeHint: G,
  clientId: Z,
  accessToken: Y
}) {
  let J = new URLSearchParams;
  if (J.set("token", B), J.set("token_type_hint", G), Z) J.set("client_id", Z);
  else i0(A, `No client_id available for ${G} revocation - server may reject`);
  let X = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  try {
    await xQ.post(Q, J, {
      headers: X
    }), i0(A, `Successfully revoked ${G}`)
  } catch (I) {
    if (xQ.isAxiosError(I) && I.response?.status === 401 && Y) i0(A, `Got 401, retrying ${G} revocation with Bearer auth`), await xQ.post(Q, J, {
      headers: {
        ...X,
        Authorization: `Bearer ${Y}`
      }
    }), i0(A, `Successfully revoked ${G} with Bearer auth`);
    else throw I
  }
}
// @from(Ln 262995, Col 0)
async function GI0(A, Q) {
  let G = ZL().read();
  if (!G?.mcpOAuth) return;
  let Z = J4A(A, Q),
    Y = G.mcpOAuth[Z];
  if (!Y?.accessToken && !Y?.refreshToken) {
    i0(A, "No tokens to revoke");
    return
  }
  try {
    let J = await pxA(Q.url);
    if (!J) {
      i0(A, "No OAuth metadata found");
      return
    }
    let X = "revocation_endpoint" in J ? J.revocation_endpoint : null;
    if (!X) {
      i0(A, "Server does not support token revocation");
      return
    }
    let I = String(X);
    if (i0(A, `Revoking tokens via ${I}`), Y.refreshToken) try {
      await T62({
        serverName: A,
        endpoint: I,
        token: Y.refreshToken,
        tokenTypeHint: "refresh_token",
        clientId: Y.clientId,
        accessToken: Y.accessToken
      })
    } catch (D) {
      i0(A, `Failed to revoke refresh token: ${D instanceof Error?D.message:String(D)}`)
    }
    if (Y.accessToken) try {
      await T62({
        serverName: A,
        endpoint: X,
        token: Y.accessToken,
        tokenTypeHint: "access_token",
        clientId: Y.clientId,
        accessToken: Y.accessToken
      })
    } catch (D) {
      i0(A, `Failed to revoke access token: ${D instanceof Error?D.message:String(D)}`)
    }
  } catch (J) {
    i0(A, `Failed to revoke tokens: ${J instanceof Error?J.message:String(J)}`)
  }
  S62(A, Q)
}
// @from(Ln 263046, Col 0)
function S62(A, Q) {
  let B = ZL(),
    G = B.read();
  if (!G?.mcpOAuth) return;
  let Z = J4A(A, Q);
  if (G.mcpOAuth[Z]) delete G.mcpOAuth[Z], B.update(G), i0(A, "Cleared stored tokens")
}
// @from(Ln 263053, Col 0)
async function axA(A, Q, B, G) {
  S62(A, Q), l("tengu_mcp_oauth_flow_start", {
    isOAuthFlow: !0
  });
  let Z = await e55(),
    Y = P62(Z);
  i0(A, `Using redirect port: ${Z}`);
  let J = new I4A(A, Q, Y, !0, B);
  try {
    let V = await pxA(Q.url);
    if (V) J.setMetadata(V), i0(A, `Fetched OAuth metadata with scope: ${BI0(V)||"NONE"}`)
  } catch (V) {
    i0(A, `Failed to fetch OAuth metadata: ${V instanceof Error?V.message:String(V)}`)
  }
  let X = await J.state(),
    I = null,
    D = null,
    W = () => {
      if (I) I.close(), I = null;
      if (D) clearTimeout(D), D = null;
      i0(A, "MCP OAuth server cleaned up")
    },
    K = await new Promise((V, F) => {
      if (G) {
        let H = () => {
          W(), F(new X4A)
        };
        if (G.aborted) {
          H();
          return
        }
        G.addEventListener("abort", H)
      }
      I = eX0((H, E) => {
        let z = l55(H.url || "", !0);
        if (z.pathname === "/callback") {
          let $ = z.query.code,
            O = z.query.state,
            L = z.query.error,
            M = z.query.error_description,
            _ = z.query.error_uri;
          if (!L && O !== X) {
            E.writeHead(400, {
              "Content-Type": "text/html"
            }), E.end("<h1>Authentication Error</h1><p>Invalid state parameter. Please try again.</p><p>You can close this window.</p>"), W(), F(Error("OAuth state mismatch - possible CSRF attack"));
            return
          }
          if (L) {
            E.writeHead(200, {
              "Content-Type": "text/html"
            });
            let j = AI0.default(String(L)),
              x = M ? AI0.default(String(M)) : "";
            E.end(`<h1>Authentication Error</h1><p>${j}: ${x}</p><p>You can close this window.</p>`), W();
            let b = `OAuth error: ${L}`;
            if (M) b += ` - ${M}`;
            if (_) b += ` (See: ${_})`;
            F(Error(b));
            return
          }
          if ($) E.writeHead(200, {
            "Content-Type": "text/html"
          }), E.end("<h1>Authentication Successful</h1><p>You can close this window. Return to Claude Code.</p>"), W(), V($)
        }
      }), I.listen(Z, async () => {
        try {
          i0(A, "Starting SDK auth"), i0(A, `Server URL: ${Q.url}`);
          let H = await v_(J, {
            serverUrl: Q.url
          });
          if (i0(A, `Initial auth result: ${H}`), H !== "REDIRECT") i0(A, `Unexpected auth result, expected REDIRECT: ${H}`)
        } catch (H) {
          i0(A, `SDK auth error: ${H}`), W(), F(H)
        }
      }), D = setTimeout(() => {
        W(), F(Error("Authentication timeout"))
      }, 300000)
    });
  try {
    i0(A, "Completing auth flow with authorization code");
    let V = await v_(J, {
      serverUrl: Q.url,
      authorizationCode: K
    });
    if (i0(A, `Auth result: ${V}`), V === "AUTHORIZED") {
      let F = await J.tokens();
      if (i0(A, `Tokens after auth: ${F?"Present":"Missing"}`), F) i0(A, `Token access_token length: ${F.access_token?.length}`), i0(A, `Token expires_in: ${F.expires_in}`);
      l("tengu_mcp_oauth_flow_success", {})
    } else throw Error("Unexpected auth result: " + V)
  } catch (V) {
    if (i0(A, `Error during auth completion: ${V}`), xQ.isAxiosError(V)) try {
      let F = bG1.parse(V.response?.data);
      if (F.error === "invalid_client" && F.error_description?.includes("Client not found")) {
        let H = ZL(),
          E = H.read() || {},
          z = J4A(A, Q);
        if (E.mcpOAuth?.[z]) delete E.mcpOAuth[z].clientId, delete E.mcpOAuth[z].clientSecret, H.update(E)
      }
    } catch {}
    throw l("tengu_mcp_oauth_flow_error", {}), V
  }
}
// @from(Ln 263155, Col 0)
class I4A {
  serverName;
  serverConfig;
  redirectUri;
  handleRedirection;
  _codeVerifier;
  _authorizationUrl;
  _state;
  _scopes;
  _metadata;
  _refreshInProgress;
  onAuthorizationUrlCallback;
  constructor(A, Q, B = P62(), G = !1, Z) {
    this.serverName = A, this.serverConfig = Q, this.redirectUri = B, this.handleRedirection = G, this.onAuthorizationUrlCallback = Z
  }
  get redirectUrl() {
    return this.redirectUri
  }
  get authorizationUrl() {
    return this._authorizationUrl
  }
  get clientMetadata() {
    let A = {
        client_name: `Claude Code (${this.serverName})`,
        redirect_uris: [this.redirectUri],
        grant_types: ["authorization_code", "refresh_token"],
        response_types: ["code"],
        token_endpoint_auth_method: "none"
      },
      Q = BI0(this._metadata);
    if (Q) A.scope = Q, i0(this.serverName, `Using scope from metadata: ${A.scope}`);
    return A
  }
  setMetadata(A) {
    this._metadata = A
  }
  async state() {
    if (!this._state) this._state = n55(32).toString("base64url"), i0(this.serverName, "Generated new OAuth state");
    return this._state
  }
  async clientInformation() {
    let Q = ZL().read(),
      B = J4A(this.serverName, this.serverConfig),
      G = Q?.mcpOAuth?.[B];
    if (G?.clientId) return i0(this.serverName, "Found client info"), {
      client_id: G.clientId,
      client_secret: G.clientSecret
    };
    i0(this.serverName, "No client info found");
    return
  }
  async saveClientInformation(A) {
    let Q = ZL(),
      B = Q.read() || {},
      G = J4A(this.serverName, this.serverConfig),
      Z = {
        ...B,
        mcpOAuth: {
          ...B.mcpOAuth,
          [G]: {
            ...B.mcpOAuth?.[G],
            serverName: this.serverName,
            serverUrl: this.serverConfig.url,
            clientId: A.client_id,
            clientSecret: A.client_secret,
            accessToken: B.mcpOAuth?.[G]?.accessToken || "",
            expiresAt: B.mcpOAuth?.[G]?.expiresAt || 0
          }
        }
      };
    Q.update(Z)
  }
  async tokens() {
    let Q = ZL().read(),
      B = J4A(this.serverName, this.serverConfig),
      G = Q?.mcpOAuth?.[B];
    if (!G) {
      i0(this.serverName, "No token data found");
      return
    }
    let Z = (G.expiresAt - Date.now()) / 1000;
    if (Z <= 0 && !G.refreshToken) {
      i0(this.serverName, "Token expired without refresh token");
      return
    }
    if (Z <= 300 && G.refreshToken) {
      if (!this._refreshInProgress) i0(this.serverName, `Token expires in ${Math.floor(Z)}s, attempting proactive refresh`), this._refreshInProgress = this.refreshAuthorization(G.refreshToken).finally(() => {
        this._refreshInProgress = void 0
      });
      else i0(this.serverName, "Token refresh already in progress, reusing existing promise");
      try {
        let J = await this._refreshInProgress;
        if (J) return i0(this.serverName, "Token refreshed successfully"), J;
        i0(this.serverName, "Token refresh failed, returning current tokens")
      } catch (J) {
        i0(this.serverName, `Token refresh error: ${J instanceof Error?J.message:String(J)}`)
      }
    }
    let Y = {
      access_token: G.accessToken,
      refresh_token: G.refreshToken,
      expires_in: Z,
      scope: G.scope,
      token_type: "Bearer"
    };
    return i0(this.serverName, "Returning tokens"), i0(this.serverName, `Token length: ${Y.access_token?.length}`), i0(this.serverName, `Has refresh token: ${!!Y.refresh_token}`), i0(this.serverName, `Expires in: ${Math.floor(Z)}s`), Y
  }
  async saveTokens(A) {
    let Q = ZL(),
      B = Q.read() || {},
      G = J4A(this.serverName, this.serverConfig);
    i0(this.serverName, "Saving tokens"), i0(this.serverName, `Token expires in: ${A.expires_in}`), i0(this.serverName, `Has refresh token: ${!!A.refresh_token}`);
    let Z = {
      ...B,
      mcpOAuth: {
        ...B.mcpOAuth,
        [G]: {
          ...B.mcpOAuth?.[G],
          serverName: this.serverName,
          serverUrl: this.serverConfig.url,
          accessToken: A.access_token,
          refreshToken: A.refresh_token,
          expiresAt: Date.now() + (A.expires_in || 3600) * 1000,
          scope: A.scope
        }
      }
    };
    Q.update(Z)
  }
  async redirectToAuthorization(A) {
    this._authorizationUrl = A.toString();
    let Q = A.searchParams.get("scope");
    if (i0(this.serverName, `Authorization URL: ${j62(A.toString())}`), i0(this.serverName, `Scopes in URL: ${Q||"NOT FOUND"}`), Q) this._scopes = Q, i0(this.serverName, `Captured scopes from authorization URL: ${Q}`);
    else {
      let Y = BI0(this._metadata);
      if (Y) this._scopes = Y, i0(this.serverName, `Using scopes from metadata: ${Y}`);
      else i0(this.serverName, "No scopes available from URL or metadata")
    }
    if (!this.handleRedirection) {
      i0(this.serverName, "Redirection handling is disabled, skipping redirect");
      return
    }
    let B = A.toString();
    if (!B.startsWith("http://") && !B.startsWith("https://")) throw Error("Invalid authorization URL: must use http:// or https:// scheme");
    i0(this.serverName, "Redirecting to authorization URL");
    let G = j62(B);
    if (i0(this.serverName, `Authorization URL: ${G}`), this.onAuthorizationUrlCallback) this.onAuthorizationUrlCallback(B);
    if (i0(this.serverName, `Opening authorization URL: ${G}`), !await i7(B)) i0(this.serverName, "Browser didn't open automatically. URL is shown in UI.")
  }
  async saveCodeVerifier(A) {
    i0(this.serverName, "Saving code verifier"), this._codeVerifier = A
  }
  async codeVerifier() {
    if (!this._codeVerifier) throw i0(this.serverName, "No code verifier saved"), Error("No code verifier saved");
    return i0(this.serverName, "Returning code verifier"), this._codeVerifier
  }
  async refreshAuthorization(A) {
    try {
      i0(this.serverName, "Starting token refresh");
      let Q = r55(),
        B = await pxA(new URL(this.serverConfig.url), {
          fetchFn: Q
        });
      if (!B) {
        i0(this.serverName, "Failed to discover OAuth metadata");
        return
      }
      let G = await this.clientInformation();
      if (!G) {
        i0(this.serverName, "No client information available for refresh");
        return
      }
      let Z = await yX0(new URL(this.serverConfig.url), {
        metadata: B,
        clientInformation: G,
        refreshToken: A,
        resource: new URL(this.serverConfig.url),
        fetchFn: Q
      });
      if (Z) return i0(this.serverName, "Token refresh successful, saving new tokens"), await this.saveTokens(Z), Z;
      i0(this.serverName, "Token refresh returned no tokens");
      return
    } catch (Q) {
      i0(this.serverName, `Token refresh failed: ${Q instanceof Error?Q.message:String(Q)}`);
      return
    }
  }
}
// @from(Ln 263344, Col 0)
function BI0(A) {
  if (!A) return;
  if ("scope" in A && typeof A.scope === "string") return A.scope;
  if ("default_scope" in A && typeof A.default_scope === "string") return A.default_scope;
  if (A.scopes_supported && Array.isArray(A.scopes_supported)) return A.scopes_supported.join(" ");
  return
}
// @from(Ln 263351, Col 4)
AI0
// @from(Ln 263351, Col 9)
a55 = 30000
// @from(Ln 263352, Col 2)
o55
// @from(Ln 263352, Col 7)
X4A
// @from(Ln 263352, Col 12)
s55
// @from(Ln 263352, Col 17)
QI0 = 3118
// @from(Ln 263353, Col 4)
QVA = w(() => {
  lnA();
  Z0();
  fG1();
  lxA();
  TN();
  j5();
  v1();
  c3();
  A0();
  AI0 = c(_62(), 1), o55 = ["state", "nonce", "code_challenge", "code_verifier", "code"];
  X4A = class X4A extends Error {
    constructor() {
      super("Authentication was cancelled");
      this.name = "AuthenticationCancelledError"
    }
  };
  s55 = $Q() === "windows" ? {
    min: 39152,
    max: 49151
  } : {
    min: 49152,
    max: 65535
  }
})
// @from(Ln 263379, Col 0)
function BVA(A) {
  let Q = [];
  return {
    expanded: A.replace(/\$\{([^}]+)\}/g, (G, Z) => {
      let [Y, J] = Z.split(":-", 2), X = process.env[Y];
      if (X !== void 0) return X;
      if (J !== void 0) return J;
      return Q.push(Y), G
    }),
    missingVars: Q
  }
}
// @from(Ln 263391, Col 4)
ZI0
// @from(Ln 263391, Col 9)
BCZ
// @from(Ln 263391, Col 14)
YI0
// @from(Ln 263391, Col 19)
A75
// @from(Ln 263391, Col 24)
Q75
// @from(Ln 263391, Col 29)
B75
// @from(Ln 263391, Col 34)
G75
// @from(Ln 263391, Col 39)
Z75
// @from(Ln 263391, Col 44)
Y75
// @from(Ln 263391, Col 49)
J75
// @from(Ln 263391, Col 54)
Rb
// @from(Ln 263391, Col 58)
x62
// @from(Ln 263392, Col 4)
D4A = w(() => {
  j9();
  ZI0 = m.enum(["local", "user", "project", "dynamic", "enterprise", "claudeai", "managed"]), BCZ = m.enum(["stdio", "sse", "sse-ide", "http", "ws", "sdk"]), YI0 = m.object({
    type: m.literal("stdio").optional(),
    command: m.string().min(1, "Command cannot be empty"),
    args: m.array(m.string()).default([]),
    env: m.record(m.string(), m.string()).optional()
  }), A75 = m.object({
    type: m.literal("sse"),
    url: m.string(),
    headers: m.record(m.string(), m.string()).optional(),
    headersHelper: m.string().optional()
  }), Q75 = m.object({
    type: m.literal("sse-ide"),
    url: m.string(),
    ideName: m.string(),
    ideRunningInWindows: m.boolean().optional()
  }), B75 = m.object({
    type: m.literal("ws-ide"),
    url: m.string(),
    ideName: m.string(),
    authToken: m.string().optional(),
    ideRunningInWindows: m.boolean().optional()
  }), G75 = m.object({
    type: m.literal("http"),
    url: m.string(),
    headers: m.record(m.string(), m.string()).optional(),
    headersHelper: m.string().optional()
  }), Z75 = m.object({
    type: m.literal("ws"),
    url: m.string(),
    headers: m.record(m.string(), m.string()).optional(),
    headersHelper: m.string().optional()
  }), Y75 = m.object({
    type: m.literal("sdk"),
    name: m.string()
  }), J75 = m.object({
    type: m.literal("claudeai-proxy"),
    url: m.string(),
    id: m.string()
  }), Rb = m.union([YI0, A75, Q75, B75, G75, Z75, Y75, J75]), x62 = m.object({
    mcpServers: m.record(m.string(), Rb)
  })
})
// @from(Ln 263436, Col 4)
_b
// @from(Ln 263437, Col 4)
y62 = w(() => {
  _b = ["PreToolUse", "PostToolUse", "PostToolUseFailure", "Notification", "UserPromptSubmit", "SessionStart", "SessionEnd", "Stop", "SubagentStart", "SubagentStop", "PreCompact", "PermissionRequest"]
})
// @from(Ln 263440, Col 4)
GVA = w(() => {
  y62()
})
// @from(Ln 263444, Col 0)
function v62(A) {
  return JI0.filePatternTools.includes(A)
}
// @from(Ln 263448, Col 0)
function k62(A) {
  return JI0.bashPrefixTools.includes(A)
}
// @from(Ln 263452, Col 0)
function b62(A) {
  return JI0.customValidation[A]
}
// @from(Ln 263455, Col 4)
JI0
// @from(Ln 263456, Col 4)
f62 = w(() => {
  JI0 = {
    filePatternTools: ["Read", "Write", "Edit", "Glob", "NotebookRead", "NotebookEdit"],
    bashPrefixTools: ["Bash"],
    customValidation: {
      WebSearch: (A) => {
        if (A.includes("*") || A.includes("?")) return {
          valid: !1,
          error: "WebSearch does not support wildcards",
          suggestion: "Use exact search terms without * or ?",
          examples: ["WebSearch(claude ai)", "WebSearch(typescript tutorial)"]
        };
        return {
          valid: !0
        }
      },
      WebFetch: (A) => {
        if (A.includes("://") || A.startsWith("http")) return {
          valid: !1,
          error: "WebFetch permissions use domain format, not URLs",
          suggestion: 'Use "domain:hostname" format',
          examples: ["WebFetch(domain:example.com)", "WebFetch(domain:github.com)"]
        };
        if (!A.startsWith("domain:")) return {
          valid: !1,
          error: 'WebFetch permissions must use "domain:" prefix',
          suggestion: 'Use "domain:hostname" format',
          examples: ["WebFetch(domain:example.com)", "WebFetch(domain:*.google.com)"]
        };
        return {
          valid: !0
        }
      }
    }
  }
})
// @from(Ln 263493, Col 0)
function g62(A, Q) {
  let B = 0,
    G = Q - 1;
  while (G >= 0 && A[G] === "\\") B++, G--;
  return B % 2 !== 0
}
// @from(Ln 263500, Col 0)
function h62(A, Q) {
  let B = 0;
  for (let G = 0; G < A.length; G++)
    if (A[G] === Q && !g62(A, G)) B++;
  return B
}
// @from(Ln 263507, Col 0)
function X75(A) {
  for (let Q = 0; Q < A.length - 1; Q++)
    if (A[Q] === "(" && A[Q + 1] === ")") {
      if (!g62(A, Q)) return !0
    } return !1
}
// @from(Ln 263514, Col 0)
function I75(A) {
  if (!A || A.trim() === "") return {
    valid: !1,
    error: "Permission rule cannot be empty"
  };
  let Q = h62(A, "("),
    B = h62(A, ")");
  if (Q !== B) return {
    valid: !1,
    error: "Mismatched parentheses",
    suggestion: "Ensure all opening parentheses have matching closing parentheses"
  };
  if (X75(A)) {
    let J = A.substring(0, A.indexOf("("));
    if (!J) return {
      valid: !1,
      error: "Empty parentheses with no tool name",
      suggestion: "Specify a tool name before the parentheses"
    };
    return {
      valid: !1,
      error: "Empty parentheses",
      suggestion: `Either specify a pattern or use just "${J}" without parentheses`,
      examples: [`${J}`, `${J}(some-pattern)`]
    }
  }
  let G = mR(A),
    Z = qF(G.toolName);
  if (Z) {
    if (G.ruleContent !== void 0) return {
      valid: !1,
      error: "MCP rules do not support patterns in parentheses",
      suggestion: `Use "${G.toolName}" without parentheses, or use "mcp__${Z.serverName}__*" for all tools`,
      examples: [`mcp__${Z.serverName}`, `mcp__${Z.serverName}__*`, Z.toolName && Z.toolName !== "*" ? `mcp__${Z.serverName}__${Z.toolName}` : void 0].filter(Boolean)
    };
    return {
      valid: !0
    }
  }
  if (!G.toolName || G.toolName.length === 0) return {
    valid: !1,
    error: "Tool name cannot be empty"
  };
  if (G.toolName[0] !== G.toolName[0]?.toUpperCase()) return {
    valid: !1,
    error: "Tool names must start with uppercase",
    suggestion: `Use "${String(G.toolName).charAt(0).toUpperCase()+String(G.toolName).slice(1)}"`
  };
  let Y = b62(G.toolName);
  if (Y && G.ruleContent !== void 0) {
    let J = Y(G.ruleContent);
    if (!J.valid) return J
  }
  if (k62(G.toolName) && G.ruleContent !== void 0) {
    let J = G.ruleContent;
    if (J.includes(":*") && !J.endsWith(":*")) return {
      valid: !1,
      error: "The :* pattern must be at the end",
      suggestion: "Move :* to the end for prefix matching, or use * for wildcard matching",
      examples: ["Bash(npm run:*) - prefix matching (legacy)", "Bash(npm run *) - wildcard matching"]
    };
    if (J === ":*") return {
      valid: !1,
      error: "Prefix cannot be empty before :*",
      suggestion: "Specify a command prefix before :*",
      examples: ["Bash(npm:*)", "Bash(git:*)"]
    };
    if (J === "*") return {
      valid: !1,
      error: 'Use "Bash" without parentheses to allow all commands',
      suggestion: "Remove the parentheses or specify a command pattern",
      examples: ["Bash", "Bash(npm:*)", "Bash(npm *)"]
    }
  }
  if (v62(G.toolName) && G.ruleContent !== void 0) {
    let J = G.ruleContent;
    if (J.includes(":*")) return {
      valid: !1,
      error: 'The ":*" syntax is only for Bash prefix rules',
      suggestion: 'Use glob patterns like "*" or "**" for file matching',
      examples: [`${G.toolName}(*.ts) - matches .ts files`, `${G.toolName}(src/**) - matches all files in src`, `${G.toolName}(**/*.test.ts) - matches test files`]
    };
    if (J.includes("*") && !J.match(/^\*|\*$|\*\*|\/\*|\*\.|\*\)/) && !J.includes("**")) return {
      valid: !1,
      error: "Wildcard placement might be incorrect",
      suggestion: "Wildcards are typically used at path boundaries",
      examples: [`${G.toolName}(*.js) - all .js files`, `${G.toolName}(src/*) - all files directly in src`, `${G.toolName}(src/**) - all files recursively in src`]
    }
  }
  return {
    valid: !0
  }
}
// @from(Ln 263607, Col 4)
qZ1
// @from(Ln 263608, Col 4)
u62 = w(() => {
  j9();
  YZ();
  PJ();
  f62();
  qZ1 = m.string().superRefine((A, Q) => {
    let B = I75(A);
    if (!B.valid) {
      let G = B.error;
      if (B.suggestion) G += `. ${B.suggestion}`;
      if (B.examples && B.examples.length > 0) G += `. Examples: ${B.examples.join(", ")}`;
      Q.addIssue({
        code: m.ZodIssueCode.custom,
        message: G,
        params: {
          received: A
        }
      })
    }
  })
})
// @from(Ln 263630, Col 0)
function oxA(A, Q) {
  return Q.autoUpdate ?? K4A.has(A.toLowerCase())
}
// @from(Ln 263634, Col 0)
function K75(A) {
  if (K4A.has(A.toLowerCase())) return !1;
  if (W75.test(A)) return !0;
  return D75.test(A)
}
// @from(Ln 263640, Col 0)
function c62(A, Q) {
  let B = A.toLowerCase();
  if (!K4A.has(B)) return null;
  if (Q.source === "github") {
    if (!(Q.repo || "").toLowerCase().startsWith(`${NZ1}/`)) return `The name '${A}' is reserved for official Anthropic marketplaces. Only repositories from 'github.com/${NZ1}/' can use this name.`;
    return null
  }
  if (Q.source === "git" && Q.url) {
    let G = Q.url.toLowerCase(),
      Z = G.includes("github.com/anthropics/"),
      Y = G.includes("git@github.com:anthropics/");
    if (Z || Y) return null;
    return `The name '${A}' is reserved for official Anthropic marketplaces. Only repositories from 'github.com/${NZ1}/' can use this name.`
  }
  return `The name '${A}' is reserved for official Anthropic marketplaces and can only be used with GitHub sources from the '${NZ1}' organization.`
}
// @from(Ln 263657, Col 0)
function Tb(A) {
  return typeof A === "string" && A.startsWith("./")
}
// @from(Ln 263660, Col 4)
K4A
// @from(Ln 263660, Col 9)
D75
// @from(Ln 263660, Col 14)
W75
// @from(Ln 263660, Col 19)
NZ1 = "anthropics"
// @from(Ln 263661, Col 2)
Nd
// @from(Ln 263661, Col 6)
ZVA
// @from(Ln 263661, Col 11)
m62
// @from(Ln 263661, Col 16)
XI0
// @from(Ln 263661, Col 21)
II0
// @from(Ln 263661, Col 26)
p62
// @from(Ln 263661, Col 31)
V75
// @from(Ln 263661, Col 36)
l62
// @from(Ln 263661, Col 41)
F75
// @from(Ln 263661, Col 46)
H75
// @from(Ln 263661, Col 51)
E75
// @from(Ln 263661, Col 56)
z75
// @from(Ln 263661, Col 61)
$75
// @from(Ln 263661, Col 66)
C75
// @from(Ln 263661, Col 71)
U75
// @from(Ln 263661, Col 76)
d62
// @from(Ln 263661, Col 81)
q75
// @from(Ln 263661, Col 86)
YVA
// @from(Ln 263661, Col 91)
N75
// @from(Ln 263661, Col 96)
V4A
// @from(Ln 263661, Col 101)
i62
// @from(Ln 263661, Col 106)
rxA
// @from(Ln 263661, Col 111)
w75
// @from(Ln 263661, Col 116)
L75
// @from(Ln 263661, Col 121)
JVA
// @from(Ln 263661, Col 126)
W4A
// @from(Ln 263661, Col 131)
CCZ
// @from(Ln 263661, Col 136)
O75
// @from(Ln 263661, Col 141)
sxA
// @from(Ln 263661, Col 146)
M75
// @from(Ln 263661, Col 151)
R75
// @from(Ln 263661, Col 156)
txA
// @from(Ln 263661, Col 161)
UCZ
// @from(Ln 263661, Col 166)
_75
// @from(Ln 263661, Col 171)
DI0
// @from(Ln 263662, Col 4)
pz = w(() => {
  j9();
  wd();
  D4A();
  K4A = new Set(["claude-code-marketplace", "claude-code-plugins", "claude-plugins-official", "anthropic-marketplace", "anthropic-plugins", "agent-skills", "life-sciences"]);
  D75 = /(?:official[^a-z0-9]*(anthropic|claude)|(?:anthropic|claude)[^a-z0-9]*official|^(?:anthropic|claude)[^a-z0-9]*(marketplace|plugins|official))/i, W75 = /[^\u0020-\u007E]/;
  Nd = m.string().startsWith("./"), ZVA = Nd.endsWith(".json"), m62 = m.union([Nd.refine((A) => A.endsWith(".mcpb") || A.endsWith(".dxt"), {
    message: "MCPB file path must end with .mcpb or .dxt"
  }).describe("Path to MCPB file relative to plugin root"), m.string().url().refine((A) => A.endsWith(".mcpb") || A.endsWith(".dxt"), {
    message: "MCPB URL must end with .mcpb or .dxt"
  }).describe("URL to MCPB file")]), XI0 = Nd.endsWith(".md"), II0 = m.union([XI0, Nd]), p62 = m.object({
    name: m.string().min(1, "Author name cannot be empty").describe("Display name of the plugin author or organization"),
    email: m.string().optional().describe("Contact email for support or feedback"),
    url: m.string().optional().describe("Website, GitHub profile, or organization URL")
  }), V75 = m.object({
    name: m.string().min(1, "Plugin name cannot be empty").refine((A) => !A.includes(" "), {
      message: 'Plugin name cannot contain spaces. Use kebab-case (e.g., "my-plugin")'
    }).describe("Unique identifier for the plugin, used for namespacing (prefer kebab-case)"),
    version: m.string().optional().describe("Semantic version (e.g., 1.2.3) following semver.org specification"),
    description: m.string().optional().describe("Brief, user-facing explanation of what the plugin provides"),
    author: p62.optional().describe("Information about the plugin creator or maintainer"),
    homepage: m.string().url().optional().describe("Plugin homepage or documentation URL"),
    repository: m.string().optional().describe("Source code repository URL"),
    license: m.string().optional().describe("SPDX license identifier (e.g., MIT, Apache-2.0)"),
    keywords: m.array(m.string()).optional().describe("Tags for plugin discovery and categorization")
  }), l62 = m.object({
    description: m.string().optional().describe("Brief, user-facing explanation of what these hooks provide"),
    hooks: m.lazy(() => jb).describe("The hooks provided by the plugin, in the same format as the one used for settings")
  }), F75 = m.object({
    hooks: m.union([ZVA.describe("Path to file with additional hooks (in addition to those in hooks/hooks.json, if it exists), relative to the plugin root"), m.lazy(() => jb).describe("Additional hooks (in addition to those in hooks/hooks.json, if it exists)"), m.array(m.union([ZVA.describe("Path to file with additional hooks (in addition to those in hooks/hooks.json, if it exists), relative to the plugin root"), m.lazy(() => jb).describe("Additional hooks (in addition to those in hooks/hooks.json, if it exists)")]))])
  }), H75 = m.object({
    source: II0.optional().describe("Path to command markdown file, relative to plugin root"),
    content: m.string().optional().describe("Inline markdown content for the command"),
    description: m.string().optional().describe("Command description override"),
    argumentHint: m.string().optional().describe('Hint for command arguments (e.g., "[file]")'),
    model: m.string().optional().describe("Default model for this command"),
    allowedTools: m.array(m.string()).optional().describe("Tools allowed when command runs")
  }).refine((A) => A.source && !A.content || !A.source && A.content, {
    message: 'Command must have either "source" (file path) or "content" (inline markdown), but not both'
  }), E75 = m.object({
    commands: m.union([II0.describe("Path to additional command file or skill directory (in addition to those in the commands/ directory, if it exists), relative to the plugin root"), m.array(II0.describe("Path to additional command file or skill directory (in addition to those in the commands/ directory, if it exists), relative to the plugin root")).describe("List of paths to additional command files or skill directories"), m.record(m.string(), H75).describe('Object mapping of command names to their metadata and source files. Command name becomes the slash command name (e.g., "about"  "/plugin:about")')])
  }), z75 = m.object({
    agents: m.union([XI0.describe("Path to additional agent file (in addition to those in the agents/ directory, if it exists), relative to the plugin root"), m.array(XI0.describe("Path to additional agent file (in addition to those in the agents/ directory, if it exists), relative to the plugin root")).describe("List of paths to additional agent files")])
  }), $75 = m.object({
    skills: m.union([Nd.describe("Path to additional skill directory (in addition to those in the skills/ directory, if it exists), relative to the plugin root"), m.array(Nd.describe("Path to additional skill directory (in addition to those in the skills/ directory, if it exists), relative to the plugin root")).describe("List of paths to additional skill directories")])
  }), C75 = m.object({
    outputStyles: m.union([Nd.describe("Path to additional output styles directory or file (in addition to those in the output-styles/ directory, if it exists), relative to the plugin root"), m.array(Nd.describe("Path to additional output styles directory or file (in addition to those in the output-styles/ directory, if it exists), relative to the plugin root")).describe("List of paths to additional output styles directories or files")])
  }), U75 = m.object({
    mcpServers: m.union([ZVA.describe("MCP servers to include in the plugin (in addition to those in the .mcp.json file, if it exists)"), m62.describe("Path or URL to MCPB file containing MCP server configuration"), m.record(m.string(), Rb).describe("MCP server configurations keyed by server name"), m.array(m.union([ZVA.describe("Path to MCP servers configuration file"), m62.describe("Path or URL to MCPB file"), m.record(m.string(), Rb).describe("Inline MCP server configurations")])).describe("Array of MCP server configurations (paths, MCPB files, or inline definitions)")])
  }), d62 = m.string().min(1), q75 = m.string().min(2).refine((A) => A.startsWith("."), {
    message: 'File extensions must start with dot (e.g., ".ts", not "ts")'
  }), YVA = m.strictObject({
    command: m.string().min(1).refine((A) => {
      if (A.includes(" ") && !A.startsWith("/")) return !1;
      return !0
    }, {
      message: "Command should not contain spaces. Use args array for arguments."
    }).describe('Command to execute the LSP server (e.g., "typescript-language-server")'),
    args: m.array(d62).optional().describe("Command-line arguments to pass to the server"),
    extensionToLanguage: m.record(q75, d62).refine((A) => Object.keys(A).length > 0, {
      message: "extensionToLanguage must have at least one mapping"
    }).describe("Mapping from file extension to LSP language ID. File extensions and languages are derived from this mapping."),
    transport: m.enum(["stdio", "socket"]).default("stdio").describe("Communication transport mechanism"),
    env: m.record(m.string(), m.string()).optional().describe("Environment variables to set when starting the server"),
    initializationOptions: m.unknown().optional().describe("Initialization options passed to the server during initialization"),
    settings: m.unknown().optional().describe("Settings passed to the server via workspace/didChangeConfiguration"),
    workspaceFolder: m.string().optional().describe("Workspace folder path to use for the server"),
    startupTimeout: m.number().int().positive().optional().describe("Maximum time to wait for server startup (milliseconds)"),
    shutdownTimeout: m.number().int().positive().optional().describe("Maximum time to wait for graceful shutdown (milliseconds)"),
    restartOnCrash: m.boolean().optional().describe("Whether to restart the server if it crashes"),
    maxRestarts: m.number().int().nonnegative().optional().describe("Maximum number of restart attempts before giving up")
  }), N75 = m.object({
    lspServers: m.union([ZVA.describe("Path to .lsp.json configuration file relative to plugin root"), m.record(m.string(), YVA).describe("LSP server configurations keyed by server name"), m.array(m.union([ZVA.describe("Path to LSP configuration file"), m.record(m.string(), YVA).describe("Inline LSP server configurations")])).describe("Array of LSP server configurations (paths or inline definitions)")])
  }), V4A = m.object({
    ...V75.shape,
    ...F75.partial().shape,
    ...E75.partial().shape,
    ...z75.partial().shape,
    ...$75.partial().shape,
    ...C75.partial().shape,
    ...U75.partial().shape,
    ...N75.partial().shape
  }).strict(), i62 = m.string().refine((A) => !A.includes("..") && !A.includes("//"), "Package name cannot contain path traversal patterns").refine((A) => {
    let Q = /^@[a-z0-9][a-z0-9-._]*\/[a-z0-9][a-z0-9-._]*$/,
      B = /^[a-z0-9][a-z0-9-._]*$/;
    return Q.test(A) || B.test(A)
  }, "Invalid npm package name format"), rxA = m.discriminatedUnion("source", [m.object({
    source: m.literal("url"),
    url: m.string().url().describe("Direct URL to marketplace.json file"),
    headers: m.record(m.string(), m.string()).optional().describe("Custom HTTP headers (e.g., for authentication)")
  }), m.object({
    source: m.literal("github"),
    repo: m.string().describe("GitHub repository in owner/repo format"),
    ref: m.string().optional().describe('Git branch or tag to use (e.g., "main", "v1.0.0"). Defaults to repository default branch.'),
    path: m.string().optional().describe("Path to marketplace.json within repo (defaults to .claude-plugin/marketplace.json)")
  }), m.object({
    source: m.literal("git"),
    url: m.string().endsWith(".git").describe("Full git repository URL"),
    ref: m.string().optional().describe('Git branch or tag to use (e.g., "main", "v1.0.0"). Defaults to repository default branch.'),
    path: m.string().optional().describe("Path to marketplace.json within repo (defaults to .claude-plugin/marketplace.json)")
  }), m.object({
    source: m.literal("npm"),
    package: i62.describe("NPM package containing marketplace.json")
  }), m.object({
    source: m.literal("file"),
    path: m.string().describe("Local file path to marketplace.json")
  }), m.object({
    source: m.literal("directory"),
    path: m.string().describe("Local directory containing .claude-plugin/marketplace.json")
  })]), w75 = m.union([Nd.describe("Path to the plugin root, relative to the marketplace directory"), m.object({
    source: m.literal("npm"),
    package: i62.or(m.string()).describe("Package name (or url, or local path, or anything else that can be passed to `npm` as a package)"),
    version: m.string().optional().describe("Specific version or version range (e.g., ^1.0.0, ~2.1.0)"),
    registry: m.string().url().optional().describe("Custom NPM registry URL (defaults to using system default, likely npmjs.org)")
  }).describe("NPM package as plugin source"), m.object({
    source: m.literal("pip"),
    package: m.string().describe("Python package name as it appears on PyPI"),
    version: m.string().optional().describe("Version specifier (e.g., ==1.0.0, >=2.0.0, <3.0.0)"),
    registry: m.string().url().optional().describe("Custom PyPI registry URL (defaults to using system default, likely pypi.org)")
  }).describe("Python package as plugin source"), m.object({
    source: m.literal("url"),
    url: m.string().endsWith(".git").describe("Full git repository URL (https:// or git@)"),
    ref: m.string().optional().describe('Git branch or tag to use (e.g., "main", "v1.0.0"). Defaults to repository default branch.')
  }), m.object({
    source: m.literal("github"),
    repo: m.string().describe("GitHub repository in owner/repo format"),
    ref: m.string().optional().describe('Git branch or tag to use (e.g., "main", "v1.0.0"). Defaults to repository default branch.')
  })]);
  L75 = V4A.partial().extend({
    name: m.string().min(1, "Plugin name cannot be empty").refine((A) => !A.includes(" "), {
      message: 'Plugin name cannot contain spaces. Use kebab-case (e.g., "my-plugin")'
    }).describe("Unique identifier matching the plugin name"),
    source: w75.describe("Where to fetch the plugin from"),
    category: m.string().optional().describe('Category for organizing plugins (e.g., "productivity", "development")'),
    tags: m.array(m.string()).optional().describe("Tags for searchability and discovery"),
    strict: m.boolean().optional().default(!0).describe("Require the plugin manifest to be present in the plugin folder. If false, the marketplace entry provides the manifest.")
  }).strict(), JVA = m.object({
    name: m.string().min(1, "Marketplace must have a name").refine((A) => !A.includes(" "), {
      message: 'Marketplace name cannot contain spaces. Use kebab-case (e.g., "my-marketplace")'
    }).refine((A) => !K75(A), {
      message: 'Marketplace name cannot impersonate official Anthropic/Claude marketplaces. Names containing "official", "anthropic", or "claude" in official-sounding combinations are reserved.'
    }),
    owner: p62.describe("Marketplace maintainer or curator information"),
    plugins: m.array(L75).describe("Collection of available plugins in this marketplace"),
    metadata: m.object({
      pluginRoot: m.string().optional().describe("Base path for relative plugin sources"),
      version: m.string().optional().describe("Marketplace version"),
      description: m.string().optional().describe("Marketplace description")
    }).optional().describe("Optional marketplace metadata")
  }), W4A = m.string().regex(/^[a-z0-9][-a-z0-9._]*@[a-z0-9][-a-z0-9._]*$/i, "Plugin ID must be in format: plugin@marketplace"), CCZ = m.union([W4A, m.object({
    id: W4A.describe('Plugin identifier (e.g., "formatter@tools")'),
    version: m.string().optional().describe('Version constraint (e.g., "^2.0.0")'),
    required: m.boolean().optional().describe("If true, cannot be disabled"),
    config: m.record(m.string(), m.unknown()).optional().describe("Plugin-specific configuration")
  })]), O75 = m.object({
    version: m.string().describe("Currently installed version"),
    installedAt: m.string().describe("ISO 8601 timestamp of installation"),
    lastUpdated: m.string().optional().describe("ISO 8601 timestamp of last update"),
    installPath: m.string().describe("Absolute path to the installed plugin directory"),
    gitCommitSha: m.string().optional().describe("Git commit SHA for git-based plugins (for version tracking)")
  }), sxA = m.object({
    version: m.literal(1).describe("Schema version 1"),
    plugins: m.record(W4A, O75).describe("Map of plugin IDs to their installation metadata")
  }), M75 = m.enum(["managed", "user", "project", "local"]), R75 = m.object({
    scope: M75.describe("Installation scope"),
    projectPath: m.string().optional().describe("Project path (required for project/local scopes)"),
    installPath: m.string().describe("Absolute path to the versioned plugin directory"),
    version: m.string().optional().describe("Currently installed version"),
    installedAt: m.string().optional().describe("ISO 8601 timestamp of installation"),
    lastUpdated: m.string().optional().describe("ISO 8601 timestamp of last update"),
    gitCommitSha: m.string().optional().describe("Git commit SHA for git-based plugins")
  }), txA = m.object({
    version: m.literal(2).describe("Schema version 2"),
    plugins: m.record(W4A, m.array(R75)).describe("Map of plugin IDs to arrays of installation entries")
  }), UCZ = m.union([sxA, txA]), _75 = m.object({
    source: rxA.describe("Where to fetch the marketplace from"),
    installLocation: m.string().describe("Local cache path where marketplace manifest is stored"),
    lastUpdated: m.string().describe("ISO 8601 timestamp of last marketplace refresh"),
    autoUpdate: m.boolean().optional().describe("Whether to automatically update this marketplace and its installed plugins on startup")
  }), DI0 = m.record(m.string(), _75)
})
// @from(Ln 263843, Col 4)
j75
// @from(Ln 263843, Col 9)
n62
// @from(Ln 263844, Col 4)
a62 = w(() => {
  j9();
  j75 = m.object({
    allowedDomains: m.array(m.string()).optional(),
    allowUnixSockets: m.array(m.string()).optional(),
    allowAllUnixSockets: m.boolean().optional(),
    allowLocalBinding: m.boolean().optional(),
    httpProxyPort: m.number().optional(),
    socksProxyPort: m.number().optional()
  }).optional(), n62 = m.object({
    enabled: m.boolean().optional(),
    autoAllowBashIfSandboxed: m.boolean().optional(),
    allowUnsandboxedCommands: m.boolean().optional().describe("Allow commands to run outside the sandbox via the dangerouslyDisableSandbox parameter. When false, the dangerouslyDisableSandbox parameter is completely ignored and all commands must run sandboxed. Default: true."),
    network: j75,
    ignoreViolations: m.record(m.string(), m.array(m.string())).optional(),
    enableWeakerNestedSandbox: m.boolean().optional(),
    excludedCommands: m.array(m.string()).optional(),
    ripgrep: m.object({
      command: m.string(),
      args: m.array(m.string()).optional()
    }).optional().describe("Custom ripgrep configuration for bundled ripgrep support")
  }).passthrough()
})
// @from(Ln 263868, Col 0)
function XVA(A) {
  return "serverName" in A && A.serverName !== void 0
}
// @from(Ln 263872, Col 0)
function wZ1(A) {
  return "serverCommand" in A && A.serverCommand !== void 0
}
// @from(Ln 263876, Col 0)
function LZ1(A) {
  return "serverUrl" in A && A.serverUrl !== void 0
}
// @from(Ln 263879, Col 4)
T75
// @from(Ln 263879, Col 9)
P75
// @from(Ln 263879, Col 14)
S75
// @from(Ln 263879, Col 19)
x75
// @from(Ln 263879, Col 24)
y75
// @from(Ln 263879, Col 29)
v75
// @from(Ln 263879, Col 34)
k75
// @from(Ln 263879, Col 39)
jb
// @from(Ln 263879, Col 43)
b75
// @from(Ln 263879, Col 48)
f75
// @from(Ln 263879, Col 53)
h75
// @from(Ln 263879, Col 58)
Ld
// @from(Ln 263880, Col 4)
wd = w(() => {
  j9();
  GVA();
  mL();
  u62();
  YI();
  pz();
  a62();
  T75 = m.record(m.string(), m.coerce.string()), P75 = m.object({
    allow: m.array(qZ1).optional().describe("List of permission rules for allowed operations"),
    deny: m.array(qZ1).optional().describe("List of permission rules for denied operations"),
    ask: m.array(qZ1).optional().describe("List of permission rules that should always prompt for confirmation"),
    defaultMode: m.enum(NP).optional().describe("Default permission mode when Claude Code needs access"),
    disableBypassPermissionsMode: m.enum(["disable"]).optional().describe("Disable the ability to bypass permission prompts"),
    additionalDirectories: m.array(m.string()).optional().describe("Additional directories to include in the permission scope")
  }).passthrough(), S75 = m.object({
    type: m.literal("command").describe("Bash command hook type"),
    command: m.string().describe("Shell command to execute"),
    timeout: m.number().positive().optional().describe("Timeout in seconds for this specific command"),
    statusMessage: m.string().optional().describe("Custom status message to display in spinner while hook runs"),
    once: m.boolean().optional().describe("If true, hook runs once and is removed after execution")
  }), x75 = m.object({
    type: m.literal("prompt").describe("LLM prompt hook type"),
    prompt: m.string().describe("Prompt to evaluate with LLM. Use $ARGUMENTS placeholder for hook input JSON."),
    timeout: m.number().positive().optional().describe("Timeout in seconds for this specific prompt evaluation"),
    model: m.string().optional().describe('Model to use for this prompt hook (e.g., "claude-sonnet-4-5-20250929"). If not specified, uses the default small fast model.'),
    statusMessage: m.string().optional().describe("Custom status message to display in spinner while hook runs"),
    once: m.boolean().optional().describe("If true, hook runs once and is removed after execution")
  }), y75 = m.object({
    type: m.literal("agent").describe("Agentic verifier hook type"),
    prompt: m.string().transform((A) => (Q) => A).describe('Prompt describing what to verify (e.g. "Verify that unit tests ran and passed."). Use $ARGUMENTS placeholder for hook input JSON.'),
    timeout: m.number().positive().optional().describe("Timeout in seconds for agent execution (default 60)"),
    model: m.string().optional().describe('Model to use for this agent hook (e.g., "claude-sonnet-4-5-20250929"). If not specified, uses Haiku.'),
    statusMessage: m.string().optional().describe("Custom status message to display in spinner while hook runs"),
    once: m.boolean().optional().describe("If true, hook runs once and is removed after execution")
  }), v75 = m.discriminatedUnion("type", [S75, x75, y75]), k75 = m.object({
    matcher: m.string().optional().describe('String pattern to match (e.g. tool names like "Write")'),
    hooks: m.array(v75).describe("List of hooks to execute when the matcher matches")
  }), jb = m.partialRecord(m.enum(_b), m.array(k75)), b75 = m.object({
    source: rxA.describe("Where to fetch the marketplace from"),
    installLocation: m.string().optional().describe("Local cache path where marketplace manifest is stored (auto-generated if not provided)")
  }), f75 = m.object({
    serverName: m.string().regex(/^[a-zA-Z0-9_-]+$/, "Server name can only contain letters, numbers, hyphens, and underscores").optional().describe("Name of the MCP server that users are allowed to configure"),
    serverCommand: m.array(m.string()).min(1, "Server command must have at least one element (the command)").optional().describe("Command array [command, ...args] to match exactly for allowed stdio servers"),
    serverUrl: m.string().optional().describe('URL pattern with wildcard support (e.g., "https://*.example.com/*") for allowed remote MCP servers')
  }).refine((A) => {
    return [A.serverName !== void 0, A.serverCommand !== void 0, A.serverUrl !== void 0].filter(Boolean).length === 1
  }, {
    message: 'Entry must have exactly one of "serverName", "serverCommand", or "serverUrl"'
  }), h75 = m.object({
    serverName: m.string().regex(/^[a-zA-Z0-9_-]+$/, "Server name can only contain letters, numbers, hyphens, and underscores").optional().describe("Name of the MCP server that is explicitly blocked"),
    serverCommand: m.array(m.string()).min(1, "Server command must have at least one element (the command)").optional().describe("Command array [command, ...args] to match exactly for blocked stdio servers"),
    serverUrl: m.string().optional().describe('URL pattern with wildcard support (e.g., "https://*.example.com/*") for blocked remote MCP servers')
  }).refine((A) => {
    return [A.serverName !== void 0, A.serverCommand !== void 0, A.serverUrl !== void 0].filter(Boolean).length === 1
  }, {
    message: 'Entry must have exactly one of "serverName", "serverCommand", or "serverUrl"'
  }), Ld = m.object({
    $schema: m.literal(yFB).optional().describe("JSON Schema reference for Claude Code settings"),
    apiKeyHelper: m.string().optional().describe("Path to a script that outputs authentication values"),
    awsCredentialExport: m.string().optional().describe("Path to a script that exports AWS credentials"),
    awsAuthRefresh: m.string().optional().describe("Path to a script that refreshes AWS authentication"),
    fileSuggestion: m.object({
      type: m.literal("command"),
      command: m.string()
    }).optional().describe("Custom file suggestion configuration for @ mentions"),
    respectGitignore: m.boolean().optional().describe("Whether file picker should respect .gitignore files (default: true). Note: .ignore files are always respected."),
    cleanupPeriodDays: m.number().nonnegative().int().optional().describe("Number of days to retain chat transcripts (0 to disable cleanup)"),
    env: T75.optional().describe("Environment variables to set for Claude Code sessions"),
    attribution: m.object({
      commit: m.string().optional().describe("Attribution text for git commits, including any trailers. Empty string hides attribution."),
      pr: m.string().optional().describe("Attribution text for pull request descriptions. Empty string hides attribution.")
    }).optional().describe("Customize attribution text for commits and PRs. Each field defaults to the standard Claude Code attribution if not set."),
    includeCoAuthoredBy: m.boolean().optional().describe("Deprecated: Use attribution instead. Whether to include Claude's co-authored by attribution in commits and PRs (defaults to true)"),
    permissions: P75.optional().describe("Tool usage permissions configuration"),
    model: m.string().optional().describe("Override the default model used by Claude Code"),
    enableAllProjectMcpServers: m.boolean().optional().describe("Whether to automatically approve all MCP servers in the project"),
    enabledMcpjsonServers: m.array(m.string()).optional().describe("List of approved MCP servers from .mcp.json"),
    disabledMcpjsonServers: m.array(m.string()).optional().describe("List of rejected MCP servers from .mcp.json"),
    allowedMcpServers: m.array(f75).optional().describe("Enterprise allowlist of MCP servers that can be used. Applies to all scopes including enterprise servers from managed-mcp.json. If undefined, all servers are allowed. If empty array, no servers are allowed. Denylist takes precedence - if a server is on both lists, it is denied."),
    deniedMcpServers: m.array(h75).optional().describe("Enterprise denylist of MCP servers that are explicitly blocked. If a server is on the denylist, it will be blocked across all scopes including enterprise. Denylist takes precedence over allowlist - if a server is on both lists, it is denied."),
    hooks: jb.optional().describe("Custom commands to run before/after tool executions"),
    disableAllHooks: m.boolean().optional().describe("Disable all hooks and statusLine execution"),
    allowManagedHooksOnly: m.boolean().optional().describe("When true (and set in managed settings), only hooks from managed settings run. User, project, and local hooks are ignored."),
    statusLine: m.object({
      type: m.literal("command"),
      command: m.string(),
      padding: m.number().optional()
    }).optional().describe("Custom status line display configuration"),
    enabledPlugins: m.record(m.string(), m.union([m.array(m.string()), m.boolean(), m.undefined()])).optional().describe('Enabled plugins using plugin-id@marketplace-id format. Example: { "formatter@anthropic-tools": true }. Also supports extended format with version constraints.'),
    extraKnownMarketplaces: m.record(m.string(), b75).optional().describe("Additional marketplaces to make available for this repository. Typically used in repository .claude/settings.json to ensure team members have required plugin sources."),
    skippedMarketplaces: m.array(m.string()).optional().describe("List of marketplace names the user has chosen not to install when prompted"),
    skippedPlugins: m.array(m.string()).optional().describe("List of plugin IDs (plugin@marketplace format) the user has chosen not to install when prompted"),
    strictKnownMarketplaces: m.array(rxA).optional().describe("Enterprise strict list of allowed marketplace sources. When set in managed settings, ONLY these exact sources can be added as marketplaces. The check happens BEFORE downloading, so blocked sources never touch the filesystem."),
    blockedMarketplaces: m.array(rxA).optional().describe("Enterprise blocklist of marketplace sources. When set in managed settings, these exact sources are blocked from being added as marketplaces. The check happens BEFORE downloading, so blocked sources never touch the filesystem."),
    forceLoginMethod: m.enum(["claudeai", "console"]).optional().describe('Force a specific login method: "claudeai" for Claude Pro/Max, "console" for Console billing'),
    forceLoginOrgUUID: m.string().optional().describe("Organization UUID to use for OAuth login"),
    otelHeadersHelper: m.string().optional().describe("Path to a script that outputs OpenTelemetry headers"),
    outputStyle: m.string().optional().describe("Controls the output style for assistant responses"),
    language: m.string().optional().describe('Preferred language for Claude responses (e.g., "japanese", "spanish")'),
    skipWebFetchPreflight: m.boolean().optional().describe("Skip the WebFetch blocklist check for enterprise environments with restrictive security policies"),
    sandbox: n62.optional(),
    spinnerTipsEnabled: m.boolean().optional().describe("Whether to show tips in the spinner"),
    syntaxHighlightingDisabled: m.boolean().optional().describe("Whether to disable syntax highlighting in diffs"),
    alwaysThinkingEnabled: m.boolean().optional().describe("When false, thinking is disabled. When absent or true, thinking is enabled automatically for supported models."),
    promptSuggestionEnabled: m.boolean().optional().describe("When false, prompt suggestions are disabled. When absent or true, prompt suggestions are enabled."),
    agent: m.string().optional().describe("Name of an agent (built-in or custom) to use for the main thread. Applies the agent's system prompt, tool restrictions, and model."),
    companyAnnouncements: m.array(m.string()).optional().describe("Company announcements to display at startup (one will be randomly selected if multiple are provided)"),
    pluginConfigs: m.record(m.string(), m.object({
      mcpServers: m.record(m.string(), m.record(m.string(), m.union([m.string(), m.number(), m.boolean(), m.array(m.string())]))).optional().describe("User configuration values for MCP servers keyed by server name")
    })).optional().describe("Per-plugin configuration including MCP server user configs, keyed by plugin ID (plugin@marketplace format)"),
    remote: m.object({
      defaultEnvironmentId: m.string().optional().describe("Default environment ID to use for remote sessions")
    }).optional().describe("Remote session configuration"),
    autoUpdatesChannel: m.enum(["latest", "stable"]).optional().describe("Release channel for auto-updates (latest or stable)"),
    minimumVersion: m.string().optional().describe("Minimum version to stay on - prevents downgrades when switching to stable channel"),
    classifierPermissionsEnabled: m.boolean().optional().describe("Enable AI-based classification for Bash(prompt:...) permission rules")
  }).passthrough()
})
// @from(Ln 264003, Col 0)
async function u75(A) {
  try {
    let {
      cmd: Q
    } = r62.findActualExecutable(A, []);
    try {
      return g75(Q, o62.F_OK | o62.X_OK), !0
    } catch (B) {
      return k(`Command '${A}' found at '${Q}' but not accessible: ${B}`), !1
    }
  } catch (Q) {
    return k(`Command '${A}' not found in PATH: ${Q}`), !1
  }
}
// @from(Ln 264017, Col 4)
r62
// @from(Ln 264017, Col 9)
OZ1
// @from(Ln 264018, Col 4)
WI0 = w(() => {
  Y9();
  T1();
  r62 = c(dcA(), 1);
  OZ1 = W0(async () => {
    return u75("git")
  })
})
// @from(Ln 264027, Col 0)
function IVA(A, Q) {
  let G = A.slice(0, 2).map((J) => {
      let X = J.reason || J.error || "unknown error";
      return Q ? `${J.name} (${X})` : J.name
    }).join(Q ? "; " : ", "),
    Z = A.length - 2,
    Y = Z > 0 ? ` and ${Z} more` : "";
  return `${G}${Y}`
}
// @from(Ln 264037, Col 0)
function exA(A) {
  switch (A.source) {
    case "github":
      return A.repo;
    case "url":
      return A.url;
    case "git":
      return A.url;
    case "directory":
      return A.path;
    case "file":
      return A.path;
    default:
      return "Unknown source"
  }
}
// @from(Ln 264054, Col 0)
function Mr(A, Q) {
  return `${A}@${Q}`
}
// @from(Ln 264057, Col 0)
async function F4A(A) {
  let Q = [],
    B = [];
  for (let [G, Z] of Object.entries(A)) {
    if (!H4A(Z.source)) continue;
    let Y = null;
    try {
      Y = await rC(G)
    } catch (J) {
      let X = J instanceof Error ? J.message : String(J);
      B.push({
        name: G,
        error: X
      }), e(J instanceof Error ? J : Error(`Failed to load marketplace ${G}: ${J}`))
    }
    Q.push({
      name: G,
      config: Z,
      data: Y
    })
  }
  return {
    marketplaces: Q,
    failures: B
  }
}
// @from(Ln 264084, Col 0)
function DVA(A, Q) {
  if (A.length === 0) return null;
  if (Q > 0) return {
    type: "warning",
    message: A.length === 1 ? `Warning: Failed to load marketplace '${A[0].name}': ${A[0].error}` : `Warning: Failed to load ${A.length} marketplaces: ${m75(A)}`
  };
  return {
    type: "error",
    message: `Failed to load all marketplaces. Errors: ${d75(A)}`
  }
}
// @from(Ln 264096, Col 0)
function m75(A) {
  return A.map((Q) => Q.name).join(", ")
}
// @from(Ln 264100, Col 0)
function d75(A) {
  return A.map((Q) => `${Q.name}: ${Q.error}`).join("; ")
}
// @from(Ln 264104, Col 0)
function WVA() {
  let A = dB("policySettings");
  if (!A?.strictKnownMarketplaces) return null;
  return A.strictKnownMarketplaces
}
// @from(Ln 264110, Col 0)
function c75() {
  let A = dB("policySettings");
  if (!A?.blockedMarketplaces) return null;
  return A.blockedMarketplaces
}
// @from(Ln 264116, Col 0)
function p75(A, Q) {
  if (A.source !== Q.source) return !1;
  switch (A.source) {
    case "url":
      return A.url === Q.url;
    case "github":
      return A.repo === Q.repo && (A.ref || void 0) === (Q.ref || void 0) && (A.path || void 0) === (Q.path || void 0);
    case "git":
      return A.url === Q.url && (A.ref || void 0) === (Q.ref || void 0) && (A.path || void 0) === (Q.path || void 0);
    case "npm":
      return A.package === Q.package;
    case "file":
      return A.path === Q.path;
    case "directory":
      return A.path === Q.path;
    default:
      return !1
  }
}
// @from(Ln 264136, Col 0)
function s62(A) {
  let Q = A.match(/^git@github\.com:([^/]+\/[^/]+?)(?:\.git)?$/);
  if (Q && Q[1]) return Q[1];
  let B = A.match(/^https?:\/\/github\.com\/([^/]+\/[^/]+?)(?:\.git)?$/);
  if (B && B[1]) return B[1];
  return null
}
// @from(Ln 264144, Col 0)
function Or(A, Q) {
  if (!A) return !0;
  return (A || void 0) === (Q || void 0)
}
// @from(Ln 264149, Col 0)
function l75(A, Q) {
  if (A.source === Q.source) switch (A.source) {
    case "github": {
      let B = Q;
      if (A.repo !== B.repo) return !1;
      return Or(B.ref, A.ref) && Or(B.path, A.path)
    }
    case "git": {
      let B = Q;
      if (A.url !== B.url) return !1;
      return Or(B.ref, A.ref) && Or(B.path, A.path)
    }
    case "url":
      return A.url === Q.url;
    case "npm":
      return A.package === Q.package;
    case "file":
      return A.path === Q.path;
    case "directory":
      return A.path === Q.path;
    default:
      return !1
  }
  if (A.source === "git" && Q.source === "github") {
    if (s62(A.url) === Q.repo) return Or(Q.ref, A.ref) && Or(Q.path, A.path)
  }
  if (A.source === "github" && Q.source === "git") {
    if (s62(Q.url) === A.repo) return Or(Q.ref, A.ref) && Or(Q.path, A.path)
  }
  return !1
}
// @from(Ln 264181, Col 0)
function AyA(A) {
  let Q = c75();
  if (Q === null) return !1;
  return Q.some((B) => l75(A, B))
}
// @from(Ln 264187, Col 0)
function H4A(A) {
  if (AyA(A)) return !1;
  let Q = WVA();
  if (Q === null) return !0;
  return Q.some((B) => p75(A, B))
}
// @from(Ln 264194, Col 0)
function KVA(A) {
  switch (A.source) {
    case "github":
      return `github:${A.repo}${A.ref?`@${A.ref}`:""}`;
    case "url":
      return A.url;
    case "git":
      return `git:${A.url}${A.ref?`@${A.ref}`:""}`;
    case "npm":
      return `npm:${A.package}`;
    case "file":
      return `file:${A.path}`;
    case "directory":
      return `dir:${A.path}`;
    default:
      return "unknown source"
  }
}
// @from(Ln 264212, Col 0)
async function t62({
  configuredMarketplaceCount: A,
  failedMarketplaceCount: Q
}) {
  if (!await OZ1()) return "git-not-installed";
  let G = WVA();
  if (G !== null) {
    if (G.length === 0) return "all-blocked-by-policy";
    if (A === 0) return "policy-restricts-sources"
  }
  if (A === 0) return "no-marketplaces-configured";
  if (Q > 0 && Q === A) return "all-marketplaces-failed";
  return "all-plugins-installed"
}
// @from(Ln 264226, Col 4)
E4A = w(() => {
  HI();
  v1();
  GB();
  WI0()
})
// @from(Ln 264238, Col 0)
function MZ1() {
  return sC(zQ(), "plugins", "known_marketplaces.json")
}
// @from(Ln 264242, Col 0)
function Z32() {
  return sC(zQ(), "plugins", "marketplaces")
}
// @from(Ln 264246, Col 0)
function RZ1() {
  rC.cache?.clear?.()
}
// @from(Ln 264249, Col 0)
async function D5() {
  let A = vA(),
    Q = MZ1();
  if (!A.existsSync(Q)) return {};
  try {
    let B = A.readFileSync(Q, {
        encoding: "utf-8"
      }),
      G = AQ(B),
      Z = DI0.safeParse(G);
    if (!Z.success) {
      let Y = `Marketplace configuration file is corrupted: ${Z.error.issues.map((J)=>`${J.path.join(".")}: ${J.message}`).join(", ")}`;
      throw k(Y, {
        level: "error"
      }), new Hq(Y, Q, G)
    }
    return Z.data
  } catch (B) {
    if (B instanceof Hq) throw B;
    let G = `Failed to load marketplace configuration: ${B instanceof Error?B.message:String(B)}`;
    throw k(G, {
      level: "error"
    }), Error(G)
  }
}
// @from(Ln 264274, Col 0)
async function FVA(A) {
  let Q = DI0.safeParse(A),
    B = MZ1();
  if (!Q.success) throw new Hq(`Invalid marketplace config: ${Q.error.message}`, B, A);
  let G = vA(),
    Z = sC(B, "..");
  G.mkdirSync(Z), bB(B, eA(Q.data, null, 2), {
    encoding: "utf-8",
    flush: !0
  })
}
// @from(Ln 264286, Col 0)
function QyA() {
  let A = {};
  if (process.env.GITHUB_TOKEN) A.GITHUB_TOKEN = process.env.GITHUB_TOKEN;
  if (process.env.GH_TOKEN) A.GH_TOKEN = process.env.GH_TOKEN;
  if (process.env.GITLAB_TOKEN) A.GITLAB_TOKEN = process.env.GITLAB_TOKEN;
  if (process.env.GL_TOKEN) A.GL_TOKEN = process.env.GL_TOKEN;
  if (process.env.BITBUCKET_TOKEN) A.BITBUCKET_TOKEN = process.env.BITBUCKET_TOKEN;
  if (process.env.SSH_AUTH_SOCK) A.SSH_AUTH_SOCK = process.env.SSH_AUTH_SOCK;
  return {
    ...process.env,
    ...i75,
    ...A
  }
}
// @from(Ln 264301, Col 0)
function n75(A) {
  if (!A.startsWith("https://")) return A;
  let Q;
  try {
    Q = new URL(A)
  } catch {
    return A
  }
  if (Q.username || Q.password) return A;
  let B = Q.hostname.toLowerCase();
  if (B === "github.com") {
    let G = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
    if (G) return Q.username = "x-access-token", Q.password = G, k("Injecting GitHub token into clone URL"), Q.toString()
  }
  if (B === "gitlab.com" || B.includes("gitlab")) {
    let G = process.env.GITLAB_TOKEN || process.env.GL_TOKEN;
    if (G) return Q.username = "oauth2", Q.password = G, k("Injecting GitLab token into clone URL"), Q.toString()
  }
  if (B === "bitbucket.org") {
    let G = process.env.BITBUCKET_TOKEN;
    if (G) return Q.username = "x-token-auth", Q.password = G, k("Injecting Bitbucket token into clone URL"), Q.toString()
  }
  return A
}
// @from(Ln 264326, Col 0)
function KI0(A) {
  return A.replace(/(https?:\/\/[^:]+:)([^@]+)(@[^\s'"]+)/gi, "$1***REDACTED***$3")
}
// @from(Ln 264329, Col 0)
async function a75(A, Q) {
  if (Q) {
    let G = await J2("git", ["-c", "credential.helper=", "fetch", "origin", Q], {
      cwd: A,
      timeout: 30000,
      stdin: "ignore",
      env: QyA()
    });
    if (G.code !== 0) return G;
    let Z = await J2("git", ["-c", "credential.helper=", "checkout", Q], {
      cwd: A,
      timeout: 30000,
      stdin: "ignore",
      env: QyA()
    });
    if (Z.code !== 0) return Z;
    let Y = await J2("git", ["-c", "credential.helper=", "pull", "origin", "HEAD"], {
      cwd: A,
      timeout: 30000,
      stdin: "ignore",
      env: QyA()
    });
    return Q32(Y)
  }
  let B = await J2("git", ["-c", "credential.helper=", "pull", "origin", "HEAD"], {
    cwd: A,
    timeout: 30000,
    stdin: "ignore",
    env: QyA()
  });
  return Q32(B)
}
// @from(Ln 264362, Col 0)
function Q32(A) {
  if (A.code !== 0 && A.stderr) {
    if (A.stderr.includes("Permission denied (publickey)") || A.stderr.includes("Could not read from remote repository")) return {
      ...A,
      stderr: `SSH authentication failed while updating marketplace. Please ensure your SSH keys are configured.

Original error: ${A.stderr}`
    };
    if (A.stderr.includes("timed out") || A.stderr.includes("Could not resolve host")) return {
      ...A,
      stderr: `Network error while updating marketplace. Please check your internet connection.

Original error: ${A.stderr}`
    }
  }
  return A
}
// @from(Ln 264379, Col 0)
async function o75() {
  try {
    let A = await TQ("ssh", ["-T", "-o", "BatchMode=yes", "-o", "ConnectTimeout=2", "-o", "StrictHostKeyChecking=accept-new", "git@github.com"], {
      timeout: 3000
    });
    return A.code === 1 && (A.stderr?.includes("successfully authenticated") || A.stdout?.includes("successfully authenticated"))
  } catch (A) {
    return k(`SSH configuration check failed: ${A instanceof Error?A.message:String(A)}`, {
      level: "warn"
    }), !1
  }
}
// @from(Ln 264392, Col 0)
function B32(A) {
  return A.includes("Authentication failed") || A.includes("could not read Username") || A.includes("terminal prompts disabled") || A.includes("403") || A.includes("401")
}
// @from(Ln 264395, Col 0)
async function G32(A, Q, B) {
  let G = ["-c", "credential.helper=", "-c", "core.sshCommand=ssh -o BatchMode=yes -o StrictHostKeyChecking=accept-new", "clone", "--depth", "1", "--recurse-submodules", "--shallow-submodules"];
  if (B) G.push("--branch", B);
  return G.push(A, Q), await TQ("git", G, {
    timeout: 30000,
    stdin: "ignore",
    env: QyA()
  })
}
// @from(Ln 264404, Col 0)
async function r75(A, Q, B) {
  let G = await G32(A, Q, B);
  if (G.code === 0) return {
    ...G,
    stderr: KI0(G.stderr)
  };
  let Z = n75(A);
  if (Z !== A && A.startsWith("https://") && B32(G.stderr)) {
    k("HTTPS clone failed with auth error, retrying with token injection");
    try {
      let {
        rmSync: D
      } = await import("fs");
      D(Q, {
        recursive: !0,
        force: !0
      })
    } catch {}
    let X = await G32(Z, Q, B),
      I = X.stderr ? KI0(X.stderr) : X.stderr;
    if (X.code === 0) return {
      ...X,
      stderr: I
    };
    return {
      ...X,
      stderr: `HTTPS authentication failed. Ensure your token has access to this repository.

Original error: ${I}`
    }
  }
  let J = G.stderr ? KI0(G.stderr) : G.stderr;
  if (G.code !== 0 && J) {
    if (J.includes("Permission denied (publickey)") || J.includes("Could not read from remote repository")) return {
      ...G,
      stderr: `SSH authentication failed. Please ensure your SSH keys are configured for GitHub, or use an HTTPS URL instead.

Original error: ${J}`
    };
    if (B32(J)) return {
      ...G,
      stderr: `HTTPS authentication failed. For private repos, set GITHUB_TOKEN, GITLAB_TOKEN, or BITBUCKET_TOKEN environment variable.

Original error: ${J}`
    };
    if (J.includes("timed out") || J.includes("timeout") || J.includes("Could not resolve host")) return {
      ...G,
      stderr: `Network error or timeout while cloning repository. Please check your internet connection and try again.

Original error: ${J}`
    };
    return {
      ...G,
      stderr: J
    }
  }
  return {
    ...G,
    stderr: J
  }
}
// @from(Ln 264466, Col 0)
function b_(A, Q) {
  if (!A) return;
  try {
    A(Q)
  } catch (B) {
    k(`Progress callback error: ${B instanceof Error?B.message:String(B)}`, {
      level: "warn"
    })
  }
}
// @from(Ln 264476, Col 0)
async function VVA(A, Q, B, G) {
  let Z = vA();
  if (Z.existsSync(Q)) {
    if (!Z.existsSync(sC(Q, ".git"))) throw Error(`Cache directory exists at ${Q} but is not a git repository. Please remove it manually and try again.`);
    b_(G, "Updating existing marketplace cache");
    let X = await a75(Q, B);
    if (X.code !== 0) {
      k(`Failed to update marketplace cache: ${X.stderr}`, {
        level: "error"
      }), b_(G, "Update failed, cleaning up and re-cloning");
      try {
        Z.rmSync(Q, {
          recursive: !0,
          force: !0
        })
      } catch (I) {
        let D = I instanceof Error ? I.message : String(I);
        throw Error(`Failed to clean up existing marketplace directory. Please manually delete the directory at ${Q} and try again.

Technical details: ${D}`)
      }
    } else return
  }
  let Y = B ? ` (ref: ${B})` : "";
  b_(G, `Cloning repository: ${A}${Y}`);
  let J = await r75(A, Q, B);
  if (J.code !== 0) throw Error(`Failed to clone marketplace repository: ${J.stderr}`);
  b_(G, "Clone complete, validating marketplace")
}
// @from(Ln 264506, Col 0)
function s75(A) {
  return Object.fromEntries(Object.entries(A).map(([Q]) => [Q, "***REDACTED***"]))
}
// @from(Ln 264509, Col 0)
async function Y32(A, Q, B, G) {
  let Z = vA();
  if (b_(G, `Downloading marketplace from ${A}`), k(`Downloading marketplace from URL: ${A}`), B && Object.keys(B).length > 0) k(`Using custom headers: ${eA(s75(B))}`);
  let Y = {
      ...B,
      "User-Agent": "Claude-Code-Plugin-Manager"
    },
    J;
  try {
    J = await xQ.get(A, {
      timeout: 1e4,
      headers: Y
    })
  } catch (D) {
    if (xQ.isAxiosError(D)) {
      if (D.code === "ECONNREFUSED" || D.code === "ENOTFOUND") throw Error(`Could not connect to ${A}. Please check your internet connection and verify the URL is correct.

Technical details: ${D.message}`);
      if (D.code === "ETIMEDOUT") throw Error(`Request timed out while downloading marketplace from ${A}. The server may be slow or unreachable.

Technical details: ${D.message}`);
      if (D.response) throw Error(`HTTP ${D.response.status} error while downloading marketplace from ${A}. The marketplace file may not exist at this URL.

Technical details: ${D.message}`)
    }
    throw Error(`Failed to download marketplace from ${A}: ${D instanceof Error?D.message:String(D)}`)
  }
  b_(G, "Validating marketplace data");
  let X = JVA.safeParse(J.data);
  if (!X.success) throw new Hq(`Invalid marketplace schema from URL: ${X.error.issues.map((D)=>`${D.path.join(".")}: ${D.message}`).join(", ")}`, A, J.data);
  b_(G, "Saving marketplace to cache");
  let I = sC(Q, "..");
  Z.mkdirSync(I), bB(Q, eA(X.data, null, 2), {
    encoding: "utf-8",
    flush: !0
  })
}